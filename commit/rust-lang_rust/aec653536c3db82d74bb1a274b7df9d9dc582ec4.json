{"sha": "aec653536c3db82d74bb1a274b7df9d9dc582ec4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzY1MzUzNmMzZGI4MmQ3NGJiMWEyNzRiN2RmOWQ5ZGM1ODJlYzQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-21T15:29:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-21T15:29:46Z"}, "message": "Rollup merge of #47833 - Aaron1011:final_auto_trait, r=GuillaumeGomez\n\nGenerate documentation for auto-trait impls\n\nA new section is added to both both struct and trait doc pages.\n\nOn struct/enum pages, a new 'Auto Trait Implementations' section displays any synthetic implementations for auto traits. Currently, this is only done for Send and Sync.\n\n![Auto trait implementations for Cloned](https://i.imgur.com/XtTV6IJ.png)\n\nOn trait pages, a new 'Auto Implementors' section displays all types which automatically implement the trait. Effectively, this is a list of all public types in the standard library.\n\n![Auto trait implementors for Send](https://i.imgur.com/3GRBpTy.png)\n\nSynthesized impls for a particular auto trait ('synthetic impls') take generic bounds into account. For example, a type\n```rust\nstruct Foo<T>(T)\n```\n will have 'impl<T> Send for Foo<T> where T: Send' generated for it.\n\nManual implementations of auto traits are also taken into account. If we have\nthe following types:\n\n```rust\nstruct Foo<T>(T)\nstruct Wrapper<T>(Foo<T>)\nunsafe impl<T> Send for Wrapper<T>' // pretend that Wrapper<T> makes this sound somehow\n```\n\nThen Wrapper will have the following impl generated:\n```rust\nimpl<T> Send for Wrapper<T>\n```\nreflecting the fact that 'T: Send' need not hold for 'Wrapper<T>: Send' to hold\n\nLifetimes, HRTBS, and projections (e.g. '<T as Iterator>::Item') are taken into account by synthetic impls:\n\n![A ridiculous demonstration type](https://i.imgur.com/TkZMWuN.png)\n\nHowever, if a type can *never* implement a particular auto trait (e.g. `struct MyStruct<T>(*const T)`), then a negative impl will be generated (in this case, `impl<T> !Send for MyStruct<T>`)\n\nAll of this means that a user should be able to copy-paste a syntheticimpl into their code, without any observable changes in behavior (assuming the rest of the program remains unchanged).", "tree": {"sha": "36cba18c84e1e646e0d12d03c6e07f095c2d7ef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36cba18c84e1e646e0d12d03c6e07f095c2d7ef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec653536c3db82d74bb1a274b7df9d9dc582ec4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJajZBqCRBK7hj4Ov3rIwAAdHIIAIVDvmEeRfxKXy76G+O2Qjzo\nwiC6qgOXs5Y2I+1l5VvlwLiuQZ2lCMwLal2gwfGsX6i8yOXtVL3THTD2oYx35HAN\n//LvZEkdg4/fGt4qRTrYqVwKZm6RGlvNs46cn7CI/0GM7IUwq7kdI5FVj00m6RtE\nursw7KVvnMbQglGfrJZceODZoicaRph2vOOTWw1mATFKueEKB86o2/aLjJsVMa2R\n/qgMQ22g9PPY3PiXZY9IfcOMAQX+MnuPASAMR1b8VJX9vwclkN+PboqZWI/HrjYc\nEkLoAIKplDAwDanS8ORU/LNW0MZ6arZu7aV55Du9EuyEGvjLhP7unz983CzW2IQ=\n=tVdG\n-----END PGP SIGNATURE-----\n", "payload": "tree 36cba18c84e1e646e0d12d03c6e07f095c2d7ef5\nparent 2a32060fb6251b5226da9785f81390151720c6bb\nparent 44d07df1cc5913b108d9207410ede33c38905bec\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1519226986 +0100\ncommitter GitHub <noreply@github.com> 1519226986 +0100\n\nRollup merge of #47833 - Aaron1011:final_auto_trait, r=GuillaumeGomez\n\nGenerate documentation for auto-trait impls\n\nA new section is added to both both struct and trait doc pages.\n\nOn struct/enum pages, a new 'Auto Trait Implementations' section displays any synthetic implementations for auto traits. Currently, this is only done for Send and Sync.\n\n![Auto trait implementations for Cloned](https://i.imgur.com/XtTV6IJ.png)\n\nOn trait pages, a new 'Auto Implementors' section displays all types which automatically implement the trait. Effectively, this is a list of all public types in the standard library.\n\n![Auto trait implementors for Send](https://i.imgur.com/3GRBpTy.png)\n\nSynthesized impls for a particular auto trait ('synthetic impls') take generic bounds into account. For example, a type\n```rust\nstruct Foo<T>(T)\n```\n will have 'impl<T> Send for Foo<T> where T: Send' generated for it.\n\nManual implementations of auto traits are also taken into account. If we have\nthe following types:\n\n```rust\nstruct Foo<T>(T)\nstruct Wrapper<T>(Foo<T>)\nunsafe impl<T> Send for Wrapper<T>' // pretend that Wrapper<T> makes this sound somehow\n```\n\nThen Wrapper will have the following impl generated:\n```rust\nimpl<T> Send for Wrapper<T>\n```\nreflecting the fact that 'T: Send' need not hold for 'Wrapper<T>: Send' to hold\n\nLifetimes, HRTBS, and projections (e.g. '<T as Iterator>::Item') are taken into account by synthetic impls:\n\n![A ridiculous demonstration type](https://i.imgur.com/TkZMWuN.png)\n\nHowever, if a type can *never* implement a particular auto trait (e.g. `struct MyStruct<T>(*const T)`), then a negative impl will be generated (in this case, `impl<T> !Send for MyStruct<T>`)\n\nAll of this means that a user should be able to copy-paste a syntheticimpl into their code, without any observable changes in behavior (assuming the rest of the program remains unchanged).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec653536c3db82d74bb1a274b7df9d9dc582ec4", "html_url": "https://github.com/rust-lang/rust/commit/aec653536c3db82d74bb1a274b7df9d9dc582ec4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec653536c3db82d74bb1a274b7df9d9dc582ec4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a32060fb6251b5226da9785f81390151720c6bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a32060fb6251b5226da9785f81390151720c6bb", "html_url": "https://github.com/rust-lang/rust/commit/2a32060fb6251b5226da9785f81390151720c6bb"}, {"sha": "44d07df1cc5913b108d9207410ede33c38905bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d07df1cc5913b108d9207410ede33c38905bec", "html_url": "https://github.com/rust-lang/rust/commit/44d07df1cc5913b108d9207410ede33c38905bec"}], "stats": {"total": 2648, "additions": 2496, "deletions": 152}, "files": [{"sha": "61a58a6030623077ba7aa011e69072ec7ee2b224", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -72,6 +72,10 @@ impl DefPathTable {\n         index\n     }\n \n+    pub fn next_id(&self, address_space: DefIndexAddressSpace) -> DefIndex {\n+        DefIndex::from_array_index(self.index_to_key[address_space.index()].len(), address_space)\n+    }\n+\n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.index_to_key[index.address_space().index()]"}, {"sha": "7a386c144b73859ed8a68ebfd8604f8a450786ce", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -180,7 +180,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // for each body-id in this map, which will process the\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n-    region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+    pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -1555,11 +1555,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         InferOk { value, obligations }\n     }\n \n-    fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n+    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n         RefMut::map(\n             self.region_constraints.borrow_mut(),\n             |c| c.as_mut().expect(\"region constraints already solved\"))\n     }\n+\n+    /// Clears the selection, evaluation, and projection cachesThis is useful when\n+    /// repeatedly attemping to select an Obligation while changing only\n+    /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n+    pub fn clear_caches(&self) {\n+        self.selection_cache.clear();\n+        self.evaluation_cache.clear();\n+        self.projection_cache.borrow_mut().clear();\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "be196192371fdfc2f913ad50f7876413d4443337", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -82,7 +82,7 @@ pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n /// Describes constraints between the region variables and other\n /// regions, as well as other conditions that must be verified, or\n /// assumptions that can be made.\n-#[derive(Debug, Default)]\n+#[derive(Debug, Default, Clone)]\n pub struct RegionConstraintData<'tcx> {\n     /// Constraints of the form `A <= B`, where either `A` or `B` can\n     /// be a region variable (or neither, as it happens).\n@@ -142,7 +142,7 @@ pub enum Constraint<'tcx> {\n /// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n /// `i`. Inference variables may be involved (but this verification\n /// step doesn't influence inference).\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Verify<'tcx> {\n     pub kind: GenericKind<'tcx>,\n     pub origin: SubregionOrigin<'tcx>,\n@@ -159,7 +159,7 @@ pub enum GenericKind<'tcx> {\n /// When we introduce a verification step, we wish to test that a\n /// particular region (let's call it `'min`) meets some bound.\n /// The bound is described the by the following grammar:\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n     /// B = exists {R} --> some 'r in {R} must outlive 'min\n     ///\n@@ -288,6 +288,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         &self.var_origins\n     }\n \n+    pub fn region_constraint_data(&self) -> &RegionConstraintData<'tcx> {\n+        &self.data\n+    }\n+\n     /// Once all the constraints have been gathered, extract out the final data.\n     ///\n     /// Not legal during a snapshot."}, {"sha": "31836f7e3c57b0e46a3b1f40b90778285372c6bb", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -32,8 +32,8 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n pub use self::fulfill::FulfillmentContext;\n pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{normalize, normalize_projection_type, Normalized};\n-pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n+pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n+pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};"}, {"sha": "0d0476e7c21dd44f8d380cc07c8610ad53db5f09", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -1596,6 +1596,10 @@ impl<'tcx> ProjectionCache<'tcx> {\n         }\n     }\n \n+    pub fn clear(&mut self) {\n+        self.map.clear();\n+    }\n+\n     pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n         ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n     }"}, {"sha": "cfeb456acefe6b8995168ca59e3e99b71a239e29", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -93,6 +93,11 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n \n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n+\n+    /// Controls whether or not to filter out negative impls when selecting.\n+    /// This is used in librustdoc to distinguish between the lack of an impl\n+    /// and a negative impl\n+    allow_negative_impls: bool\n }\n \n #[derive(Clone, Debug)]\n@@ -424,6 +429,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n+            allow_negative_impls: false,\n         }\n     }\n \n@@ -436,6 +442,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n+            allow_negative_impls: false,\n+        }\n+    }\n+\n+    pub fn with_negative(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                         allow_negative_impls: bool) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"with_negative({:?})\", allow_negative_impls);\n+        SelectionContext {\n+            infcx,\n+            freshener: infcx.freshener(),\n+            intercrate: None,\n+            inferred_obligations: SnapshotVec::new(),\n+            intercrate_ambiguity_causes: None,\n+            allow_negative_impls,\n         }\n     }\n \n@@ -1086,7 +1106,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if self.tcx().impl_polarity(def_id) == hir::ImplPolarity::Negative {\n+            if !self.allow_negative_impls &&\n+                self.tcx().impl_polarity(def_id) == hir::ImplPolarity::Negative {\n                 return Err(Unimplemented)\n             }\n         }\n@@ -3337,6 +3358,10 @@ impl<'tcx> SelectionCache<'tcx> {\n             hashmap: RefCell::new(FxHashMap())\n         }\n     }\n+\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = FxHashMap()\n+    }\n }\n \n impl<'tcx> EvaluationCache<'tcx> {\n@@ -3345,6 +3370,10 @@ impl<'tcx> EvaluationCache<'tcx> {\n             hashmap: RefCell::new(FxHashMap())\n         }\n     }\n+\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = FxHashMap()\n+    }\n }\n \n impl<'o,'tcx> TraitObligationStack<'o,'tcx> {"}, {"sha": "cede6f147821bf8e3c2e49c72e0068229a9e5fc1", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -45,6 +45,11 @@ impl<K, V> SnapshotMap<K, V>\n         }\n     }\n \n+    pub fn clear(&mut self) {\n+        self.map.clear();\n+        self.undo_log.clear();\n+    }\n+\n     pub fn insert(&mut self, key: K, value: V) -> bool {\n         match self.map.insert(key.clone(), value) {\n             None => {"}, {"sha": "f1bba0e836189ff4383b2f20223c69e619705f6e", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "added", "additions": 1492, "deletions": 0, "changes": 1492, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,1492 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TypeFoldable;\n+\n+use super::*;\n+\n+pub struct AutoTraitFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n+    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+}\n+\n+impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n+    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n+        let ty = self.cx.tcx.type_of(def_id);\n+\n+        let def_ctor: fn(DefId) -> Def = match ty.sty {\n+            ty::TyAdt(adt, _) => match adt.adt_kind() {\n+                AdtKind::Struct => Def::Struct,\n+                AdtKind::Enum => Def::Enum,\n+                AdtKind::Union => Def::Union,\n+            },\n+            _ => panic!(\"Unexpected type {:?}\", def_id),\n+        };\n+\n+        self.get_auto_trait_impls(def_id, def_ctor, None)\n+    }\n+\n+    pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n+        let item = &self.cx.tcx.hir.expect_item(id).node;\n+        let did = self.cx.tcx.hir.local_def_id(id);\n+\n+        let def_ctor = match *item {\n+            hir::ItemStruct(_, _) => Def::Struct,\n+            hir::ItemUnion(_, _) => Def::Union,\n+            hir::ItemEnum(_, _) => Def::Enum,\n+            _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n+        };\n+\n+        self.get_auto_trait_impls(did, def_ctor, Some(name))\n+    }\n+\n+    pub fn get_auto_trait_impls(\n+        &self,\n+        def_id: DefId,\n+        def_ctor: fn(DefId) -> Def,\n+        name: Option<String>,\n+    ) -> Vec<Item> {\n+        if self.cx\n+            .tcx\n+            .get_attrs(def_id)\n+            .lists(\"doc\")\n+            .has_word(\"hidden\")\n+        {\n+            debug!(\n+                \"get_auto_trait_impls(def_id={:?}, def_ctor={:?}): item has doc('hidden'), \\\n+                 aborting\",\n+                def_id, def_ctor\n+            );\n+            return Vec::new();\n+        }\n+\n+        let tcx = self.cx.tcx;\n+        let generics = self.cx.tcx.generics_of(def_id);\n+\n+        debug!(\n+            \"get_auto_trait_impls(def_id={:?}, def_ctor={:?}, generics={:?}\",\n+            def_id, def_ctor, generics\n+        );\n+        let auto_traits: Vec<_> = self.cx\n+            .send_trait\n+            .and_then(|send_trait| {\n+                self.get_auto_trait_impl_for(\n+                    def_id,\n+                    name.clone(),\n+                    generics.clone(),\n+                    def_ctor,\n+                    send_trait,\n+                )\n+            })\n+            .into_iter()\n+            .chain(self.get_auto_trait_impl_for(\n+                def_id,\n+                name.clone(),\n+                generics.clone(),\n+                def_ctor,\n+                tcx.require_lang_item(lang_items::SyncTraitLangItem),\n+            ).into_iter())\n+            .collect();\n+\n+        debug!(\n+            \"get_auto_traits: type {:?} auto_traits {:?}\",\n+            def_id, auto_traits\n+        );\n+        auto_traits\n+    }\n+\n+    fn get_auto_trait_impl_for(\n+        &self,\n+        def_id: DefId,\n+        name: Option<String>,\n+        generics: ty::Generics,\n+        def_ctor: fn(DefId) -> Def,\n+        trait_def_id: DefId,\n+    ) -> Option<Item> {\n+        if !self.cx\n+            .generated_synthetics\n+            .borrow_mut()\n+            .insert((def_id, trait_def_id))\n+        {\n+            debug!(\n+                \"get_auto_trait_impl_for(def_id={:?}, generics={:?}, def_ctor={:?}, \\\n+                 trait_def_id={:?}): already generated, aborting\",\n+                def_id, generics, def_ctor, trait_def_id\n+            );\n+            return None;\n+        }\n+\n+        let result = self.find_auto_trait_generics(def_id, trait_def_id, &generics);\n+\n+        if result.is_auto() {\n+            let trait_ = hir::TraitRef {\n+                path: get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait),\n+                ref_id: ast::DUMMY_NODE_ID,\n+            };\n+\n+            let polarity;\n+\n+            let new_generics = match result {\n+                AutoTraitResult::PositiveImpl(new_generics) => {\n+                    polarity = None;\n+                    new_generics\n+                }\n+                AutoTraitResult::NegativeImpl => {\n+                    polarity = Some(ImplPolarity::Negative);\n+\n+                    // For negative impls, we use the generic params, but *not* the predicates,\n+                    // from the original type. Otherwise, the displayed impl appears to be a\n+                    // conditional negative impl, when it's really unconditional.\n+                    //\n+                    // For example, consider the struct Foo<T: Copy>(*mut T). Using\n+                    // the original predicates in our impl would cause us to generate\n+                    // `impl !Send for Foo<T: Copy>`, which makes it appear that Foo\n+                    // implements Send where T is not copy.\n+                    //\n+                    // Instead, we generate `impl !Send for Foo<T>`, which better\n+                    // expresses the fact that `Foo<T>` never implements `Send`,\n+                    // regardless of the choice of `T`.\n+                    let real_generics = (&generics, &Default::default());\n+\n+                    // Clean the generics, but ignore the '?Sized' bounds generated\n+                    // by the `Clean` impl\n+                    let clean_generics = real_generics.clean(self.cx);\n+\n+                    Generics {\n+                        params: clean_generics.params,\n+                        where_predicates: Vec::new(),\n+                    }\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let path = get_path_for_type(self.cx.tcx, def_id, def_ctor);\n+            let mut segments = path.segments.into_vec();\n+            let last = segments.pop().unwrap();\n+\n+            let real_name = name.as_ref().map(|n| Symbol::from(n.as_str()));\n+\n+            segments.push(hir::PathSegment::new(\n+                real_name.unwrap_or(last.name),\n+                self.generics_to_path_params(generics.clone()),\n+                false,\n+            ));\n+\n+            let new_path = hir::Path {\n+                span: path.span,\n+                def: path.def,\n+                segments: HirVec::from_vec(segments),\n+            };\n+\n+            let ty = hir::Ty {\n+                id: ast::DUMMY_NODE_ID,\n+                node: hir::Ty_::TyPath(hir::QPath::Resolved(None, P(new_path))),\n+                span: DUMMY_SP,\n+                hir_id: hir::DUMMY_HIR_ID,\n+            };\n+\n+            return Some(Item {\n+                source: Span::empty(),\n+                name: None,\n+                attrs: Default::default(),\n+                visibility: None,\n+                def_id: self.next_def_id(def_id.krate),\n+                stability: None,\n+                deprecation: None,\n+                inner: ImplItem(Impl {\n+                    unsafety: hir::Unsafety::Normal,\n+                    generics: new_generics,\n+                    provided_trait_methods: FxHashSet(),\n+                    trait_: Some(trait_.clean(self.cx)),\n+                    for_: ty.clean(self.cx),\n+                    items: Vec::new(),\n+                    polarity,\n+                    synthetic: true,\n+                }),\n+            });\n+        }\n+        None\n+    }\n+\n+    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n+        let lifetimes = HirVec::from_vec(\n+            generics\n+                .regions\n+                .iter()\n+                .map(|p| {\n+                    let name = if p.name == \"\" {\n+                        hir::LifetimeName::Static\n+                    } else {\n+                        hir::LifetimeName::Name(p.name)\n+                    };\n+\n+                    hir::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        name,\n+                    }\n+                })\n+                .collect(),\n+        );\n+        let types = HirVec::from_vec(\n+            generics\n+                .types\n+                .iter()\n+                .map(|p| P(self.ty_param_to_ty(p.clone())))\n+                .collect(),\n+        );\n+\n+        hir::PathParameters {\n+            lifetimes: lifetimes,\n+            types: types,\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n+\n+    fn ty_param_to_ty(&self, param: ty::TypeParameterDef) -> hir::Ty {\n+        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::Ty_::TyPath(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: DUMMY_SP,\n+                    def: Def::TyParam(param.def_id),\n+                    segments: HirVec::from_vec(vec![hir::PathSegment::from_name(param.name)]),\n+                }),\n+            )),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n+\n+    fn find_auto_trait_generics(\n+        &self,\n+        did: DefId,\n+        trait_did: DefId,\n+        generics: &ty::Generics,\n+    ) -> AutoTraitResult {\n+        let tcx = self.cx.tcx;\n+        let ty = self.cx.tcx.type_of(did);\n+\n+        let orig_params = tcx.param_env(did);\n+\n+        let trait_ref = ty::TraitRef {\n+            def_id: trait_did,\n+            substs: tcx.mk_substs_trait(ty, &[]),\n+        };\n+\n+        let trait_pred = ty::Binder(trait_ref);\n+\n+        let bail_out = tcx.infer_ctxt().enter(|infcx| {\n+            let mut selcx = SelectionContext::with_negative(&infcx, true);\n+            let result = selcx.select(&Obligation::new(\n+                ObligationCause::dummy(),\n+                orig_params,\n+                trait_pred.to_poly_trait_predicate(),\n+            ));\n+            match result {\n+                Ok(Some(Vtable::VtableImpl(_))) => {\n+                    debug!(\n+                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n+                         manual impl found, bailing out\",\n+                        did, trait_did, generics\n+                    );\n+                    return true;\n+                }\n+                _ => return false,\n+            };\n+        });\n+\n+        // If an explicit impl exists, it always takes priority over an auto impl\n+        if bail_out {\n+            return AutoTraitResult::ExplicitImpl;\n+        }\n+\n+        return tcx.infer_ctxt().enter(|mut infcx| {\n+            let mut fresh_preds = FxHashSet();\n+\n+            // Due to the way projections are handled by SelectionContext, we need to run\n+            // evaluate_predicates twice: once on the original param env, and once on the result of\n+            // the first evaluate_predicates call.\n+            //\n+            // The problem is this: most of rustc, including SelectionContext and traits::project,\n+            // are designed to work with a concrete usage of a type (e.g. Vec<u8>\n+            // fn<T>() { Vec<T> }. This information will generally never change - given\n+            // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n+            // If we're unable to prove that 'T' implements a particular trait, we're done -\n+            // there's nothing left to do but error out.\n+            //\n+            // However, synthesizing an auto trait impl works differently. Here, we start out with\n+            // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n+            // with - and progressively discover the conditions we need to fulfill for it to\n+            // implement a certain auto trait. This ends up breaking two assumptions made by trait\n+            // selection and projection:\n+            //\n+            // * We can always cache the result of a particular trait selection for the lifetime of\n+            // an InfCtxt\n+            // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n+            // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n+            //\n+            // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n+            // in between calls to SelectionContext.select. This allows us to keep all of the\n+            // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n+            // them between calls.\n+            //\n+            // We fix the second assumption by reprocessing the result of our first call to\n+            // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n+            // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n+            // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n+            // SelectionContext to return it back to us.\n+\n+            let (new_env, user_env) = match self.evaluate_predicates(\n+                &mut infcx,\n+                did,\n+                trait_did,\n+                ty,\n+                orig_params.clone(),\n+                orig_params,\n+                &mut fresh_preds,\n+                false,\n+            ) {\n+                Some(e) => e,\n+                None => return AutoTraitResult::NegativeImpl,\n+            };\n+\n+            let (full_env, full_user_env) = self.evaluate_predicates(\n+                &mut infcx,\n+                did,\n+                trait_did,\n+                ty,\n+                new_env.clone(),\n+                user_env,\n+                &mut fresh_preds,\n+                true,\n+            ).unwrap_or_else(|| {\n+                panic!(\n+                    \"Failed to fully process: {:?} {:?} {:?}\",\n+                    ty, trait_did, orig_params\n+                )\n+            });\n+\n+            debug!(\n+                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n+                 with {:?}\",\n+                did, trait_did, generics, full_env\n+            );\n+            infcx.clear_caches();\n+\n+            // At this point, we already have all of the bounds we need. FulfillmentContext is used\n+            // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n+            // an additional sanity check.\n+            let mut fulfill = FulfillmentContext::new();\n+            fulfill.register_bound(\n+                &infcx,\n+                full_env,\n+                ty,\n+                trait_did,\n+                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+            );\n+            fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n+                panic!(\n+                    \"Unable to fulfill trait {:?} for '{:?}': {:?}\",\n+                    trait_did, ty, e\n+                )\n+            });\n+\n+            let names_map: FxHashMap<String, Lifetime> = generics\n+                .regions\n+                .iter()\n+                .map(|l| (l.name.as_str().to_string(), l.clean(self.cx)))\n+                .collect();\n+\n+            let body_ids: FxHashSet<_> = infcx\n+                .region_obligations\n+                .borrow()\n+                .iter()\n+                .map(|&(id, _)| id)\n+                .collect();\n+\n+            for id in body_ids {\n+                infcx.process_registered_region_obligations(&[], None, full_env.clone(), id);\n+            }\n+\n+            let region_data = infcx\n+                .borrow_region_constraints()\n+                .region_constraint_data()\n+                .clone();\n+\n+            let lifetime_predicates = self.handle_lifetimes(&region_data, &names_map);\n+            let vid_to_region = self.map_vid_to_region(&region_data);\n+\n+            debug!(\n+                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): computed \\\n+                 lifetime information '{:?}' '{:?}'\",\n+                did, trait_did, generics, lifetime_predicates, vid_to_region\n+            );\n+\n+            let new_generics = self.param_env_to_generics(\n+                infcx.tcx,\n+                did,\n+                full_user_env,\n+                generics.clone(),\n+                lifetime_predicates,\n+                vid_to_region,\n+            );\n+            debug!(\n+                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): finished with \\\n+                 {:?}\",\n+                did, trait_did, generics, new_generics\n+            );\n+            return AutoTraitResult::PositiveImpl(new_generics);\n+        });\n+    }\n+\n+    fn clean_pred<'c, 'd, 'cx>(\n+        &self,\n+        infcx: &InferCtxt<'c, 'd, 'cx>,\n+        p: ty::Predicate<'cx>,\n+    ) -> ty::Predicate<'cx> {\n+        infcx.freshen(p)\n+    }\n+\n+    fn evaluate_nested_obligations<'b, 'c, 'd, 'cx,\n+                                    T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>>(\n+        &self,\n+        ty: ty::Ty,\n+        nested: T,\n+        computed_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n+        fresh_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n+        predicates: &'b mut VecDeque<ty::PolyTraitPredicate<'cx>>,\n+        select: &mut traits::SelectionContext<'c, 'd, 'cx>,\n+        only_projections: bool,\n+    ) -> bool {\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+\n+        for (obligation, predicate) in nested\n+            .filter(|o| o.recursion_depth == 1)\n+            .map(|o| (o.clone(), o.predicate.clone()))\n+        {\n+            let is_new_pred =\n+                fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n+\n+            match &predicate {\n+                &ty::Predicate::Trait(ref p) => {\n+                    let substs = &p.skip_binder().trait_ref.substs;\n+\n+                    if self.is_of_param(substs) && !only_projections && is_new_pred {\n+                        computed_preds.insert(predicate);\n+                    }\n+                    predicates.push_back(p.clone());\n+                }\n+                &ty::Predicate::Projection(p) => {\n+                    // If the projection isn't all type vars, then\n+                    // we don't want to add it as a bound\n+                    if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n+                        computed_preds.insert(predicate);\n+                    } else {\n+                        match traits::poly_project_and_unify_type(\n+                            select,\n+                            &obligation.with(p.clone()),\n+                        ) {\n+                            Err(e) => {\n+                                debug!(\n+                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n+                                     '{:?}' '{:?}', bailing out\",\n+                                    ty, e\n+                                );\n+                                return false;\n+                            }\n+                            Ok(Some(v)) => {\n+                                if !self.evaluate_nested_obligations(\n+                                    ty,\n+                                    v.clone().iter().cloned(),\n+                                    computed_preds,\n+                                    fresh_preds,\n+                                    predicates,\n+                                    select,\n+                                    only_projections,\n+                                ) {\n+                                    return false;\n+                                }\n+                            }\n+                            Ok(None) => {\n+                                panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n+                            }\n+                        }\n+                    }\n+                }\n+                &ty::Predicate::RegionOutlives(ref binder) => {\n+                    if let Err(_) = select\n+                        .infcx()\n+                        .region_outlives_predicate(&dummy_cause, binder)\n+                    {\n+                        return false;\n+                    }\n+                }\n+                &ty::Predicate::TypeOutlives(ref binder) => {\n+                    match (\n+                        binder.no_late_bound_regions(),\n+                        binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n+                    ) {\n+                        (None, Some(t_a)) => {\n+                            select.infcx().register_region_obligation(\n+                                ast::DUMMY_NODE_ID,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: select.infcx().tcx.types.re_static,\n+                                    cause: dummy_cause.clone(),\n+                                },\n+                            );\n+                        }\n+                        (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n+                            select.infcx().register_region_obligation(\n+                                ast::DUMMY_NODE_ID,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_b,\n+                                    cause: dummy_cause.clone(),\n+                                },\n+                            );\n+                        }\n+                        _ => {}\n+                    };\n+                }\n+                _ => panic!(\"Unexpected predicate {:?} {:?}\", ty, predicate),\n+            };\n+        }\n+        return true;\n+    }\n+\n+    // The core logic responsible for computing the bounds for our synthesized impl.\n+    //\n+    // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n+    // we recursively select the nested obligations of predicates we encounter. However, whenver we\n+    // encounter an UnimplementedError involving a type parameter, we add it to our ParamEnv. Since\n+    // our goal is to determine when a particular type implements an auto trait, Unimplemented\n+    // errors tell us what conditions need to be met.\n+    //\n+    // This method ends up working somewhat similary to FulfillmentContext, but with a few key\n+    // differences. FulfillmentContext works under the assumption that it's dealing with concrete\n+    // user code. According, it considers all possible ways that a Predicate could be met - which\n+    // isn't always what we want for a synthesized impl. For example, given the predicate 'T:\n+    // Iterator', FulfillmentContext can end up reporting an Unimplemented error for T:\n+    // IntoIterator - since there's an implementation of Iteratpr where T: IntoIterator,\n+    // FulfillmentContext will drive SelectionContext to consider that impl before giving up. If we\n+    // were to rely on FulfillmentContext's decision, we might end up synthesizing an impl like\n+    // this:\n+    // 'impl<T> Send for Foo<T> where T: IntoIterator'\n+    //\n+    // While it might be technically true that Foo implements Send where T: IntoIterator,\n+    // the bound is overly restrictive - it's really only necessary that T: Iterator.\n+    //\n+    // For this reason, evaluate_predicates handles predicates with type variables specially. When\n+    // we encounter an Unimplemented error for a bound such as 'T: Iterator', we immediately add it\n+    // to our ParamEnv, and add it to our stack for recursive evaluation. When we later select it,\n+    // we'll pick up any nested bounds, without ever inferring that 'T: IntoIterator' needs to\n+    // hold.\n+    //\n+    // One additonal consideration is supertrait bounds. Normally, a ParamEnv is only ever\n+    // consutrcted once for a given type. As part of the construction process, the ParamEnv will\n+    // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n+    // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n+    // own ParamEnv, we need to do this outselves, through traits::elaborate_predicates, or else\n+    // SelectionContext will choke on the missing predicates. However, this should never show up in\n+    // the final synthesized generics: we don't want our generated docs page to contain something\n+    // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n+    // 'user_env', which only holds the predicates that will actually be displayed to the user.\n+    fn evaluate_predicates<'b, 'gcx, 'c>(\n+        &self,\n+        infcx: &mut InferCtxt<'b, 'tcx, 'c>,\n+        ty_did: DefId,\n+        trait_did: DefId,\n+        ty: ty::Ty<'c>,\n+        param_env: ty::ParamEnv<'c>,\n+        user_env: ty::ParamEnv<'c>,\n+        fresh_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+        only_projections: bool,\n+    ) -> Option<(ty::ParamEnv<'c>, ty::ParamEnv<'c>)> {\n+        let tcx = infcx.tcx;\n+\n+        let mut select = traits::SelectionContext::new(&infcx);\n+\n+        let mut already_visited = FxHashSet();\n+        let mut predicates = VecDeque::new();\n+        predicates.push_back(ty::Binder(ty::TraitPredicate {\n+            trait_ref: ty::TraitRef {\n+                def_id: trait_did,\n+                substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+            },\n+        }));\n+\n+        let mut computed_preds: FxHashSet<_> = param_env.caller_bounds.iter().cloned().collect();\n+        let mut user_computed_preds: FxHashSet<_> =\n+            user_env.caller_bounds.iter().cloned().collect();\n+\n+        let mut new_env = param_env.clone();\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+\n+        while let Some(pred) = predicates.pop_front() {\n+            infcx.clear_caches();\n+\n+            if !already_visited.insert(pred.clone()) {\n+                continue;\n+            }\n+\n+            let result = select.select(&Obligation::new(dummy_cause.clone(), new_env, pred));\n+\n+            match &result {\n+                &Ok(Some(ref vtable)) => {\n+                    let obligations = vtable.clone().nested_obligations().into_iter();\n+\n+                    if !self.evaluate_nested_obligations(\n+                        ty,\n+                        obligations,\n+                        &mut user_computed_preds,\n+                        fresh_preds,\n+                        &mut predicates,\n+                        &mut select,\n+                        only_projections,\n+                    ) {\n+                        return None;\n+                    }\n+                }\n+                &Ok(None) => {}\n+                &Err(SelectionError::Unimplemented) => {\n+                    if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n+                        already_visited.remove(&pred);\n+                        user_computed_preds.insert(ty::Predicate::Trait(pred.clone()));\n+                        predicates.push_back(pred);\n+                    } else {\n+                        debug!(\n+                            \"evaluate_nested_obligations: Unimplemented found, bailing: {:?} {:?} \\\n+                             {:?}\",\n+                            ty,\n+                            pred,\n+                            pred.skip_binder().trait_ref.substs\n+                        );\n+                        return None;\n+                    }\n+                }\n+                _ => panic!(\"Unexpected error for '{:?}': {:?}\", ty, result),\n+            };\n+\n+            computed_preds.extend(user_computed_preds.iter().cloned());\n+            let normalized_preds =\n+                traits::elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n+            new_env = ty::ParamEnv::new(tcx.mk_predicates(normalized_preds), param_env.reveal);\n+        }\n+\n+        let final_user_env = ty::ParamEnv::new(\n+            tcx.mk_predicates(user_computed_preds.into_iter()),\n+            user_env.reveal,\n+        );\n+        debug!(\n+            \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n+             '{:?}'\",\n+            ty_did, trait_did, new_env, final_user_env\n+        );\n+\n+        return Some((new_env, final_user_env));\n+    }\n+\n+    fn is_of_param(&self, substs: &Substs) -> bool {\n+        if substs.is_noop() {\n+            return false;\n+        }\n+\n+        return match substs.type_at(0).sty {\n+            ty::TyParam(_) => true,\n+            ty::TyProjection(p) => self.is_of_param(p.substs),\n+            _ => false,\n+        };\n+    }\n+\n+    fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, Lifetime>) -> Lifetime {\n+        self.region_name(region)\n+            .map(|name| {\n+                names_map.get(&name).unwrap_or_else(|| {\n+                    panic!(\"Missing lifetime with name {:?} for {:?}\", name, region)\n+                })\n+            })\n+            .unwrap_or(&Lifetime::statik())\n+            .clone()\n+    }\n+\n+    fn region_name(&self, region: Region) -> Option<String> {\n+        match region {\n+            &ty::ReEarlyBound(r) => Some(r.name.as_str().to_string()),\n+            _ => None,\n+        }\n+    }\n+\n+    // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n+    // to each other, we match ty::RegionVid's to ty::Region's\n+    fn map_vid_to_region<'cx>(\n+        &self,\n+        regions: &RegionConstraintData<'cx>,\n+    ) -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n+        let mut vid_map: FxHashMap<RegionTarget<'cx>, RegionDeps<'cx>> = FxHashMap();\n+        let mut finished_map = FxHashMap();\n+\n+        for constraint in regions.constraints.keys() {\n+            match constraint {\n+                &Constraint::VarSubVar(r1, r2) => {\n+                    {\n+                        let deps1 = vid_map\n+                            .entry(RegionTarget::RegionVid(r1))\n+                            .or_insert_with(|| Default::default());\n+                        deps1.larger.insert(RegionTarget::RegionVid(r2));\n+                    }\n+\n+                    let deps2 = vid_map\n+                        .entry(RegionTarget::RegionVid(r2))\n+                        .or_insert_with(|| Default::default());\n+                    deps2.smaller.insert(RegionTarget::RegionVid(r1));\n+                }\n+                &Constraint::RegSubVar(region, vid) => {\n+                    {\n+                        let deps1 = vid_map\n+                            .entry(RegionTarget::Region(region))\n+                            .or_insert_with(|| Default::default());\n+                        deps1.larger.insert(RegionTarget::RegionVid(vid));\n+                    }\n+\n+                    let deps2 = vid_map\n+                        .entry(RegionTarget::RegionVid(vid))\n+                        .or_insert_with(|| Default::default());\n+                    deps2.smaller.insert(RegionTarget::Region(region));\n+                }\n+                &Constraint::VarSubReg(vid, region) => {\n+                    finished_map.insert(vid, region);\n+                }\n+                &Constraint::RegSubReg(r1, r2) => {\n+                    {\n+                        let deps1 = vid_map\n+                            .entry(RegionTarget::Region(r1))\n+                            .or_insert_with(|| Default::default());\n+                        deps1.larger.insert(RegionTarget::Region(r2));\n+                    }\n+\n+                    let deps2 = vid_map\n+                        .entry(RegionTarget::Region(r2))\n+                        .or_insert_with(|| Default::default());\n+                    deps2.smaller.insert(RegionTarget::Region(r1));\n+                }\n+            }\n+        }\n+\n+        while !vid_map.is_empty() {\n+            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n+            let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n+\n+            for smaller in deps.smaller.iter() {\n+                for larger in deps.larger.iter() {\n+                    match (smaller, larger) {\n+                        (&RegionTarget::Region(_), &RegionTarget::Region(_)) => {\n+                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n+                                let smaller_deps = v.into_mut();\n+                                smaller_deps.larger.insert(*larger);\n+                                smaller_deps.larger.remove(&target);\n+                            }\n+\n+                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n+                                let larger_deps = v.into_mut();\n+                                larger_deps.smaller.insert(*smaller);\n+                                larger_deps.smaller.remove(&target);\n+                            }\n+                        }\n+                        (&RegionTarget::RegionVid(v1), &RegionTarget::Region(r1)) => {\n+                            finished_map.insert(v1, r1);\n+                        }\n+                        (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {\n+                            // Do nothing - we don't care about regions that are smaller than vids\n+                        }\n+                        (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {\n+                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n+                                let smaller_deps = v.into_mut();\n+                                smaller_deps.larger.insert(*larger);\n+                                smaller_deps.larger.remove(&target);\n+                            }\n+\n+                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n+                                let larger_deps = v.into_mut();\n+                                larger_deps.smaller.insert(*smaller);\n+                                larger_deps.smaller.remove(&target);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        finished_map\n+    }\n+\n+    // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n+    // and region constraints of the form ReVar: 'a\n+    //\n+    // This is essentially a simplified version of lexical_region_resolve. However,\n+    // handle_lifetimes determines what *needs be* true in order for an impl to hold.\n+    // lexical_region_resolve, along with much of the rest of the compiler, is concerned\n+    // with determining if a given set up constraints/predicates *are* met, given some\n+    // starting conditions (e.g. user-provided code). For this reason, it's easier\n+    // to perform the calculations we need on our own, rather than trying to make\n+    // existing inference/solver code do what we want.\n+    fn handle_lifetimes<'cx>(\n+        &self,\n+        regions: &RegionConstraintData<'cx>,\n+        names_map: &FxHashMap<String, Lifetime>,\n+    ) -> Vec<WherePredicate> {\n+        // Our goal is to 'flatten' the list of constraints by eliminating\n+        // all intermediate RegionVids. At the end, all constraints should\n+        // be between Regions (aka region variables). This gives us the information\n+        // we need to create the Generics.\n+        let mut finished = FxHashMap();\n+\n+        let mut vid_map: FxHashMap<RegionTarget, RegionDeps> = FxHashMap();\n+\n+        // Flattening is done in two parts. First, we insert all of the constraints\n+        // into a map. Each RegionTarget (either a RegionVid or a Region) maps\n+        // to its smaller and larger regions. Note that 'larger' regions correspond\n+        // to sub-regions in Rust code (e.g. in 'a: 'b, 'a is the larger region).\n+        for constraint in regions.constraints.keys() {\n+            match constraint {\n+                &Constraint::VarSubVar(r1, r2) => {\n+                    {\n+                        let deps1 = vid_map\n+                            .entry(RegionTarget::RegionVid(r1))\n+                            .or_insert_with(|| Default::default());\n+                        deps1.larger.insert(RegionTarget::RegionVid(r2));\n+                    }\n+\n+                    let deps2 = vid_map\n+                        .entry(RegionTarget::RegionVid(r2))\n+                        .or_insert_with(|| Default::default());\n+                    deps2.smaller.insert(RegionTarget::RegionVid(r1));\n+                }\n+                &Constraint::RegSubVar(region, vid) => {\n+                    let deps = vid_map\n+                        .entry(RegionTarget::RegionVid(vid))\n+                        .or_insert_with(|| Default::default());\n+                    deps.smaller.insert(RegionTarget::Region(region));\n+                }\n+                &Constraint::VarSubReg(vid, region) => {\n+                    let deps = vid_map\n+                        .entry(RegionTarget::RegionVid(vid))\n+                        .or_insert_with(|| Default::default());\n+                    deps.larger.insert(RegionTarget::Region(region));\n+                }\n+                &Constraint::RegSubReg(r1, r2) => {\n+                    // The constraint is already in the form that we want, so we're done with it\n+                    // Desired order is 'larger, smaller', so flip then\n+                    if self.region_name(r1) != self.region_name(r2) {\n+                        finished\n+                            .entry(self.region_name(r2).unwrap())\n+                            .or_insert_with(|| Vec::new())\n+                            .push(r1);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Here, we 'flatten' the map one element at a time.\n+        // All of the element's sub and super regions are connected\n+        // to each other. For example, if we have a graph that looks like this:\n+        //\n+        // (A, B) - C - (D, E)\n+        // Where (A, B) are subregions, and (D,E) are super-regions\n+        //\n+        // then after deleting 'C', the graph will look like this:\n+        //  ... - A - (D, E ...)\n+        //  ... - B - (D, E, ...)\n+        //  (A, B, ...) - D - ...\n+        //  (A, B, ...) - E - ...\n+        //\n+        //  where '...' signifies the existing sub and super regions of an entry\n+        //  When two adjacent ty::Regions are encountered, we've computed a final\n+        //  constraint, and add it to our list. Since we make sure to never re-add\n+        //  deleted items, this process will always finish.\n+        while !vid_map.is_empty() {\n+            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n+            let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n+\n+            for smaller in deps.smaller.iter() {\n+                for larger in deps.larger.iter() {\n+                    match (smaller, larger) {\n+                        (&RegionTarget::Region(r1), &RegionTarget::Region(r2)) => {\n+                            if self.region_name(r1) != self.region_name(r2) {\n+                                finished\n+                                    .entry(self.region_name(r2).unwrap())\n+                                    .or_insert_with(|| Vec::new())\n+                                    .push(r1) // Larger, smaller\n+                            }\n+                        }\n+                        (&RegionTarget::RegionVid(_), &RegionTarget::Region(_)) => {\n+                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n+                                let smaller_deps = v.into_mut();\n+                                smaller_deps.larger.insert(*larger);\n+                                smaller_deps.larger.remove(&target);\n+                            }\n+                        }\n+                        (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {\n+                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n+                                let deps = v.into_mut();\n+                                deps.smaller.insert(*smaller);\n+                                deps.smaller.remove(&target);\n+                            }\n+                        }\n+                        (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {\n+                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n+                                let smaller_deps = v.into_mut();\n+                                smaller_deps.larger.insert(*larger);\n+                                smaller_deps.larger.remove(&target);\n+                            }\n+\n+                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n+                                let larger_deps = v.into_mut();\n+                                larger_deps.smaller.insert(*smaller);\n+                                larger_deps.smaller.remove(&target);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let lifetime_predicates = names_map\n+            .iter()\n+            .flat_map(|(name, lifetime)| {\n+                let empty = Vec::new();\n+                let bounds: FxHashSet<Lifetime> = finished\n+                    .get(name)\n+                    .unwrap_or(&empty)\n+                    .iter()\n+                    .map(|region| self.get_lifetime(region, names_map))\n+                    .collect();\n+\n+                if bounds.is_empty() {\n+                    return None;\n+                }\n+                Some(WherePredicate::RegionPredicate {\n+                    lifetime: lifetime.clone(),\n+                    bounds: bounds.into_iter().collect(),\n+                })\n+            })\n+            .collect();\n+\n+        lifetime_predicates\n+    }\n+\n+    fn extract_for_generics<'b, 'c, 'd>(\n+        &self,\n+        tcx: TyCtxt<'b, 'c, 'd>,\n+        pred: ty::Predicate<'d>,\n+    ) -> FxHashSet<GenericParam> {\n+        pred.walk_tys()\n+            .flat_map(|t| {\n+                let mut regions = FxHashSet();\n+                tcx.collect_regions(&t, &mut regions);\n+\n+                regions.into_iter().flat_map(|r| {\n+                    match r {\n+                        // We only care about late bound regions, as we need to add them\n+                        // to the 'for<>' section\n+                        &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n+                            Some(GenericParam::Lifetime(Lifetime(name.as_str().to_string())))\n+                        }\n+                        &ty::ReVar(_) | &ty::ReEarlyBound(_) => None,\n+                        _ => panic!(\"Unexpected region type {:?}\", r),\n+                    }\n+                })\n+            })\n+            .collect()\n+    }\n+\n+    fn make_final_bounds<'b, 'c, 'cx>(\n+        &self,\n+        ty_to_bounds: FxHashMap<Type, FxHashSet<TyParamBound>>,\n+        ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)>,\n+        lifetime_to_bounds: FxHashMap<Lifetime, FxHashSet<Lifetime>>,\n+    ) -> Vec<WherePredicate> {\n+        ty_to_bounds\n+            .into_iter()\n+            .flat_map(|(ty, mut bounds)| {\n+                if let Some(data) = ty_to_fn.get(&ty) {\n+                    let (poly_trait, output) =\n+                        (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned());\n+                    let new_ty = match &poly_trait.trait_ {\n+                        &Type::ResolvedPath {\n+                            ref path,\n+                            ref typarams,\n+                            ref did,\n+                            ref is_generic,\n+                        } => {\n+                            let mut new_path = path.clone();\n+                            let last_segment = new_path.segments.pop().unwrap();\n+\n+                            let (old_input, old_output) = match last_segment.params {\n+                                PathParameters::AngleBracketed { types, .. } => (types, None),\n+                                PathParameters::Parenthesized { inputs, output, .. } => {\n+                                    (inputs, output)\n+                                }\n+                            };\n+\n+                            if old_output.is_some() && old_output != output {\n+                                panic!(\n+                                    \"Output mismatch for {:?} {:?} {:?}\",\n+                                    ty, old_output, data.1\n+                                );\n+                            }\n+\n+                            let new_params = PathParameters::Parenthesized {\n+                                inputs: old_input,\n+                                output,\n+                            };\n+\n+                            new_path.segments.push(PathSegment {\n+                                name: last_segment.name,\n+                                params: new_params,\n+                            });\n+\n+                            Type::ResolvedPath {\n+                                path: new_path,\n+                                typarams: typarams.clone(),\n+                                did: did.clone(),\n+                                is_generic: *is_generic,\n+                            }\n+                        }\n+                        _ => panic!(\"Unexpected data: {:?}, {:?}\", ty, data),\n+                    };\n+                    bounds.insert(TyParamBound::TraitBound(\n+                        PolyTrait {\n+                            trait_: new_ty,\n+                            generic_params: poly_trait.generic_params,\n+                        },\n+                        hir::TraitBoundModifier::None,\n+                    ));\n+                }\n+                if bounds.is_empty() {\n+                    return None;\n+                }\n+\n+                Some(WherePredicate::BoundPredicate {\n+                    ty,\n+                    bounds: bounds.into_iter().collect(),\n+                })\n+            })\n+            .chain(\n+                lifetime_to_bounds\n+                    .into_iter()\n+                    .filter(|&(_, ref bounds)| !bounds.is_empty())\n+                    .map(|(lifetime, bounds)| WherePredicate::RegionPredicate {\n+                        lifetime,\n+                        bounds: bounds.into_iter().collect(),\n+                    }),\n+            )\n+            .collect()\n+    }\n+\n+    // Converts the calculated ParamEnv and lifetime information to a clean::Generics, suitable for\n+    // display on the docs page. Cleaning the Predicates produces sub-optimal WherePredicate's,\n+    // so we fix them up:\n+    //\n+    // * Multiple bounds for the same type are coalesced into one: e.g. 'T: Copy', 'T: Debug'\n+    // becomes 'T: Copy + Debug'\n+    // * Fn bounds are handled specially - instead of leaving it as 'T: Fn(), <T as Fn::Output> =\n+    // K', we use the dedicated syntax 'T: Fn() -> K'\n+    // * We explcitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n+    fn param_env_to_generics<'b, 'c, 'cx>(\n+        &self,\n+        tcx: TyCtxt<'b, 'c, 'cx>,\n+        did: DefId,\n+        param_env: ty::ParamEnv<'cx>,\n+        type_generics: ty::Generics,\n+        mut existing_predicates: Vec<WherePredicate>,\n+        vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n+    ) -> Generics {\n+        debug!(\n+            \"param_env_to_generics(did={:?}, param_env={:?}, type_generics={:?}, \\\n+             existing_predicates={:?})\",\n+            did, param_env, type_generics, existing_predicates\n+        );\n+\n+        // The `Sized` trait must be handled specially, since we only only display it when\n+        // it is *not* required (i.e. '?Sized')\n+        let sized_trait = self.cx\n+            .tcx\n+            .require_lang_item(lang_items::SizedTraitLangItem);\n+\n+        let mut replacer = RegionReplacer {\n+            vid_to_region: &vid_to_region,\n+            tcx,\n+        };\n+\n+        let orig_bounds: FxHashSet<_> = self.cx.tcx.param_env(did).caller_bounds.iter().collect();\n+        let clean_where_predicates = param_env\n+            .caller_bounds\n+            .iter()\n+            .filter(|p| {\n+                !orig_bounds.contains(p) || match p {\n+                    &&ty::Predicate::Trait(pred) => pred.def_id() == sized_trait,\n+                    _ => false,\n+                }\n+            })\n+            .map(|p| {\n+                let replaced = p.fold_with(&mut replacer);\n+                (replaced.clone(), replaced.clean(self.cx))\n+            });\n+\n+        let full_generics = (&type_generics, &tcx.predicates_of(did));\n+        let Generics {\n+            params: mut generic_params,\n+            ..\n+        } = full_generics.clean(self.cx);\n+\n+        let mut has_sized = FxHashSet();\n+        let mut ty_to_bounds = FxHashMap();\n+        let mut lifetime_to_bounds = FxHashMap();\n+        let mut ty_to_traits: FxHashMap<Type, FxHashSet<Type>> = FxHashMap();\n+\n+        let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = FxHashMap();\n+\n+        for (orig_p, p) in clean_where_predicates {\n+            match p {\n+                WherePredicate::BoundPredicate { ty, mut bounds } => {\n+                    // Writing a projection trait bound of the form\n+                    // <T as Trait>::Name : ?Sized\n+                    // is illegal, because ?Sized bounds can only\n+                    // be written in the (here, nonexistant) definition\n+                    // of the type.\n+                    // Therefore, we make sure that we never add a ?Sized\n+                    // bound for projections\n+                    match &ty {\n+                        &Type::QPath { .. } => {\n+                            has_sized.insert(ty.clone());\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    if bounds.is_empty() {\n+                        continue;\n+                    }\n+\n+                    let mut for_generics = self.extract_for_generics(tcx, orig_p.clone());\n+\n+                    assert!(bounds.len() == 1);\n+                    let mut b = bounds.pop().unwrap();\n+\n+                    if b.is_sized_bound(self.cx) {\n+                        has_sized.insert(ty.clone());\n+                    } else if !b.get_trait_type()\n+                        .and_then(|t| {\n+                            ty_to_traits\n+                                .get(&ty)\n+                                .map(|bounds| bounds.contains(&strip_type(t.clone())))\n+                        })\n+                        .unwrap_or(false)\n+                    {\n+                        // If we've already added a projection bound for the same type, don't add\n+                        // this, as it would be a duplicate\n+\n+                        // Handle any 'Fn/FnOnce/FnMut' bounds specially,\n+                        // as we want to combine them with any 'Output' qpaths\n+                        // later\n+\n+                        let is_fn = match &mut b {\n+                            &mut TyParamBound::TraitBound(ref mut p, _) => {\n+                                // Insert regions into the for_generics hash map first, to ensure\n+                                // that we don't end up with duplicate bounds (e.g. for<'b, 'b>)\n+                                for_generics.extend(p.generic_params.clone());\n+                                p.generic_params = for_generics.into_iter().collect();\n+                                self.is_fn_ty(&tcx, &p.trait_)\n+                            }\n+                            _ => false,\n+                        };\n+\n+                        let poly_trait = b.get_poly_trait().unwrap();\n+\n+                        if is_fn {\n+                            ty_to_fn\n+                                .entry(ty.clone())\n+                                .and_modify(|e| *e = (Some(poly_trait.clone()), e.1.clone()))\n+                                .or_insert(((Some(poly_trait.clone())), None));\n+\n+                            ty_to_bounds\n+                                .entry(ty.clone())\n+                                .or_insert_with(|| FxHashSet());\n+                        } else {\n+                            ty_to_bounds\n+                                .entry(ty.clone())\n+                                .or_insert_with(|| FxHashSet())\n+                                .insert(b.clone());\n+                        }\n+                    }\n+                }\n+                WherePredicate::RegionPredicate { lifetime, bounds } => {\n+                    lifetime_to_bounds\n+                        .entry(lifetime)\n+                        .or_insert_with(|| FxHashSet())\n+                        .extend(bounds);\n+                }\n+                WherePredicate::EqPredicate { lhs, rhs } => {\n+                    match &lhs {\n+                        &Type::QPath {\n+                            name: ref left_name,\n+                            ref self_type,\n+                            ref trait_,\n+                        } => {\n+                            let ty = &*self_type;\n+                            match **trait_ {\n+                                Type::ResolvedPath {\n+                                    path: ref trait_path,\n+                                    ref typarams,\n+                                    ref did,\n+                                    ref is_generic,\n+                                } => {\n+                                    let mut new_trait_path = trait_path.clone();\n+\n+                                    if self.is_fn_ty(&tcx, trait_) && left_name == FN_OUTPUT_NAME {\n+                                        ty_to_fn\n+                                            .entry(*ty.clone())\n+                                            .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n+                                            .or_insert((None, Some(rhs)));\n+                                        continue;\n+                                    }\n+\n+                                    // FIXME: Remove this scope when NLL lands\n+                                    {\n+                                        let params =\n+                                            &mut new_trait_path.segments.last_mut().unwrap().params;\n+\n+                                        match params {\n+                                            // Convert somethiung like '<T as Iterator::Item> = u8'\n+                                            // to 'T: Iterator<Item=u8>'\n+                                            &mut PathParameters::AngleBracketed {\n+                                                ref mut bindings,\n+                                                ..\n+                                            } => {\n+                                                bindings.push(TypeBinding {\n+                                                    name: left_name.clone(),\n+                                                    ty: rhs,\n+                                                });\n+                                            }\n+                                            &mut PathParameters::Parenthesized { .. } => {\n+                                                existing_predicates.push(\n+                                                    WherePredicate::EqPredicate {\n+                                                        lhs: lhs.clone(),\n+                                                        rhs,\n+                                                    },\n+                                                );\n+                                                continue; // If something other than a Fn ends up\n+                                                          // with parenthesis, leave it alone\n+                                            }\n+                                        }\n+                                    }\n+\n+                                    let bounds = ty_to_bounds\n+                                        .entry(*ty.clone())\n+                                        .or_insert_with(|| FxHashSet());\n+\n+                                    bounds.insert(TyParamBound::TraitBound(\n+                                        PolyTrait {\n+                                            trait_: Type::ResolvedPath {\n+                                                path: new_trait_path,\n+                                                typarams: typarams.clone(),\n+                                                did: did.clone(),\n+                                                is_generic: *is_generic,\n+                                            },\n+                                            generic_params: Vec::new(),\n+                                        },\n+                                        hir::TraitBoundModifier::None,\n+                                    ));\n+\n+                                    // Remove any existing 'plain' bound (e.g. 'T: Iterator`) so\n+                                    // that we don't see a\n+                                    // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n+                                    // on the docs page.\n+                                    bounds.remove(&TyParamBound::TraitBound(\n+                                        PolyTrait {\n+                                            trait_: *trait_.clone(),\n+                                            generic_params: Vec::new(),\n+                                        },\n+                                        hir::TraitBoundModifier::None,\n+                                    ));\n+                                    // Avoid creating any new duplicate bounds later in the outer\n+                                    // loop\n+                                    ty_to_traits\n+                                        .entry(*ty.clone())\n+                                        .or_insert_with(|| FxHashSet())\n+                                        .insert(*trait_.clone());\n+                                }\n+                                _ => panic!(\"Unexpected trait {:?} for {:?}\", trait_, did),\n+                            }\n+                        }\n+                        _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, did),\n+                    }\n+                }\n+            };\n+        }\n+\n+        let final_bounds = self.make_final_bounds(ty_to_bounds, ty_to_fn, lifetime_to_bounds);\n+\n+        existing_predicates.extend(final_bounds);\n+\n+        for p in generic_params.iter_mut() {\n+            match p {\n+                &mut GenericParam::Type(ref mut ty) => {\n+                    // We never want something like 'impl<T=Foo>'\n+                    ty.default.take();\n+\n+                    let generic_ty = Type::Generic(ty.name.clone());\n+\n+                    if !has_sized.contains(&generic_ty) {\n+                        ty.bounds.insert(0, TyParamBound::maybe_sized(self.cx));\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.sort_where_predicates(&mut existing_predicates);\n+\n+        Generics {\n+            params: generic_params,\n+            where_predicates: existing_predicates,\n+        }\n+    }\n+\n+    // Ensure that the predicates are in a consistent order. The precise\n+    // ordering doesn't actually matter, but it's important that\n+    // a given set of predicates always appears in the same order -\n+    // both for visual consistency between 'rustdoc' runs, and to\n+    // make writing tests much easier\n+    fn sort_where_predicates(&self, predicates: &mut Vec<WherePredicate>) {\n+        // We should never have identical bounds - and if we do,\n+        // they're visually identical as well. Therefore, using\n+        // an unstable sort is fine.\n+        predicates.sort_unstable_by(|first, second| {\n+            // This might look horrendously hacky, but it's actually not that bad.\n+            //\n+            // For performance reasons, we use several different FxHashMaps\n+            // in the process of computing the final set of where predicates.\n+            // However, the iteration order of a HashMap is completely unspecified.\n+            // In fact, the iteration of an FxHashMap can even vary between platforms,\n+            // since FxHasher has different behavior for 32-bit and 64-bit platforms.\n+            //\n+            // Obviously, it's extremely undesireable for documentation rendering\n+            // to be depndent on the platform it's run on. Apart from being confusing\n+            // to end users, it makes writing tests much more difficult, as predicates\n+            // can appear in any order in the final result.\n+            //\n+            // To solve this problem, we sort WherePredicates by their Debug\n+            // string. The thing to keep in mind is that we don't really\n+            // care what the final order is - we're synthesizing an impl\n+            // ourselves, so any order can be considered equally valid.\n+            // By sorting the predicates, however, we ensure that for\n+            // a given codebase, all auto-trait impls always render\n+            // in exactly the same way.\n+            //\n+            // Using the Debug impementation for sorting prevents\n+            // us from needing to write quite a bit of almost\n+            // entirely useless code (e.g. how should two\n+            // Types be sorted relative to each other).\n+            // This approach is probably somewhat slower, but\n+            // the small number of items involved (impls\n+            // rarely have more than a few bounds) means\n+            // that it shouldn't matter in practice.\n+            format!(\"{:?}\", first).cmp(&format!(\"{:?}\", second))\n+        });\n+    }\n+\n+    fn is_fn_ty(&self, tcx: &TyCtxt, ty: &Type) -> bool {\n+        match &ty {\n+            &&Type::ResolvedPath { ref did, .. } => {\n+                *did == tcx.require_lang_item(lang_items::FnTraitLangItem)\n+                    || *did == tcx.require_lang_item(lang_items::FnMutTraitLangItem)\n+                    || *did == tcx.require_lang_item(lang_items::FnOnceTraitLangItem)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n+    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n+    // registered after the AST is constructed would require storing the defid mapping in a\n+    // RefCell, decreasing the performance for normal compilation for very little gain.\n+    //\n+    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n+    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n+    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n+    fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+        let start_def_id = {\n+            let next_id = if crate_num == LOCAL_CRATE {\n+                self.cx\n+                    .tcx\n+                    .hir\n+                    .definitions()\n+                    .def_path_table()\n+                    .next_id(DefIndexAddressSpace::Low)\n+            } else {\n+                self.cx\n+                    .cstore\n+                    .def_path_table(crate_num)\n+                    .next_id(DefIndexAddressSpace::Low)\n+            };\n+\n+            DefId {\n+                krate: crate_num,\n+                index: next_id,\n+            }\n+        };\n+\n+        let mut fake_ids = self.cx.fake_def_ids.borrow_mut();\n+\n+        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n+        fake_ids.insert(\n+            crate_num,\n+            DefId {\n+                krate: crate_num,\n+                index: DefIndex::from_array_index(\n+                    def_id.index.as_array_index() + 1,\n+                    def_id.index.address_space(),\n+                ),\n+            },\n+        );\n+\n+        MAX_DEF_ID.with(|m| {\n+            m.borrow_mut()\n+                .entry(def_id.krate.clone())\n+                .or_insert(start_def_id);\n+        });\n+\n+        self.cx.all_fake_def_ids.borrow_mut().insert(def_id);\n+\n+        def_id.clone()\n+    }\n+}\n+\n+// Replaces all ReVars in a type with ty::Region's, using the provided map\n+struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        (match r {\n+            &ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n+            _ => None,\n+        }).unwrap_or_else(|| r.super_fold_with(self))\n+    }\n+}"}, {"sha": "a769771f8aa88bae8a2df9a7c062028228950076", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::Span;\n \n use html::escape::Escape;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n     /// Accepts all configurations.\n     True,"}, {"sha": "d4233309627f5844874b4ab3c66f7b26f53de400", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -12,8 +12,8 @@\n \n use std::collections::BTreeMap;\n use std::io;\n-use std::iter::once;\n use std::rc::Rc;\n+use std::iter::once;\n \n use syntax::ast;\n use rustc::hir;\n@@ -25,7 +25,7 @@ use rustc::util::nodemap::FxHashSet;\n \n use core::{DocContext, DocAccessLevels};\n use doctree;\n-use clean::{self, GetDefId};\n+use clean::{self, GetDefId, get_auto_traits_with_def_id};\n \n use super::Clean;\n \n@@ -50,7 +50,7 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name)\n     let inner = match def {\n         Def::Trait(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, false));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Def::Fn(did) => {\n@@ -59,27 +59,27 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name)\n         }\n         Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, true));\n             clean::StructItem(build_struct(cx, did))\n         }\n         Def::Union(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, true));\n             clean::UnionItem(build_union(cx, did))\n         }\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, false));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, true));\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Def::TyForeign(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, false));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -125,6 +125,11 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n+    if did.is_local() {\n+        debug!(\"record_extern_fqn(did={:?}, kind+{:?}): def_id is local, aborting\", did, kind);\n+        return;\n+    }\n+\n     let crate_name = cx.tcx.crate_name(did.krate).to_string();\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n@@ -144,6 +149,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n }\n \n pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n+    let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n@@ -152,6 +158,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n     let is_spotlight = load_attrs(cx, did).has_doc_flag(\"spotlight\");\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n+        auto: auto_trait,\n         unsafety: cx.tcx.trait_def(did).unsafety,\n         generics,\n         items: trait_items,\n@@ -227,14 +234,24 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n     for &did in tcx.inherent_impls(did).iter() {\n         build_impl(cx, did, &mut impls);\n     }\n \n+    if auto_traits {\n+        let auto_impls = get_auto_traits_with_def_id(cx, did);\n+        let mut renderinfo = cx.renderinfo.borrow_mut();\n+\n+        let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n+            .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n+\n+        impls.extend(new_impls);\n+    }\n+\n     // If this is the first time we've inlined something from another crate, then\n     // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need\n@@ -347,13 +364,14 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n-            unsafety: hir::Unsafety::Normal, // FIXME: this should be decoded\n+            unsafety: hir::Unsafety::Normal,\n+            generics: (tcx.generics_of(did), &predicates).clean(cx),\n             provided_trait_methods: provided,\n             trait_,\n             for_,\n-            generics: (tcx.generics_of(did), &predicates).clean(cx),\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n+            synthetic: false,\n         }),\n         source: tcx.def_span(did).clean(cx),\n         name: None,"}, {"sha": "ff6d14f04579cb5532bf7f3c2a71921c41470654", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 373, "deletions": 60, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -26,31 +26,41 @@ use syntax::codemap::Spanned;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n+use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n-use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::{self, HirVec};\n+use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::DefIndexAddressSpace;\n+use rustc::traits;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, AdtKind};\n+use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n-\n-use rustc::hir;\n+use rustc::infer::{InferCtxt, RegionObligation};\n+use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n+use rustc::traits::*;\n+use std::collections::hash_map::Entry;\n+use std::collections::VecDeque;\n+use std::fmt;\n \n use rustc_const_math::ConstInt;\n use std::default::Default;\n use std::{mem, slice, vec};\n-use std::iter::FromIterator;\n+use std::iter::{FromIterator, once};\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n-use core::DocContext;\n+use core::{self, DocContext};\n use doctree;\n use visit_ast;\n use html::item_type::ItemType;\n@@ -59,8 +69,14 @@ use html::markdown::markdown_links;\n pub mod inline;\n pub mod cfg;\n mod simplify;\n+mod auto_trait;\n \n use self::cfg::Cfg;\n+use self::auto_trait::AutoTraitFinder;\n+\n+thread_local!(static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = RefCell::new(FxHashMap()));\n+\n+const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n@@ -282,7 +298,7 @@ impl Clean<ExternalCrate> for CrateNum {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Item {\n     /// Stringified span\n     pub source: Span,\n@@ -296,6 +312,26 @@ pub struct Item {\n     pub deprecation: Option<Deprecation>,\n }\n \n+impl fmt::Debug for Item {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+\n+        let fake = MAX_DEF_ID.with(|m| m.borrow().get(&self.def_id.krate)\n+                                   .map(|id| self.def_id >= *id).unwrap_or(false));\n+        let def_id: &fmt::Debug = if fake { &\"**FAKE**\" } else { &self.def_id };\n+\n+        fmt.debug_struct(\"Item\")\n+            .field(\"source\", &self.source)\n+            .field(\"name\", &self.name)\n+            .field(\"attrs\", &self.attrs)\n+            .field(\"inner\", &self.inner)\n+            .field(\"visibility\", &self.visibility)\n+            .field(\"def_id\", def_id)\n+            .field(\"stability\", &self.stability)\n+            .field(\"deprecation\", &self.deprecation)\n+            .finish()\n+    }\n+}\n+\n impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n@@ -492,9 +528,9 @@ impl Clean<Item> for doctree::Module {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.structs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.unions.iter().map(|x| x.clean(cx)));\n-        items.extend(self.enums.iter().map(|x| x.clean(cx)));\n+        items.extend(self.structs.iter().flat_map(|x| x.clean(cx)));\n+        items.extend(self.unions.iter().flat_map(|x| x.clean(cx)));\n+        items.extend(self.enums.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n@@ -601,7 +637,7 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n /// Included files are kept separate from inline doc comments so that proper line-number\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum DocFragment {\n     // FIXME #44229 (misdreavus): sugared and raw doc comments can be brought back together once\n     // hoedown is completely removed from rustdoc.\n@@ -653,7 +689,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n pub struct Attributes {\n     pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n@@ -1177,7 +1213,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct TyParam {\n     pub name: String,\n     pub did: DefId,\n@@ -1212,7 +1248,7 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n     TraitBound(PolyTrait, hir::TraitBoundModifier)\n@@ -1245,6 +1281,21 @@ impl TyParamBound {\n         }\n         false\n     }\n+\n+    fn get_poly_trait(&self) -> Option<PolyTrait> {\n+        if let TyParamBound::TraitBound(ref p, _) = *self {\n+            return Some(p.clone())\n+        }\n+        None\n+    }\n+\n+    fn get_trait_type(&self) -> Option<Type> {\n+\n+        if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n+            return Some(trait_.clone());\n+        }\n+        None\n+    }\n }\n \n impl Clean<TyParamBound> for hir::TyParamBound {\n@@ -1363,7 +1414,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -1380,17 +1431,19 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n-        let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n-        let def = cx.tcx.named_region(hir_id);\n-        match def {\n-            Some(rl::Region::EarlyBound(_, node_id, _)) |\n-            Some(rl::Region::LateBound(_, node_id, _)) |\n-            Some(rl::Region::Free(_, node_id)) => {\n-                if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n-                    return lt;\n+        if self.id != ast::DUMMY_NODE_ID {\n+            let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n+            let def = cx.tcx.named_region(hir_id);\n+            match def {\n+                Some(rl::Region::EarlyBound(_, node_id, _)) |\n+                Some(rl::Region::LateBound(_, node_id, _)) |\n+                Some(rl::Region::Free(_, node_id)) => {\n+                    if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                        return lt;\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n         }\n         Lifetime(self.name.name().to_string())\n     }\n@@ -1437,7 +1490,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n@@ -1562,7 +1615,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum GenericParam {\n     Lifetime(Lifetime),\n     Type(TyParam),\n@@ -1577,7 +1630,8 @@ impl Clean<GenericParam> for hir::GenericParam {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n+// maybe use a Generic enum and use Vec<Generic>?\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n pub struct Generics {\n     pub params: Vec<GenericParam>,\n     pub where_predicates: Vec<WherePredicate>,\n@@ -1747,7 +1801,7 @@ impl Clean<Item> for doctree::Function {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n@@ -1765,7 +1819,7 @@ impl FnDecl {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n@@ -1840,7 +1894,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n@@ -1870,7 +1924,7 @@ impl Argument {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum FunctionRetTy {\n     Return(Type),\n     DefaultReturn,\n@@ -1896,6 +1950,7 @@ impl GetDefId for FunctionRetTy {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Trait {\n+    pub auto: bool,\n     pub unsafety: hir::Unsafety,\n     pub items: Vec<Item>,\n     pub generics: Generics,\n@@ -1917,6 +1972,7 @@ impl Clean<Item> for doctree::Trait {\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n             inner: TraitItem(Trait {\n+                auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n                 items: self.items.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -2158,7 +2214,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PolyTrait {\n     pub trait_: Type,\n     pub generic_params: Vec<GenericParam>,\n@@ -2167,7 +2223,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n     /// structs/enums/traits (most that'd be an hir::TyPath)\n     ResolvedPath {\n@@ -2782,10 +2838,13 @@ pub struct Union {\n     pub fields_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Struct {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n+impl Clean<Vec<Item>> for doctree::Struct {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        let name = self.name.clean(cx);\n+        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+\n+        ret.push(Item {\n+            name: Some(name),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2798,14 +2857,19 @@ impl Clean<Item> for doctree::Struct {\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+        });\n+\n+        ret\n     }\n }\n \n-impl Clean<Item> for doctree::Union {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n+impl Clean<Vec<Item>> for doctree::Union {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        let name = self.name.clean(cx);\n+        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+\n+        ret.push(Item {\n+            name: Some(name),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2818,7 +2882,9 @@ impl Clean<Item> for doctree::Union {\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+        });\n+\n+        ret\n     }\n }\n \n@@ -2849,10 +2915,13 @@ pub struct Enum {\n     pub variants_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Enum {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n+impl Clean<Vec<Item>> for doctree::Enum {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        let name = self.name.clean(cx);\n+        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+\n+        ret.push(Item {\n+            name: Some(name),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2864,7 +2933,9 @@ impl Clean<Item> for doctree::Enum {\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n-        }\n+        });\n+\n+        ret\n     }\n }\n \n@@ -2989,7 +3060,7 @@ impl Clean<Span> for syntax_pos::Span {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct Path {\n     pub global: bool,\n     pub def: Def,\n@@ -3006,7 +3077,7 @@ impl Path {\n                 params: PathParameters::AngleBracketed {\n                     lifetimes: Vec::new(),\n                     types: Vec::new(),\n-                    bindings: Vec::new()\n+                    bindings: Vec::new(),\n                 }\n             }]\n         }\n@@ -3027,7 +3098,7 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum PathParameters {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n@@ -3062,7 +3133,7 @@ impl Clean<PathParameters> for hir::PathParameters {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PathSegment {\n     pub name: String,\n     pub params: PathParameters,\n@@ -3077,6 +3148,50 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n+fn strip_type(ty: Type) -> Type {\n+    match ty {\n+        Type::ResolvedPath { path, typarams, did, is_generic } => {\n+            Type::ResolvedPath { path: strip_path(&path), typarams, did, is_generic }\n+        }\n+        Type::Tuple(inner_tys) => {\n+            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n+        }\n+        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n+        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n+        Type::Unique(inner_ty) => Type::Unique(Box::new(strip_type(*inner_ty))),\n+        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n+        Type::BorrowedRef { lifetime, mutability, type_ } => {\n+            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n+        }\n+        Type::QPath { name, self_type, trait_ } => {\n+            Type::QPath {\n+                name,\n+                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n+            }\n+        }\n+        _ => ty\n+    }\n+}\n+\n+fn strip_path(path: &Path) -> Path {\n+    let segments = path.segments.iter().map(|s| {\n+        PathSegment {\n+            name: s.name.clone(),\n+            params: PathParameters::AngleBracketed {\n+                lifetimes: Vec::new(),\n+                types: Vec::new(),\n+                bindings: Vec::new(),\n+            }\n+        }\n+    }).collect();\n+\n+    Path {\n+        global: path.global,\n+        def: path.def.clone(),\n+        segments,\n+    }\n+}\n+\n fn qpath_to_string(p: &hir::QPath) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n@@ -3125,7 +3240,7 @@ impl Clean<Item> for doctree::Typedef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct BareFunctionDecl {\n     pub unsafety: hir::Unsafety,\n     pub generic_params: Vec<GenericParam>,\n@@ -3198,7 +3313,7 @@ impl Clean<Item> for doctree::Constant {\n     }\n }\n \n-#[derive(Debug, Clone, RustcEncodable, RustcDecodable, PartialEq, Copy)]\n+#[derive(Debug, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Copy, Hash)]\n pub enum Mutability {\n     Mutable,\n     Immutable,\n@@ -3213,7 +3328,7 @@ impl Clean<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Copy, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Copy, Debug, Hash)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -3237,6 +3352,20 @@ pub struct Impl {\n     pub for_: Type,\n     pub items: Vec<Item>,\n     pub polarity: Option<ImplPolarity>,\n+    pub synthetic: bool,\n+}\n+\n+pub fn get_auto_traits_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+    let finder = AutoTraitFinder { cx };\n+    finder.get_with_node_id(id, name)\n+}\n+\n+pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+    let finder = AutoTraitFinder {\n+        cx,\n+    };\n+\n+    finder.get_with_def_id(id)\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n@@ -3274,7 +3403,8 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                 for_: self.for_.clean(cx),\n                 items,\n                 polarity: Some(self.polarity.clean(cx)),\n-            }),\n+                synthetic: false,\n+            })\n         });\n         ret\n     }\n@@ -3294,7 +3424,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did));\n+                ret.extend(inline::build_impls(cx, did, true));\n                 continue\n             }\n             _ => match target.primitive_type() {\n@@ -3514,7 +3644,11 @@ fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n-    debug!(\"resolve_type({:?},{:?})\", path, id);\n+    if id == ast::DUMMY_NODE_ID {\n+        debug!(\"resolve_type({:?})\", path);\n+    } else {\n+        debug!(\"resolve_type({:?},{:?})\", path, id);\n+    }\n \n     let is_generic = match path.def {\n         Def::PrimTy(p) => match p {\n@@ -3669,7 +3803,7 @@ impl Clean<Deprecation> for attr::Deprecation {\n }\n \n /// An equality constraint on an associated type, e.g. `A=Bar` in `Foo<A=Bar>`\n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n pub struct TypeBinding {\n     pub name: String,\n     pub ty: Type\n@@ -3683,3 +3817,182 @@ impl Clean<TypeBinding> for hir::TypeBinding {\n         }\n     }\n }\n+\n+pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<String> {\n+    let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n+    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() {\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    });\n+    once(crate_name).chain(relative).collect()\n+}\n+\n+// Start of code copied from rust-clippy\n+\n+pub fn get_trait_def_id(tcx: &TyCtxt, path: &[&str], use_local: bool) -> Option<DefId> {\n+    if use_local {\n+        path_to_def_local(tcx, path)\n+    } else {\n+        path_to_def(tcx, path)\n+    }\n+}\n+\n+pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+    let krate = tcx.hir.krate();\n+    let mut items = krate.module.item_ids.clone();\n+    let mut path_it = path.iter().peekable();\n+\n+    loop {\n+        let segment = match path_it.next() {\n+            Some(segment) => segment,\n+            None => return None,\n+        };\n+\n+        for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n+            let item = tcx.hir.expect_item(item_id.id);\n+            if item.name == *segment {\n+                if path_it.peek().is_none() {\n+                    return Some(tcx.hir.local_def_id(item_id.id))\n+                }\n+\n+                items = match &item.node {\n+                    &hir::ItemMod(ref m) => m.item_ids.clone(),\n+                    _ => panic!(\"Unexpected item {:?} in path {:?} path\")\n+                };\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+    let crates = tcx.crates();\n+\n+    let krate = crates\n+        .iter()\n+        .find(|&&krate| tcx.crate_name(krate) == path[0]);\n+\n+    if let Some(krate) = krate {\n+        let krate = DefId {\n+            krate: *krate,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let mut items = tcx.item_children(krate);\n+        let mut path_it = path.iter().skip(1).peekable();\n+\n+        loop {\n+            let segment = match path_it.next() {\n+                Some(segment) => segment,\n+                None => return None,\n+            };\n+\n+            for item in mem::replace(&mut items, Rc::new(vec![])).iter() {\n+                if item.ident.name == *segment {\n+                    if path_it.peek().is_none() {\n+                        return match item.def {\n+                            def::Def::Trait(did) => Some(did),\n+                            _ => None,\n+                        }\n+                    }\n+\n+                    items = tcx.item_children(item.def.def_id());\n+                    break;\n+                }\n+            }\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn get_path_for_type(tcx: TyCtxt, def_id: DefId, def_ctor: fn(DefId) -> Def) -> hir::Path {\n+    struct AbsolutePathBuffer {\n+        names: Vec<String>,\n+    }\n+\n+    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n+        fn root_mode(&self) -> &ty::item_path::RootMode {\n+            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n+            ABSOLUTE\n+        }\n+\n+        fn push(&mut self, text: &str) {\n+            self.names.push(text.to_owned());\n+        }\n+    }\n+\n+    let mut apb = AbsolutePathBuffer { names: vec![] };\n+\n+    tcx.push_item_path(&mut apb, def_id);\n+\n+    hir::Path {\n+        span: DUMMY_SP,\n+        def: def_ctor(def_id),\n+        segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n+            name: ast::Name::intern(&s),\n+            parameters: None,\n+            infer_types: false,\n+        }).collect())\n+    }\n+}\n+\n+// End of code copied from rust-clippy\n+\n+\n+#[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n+enum RegionTarget<'tcx> {\n+    Region(Region<'tcx>),\n+    RegionVid(RegionVid)\n+}\n+\n+#[derive(Default, Debug, Clone)]\n+struct RegionDeps<'tcx> {\n+    larger: FxHashSet<RegionTarget<'tcx>>,\n+    smaller: FxHashSet<RegionTarget<'tcx>>\n+}\n+\n+#[derive(Eq, PartialEq, Hash, Debug)]\n+enum SimpleBound {\n+    RegionBound(Lifetime),\n+    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParam>, hir::TraitBoundModifier)\n+}\n+\n+enum AutoTraitResult {\n+    ExplicitImpl,\n+    PositiveImpl(Generics),\n+    NegativeImpl,\n+}\n+\n+impl AutoTraitResult {\n+    fn is_auto(&self) -> bool {\n+        match *self {\n+            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl From<TyParamBound> for SimpleBound {\n+    fn from(bound: TyParamBound) -> Self {\n+        match bound.clone() {\n+            TyParamBound::RegionBound(l) => SimpleBound::RegionBound(l),\n+            TyParamBound::TraitBound(t, mod_) => match t.trait_ {\n+                Type::ResolvedPath { path, typarams, .. } => {\n+                    SimpleBound::TraitBound(path.segments,\n+                                            typarams\n+                                                .map_or_else(|| Vec::new(), |v| v.iter()\n+                                                        .map(|p| SimpleBound::from(p.clone()))\n+                                                        .collect()),\n+                                            t.generic_params,\n+                                            mod_)\n+                }\n+                _ => panic!(\"Unexpected bound {:?}\", bound),\n+            }\n+        }\n+    }\n+}"}, {"sha": "df7371cdf817b805c6d5e7c2a8f958bd003b26be", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -11,13 +11,14 @@\n use rustc_lint;\n use rustc_driver::{self, driver, target_features, abort_on_err};\n use rustc::session::{self, config};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::hir::def::Def;\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, AllArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_resolve as resolve;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -48,6 +49,8 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub resolver: &'a RefCell<resolve::Resolver<'rcx>>,\n     /// The stack of module NodeIds up till this point\n     pub mod_ids: RefCell<Vec<NodeId>>,\n+    pub crate_name: Option<String>,\n+    pub cstore: Rc<CrateStore>,\n     pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -65,6 +68,11 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n+    pub send_trait: Option<DefId>,\n+    pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n+    pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n+    /// Maps (type_id, trait_id) -> auto trait impl\n+    pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>\n }\n \n impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n@@ -107,6 +115,7 @@ pub fn run_core(search_paths: SearchPaths,\n                 triple: Option<String>,\n                 maybe_sysroot: Option<PathBuf>,\n                 allow_warnings: bool,\n+                crate_name: Option<String>,\n                 force_unstable_if_unmarked: bool) -> (clean::Crate, RenderInfo)\n {\n     // Parse, resolve, and typecheck the given crate.\n@@ -230,16 +239,28 @@ pub fn run_core(search_paths: SearchPaths,\n                                   .collect()\n         };\n \n+        let send_trait = if crate_name == Some(\"core\".to_string()) {\n+            clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n+        } else {\n+            clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+        };\n+\n         let ctxt = DocContext {\n             tcx,\n             resolver: &resolver,\n+            crate_name,\n+            cstore: cstore.clone(),\n             populated_all_crate_impls: Cell::new(false),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             mod_ids: Default::default(),\n+            send_trait: send_trait,\n+            fake_def_ids: RefCell::new(FxHashMap()),\n+            all_fake_def_ids: RefCell::new(FxHashSet()),\n+            generated_synthetics: RefCell::new(FxHashSet()),\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "413e5623118ac4bfd9a3313c6c86af7358c91174", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -210,6 +210,7 @@ pub struct Trait {\n     pub depr: Option<attr::Deprecation>,\n }\n \n+#[derive(Debug)]\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,"}, {"sha": "e7bb0b03ce24821ccd1e3d298d94e0890573800e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 222, "deletions": 60, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -37,7 +37,7 @@ pub use self::ExternalLocation::*;\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n-use std::collections::{BTreeMap, HashSet};\n+use std::collections::{BTreeMap, HashSet, VecDeque};\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n@@ -270,6 +270,18 @@ pub struct Cache {\n     /// generating explicit hyperlinks to other crates.\n     pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n+    /// Maps local def ids of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n@@ -322,6 +334,7 @@ pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n     pub external_paths: ::core::ExternalPaths,\n     pub external_typarams: FxHashMap<DefId, String>,\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n     pub owned_box_did: Option<DefId>,\n@@ -436,7 +449,9 @@ fn init_ids() -> FxHashMap<String, usize> {\n      \"required-methods\",\n      \"provided-methods\",\n      \"implementors\",\n+     \"synthetic-implementors\",\n      \"implementors-list\",\n+     \"synthetic-implementors-list\",\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n@@ -556,6 +571,7 @@ pub fn run(mut krate: clean::Crate,\n         inlined: _,\n         external_paths,\n         external_typarams,\n+        exact_paths,\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n@@ -568,6 +584,7 @@ pub fn run(mut krate: clean::Crate,\n     let mut cache = Cache {\n         impls: FxHashMap(),\n         external_paths,\n+        exact_paths,\n         paths: FxHashMap(),\n         implementors: FxHashMap(),\n         stack: Vec::new(),\n@@ -873,7 +890,10 @@ themePicker.onclick = function() {{\n             // should add it.\n             if !imp.impl_item.def_id.is_local() { continue }\n             have_impls = true;\n-            write!(implementors, \"{},\", as_json(&imp.inner_impl().to_string())).unwrap();\n+            write!(implementors, \"{{text:{},synthetic:{},types:{}}},\",\n+                   as_json(&imp.inner_impl().to_string()),\n+                   imp.inner_impl().synthetic,\n+                   as_json(&collect_paths_for_type(imp.inner_impl().for_.clone()))).unwrap();\n         }\n         implementors.push_str(\"];\");\n \n@@ -1856,8 +1876,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     document(w, cx, item)?;\n \n-    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped())\n-                                      .collect::<Vec<usize>>();\n+    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n@@ -2201,6 +2220,50 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n+fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter,\n+                      implementor_dups: &FxHashMap<&str, (DefId, bool)>) -> Result<(), fmt::Error> {\n+    write!(w, \"<li>\")?;\n+    if let Some(l) = (Item { cx, item: &implementor.impl_item }).src_href() {\n+        write!(w, \"<div class='out-of-band'>\")?;\n+        write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                    l, \"goto source code\")?;\n+        write!(w, \"</div>\")?;\n+    }\n+    write!(w, \"<code>\")?;\n+    // If there's already another implementor that has the same abbridged name, use the\n+    // full path, for example in `std::iter::ExactSizeIterator`\n+    let use_absolute = match implementor.inner_impl().for_ {\n+        clean::ResolvedPath { ref path, is_generic: false, .. } |\n+        clean::BorrowedRef {\n+            type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n+            ..\n+        } => implementor_dups[path.last_name()].1,\n+        _ => false,\n+    };\n+    fmt_impl_for_trait_page(&implementor.inner_impl(), w, use_absolute)?;\n+    for it in &implementor.inner_impl().items {\n+        if let clean::TypedefItem(ref tydef, _) = it.inner {\n+            write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n+            assoc_type(w, it, &vec![], Some(&tydef.type_), AssocItemLink::Anchor(None))?;\n+            write!(w, \";</span>\")?;\n+        }\n+    }\n+    writeln!(w, \"</code></li>\")?;\n+    Ok(())\n+}\n+\n+fn render_impls(cx: &Context, w: &mut fmt::Formatter,\n+                traits: Vec<&&Impl>,\n+                containing_item: &clean::Item) -> Result<(), fmt::Error> {\n+    for i in &traits {\n+        let did = i.trait_did().unwrap();\n+        let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n+        render_impl(w, cx, i, assoc_link,\n+                    RenderMode::Normal, containing_item.stable_since(), true)?;\n+    }\n+    Ok(())\n+}\n+\n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n@@ -2380,6 +2443,16 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         </h2>\n         <ul class='item-list' id='implementors-list'>\n     \";\n+\n+    let synthetic_impl_header = \"\n+        <h2 id='synthetic-implementors' class='small-section-header'>\n+          Auto implementors<a href='#synthetic-implementors' class='anchor'></a>\n+        </h2>\n+        <ul class='item-list' id='synthetic-implementors-list'>\n+    \";\n+\n+    let mut synthetic_types = Vec::new();\n+\n     if let Some(implementors) = cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n@@ -2405,6 +2478,11 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             .partition::<Vec<_>, _>(|i| i.inner_impl().for_.def_id()\n                                          .map_or(true, |d| cache.paths.contains_key(&d)));\n \n+\n+        let (synthetic, concrete) = local.iter()\n+            .partition::<Vec<_>, _>(|i| i.inner_impl().synthetic);\n+\n+\n         if !foreign.is_empty() {\n             write!(w, \"\n                 <h2 id='foreign-impls' class='small-section-header'>\n@@ -2422,42 +2500,35 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n \n         write!(w, \"{}\", impl_header)?;\n+        for implementor in concrete {\n+            render_implementor(cx, implementor, w, &implementor_dups)?;\n+        }\n+        write!(w, \"</ul>\")?;\n \n-        for implementor in local {\n-            write!(w, \"<li>\")?;\n-            if let Some(l) = (Item { cx, item: &implementor.impl_item }).src_href() {\n-                write!(w, \"<div class='out-of-band'>\")?;\n-                write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                            l, \"goto source code\")?;\n-                write!(w, \"</div>\")?;\n-            }\n-            write!(w, \"<code>\")?;\n-            // If there's already another implementor that has the same abbridged name, use the\n-            // full path, for example in `std::iter::ExactSizeIterator`\n-            let use_absolute = match implementor.inner_impl().for_ {\n-                clean::ResolvedPath { ref path, is_generic: false, .. } |\n-                clean::BorrowedRef {\n-                    type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n-                    ..\n-                } => implementor_dups[path.last_name()].1,\n-                _ => false,\n-            };\n-            fmt_impl_for_trait_page(&implementor.inner_impl(), w, use_absolute)?;\n-            for it in &implementor.inner_impl().items {\n-                if let clean::TypedefItem(ref tydef, _) = it.inner {\n-                    write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n-                    assoc_type(w, it, &vec![], Some(&tydef.type_), AssocItemLink::Anchor(None))?;\n-                    write!(w, \";</span>\")?;\n-                }\n+        if t.auto {\n+            write!(w, \"{}\", synthetic_impl_header)?;\n+            for implementor in synthetic {\n+                synthetic_types.extend(\n+                    collect_paths_for_type(implementor.inner_impl().for_.clone())\n+                );\n+                render_implementor(cx, implementor, w, &implementor_dups)?;\n             }\n-            writeln!(w, \"</code></li>\")?;\n+            write!(w, \"</ul>\")?;\n         }\n     } else {\n         // even without any implementations to write in, we still want the heading and list, so the\n         // implementors javascript file pulled in below has somewhere to write the impls into\n         write!(w, \"{}\", impl_header)?;\n+        write!(w, \"</ul>\")?;\n+\n+        if t.auto {\n+            write!(w, \"{}\", synthetic_impl_header)?;\n+            write!(w, \"</ul>\")?;\n+        }\n     }\n-    write!(w, \"</ul>\")?;\n+    write!(w, r#\"<script type=\"text/javascript\">window.inlined_types=new Set({});</script>\"#,\n+           as_json(&synthetic_types))?;\n+\n     write!(w, r#\"<script type=\"text/javascript\" async\n                          src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                  </script>\"#,\n@@ -3075,17 +3146,28 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }).is_some();\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut)?;\n         }\n+\n+        let (synthetic, concrete) = traits\n+            .iter()\n+            .partition::<Vec<_>, _>(|t| t.inner_impl().synthetic);\n+\n         write!(w, \"\n             <h2 id='implementations' class='small-section-header'>\n               Trait Implementations<a href='#implementations' class='anchor'></a>\n             </h2>\n+            <div id='implementations-list'>\n         \")?;\n-        for i in &traits {\n-            let did = i.trait_did().unwrap();\n-            let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n-            render_impl(w, cx, i, assoc_link,\n-                        RenderMode::Normal, containing_item.stable_since(), true)?;\n-        }\n+        render_impls(cx, w, concrete, containing_item)?;\n+        write!(w, \"</div>\")?;\n+\n+        write!(w, \"\n+            <h2 id='synthetic-implementations' class='small-section-header'>\n+              Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>\n+            </h2>\n+            <div id='synthetic-implementations-list'>\n+        \")?;\n+        render_impls(cx, w, synthetic, containing_item)?;\n+        write!(w, \"</div>\")?;\n     }\n     Ok(())\n }\n@@ -3586,32 +3668,48 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     }\n                 }\n             }\n-            let mut links = HashSet::new();\n-            let ret = v.iter()\n-                       .filter_map(|i| {\n-                           let is_negative_impl = is_negative_impl(i.inner_impl());\n-                           if let Some(ref i) = i.inner_impl().trait_ {\n-                               let i_display = format!(\"{:#}\", i);\n-                               let out = Escape(&i_display);\n-                               let encoded = small_url_encode(&format!(\"{:#}\", i));\n-                               let generated = format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n-                                                       encoded,\n-                                                       if is_negative_impl { \"!\" } else { \"\" },\n-                                                       out);\n-                               if !links.contains(&generated) && links.insert(generated.clone()) {\n-                                   Some(generated)\n+            let format_impls = |impls: Vec<&Impl>| {\n+                let mut links = HashSet::new();\n+                impls.iter()\n+                           .filter_map(|i| {\n+                               let is_negative_impl = is_negative_impl(i.inner_impl());\n+                               if let Some(ref i) = i.inner_impl().trait_ {\n+                                   let i_display = format!(\"{:#}\", i);\n+                                   let out = Escape(&i_display);\n+                                   let encoded = small_url_encode(&format!(\"{:#}\", i));\n+                                   let generated = format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n+                                                           encoded,\n+                                                           if is_negative_impl { \"!\" } else { \"\" },\n+                                                           out);\n+                                   if links.insert(generated.clone()) {\n+                                       Some(generated)\n+                                   } else {\n+                                       None\n+                                   }\n                                } else {\n                                    None\n                                }\n-                           } else {\n-                               None\n-                           }\n-                       })\n-                       .collect::<String>();\n-            if !ret.is_empty() {\n+                           })\n+                           .collect::<String>()\n+            };\n+\n+            let (synthetic, concrete) = v\n+                .iter()\n+                .partition::<Vec<_>, _>(|i| i.inner_impl().synthetic);\n+\n+            let concrete_format = format_impls(concrete);\n+            let synthetic_format = format_impls(synthetic);\n+\n+            if !concrete_format.is_empty() {\n                 out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">\\\n                               Trait Implementations</a>\");\n-                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret));\n+                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", concrete_format));\n+            }\n+\n+            if !synthetic_format.is_empty() {\n+                out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#synthetic-implementations\\\">\\\n+                              Auto Trait Implementations</a>\");\n+                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", synthetic_format));\n             }\n         }\n     }\n@@ -3734,7 +3832,7 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n     if let Some(implementors) = c.implementors.get(&it.def_id) {\n         let res = implementors.iter()\n                               .filter(|i| i.inner_impl().for_.def_id()\n-                                           .map_or(false, |d| !c.paths.contains_key(&d)))\n+                              .map_or(false, |d| !c.paths.contains_key(&d)))\n                               .filter_map(|i| {\n                                   match extract_for_impl_name(&i.impl_item) {\n                                       Some((ref name, ref url)) => {\n@@ -3755,6 +3853,10 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n     }\n \n     sidebar.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n+    if t.auto {\n+        sidebar.push_str(\"<a class=\\\"sidebar-title\\\" \\\n+                          href=\\\"#synthetic-implementors\\\">Auto Implementors</a>\");\n+    }\n \n     sidebar.push_str(&sidebar_assoc_items(it));\n \n@@ -3969,6 +4071,66 @@ fn get_index_type(clean_type: &clean::Type) -> Type {\n     t\n }\n \n+/// Returns a list of all paths used in the type.\n+/// This is used to help deduplicate imported impls\n+/// for reexported types. If any of the contained\n+/// types are re-exported, we don't use the corresponding\n+/// entry from the js file, as inlining will have already\n+/// picked up the impl\n+fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n+    let mut out = Vec::new();\n+    let mut visited = FxHashSet();\n+    let mut work = VecDeque::new();\n+    let cache = cache();\n+\n+    work.push_back(first_ty);\n+\n+    while let Some(ty) = work.pop_front() {\n+        if !visited.insert(ty.clone()) {\n+            continue;\n+        }\n+\n+        match ty {\n+            clean::Type::ResolvedPath { did, .. } => {\n+                let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n+                let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+\n+                match fqp {\n+                    Some(path) => {\n+                        out.push(path.join(\"::\"));\n+                    },\n+                    _ => {}\n+                };\n+\n+            },\n+            clean::Type::Tuple(tys) => {\n+                work.extend(tys.into_iter());\n+            },\n+            clean::Type::Slice(ty) => {\n+                work.push_back(*ty);\n+            }\n+            clean::Type::Array(ty, _) => {\n+                work.push_back(*ty);\n+            },\n+            clean::Type::Unique(ty) => {\n+                work.push_back(*ty);\n+            },\n+            clean::Type::RawPointer(_, ty) => {\n+                work.push_back(*ty);\n+            },\n+            clean::Type::BorrowedRef { type_, .. } => {\n+                work.push_back(*type_);\n+            },\n+            clean::Type::QPath { self_type, trait_, .. } => {\n+                work.push_back(*self_type);\n+                work.push_back(*trait_);\n+            },\n+            _ => {}\n+        }\n+    };\n+    out\n+}\n+\n fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n     match *clean_type {\n         clean::ResolvedPath { ref path, .. } => {"}, {"sha": "5c674cabde5d81cd654159e18cc57ab8f6f387a8", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -1563,14 +1563,31 @@\n     window.initSidebarItems = initSidebarItems;\n \n     window.register_implementors = function(imp) {\n-        var list = document.getElementById('implementors-list');\n+        var implementors = document.getElementById('implementors-list');\n+        var synthetic_implementors = document.getElementById('synthetic-implementors-list');\n+\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] === currentCrate) { continue; }\n             var structs = imp[libs[i]];\n+\n+            struct_loop:\n             for (var j = 0; j < structs.length; ++j) {\n+                var struct = structs[j];\n+\n+                var list = struct.synthetic ? synthetic_implementors : implementors;\n+\n+                if (struct.synthetic) {\n+                    for (var k = 0; k < struct.types.length; k++) {\n+                        if (window.inlined_types.has(struct.types[k])) {\n+                            continue struct_loop;\n+                        }\n+                        window.inlined_types.add(struct.types[k]);\n+                    }\n+                }\n+\n                 var code = document.createElement('code');\n-                code.innerHTML = structs[j];\n+                code.innerHTML = struct.text;\n \n                 var x = code.getElementsByTagName('a');\n                 for (var k = 0; k < x.length; k++) {"}, {"sha": "033988fa9d9d86fe90c5640ee69ca97d31a9bf2b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -24,6 +24,7 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n+#![feature(entry_and_modify)]\n \n extern crate arena;\n extern crate getopts;\n@@ -549,7 +550,8 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n \n         let (mut krate, renderinfo) =\n             core::run_core(paths, cfgs, externs, Input::File(cratefile), triple, maybe_sysroot,\n-                           display_warnings, force_unstable_if_unmarked);\n+                           display_warnings, crate_name.clone(),\n+                           force_unstable_if_unmarked);\n \n         info!(\"finished with rustc\");\n "}, {"sha": "f692e05d6a2591c07c9c618cc1456685f4dbb884", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -24,12 +24,12 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::{LoadedMacro, CrateStore};\n use rustc::middle::privacy::AccessLevel;\n use rustc::ty::Visibility;\n-use rustc::util::nodemap::FxHashSet;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n use rustc::hir;\n \n use core;\n-use clean::{self, AttributesExt, NestedAttributesExt};\n+use clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n use doctree::*;\n \n // looks to me like the first two of these are actually\n@@ -41,7 +41,7 @@ use doctree::*;\n // framework from syntax?\n \n pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cstore: &'a CrateStore,\n+    pub cstore: &'a CrateStore,\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n@@ -50,6 +50,7 @@ pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n     /// Is the current module and all of its parents public?\n     inside_public_path: bool,\n     reexported_macros: FxHashSet<DefId>,\n+    exact_paths: Option<FxHashMap<DefId, Vec<String>>>,\n }\n \n impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n@@ -66,10 +67,21 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             inlining: false,\n             inside_public_path: true,\n             reexported_macros: FxHashSet(),\n+            exact_paths: Some(FxHashMap()),\n             cstore,\n         }\n     }\n \n+    fn store_path(&mut self, did: DefId) {\n+        // We can't use the entry api, as that keeps the mutable borrow of self active\n+        // when we try to use cx\n+        let exact_paths = self.exact_paths.as_mut().unwrap();\n+        if exact_paths.get(&did).is_none() {\n+            let path = def_id_to_path(self.cx, did, self.cx.crate_name.clone());\n+            exact_paths.insert(did, path);\n+        }\n+    }\n+\n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx.hir.opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n@@ -94,6 +106,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             krate.exported_macros.iter().map(|def| self.visit_local_macro(def)).collect();\n         self.module.macros.extend(macro_exports);\n         self.module.is_crate = true;\n+\n+        self.cx.renderinfo.borrow_mut().exact_paths = self.exact_paths.take().unwrap();\n     }\n \n     pub fn visit_variant_data(&mut self, item: &hir::Item,\n@@ -371,6 +385,12 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                       renamed: Option<ast::Name>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.name);\n+\n+        if item.vis == hir::Public {\n+            let def_id = self.cx.tcx.hir.local_def_id(item.id);\n+            self.store_path(def_id);\n+        }\n+\n         match item.node {\n             hir::ItemForeignMod(ref fm) => {\n                 // If inlining we only want to include public functions."}, {"sha": "43a425d4c5e4fc16002367cf8bfdf4b013f768b9", "filename": "src/test/rustdoc/duplicate_impls/issue-33054.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -11,7 +11,8 @@\n // @has issue_33054/impls/struct.Foo.html\n // @has - '//code' 'impl Foo'\n // @has - '//code' 'impl Bar for Foo'\n-// @count - '//*[@class=\"impl\"]' 2\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"main\"]/*[@class=\"impl\"]' 1\n // @has issue_33054/impls/bar/trait.Bar.html\n // @has - '//code' 'impl Bar for Foo'\n // @count - '//*[@class=\"struct\"]' 1"}, {"sha": "553bbeb0cff391647c04462d0005cbccf790f91f", "filename": "src/test/rustdoc/issue-21474.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fissue-21474.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fissue-21474.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-21474.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -17,5 +17,5 @@ mod inner {\n pub trait Blah { }\n \n // @count issue_21474/struct.What.html \\\n-//        '//*[@class=\"impl\"]' 1\n+//        '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n pub struct What;"}, {"sha": "b0e64557be253caad64721fa9c8945e29b6cd6b5", "filename": "src/test/rustdoc/issue-45584.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fissue-45584.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fissue-45584.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-45584.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -14,12 +14,12 @@ pub trait Bar<T, U> {}\n \n // @has 'foo/struct.Foo1.html'\n pub struct Foo1;\n-// @count - '//*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n // @has - '//*[@class=\"impl\"]' \"impl Bar<Foo1, &'static Foo1> for Foo1\"\n impl Bar<Foo1, &'static Foo1> for Foo1 {}\n \n // @has 'foo/struct.Foo2.html'\n pub struct Foo2;\n-// @count - '//*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n // @has - '//*[@class=\"impl\"]' \"impl Bar<&'static Foo2, Foo2> for u8\"\n impl Bar<&'static Foo2, Foo2> for u8 {}"}, {"sha": "8ff84d11a5009874ced4f941da3ce7777e42a839", "filename": "src/test/rustdoc/synthetic_auto/basic.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has basic/struct.Foo.html\n+// @has - '//code' 'impl<T> Send for Foo<T> where T: Send'\n+// @has - '//code' 'impl<T> Sync for Foo<T> where T: Sync'\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 0\n+// @count - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]' 2\n+pub struct Foo<T> {\n+    field: T,\n+}"}, {"sha": "531798c30c656852ec5f8397c32210dcf6b103c0", "filename": "src/test/rustdoc/synthetic_auto/complex.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub trait MyTrait<'a> {\n+        type MyItem: ?Sized;\n+    }\n+\n+    pub struct Inner<'a, Q, R: ?Sized> {\n+        field: Q,\n+        field3: &'a u8,\n+        my_foo: Foo<Q>,\n+        field2: R,\n+    }\n+\n+    pub struct Outer<'a, T, K: ?Sized> {\n+        my_inner: Inner<'a, T, K>,\n+    }\n+\n+    pub struct Foo<T> {\n+        myfield: T,\n+    }\n+}\n+\n+// @has complex/struct.NotOuter.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<'a, T, K: \\\n+// ?Sized> Send for NotOuter<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n+// -> &'b i8, T: MyTrait<'a>, <T as MyTrait<'a>>::MyItem: Copy, 'a: 'static\"\n+\n+pub use foo::{Foo, Inner as NotInner, MyTrait as NotMyTrait, Outer as NotOuter};\n+\n+unsafe impl<T> Send for Foo<T>\n+where\n+    T: NotMyTrait<'static>,\n+{\n+}\n+\n+unsafe impl<'a, Q, R: ?Sized> Send for NotInner<'a, Q, R>\n+where\n+    Q: NotMyTrait<'a>,\n+    <Q as NotMyTrait<'a>>::MyItem: Copy,\n+    R: for<'b> Fn((&'b bool, &'a u8)) -> &'b i8,\n+    Foo<Q>: Send,\n+{\n+}"}, {"sha": "272925e5db5424d7a414a2d0a1e94bbea67b888f", "filename": "src/test/rustdoc/synthetic_auto/lifetimes.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+pub struct Inner<'a, T: 'a> {\n+    field: &'a T,\n+}\n+\n+unsafe impl<'a, T> Send for Inner<'a, T>\n+where\n+    'a: 'static,\n+    T: for<'b> Fn(&'b bool) -> &'a u8,\n+{}\n+\n+// @has lifetimes/struct.Foo.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<'c, K> Send \\\n+// for Foo<'c, K> where K: for<'b> Fn(&'b bool) -> &'c u8, 'c: 'static\"\n+//\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<'c, K> Sync \\\n+// for Foo<'c, K> where K: Sync\"\n+pub struct Foo<'c, K: 'c> {\n+    inner_field: Inner<'c, K>,\n+}"}, {"sha": "d81e6309dff6157a66ebdcd2e271f4619a8d6c77", "filename": "src/test/rustdoc/synthetic_auto/manual.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has manual/struct.Foo.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' 'impl<T> Sync for \\\n+// Foo<T> where T: Sync'\n+//\n+// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]/*/code' \\\n+// 'impl<T> Send for Foo<T>'\n+//\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]' 1\n+pub struct Foo<T> {\n+    field: T,\n+}\n+\n+unsafe impl<T> Send for Foo<T> {}"}, {"sha": "ec9cb710f1f8cda650bf885942d36f3c33868a2a", "filename": "src/test/rustdoc/synthetic_auto/negative.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Inner<T: Copy> {\n+    field: *mut T,\n+}\n+\n+// @has negative/struct.Outer.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<T> !Send for \\\n+// Outer<T>\"\n+//\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<T> \\\n+// !Sync for Outer<T>\"\n+pub struct Outer<T: Copy> {\n+    inner_field: Inner<T>,\n+}"}, {"sha": "1f33a8b13cbf8bc2f8e31eb0bbeb433be0a02314", "filename": "src/test/rustdoc/synthetic_auto/nested.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+pub struct Inner<T> {\n+    field: T,\n+}\n+\n+unsafe impl<T> Send for Inner<T>\n+where\n+    T: Copy,\n+{\n+}\n+\n+// @has nested/struct.Foo.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' 'impl<T> Send for \\\n+// Foo<T> where T: Copy'\n+//\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \\\n+// 'impl<T> Sync for Foo<T> where T: Sync'\n+pub struct Foo<T> {\n+    inner_field: Inner<T>,\n+}"}, {"sha": "0b37f2ed3179021aaa041687fc0bde509a2ea7df", "filename": "src/test/rustdoc/synthetic_auto/no-redundancy.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Inner<T> {\n+    field: T,\n+}\n+\n+unsafe impl<T> Send for Inner<T>\n+where\n+    T: Copy + Send,\n+{\n+}\n+\n+// @has no_redundancy/struct.Outer.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<T> Send for \\\n+// Outer<T> where T: Copy + Send\"\n+pub struct Outer<T> {\n+    inner_field: Inner<T>,\n+}"}, {"sha": "977607fb148264652908b8f4b26a981d1c60b1db", "filename": "src/test/rustdoc/synthetic_auto/project.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec653536c3db82d74bb1a274b7df9d9dc582ec4/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs?ref=aec653536c3db82d74bb1a274b7df9d9dc582ec4", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Inner<'a, T: 'a> {\n+    field: &'a T,\n+}\n+\n+trait MyTrait {\n+    type MyItem;\n+}\n+\n+trait OtherTrait {}\n+\n+unsafe impl<'a, T> Send for Inner<'a, T>\n+where\n+    'a: 'static,\n+    T: MyTrait<MyItem = bool>,\n+{\n+}\n+unsafe impl<'a, T> Sync for Inner<'a, T>\n+where\n+    'a: 'static,\n+    T: MyTrait,\n+    <T as MyTrait>::MyItem: OtherTrait,\n+{\n+}\n+\n+// @has project/struct.Foo.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<'c, K> Send \\\n+// for Foo<'c, K> where K: MyTrait<MyItem = bool>, 'c: 'static\"\n+//\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]/*/code' \"impl<'c, K> Sync \\\n+// for Foo<'c, K> where K: MyTrait, <K as MyTrait>::MyItem: OtherTrait, 'c: 'static,\"\n+pub struct Foo<'c, K: 'c> {\n+    inner_field: Inner<'c, K>,\n+}"}]}