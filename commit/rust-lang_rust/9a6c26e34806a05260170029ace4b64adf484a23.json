{"sha": "9a6c26e34806a05260170029ace4b64adf484a23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNmMyNmUzNDgwNmEwNTI2MDE3MDAyOWFjZTRiNjRhZGY0ODRhMjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T15:53:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T15:53:11Z"}, "message": "Move module to SourceBinder", "tree": {"sha": "2fc837f43e859e569b8b156c1d090d1c5fec63c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc837f43e859e569b8b156c1d090d1c5fec63c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a6c26e34806a05260170029ace4b64adf484a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c26e34806a05260170029ace4b64adf484a23", "html_url": "https://github.com/rust-lang/rust/commit/9a6c26e34806a05260170029ace4b64adf484a23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c26e34806a05260170029ace4b64adf484a23/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16cfc8d50c9b5b4deb1065b9394e7663df7e9500", "url": "https://api.github.com/repos/rust-lang/rust/commits/16cfc8d50c9b5b4deb1065b9394e7663df7e9500", "html_url": "https://github.com/rust-lang/rust/commit/16cfc8d50c9b5b4deb1065b9394e7663df7e9500"}], "stats": {"total": 124, "additions": 69, "deletions": 55}, "files": [{"sha": "eb76aecb1bac6d30c4273103720c24db84de564b", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -2,46 +2,22 @@\n //! file.\n \n use hir_def::{nameres::ModuleSource, ModuleId};\n-use hir_expand::name::AsName;\n use ra_db::FileId;\n use ra_prof::profile;\n-use ra_syntax::ast::{self, AstNode, NameOwner};\n \n-use crate::{db::DefDatabase, InFile, Module};\n+use crate::{\n+    db::{DefDatabase, HirDatabase},\n+    InFile, Module,\n+};\n \n impl Module {\n-    pub fn from_declaration(db: &impl DefDatabase, src: InFile<ast::Module>) -> Option<Self> {\n-        let _p = profile(\"Module::from_declaration\");\n-        let parent_declaration = src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n-\n-        let parent_module = match parent_declaration {\n-            Some(parent_declaration) => {\n-                let src_parent = InFile { file_id: src.file_id, value: parent_declaration };\n-                Module::from_declaration(db, src_parent)\n-            }\n-            None => {\n-                let source_file = db.parse(src.file_id.original_file(db)).tree();\n-                let src_parent =\n-                    InFile { file_id: src.file_id, value: ModuleSource::SourceFile(source_file) };\n-                Module::from_definition(db, src_parent)\n-            }\n-        }?;\n-\n-        let child_name = src.value.name()?.as_name();\n-        let def_map = db.crate_def_map(parent_module.id.krate);\n-        let child_id = def_map[parent_module.id.local_id].children.get(&child_name)?;\n-        Some(parent_module.with_module_id(*child_id))\n-    }\n-\n-    pub fn from_definition(db: &impl DefDatabase, src: InFile<ModuleSource>) -> Option<Self> {\n+    pub fn from_definition(db: &impl HirDatabase, src: InFile<ModuleSource>) -> Option<Self> {\n         let _p = profile(\"Module::from_definition\");\n+        let mut sb = crate::SourceBinder::new(db);\n         match src.value {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n-                return Module::from_declaration(\n-                    db,\n-                    InFile { file_id: src.file_id, value: module.clone() },\n-                );\n+                return sb.to_def(InFile { file_id: src.file_id, value: module.clone() });\n             }\n             ModuleSource::SourceFile(_) => (),\n         };"}, {"sha": "26eedbb2c55bdcc9bce7202a90957b9f6a42fa94", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -11,12 +11,15 @@ use hir_def::{\n     ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n     StaticId, StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n-use hir_expand::{AstId, InFile, MacroDefId, MacroDefKind};\n+use hir_expand::{name::AsName, AstId, InFile, MacroDefId, MacroDefKind};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, TextUnit};\n+use ra_syntax::{\n+    ast::{self, NameOwner},\n+    match_ast, AstNode, SyntaxNode, TextUnit,\n+};\n use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, Local, ModuleSource, SourceAnalyzer, TypeParam};\n+use crate::{db::HirDatabase, Local, Module, ModuleSource, SourceAnalyzer, TypeParam};\n \n pub struct SourceBinder<'a, DB> {\n     pub db: &'a DB,\n@@ -306,3 +309,38 @@ impl ToDef for ast::TypeParam {\n         Some(TypeParam { id })\n     }\n }\n+\n+impl ToDef for ast::Module {\n+    type Def = Module;\n+\n+    fn to_def<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<ast::Module>,\n+    ) -> Option<Module> {\n+        {\n+            let _p = profile(\"ast::Module::to_def\");\n+            let parent_declaration =\n+                src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n+\n+            let parent_module = match parent_declaration {\n+                Some(parent_declaration) => {\n+                    let src_parent = InFile { file_id: src.file_id, value: parent_declaration };\n+                    sb.to_def(src_parent)\n+                }\n+                None => {\n+                    let source_file = sb.db.parse(src.file_id.original_file(sb.db)).tree();\n+                    let src_parent = InFile {\n+                        file_id: src.file_id,\n+                        value: ModuleSource::SourceFile(source_file),\n+                    };\n+                    Module::from_definition(sb.db, src_parent)\n+                }\n+            }?;\n+\n+            let child_name = src.value.name()?.as_name();\n+            let def_map = sb.db.crate_def_map(parent_module.id.krate);\n+            let child_id = def_map[parent_module.id.local_id].children.get(&child_name)?;\n+            Some(parent_module.with_module_id(*child_id))\n+        }\n+    }\n+}"}, {"sha": "5a12a619c4ffbc64c30a91701b829581b77da55f", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -24,13 +24,14 @@ pub(crate) fn goto_definition(\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = descend_into_macros(db, position.file_id, original_token.clone());\n \n+    let mut sb = SourceBinder::new(db);\n     let nav_targets = match_ast! {\n         match (token.value.parent()) {\n             ast::NameRef(name_ref) => {\n-                reference_definition(db, token.with_value(&name_ref)).to_vec()\n+                reference_definition(&mut sb, token.with_value(&name_ref)).to_vec()\n             },\n             ast::Name(name) => {\n-                name_definition(db, token.with_value(&name))?\n+                name_definition(&mut sb, token.with_value(&name))?\n             },\n             _ => return None,\n         }\n@@ -67,57 +68,56 @@ impl ReferenceResult {\n }\n \n pub(crate) fn reference_definition(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     name_ref: InFile<&ast::NameRef>,\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let mut sb = SourceBinder::new(db);\n-    let name_kind = classify_name_ref(&mut sb, name_ref).map(|d| d.kind);\n+    let name_kind = classify_name_ref(sb, name_ref).map(|d| d.kind);\n     match name_kind {\n-        Some(Macro(it)) => return Exact(it.to_nav(db)),\n-        Some(Field(it)) => return Exact(it.to_nav(db)),\n-        Some(TypeParam(it)) => return Exact(it.to_nav(db)),\n-        Some(AssocItem(it)) => return Exact(it.to_nav(db)),\n-        Some(Local(it)) => return Exact(it.to_nav(db)),\n-        Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n+        Some(Macro(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Field(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(TypeParam(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(AssocItem(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Local(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Def(def)) => match NavigationTarget::from_def(sb.db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n         },\n         Some(SelfType(imp)) => {\n             // FIXME: ideally, this should point to the type in the impl, and\n             // not at the whole impl. And goto **type** definition should bring\n             // us to the actual type\n-            return Exact(imp.to_nav(db));\n+            return Exact(imp.to_nav(sb.db));\n         }\n         None => {}\n     };\n \n     // Fallback index based approach:\n-    let navs = crate::symbol_index::index_resolve(db, name_ref.value)\n+    let navs = crate::symbol_index::index_resolve(sb.db, name_ref.value)\n         .into_iter()\n-        .map(|s| s.to_nav(db))\n+        .map(|s| s.to_nav(sb.db))\n         .collect();\n     Approximate(navs)\n }\n \n-pub(crate) fn name_definition(\n-    db: &RootDatabase,\n+fn name_definition(\n+    sb: &mut SourceBinder<RootDatabase>,\n     name: InFile<&ast::Name>,\n ) -> Option<Vec<NavigationTarget>> {\n     let parent = name.value.syntax().parent()?;\n \n     if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n             let src = name.with_value(module);\n-            if let Some(child_module) = hir::Module::from_declaration(db, src) {\n-                let nav = child_module.to_nav(db);\n+            if let Some(child_module) = sb.to_def(src) {\n+                let nav = child_module.to_nav(sb.db);\n                 return Some(vec![nav]);\n             }\n         }\n     }\n \n-    if let Some(nav) = named_target(db, name.with_value(&parent)) {\n+    if let Some(nav) = named_target(sb.db, name.with_value(&parent)) {\n         return Some(vec![nav]);\n     }\n "}, {"sha": "cb7da1fffb20659b6132af9f09e4bf132f50027c", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn classify_name(\n                         hir::Module::from_definition(sb.db, src)\n                     } else {\n                         let src = name.with_value(it);\n-                        hir::Module::from_declaration(sb.db, src)\n+                        sb.to_def(src)\n                     }\n                 }?;\n                 Some(from_module_def(sb.db, def.into(), None))"}, {"sha": "626efb603958e7b16297093af5b1373573b794f4", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -63,7 +63,7 @@ fn rename_mod(\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n     let module_src = hir::InFile { file_id: position.file_id.into(), value: ast_module.clone() };\n-    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n+    if let Some(module) = hir::SourceBinder::new(db).to_def(module_src) {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.original_file(db);\n         match src.value {"}]}