{"sha": "56e8db476c437590f21be041c0e751ee185d8dd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZThkYjQ3NmM0Mzc1OTBmMjFiZTA0MWMwZTc1MWVlMTg1ZDhkZDA=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-24T16:13:02Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-25T09:10:42Z"}, "message": "new lint: inherent methods that should be trait impls (fixes #218)", "tree": {"sha": "3d4dec245577de6aabda5d2ba1ec4855dc4b8fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d4dec245577de6aabda5d2ba1ec4855dc4b8fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56e8db476c437590f21be041c0e751ee185d8dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56e8db476c437590f21be041c0e751ee185d8dd0", "html_url": "https://github.com/rust-lang/rust/commit/56e8db476c437590f21be041c0e751ee185d8dd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56e8db476c437590f21be041c0e751ee185d8dd0/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "802d56c46c9879da9a45f936b3b5160967e04381", "url": "https://api.github.com/repos/rust-lang/rust/commits/802d56c46c9879da9a45f936b3b5160967e04381", "html_url": "https://github.com/rust-lang/rust/commit/802d56c46c9879da9a45f936b3b5160967e04381"}], "stats": {"total": 145, "additions": 140, "deletions": 5}, "files": [{"sha": "9d86ece99d63b58954ad62672429469ffbd7bd78", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56e8db476c437590f21be041c0e751ee185d8dd0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/56e8db476c437590f21be041c0e751ee185d8dd0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=56e8db476c437590f21be041c0e751ee185d8dd0", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 45 lints included in this crate:\n+There are 46 lints included in this crate:\n \n name                     | default | meaning\n -------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -44,6 +44,7 @@ ptr_arg                  | allow   | fn arguments of the type `&Vec<...>` or `&S\n range_step_by_zero       | warn    | using Range::step_by(0), which produces an infinite iterator\n redundant_closure        | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n result_unwrap_used       | allow   | using `Result.unwrap()`, which might be better handled\n+should_implement_trait   | warn    | defining a method that should be implementing a std trait\n single_match             | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n str_to_string            | warn    | using `to_string()` on a str, which should be `to_owned()`\n string_add               | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead"}, {"sha": "bacff19addc1473a9975b8f54cbaa0e9fa271495", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56e8db476c437590f21be041c0e751ee185d8dd0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8db476c437590f21be041c0e751ee185d8dd0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=56e8db476c437590f21be041c0e751ee185d8dd0", "patch": "@@ -92,6 +92,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n+        methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n         misc::CMP_NAN,"}, {"sha": "73cf81fbdaecb1f42e212aaa4393bd08cc88898f", "filename": "src/methods.rs", "status": "modified", "additions": 116, "deletions": 2, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/56e8db476c437590f21be041c0e751ee185d8dd0/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8db476c437590f21be041c0e751ee185d8dd0/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=56e8db476c437590f21be041c0e751ee185d8dd0", "patch": "@@ -2,9 +2,12 @@ use syntax::ast::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_type, walk_ptrs_ty};\n+use utils::{span_lint, match_path, match_type, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n+use self::SelfKind::*;\n+use self::OutType::*;\n+\n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n \n@@ -16,10 +19,13 @@ declare_lint!(pub STR_TO_STRING, Warn,\n               \"using `to_string()` on a str, which should be `to_owned()`\");\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n+declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n+              \"defining a method that should be implementing a std trait\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n+        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n+                    SHOULD_IMPLEMENT_TRAIT)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -46,4 +52,112 @@ impl LintPass for MethodsPass {\n             }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n+            for item in items {\n+                let name = item.ident.name;\n+                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                    if_let_chain! {\n+                        [\n+                            name == method_name,\n+                            let MethodImplItem(ref sig, _) = item.node,\n+                            sig.decl.inputs.len() == n_args,\n+                            out_type.matches(&sig.decl.output),\n+                            self_kind.matches(&sig.explicit_self.node)\n+                        ], {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n+    (\"add\",        2, ValueSelf,  AnyType,  \"std::ops::Add`\"),\n+    (\"sub\",        2, ValueSelf,  AnyType,  \"std::ops::Sub\"),\n+    (\"mul\",        2, ValueSelf,  AnyType,  \"std::ops::Mul\"),\n+    (\"div\",        2, ValueSelf,  AnyType,  \"std::ops::Div\"),\n+    (\"rem\",        2, ValueSelf,  AnyType,  \"std::ops::Rem\"),\n+    (\"shl\",        2, ValueSelf,  AnyType,  \"std::ops::Shl\"),\n+    (\"shr\",        2, ValueSelf,  AnyType,  \"std::ops::Shr\"),\n+    (\"bitand\",     2, ValueSelf,  AnyType,  \"std::ops::BitAnd\"),\n+    (\"bitor\",      2, ValueSelf,  AnyType,  \"std::ops::BitOr\"),\n+    (\"bitxor\",     2, ValueSelf,  AnyType,  \"std::ops::BitXor\"),\n+    (\"neg\",        1, ValueSelf,  AnyType,  \"std::ops::Neg\"),\n+    (\"not\",        1, ValueSelf,  AnyType,  \"std::ops::Not\"),\n+    (\"drop\",       1, RefMutSelf, UnitType, \"std::ops::Drop\"),\n+    (\"index\",      2, RefSelf,    RefType,  \"std::ops::Index\"),\n+    (\"index_mut\",  2, RefMutSelf, RefType,  \"std::ops::IndexMut\"),\n+    (\"deref\",      1, RefSelf,    RefType,  \"std::ops::Deref\"),\n+    (\"deref_mut\",  1, RefMutSelf, RefType,  \"std::ops::DerefMut\"),\n+    (\"clone\",      1, RefSelf,    AnyType,  \"std::clone::Clone\"),\n+    (\"borrow\",     1, RefSelf,    RefType,  \"std::borrow::Borrow\"),\n+    (\"borrow_mut\", 1, RefMutSelf, RefType,  \"std::borrow::BorrowMut\"),\n+    (\"as_ref\",     1, RefSelf,    RefType,  \"std::convert::AsRef\"),\n+    (\"as_mut\",     1, RefMutSelf, RefType,  \"std::convert::AsMut\"),\n+    (\"eq\",         2, RefSelf,    BoolType, \"std::cmp::PartialEq\"),\n+    (\"cmp\",        2, RefSelf,    AnyType,  \"std::cmp::Ord\"),\n+    (\"default\",    0, NoSelf,     AnyType,  \"std::default::Default\"),\n+    (\"hash\",       2, RefSelf,    UnitType, \"std::hash::Hash\"),\n+    (\"next\",       1, RefMutSelf, AnyType,  \"std::iter::Iterator\"),\n+    (\"into_iter\",  1, ValueSelf,  AnyType,  \"std::iter::IntoIterator\"),\n+    (\"from_iter\",  1, NoSelf,     AnyType,  \"std::iter::FromIterator\"),\n+    (\"from_str\",   1, NoSelf,     AnyType,  \"std::str::FromStr\"),\n+];\n+\n+#[derive(Clone, Copy)]\n+enum SelfKind {\n+    ValueSelf,\n+    RefSelf,\n+    RefMutSelf,\n+    NoSelf\n+}\n+\n+impl SelfKind {\n+    fn matches(&self, slf: &ExplicitSelf_) -> bool {\n+        match (self, slf) {\n+            (&ValueSelf, &SelfValue(_)) => true,\n+            (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n+            (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n+            (&NoSelf, &SelfStatic) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OutType {\n+    UnitType,\n+    BoolType,\n+    AnyType,\n+    RefType,\n+}\n+\n+impl OutType {\n+    fn matches(&self, ty: &FunctionRetTy) -> bool {\n+        match (self, ty) {\n+            (&UnitType, &DefaultReturn(_)) => true,\n+            (&UnitType, &Return(ref ty)) if ty.node == TyTup(vec![]) => true,\n+            (&BoolType, &Return(ref ty)) if is_bool(ty) => true,\n+            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![])  => true,\n+            (&RefType, &Return(ref ty)) => {\n+                if let TyRptr(_, _) = ty.node { true } else { false }\n+            }\n+            _ => false\n+        }\n+    }\n+}\n+\n+fn is_bool(ty: &Ty) -> bool {\n+    if let TyPath(None, ref p) = ty.node {\n+        if match_path(p, &[\"bool\"]) {\n+            return true;\n+        }\n+    }\n+    false\n }"}, {"sha": "cb77d79f0ff910cd20b52dc9bdbda62c40c8dbd6", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56e8db476c437590f21be041c0e751ee185d8dd0/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8db476c437590f21be041c0e751ee185d8dd0/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=56e8db476c437590f21be041c0e751ee185d8dd0", "patch": "@@ -1,8 +1,27 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#[deny(option_unwrap_used, result_unwrap_used)]\n-#[deny(str_to_string, string_to_string)]\n+#![allow(unused)]\n+#![deny(clippy)]\n+\n+use std::ops::Mul;\n+\n+struct T;\n+\n+impl T {\n+    fn add(self, other: T) -> T { self } //~ERROR defining a method called `add`\n+    fn drop(&mut self) { } //~ERROR defining a method called `drop`\n+\n+    fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+    fn div(self) -> T { self } // no error, different #arguments\n+    fn rem(self, other: T) { } // no error, wrong return type\n+}\n+\n+impl Mul<T> for T {\n+    type Output = T;\n+    fn mul(self, other: T) -> T { self } // no error, obviously\n+}\n+\n fn main() {\n     let opt = Some(0);\n     let _ = opt.unwrap();  //~ERROR used unwrap() on an Option"}]}