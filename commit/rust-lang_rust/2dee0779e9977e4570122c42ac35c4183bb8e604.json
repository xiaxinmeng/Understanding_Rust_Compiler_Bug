{"sha": "2dee0779e9977e4570122c42ac35c4183bb8e604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZWUwNzc5ZTk5NzdlNDU3MDEyMmM0MmFjMzVjNDE4M2JiOGU2MDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T13:43:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-26T13:43:15Z"}, "message": "Merge pull request #3314 from edwin0cheng/original-range-recursive\n\nAdd recursive macro support in `original_range`", "tree": {"sha": "27fb867641ee0c771ae230fc60eff8bb979dc295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27fb867641ee0c771ae230fc60eff8bb979dc295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dee0779e9977e4570122c42ac35c4183bb8e604", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeVnXzCRBK7hj4Ov3rIwAAdHIIABSBpZ/bwaY0+PqxE6R7MozS\nEDLkgMHH/WqG2LfS5Ug7fIOFIH4nWVlJCioxfFpLb3lKbW07AhnRUgBDRURowL1R\nwXPuHlXdCm88yNA40w3DQhcHgztq2UNI9OuzAX5wT56VjJpTQOBGsqn5BInPBtcI\n/hSmNhLgPthKbEaNMPHb8E5uIBAwIxmC2LsiMC6XUZ3VNzBa46akLU1OydjX/LS9\nNT8deLQ5eJv2SXMwg1YyEYh7CPWBaXyhJJwnVoGXynJLmC1SRGsN9AxMimxDjIT/\nvNnWIpEfn2Y9ijYxdikKqS0jEnzRfIwPT4aWUTPk55ZgxPbZY0H+6uaXL3pUuso=\n=cmNa\n-----END PGP SIGNATURE-----\n", "payload": "tree 27fb867641ee0c771ae230fc60eff8bb979dc295\nparent 9b11c183ed41676bce00e8550707b6552184f30b\nparent 871dc2bd3cec11f76a4ef93ac3438af80fb6e776\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1582724595 +0100\ncommitter GitHub <noreply@github.com> 1582724595 +0100\n\nMerge pull request #3314 from edwin0cheng/original-range-recursive\n\nAdd recursive macro support in `original_range`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dee0779e9977e4570122c42ac35c4183bb8e604", "html_url": "https://github.com/rust-lang/rust/commit/2dee0779e9977e4570122c42ac35c4183bb8e604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dee0779e9977e4570122c42ac35c4183bb8e604/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b11c183ed41676bce00e8550707b6552184f30b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b11c183ed41676bce00e8550707b6552184f30b", "html_url": "https://github.com/rust-lang/rust/commit/9b11c183ed41676bce00e8550707b6552184f30b"}, {"sha": "871dc2bd3cec11f76a4ef93ac3438af80fb6e776", "url": "https://api.github.com/repos/rust-lang/rust/commits/871dc2bd3cec11f76a4ef93ac3438af80fb6e776", "html_url": "https://github.com/rust-lang/rust/commit/871dc2bd3cec11f76a4ef93ac3438af80fb6e776"}], "stats": {"total": 71, "additions": 57, "deletions": 14}, "files": [{"sha": "0b40bf9afadab97a9faa4aad31f8723dc134acbf", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2dee0779e9977e4570122c42ac35c4183bb8e604/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dee0779e9977e4570122c42ac35c4183bb8e604/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=2dee0779e9977e4570122c42ac35c4183bb8e604", "patch": "@@ -7,7 +7,10 @@ use hir_def::{\n     DefWithBodyId, TraitId,\n };\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n+use ra_syntax::{\n+    algo::find_covering_element, ast, match_ast, AstNode, NodeOrToken, SyntaxElement, SyntaxNode,\n+    SyntaxToken, TextRange, TextUnit,\n+};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n@@ -333,10 +336,27 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?\n pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n-    if let Some((range, Origin::Call)) = original_range_and_origin(db, node) {\n-        return range;\n+    let mut elem: InFile<SyntaxElement> = node.map(|n| n.clone().into());\n+\n+    while let Some((range, Origin::Call)) = original_range_and_origin(db, elem.as_ref()) {\n+        let original_file = range.file_id.original_file(db);\n+\n+        if range.file_id == original_file.into() {\n+            return FileRange { file_id: original_file, range: range.value };\n+        }\n+\n+        if range.file_id != elem.file_id {\n+            if let Some(root) = db.parse_or_expand(range.file_id) {\n+                elem = range.with_value(find_covering_element(&root, range.value));\n+                continue;\n+            }\n+        }\n+\n+        log::error!(\"Fail to mapping up more for {:?}\", range);\n+        return FileRange { file_id: range.file_id.original_file(db), range: range.value };\n     }\n \n+    // Fall back to whole macro call\n     if let Some(expansion) = node.file_id.expansion_info(db) {\n         if let Some(call_node) = expansion.call_node() {\n             return FileRange {\n@@ -351,15 +371,22 @@ pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileR\n \n fn original_range_and_origin(\n     db: &impl HirDatabase,\n-    node: InFile<&SyntaxNode>,\n-) -> Option<(FileRange, Origin)> {\n-    let expansion = node.file_id.expansion_info(db)?;\n+    elem: InFile<&SyntaxElement>,\n+) -> Option<(InFile<TextRange>, Origin)> {\n+    let expansion = elem.file_id.expansion_info(db)?;\n+\n+    let node = match elem.as_ref().value {\n+        NodeOrToken::Node(it) => elem.with_value(it),\n+        NodeOrToken::Token(it) => {\n+            let (tt, origin) = expansion.map_token_up(elem.with_value(it))?;\n+            return Some((tt.map(|it| it.text_range()), origin));\n+        }\n+    };\n \n     // the input node has only one token ?\n     let single = node.value.first_token()? == node.value.last_token()?;\n \n-    // FIXME: We should handle recurside macro expansions\n-    let (range, origin) = node.value.descendants().find_map(|it| {\n+    return Some(node.value.descendants().find_map(|it| {\n         let first = it.first_token()?;\n         let last = it.last_token()?;\n \n@@ -380,12 +407,7 @@ fn original_range_and_origin(\n             first.with_value(union_range(first.value.text_range(), last.value.text_range())),\n             first_origin,\n         ))\n-    })?;\n-\n-    return Some((\n-        FileRange { file_id: range.file_id.original_file(db), range: range.value },\n-        origin,\n-    ));\n+    })?);\n \n     fn union_range(a: TextRange, b: TextRange) -> TextRange {\n         let start = a.start().min(b.start());"}, {"sha": "29b16e602f9821bdc0f4dd64d830ffef8b6da773", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2dee0779e9977e4570122c42ac35c4183bb8e604/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dee0779e9977e4570122c42ac35c4183bb8e604/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=2dee0779e9977e4570122c42ac35c4183bb8e604", "patch": "@@ -753,6 +753,27 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         assert_eq!(hover_on, \"bar\")\n     }\n \n+    #[test]\n+    fn test_hover_through_expr_in_macro_recursive() {\n+        let hover_on = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            macro_rules! id_deep {\n+                ($($tt:tt)*) => { $($tt)* }\n+            }\n+            macro_rules! id {\n+                ($($tt:tt)*) => { id_deep!($($tt)*) }\n+            }\n+            fn foo(bar:u32) {\n+                let a = id!(ba<|>r);\n+            }\n+            \",\n+            &[\"u32\"],\n+        );\n+\n+        assert_eq!(hover_on, \"bar\")\n+    }\n+\n     #[test]\n     fn test_hover_non_ascii_space_doc() {\n         check_hover_result("}]}