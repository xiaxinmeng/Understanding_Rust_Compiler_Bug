{"sha": "63ed62531324cd4660deb7faff58e6c17b93b487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZWQ2MjUzMTMyNGNkNDY2MGRlYjdmYWZmNThlNmMxN2I5M2I0ODc=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-31T14:46:23Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-08-02T17:09:37Z"}, "message": "Implement pointer casting.", "tree": {"sha": "8e2743bf8f7a120bdff376a45e9f21d396414837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e2743bf8f7a120bdff376a45e9f21d396414837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ed62531324cd4660deb7faff58e6c17b93b487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ed62531324cd4660deb7faff58e6c17b93b487", "html_url": "https://github.com/rust-lang/rust/commit/63ed62531324cd4660deb7faff58e6c17b93b487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ed62531324cd4660deb7faff58e6c17b93b487/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "html_url": "https://github.com/rust-lang/rust/commit/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f"}], "stats": {"total": 344, "additions": 256, "deletions": 88}, "files": [{"sha": "d594731b4dfce5870bc9358d0a5edf466f64fe60", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -25,39 +25,73 @@ pub(crate) fn unsized_info<'tcx>(\n             .bcx\n             .ins()\n             .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            let old_info =\n+                old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n+            if data_a.principal_def_id() == data_b.principal_def_id() {\n+                return old_info;\n+            }\n+            // trait upcasting coercion\n+\n+            // if both of the two `principal`s are `None`, this function would have returned early above.\n+            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n+            let principal_a = data_a\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+            let principal_b = data_b\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+\n+            let vptr_entry_idx = fx.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                principal_a.with_self_ty(fx.tcx, source),\n+                principal_b.with_self_ty(fx.tcx, source),\n+            ));\n+\n+            if let Some(entry_idx) = vptr_entry_idx {\n+                let entry_idx = u32::try_from(entry_idx).unwrap();\n+                let entry_offset = entry_idx * fx.pointer_type.bytes();\n+                let vptr_ptr = Pointer::new(old_info).offset_i64(fx, entry_offset.into()).load(\n+                    fx,\n+                    fx.pointer_type,\n+                    crate::vtable::vtable_memflags(),\n+                );\n+                vptr_ptr\n+            } else {\n+                old_info\n+            }\n         }\n         (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-fn unsize_thin_ptr<'tcx>(\n+/// Coerce `src` to `dst_ty`.\n+fn unsize_ptr<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n+    old_info: Option<Value>,\n ) -> (Value, Value) {\n     match (&src_layout.ty.kind(), &dst_layout.ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n+            if src_layout == dst_layout {\n+                return (src, old_info.unwrap());\n+            }\n+\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(fx, i);\n@@ -71,11 +105,11 @@ fn unsize_thin_ptr<'tcx>(\n                 let dst_f = dst_layout.field(fx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(fx, src, src_f, dst_f));\n+                result = Some(unsize_ptr(fx, src, src_f, dst_f, old_info));\n             }\n             result.unwrap()\n         }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_ptr: called on bad types\"),\n     }\n }\n \n@@ -91,12 +125,11 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     let mut coerce_ptr = || {\n         let (base, info) =\n             if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                src.load_scalar_pair(fx)\n+                let (old_base, old_info) = src.load_scalar_pair(fx);\n+                unsize_ptr(fx, old_base, src.layout(), dst.layout(), Some(old_info))\n             } else {\n                 let base = src.load_scalar(fx);\n-                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+                unsize_ptr(fx, base, src.layout(), dst.layout(), None)\n             };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };"}, {"sha": "1b31587430887e3931829a4c81f3c86e109e1b75", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -5,7 +5,7 @@\n use crate::constant::data_id_for_alloc_id;\n use crate::prelude::*;\n \n-fn vtable_memflags() -> MemFlags {\n+pub(crate) fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n     flags.set_readonly(); // A vtable is always read-only.\n     flags"}, {"sha": "87b342e844391be3f004949e120fb518be45e2a1", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::lang_items;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n-use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n@@ -32,6 +31,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n+use std::convert::TryFrom;\n use std::ops::{Deref, DerefMut};\n use std::time::{Duration, Instant};\n \n@@ -128,55 +128,92 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ///\n /// The `old_info` argument is a bit odd. It is intended for use in an upcast,\n /// where the new vtable for an object will be derived from the old one.\n-pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n+pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n-    old_info: Option<Cx::Value>,\n-) -> Cx::Value {\n+    old_info: Option<Bx::Value>,\n+) -> Bx::Value {\n+    let cx = bx.cx();\n     let (source, target) =\n-        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n+        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, bx.param_env());\n     match (source.kind(), target.kind()) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            let old_info =\n+                old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n+            if data_a.principal_def_id() == data_b.principal_def_id() {\n+                return old_info;\n+            }\n+\n+            // trait upcasting coercion\n+\n+            // if both of the two `principal`s are `None`, this function would have returned early above.\n+            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n+            let principal_a = data_a\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+            let principal_b = data_b\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+\n+            let vptr_entry_idx = cx.tcx().vtable_trait_upcasting_coercion_new_vptr_slot((\n+                principal_a.with_self_ty(cx.tcx(), source),\n+                principal_b.with_self_ty(cx.tcx(), source),\n+            ));\n+\n+            if let Some(entry_idx) = vptr_entry_idx {\n+                let ptr_ty = cx.type_i8p();\n+                let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n+                let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n+                let gep =\n+                    bx.inbounds_gep(llvtable, &[bx.const_usize(u64::try_from(entry_idx).unwrap())]);\n+                let new_vptr = bx.load(ptr_ty, gep, ptr_align);\n+                bx.nonnull_metadata(new_vptr);\n+                // Vtable loads are invariant.\n+                bx.set_invariant_load(new_vptr);\n+                new_vptr\n+            } else {\n+                old_info\n+            }\n         }\n         (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target)).field(cx, FAT_PTR_EXTRA);\n-            cx.const_ptrcast(\n-                meth::get_vtable(cx, source, data.principal()),\n-                cx.backend_type(vtable_ptr),\n-            )\n+            let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n+                cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n+                1,\n+                true,\n+            );\n+            cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()), vtable_ptr_ty)\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n-/// Coerces `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+/// Coerces `src` to `dst_ty`. `src_ty` must be a pointer.\n+pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: Bx::Value,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>,\n+    old_info: Option<Bx::Value>,\n ) -> (Bx::Value, Bx::Value) {\n-    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    debug!(\"unsize_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bx.cx().type_is_sized(a));\n+            assert_eq!(bx.cx().type_is_sized(a), old_info.is_none());\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n-\n             let src_layout = bx.cx().layout_of(src_ty);\n             let dst_layout = bx.cx().layout_of(dst_ty);\n+            if src_ty == dst_ty {\n+                return (src, old_info.unwrap());\n+            }\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(bx.cx(), i);\n@@ -190,18 +227,15 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 let dst_f = dst_layout.field(bx.cx(), i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n+                result = Some(unsize_ptr(bx, src, src_f.ty, dst_f.ty, old_info));\n             }\n             let (lldata, llextra) = result.unwrap();\n+            let lldata_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true);\n+            let llextra_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true);\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            // FIXME(eddyb) move these out of this `match` arm, so they're always\n-            // applied, uniformly, no matter the source/destination types.\n-            (\n-                bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n-                bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)),\n-            )\n+            (bx.bitcast(lldata, lldata_ty), bx.bitcast(llextra, llextra_ty))\n         }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_ptr: called on bad types\"),\n     }\n }\n \n@@ -217,17 +251,8 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(..), &ty::Ref(..) | &ty::RawPtr(..)) | (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             let (base, info) = match bx.load_operand(src).val {\n-                OperandValue::Pair(base, info) => {\n-                    // fat-ptr to fat-ptr unsize preserves the vtable\n-                    // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                    // So we need to pointercast the base to ensure\n-                    // the types match up.\n-                    // FIXME(eddyb) use `scalar_pair_element_backend_type` here,\n-                    // like `unsize_thin_ptr` does.\n-                    let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n-                    (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-                }\n-                OperandValue::Immediate(base) => unsize_thin_ptr(bx, base, src_ty, dst_ty),\n+                OperandValue::Pair(base, info) => unsize_ptr(bx, base, src_ty, dst_ty, Some(info)),\n+                OperandValue::Immediate(base) => unsize_ptr(bx, base, src_ty, dst_ty, None),\n                 OperandValue::Ref(..) => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);"}, {"sha": "7e1dfeb2457ebb88c17f24ac56931cf1d17fa3c6", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -220,34 +220,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                     mir::CastKind::Pointer(PointerCast::Unsize) => {\n                         assert!(bx.cx().is_backend_scalar_pair(cast));\n-                        match operand.val {\n+                        let (lldata, llextra) = match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer -- this is a\n-                                // \"trait-object-to-supertrait\" coercion, for\n-                                // example, `&'a fmt::Debug + Send => &'a fmt::Debug`.\n-\n-                                // HACK(eddyb) have to bitcast pointers\n-                                // until LLVM removes pointee types.\n-                                let lldata = bx.pointercast(\n-                                    lldata,\n-                                    bx.cx().scalar_pair_element_backend_type(cast, 0, true),\n-                                );\n-                                OperandValue::Pair(lldata, llextra)\n+                                // \"trait-object-to-supertrait\" coercion.\n+                                (lldata, Some(llextra))\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n-                                let (lldata, llextra) = base::unsize_thin_ptr(\n-                                    &mut bx,\n-                                    lldata,\n-                                    operand.layout.ty,\n-                                    cast.ty,\n-                                );\n-                                OperandValue::Pair(lldata, llextra)\n+                                (lldata, None)\n                             }\n                             OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\", operand);\n                             }\n-                        }\n+                        };\n+                        let (lldata, llextra) =\n+                            base::unsize_ptr(&mut bx, lldata, operand.layout.ty, cast.ty, llextra);\n+                        OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n                     | mir::CastKind::Misc"}, {"sha": "3c16852df059a9ee6b6938cd9bb7fdffaf252679", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -977,6 +977,11 @@ rustc_queries! {\n         desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n     }\n \n+    query vtable_trait_upcasting_coercion_new_vptr_slot(key: (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>)) -> Option<usize> {\n+        desc { |tcx| \"finding the slot within vtable for trait {} vtable ptr during trait upcasting coercion from {} vtable\",\n+            tcx.def_path_str(key.1.def_id()), tcx.def_path_str(key.0.def_id()) }\n+    }\n+\n     query codegen_fulfill_obligation(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n     ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {"}, {"sha": "cee4c2e30aa0973c019918601828caeed5a8f025", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -269,12 +269,34 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n-            (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-                // For now, upcasts are limited to changes in marker\n-                // traits, and hence never actually require an actual\n-                // change to the vtable.\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let val = self.read_immediate(src)?;\n-                self.write_immediate(*val, dest)\n+                if data_a.principal_def_id() == data_b.principal_def_id() {\n+                    return self.write_immediate(*val, dest);\n+                }\n+                // trait upcasting coercion\n+                let principal_a = data_a.principal().expect(\n+                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n+                );\n+                let principal_b = data_b.principal().expect(\n+                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n+                );\n+\n+                let vptr_entry_idx = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                    principal_a.with_self_ty(*self.tcx, src_pointee_ty),\n+                    principal_b.with_self_ty(*self.tcx, src_pointee_ty),\n+                ));\n+\n+                if let Some(entry_idx) = vptr_entry_idx {\n+                    let entry_idx = u64::try_from(entry_idx).unwrap();\n+                    let (old_data, old_vptr) = val.to_scalar_pair()?;\n+                    let old_vptr = self.scalar_to_ptr(old_vptr);\n+                    let new_vptr = self\n+                        .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n+                    self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n+                } else {\n+                    self.write_immediate(*val, dest)\n+                }\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait"}, {"sha": "bd6ee4a37e3d48e4a976e201562a34a980cb6844", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -79,6 +79,16 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n+\n+    #[inline]\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+        match self {\n+            Immediate::ScalarPair(val1, val2) => Ok((val1.check_init()?, val2.check_init()?)),\n+            Immediate::Scalar(..) => {\n+                bug!(\"Got a scalar where a wide pointer was expected\")\n+            }\n+        }\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "041be9814a3d6d32f3050d7f332e948d2fefc32a", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -121,4 +121,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         Ok((Size::from_bytes(size), align))\n     }\n+\n+    pub fn read_new_vtable_after_trait_upcasting_from_vtable(\n+        &self,\n+        vtable: Pointer<Option<M::PointerTag>>,\n+        idx: u64,\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        let pointer_size = self.pointer_size();\n+\n+        let vtable = self\n+            .memory\n+            .get(\n+                vtable,\n+                pointer_size * idx.checked_add(1).unwrap(),\n+                self.tcx.data_layout.pointer_align.abi,\n+            )?\n+            .expect(\"cannot be a ZST\");\n+        let new_vtable = self\n+            .scalar_to_ptr(vtable.read_ptr_sized(pointer_size * idx)?.check_init()?)\n+            .into_pointer_or_addr()\n+            .expect(\"should be a pointer\");\n+\n+        Ok(new_vtable)\n+    }\n }"}, {"sha": "ace7cffd16dafb3c22168a5fc8edcc89bc79e34e", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -282,6 +282,16 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.def_id().krate == LOCAL_CRATE\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.0.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for GenericArg<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "585fcf795b7f5fb2cd0cf22615edfbfcffc68183", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -756,16 +756,17 @@ fn vtable_trait_first_method_offset<'tcx>(\n }\n \n /// Find slot offset for trait vptr within vtable entries of another trait\n-/// FIXME: This function is not yet used. Remove `#[allow(dead_code)]` when it's used in upcoming pr.\n-#[allow(dead_code)]\n-fn vtable_trait_vptr_slot_offset<'tcx>(\n+pub fn vtable_trait_upcasting_coercion_new_vptr_slot(\n     tcx: TyCtxt<'tcx>,\n     key: (\n-        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n-        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+        ty::PolyTraitRef<'tcx>, // trait owning vtable\n+        ty::PolyTraitRef<'tcx>, // super trait ref\n     ),\n ) -> Option<usize> {\n-    let (trait_to_be_found, trait_owning_vtable) = key;\n+    let (trait_owning_vtable, super_trait_ref) = key;\n+    let super_trait_did = super_trait_ref.def_id();\n+    // FIXME: take substsref part into account here after upcasting coercion allows the same def_id occur\n+    // multiple times.\n \n     let vtable_segment_callback = {\n         let mut vptr_offset = 0;\n@@ -776,7 +777,7 @@ fn vtable_trait_vptr_slot_offset<'tcx>(\n                 }\n                 VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                     vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if trait_ref == trait_to_be_found {\n+                    if trait_ref.def_id() == super_trait_did {\n                         if emit_vptr {\n                             return ControlFlow::Break(Some(vptr_offset));\n                         } else {\n@@ -810,6 +811,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specializes: specialize::specializes,\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n         vtable_entries,\n+        vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         mir_abstract_const: |tcx, def_id| {\n             let def_id = def_id.expect_local();"}, {"sha": "1164e43611a1d20aefcfa69032ba626c96c4d2ec", "filename": "src/test/ui/traits/trait-upcasting/replace-vptr.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/63ed62531324cd4660deb7faff58e6c17b93b487/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ed62531324cd4660deb7faff58e6c17b93b487/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs?ref=63ed62531324cd4660deb7faff58e6c17b93b487", "patch": "@@ -0,0 +1,49 @@\n+// run-pass\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait A {\n+    fn foo_a(&self);\n+}\n+\n+trait B {\n+    fn foo_b(&self);\n+}\n+\n+trait C: A + B {\n+    fn foo_c(&self);\n+}\n+\n+struct S(i32);\n+\n+impl A for S {\n+    fn foo_a(&self) {\n+        unreachable!();\n+    }\n+}\n+\n+impl B for S {\n+    fn foo_b(&self) {\n+        assert_eq!(42, self.0);\n+    }\n+}\n+\n+impl C for S {\n+    fn foo_c(&self) {\n+        unreachable!();\n+    }\n+}\n+\n+fn invoke_inner(b: &dyn B) {\n+    b.foo_b();\n+}\n+\n+fn invoke_outer(c: &dyn C) {\n+    invoke_inner(c);\n+}\n+\n+fn main() {\n+    let s = S(42);\n+    invoke_outer(&s);\n+}"}]}