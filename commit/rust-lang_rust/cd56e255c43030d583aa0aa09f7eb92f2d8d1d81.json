{"sha": "cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNTZlMjU1YzQzMDMwZDU4M2FhMGFhMDlmN2ViOTJmMmQ4ZDFkODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-09T01:50:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-09T01:50:01Z"}, "message": "Auto merge of #83870 - jackh726:binder-refactor-fix, r=nikomatsakis\n\nDon't concatenate binders across types\n\nPartially addresses #83737\n\nThere's actually two issues that I uncovered in #83737. The first is that we are concatenating bound vars across types, i.e. in\n```\nF: Fn(&()) -> &mut (dyn Future<Output = ()> + Unpin)\n```\nthe bound vars on `Future` get set as `for<anon>` since those are the binders on `Fn(&()`. This is obviously wrong, since we should only concatenate directly nested trait refs. This is solved here by introducing a new `TraitRefBoundary` scope, that we put around the \"syntactical\" trait refs and basically don't allow concatenation across.\n\nNow, this alone *shouldn't* be a super terrible problem. At least not until you consider the other issue, which is a much more elusive and harder to design a \"perfect\" fix. A repro can be seen in:\n```\nuse core::future::Future;\n\nasync fn handle<F>(slf: &F)\nwhere\n    F: Fn(&()) -> &mut (dyn for<'a> Future<Output = ()> + Unpin),\n{\n    (slf)(&()).await;\n}\n```\nNotice the `for<'a>` around `Future`. Here, `'a` is unused, so the `for<'a>` Binder gets changed to a `for<>` Binder in the generator witness, but the \"local decl\" still has it. This has heavy intersections with region anonymization and erasing. Luckily, it's not *super* common to find this unique set of circumstances. It only became apparently because of the first issue mentioned here. However, this *is* still a problem, so I'm leaving #83737 open.\n\nr? `@nikomatsakis`", "tree": {"sha": "b4cfedb97c10d5d7aabfc3562c53a0c8ddcbb03b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4cfedb97c10d5d7aabfc3562c53a0c8ddcbb03b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "html_url": "https://github.com/rust-lang/rust/commit/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "619d19c3181e4793de789302d60a0343f0081139", "url": "https://api.github.com/repos/rust-lang/rust/commits/619d19c3181e4793de789302d60a0343f0081139", "html_url": "https://github.com/rust-lang/rust/commit/619d19c3181e4793de789302d60a0343f0081139"}, {"sha": "c1dc0b7bbc239290388d2365c6d0b282e299bdbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1dc0b7bbc239290388d2365c6d0b282e299bdbc", "html_url": "https://github.com/rust-lang/rust/commit/c1dc0b7bbc239290388d2365c6d0b282e299bdbc"}], "stats": {"total": 323, "additions": 237, "deletions": 86}, "files": [{"sha": "1989c91a87962dbdcc253d2f2173254fd621ca11", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 87, "deletions": 22, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "patch": "@@ -1804,29 +1804,94 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n-        let new_value = self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-            let _ = start_or_continue(&mut self, \"for<\", \", \");\n-            let kind = match br.kind {\n-                ty::BrNamed(_, name) => {\n-                    let _ = write!(self, \"{}\", name);\n-                    br.kind\n-                }\n-                ty::BrAnon(_) | ty::BrEnv => {\n-                    let name = loop {\n-                        let name = name_by_region_index(region_index);\n-                        region_index += 1;\n-                        if !self.used_region_names.contains(&name) {\n-                            break name;\n-                        }\n-                    };\n-                    let _ = write!(self, \"{}\", name);\n-                    ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+        // If we want to print verbosly, then print *all* binders, even if they\n+        // aren't named. Eventually, we might just want this as the default, but\n+        // this is not *quite* right and changes the ordering of some output\n+        // anyways.\n+        let new_value = if self.tcx().sess.verbose() {\n+            // anon index + 1 (BrEnv takes 0) -> name\n+            let mut region_map: BTreeMap<u32, Symbol> = BTreeMap::default();\n+            let bound_vars = value.bound_vars();\n+            for var in bound_vars {\n+                match var {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(_, name)) => {\n+                        let _ = start_or_continue(&mut self, \"for<\", \", \");\n+                        let _ = write!(self, \"{}\", name);\n+                    }\n+                    ty::BoundVariableKind::Region(ty::BrAnon(i)) => {\n+                        let _ = start_or_continue(&mut self, \"for<\", \", \");\n+                        let name = loop {\n+                            let name = name_by_region_index(region_index);\n+                            region_index += 1;\n+                            if !self.used_region_names.contains(&name) {\n+                                break name;\n+                            }\n+                        };\n+                        let _ = write!(self, \"{}\", name);\n+                        region_map.insert(i + 1, name);\n+                    }\n+                    ty::BoundVariableKind::Region(ty::BrEnv) => {\n+                        let _ = start_or_continue(&mut self, \"for<\", \", \");\n+                        let name = loop {\n+                            let name = name_by_region_index(region_index);\n+                            region_index += 1;\n+                            if !self.used_region_names.contains(&name) {\n+                                break name;\n+                            }\n+                        };\n+                        let _ = write!(self, \"{}\", name);\n+                        region_map.insert(0, name);\n+                    }\n+                    _ => continue,\n                 }\n-            };\n-            self.tcx\n-                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n-        });\n-        start_or_continue(&mut self, \"\", \"> \")?;\n+            }\n+            start_or_continue(&mut self, \"\", \"> \")?;\n+\n+            self.tcx.replace_late_bound_regions(value.clone(), |br| {\n+                let kind = match br.kind {\n+                    ty::BrNamed(_, _) => br.kind,\n+                    ty::BrAnon(i) => {\n+                        let name = region_map[&(i + 1)];\n+                        ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                    }\n+                    ty::BrEnv => {\n+                        let name = region_map[&0];\n+                        ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                    }\n+                };\n+                self.tcx.mk_region(ty::ReLateBound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: br.var, kind },\n+                ))\n+            })\n+        } else {\n+            let new_value = self.tcx.replace_late_bound_regions(value.clone(), |br| {\n+                let _ = start_or_continue(&mut self, \"for<\", \", \");\n+                let kind = match br.kind {\n+                    ty::BrNamed(_, name) => {\n+                        let _ = write!(self, \"{}\", name);\n+                        br.kind\n+                    }\n+                    ty::BrAnon(_) | ty::BrEnv => {\n+                        let name = loop {\n+                            let name = name_by_region_index(region_index);\n+                            region_index += 1;\n+                            if !self.used_region_names.contains(&name) {\n+                                break name;\n+                            }\n+                        };\n+                        let _ = write!(self, \"{}\", name);\n+                        ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                    }\n+                };\n+                self.tcx.mk_region(ty::ReLateBound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: br.var, kind },\n+                ))\n+            });\n+            start_or_continue(&mut self, \"\", \"> \")?;\n+            new_value\n+        };\n \n         self.binder_depth += 1;\n         self.region_index = region_index;"}, {"sha": "003003a8abbeae90f8f736d89e8a3a504e271de8", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "patch": "@@ -751,9 +751,10 @@ fn sanitize_witness<'tcx>(\n             span_bug!(\n                 body.span,\n                 \"Broken MIR: generator contains type {} in MIR, \\\n-                       but typeck only knows about {}\",\n-                decl.ty,\n-                witness,\n+                       but typeck only knows about {} and {:?}\",\n+                decl_ty,\n+                allowed,\n+                allowed_upvars\n             );\n         }\n     }"}, {"sha": "91bc8ab5ef41da194936a68aada9b56da6639cf8", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 132, "deletions": 61, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "patch": "@@ -72,8 +72,8 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n-            \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n-            param, depth, def_id, origin,\n+            \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?} origin={:?}\",\n+            idx, param, depth, def_id, origin,\n         );\n         (\n             param.name.normalize_to_macros_2_0(),\n@@ -326,6 +326,10 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n+    TraitRefBoundary {\n+        s: ScopeRef<'a>,\n+    },\n+\n     Root,\n }\n \n@@ -374,6 +378,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetimes\", lifetimes)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n+            Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n             Scope::Root => f.debug_struct(\"Root\").finish(),\n         }\n     }\n@@ -877,9 +882,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n-                for bound in bounds {\n-                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                }\n+                let scope = Scope::TraitRefBoundary { s: self.scope };\n+                self.with(scope, |_, this| {\n+                    for bound in bounds {\n+                        this.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    }\n+                });\n                 match lifetime.name {\n                     LifetimeName::Implicit => {\n                         // For types like `dyn Foo`, we should\n@@ -1058,9 +1066,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n-                            for bound in bounds {\n-                                this.visit_param_bound(bound);\n-                            }\n+                            let scope = Scope::TraitRefBoundary { s: this.scope };\n+                            this.with(scope, |_, this| {\n+                                for bound in bounds {\n+                                    this.visit_param_bound(bound);\n+                                }\n+                            })\n                         });\n                     });\n                 } else {\n@@ -1074,10 +1085,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         from_poly_trait_ref: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n+                        let scope = Scope::TraitRefBoundary { s: this.scope };\n+                        this.with(scope, |_, this| {\n+                            this.visit_generics(generics);\n+                            for bound in bounds {\n+                                this.visit_param_bound(bound);\n+                            }\n+                        })\n                     });\n                 }\n             }\n@@ -1131,13 +1145,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n-                    this.visit_generics(generics);\n-                    for bound in bounds {\n-                        this.visit_param_bound(bound);\n-                    }\n-                    if let Some(ty) = ty {\n-                        this.visit_ty(ty);\n-                    }\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |_, this| {\n+                        this.visit_generics(generics);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                        if let Some(ty) = ty {\n+                            this.visit_ty(ty);\n+                        }\n+                    })\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n@@ -1197,8 +1214,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n-                    this.visit_generics(generics);\n-                    this.visit_ty(ty);\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |_, this| {\n+                        this.visit_generics(generics);\n+                        this.visit_ty(ty);\n+                    })\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n@@ -1292,29 +1312,31 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             })\n                             .unzip();\n                     self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                    if !lifetimes.is_empty() {\n-                        let next_early_index = self.next_early_index();\n-                        let scope = Scope::Binder {\n-                            hir_id: bounded_ty.hir_id,\n-                            lifetimes,\n-                            s: self.scope,\n-                            next_early_index,\n-                            track_lifetime_uses: true,\n-                            opaque_type_parent: false,\n-                            from_poly_trait_ref: true,\n-                        };\n-                        let result = self.with(scope, |old_scope, this| {\n-                            this.check_lifetime_params(old_scope, &bound_generic_params);\n+                    let scope = Scope::TraitRefBoundary { s: self.scope };\n+                    self.with(scope, |_, this| {\n+                        if !lifetimes.is_empty() {\n+                            let next_early_index = this.next_early_index();\n+                            let scope = Scope::Binder {\n+                                hir_id: bounded_ty.hir_id,\n+                                lifetimes,\n+                                s: this.scope,\n+                                next_early_index,\n+                                track_lifetime_uses: true,\n+                                opaque_type_parent: false,\n+                                from_poly_trait_ref: true,\n+                            };\n+                            this.with(scope, |old_scope, this| {\n+                                this.check_lifetime_params(old_scope, &bound_generic_params);\n+                                this.visit_ty(&bounded_ty);\n+                                this.trait_ref_hack = Some(bounded_ty.hir_id);\n+                                walk_list!(this, visit_param_bound, bounds);\n+                                this.trait_ref_hack = None;\n+                            })\n+                        } else {\n                             this.visit_ty(&bounded_ty);\n-                            this.trait_ref_hack = Some(bounded_ty.hir_id);\n                             walk_list!(this, visit_param_bound, bounds);\n-                            this.trait_ref_hack = None;\n-                        });\n-                        result\n-                    } else {\n-                        self.visit_ty(&bounded_ty);\n-                        walk_list!(self, visit_param_bound, bounds);\n-                    }\n+                        }\n+                    })\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     ref lifetime,\n@@ -1438,6 +1460,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         scope = s;\n                     }\n \n+                    Scope::TraitRefBoundary { .. } => {\n+                        // We should only see super trait lifetimes if there is a `Binder` above\n+                        assert!(supertrait_lifetimes.is_empty());\n+                        break vec![];\n+                    }\n+\n                     Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n                         if !from_poly_trait_ref {\n                             // We should only see super trait lifetimes if there is a `Binder` above\n@@ -1653,7 +1681,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n \n@@ -2261,7 +2290,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => scope = s,\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -2311,6 +2341,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n+                Scope::TraitRefBoundary { s, .. } => {\n+                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n+                    // We don't increase the late depth because this isn't a `Binder` scope.\n+                    //\n+                    // This came up in #83737, which boiled down to a case like this:\n+                    //\n+                    // ```\n+                    // F: for<> Fn(&()) -> Box<dyn for<> Future<Output = ()> + Unpin>,\n+                    //                         //  ^^^^^\n+\n+                    // ```\n+                    //\n+                    // Here, as we traverse upwards from the `dyn for<>` binder, we want to reset `in_poly_trait_ref`\n+                    // to false, so that we avoid excess contaenation when we encounter the outer `for<>`  binder.\n+                    in_poly_trait_ref = false;\n+                    scope = s;\n+                }\n+\n                 Scope::Binder { ref lifetimes, from_poly_trait_ref, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n@@ -2332,6 +2380,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         // We've already seen a binder that is a poly trait ref and this one is too,\n                         // that means that they are nested and we are concatenating the bound vars;\n                         // don't increase the late depth.\n+                        //\n+                        // This happens specifically with associated trait bounds like the following:\n+                        //\n+                        // ```\n+                        // for<'a> T: Iterator<Item: for<'b> Foo<'a, 'b>>\n+                        // ```\n+                        //\n+                        // In this case, as we traverse `for<'b>`, we would increment `late_depth` but\n+                        // set `in_poly_trait_ref` to true. Then when we traverse `for<'a>`, we would\n+                        // not increment `late_depth` again. (NB: Niko thinks this logic is actually\n+                        // wrong.)\n                         (true, true) => {}\n                         // We've exited nested poly trait refs; add one to the late depth and mark\n                         // that we are no longer in nested trait refs\n@@ -2504,7 +2563,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n                         | Scope::TraitRefHackInner { s, .. }\n-                        | Scope::Supertrait { s, .. } => {\n+                        | Scope::Supertrait { s, .. }\n+                        | Scope::TraitRefBoundary { s, .. } => {\n                             scope = s;\n                         }\n                     }\n@@ -2700,7 +2760,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { id, .. } => break id.hir_id,\n                 Scope::ObjectLifetimeDefault { ref s, .. }\n                 | Scope::Elision { ref s, .. }\n-                | Scope::Supertrait { ref s, .. } => {\n+                | Scope::Supertrait { ref s, .. }\n+                | Scope::TraitRefBoundary { ref s, .. } => {\n                     scope = *s;\n                 }\n                 Scope::Root => bug!(\"In fn_like_elision without appropriate scope above\"),\n@@ -2982,6 +3043,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             self.have_bound_regions = true;\n                         }\n                         _ => {\n+                            // FIXME(jackh726): nested trait refs?\n                             self.lifetimes.insert(lifetime.shifted_out_to_binder(self.outer_index));\n                         }\n                     }\n@@ -3047,6 +3109,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Root => break None,\n \n+                Scope::TraitRefBoundary { s, .. } => {\n+                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n+                    // We don't increase the late depth because this isn't a `Binder` scope\n+                    in_poly_trait_ref = false;\n+                    scope = s;\n+                }\n+\n                 Scope::Binder { s, ref lifetimes, from_poly_trait_ref, .. } => {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n@@ -3100,7 +3169,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                         scope = s;\n                                     }\n                                     Scope::ObjectLifetimeDefault { ref s, .. }\n-                                    | Scope::Elision { ref s, .. } => {\n+                                    | Scope::Elision { ref s, .. }\n+                                    | Scope::TraitRefBoundary { ref s, .. } => {\n                                         scope = s;\n                                     }\n                                     _ => break,\n@@ -3228,6 +3298,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = self.scope;\n         let lifetime = loop {\n             match *scope {\n+                Scope::TraitRefBoundary { s, .. } => {\n+                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n+                    // We don't increase the late depth because this isn't a `Binder` scope\n+                    in_poly_trait_ref = false;\n+                    scope = s;\n+                }\n+\n                 Scope::Binder { s, from_poly_trait_ref, .. } => {\n                     match (from_poly_trait_ref, in_poly_trait_ref) {\n                         (true, false) => {\n@@ -3380,7 +3457,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     old_scope = s;\n                 }\n \n@@ -3438,7 +3516,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => scope = s,\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -3492,13 +3571,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n+#[tracing::instrument(level = \"debug\", skip(map))]\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,\n     decl: &hir::FnDecl<'_>,\n     generics: &hir::Generics<'_>,\n ) {\n-    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n-\n     let mut constrained_by_input = ConstrainedCollector::default();\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n@@ -3507,7 +3585,7 @@ fn insert_late_bound_lifetimes(\n     let mut appears_in_output = AllCollector::default();\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\", constrained_by_input.regions);\n+    debug!(?constrained_by_input.regions);\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -3527,10 +3605,7 @@ fn insert_late_bound_lifetimes(\n         }\n     }\n \n-    debug!(\n-        \"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n-        appears_in_where_clause.regions\n-    );\n+    debug!(?appears_in_where_clause.regions);\n \n     // Late bound regions are those that:\n     // - appear in the inputs\n@@ -3557,11 +3632,7 @@ fn insert_late_bound_lifetimes(\n             continue;\n         }\n \n-        debug!(\n-            \"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-            param.name.ident(),\n-            param.hir_id\n-        );\n+        debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n \n         let inserted = map.late_bound.insert(param.hir_id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);"}, {"sha": "e130561e466731325d0451a40b60479f36647b07", "filename": "src/test/ui/lifetimes/issue-83737-binders-across-types.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/src%2Ftest%2Fui%2Flifetimes%2Fissue-83737-binders-across-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd56e255c43030d583aa0aa09f7eb92f2d8d1d81/src%2Ftest%2Fui%2Flifetimes%2Fissue-83737-binders-across-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-83737-binders-across-types.rs?ref=cd56e255c43030d583aa0aa09f7eb92f2d8d1d81", "patch": "@@ -0,0 +1,14 @@\n+// build-pass\n+// compile-flags: --edition 2018\n+// compile-flags: --crate-type rlib\n+\n+use std::future::Future;\n+\n+async fn handle<F>(slf: &F)\n+where\n+    F: Fn(&()) -> Box<dyn Future<Output = ()> + Unpin>,\n+{\n+    (slf)(&()).await;\n+}\n+\n+fn main() {}"}]}