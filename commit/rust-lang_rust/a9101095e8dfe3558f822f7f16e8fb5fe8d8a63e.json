{"sha": "a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MTAxMDk1ZThkZmUzNTU4ZjgyMmY3ZjE2ZThmYjVmZThkOGE2M2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-26T14:51:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-26T14:51:43Z"}, "message": "Merge branch 'simd-always-mem' of https://github.com/alexcrichton/rust into rollup", "tree": {"sha": "6cabe961ed619938991e4c98882902b813dde40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cabe961ed619938991e4c98882902b813dde40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "html_url": "https://github.com/rust-lang/rust/commit/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f41567c52bf4ce851963809ca3c08cfeffab79", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f41567c52bf4ce851963809ca3c08cfeffab79", "html_url": "https://github.com/rust-lang/rust/commit/a7f41567c52bf4ce851963809ca3c08cfeffab79"}, {"sha": "502de01ff40d37d3e6b419c3931a23284ce1a4e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/502de01ff40d37d3e6b419c3931a23284ce1a4e4", "html_url": "https://github.com/rust-lang/rust/commit/502de01ff40d37d3e6b419c3931a23284ce1a4e4"}], "stats": {"total": 210, "additions": 207, "deletions": 3}, "files": [{"sha": "9cabd9356e9bfe17b8c55554a6c664126d774aed", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "patch": "@@ -871,6 +871,31 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n                 match arg.layout.abi {\n                     layout::Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    layout::Abi::Vector { .. } if abi != Abi::PlatformIntrinsic => {\n+                        arg.make_indirect();\n+                        return\n+                    }\n+\n                     _ => return\n                 }\n "}, {"sha": "dc9f63c35db2eadd00a6309477c93968d551d375", "filename": "src/test/codegen/x86_mmx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fx86_mmx.rs?ref=a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "patch": "@@ -22,9 +22,7 @@ pub struct i8x8(u64);\n \n #[no_mangle]\n pub fn a(a: &mut i8x8, b: i8x8) -> i8x8 {\n-    // CHECK-LABEL: define x86_mmx @a(x86_mmx*{{.*}}, x86_mmx{{.*}})\n-    // CHECK: store x86_mmx %b, x86_mmx* %a\n-    // CHECK: ret x86_mmx %b\n+    // CHECK-LABEL: define void @a(x86_mmx*{{.*}}, x86_mmx*{{.*}}, x86_mmx*{{.*}})\n     *a = b;\n     return b\n }"}, {"sha": "b60aec2b5c923113d1c37fc5fb4d7508cde43f2c", "filename": "src/test/run-pass/simd-target-feature-mixup.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs?ref=a9101095e8dfe3558f822f7f16e8fb5fe8d8a63e", "patch": "@@ -0,0 +1,181 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, target_feature, cfg_target_feature)]\n+\n+use std::process::{Command, ExitStatus};\n+use std::env;\n+\n+fn main() {\n+    if let Some(level) = env::args().nth(1) {\n+        return test::main(&level)\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    for level in [\"sse\", \"avx\", \"avx512\"].iter() {\n+        let status = Command::new(&me).arg(level).status().unwrap();\n+        if status.success() {\n+            println!(\"success with {}\", level);\n+            continue\n+        }\n+\n+        // We don't actually know if our computer has the requisite target features\n+        // for the test below. Testing for that will get added to libstd later so\n+        // for now just asume sigill means this is a machine that can't run this test.\n+        if is_sigill(status) {\n+            println!(\"sigill with {}, assuming spurious\", level);\n+            continue\n+        }\n+        panic!(\"invalid status at {}: {}\", level, status);\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    use std::os::unix::prelude::*;\n+    status.signal() == Some(4)\n+}\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[allow(bad_style)]\n+mod test {\n+    // An SSE type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m128i(u64, u64);\n+\n+    // An AVX type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m256i(u64, u64, u64, u64);\n+\n+    // An AVX-512 type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m512i(u64, u64, u64, u64, u64, u64, u64, u64);\n+\n+    pub fn main(level: &str) {\n+        unsafe {\n+            main_normal(level);\n+            main_sse(level);\n+            if level == \"sse\" {\n+                return\n+            }\n+            main_avx(level);\n+            if level == \"avx\" {\n+                return\n+            }\n+            main_avx512(level);\n+        }\n+    }\n+\n+    macro_rules! mains {\n+        ($(\n+            $(#[$attr:meta])*\n+            unsafe fn $main:ident(level: &str) {\n+                ...\n+            }\n+        )*) => ($(\n+            $(#[$attr])*\n+            unsafe fn $main(level: &str) {\n+                let m128 = __m128i(1, 2);\n+                let m256 = __m256i(3, 4, 5, 6);\n+                let m512 = __m512i(7, 8, 9, 10, 11, 12, 13, 14);\n+                assert_eq!(id_sse_128(m128), m128);\n+                assert_eq!(id_sse_256(m256), m256);\n+                assert_eq!(id_sse_512(m512), m512);\n+\n+                if level == \"sse\" {\n+                    return\n+                }\n+                assert_eq!(id_avx_128(m128), m128);\n+                assert_eq!(id_avx_256(m256), m256);\n+                assert_eq!(id_avx_512(m512), m512);\n+\n+                if level == \"avx\" {\n+                    return\n+                }\n+                assert_eq!(id_avx512_128(m128), m128);\n+                assert_eq!(id_avx512_256(m256), m256);\n+                assert_eq!(id_avx512_512(m512), m512);\n+            }\n+        )*)\n+    }\n+\n+    mains! {\n+        unsafe fn main_normal(level: &str) { ... }\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn main_sse(level: &str) { ... }\n+        #[target_feature(enable = \"avx\")]\n+        unsafe fn main_avx(level: &str) { ... }\n+        #[target_feature(enable = \"avx512bw\")]\n+        unsafe fn main_avx512(level: &str) { ... }\n+    }\n+\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+}\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+mod test {\n+    pub fn main(level: &str) {}\n+}"}]}