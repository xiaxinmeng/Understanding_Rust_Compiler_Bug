{"sha": "c55af41e7a8388a022049f21a93b68626b36bc90", "node_id": "C_kwDOAAsO6NoAKGM1NWFmNDFlN2E4Mzg4YTAyMjA0OWYyMWE5M2I2ODYyNmIzNmJjOTA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-16T19:53:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-16T19:53:21Z"}, "message": "Rollup merge of #111074 - WaffleLapkin:\ud83c\udf1funsizes_your_buf_reader\ud83c\udf1f, r=Amanieu\n\nRelax implicit `T: Sized` bounds on `BufReader<T>`, `BufWriter<T>` and `LineWriter<T>`\n\nTL;DR:\n```diff,rust\n-pub struct BufReader<R> { /* ... */ }\n+pub struct BufReader<R: ?Sized> { /* ... */ }\n\n-pub struct BufWriter<W: Write> { /* ... */ }\n+pub struct BufWriter<W: ?Sized + Write> { /* ... */ }\n\n-pub struct LineWriter<W: Write> { /* ... */ }\n+pub struct LineWriter<W: ?Sized + Write> { /* ... */ }\n```\n\nThis allows using `&mut BufReader<dyn Read>`, for example.\n\n**This is an insta-stable change**.", "tree": {"sha": "37bdf49a94a40fb6487c2c6a335fddbf06227b4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37bdf49a94a40fb6487c2c6a335fddbf06227b4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c55af41e7a8388a022049f21a93b68626b36bc90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkjL2xCRBK7hj4Ov3rIwAA7NoIAKyngE/eWQ78fKULfJ4LlNXr\nvIOW9sZdNtX3X/7U01OLk3+PYJPfSDxQpe70ihlt2mgrWadlFwuagjSAnCw9IL+6\nUZRKS0vUdgYC0/4PEgk6WTG/xVYVfwtOX3DaD/O9y+iPmQ1y3BSR/mPdDZfB/fzk\nqfnBwV64mtlEbFfq9XsAQEHsuiNE40j9aYmnU9nqJ1hxM9v3o9zki4Q6a8g39RFR\nRbBz1bUOQAASsUCSvkDpz6spc/3e2W2+li/u85Z6eEsICkQM5TPpwiEI6wiltESh\nCQqzZgIQrkdBy4SXeZHaAop2FRW5Vi5R6laIgtf/r0kV/ADMdvU3U4LEKhDWrdE=\n=md/t\n-----END PGP SIGNATURE-----\n", "payload": "tree 37bdf49a94a40fb6487c2c6a335fddbf06227b4a\nparent 6a94e87a54ecf2df307c65af2dbc2effb3a525b8\nparent 29302a204c1f5a1ac1c114cbdb17c32a24da8367\nauthor Michael Goulet <michael@errs.io> 1686945201 -0700\ncommitter GitHub <noreply@github.com> 1686945201 -0700\n\nRollup merge of #111074 - WaffleLapkin:\ud83c\udf1funsizes_your_buf_reader\ud83c\udf1f, r=Amanieu\n\nRelax implicit `T: Sized` bounds on `BufReader<T>`, `BufWriter<T>` and `LineWriter<T>`\n\nTL;DR:\n```diff,rust\n-pub struct BufReader<R> { /* ... */ }\n+pub struct BufReader<R: ?Sized> { /* ... */ }\n\n-pub struct BufWriter<W: Write> { /* ... */ }\n+pub struct BufWriter<W: ?Sized + Write> { /* ... */ }\n\n-pub struct LineWriter<W: Write> { /* ... */ }\n+pub struct LineWriter<W: ?Sized + Write> { /* ... */ }\n```\n\nThis allows using `&mut BufReader<dyn Read>`, for example.\n\n**This is an insta-stable change**.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c55af41e7a8388a022049f21a93b68626b36bc90", "html_url": "https://github.com/rust-lang/rust/commit/c55af41e7a8388a022049f21a93b68626b36bc90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c55af41e7a8388a022049f21a93b68626b36bc90/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a94e87a54ecf2df307c65af2dbc2effb3a525b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a94e87a54ecf2df307c65af2dbc2effb3a525b8", "html_url": "https://github.com/rust-lang/rust/commit/6a94e87a54ecf2df307c65af2dbc2effb3a525b8"}, {"sha": "29302a204c1f5a1ac1c114cbdb17c32a24da8367", "url": "https://api.github.com/repos/rust-lang/rust/commits/29302a204c1f5a1ac1c114cbdb17c32a24da8367", "html_url": "https://github.com/rust-lang/rust/commit/29302a204c1f5a1ac1c114cbdb17c32a24da8367"}], "stats": {"total": 229, "additions": 118, "deletions": 111}, "files": [{"sha": "3edf9d747ce895f46e99935507a174817f56fb4d", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -47,9 +47,9 @@ use buffer::Buffer;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufReader<R> {\n-    inner: R,\n+pub struct BufReader<R: ?Sized> {\n     buf: Buffer,\n+    inner: R,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -95,7 +95,7 @@ impl<R: Read> BufReader<R> {\n     }\n }\n \n-impl<R> BufReader<R> {\n+impl<R: ?Sized> BufReader<R> {\n     /// Gets a reference to the underlying reader.\n     ///\n     /// It is inadvisable to directly read from the underlying reader.\n@@ -213,7 +213,10 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R {\n+    pub fn into_inner(self) -> R\n+    where\n+        R: Sized,\n+    {\n         self.inner\n     }\n \n@@ -226,13 +229,13 @@ impl<R> BufReader<R> {\n \n // This is only used by a test which asserts that the initialization-tracking is correct.\n #[cfg(test)]\n-impl<R> BufReader<R> {\n+impl<R: ?Sized> BufReader<R> {\n     pub fn initialized(&self) -> usize {\n         self.buf.initialized()\n     }\n }\n \n-impl<R: Seek> BufReader<R> {\n+impl<R: ?Sized + Seek> BufReader<R> {\n     /// Seeks relative to the current position. If the new position lies within the buffer,\n     /// the buffer will not be flushed, allowing for more efficient seeks.\n     /// This method does not return the location of the underlying reader, so the caller\n@@ -257,7 +260,7 @@ impl<R: Seek> BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> Read for BufReader<R> {\n+impl<R: ?Sized + Read> Read for BufReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n@@ -371,7 +374,7 @@ impl<R: Read> Read for BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> BufRead for BufReader<R> {\n+impl<R: ?Sized + Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         self.buf.fill_buf(&mut self.inner)\n     }\n@@ -384,11 +387,11 @@ impl<R: Read> BufRead for BufReader<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R> fmt::Debug for BufReader<R>\n where\n-    R: fmt::Debug,\n+    R: ?Sized + fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n-            .field(\"reader\", &self.inner)\n+            .field(\"reader\", &&self.inner)\n             .field(\n                 \"buffer\",\n                 &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n@@ -398,7 +401,7 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Seek> Seek for BufReader<R> {\n+impl<R: ?Sized + Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n     /// The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the\n@@ -491,7 +494,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     }\n }\n \n-impl<T> SizeHint for BufReader<T> {\n+impl<T: ?Sized> SizeHint for BufReader<T> {\n     #[inline]\n     fn lower_bound(&self) -> usize {\n         SizeHint::lower_bound(self.get_ref()) + self.buffer().len()"}, {"sha": "0e2450655e5bf0741158f751bfcf09a9718754bd", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -67,8 +67,7 @@ use crate::ptr;\n /// [`TcpStream`]: crate::net::TcpStream\n /// [`flush`]: BufWriter::flush\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W: Write> {\n-    inner: W,\n+pub struct BufWriter<W: ?Sized + Write> {\n     // The buffer. Avoid using this like a normal `Vec` in common code paths.\n     // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n     // methods that require bounds checking or the like. This makes an enormous\n@@ -78,6 +77,7 @@ pub struct BufWriter<W: Write> {\n     // write the buffered data a second time in BufWriter's destructor. This\n     // flag tells the Drop impl if it should skip the flush.\n     panicked: bool,\n+    inner: W,\n }\n \n impl<W: Write> BufWriter<W> {\n@@ -115,6 +115,69 @@ impl<W: Write> BufWriter<W> {\n         BufWriter { inner, buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n+    ///\n+    /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError::new(self, e)),\n+            Ok(()) => Ok(self.into_parts().0),\n+        }\n+    }\n+\n+    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n+    /// unwritten data.\n+    ///\n+    /// If the underlying writer panicked, it is not known what portion of the data was written.\n+    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n+    /// contents can still be recovered).\n+    ///\n+    /// `into_parts` makes no attempt to flush data and cannot fail.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{BufWriter, Write};\n+    ///\n+    /// let mut buffer = [0u8; 10];\n+    /// let mut stream = BufWriter::new(buffer.as_mut());\n+    /// write!(stream, \"too much data\").unwrap();\n+    /// stream.flush().expect_err(\"it doesn't fit\");\n+    /// let (recovered_writer, buffered_data) = stream.into_parts();\n+    /// assert_eq!(recovered_writer.len(), 0);\n+    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n+    /// ```\n+    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n+    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n+        let buf = mem::take(&mut self.buf);\n+        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n+\n+        // SAFETY: forget(self) prevents double dropping inner\n+        let inner = unsafe { ptr::read(&self.inner) };\n+        mem::forget(self);\n+\n+        (inner, buf)\n+    }\n+}\n+\n+impl<W: ?Sized + Write> BufWriter<W> {\n     /// Send data in our local buffer into the inner writer, looping as\n     /// necessary until either it's all been sent or an error occurs.\n     ///\n@@ -284,67 +347,6 @@ impl<W: Write> BufWriter<W> {\n         self.buf.capacity()\n     }\n \n-    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n-    ///\n-    /// The buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // unwrap the TcpStream and flush the buffer\n-    /// let stream = buffer.into_inner().unwrap();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n-        match self.flush_buf() {\n-            Err(e) => Err(IntoInnerError::new(self, e)),\n-            Ok(()) => Ok(self.into_parts().0),\n-        }\n-    }\n-\n-    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n-    /// unwritten data.\n-    ///\n-    /// If the underlying writer panicked, it is not known what portion of the data was written.\n-    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n-    /// contents can still be recovered).\n-    ///\n-    /// `into_parts` makes no attempt to flush data and cannot fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::io::{BufWriter, Write};\n-    ///\n-    /// let mut buffer = [0u8; 10];\n-    /// let mut stream = BufWriter::new(buffer.as_mut());\n-    /// write!(stream, \"too much data\").unwrap();\n-    /// stream.flush().expect_err(\"it doesn't fit\");\n-    /// let (recovered_writer, buffered_data) = stream.into_parts();\n-    /// assert_eq!(recovered_writer.len(), 0);\n-    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n-    /// ```\n-    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n-    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n-        let buf = mem::take(&mut self.buf);\n-        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n-\n-        // SAFETY: forget(self) prevents double dropping inner\n-        let inner = unsafe { ptr::read(&self.inner) };\n-        mem::forget(self);\n-\n-        (inner, buf)\n-    }\n-\n     // Ensure this function does not get inlined into `write`, so that it\n     // remains inlineable and its common path remains as short as possible.\n     // If this function ends up being called frequently relative to `write`,\n@@ -511,7 +513,7 @@ impl fmt::Debug for WriterPanicked {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for BufWriter<W> {\n+impl<W: ?Sized + Write> Write for BufWriter<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n@@ -640,20 +642,20 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W>\n+impl<W: ?Sized + Write> fmt::Debug for BufWriter<W>\n where\n     W: fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufWriter\")\n-            .field(\"writer\", &self.inner)\n+            .field(\"writer\", &&self.inner)\n             .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n             .finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write + Seek> Seek for BufWriter<W> {\n+impl<W: ?Sized + Write + Seek> Seek for BufWriter<W> {\n     /// Seek to the offset, in bytes, in the underlying writer.\n     ///\n     /// Seeking always writes out the internal buffer before seeking.\n@@ -664,7 +666,7 @@ impl<W: Write + Seek> Seek for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Drop for BufWriter<W> {\n+impl<W: ?Sized + Write> Drop for BufWriter<W> {\n     fn drop(&mut self) {\n         if !self.panicked {\n             // dtors should not panic, so we ignore a failed flush"}, {"sha": "3d4ae7041932255181e9ed06ca456b50862c5c75", "filename": "library/std/src/io/buffered/linewriter.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -64,7 +64,7 @@ use crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSli\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W: Write> {\n+pub struct LineWriter<W: ?Sized + Write> {\n     inner: BufWriter<W>,\n }\n \n@@ -109,27 +109,6 @@ impl<W: Write> LineWriter<W> {\n         LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n     }\n \n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///\n-    ///     let reference = file.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.get_ref()\n-    }\n-\n     /// Gets a mutable reference to the underlying writer.\n     ///\n     /// Caution must be taken when calling methods on the mutable reference\n@@ -184,8 +163,31 @@ impl<W: Write> LineWriter<W> {\n     }\n }\n \n+impl<W: ?Sized + Write> LineWriter<W> {\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///\n+    ///     let reference = file.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for LineWriter<W> {\n+impl<W: ?Sized + Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         LineWriterShim::new(&mut self.inner).write(buf)\n     }\n@@ -216,7 +218,7 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W>\n+impl<W: ?Sized + Write> fmt::Debug for LineWriter<W>\n where\n     W: fmt::Debug,\n {"}, {"sha": "f2a55da05b22eb5368b33403580c7b81d7242027", "filename": "library/std/src/io/buffered/linewritershim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -11,11 +11,11 @@ use crate::sys_common::memchr;\n /// `BufWriters` to be temporarily given line-buffering logic; this is what\n /// enables Stdout to be alternately in line-buffered or block-buffered mode.\n #[derive(Debug)]\n-pub struct LineWriterShim<'a, W: Write> {\n+pub struct LineWriterShim<'a, W: ?Sized + Write> {\n     buffer: &'a mut BufWriter<W>,\n }\n \n-impl<'a, W: Write> LineWriterShim<'a, W> {\n+impl<'a, W: ?Sized + Write> LineWriterShim<'a, W> {\n     pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n         Self { buffer }\n     }\n@@ -49,7 +49,7 @@ impl<'a, W: Write> LineWriterShim<'a, W> {\n     }\n }\n \n-impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n+impl<'a, W: ?Sized + Write> Write for LineWriterShim<'a, W> {\n     /// Write some data into this BufReader with line buffering. This means\n     /// that, if any newlines are present in the data, the data up to the last\n     /// newline is sent directly to the underlying writer, and data after it"}, {"sha": "420fc4007050b256aa6d537c0b8d076693a9bc40", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -86,7 +86,7 @@ impl<W: Write + ?Sized> BufferedCopySpec for W {\n     }\n }\n \n-impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+impl<I: ?Sized + Write> BufferedCopySpec for BufWriter<I> {\n     fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n         if writer.capacity() < DEFAULT_BUF_SIZE {\n             return stack_buffer_copy(reader, writer);"}, {"sha": "173233d7150b2719613a64a0974620e615d5530e", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -2754,7 +2754,7 @@ trait SizeHint {\n     }\n }\n \n-impl<T> SizeHint for T {\n+impl<T: ?Sized> SizeHint for T {\n     #[inline]\n     default fn lower_bound(&self) -> usize {\n         0"}, {"sha": "7d49bbdcbe063bde033f156cc9711c6fde8a80b4", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55af41e7a8388a022049f21a93b68626b36bc90/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=c55af41e7a8388a022049f21a93b68626b36bc90", "patch": "@@ -466,7 +466,7 @@ impl<T: CopyRead> CopyRead for Take<T> {\n     }\n }\n \n-impl<T: CopyRead> CopyRead for BufReader<T> {\n+impl<T: ?Sized + CopyRead> CopyRead for BufReader<T> {\n     fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n         let buf = self.buffer();\n         let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n@@ -495,7 +495,7 @@ impl<T: CopyRead> CopyRead for BufReader<T> {\n     }\n }\n \n-impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+impl<T: ?Sized + CopyWrite> CopyWrite for BufWriter<T> {\n     fn properties(&self) -> CopyParams {\n         self.get_ref().properties()\n     }"}]}