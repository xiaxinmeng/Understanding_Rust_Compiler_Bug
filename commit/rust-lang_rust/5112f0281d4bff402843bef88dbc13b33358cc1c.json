{"sha": "5112f0281d4bff402843bef88dbc13b33358cc1c", "node_id": "C_kwDOAAsO6NoAKDUxMTJmMDI4MWQ0YmZmNDAyODQzYmVmODhkYmMxM2IzMzM1OGNjMWM", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-03T18:28:28Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-05T19:42:26Z"}, "message": "Shrink `ParseResult` in the hot path.\n\nA recent PR increased the size, which caused regressions. This uses the\nexisting generic infrastructure to differentiate between the hot path\nand the diagnostics path.", "tree": {"sha": "c80cd51d963d2ec9856f0204d0eca40ea4cd7e3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c80cd51d963d2ec9856f0204d0eca40ea4cd7e3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5112f0281d4bff402843bef88dbc13b33358cc1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5112f0281d4bff402843bef88dbc13b33358cc1c", "html_url": "https://github.com/rust-lang/rust/commit/5112f0281d4bff402843bef88dbc13b33358cc1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5112f0281d4bff402843bef88dbc13b33358cc1c/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d284af117716473e1a35cc0d91c170e44e3fc6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d284af117716473e1a35cc0d91c170e44e3fc6e", "html_url": "https://github.com/rust-lang/rust/commit/1d284af117716473e1a35cc0d91c170e44e3fc6e"}], "stats": {"total": 111, "additions": 81, "deletions": 30}, "files": [{"sha": "f469b2daef5eb7cf767e6f272ea2d6c05dbbe29f", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=5112f0281d4bff402843bef88dbc13b33358cc1c", "patch": "@@ -114,6 +114,12 @@ impl BestFailure {\n }\n \n impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    type Failure = (Token, usize, &'static str);\n+\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure {\n+        (tok, position, msg)\n+    }\n+\n     fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n         if self.remaining_matcher.is_none()\n             || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n@@ -122,7 +128,7 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n         }\n     }\n \n-    fn after_arm(&mut self, result: &NamedParseResult) {\n+    fn after_arm(&mut self, result: &NamedParseResult<Self::Failure>) {\n         match result {\n             Success(_) => {\n                 // Nonterminal parser recovery might turn failed matches into successful ones,\n@@ -132,7 +138,7 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n                     \"should not collect detailed info for successful macro match\",\n                 );\n             }\n-            Failure(token, approx_position, msg) => {\n+            Failure((token, approx_position, msg)) => {\n                 debug!(?token, ?msg, \"a new failure of an arm\");\n \n                 if self\n@@ -175,6 +181,21 @@ impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n     }\n }\n \n+/// Currently used by macro_rules! compilation to extract a little information from the `Failure` case.\n+pub struct FailureForwarder;\n+\n+impl<'matcher> Tracker<'matcher> for FailureForwarder {\n+    type Failure = (Token, usize, &'static str);\n+\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure {\n+        (tok, position, msg)\n+    }\n+\n+    fn description() -> &'static str {\n+        \"failure-forwarder\"\n+    }\n+}\n+\n pub(super) fn emit_frag_parse_err(\n     mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n     parser: &Parser<'_>,"}, {"sha": "2e199541b92b43c08f0387b84deef90e8275a2cd", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=5112f0281d4bff402843bef88dbc13b33358cc1c", "patch": "@@ -305,13 +305,13 @@ enum EofMatcherPositions {\n }\n \n /// Represents the possible results of an attempted parse.\n-pub(crate) enum ParseResult<T> {\n+pub(crate) enum ParseResult<T, F> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n     /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n     /// The usize is the approximate position of the token in the input token stream.\n-    Failure(Token, usize, &'static str),\n+    Failure(F),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n     ErrorReported(ErrorGuaranteed),\n@@ -320,7 +320,7 @@ pub(crate) enum ParseResult<T> {\n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-pub(crate) type NamedParseResult = ParseResult<NamedMatches>;\n+pub(crate) type NamedParseResult<F> = ParseResult<NamedMatches, F>;\n \n /// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n@@ -458,7 +458,7 @@ impl TtParser {\n         token: &Token,\n         approx_position: usize,\n         track: &mut T,\n-    ) -> Option<NamedParseResult> {\n+    ) -> Option<NamedParseResult<T::Failure>> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n@@ -595,14 +595,14 @@ impl TtParser {\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n                 }\n-                EofMatcherPositions::None => Failure(\n+                EofMatcherPositions::None => Failure(T::build_failure(\n                     Token::new(\n                         token::Eof,\n                         if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n                     ),\n                     approx_position,\n                     \"missing tokens in macro arguments\",\n-                ),\n+                )),\n             })\n         } else {\n             None\n@@ -615,7 +615,7 @@ impl TtParser {\n         parser: &mut Cow<'_, Parser<'_>>,\n         matcher: &'matcher [MatcherLoc],\n         track: &mut T,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<T::Failure> {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n         // `parse_tt_inner` then processes all of these possible matcher positions and produces\n@@ -648,11 +648,11 @@ impl TtParser {\n                 (0, 0) => {\n                     // There are no possible next positions AND we aren't waiting for the black-box\n                     // parser: syntax error.\n-                    return Failure(\n+                    return Failure(T::build_failure(\n                         parser.token.clone(),\n                         parser.approx_token_stream_pos(),\n                         \"no rules expected this token in macro call\",\n-                    );\n+                    ));\n                 }\n \n                 (_, 0) => {\n@@ -711,11 +711,11 @@ impl TtParser {\n         }\n     }\n \n-    fn ambiguity_error(\n+    fn ambiguity_error<F>(\n         &self,\n         matcher: &[MatcherLoc],\n         token_span: rustc_span::Span,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<F> {\n         let nts = self\n             .bb_mps\n             .iter()\n@@ -741,11 +741,11 @@ impl TtParser {\n         )\n     }\n \n-    fn nameize<I: Iterator<Item = NamedMatch>>(\n+    fn nameize<I: Iterator<Item = NamedMatch>, F>(\n         &self,\n         matcher: &[MatcherLoc],\n         mut res: I,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<F> {\n         // Make that each metavar has _exactly one_ binding. If so, insert the binding into the\n         // `NamedParseResult`. Otherwise, it's an error.\n         let mut ret_val = FxHashMap::default();"}, {"sha": "c0489f686336b2747c9252500425e451561a83b6", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5112f0281d4bff402843bef88dbc13b33358cc1c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=5112f0281d4bff402843bef88dbc13b33358cc1c", "patch": "@@ -141,31 +141,40 @@ fn trace_macros_note(cx_expansions: &mut FxIndexMap<Span, Vec<String>>, sp: Span\n }\n \n pub(super) trait Tracker<'matcher> {\n+    /// The contents of `ParseResult::Failure`.\n+    type Failure;\n+\n+    /// Arm failed to match. If the token is `token::Eof`, it indicates an unexpected\n+    /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n+    /// The usize is the approximate position of the token in the input token stream.\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure;\n+\n     /// This is called before trying to match next MatcherLoc on the current token.\n-    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc);\n+    fn before_match_loc(&mut self, _parser: &TtParser, _matcher: &'matcher MatcherLoc) {}\n \n     /// This is called after an arm has been parsed, either successfully or unsuccessfully. When this is called,\n     /// `before_match_loc` was called at least once (with a `MatcherLoc::Eof`).\n-    fn after_arm(&mut self, result: &NamedParseResult);\n+    fn after_arm(&mut self, _result: &NamedParseResult<Self::Failure>) {}\n \n     /// For tracing.\n     fn description() -> &'static str;\n \n-    fn recovery() -> Recovery;\n+    fn recovery() -> Recovery {\n+        Recovery::Forbidden\n+    }\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n pub(super) struct NoopTracker;\n \n impl<'matcher> Tracker<'matcher> for NoopTracker {\n-    fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n-    fn after_arm(&mut self, _: &NamedParseResult) {}\n+    type Failure = ();\n+\n+    fn build_failure(_tok: Token, _position: usize, _msg: &'static str) -> Self::Failure {}\n+\n     fn description() -> &'static str {\n         \"none\"\n     }\n-    fn recovery() -> Recovery {\n-        Recovery::Forbidden\n-    }\n }\n \n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n@@ -326,8 +335,8 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n \n                 return Ok((i, named_matches));\n             }\n-            Failure(_, reached_position, _) => {\n-                trace!(%reached_position, \"Failed to match arm, trying the next one\");\n+            Failure(_) => {\n+                trace!(\"Failed to match arm, trying the next one\");\n                 // Try the next arm.\n             }\n             Error(_, _) => {\n@@ -381,11 +390,13 @@ pub fn compile_declarative_macro(\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n     let tt_spec = Some(NonterminalKind::TT);\n \n-    // Parse the macro_rules! invocation\n-    let (macro_rules, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.tokens.clone()),\n+    let macro_def = match &def.kind {\n+        ast::ItemKind::MacroDef(def) => def,\n         _ => unreachable!(),\n     };\n+    let macro_rules = macro_def.macro_rules;\n+\n+    // Parse the macro_rules! invocation\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n@@ -426,13 +437,32 @@ pub fn compile_declarative_macro(\n     // Convert it into `MatcherLoc` form.\n     let argument_gram = mbe::macro_parser::compute_locs(&argument_gram);\n \n-    let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n+    let create_parser = || {\n+        let body = macro_def.body.tokens.clone();\n+        Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS)\n+    };\n+\n+    let parser = create_parser();\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n     let argument_map =\n         match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n-            Failure(token, _, msg) => {\n+            Failure(()) => {\n+                // The fast `NoopTracker` doesn't have any info on failure, so we need to retry it with another one\n+                // that gives us the information we need.\n+                // For this we need to reclone the macro body as the previous parser consumed it.\n+                let retry_parser = create_parser();\n+\n+                let parse_result = tt_parser.parse_tt(\n+                    &mut Cow::Owned(retry_parser),\n+                    &argument_gram,\n+                    &mut diagnostics::FailureForwarder,\n+                );\n+                let Failure((token, _, msg)) = parse_result else {\n+                    unreachable!(\"matcher returned something other than Failure after retry\");\n+                };\n+\n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n                 let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);"}]}