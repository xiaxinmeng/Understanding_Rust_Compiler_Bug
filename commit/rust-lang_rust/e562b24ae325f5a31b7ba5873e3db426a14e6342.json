{"sha": "e562b24ae325f5a31b7ba5873e3db426a14e6342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NjJiMjRhZTMyNWY1YTMxYjdiYTU4NzNlM2RiNDI2YTE0ZTYzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T02:16:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T02:16:53Z"}, "message": "Auto merge of #62041 - Centril:rollup-95eeyx7, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #60971 (Add DocFS layer to rustdoc)\n - #61146 (SliceConcatExt::connect defaults to calling join)\n - #61181 (Fix theme-checker failure)\n - #61267 (rustc-book: Update the rustc/clang compatibility table for xLTO.)\n - #61270 (Remove warnings about incr. comp. generating less debugging output.)\n - #61681 (Changed the error message to more clearly explain what is allowed)\n - #61984 (More NodeId pruning)\n - #62016 (Add test for issue-27697)\n - #62019 (Remove needless lifetimes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e9dfa0b1f2f5ff685a4f1866cc8b11275a4e4088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9dfa0b1f2f5ff685a4f1866cc8b11275a4e4088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e562b24ae325f5a31b7ba5873e3db426a14e6342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e562b24ae325f5a31b7ba5873e3db426a14e6342", "html_url": "https://github.com/rust-lang/rust/commit/e562b24ae325f5a31b7ba5873e3db426a14e6342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e562b24ae325f5a31b7ba5873e3db426a14e6342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6f4b96df0a837036fa0f58541cd32c6c56a463", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6f4b96df0a837036fa0f58541cd32c6c56a463", "html_url": "https://github.com/rust-lang/rust/commit/8d6f4b96df0a837036fa0f58541cd32c6c56a463"}, {"sha": "64e58183074480bc6a1dfdd9ffe8ef7674005806", "url": "https://api.github.com/repos/rust-lang/rust/commits/64e58183074480bc6a1dfdd9ffe8ef7674005806", "html_url": "https://github.com/rust-lang/rust/commit/64e58183074480bc6a1dfdd9ffe8ef7674005806"}], "stats": {"total": 907, "additions": 517, "deletions": 390}, "files": [{"sha": "40b8cf507e97c5b95ec70ca58237359ead967f37", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -3254,6 +3254,7 @@ dependencies = [\n  \"minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "2ae726c4ba61d6af6744f03c82ff644e3933f92a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -100,9 +100,10 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           | Clang 7   | Clang 8   |\n+|           |  Clang 7  |  Clang 8  |\n |-----------|-----------|-----------|\n | Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |    \u2713(?)   |\n+| Rust 1.35 |     \u2717     |     \u2713     |\n+| Rust 1.36 |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "f7b0a5e703cc3b8d58e634d05e3bf71f40d722b0", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -581,7 +581,9 @@ pub trait SliceConcatExt<T: ?Sized> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    fn connect(&self, sep: &T) -> Self::Output;\n+    fn connect(&self, sep: &T) -> Self::Output {\n+        self.join(sep)\n+    }\n }\n \n #[unstable(feature = \"slice_concat_ext\",\n@@ -615,10 +617,6 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         }\n         result\n     }\n-\n-    fn connect(&self, sep: &T) -> Vec<T> {\n-        self.join(sep)\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "40104554fe574a9caa8d7f5b6a5a19d62e354647", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -86,10 +86,6 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n             String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n         }\n     }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n }\n \n macro_rules! spezialize_for_lengths {"}, {"sha": "8c5fa97d4b72d03054df28a439271080e6b2aa62", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -15,7 +15,7 @@ use crate::hir as ast;\n use crate::hir::map;\n use crate::hir::{Expr, FnDecl, Node};\n use crate::hir::intravisit::FnKind;\n-use syntax::ast::{Attribute, Ident, NodeId};\n+use syntax::ast::{Attribute, Ident};\n use syntax_pos::Span;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n@@ -83,11 +83,11 @@ impl<'a> Code<'a> {\n     }\n \n     /// Attempts to construct a Code from presumed FnLike or Expr node input.\n-    pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n+    pub fn from_node(map: &map::Map<'a>, id: ast::HirId) -> Option<Code<'a>> {\n         match map.get(id) {\n             map::Node::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n-                Code::from_node(map, map.get_parent_node(id))\n+                Code::from_node(map, map.get_parent_node_by_hir_id(id))\n             }\n             map::Node::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike)"}, {"sha": "b4bda36bc8a279036c60ddb10bdbf8c299695ad2", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -397,11 +397,6 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n-    #[inline]\n-    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> ast::NodeId {\n-        self.as_local_node_id(DefId::local(def_index)).unwrap()\n-    }\n-\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n     /// and it's not `DUMMY_SP`.\n     #[inline]"}, {"sha": "0b8b69be0a48007b8fd98d2b94230ef11d36b40b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -291,8 +291,8 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n     }\n \n-    fn def_kind(&self, node_id: NodeId) -> Option<DefKind> {\n-        let node = if let Some(node) = self.find(node_id) {\n+    fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n+        let node = if let Some(node) = self.find_by_hir_id(hir_id) {\n             node\n         } else {\n             return None\n@@ -347,7 +347,7 @@ impl<'hir> Map<'hir> {\n                 if variant_data.ctor_hir_id().is_none() {\n                     return None;\n                 }\n-                let ctor_of = match self.find(self.get_parent_node(node_id)) {\n+                let ctor_of = match self.find_by_hir_id(self.get_parent_node_by_hir_id(hir_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n@@ -458,7 +458,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n-        match self.get_by_hir_id(id) {\n+        match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n@@ -482,7 +482,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n-        match self.get_by_hir_id(id) {\n+        match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n@@ -491,7 +491,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn ty_param_name(&self, id: HirId) -> Name {\n-        match self.get_by_hir_id(id) {\n+        match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n@@ -561,20 +561,14 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: NodeId) -> Node<'hir> {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n+    pub fn get(&self, id: HirId) -> Node<'hir> {\n         // read recorded by `find`\n         self.find_by_hir_id(id).unwrap_or_else(||\n             bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n+        self.as_local_hir_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n@@ -846,7 +840,7 @@ impl<'hir> Map<'hir> {\n             if scope == CRATE_HIR_ID {\n                 return Some(CRATE_HIR_ID);\n             }\n-            match self.get_by_hir_id(scope) {\n+            match self.get(scope) {\n                 Node::Item(i) => {\n                     match i.node {\n                         ItemKind::Existential(ExistTy { impl_trait_fn: None, .. }) => {}\n@@ -927,28 +921,15 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.expect_expr_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n+    pub fn expect_expr(&self, id: HirId) -> &'hir Expr {\n         match self.find_by_hir_id(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    /// Returns the name associated with the given `NodeId`'s AST.\n-    pub fn name(&self, id: NodeId) -> Name {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.name_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n-        match self.get_by_hir_id(id) {\n+    pub fn name(&self, id: HirId) -> Name {\n+        match self.get(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n@@ -958,7 +939,7 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::Ctor(..) => self.name_by_hir_id(self.get_parent_item(id)),\n+            Node::Ctor(..) => self.name(self.get_parent_item(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n@@ -1080,7 +1061,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n-        print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n+        print::to_string(self, |s| s.print_node(self.get(id)))\n     }\n }\n \n@@ -1407,8 +1388,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.def_kind = |tcx, def_id| {\n-        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-            tcx.hir().def_kind(node_id)\n+        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+            tcx.hir().def_kind(hir_id)\n         } else {\n             bug!(\"calling local def_kind query provider for upstream DefId: {:?}\",\n                 def_id"}, {"sha": "d1e32b1dbad36761cf7a42b23896322be1334ebc", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -617,7 +617,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let discrim_expr = self.tcx.hir().expect_expr_by_hir_id(discrim_hir_id);\n+                        let discrim_expr = self.tcx.hir().expect_expr(discrim_hir_id);\n                         let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.node {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n                             self.in_progress_tables.and_then(|tables| {\n@@ -1335,7 +1335,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get_by_hir_id(id) {\n+                            if let Node::GenericParam(ref param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);\n@@ -1583,7 +1583,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),"}, {"sha": "4426b5c0e85b5d55e65cac4cf7f3725c5a4b6bde", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr_by_hir_id(body_id.hir_id);\n+            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "283af94b89b4841604bfdd19bdbcbae273f5e6bf", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n-                let fndecl = match self.tcx().hir().get_by_hir_id(hir_id) {\n+                let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         .."}, {"sha": "f5a4dac2c2cb8e799b0e2fa7162e3bc0bb6dba83", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),\n                         ..\n-                    }) = hir.get_by_hir_id(hir_id) {\n+                    }) = hir.get(hir_id) {\n                         let sup_sp = sup_origin.span();\n                         let origin_sp = origin.span();\n                         let mut err = self.tcx().sess.struct_span_err("}, {"sha": "caed4288892eff2844e9a0c4728647577ff9a75e", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n             }\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,"}, {"sha": "5c5e6303b82434ea9db61de8cdfd370851bc78e8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -265,7 +265,7 @@ pub enum SubregionOrigin<'tcx> {\n     DerefPointer(Span),\n \n     /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, ast::NodeId),\n+    ClosureCapture(Span, hir::HirId),\n \n     /// Index into slice must be within its lifetime\n     IndexSlice(Span),"}, {"sha": "a687b0e459100d7a084e3d99c6980ad3c05cc97e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -945,8 +945,8 @@ pub fn may_define_existential_type(\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     trace!(\n         \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n-        tcx.hir().get_by_hir_id(hir_id),\n-        tcx.hir().get_by_hir_id(opaque_hir_id)\n+        tcx.hir().get(hir_id),\n+        tcx.hir().get(opaque_hir_id)\n     );\n \n     // Named existential types can be defined by any siblings or children of siblings."}, {"sha": "0d59e32b09818fdf5c71d7086100c9d180f80f0b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1630,7 +1630,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     );\n \n                     if self.ir.variable_is_shorthand(var) {\n-                        if let Node::Binding(pat) = self.ir.tcx.hir().get_by_hir_id(hir_id) {\n+                        if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n                             // Handle `ref` and `ref mut`.\n                             let spans = spans.iter()\n                                 .map(|_span| (pat.span, format!(\"{}: _\", name)))"}, {"sha": "10796abe5d4c42b2f90000505eef8da113a90414", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -344,7 +344,7 @@ impl MutabilityCategory {\n         tables: &ty::TypeckTables<'_>,\n         id: hir::HirId,\n     ) -> MutabilityCategory {\n-        let ret = match tcx.hir().get_by_hir_id(id) {\n+        let ret = match tcx.hir().get(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()"}, {"sha": "d9ccb9d42f23656c0c96a0b0aa8d413beaf1f2f1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -190,7 +190,7 @@ impl Scope {\n         }\n         let span = tcx.hir().span(hir_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir().get_by_hir_id(hir_id) {\n+            if let Node::Block(ref blk) = tcx.hir().get(hir_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -1368,7 +1368,7 @@ fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree\n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n-        match tcx.hir().get_by_hir_id(id) {\n+        match tcx.hir().get(id) {\n             Node::ImplItem(_) |\n             Node::TraitItem(_) => {\n                 visitor.scope_tree.root_parent = Some(tcx.hir().get_parent_item(id));"}, {"sha": "b8e7db99d071ca629234cbadeafda033c00e8b6d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1488,7 +1488,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get_by_hir_id(lifetime.hir_id) {\n+        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.hir_id) {\n             if let Some(parent) = self.tcx.hir().find_by_hir_id(\n                 self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n             {\n@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n                     let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n                     debug!(\"hir id first={:?}\", hir_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n                             hir_lifetime.span,\n@@ -1620,7 +1620,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n                 None => {\n                     let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n                             hir_lifetime.span,\n@@ -1823,7 +1823,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n-                match self.tcx.hir().get_by_hir_id(fn_id) {\n+                match self.tcx.hir().get(fn_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n@@ -2052,7 +2052,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n         let parent = self.tcx.hir().get_parent_node_by_hir_id(output.hir_id);\n-        let body = match self.tcx.hir().get_by_hir_id(parent) {\n+        let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),"}, {"sha": "38df4060652b7c6b799bfaa4ed08ee1f06f64b2d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -580,7 +580,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let mut diag = self.struct_span_lint_hir(lint, id, span, &msg);\n             if let Some(suggestion) = suggestion {\n-                if let hir::Node::Expr(_) = self.hir().get_by_hir_id(id) {\n+                if let hir::Node::Expr(_) = self.hir().get(id) {\n                     diag.span_suggestion(\n                         span,\n                         \"replace the use of the deprecated item\","}, {"sha": "6f9cede7e46b1db06f78f22582e81cfdcc9ad178", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -2573,7 +2573,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(var_id);\n+                                    let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }\n@@ -2592,7 +2592,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(var_id);\n+                                    let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }"}, {"sha": "895f9c6d8fb8510661dae5a14aa034448854c5d4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -330,14 +330,6 @@ macro_rules! hash_option {\n             bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n     });\n-    ($opt_name:ident,\n-     $opt_expr:expr,\n-     $sub_hashes:expr,\n-     [UNTRACKED_WITH_WARNING $warn_val:expr, $warn_text:expr, $error_format:expr]) => ({\n-        if *$opt_expr == $warn_val {\n-            early_warn($error_format, $warn_text)\n-        }\n-    });\n }\n \n macro_rules! top_level_options {\n@@ -383,10 +375,6 @@ macro_rules! top_level_options {\n // [UNTRACKED]\n // Incremental compilation is not influenced by this option.\n //\n-// [UNTRACKED_WITH_WARNING(val, warning)]\n-// The option is incompatible with incremental compilation in some way. If it\n-// has the value `val`, the string `warning` is emitted as a warning.\n-//\n // If you add a new option to this struct or one of the sub-structs like\n // CodegenOptions, think about how it influences incremental compilation. If in\n // doubt, specify [TRACKED], which is always \"correct\" but might lead to\n@@ -1163,9 +1151,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"a list of extra LLVM passes to run (space separated)\"),\n     llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of arguments to pass to llvm (space separated)\"),\n-    save_temps: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"`-C save-temps` might not produce all requested temporary products \\\n-         when incremental compilation is enabled.\")],\n+    save_temps: bool = (false, parse_bool, [UNTRACKED],\n         \"save all temporary output files during compilation\"),\n     rpath: bool = (false, parse_bool, [UNTRACKED],\n         \"set rpath values in libs/exes\"),\n@@ -1241,9 +1227,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"measure time of each rustc pass\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes\"),\n-    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n-         re-codegened modules when used with incremental compilation\" )],\n+    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each LLVM pass\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),"}, {"sha": "b433098c1b2653143e294da1ff155165f9554e31", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -937,9 +937,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         code: &ObligationCauseCode<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n     ) {\n-        if let &ObligationCauseCode::VariableType(node_id) = code {\n-            let parent_node = self.tcx.hir().get_parent_node(node_id);\n-            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n+        if let &ObligationCauseCode::VariableType(hir_id) = code {\n+            let parent_node = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find_by_hir_id(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {"}, {"sha": "8d17df1e61055ab3183412856a6a687e36b73985", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -188,7 +188,7 @@ pub enum ObligationCauseCode<'tcx> {\n     /// S { ... } must be Sized\n     StructInitializerSized,\n     /// Type of each variable must be Sized\n-    VariableType(ast::NodeId),\n+    VariableType(hir::HirId),\n     /// Argument type must be Sized\n     SizedArgumentType,\n     /// Return type must be Sized"}, {"sha": "e4022bb24ad442e7d4cb45c9ceeca9dca9b8d608", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -67,13 +67,13 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n \n-pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     /// only checks whether the function has a `const` modifier\n-    fn is_const_fn_raw<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n-        let node = tcx.hir().get_by_hir_id(hir_id);\n+        let node = tcx.hir().get(hir_id);\n         if let Some(fn_like) = FnLikeNode::from_node(node) {\n             fn_like.constness() == hir::Constness::Const\n         } else if let hir::Node::Ctor(_) = node {\n@@ -83,7 +83,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn is_promotable_const_fn<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) && match tcx.lookup_stability(def_id) {\n             Some(stab) => {\n                 if cfg!(debug_assertions) && stab.promotable {\n@@ -101,7 +101,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn const_fn_is_allowed_fn_ptr<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) &&\n             tcx.lookup_stability(def_id)\n                 .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)"}, {"sha": "ce785f9a0246bb9493aa89e8bfaf66d6ed97b1c7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1610,7 +1610,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Option<Ty<'tcx>> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n-        match self.hir().get_by_hir_id(hir_id) {\n+        match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n@@ -2223,7 +2223,7 @@ impl<'tcx> Borrow<[Ty<'tcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n }\n \n impl<'tcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n-    fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n+    fn borrow(&self) -> &[CanonicalVarInfo] {\n         &self.0[..]\n     }\n }\n@@ -2236,13 +2236,13 @@ impl<'tcx> Borrow<[Kind<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n \n impl<'tcx> Borrow<[ProjectionKind]>\n     for Interned<'tcx, List<ProjectionKind>> {\n-    fn borrow<'a>(&'a self) -> &'a [ProjectionKind] {\n+    fn borrow(&self) -> &[ProjectionKind] {\n         &self.0[..]\n     }\n }\n \n impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n-    fn borrow<'a>(&'a self) -> &'a RegionKind {\n+    fn borrow(&self) -> &RegionKind {\n         &self.0\n     }\n }"}, {"sha": "ee0d33dbe345cee6758be24922469853012c90c1", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -55,8 +55,8 @@ pub enum SimplifiedTypeGen<D>\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn simplify_type(\n+    tcx: TyCtxt<'_>,\n     ty: Ty<'_>,\n     can_simplify_params: bool,\n ) -> Option<SimplifiedType> {"}, {"sha": "ad9880725128f0156af94de039c9aaf1d70c313c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -213,7 +213,7 @@ impl AssocItem {\n         }\n     }\n \n-    pub fn signature<'tcx>(&self, tcx: TyCtxt<'tcx>) -> String {\n+    pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n         match self.kind {\n             ty::AssocKind::Method => {\n                 // We skip the binder here because the binder would deanonymize all\n@@ -2311,7 +2311,7 @@ impl<'tcx> AdtDef {\n     /// Returns an iterator over all fields contained\n     /// by this ADT.\n     #[inline]\n-    pub fn all_fields<'s>(&'s self) -> impl Iterator<Item = &'s FieldDef> + Clone {\n+    pub fn all_fields(&self) -> impl Iterator<Item=&FieldDef> + Clone {\n         self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n@@ -2777,20 +2777,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n     }\n \n-    pub fn expr_span(self, id: NodeId) -> Span {\n-        match self.hir().find(id) {\n-            Some(Node::Expr(e)) => {\n-                e.span\n-            }\n-            Some(f) => {\n-                bug!(\"node-ID {} is not an expr: {:?}\", id, f);\n-            }\n-            None => {\n-                bug!(\"node-ID {} is not present in the node map\", id);\n-            }\n-        }\n-    }\n-\n     pub fn provided_trait_methods(self, id: DefId) -> Vec<AssocItem> {\n         self.associated_items(id)\n             .filter(|item| item.kind == AssocKind::Method && item.defaultness.has_value())\n@@ -2805,7 +2791,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n         let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n-            match self.hir().get_by_hir_id(hir_id) {\n+            match self.hir().get(hir_id) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -3125,7 +3111,7 @@ impl Iterator for AssocItemsIterator<'_> {\n     }\n }\n \n-fn associated_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AssocItem {\n+fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n@@ -3170,7 +3156,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n ///       such.\n ///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n-fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AdtSizedConstraint<'tcx> {\n+fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> AdtSizedConstraint<'_> {\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(def.variants.iter().flat_map(|v| {\n@@ -3184,7 +3170,7 @@ fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AdtSizedConst\n     AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DefId] {\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(id);\n     match item.node {\n@@ -3207,14 +3193,14 @@ fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Def\n     }\n }\n \n-fn def_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n+fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given `DefId` describes an item belonging to a trait,\n /// returns the `DefId` of the trait that the trait item belongs to;\n /// otherwise, returns `None`.\n-fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId> {\n+fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n             match associated_item.container {\n@@ -3227,7 +3213,7 @@ fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId> {\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get_by_hir_id(hir_id) {\n+        if let Node::Item(item) = tcx.hir().get(hir_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }\n@@ -3237,7 +3223,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n }\n \n /// See `ParamEnv` struct definition for details.\n-fn param_env<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n+fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ParamEnv<'_> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n         return param_env(tcx, parent);\n@@ -3272,17 +3258,17 @@ fn param_env<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n-fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> CrateDisambiguator {\n+fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> Symbol {\n+fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.crate_name.clone()\n }\n \n-fn crate_hash<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> Svh {\n+fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.hir().crate_hash\n }\n@@ -3302,7 +3288,7 @@ fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx>, instance_def: InstanceDef\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Ty<'tcx>> {\n+fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap_or_else(|| {"}, {"sha": "cb0ac0f07f28717fa7652b3151b0ebff2a9ee75c", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -600,7 +600,7 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(var_id)),\n+                                    self.tcx().hir().name(var_id)),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -643,7 +643,7 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(var_id)),\n+                                    self.tcx().hir().name(var_id)),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }"}, {"sha": "3d8170586c47f9248e97b3d73e0f057e3c84eb9d", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -62,7 +62,7 @@ impl fmt::Debug for ty::ClosureUpvar<'tcx> {\n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let name = ty::tls::with(|tcx| {\n-            tcx.hir().name_by_hir_id(self.var_path.hir_id)\n+            tcx.hir().name(self.var_path.hir_id)\n         });\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n             self.var_path.hir_id,"}, {"sha": "a7ade875bf11b25d61368a5298d061218d5c37fe", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -150,10 +150,10 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n // Query provider for `trait_impls_of`.\n-pub(super) fn trait_impls_of_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(super) fn trait_impls_of_provider(\n+    tcx: TyCtxt<'_>,\n     trait_id: DefId,\n-) -> &'tcx TraitImpls {\n+) -> &TraitImpls {\n     let mut impls = TraitImpls::default();\n \n     {"}, {"sha": "c74511cf0fdda02acfb7b63994981aa1fc89c556", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n     }\n }\n \n-pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> smallvec::IntoIter<TypeWalkerArray<'tcx>> {\n+pub fn walk_shallow(ty: Ty<'_>) -> smallvec::IntoIter<TypeWalkerArray<'_>> {\n     let mut stack = SmallVec::new();\n     push_subtypes(&mut stack, ty);\n     stack.into_iter()"}, {"sha": "714b7c27200e3ebe0215dbd1c12522930079fff7", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -191,7 +191,7 @@ pub fn check_loans<'a, 'tcx>(\n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n \n     let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir().get_by_hir_id(hir_id) {\n+    let movable_generator = !match bccx.tcx.hir().get(hir_id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             .."}, {"sha": "fa286632dac8480a8f3a6f6410a15f379e3da5f9", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -49,7 +49,7 @@ fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx>, pat: &Pat) -> PatternSource<'tcx>\n \n     let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n \n-    match tcx.hir().get_by_hir_id(parent) {\n+    match tcx.hir().get(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {"}, {"sha": "87c0b8563cadb45e568d67bb7b70528b36f622f8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -80,7 +80,7 @@ fn borrowck<'tcx>(tcx: TyCtxt<'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckRe\n \n     let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n-    match tcx.hir().get_by_hir_id(owner_id) {\n+    match tcx.hir().get(owner_id) {\n         Node::Ctor(..) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n@@ -390,7 +390,7 @@ pub enum LoanPathElem<'tcx> {\n \n fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n-    match tcx.hir().get_by_hir_id(closure_id) {\n+    match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.hir_id\n@@ -702,7 +702,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n             move_data::MovePat => (self.tcx.hir().span(hir_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir().expect_expr_by_hir_id(hir_id).node {\n+                (match self.tcx.hir().expect_expr(hir_id).node {\n                     hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n@@ -896,7 +896,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 // to implement two traits for \"one operator\" is not very intuitive for\n                 // many programmers.\n                 if err.cmt.note == mc::NoteIndex {\n-                    let node = self.tcx.hir().get_by_hir_id(err.cmt.hir_id);\n+                    let node = self.tcx.hir().get(err.cmt.hir_id);\n \n                     // This pattern probably always matches.\n                     if let Node::Expr(\n@@ -1172,7 +1172,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n     }\n \n     fn local_binding_mode(&self, hir_id: hir::HirId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir().get_by_hir_id(hir_id) {\n+        let pat = match self.tcx.hir().get(hir_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1190,7 +1190,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n \n     fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n         let parent = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n-        let parent_node = self.tcx.hir().get_by_hir_id(parent);\n+        let parent_node = self.tcx.hir().get(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n@@ -1255,7 +1255,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                     None => return\n                 };\n \n-                if let Node::Field(ref field) = self.tcx.hir().get_by_hir_id(hir_id) {\n+                if let Node::Field(ref field) = self.tcx.hir().get(hir_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }\n@@ -1394,10 +1394,10 @@ impl BorrowckCtxt<'_, 'tcx> {\n                                       out: &mut String) {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {"}, {"sha": "e02d14a151e620c069f083abac81952b74422c28", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -210,7 +210,7 @@ impl CodegenCx<'ll, 'tcx> {\n         let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n \n             let llty = self.layout_of(ty).llvm_type(self);\n-            let (g, attrs) = match self.tcx.hir().get_by_hir_id(id) {\n+            let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {"}, {"sha": "b9ee82f108ae34a50dcacb12918609efcc359e0c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -82,7 +82,7 @@ fn reachable_non_generics_provider<'tcx>(\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get_by_hir_id(hir_id) {\n+            match tcx.hir().get(hir_id) {\n                 Node::ForeignItem(..) => {\n                     let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {"}, {"sha": "7ccd024769f757179a4af9e1b4cf5e8d2c14067f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -135,7 +135,7 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = hir_id {\n-        match tcx.hir().get_by_hir_id(id) {\n+        match tcx.hir().get(id) {\n             Node::ForeignItem(_) => true,\n             _ => false,\n         }"}, {"sha": "030166182490b6e9b180428f207eb4d63aee58e6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -627,7 +627,7 @@ fn print_flowgraph<'tcx, W: Write>(\n             // Find the function this expression is from.\n             let mut hir_id = expr.hir_id;\n             loop {\n-                let node = tcx.hir().get_by_hir_id(hir_id);\n+                let node = tcx.hir().get(hir_id);\n                 if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n                     break n.body();\n                 }\n@@ -830,7 +830,8 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          box out,\n                                                                          annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n-                        let node = hir_map.get(node_id);\n+                        let hir_id = tcx.hir().node_to_hir_id(node_id);\n+                        let node = hir_map.get(hir_id);\n                         pp_state.print_node(node)?;\n                         pp_state.s.space()?;\n                         let path = annotation.node_path(node_id)\n@@ -847,7 +848,8 @@ pub fn print_after_hir_lowering<'tcx>(\n                 s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n-                        let node = tcx.hir().get(node_id);\n+                        let hir_id = tcx.hir().node_to_hir_id(node_id);\n+                        let node = tcx.hir().get(hir_id);\n                         write!(out, \"{:#?}\", node)?;\n                     }\n                     Ok(())\n@@ -909,7 +911,8 @@ fn print_with_analysis<'tcx>(\n                 tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n             });\n \n-            match blocks::Code::from_node(&tcx.hir(), nodeid) {\n+            let hir_id = tcx.hir().node_to_hir_id(nodeid);\n+            match blocks::Code::from_node(&tcx.hir(), hir_id) {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(tcx.sess);\n "}, {"sha": "5296ed0ffd0b818bfa46b554c729f558f4407e78", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -322,7 +322,7 @@ impl DirtyCleanVisitor<'tcx> {\n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n     fn auto_labels(&mut self, item_id: hir::HirId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir().get_by_hir_id(item_id);\n+        let node = self.tcx.hir().get(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.node {"}, {"sha": "cd4eecf26387fbb7108c8ec76a7fcc280af6f41a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -276,7 +276,7 @@ fn lint_int_literal<'a, 'tcx>(\n         }\n \n         let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n+        if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.node {\n                 if is_range_literal(cx.sess(), par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n@@ -315,7 +315,7 @@ fn lint_uint_literal<'a, 'tcx>(\n     };\n     if lit_val < min || lit_val > max {\n         let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(parent_id) {\n+        if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.node {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.tables.expr_ty(par_e).sty {"}, {"sha": "f23cffeda689c779eb7a8a558f1f97833a1433e8", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -853,7 +853,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     format!(\n                         \"...but `{}` will be dropped here, when the function `{}` returns\",\n                         name,\n-                        self.infcx.tcx.hir().name_by_hir_id(fn_hir_id),\n+                        self.infcx.tcx.hir().name(fn_hir_id),\n                     ),\n                 );\n "}, {"sha": "ac64cf79537cd8c4715c3123068b03b7b8ac6072", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -349,7 +349,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let (&var_id, _) = self.infcx.tcx.upvars(def_id).unwrap()\n                         .get_index(field.index()).unwrap();\n \n-                    self.infcx.tcx.hir().name_by_hir_id(var_id).to_string()\n+                    self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -659,7 +659,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             def_id, target_place, places\n         );\n         let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n-        let expr = &self.infcx.tcx.hir().expect_expr_by_hir_id(hir_id).node;\n+        let expr = &self.infcx.tcx.hir().expect_expr(hir_id).node;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(\n             .., args_span, _"}, {"sha": "919ed5ccaba1e9170e85bc91b17d83b8fff51cd7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -124,14 +124,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n         .flat_map(|v| v.values())\n         .map(|upvar_id| {\n             let var_hir_id = upvar_id.var_path.hir_id;\n-            let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);\n             let capture = tables.upvar_capture(*upvar_id);\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n             let mut upvar = Upvar {\n-                name: tcx.hir().name(var_node_id),\n+                name: tcx.hir().name(var_hir_id),\n                 var_hir_id,\n                 by_ref,\n                 mutability: Mutability::Not,\n@@ -231,7 +230,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n-    let movable_generator = match tcx.hir().get_by_hir_id(id) {\n+    let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             .."}, {"sha": "3f5b2f4bce78b7973431515aeab11d908e83eb93", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -237,7 +237,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr_by_hir_id(mir_hir_id).node\n+                            tcx.hir().expect_expr(mir_hir_id).node\n                         {\n                             span\n                         } else {\n@@ -698,7 +698,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) = match tcx.hir().get_by_hir_id(mir_hir_id) {\n+        let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n@@ -761,7 +761,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let yield_span = match tcx.hir().get_by_hir_id(mir_hir_id) {\n+        let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, _, _, span, _),\n                 .."}, {"sha": "750a1324faeb3de025ba76910d2d1e0d6086aa0e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let upvar_hir_id = upvars[upvar_index].var_hir_id;\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n-        let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);\n+        let upvar_name = tcx.hir().name(upvar_hir_id);\n         let upvar_span = tcx.hir().span(upvar_hir_id);\n         debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n                upvar_name, upvar_span);"}, {"sha": "a85f4776a8bee2638def80071668c35cb35cb875", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -767,7 +767,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n                 owner: fn_def_id.index,\n                 local_id: *late_bound,\n             };\n-            let name = tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id).as_interned_str();\n             let region_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,"}, {"sha": "66064221b391c4b9b162359ec71e8d9007f39383", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -26,7 +26,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n-    let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n+    let (body_id, return_ty_span) = match tcx.hir().get(id) {\n         Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem("}, {"sha": "597f172da671f52c02e02a00011bd22d13d4316b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -914,7 +914,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n             let index = generics.param_def_id_to_index[&local_def_id];\n-            let name = cx.tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n+            let name = cx.tcx.hir().name(hir_id).as_interned_str();\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const("}, {"sha": "a21d900cf5e5e2344e21bdfd95b213a4b2957adb", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir().get_by_hir_id(p.hir_id) {\n+        let p = match tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };"}, {"sha": "e42c667fec9ef5241526c946cef975654e99b753", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -193,7 +193,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n-                            let node = self.ecx.tcx.hir().get_by_hir_id(var_hir_id);\n+                            let node = self.ecx.tcx.hir().get(var_hir_id);\n                             if let hir::Node::Binding(pat) = node {\n                                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                                     name = Some(ident.name);"}, {"sha": "8c815a51b5d65d919eddd59d4f8febffe512a370", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::subst::InternalSubsts;\n pub fn check(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n-    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n+    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n     }\n }"}, {"sha": "9092cf2c457963f704ffa97b340ffe494e6c9640", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -41,7 +41,7 @@ impl MirPass for ConstProp {\n         let hir_id = tcx.hir().as_local_hir_id(source.def_id())\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n-        let is_fn_like = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)).is_some();\n+        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n         let is_assoc_const = match tcx.def_kind(source.def_id()) {\n             Some(DefKind::AssocConst) => true,\n             _ => false,"}, {"sha": "1c18322259f808fcee21c3304c303bfd28a28a70", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     let loop_kind = if loop_id == hir::DUMMY_HIR_ID {\n                         None\n                     } else {\n-                        Some(match self.hir_map.expect_expr_by_hir_id(loop_id).node {\n+                        Some(match self.hir_map.expect_expr(loop_id).node {\n                             hir::ExprKind::While(..) => LoopKind::WhileLoop,\n                             hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n                             ref r => span_bug!(e.span,"}, {"sha": "0fdc9ac8903500e111a7e7e622c90a52257dc1ad", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -229,14 +229,14 @@ fn def_id_visibility<'tcx>(\n ) -> (ty::Visibility, Span, &'static str) {\n     match tcx.hir().as_local_hir_id(def_id) {\n         Some(hir_id) => {\n-            let vis = match tcx.hir().get_by_hir_id(hir_id) {\n+            let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::TraitItem(..) | Node::Variant(..) => {\n                     return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n                 Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get_by_hir_id(tcx.hir().get_parent_item(hir_id)) {\n+                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n                         Node::Item(item) => match &item.node {\n                             hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n                             hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n@@ -248,7 +248,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::Ctor(vdata) => {\n                     let parent_hir_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n-                    match tcx.hir().get_by_hir_id(parent_hir_id) {\n+                    match tcx.hir().get(parent_hir_id) {\n                         Node::Variant(..) => {\n                             let parent_did = tcx.hir().local_def_id_from_hir_id(parent_hir_id);\n                             let (mut ctor_vis, mut span, mut descr) = def_id_visibility(\n@@ -274,7 +274,7 @@ fn def_id_visibility<'tcx>(\n                             return (ctor_vis, span, descr);\n                         }\n                         Node::Item(..) => {\n-                            let item = match tcx.hir().get_by_hir_id(parent_hir_id) {\n+                            let item = match tcx.hir().get(parent_hir_id) {\n                                 Node::Item(item) => item,\n                                 node => bug!(\"unexpected node kind: {:?}\", node),\n                             };"}, {"sha": "f67241ef23efcbf6d6ca4d5246c62869c0d52d06", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1531,7 +1531,8 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n         self.process_macro_use(ex.span);\n         match ex.node {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.id);\n+                let expr_hir_id = self.save_ctxt.tcx.hir().node_to_hir_id(ex.id);\n+                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {"}, {"sha": "23fe150c6ff6515f2431cce37dc89c01e99a04b3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -513,7 +513,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let hir_node = self.tcx.hir().expect_expr(expr.id);\n+        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr.id);\n+        let hir_node = self.tcx.hir().expect_expr(expr_hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::Error {\n             return None;\n@@ -606,7 +607,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_res(&self, id: NodeId) -> Res {\n-        match self.tcx.hir().get(id) {\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        match self.tcx.hir().get(hir_id) {\n             Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item {\n@@ -627,7 +629,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) => {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.tables.qpath_res(qpath, hir_id)\n             }\n \n@@ -651,7 +652,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 node: hir::TyKind::Path(ref qpath),\n                 ..\n             }) => {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.tables.qpath_res(qpath, hir_id)\n             }\n "}, {"sha": "017368558314824c1dfa9c8bdf227680b58135fa", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -185,7 +185,7 @@ crate fn environment<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Environment<'tcx\n         .map(Clause::ForAll);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let node = tcx.hir().get_by_hir_id(hir_id);\n+    let node = tcx.hir().get(hir_id);\n \n     enum NodeKind {\n         TraitImpl,"}, {"sha": "33d9b1ff0c6ce85af1b7a5b4ef0130de6087d59c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -123,7 +123,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| {\n-            tcx.hir().name_by_hir_id(tcx.hir().as_local_hir_id(def_id).unwrap()).as_interned_str()\n+            tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap()).as_interned_str()\n         };\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n@@ -1253,7 +1253,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {\n             span_err!(tcx.sess, span, E0224,\n-                \"at least one non-builtin trait is required for an object type\");\n+                \"at least one trait is required for an object type\");\n             return tcx.types.err;\n         }\n \n@@ -2004,7 +2004,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n-                tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n+                tcx.mk_ty_param(index, tcx.hir().name(hir_id).as_interned_str())\n             }\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait or type alias.\n@@ -2194,7 +2194,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n             let index = generics.param_def_id_to_index[&tcx.hir().local_def_id_from_hir_id(hir_id)];\n-            let name = tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id).as_interned_str();\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }\n "}, {"sha": "293b68c8711317736ca1c1ba40929dbf067dcfce", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let PatKind::Binding(..) = inner.node {\n             let parent_id = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n-            let parent = tcx.hir().get_by_hir_id(parent_id);\n+            let parent = tcx.hir().get(parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, parent);\n             match parent {\n                 hir::Node::Item(hir::Item { node: hir::ItemKind::Fn(..), .. }) |\n@@ -812,10 +812,10 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let match_id = hir.get_parent_node_by_hir_id(arm_id);\n         let containing_id = hir.get_parent_node_by_hir_id(match_id);\n \n-        let node = hir.get_by_hir_id(containing_id);\n+        let node = hir.get(containing_id);\n         if let Block(block) = node {\n             // check that the body's parent is an fn\n-            let parent = hir.get_by_hir_id(\n+            let parent = hir.get(\n                 hir.get_parent_node_by_hir_id(\n                     hir.get_parent_node_by_hir_id(block.hir_id),\n                 ),"}, {"sha": "87807ad91a27db7a14e76ff67c7d39499f61a845", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         callee_span: Span,\n     ) {\n         let hir_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n-        let parent_node = self.tcx.hir().get_by_hir_id(hir_id);\n+        let parent_node = self.tcx.hir().get(hir_id);\n         if let (\n             hir::Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),\n             hir::ExprKind::Block(..),"}, {"sha": "71a0ca090b0d8e58575268f40eb79de3d8c0fc5e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1291,7 +1291,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 cause.span,\n                 blk_id,\n             );\n-            let parent = fcx.tcx.hir().get_by_hir_id(parent_id);\n+            let parent = fcx.tcx.hir().get(parent_id);\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         } else {\n             fcx.get_fn_decl(parent_id)"}, {"sha": "8ad67c2adc035e1526311ad86f284a4bb1e6f7bf", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span);\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n-                                        let parent_node = self.tcx.hir().get_by_hir_id(\n+                                        let parent_node = self.tcx.hir().get(\n                                             self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n                                         );\n                                         let msg = format!(\n@@ -389,7 +389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MachineApplicable,\n                                 );\n                             } else {\n-                                let call_expr = self.tcx.hir().expect_expr_by_hir_id(\n+                                let call_expr = self.tcx.hir().expect_expr(\n                                     self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id),\n                                 );\n "}, {"sha": "0ec5c9763a0fb1714af4aa5e9cb15321cfa0c5f5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -759,7 +759,7 @@ fn primary_body_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n ) -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)> {\n-    match tcx.hir().get_by_hir_id(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n@@ -993,10 +993,9 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         if let PatKind::Binding(_, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n-            let node_id = self.fcx.tcx.hir().hir_to_node_id(p.hir_id);\n             if !self.fcx.tcx.features().unsized_locals {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n-                                               traits::VariableType(node_id));\n+                                               traits::VariableType(p.hir_id));\n             }\n \n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n@@ -1214,7 +1213,7 @@ fn check_fn<'a, 'tcx>(\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1262,7 +1261,7 @@ fn check_fn<'a, 'tcx>(\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -3677,7 +3676,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n-        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_item(id));\n+        let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n         match node {\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(_, _, _, body_id), ..\n@@ -3697,7 +3696,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n     fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, ast::Ident)> {\n-        let parent = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_item(blk_id));\n+        let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n@@ -3732,7 +3731,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n-            let parent = self.tcx.hir().get_by_hir_id(blk_id);\n+            let parent = self.tcx.hir().get(blk_id);\n             self.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         })\n     }\n@@ -4259,7 +4258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        if let Node::Expr(expr) = self.tcx.hir().get_by_hir_id(\n+        if let Node::Expr(expr) = self.tcx.hir().get(\n             self.tcx.hir().get_parent_node_by_hir_id(hir_id))\n         {\n             if let ExprKind::Call(ref callee, ..) = expr.node {\n@@ -4335,7 +4334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut contained_in_place = false;\n \n         while let hir::Node::Expr(parent_expr) =\n-            self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr_id))\n+            self.tcx.hir().get(self.tcx.hir().get_parent_node_by_hir_id(expr_id))\n         {\n             match &parent_expr.node {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {"}, {"sha": "ac39757df74dc38b69a94e707bd4b9f0815f246a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -652,5 +652,5 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> ast::Name {\n-    tcx.hir().name_by_hir_id(var_hir_id)\n+    tcx.hir().name(var_hir_id)\n }"}, {"sha": "301168aefd203640200a00e122d908971d04300e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -284,7 +284,7 @@ fn type_param_predicates<'tcx>(\n     let mut extend = None;\n \n     let item_hir_id = tcx.hir().as_local_hir_id(item_def_id).unwrap();\n-    let ast_generics = match tcx.hir().get_by_hir_id(item_hir_id) {\n+    let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => &item.generics,\n@@ -623,7 +623,7 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = match tcx.hir().get_by_hir_id(hir_id) {\n+    let item = match tcx.hir().get(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n     };\n@@ -693,7 +693,7 @@ fn super_predicates_of<'tcx>(\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n \n-    let item = match tcx.hir().get_by_hir_id(trait_hir_id) {\n+    let item = match tcx.hir().get(trait_hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n     };\n@@ -884,7 +884,7 @@ fn generics_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n-    let node = tcx.hir().get_by_hir_id(hir_id);\n+    let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n         Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_) |\n         Node::Ctor(..) | Node::Field(_) => {\n@@ -1154,7 +1154,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    Some(match tcx.hir().get_by_hir_id(hir_id) {\n+    Some(match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1298,7 +1298,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n         }\n \n         Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get_by_hir_id(tcx.hir().get_parent_node_by_hir_id(hir_id));\n+            let parent_node = tcx.hir().get(tcx.hir().get_parent_node_by_hir_id(hir_id));\n             match parent_node {\n                 Node::Ty(&hir::Ty {\n                     node: hir::TyKind::Array(_, ref constant),\n@@ -1660,8 +1660,8 @@ fn find_existential_constraints<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'t\n     if scope == hir::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get_by_hir_id(scope));\n-        match tcx.hir().get_by_hir_id(scope) {\n+        debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n             Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n@@ -1690,7 +1690,7 @@ fn fn_sig<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get_by_hir_id(hir_id) {\n+    match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n@@ -1903,7 +1903,7 @@ fn explicit_predicates_of<'tcx>(\n         Some(hir_id) => hir_id,\n         None => return tcx.predicates_of(def_id),\n     };\n-    let node = tcx.hir().get_by_hir_id(hir_id);\n+    let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;"}, {"sha": "f2661b46b8b0c56a291cbcf994a63bf034db3cae", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -61,7 +61,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n             .hir()\n             .as_local_hir_id(item_did)\n             .expect(\"expected local def-id\");\n-        let item = match self.tcx.hir().get_by_hir_id(hir_id) {\n+        let item = match self.tcx.hir().get(hir_id) {\n             Node::Item(item) => item,\n             _ => bug!(),\n         };"}, {"sha": "63e41e01fbff5ffb512558aa931cbd9dfafeefd9", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -29,7 +29,7 @@ fn inferred_outlives_of<'tcx>(\n         .as_local_hir_id(item_def_id)\n         .expect(\"expected local def-id\");\n \n-    match tcx.hir().get_by_hir_id(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);"}, {"sha": "1a8871a3da9dab3230dda20d4cd554c5c9919301", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -48,7 +48,7 @@ fn variances_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> &'tcx [ty::Varia\n         // Variance not relevant.\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n-    match tcx.hir().get_by_hir_id(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |"}, {"sha": "3158ec3832aed5d20d99462761e2bd93833f0744", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -11,5 +11,6 @@ path = \"lib.rs\"\n [dependencies]\n pulldown-cmark = { version = \"0.5.2\", default-features = false }\n minifier = \"0.0.30\"\n+rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "740947fc3e37e8d1f20700d21d8bb6b24dfb1127", "filename": "src/librustdoc/docfs.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -0,0 +1,116 @@\n+//! Rustdoc's FileSystem abstraction module.\n+//!\n+//! On Windows this indirects IO into threads to work around performance issues\n+//! with Defender (and other similar virus scanners that do blocking operations).\n+//! On other platforms this is a thin shim to fs.\n+//!\n+//! Only calls needed to permit this workaround have been abstracted: thus\n+//! fs::read is still done directly via the fs module; if in future rustdoc\n+//! needs to read-after-write from a file, then it would be added to this\n+//! abstraction.\n+\n+use errors;\n+\n+use std::fs;\n+use std::io;\n+use std::path::Path;\n+use std::sync::Arc;\n+use std::sync::mpsc::{channel, Receiver, Sender};\n+\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => {{\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(E::new(e, $file)),\n+        }\n+    }};\n+}\n+\n+pub trait PathError {\n+    fn new<P: AsRef<Path>>(e: io::Error, path: P) -> Self;\n+}\n+\n+pub struct ErrorStorage {\n+    sender: Option<Sender<Option<String>>>,\n+    receiver: Receiver<Option<String>>,\n+}\n+\n+impl ErrorStorage {\n+    pub fn new() -> ErrorStorage {\n+        let (sender, receiver) = channel();\n+        ErrorStorage {\n+            sender: Some(sender),\n+            receiver,\n+        }\n+    }\n+\n+    /// Prints all stored errors. Returns the number of printed errors.\n+    pub fn write_errors(&mut self, diag: &errors::Handler) -> usize {\n+        let mut printed = 0;\n+        // In order to drop the sender part of the channel.\n+        self.sender = None;\n+\n+        for msg in self.receiver.iter() {\n+            if let Some(ref error) = msg {\n+                diag.struct_err(&error).emit();\n+                printed += 1;\n+            }\n+        }\n+        printed\n+    }\n+}\n+\n+pub struct DocFS {\n+    sync_only: bool,\n+    errors: Arc<ErrorStorage>,\n+}\n+\n+impl DocFS {\n+    pub fn new(errors: &Arc<ErrorStorage>) -> DocFS {\n+        DocFS {\n+            sync_only: false,\n+            errors: Arc::clone(errors),\n+        }\n+    }\n+\n+    pub fn set_sync_only(&mut self, sync_only: bool) {\n+        self.sync_only = sync_only;\n+    }\n+\n+    pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        // For now, dir creation isn't a huge time consideration, do it\n+        // synchronously, which avoids needing ordering between write() actions\n+        // and directory creation.\n+        fs::create_dir_all(path)\n+    }\n+\n+    pub fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n+    where\n+        P: AsRef<Path>,\n+        C: AsRef<[u8]>,\n+        E: PathError,\n+    {\n+        if !self.sync_only && cfg!(windows) {\n+            // A possible future enhancement after more detailed profiling would\n+            // be to create the file sync so errors are reported eagerly.\n+            let contents = contents.as_ref().to_vec();\n+            let path = path.as_ref().to_path_buf();\n+            let sender = self.errors.sender.clone().unwrap();\n+            rayon::spawn(move || {\n+                match fs::write(&path, &contents) {\n+                    Ok(_) => {\n+                        sender.send(None)\n+                            .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                    }\n+                    Err(e) => {\n+                        sender.send(Some(format!(\"\\\"{}\\\": {}\", path.display(), e)))\n+                            .expect(&format!(\"failed to send non-error on \\\"{}\\\"\", path.display()));\n+                    }\n+                }\n+            });\n+            Ok(())\n+        } else {\n+            Ok(try_err!(fs::write(&path, contents), path))\n+        }\n+    }\n+}"}, {"sha": "f0aff961c675170874e8a1429effc63505c789f0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 167, "deletions": 137, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -35,9 +35,9 @@ use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n use std::ffi::OsStr;\n-use std::fs::{self, File, OpenOptions};\n+use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::io::{self, BufWriter, BufReader};\n+use std::io::{self, BufReader};\n use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n@@ -61,6 +61,7 @@ use rustc_data_structures::flock;\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n@@ -89,6 +90,58 @@ impl<'a> Display for SlashChecker<'a> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct Error {\n+    pub file: PathBuf,\n+    pub error: io::Error,\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        self.error.description()\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        let file = self.file.display().to_string();\n+        if file.is_empty() {\n+            write!(f, \"{}\", self.error)\n+        } else {\n+            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n+        }\n+    }\n+}\n+\n+impl PathError for Error {\n+    fn new<P: AsRef<Path>>(e: io::Error, path: P) -> Error {\n+        Error {\n+            file: path.as_ref().to_path_buf(),\n+            error: e,\n+        }\n+    }\n+}\n+\n+macro_rules! try_none {\n+    ($e:expr, $file:expr) => ({\n+        use std::io;\n+        match $e {\n+            Some(e) => e,\n+            None => return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"),\n+                                          $file))\n+        }\n+    })\n+}\n+\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => ({\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(Error::new(e, $file)),\n+        }\n+    })\n+}\n+\n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n /// how the current page is being rendered.\n@@ -156,13 +209,15 @@ struct SharedContext {\n     pub generate_search_filter: bool,\n     /// Option disabled by default to generate files used by RLS and some other tools.\n     pub generate_redirect_pages: bool,\n+    /// The fs handle we are working with.\n+    pub fs: DocFS,\n }\n \n impl SharedContext {\n-    fn ensure_dir(&self, dst: &Path) -> io::Result<()> {\n+    fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n-            fs::create_dir_all(dst)?;\n+            try_err!(self.fs.create_dir_all(dst), dst);\n             dirs.insert(dst.to_path_buf());\n         }\n \n@@ -216,53 +271,6 @@ impl Impl {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: io::Error,\n-}\n-\n-impl error::Error for Error {\n-    fn description(&self) -> &str {\n-        self.error.description()\n-    }\n-}\n-\n-impl Display for Error {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n-    }\n-}\n-\n-impl Error {\n-    pub fn new(e: io::Error, file: &Path) -> Error {\n-        Error {\n-            file: file.to_path_buf(),\n-            error: e,\n-        }\n-    }\n-}\n-\n-macro_rules! try_none {\n-    ($e:expr, $file:expr) => ({\n-        use std::io;\n-        match $e {\n-            Some(e) => e,\n-            None => return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"),\n-                                          $file))\n-        }\n-    })\n-}\n-\n-macro_rules! try_err {\n-    ($e:expr, $file:expr) => ({\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => return Err(Error::new(e, $file)),\n-        }\n-    })\n-}\n-\n /// This cache is used to store information about the `clean::Crate` being\n /// rendered in order to provide more useful documentation. This contains\n /// information like all implementors of a trait, all traits a type implements,\n@@ -544,6 +552,7 @@ pub fn run(mut krate: clean::Crate,\n         },\n         _ => PathBuf::new(),\n     };\n+    let mut errors = Arc::new(ErrorStorage::new());\n     let mut scx = SharedContext {\n         src_root,\n         passes,\n@@ -564,6 +573,7 @@ pub fn run(mut krate: clean::Crate,\n         static_root_path,\n         generate_search_filter,\n         generate_redirect_pages,\n+        fs: DocFS::new(&errors),\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -601,9 +611,9 @@ pub fn run(mut krate: clean::Crate,\n         }\n     }\n     let dst = output;\n-    try_err!(fs::create_dir_all(&dst), &dst);\n+    scx.ensure_dir(&dst)?;\n     krate = render_sources(&dst, &mut scx, krate)?;\n-    let cx = Context {\n+    let mut cx = Context {\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n@@ -705,10 +715,21 @@ pub fn run(mut krate: clean::Crate,\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n+    // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n     write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n+    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n \n     // And finally render the whole crate's documentation\n-    cx.krate(krate)\n+    let ret = cx.krate(krate);\n+    let nb_errors = Arc::get_mut(&mut errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n+    if ret.is_err() {\n+        ret\n+    } else if nb_errors > 0 {\n+        Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Builds the search index from the collected metadata\n@@ -797,13 +818,13 @@ fn write_shared(\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write_minify(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n                  static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n                  static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n                  static_files::NOSCRIPT_CSS,\n                  options.enable_minification)?;\n \n@@ -815,11 +836,13 @@ fn write_shared(\n         let content = try_err!(fs::read(&entry), &entry);\n         let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n         let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n-        write(cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n-              content.as_slice())?;\n+        cx.shared.fs.write(\n+            cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n+            content.as_slice())?;\n         themes.insert(theme.to_owned());\n     }\n \n+    let write = |p, c| { cx.shared.fs.write(p, c) };\n     if (*cx.shared).layout.logo.is_empty() {\n         write(cx.dst.join(&format!(\"rust-logo{}.png\", cx.shared.resource_suffix)),\n               static_files::RUST_LOGO)?;\n@@ -834,11 +857,11 @@ fn write_shared(\n           static_files::WHEEL_SVG)?;\n     write(cx.dst.join(&format!(\"down-arrow{}.svg\", cx.shared.resource_suffix)),\n           static_files::DOWN_ARROW_SVG)?;\n-    write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n                  static_files::themes::LIGHT,\n                  options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n-    write_minify(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n                  static_files::themes::DARK,\n                  options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n@@ -847,8 +870,7 @@ fn write_shared(\n     themes.sort();\n     // To avoid theme switch latencies as much as possible, we put everything theme related\n     // at the beginning of the html files into another js file.\n-    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n-          format!(\n+    let theme_js = format!(\n r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n@@ -891,39 +913,45 @@ themePicker.onblur = handleThemeButtonsBlur;\n                  themes.iter()\n                        .map(|s| format!(\"\\\"{}\\\"\", s))\n                        .collect::<Vec<String>>()\n-                       .join(\",\")).as_bytes(),\n+                       .join(\",\"));\n+    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n+          theme_js.as_bytes()\n     )?;\n \n-    write_minify(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n                  static_files::MAIN_JS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n                  static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n     if cx.shared.include_sources {\n-        write_minify(cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n-                     static_files::sidebar::SOURCE_SCRIPT,\n-                     options.enable_minification)?;\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n+            static_files::sidebar::SOURCE_SCRIPT,\n+            options.enable_minification)?;\n     }\n \n     {\n-        write_minify(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n-                     &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n-                              cx.shared.resource_suffix,\n-                              static_files::STORAGE_JS),\n-                     options.enable_minification)?;\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n+            &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n+                     cx.shared.resource_suffix,\n+                     static_files::STORAGE_JS),\n+            options.enable_minification)?;\n     }\n \n     if let Some(ref css) = cx.shared.css_file_extension {\n         let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n+        let buffer = try_err!(fs::read_to_string(css), css);\n         if !options.enable_minification {\n-            try_err!(fs::copy(css, out), css);\n+            cx.shared.fs.write(&out, &buffer)?;\n         } else {\n-            let buffer = try_err!(fs::read_to_string(css), css);\n-            write_minify(out, &buffer, options.enable_minification)?;\n+            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n         }\n     }\n-    write_minify(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n                  static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n@@ -999,7 +1027,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n     let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n-        let mut w = try_err!(File::create(&dst), &dst);\n         let mut output = String::with_capacity(100);\n         for (alias, items) in &cache.aliases {\n             if items.is_empty() {\n@@ -1014,10 +1041,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         all_aliases.push(format!(\"ALIASES[\\\"{}\\\"] = {{{}}};\", krate.name, output));\n         all_aliases.sort();\n-        try_err!(writeln!(&mut w, \"var ALIASES = {{}};\"), &dst);\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"var ALIASES = {{}};\"), &dst);\n         for aliases in &all_aliases {\n-            try_err!(writeln!(&mut w, \"{}\", aliases), &dst);\n+            try_err!(writeln!(&mut v, \"{}\", aliases), &dst);\n         }\n+        cx.shared.fs.write(&dst, &v)?;\n     }\n \n     use std::ffi::OsString;\n@@ -1101,11 +1130,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                  &krate.name,\n                                  hierarchy.to_json_string()));\n         all_sources.sort();\n-        let mut w = try_err!(File::create(&dst), &dst);\n-        try_err!(writeln!(&mut w,\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v,\n                           \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\",\n                           all_sources.join(\"\\n\")),\n                  &dst);\n+        cx.shared.fs.write(&dst, &v)?;\n     }\n \n     // Update the search index\n@@ -1119,14 +1149,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // Sort the indexes by crate so the file will be generated identically even\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n-    let mut w = try_err!(File::create(&dst), &dst);\n-    try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n-    try_err!(write_minify_replacer(&mut w,\n-                                   &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n-                                   options.enable_minification),\n-             &dst);\n-    try_err!(write!(&mut w, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n-\n+    {\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n+        try_err!(write_minify_replacer(\n+            &mut v,\n+            &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n+            options.enable_minification),\n+            &dst);\n+        try_err!(write!(&mut v, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n+        cx.shared.fs.write(&dst, &v)?;\n+    }\n     if options.enable_index_page {\n         if let Some(index_page) = options.index_page.clone() {\n             let mut md_opts = options.clone();\n@@ -1136,7 +1169,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n             crate::markdown::render(index_page, md_opts, diag, cx.edition);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n-            let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));\n             let page = layout::Page {\n                 title: \"Index of crates\",\n                 css_class: \"mod\",\n@@ -1163,12 +1195,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                                 SlashChecker(s), s)\n                                     })\n                                     .collect::<String>());\n-            try_err!(layout::render(&mut w, &cx.shared.layout,\n+            let mut v = Vec::new();\n+            try_err!(layout::render(&mut v, &cx.shared.layout,\n                                     &page, &(\"\"), &content,\n                                     cx.shared.css_file_extension.is_some(),\n                                     &cx.shared.themes,\n                                     cx.shared.generate_search_filter), &dst);\n-            try_err!(w.flush(), &dst);\n+            cx.shared.fs.write(&dst, &v)?;\n         }\n     }\n \n@@ -1220,7 +1253,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n         }\n-        try_err!(fs::create_dir_all(&mydst), &mydst);\n+        cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\",\n                             remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n@@ -1233,19 +1266,20 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut f = try_err!(File::create(&mydst), &mydst);\n-        try_err!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"), &mydst);\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"(function() {{var implementors = {{}};\"), &mydst);\n         for implementor in &all_implementors {\n-            try_err!(writeln!(&mut f, \"{}\", *implementor), &mydst);\n+            try_err!(writeln!(&mut v, \"{}\", *implementor), &mydst);\n         }\n-        try_err!(writeln!(&mut f, \"{}\", r\"\n+        try_err!(writeln!(&mut v, \"{}\", r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n             } else {\n                 window.pending_implementors = implementors;\n             }\n         \"), &mydst);\n-        try_err!(writeln!(&mut f, r\"}})()\"), &mydst);\n+        try_err!(writeln!(&mut v, r\"}})()\"), &mydst);\n+        cx.shared.fs.write(&mydst, &v)?;\n     }\n     Ok(())\n }\n@@ -1254,30 +1288,25 @@ fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n     let dst = dst.join(\"src\").join(&krate.name);\n-    try_err!(fs::create_dir_all(&dst), &dst);\n+    scx.ensure_dir(&dst)?;\n     let mut folder = SourceCollector {\n         dst,\n         scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n \n-/// Writes the entire contents of a string to a destination, not attempting to\n-/// catch any errors.\n-fn write(dst: PathBuf, contents: &[u8]) -> Result<(), Error> {\n-    Ok(try_err!(fs::write(&dst, contents), &dst))\n-}\n-\n-fn write_minify(dst: PathBuf, contents: &str, enable_minification: bool) -> Result<(), Error> {\n+fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bool\n+                ) -> Result<(), Error> {\n     if enable_minification {\n         if dst.extension() == Some(&OsStr::new(\"css\")) {\n             let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n-            write(dst, res.as_bytes())\n+            fs.write(dst, res.as_bytes())\n         } else {\n-            write(dst, minifier::js::minify(contents).as_bytes())\n+            fs.write(dst, minifier::js::minify(contents).as_bytes())\n         }\n     } else {\n-        write(dst, contents.as_bytes())\n+        fs.write(dst, contents.as_bytes())\n     }\n }\n \n@@ -1439,7 +1468,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> io::Result<()> {\n+    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {\n             FileName::Real(ref file) => file,\n             _ => return Ok(()),\n@@ -1449,7 +1478,7 @@ impl<'a> SourceCollector<'a> {\n             return Ok(());\n         }\n \n-        let contents = fs::read_to_string(&p)?;\n+        let contents = try_err!(fs::read_to_string(&p), &p);\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\u{feff}\") {\n@@ -1468,15 +1497,15 @@ impl<'a> SourceCollector<'a> {\n             href.push_str(&component.to_string_lossy());\n             href.push('/');\n         });\n-        fs::create_dir_all(&cur)?;\n+        self.scx.ensure_dir(&cur)?;\n         let mut fname = p.file_name()\n                          .expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n         cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n-        let mut w = BufWriter::new(File::create(&cur)?);\n+        let mut v = Vec::new();\n         let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n@@ -1491,12 +1520,12 @@ impl<'a> SourceCollector<'a> {\n             extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n             static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n         };\n-        layout::render(&mut w, &self.scx.layout,\n+        try_err!(layout::render(&mut v, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents),\n                        self.scx.css_file_extension.is_some(),\n                        &self.scx.themes,\n-                       self.scx.generate_search_filter)?;\n-        w.flush()?;\n+                       self.scx.generate_search_filter), &cur);\n+        self.scx.fs.write(&cur, &v)?;\n         self.scx.local_sources.insert(p.clone(), href);\n         Ok(())\n     }\n@@ -2073,7 +2102,6 @@ impl Context {\n             }\n         }\n \n-        let mut w = BufWriter::new(try_err!(File::create(&final_file), &final_file));\n         let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n         if !root_path.ends_with('/') {\n             root_path.push('/');\n@@ -2099,12 +2127,14 @@ impl Context {\n         } else {\n             String::new()\n         };\n-        try_err!(layout::render(&mut w, &self.shared.layout,\n+        let mut v = Vec::new();\n+        try_err!(layout::render(&mut v, &self.shared.layout,\n                                 &page, &sidebar, &all,\n                                 self.shared.css_file_extension.is_some(),\n                                 &self.shared.themes,\n                                 self.shared.generate_search_filter),\n                  &final_file);\n+        self.shared.fs.write(&final_file, &v)?;\n \n         // Generating settings page.\n         let settings = Settings::new(self.shared.static_root_path.deref().unwrap_or(\"./\"),\n@@ -2113,17 +2143,18 @@ impl Context {\n         page.description = \"Settings of Rustdoc\";\n         page.root_path = \"./\";\n \n-        let mut w = BufWriter::new(try_err!(File::create(&settings_file), &settings_file));\n         let mut themes = self.shared.themes.clone();\n         let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n         themes.push(PathBuf::from(\"settings.css\"));\n         let layout = self.shared.layout.clone();\n-        try_err!(layout::render(&mut w, &layout,\n+        let mut v = Vec::new();\n+        try_err!(layout::render(&mut v, &layout,\n                                 &page, &sidebar, &settings,\n                                 self.shared.css_file_extension.is_some(),\n                                 &themes,\n                                 self.shared.generate_search_filter),\n                  &settings_file);\n+        self.shared.fs.write(&settings_file, &v)?;\n \n         Ok(())\n     }\n@@ -2223,16 +2254,17 @@ impl Context {\n             // recurse into the items of the module as well.\n             let name = item.name.as_ref().unwrap().to_string();\n             let mut item = Some(item);\n+            let scx = self.shared.clone();\n             self.recurse(name, |this| {\n                 let item = item.take().unwrap();\n \n                 let mut buf = Vec::new();\n                 this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n-                    try_err!(this.shared.ensure_dir(&this.dst), &this.dst);\n+                    this.shared.ensure_dir(&this.dst)?;\n                     let joint_dst = this.dst.join(\"index.html\");\n-                    try_err!(fs::write(&joint_dst, buf), &joint_dst);\n+                    scx.fs.write(&joint_dst, buf)?;\n                 }\n \n                 let m = match item.inner {\n@@ -2245,9 +2277,10 @@ impl Context {\n                 if !this.render_redirect_pages {\n                     let items = this.build_sidebar_items(&m);\n                     let js_dst = this.dst.join(\"sidebar-items.js\");\n-                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                    let mut v = Vec::new();\n+                    try_err!(write!(&mut v, \"initSidebarItems({});\",\n                                     as_json(&items)), &js_dst);\n+                    scx.fs.write(&js_dst, &v)?;\n                 }\n \n                 for item in m.items {\n@@ -2264,9 +2297,9 @@ impl Context {\n                 let name = item.name.as_ref().unwrap();\n                 let item_type = item.type_();\n                 let file_name = &item_path(item_type, name);\n-                try_err!(self.shared.ensure_dir(&self.dst), &self.dst);\n+                self.shared.ensure_dir(&self.dst)?;\n                 let joint_dst = self.dst.join(file_name);\n-                try_err!(fs::write(&joint_dst, buf), &joint_dst);\n+                self.shared.fs.write(&joint_dst, buf)?;\n \n                 if !self.render_redirect_pages {\n                     all.append(full_path(self, &item), &item_type);\n@@ -2276,21 +2309,18 @@ impl Context {\n                     // URL for the page.\n                     let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n                     let redir_dst = self.dst.join(redir_name);\n-                    if let Ok(redirect_out) = OpenOptions::new().create_new(true)\n-                                                                .write(true)\n-                                                                .open(&redir_dst) {\n-                        let mut redirect_out = BufWriter::new(redirect_out);\n-                        try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n-                    }\n+                    let mut v = Vec::new();\n+                    try_err!(layout::redirect(&mut v, file_name), &redir_dst);\n+                    self.shared.fs.write(&redir_dst, &v)?;\n                 }\n                 // If the item is a macro, redirect from the old macro URL (with !)\n                 // to the new one (without).\n                 if item_type == ItemType::Macro {\n                     let redir_name = format!(\"{}.{}!.html\", item_type, name);\n                     let redir_dst = self.dst.join(redir_name);\n-                    let redirect_out = try_err!(File::create(&redir_dst), &redir_dst);\n-                    let mut redirect_out = BufWriter::new(redirect_out);\n-                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                    let mut v = Vec::new();\n+                    try_err!(layout::redirect(&mut v, file_name), &redir_dst);\n+                    self.shared.fs.write(&redir_dst, &v)?;\n                 }\n             }\n         }"}, {"sha": "7a8b088020c5320c32a8e41accbdb026dae955cd", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -59,6 +59,7 @@ mod externalfiles;\n mod clean;\n mod config;\n mod core;\n+mod docfs;\n mod doctree;\n mod fold;\n pub mod html {"}, {"sha": "e6f09927796fae3705187b417b0c7db2af2de696", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n                         Some(parent) if parent != hir::CRATE_HIR_ID => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir().name_by_hir_id(parent).to_string())\n+                            Some(self.cx.tcx.hir().name(parent).to_string())\n                         }\n                         _ => None,\n                     }"}, {"sha": "7220a05df47e660a5ecc517ec53bb667fd42ab37", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -103,16 +103,16 @@ fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n     if let Some(&Events::StartComment(_)) = events.last() {\n         return false;\n     }\n-    pos + 1 < v.len() && v[pos + 1] == b'/'\n+    v[pos + 1] == b'/'\n }\n \n fn load_css_events(v: &[u8]) -> Vec<Events> {\n     let mut pos = 0;\n     let mut events = Vec::with_capacity(100);\n \n-    while pos < v.len() - 1 {\n+    while pos + 1 < v.len() {\n         match v[pos] {\n-            b'/' if pos + 1 < v.len() && v[pos + 1] == b'*' => {\n+            b'/' if v[pos + 1] == b'*' => {\n                 events.push(Events::StartComment(pos));\n                 pos += 1;\n             }\n@@ -123,7 +123,7 @@ fn load_css_events(v: &[u8]) -> Vec<Events> {\n             b'\\n' if previous_is_line_comment(&events) => {\n                 events.push(Events::EndComment(pos));\n             }\n-            b'*' if pos + 1 < v.len() && v[pos + 1] == b'/' => {\n+            b'*' if v[pos + 1] == b'/' => {\n                 events.push(Events::EndComment(pos + 2));\n                 pos += 1;\n             }\n@@ -264,9 +264,11 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n     }\n }\n \n-pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath, diag: &Handler)\n-    -> (bool, Vec<String>)\n-{\n+pub fn test_theme_against<P: AsRef<Path>>(\n+    f: &P,\n+    against: &CssPath,\n+    diag: &Handler,\n+) -> (bool, Vec<String>) {\n     let data = try_something!(fs::read(f), diag, (false, vec![]));\n     let paths = load_css_paths(&data);\n     let mut ret = vec![];\n@@ -366,4 +368,16 @@ a {\n         get_differences(&other, &against, &mut ret);\n         assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n     }\n+\n+    #[test]\n+    fn check_empty_css() {\n+        let events = load_css_events(&[]);\n+        assert_eq!(events.len(), 0);\n+    }\n+\n+    #[test]\n+    fn check_invalid_css() {\n+        let events = load_css_events(b\"*\");\n+        assert_eq!(events.len(), 0);\n+    }\n }"}, {"sha": "781e62c3b274cfcfc15349bd19fb6d2df76bf119", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         if !self.view_item_stack.insert(res_hir_id) { return false }\n \n-        let ret = match tcx.hir().get_by_hir_id(res_hir_id) {\n+        let ret = match tcx.hir().get(res_hir_id) {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {"}, {"sha": "64b795af9267fc75a43bdd221cf4b93b25f18969", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 span: source_map::Span,\n                 id: hir::HirId) {\n \n-        let item = match cx.tcx.hir().get_by_hir_id(id) {\n+        let item = match cx.tcx.hir().get(id) {\n             Node::Item(item) => item,\n             _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n         };"}, {"sha": "83070012f5f042983e53c5ad9d8a4e75600b0a9f", "filename": "src/test/ui/issues/issue-27697.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Fissues%2Fissue-27697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Fissues%2Fissue-27697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27697.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+\n+use std::ops::Deref;\n+\n+trait MyTrait {\n+    fn do_something(&self);\n+    fn as_str(&self) -> &str;\n+}\n+\n+impl Deref for dyn MyTrait {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.as_str()\n+    }\n+}\n+\n+fn trait_object_does_something(t: &dyn MyTrait) {\n+    t.do_something()\n+}\n+\n+fn main() {}"}, {"sha": "e4abf314e0a967b99283b3e0ff23235491d36508", "filename": "src/test/ui/traits/trait-alias/trait-alias-only-maybe-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -11,12 +11,12 @@ trait _1 = _0;\n \n // Straight list expansion:\n type _T0 = dyn _1;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+//~^ ERROR at least one trait is required for an object type [E0224]\n \n // Twice:\n trait _2 = _1 + _1;\n \n type _T1 = dyn _2;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+//~^ ERROR at least one trait is required for an object type [E0224]\n \n fn main() {}"}, {"sha": "6de79fa917b16d704f3ba6e3aa21475755a9dfb2", "filename": "src/test/ui/traits/trait-alias/trait-alias-only-maybe-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1,10 +1,10 @@\n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-alias-only-maybe-bound.rs:13:12\n    |\n LL | type _T0 = dyn _1;\n    |            ^^^^^^\n \n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-alias-only-maybe-bound.rs:19:12\n    |\n LL | type _T1 = dyn _2;"}, {"sha": "a6852569f3a12b85cfd9c882a17671176c7c6d48", "filename": "src/test/ui/traits/trait-object-macro-matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     m!(dyn Copy + Send + 'static);\n     //~^ ERROR the trait `std::marker::Copy` cannot be made into an object\n     m!(dyn 'static + Send);\n-    m!(dyn 'static +); //~ ERROR at least one non-builtin trait is required for an object type\n+    m!(dyn 'static +); //~ ERROR at least one trait is required for an object type\n }"}, {"sha": "6b5effaad9bc4e49a73245d035f372f83e23da5f", "filename": "src/test/ui/traits/trait-object-macro-matcher.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-macro-matcher.stderr?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1,4 +1,4 @@\n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-object-macro-matcher.rs:11:8\n    |\n LL |     m!(dyn 'static +);"}, {"sha": "0b33dc7f69a3ace1ea5894e4308788543d9ea5c6", "filename": "src/test/ui/traits/trait-object-vs-lifetime-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -5,7 +5,7 @@\n fn g() where\n     'static: 'static,\n     dyn 'static +: 'static + Copy,\n-    //~^ ERROR at least one non-builtin trait is required for an object type\n+    //~^ ERROR at least one trait is required for an object type\n {}\n \n fn main() {}"}, {"sha": "014d380b63ca5c05dedb798944d9819ff32053a6", "filename": "src/test/ui/traits/trait-object-vs-lifetime-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime-2.stderr?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1,4 +1,4 @@\n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-object-vs-lifetime-2.rs:7:5\n    |\n LL |     dyn 'static +: 'static + Copy,"}, {"sha": "e0ff73494837613385ab9b6b6ef3cdbb309382e0", "filename": "src/test/ui/traits/trait-object-vs-lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -7,11 +7,11 @@ fn main() {\n     // `'static` is a lifetime argument, `'static +` is a type argument\n     let _: S<'static, u8>;\n     let _: S<'static, dyn 'static +>;\n-    //~^ at least one non-builtin trait is required for an object type\n+    //~^ at least one trait is required for an object type\n     let _: S<'static, 'static>;\n     //~^ ERROR wrong number of lifetime arguments: expected 1, found 2\n     //~| ERROR wrong number of type arguments: expected 1, found 0\n     let _: S<dyn 'static +, 'static>;\n     //~^ ERROR lifetime arguments must be declared prior to type arguments\n-    //~| ERROR at least one non-builtin trait is required for an object type\n+    //~| ERROR at least one trait is required for an object type\n }"}, {"sha": "be1958770a426b73fa5b22e83d0a4581b7f3e6b1", "filename": "src/test/ui/traits/trait-object-vs-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -4,7 +4,7 @@ error: lifetime arguments must be declared prior to type arguments\n LL |     let _: S<dyn 'static +, 'static>;\n    |                             ^^^^^^^\n \n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-object-vs-lifetime.rs:9:23\n    |\n LL |     let _: S<'static, dyn 'static +>;\n@@ -22,7 +22,7 @@ error[E0107]: wrong number of type arguments: expected 1, found 0\n LL |     let _: S<'static, 'static>;\n    |            ^^^^^^^^^^^^^^^^^^^ expected 1 type argument\n \n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-object-vs-lifetime.rs:14:14\n    |\n LL |     let _: S<dyn 'static +, 'static>;"}, {"sha": "3e6db3e997c9b7da2007b5b0878fa051f1402c0c", "filename": "src/test/ui/traits/wf-trait-object-only-maybe-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -1,7 +1,7 @@\n // Test that `dyn ?Sized` (i.e., a trait object with only a maybe buond) is not allowed.\n \n type _0 = dyn ?Sized;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+//~^ ERROR at least one trait is required for an object type [E0224]\n //~| ERROR ?Trait` is not permitted in trait object types\n \n fn main() {}"}, {"sha": "8cc97addc7dd4a832119c0f52587f5e320e5d6ca", "filename": "src/test/ui/traits/wf-trait-object-only-maybe-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e562b24ae325f5a31b7ba5873e3db426a14e6342/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr?ref=e562b24ae325f5a31b7ba5873e3db426a14e6342", "patch": "@@ -4,7 +4,7 @@ error: `?Trait` is not permitted in trait object types\n LL | type _0 = dyn ?Sized;\n    |               ^^^^^^\n \n-error[E0224]: at least one non-builtin trait is required for an object type\n+error[E0224]: at least one trait is required for an object type\n   --> $DIR/wf-trait-object-only-maybe-bound.rs:3:11\n    |\n LL | type _0 = dyn ?Sized;"}]}