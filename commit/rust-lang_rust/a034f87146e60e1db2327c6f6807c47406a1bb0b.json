{"sha": "a034f87146e60e1db2327c6f6807c47406a1bb0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMzRmODcxNDZlNjBlMWRiMjMyN2M2ZjY4MDdjNDc0MDZhMWJiMGI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-21T15:31:43Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-21T16:42:09Z"}, "message": "Revert \"Implement pattern ranges for all numeric types.\"\n\nThis reverts commit ce0f054f9d56df4e60291fc2e1b89ce979cf374f.", "tree": {"sha": "f0d8b144200a362611534c02bca9305eea4ce61b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0d8b144200a362611534c02bca9305eea4ce61b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a034f87146e60e1db2327c6f6807c47406a1bb0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a034f87146e60e1db2327c6f6807c47406a1bb0b", "html_url": "https://github.com/rust-lang/rust/commit/a034f87146e60e1db2327c6f6807c47406a1bb0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a034f87146e60e1db2327c6f6807c47406a1bb0b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410f73fdb23b189ea0b54dd5c025bbae5e58dee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/410f73fdb23b189ea0b54dd5c025bbae5e58dee6", "html_url": "https://github.com/rust-lang/rust/commit/410f73fdb23b189ea0b54dd5c025bbae5e58dee6"}], "stats": {"total": 476, "additions": 25, "deletions": 451}, "files": [{"sha": "f1788fda27e631f730e3f2badd333ae0c16aa46c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -645,7 +645,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n     fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt pat.node {\n-          ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) {}\n+          ast::pat_wild. | ast::pat_lit(_) {}\n           ast::pat_bind(nm) {\n             set += [{id: pat.id, name: nm, mut: mut, span: pat.span}];\n           }"}, {"sha": "354d23f38f6f005024563d1d25ef8f423a27f67c", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -62,15 +62,12 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n         ret true;\n     }\n \n+\n     alt a.node {\n       pat_wild. | pat_bind(_) { ret true; }\n       pat_lit(la) {\n         alt b.node {\n           pat_lit(lb) { ret util::common::lit_eq(la, lb); }\n-          pat_range(beginb, endb) {\n-            ret util::common::lit_type_eq(la, beginb) &&\n-                util::common::lit_in_range(la, beginb, endb);\n-          }\n           _ { ret false; }\n         }\n       }\n@@ -101,19 +98,6 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n           _ { ret pattern_supersedes(tcx, suba, b); }\n         }\n       }\n-      pat_range(begina, enda) {\n-        alt b.node {\n-          pat_lit(lb) {\n-            ret util::common::lit_type_eq(lb, begina) &&\n-                util::common::lit_in_range(lb, begina, enda);\n-          }\n-          pat_range(beginb, endb) {\n-            ret util::common::lit_type_eq(begina, beginb) &&\n-                util::common::lit_ranges_overlap(begina, enda, beginb, endb);\n-          }\n-          _ { ret false; }\n-        }\n-      }\n     }\n }\n "}, {"sha": "eea4704c3d080aef1f25b046b0b9b5c7f33cb9e8", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 20, "deletions": 78, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -1,4 +1,4 @@\n-import std::{str, vec, option, int};\n+import std::{str, vec, option};\n import option::{some, none};\n import std::map::hashmap;\n \n@@ -16,42 +16,25 @@ import util::common::lit_eq;\n \n import trans_common::*;\n \n-// An option identifying a branch (either a literal, a tag variant or a range)\n+// An option identifying a branch (either a literal or a tag variant)\n tag opt {\n     lit(@ast::lit);\n     var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n-    range(@ast::lit, @ast::lit);\n }\n fn opt_eq(a: opt, b: opt) -> bool {\n     alt a {\n       lit(la) {\n-        ret alt b { lit(lb) { lit_eq(la, lb) } _ { false } };\n+        ret alt b { lit(lb) { lit_eq(la, lb) } var(_, _) { false } };\n       }\n       var(ida, _) {\n-        ret alt b { var(idb, _) { ida == idb } _ { false } };\n-      }\n-      range(la1, la2) {\n-        ret alt b {\n-          range(lb1, lb2) { lit_eq(la1, lb1) && lit_eq(la2, lb2) }\n-          _ { false }\n-        };\n+        ret alt b { lit(_) { false } var(idb, _) { ida == idb } };\n       }\n     }\n }\n-\n-tag opt_result {\n-    single_result(result);\n-    range_result(result, result);\n-}\n-fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n+fn trans_opt(bcx: @block_ctxt, o: opt) -> result {\n     alt o {\n-      lit(l) { ret single_result(trans::trans_lit(bcx, *l)); }\n-      var(id, _) { ret single_result(rslt(bcx, C_int(id as int))); }\n-      range(l1, l2) {\n-        let r1 = trans::trans_lit(bcx, *l1);\n-        let r2 = trans::trans_lit(r1.bcx, *l2);\n-        ret range_result(r1, r2);\n-      }\n+      lit(l) { ret trans::trans_lit(bcx, *l); }\n+      var(id, _) { ret rslt(bcx, C_int(id as int)); }\n     }\n }\n \n@@ -141,9 +124,6 @@ fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, tag_size: uint,\n           ast::pat_lit(l) {\n             ret if opt_eq(lit(l), opt) { some([]) } else { none };\n           }\n-          ast::pat_range(l1, l2) {\n-            ret if opt_eq(range(l1, l2), opt) { some([]) } else { none };\n-          }\n           _ { ret some(vec::init_elt(dummy, size)); }\n         }\n     }\n@@ -206,9 +186,6 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n     for br: match_branch in m {\n         alt br.pats[col].node {\n           ast::pat_lit(l) { add_to_set(found, lit(l)); }\n-          ast::pat_range(l1, l2) {\n-            add_to_set(found, range(l1, l2));\n-          }\n           ast::pat_tag(_, _) {\n             add_to_set(found, variant_opt(ccx, br.pats[col].id));\n           }\n@@ -288,9 +265,7 @@ fn pick_col(m: match) -> uint {\n         let i = 0u;\n         for p: @ast::pat in br.pats {\n             alt p.node {\n-              ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) {\n-                scores[i] += 1u;\n-              }\n+              ast::pat_lit(_) | ast::pat_tag(_, _) { scores[i] += 1u; }\n               _ { }\n             }\n             i += 1u;\n@@ -435,16 +410,6 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                   _ { test_val = Load(bcx, val); switch }\n                 };\n           }\n-          range(_, _) {\n-            test_val = Load(bcx, val);\n-            kind = compare;\n-          }\n-        }\n-    }\n-    for o: opt in opts {\n-        alt o {\n-          range(_, _) { kind = compare; break; }\n-          _ { }\n         }\n     }\n     let else_cx =\n@@ -463,44 +428,22 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         alt kind {\n           single. { Br(bcx, opt_cx.llbb); }\n           switch. {\n-            let res = trans_opt(bcx, opt);\n-            alt res {\n-              single_result(r) {\n-                llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n-                bcx = r.bcx;\n-              }\n-            }\n+            let r = trans_opt(bcx, opt);\n+            bcx = r.bcx;\n+            llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n           }\n           compare. {\n             let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n             Br(bcx, compare_cx.llbb);\n             bcx = compare_cx;\n+            let r = trans_opt(bcx, opt);\n+            bcx = r.bcx;\n             let t = ty::node_id_to_type(ccx.tcx, pat_id);\n-            let res = trans_opt(bcx, opt);\n-            alt res {\n-              single_result(r) {\n-                bcx = r.bcx;\n-                let eq =\n-                    trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n-                /*let*/ bcx = eq.bcx; //XXX uncomment for assertion\n-                let cleanup_cx = trans::trans_block_cleanups(bcx, compare_cx);\n-                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n-                CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n-              }\n-              range_result(rbegin, rend) {\n-                bcx = rend.bcx;\n-                let ge = trans::trans_compare(bcx, ast::ge, test_val, t,\n-                                              rbegin.val, t);\n-                let le = trans::trans_compare(ge.bcx, ast::le, test_val, t,\n-                                              rend.val, t);\n-                let in_range = rslt(le.bcx, And(le.bcx, ge.val, le.val));\n-                /*let*/ bcx = in_range.bcx; //XXX uncomment for assertion\n-                let cleanup_cx =\n-                    trans::trans_block_cleanups(bcx, compare_cx);\n-                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n-                CondBr(cleanup_cx, in_range.val, opt_cx.llbb, bcx.llbb);\n-              }\n-            }\n+            let eq =\n+                trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n+            let cleanup_cx = trans::trans_block_cleanups(bcx, compare_cx);\n+            bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n+            CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n         }\n@@ -513,7 +456,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             unpacked = args.vals;\n             opt_cx = args.bcx;\n           }\n-          lit(_) | range(_, _) { }\n+          lit(_) { }\n         }\n         compile_submatch(opt_cx, enter_opt(ccx, m, opt, col, size, val),\n                          unpacked + vals_left, f, exits);\n@@ -688,13 +631,12 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         [C_int(0), C_int(back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);\n       }\n-      ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) { }\n+      ast::pat_wild. | ast::pat_lit(_) { }\n     }\n     ret bcx;\n }\n \n // Local Variables:\n-// mode: rust\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4"}, {"sha": "c6d24802ecd90c6ec0362596a256193a16d6b316", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -1266,44 +1266,6 @@ fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-fn lit_as_uint(l: @ast::lit) -> uint {\n-    alt l.node {\n-      ast::lit_uint(u) { u }\n-      ast::lit_char(c) { c as uint }\n-    }\n-}\n-fn lit_as_int(l: @ast::lit) -> int {\n-    alt l.node {\n-      ast::lit_int(i) | ast::lit_mach_int(_, i) { i }\n-    }\n-}\n-fn lit_as_float(l: @ast::lit) -> str {\n-    alt l.node {\n-      ast::lit_float(f) | ast::lit_mach_float(_, f) { f }\n-    }\n-}\n-\n-fn valid_range_bounds(l1: @ast::lit, l2: @ast::lit) -> bool {\n-    alt l1.node {\n-      ast::lit_float(s1) | ast::lit_mach_float(_, s1) {\n-        let s2 = lit_as_float(l2);\n-        let f1 = util::common::str_to_float(s1);\n-        let f2 = util::common::str_to_float(s2);\n-        ret *util::common::min(f1, f2) == f1\n-      }\n-      ast::lit_uint(_) | ast::lit_char(_) {\n-        let u1 = lit_as_uint(l1);\n-        let u2 = lit_as_uint(l2);\n-        ret *util::common::min(u1, u2) == u1\n-      }\n-      _ {\n-        let i1 = lit_as_int(l1);\n-        let i2 = lit_as_int(l2);\n-        ret *util::common::min(i1, i2) == i1\n-      }\n-    }\n-}\n-\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n@@ -1315,23 +1277,6 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         typ = demand::simple(fcx, pat.span, expected, typ);\n         write::ty_only_fixup(fcx, pat.id, typ);\n       }\n-      ast::pat_range(begin, end) {\n-        if !util::common::lit_is_numeric(begin) ||\n-           !util::common::lit_is_numeric(end) {\n-            fcx.ccx.tcx.sess.span_err(pat.span,\n-                                      \"non-numeric type used in range\");\n-        } else if !valid_range_bounds(begin, end) {\n-            fcx.ccx.tcx.sess.span_err(begin.span,\n-                                      \"lower range bound must be less \\\n-                                       than upper\");\n-        }\n-        let typ1 = check_lit(fcx.ccx, begin);\n-        typ1 = demand::simple(fcx, pat.span, expected, typ1);\n-        write::ty_only_fixup(fcx, pat.id, typ1);\n-        let typ2 = check_lit(fcx.ccx, end);\n-        typ2 = demand::simple(fcx, pat.span, typ1, typ2);\n-        write::ty_only_fixup(fcx, pat.id, typ2);\n-      }\n       ast::pat_bind(name) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);"}, {"sha": "ad6aacb1549db507b855f103b870155e2299a069", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -92,7 +92,6 @@ tag pat_ {\n     pat_rec([field_pat], bool);\n     pat_tup([@pat]);\n     pat_box(@pat);\n-    pat_range(@lit, @lit);\n }\n \n tag mutability { mut; imm; maybe_mut; }"}, {"sha": "8350ce9a8bbde3b063d58c29ac8bd7f4ca9c3eb5", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -69,7 +69,7 @@ iter pat_bindings(pat: @pat) -> @pat {\n         for elt in elts { for each b in pat_bindings(elt) { put b; } }\n       }\n       pat_box(sub) { for each b in pat_bindings(sub) { put b; } }\n-      pat_wild. | pat_lit(_) | pat_range(_, _) { }\n+      pat_wild. | pat_lit(_) { }\n     }\n }\n \n@@ -229,4 +229,3 @@ fn ret_by_ref(style: ret_style) -> bool {\n // buffer-file-coding-system: utf-8-unix\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n-"}, {"sha": "c53176e24fb992ff791fe20ee53f163391ab505f", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -291,7 +291,6 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           }\n           pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n-          pat_range(_, _) { p }\n         };\n }\n "}, {"sha": "6869dc6501d07ec0b66d92660f4ec94225000e13", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -1494,14 +1494,8 @@ fn parse_pat(p: parser) -> @ast::pat {\n       tok {\n         if !is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\") {\n             let lit = parse_lit(p);\n-            if eat_word(p, \"to\") {\n-                let end = parse_lit(p);\n-                hi = end.span.hi;\n-                pat = ast::pat_range(@lit, @end);\n-            } else {\n-                hi = lit.span.hi;\n-                pat = ast::pat_lit(@lit);\n-            }\n+            hi = lit.span.hi;\n+            pat = ast::pat_lit(@lit);\n         } else if is_plain_ident(p) &&\n                       alt p.look_ahead(1u) {\n                         token::DOT. | token::LPAREN. | token::LBRACKET. {"}, {"sha": "48031a295db96d1a2e3eb09c2a1d9b7ff44ff4b1", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -1113,12 +1113,6 @@ fn print_pat(s: ps, pat: @ast::pat) {\n         pclose(s);\n       }\n       ast::pat_box(inner) { word(s.s, \"@\"); print_pat(s, inner); }\n-      ast::pat_range(begin, end) {\n-        print_literal(s, begin);\n-        space(s.s);\n-        word_space(s, \"to\");\n-        print_literal(s, end);\n-      }\n     }\n     s.ann.post(ann_node);\n }"}, {"sha": "355fcd934b4fea28be6e69a2e2cbfcce58372ef9", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -84,162 +84,6 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n     alt l.node.init { some(i) { ret i.expr.span; } _ { ret def; } }\n }\n \n-fn lit_is_numeric(l: @ast::lit) -> bool {\n-    alt l.node {\n-      ast::lit_int(_) | ast::lit_char(_) | ast::lit_uint(_) |\n-      ast::lit_mach_int(_, _) | ast::lit_float(_) | ast::lit_mach_float(_,_) {\n-        true\n-      }\n-      _ { false }\n-    }\n-}\n-\n-fn lit_type_eq(l: @ast::lit, m: @ast::lit) -> bool {\n-    alt l.node {\n-      ast::lit_str(_) {\n-        alt m.node { ast::lit_str(_) { true } _ { false } }\n-      }\n-      ast::lit_char(_) {\n-        alt m.node { ast::lit_char(_) { true } _ { false } }\n-      }\n-      ast::lit_int(_) {\n-        alt m.node { ast::lit_int(_) { true } _ { false } }\n-      }\n-      ast::lit_uint(_) {\n-        alt m.node { ast::lit_uint(_) { true } _ { false } }\n-      }\n-      ast::lit_mach_int(_, _) {\n-        alt m.node { ast::lit_mach_int(_, _) { true } _ { false } }\n-      }\n-      ast::lit_float(_) {\n-        alt m.node { ast::lit_float(_) { true } _ { false } }\n-      }\n-      ast::lit_mach_float(_, _) {\n-        alt m.node { ast::lit_mach_float(_, _) { true } _ { false } }\n-      }\n-      ast::lit_nil. {\n-        alt m.node { ast::lit_nil. { true } _ { false } }\n-      }\n-      ast::lit_bool(_) {\n-        alt m.node { ast::lit_bool(_) { true } _ { false } }\n-      }\n-    }\n-}\n-\n-fn lit_in_range(l: @ast::lit, m1: @ast::lit, m2: @ast::lit) -> bool {\n-    alt lits_to_range(m1, m2) {\n-      irange(i1, i2) {\n-        alt l.node {\n-          ast::lit_int(i3) | ast::lit_mach_int(_, i3) {\n-            i3 >= *min(i1, i2) && i3 <= *max(i1, i2)\n-          }\n-          _ { fail }\n-        }\n-      }\n-      urange(u1, u2) {\n-        alt l.node {\n-          ast::lit_uint(u3) {\n-            u3 >= *min(u1, u2) && u3 <= *max(u1, u2)\n-          }\n-          _ { fail }\n-        }\n-      }\n-      crange(c1, c2) {\n-        alt l.node {\n-          ast::lit_char(c3) {\n-            (c3 as uint) >= *min(c1 as uint, c2 as uint) &&\n-            (c3 as uint) <= *max(c1 as uint, c2 as uint)\n-          }\n-          _ { fail }\n-        }\n-      }\n-      frange(f1, f2) {\n-        alt l.node {\n-          ast::lit_float(f3) | ast::lit_mach_float(_, f3) {\n-            str_to_float(f3) >= *min(f1, f2) &&\n-            str_to_float(f3) <= *max(f1, f2)\n-          }\n-          _ { fail }\n-        }\n-      }\n-    }\n-}\n-\n-fn min<T>(x: T, y: T) -> @T {\n-    ret @(if x > y { y } else { x });\n-}\n-\n-fn max<T>(x: T, y: T) -> @T {\n-    ret @(if x > y { x } else { y });\n-}\n-\n-fn ranges_overlap<T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n-    let min1 = *min(a1, a2);\n-    let max1 = *max(a1, a2);\n-    let min2 = *min(b1, b2);\n-    let max2 = *max(b1, b2);\n-    ret (min1 >= min2 && max1 <= max2) || (min1 <= min2 && max1 >= min2) ||\n-        (min1 >= min2 && min1 <= max2) || (max1 >= min2 && max1 <= max2);\n-}\n-\n-fn lit_ranges_overlap(a1: @ast::lit, a2: @ast::lit,\n-                      b1: @ast::lit, b2: @ast::lit) -> bool {\n-    alt lits_to_range(a1, a2) {\n-      irange(i1, i2) {\n-        alt lits_to_range(b1, b2) {\n-          irange(i3, i4) { ranges_overlap(i1, i2, i3, i4) }\n-          _ { fail }\n-        }\n-      }\n-      urange(u1, u2) {\n-        alt lits_to_range(b1, b2) {\n-          urange(u3, u4) { ranges_overlap(u1, u2, u3, u4) }\n-          _ { fail }\n-        }\n-      }\n-      crange(c1, c2) {\n-        alt lits_to_range(b1, b2) {\n-          crange(c3, c4) { ranges_overlap(c1, c2, c3, c4) }\n-          _ { fail }\n-        }\n-      }\n-      frange(f1, f2) {\n-        alt lits_to_range(b1, b2) {\n-          frange(f3, f4) { ranges_overlap(f1, f2, f3, f4) }\n-          _ { fail }\n-        }\n-      }\n-    }\n-}\n-\n-tag range {\n-    irange(int, int);\n-    urange(uint, uint);\n-    crange(char, char);\n-    frange(float, float);\n-}\n-\n-fn lits_to_range(l: @ast::lit, r: @ast::lit) -> range {\n-    alt l.node {\n-      ast::lit_int(i1) | ast::lit_mach_int(_, i1) {\n-        alt r.node { ast::lit_int(i2) { irange(i1, i2) } _ { fail } }\n-      }\n-      ast::lit_uint(u1) {\n-        alt r.node { ast::lit_uint(u2) { urange(u1, u2) } _ { fail } }\n-      }\n-      ast::lit_char(c1) {\n-        alt r.node { ast::lit_char(c2) { crange(c1, c2) } _ { fail } }\n-      }\n-      ast::lit_float(f1) | ast::lit_mach_float(_, f1) {\n-        alt r.node { ast::lit_float(f2) | ast::lit_mach_float(_, f2) {\n-          frange(str_to_float(f1), str_to_float(f2))\n-        }\n-        _ { fail } }\n-      }\n-      _ { fail }\n-    }\n-}\n-\n fn lit_eq(l: @ast::lit, m: @ast::lit) -> bool {\n     alt l.node {\n       ast::lit_str(s) {\n@@ -312,22 +156,6 @@ fn float_to_str(num: float, digits: uint) -> str {\n     ret accum;\n }\n \n-fn str_to_float(num: str) -> float {\n-    let digits = str::split(num, '.' as u8);\n-    let total = int::from_str(digits[0]) as float;\n-\n-    fn dec_val(c: char) -> int { ret (c as int) - ('0' as int); }\n-\n-    let right = digits[1];\n-    let len = str::char_len(digits[1]);\n-    let i = 1u;\n-    while (i < len) {\n-        total += dec_val(str::pop_char(right)) as float /\n-                 (int::pow(10, i) as float);\n-        i += 1u;\n-    }\n-    ret total;\n-}\n \n //\n // Local Variables:"}, {"sha": "98d8bb5e157e196618f48bdb05e35b9aac3d283e", "filename": "src/lib/int.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a034f87146e60e1db2327c6f6807c47406a1bb0b/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=a034f87146e60e1db2327c6f6807c47406a1bb0b", "patch": "@@ -41,29 +41,6 @@ iter range(lo: int, hi: int) -> int {\n     while lo_ < hi { put lo_; lo_ += 1; }\n }\n \n-fn parse_buf(buf: [u8], radix: uint) -> int {\n-    if vec::len::<u8>(buf) == 0u {\n-        log_err \"parse_buf(): buf is empty\";\n-        fail;\n-    }\n-    let i = vec::len::<u8>(buf) - 1u;\n-    let power = 1;\n-    if buf[0] == ('-' as u8) {\n-        power = -1;\n-        i -= 1u;\n-    }\n-    let n = 0;\n-    while true {\n-        n += (buf[i] - ('0' as u8) as int) * power;\n-        power *= radix as int;\n-        if i == 0u { ret n; }\n-        i -= 1u;\n-    }\n-    fail;\n-}\n-\n-fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n-\n fn to_str(n: int, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n     ret if n < 0 {"}, {"sha": "51883e8f8ddbafe01c042d3b0843398392c733f5", "filename": "src/test/compile-fail/alt-range-fail-dominate.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs?ref=410f73fdb23b189ea0b54dd5c025bbae5e58dee6", "patch": "@@ -1,38 +0,0 @@\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-\n-fn main() {\n-    alt 5u {\n-      1u to 10u { }\n-      5u to 6u { }\n-    };\n-\n-    alt 5u {\n-      4u to 6u { }\n-      3u to 5u { }\n-    };\n-\n-    alt 5u {\n-      4u to 6u { }\n-      5u to 7u { }\n-    };\n-\n-    alt 'c' {\n-      'A' to 'z' {}\n-      'a' to 'z' {}\n-    };\n-\n-    alt 1.0 {\n-      -5.0 to 5.0 {}\n-      0.0 to 6.5 {}\n-    };\n-\n-    alt 1.0 {\n-      0.02 {}\n-      0.01 to 6.5 {}\n-    };\n-}\n\\ No newline at end of file"}, {"sha": "0a9acdcd4b98b63b86352d4ecdd8b95abe8ead36", "filename": "src/test/compile-fail/alt-range-fail.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs?ref=410f73fdb23b189ea0b54dd5c025bbae5e58dee6", "patch": "@@ -1,19 +0,0 @@\n-//error-pattern: lower range bound\n-//error-pattern: non-numeric\n-//error-pattern: mismatched types\n-\n-fn main() {\n-    alt 5u {\n-      6u to 1u { }\n-      _ { }\n-    };\n-\n-    alt \"wow\" {\n-      \"wow\" to \"woow\" { }\n-    };\n-\n-    alt 5u {\n-      'c' to 100u { }\n-      _ { }\n-    };\n-}\n\\ No newline at end of file"}, {"sha": "1cd29cb35177bb978e94fb0f8a649ecd6115881c", "filename": "src/test/run-pass/alt-range.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410f73fdb23b189ea0b54dd5c025bbae5e58dee6/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=410f73fdb23b189ea0b54dd5c025bbae5e58dee6", "patch": "@@ -1,30 +0,0 @@\n-fn main() {\n-    alt 5u {\n-      1u to 5u {}\n-      _ { fail \"should match range\"; }\n-    }\n-    alt 5u {\n-      6u to 7u { fail \"shouldn't match range\"; }\n-      _ {}\n-    }\n-    alt 5u {\n-      1u { fail \"should match non-first range\"; }\n-      2u to 6u {}\n-    }\n-    alt 'c' {\n-      'a' to 'z' {}\n-      _ { fail \"should suppport char ranges\"; }\n-    }\n-    alt -3 {\n-      -7 to 5 {}\n-      _ { fail \"should match signed range\"; }\n-    }\n-    alt 3.0 {\n-      1.0 to 5.0 {}\n-      _ { fail \"should match float range\"; }\n-    }\n-    alt -1.5 {\n-      -3.6 to 3.6 {}\n-      _ { fail \"should match negative float range\"; }\n-    }\n-}"}]}