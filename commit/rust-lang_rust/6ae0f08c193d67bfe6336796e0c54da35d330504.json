{"sha": "6ae0f08c193d67bfe6336796e0c54da35d330504", "node_id": "C_kwDOAAsO6NoAKDZhZTBmMDhjMTkzZDY3YmZlNjMzNjc5NmUwYzU0ZGEzNWQzMzA1MDQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-01-06T06:08:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-06T06:08:56Z"}, "message": "Rollup merge of #106400 - estebank:type-errs, r=compiler-errors\n\nPoint at expressions where inference refines an unexpected type\n\nFix #106355. Fix #14007. (!)\n\n```\nerror[E0308]: mismatched types\n  --> src/test/ui/type/type-check/point-at-inference.rs:12:9\n   |\n9  |         foo.push(i);\n   |                  - this is of type `&{integer}`, which makes `foo` to be inferred as `Vec<&{integer}>`\n...\n12 |     bar(foo);\n   |     --- ^^^ expected `i32`, found `&{integer}`\n   |     |\n   |     arguments to this function are incorrect\n   |\n   = note: expected struct `Vec<i32>`\n              found struct `Vec<&{integer}>`\nnote: function defined here\n  --> src/test/ui/type/type-check/point-at-inference.rs:2:4\n   |\n2  | fn bar(_: Vec<i32>) {}\n   |    ^^^ -----------\nhelp: consider dereferencing the borrow\n   |\n9  |         foo.push(*i);\n   |                  +\n```", "tree": {"sha": "10c69cec34df6ee08f107fd45c71d1f3d17d3908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10c69cec34df6ee08f107fd45c71d1f3d17d3908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae0f08c193d67bfe6336796e0c54da35d330504", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjt7r4CRBK7hj4Ov3rIwAArRoIADb+9lNcZ/bTy+BA37rlD7eI\ny8uWONs3MtwXy31stNispH2Wgu2pVB07hsL1P1DuKU8mWUJTurFsKmW56ijLX+67\nbtv6393vqZhwuL2LPz2Rs+iiIdtXDJ0sKlOMEK0MdfMlGHc7oOF5yv6BHxcqunxs\n0ZVZTs996BMJ0kn4F6l69q1MUFxTrvnJ1qJ5TD0OjCM2Bk9Oi764o57aSsvbrW1e\ncR5XbmfAhiHoE3x6V2ctpQLqZAh/m2m1+vu8jbFEUo0tzUL+FtA/KDwom0IZJaSj\ncMXMW4hjbGXJrHOnc5Ty2fgX1j7MjCT93UMkDW0mV+Z5dlxa02YZmpysZo3jVac=\n=UwRW\n-----END PGP SIGNATURE-----\n", "payload": "tree 10c69cec34df6ee08f107fd45c71d1f3d17d3908\nparent 0853d9677ca903cd650d5c4b93b1c55e7995cf01\nparent f98f2fcb5e4985bd7b12bae4ec03f2d96197fb2b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1672985336 +0530\ncommitter GitHub <noreply@github.com> 1672985336 +0530\n\nRollup merge of #106400 - estebank:type-errs, r=compiler-errors\n\nPoint at expressions where inference refines an unexpected type\n\nFix #106355. Fix #14007. (!)\n\n```\nerror[E0308]: mismatched types\n  --> src/test/ui/type/type-check/point-at-inference.rs:12:9\n   |\n9  |         foo.push(i);\n   |                  - this is of type `&{integer}`, which makes `foo` to be inferred as `Vec<&{integer}>`\n...\n12 |     bar(foo);\n   |     --- ^^^ expected `i32`, found `&{integer}`\n   |     |\n   |     arguments to this function are incorrect\n   |\n   = note: expected struct `Vec<i32>`\n              found struct `Vec<&{integer}>`\nnote: function defined here\n  --> src/test/ui/type/type-check/point-at-inference.rs:2:4\n   |\n2  | fn bar(_: Vec<i32>) {}\n   |    ^^^ -----------\nhelp: consider dereferencing the borrow\n   |\n9  |         foo.push(*i);\n   |                  +\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae0f08c193d67bfe6336796e0c54da35d330504", "html_url": "https://github.com/rust-lang/rust/commit/6ae0f08c193d67bfe6336796e0c54da35d330504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae0f08c193d67bfe6336796e0c54da35d330504/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0853d9677ca903cd650d5c4b93b1c55e7995cf01", "url": "https://api.github.com/repos/rust-lang/rust/commits/0853d9677ca903cd650d5c4b93b1c55e7995cf01", "html_url": "https://github.com/rust-lang/rust/commit/0853d9677ca903cd650d5c4b93b1c55e7995cf01"}, {"sha": "f98f2fcb5e4985bd7b12bae4ec03f2d96197fb2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f98f2fcb5e4985bd7b12bae4ec03f2d96197fb2b", "html_url": "https://github.com/rust-lang/rust/commit/f98f2fcb5e4985bd7b12bae4ec03f2d96197fb2b"}], "stats": {"total": 413, "additions": 409, "deletions": 4}, "files": [{"sha": "cf070eb962f09bf46d0def52c36913a839a8116c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 220, "deletions": 3, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -1,21 +1,26 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n+use rustc_middle::ty::relate::TypeRelation;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitable};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -40,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_alternative_method_deref(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n-        let _ = self.suggest_missing_parentheses(err, expr)\n+        let suggested = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n             || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n@@ -54,6 +59,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+        if !suggested {\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+        }\n     }\n \n     pub fn emit_coerce_suggestions(\n@@ -205,6 +213,215 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n+    pub fn point_at_expr_source_of_inferred_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        found: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let map = self.tcx.hir();\n+\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n+        let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n+        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n+        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = map.find_parent(pat.hir_id) else { return false; };\n+        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n+        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n+            return false;\n+        }\n+\n+        // Locate all the usages of the relevant binding.\n+        struct FindExprs<'hir> {\n+            hir_id: hir::HirId,\n+            uses: Vec<&'hir hir::Expr<'hir>>,\n+        }\n+        impl<'v> Visitor<'v> for FindExprs<'v> {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n+                    && let hir::def::Res::Local(hir_id) = path.res\n+                    && hir_id == self.hir_id\n+                {\n+                    self.uses.push(ex);\n+                }\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n+        let id = map.get_parent_item(hir_id);\n+        let hir_id: hir::HirId = id.into();\n+\n+        let Some(node) = map.find(hir_id) else { return false; };\n+        let Some(body_id) = node.body_id() else { return false; };\n+        let body = map.body(body_id);\n+        expr_finder.visit_expr(body.value);\n+        // Hack to make equality checks on types with inference variables and regions useful.\n+        let mut eraser = BottomUpFolder {\n+            tcx: self.tcx,\n+            lt_op: |_| self.tcx.lifetimes.re_erased,\n+            ct_op: |c| c,\n+            ty_op: |t| match *t.kind() {\n+                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::IntVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n+                }\n+                ty::Infer(ty::FloatVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::FloatVar(ty::FloatVid { index: 0 }))\n+                }\n+                _ => t,\n+            },\n+        };\n+        let mut prev = eraser.fold_ty(ty);\n+        let mut prev_span = None;\n+\n+        for binding in expr_finder.uses {\n+            // In every expression where the binding is referenced, we will look at that\n+            // expression's type and see if it is where the incorrect found type was fully\n+            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n+            if let Some(hir::Node::Expr(expr)\n+            | hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n+                ..\n+            })) = &map.find_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n+            {\n+                // We special case methods, because they can influence inference through the\n+                // call's arguments and we can provide a more explicit span.\n+                let sig = self.tcx.fn_sig(def_id);\n+                let def_self_ty = sig.input(0).skip_binder();\n+                let rcvr_ty = self.node_ty(rcvr.hir_id);\n+                // Get the evaluated type *after* calling the method call, so that the influence\n+                // of the arguments can be reflected in the receiver type. The receiver\n+                // expression has the type *before* theis analysis is done.\n+                let ty = match self.lookup_probe(\n+                    segment.ident,\n+                    rcvr_ty,\n+                    expr,\n+                    probe::ProbeScope::TraitsInScope,\n+                ) {\n+                    Ok(pick) => pick.self_ty,\n+                    Err(_) => rcvr_ty,\n+                };\n+                // Remove one layer of references to account for `&mut self` and\n+                // `&self`, so that we can compare it against the binding.\n+                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n+                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n+                    _ => (ty, def_self_ty),\n+                };\n+                let mut param_args = FxHashMap::default();\n+                let mut param_expected = FxHashMap::default();\n+                let mut param_found = FxHashMap::default();\n+                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                    // We only point at the first place where the found type was inferred.\n+                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n+                            // We found an argument that references a type parameter in `Self`,\n+                            // so we assume that this is the argument that caused the found\n+                            // type, which we know already because of `can_eq` above was first\n+                            // inferred in this method call.\n+                            let arg = &args[i];\n+                            let arg_ty = self.node_ty(arg.hir_id);\n+                            err.span_label(\n+                                arg.span,\n+                                &format!(\n+                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                     inferred as `{ty}`\",\n+                                ),\n+                            );\n+                            param_args.insert(param_ty, (arg, arg_ty));\n+                        }\n+                    }\n+                }\n+\n+                // Here we find, for a type param `T`, the type that `T` is in the current\n+                // method call *and* in the original expected type. That way, we can see if we\n+                // can give any structured suggestion for the function argument.\n+                let mut c = CollectAllMismatches {\n+                    infcx: &self.infcx,\n+                    param_env: self.param_env,\n+                    errors: vec![],\n+                };\n+                let _ = c.relate(def_self_ty, ty);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_found.insert(error.expected, error.found);\n+                    }\n+                }\n+                c.errors = vec![];\n+                let _ = c.relate(def_self_ty, expected);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_expected.insert(error.expected, error.found);\n+                    }\n+                }\n+                for (param, (arg, arg_ty)) in param_args.iter() {\n+                    let Some(expected) = param_expected.get(param) else { continue; };\n+                    let Some(found) = param_found.get(param) else { continue; };\n+                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n+                }\n+\n+                let ty = eraser.fold_ty(ty);\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && param_args.is_empty()\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    err.span_label(\n+                        segment.ident.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                } else if !param_args.is_empty() {\n+                    break;\n+                }\n+                prev = ty;\n+            } else {\n+                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && let Some(span) = prev_span\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    // We use the *previous* span because if the type is known *here* it means\n+                    // it was *evaluated earlier*. We don't do this for method calls because we\n+                    // evaluate the method's self type eagerly, but not in any other case.\n+                    err.span_label(\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                }\n+                prev = ty;\n+            }\n+            if binding.hir_id == expr.hir_id {\n+                // Do not look at expressions that come after the expression we were originally\n+                // evaluating and had a type error.\n+                break;\n+            }\n+            prev_span = Some(binding.span);\n+        }\n+        true\n+    }\n+\n     fn annotate_expected_due_to_let_ty(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "6ed1bc051a5fa406b0845d0579527fdb78071f6f", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -234,6 +234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) => self.check_expr_path(qpath, expr, args),\n             _ => self.check_expr_kind(expr, expected),\n         });\n+        let ty = self.resolve_vars_if_possible(ty);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {"}, {"sha": "7d6b4aaebf4ea93c4313699c7d0208c065273088", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -798,6 +798,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n+            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n+                (callee_ty, &call_expr.kind)\n+            {\n+                // Type that would have accepted this argument if it hadn't been inferred earlier.\n+                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n+                // specific type to increase the accuracy of the diagnostic.\n+                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: full_call_span,\n+                });\n+                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+            }\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "749e960bfd03090876186167b6b6247b5eb44efc", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .as_local()\n                 .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n         };\n-        let value = value.fold_with(&mut ty::fold::BottomUpFolder {\n+        let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,"}, {"sha": "de133e5599cf96fb8d0efce000d83a58eb5f957f", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -67,6 +67,9 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -75,6 +78,9 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -92,6 +98,9 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "6557d7fa1911afc3fa5ea3a871c762b3fffdf468", "filename": "src/test/ui/type/type-check/point-at-inference-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,13 @@\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &Vec<&i32>) {}\n+fn main() {\n+    let v = vec![&1];\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+}"}, {"sha": "13227c5e245bdf9748ab3a4f4f398e09d5ce05b2", "filename": "src/test/ui/type/type-check/point-at-inference-2.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,56 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:5:9\n+   |\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:9:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     baz(&v);\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:12:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1a960133ceba9ab2f858ed0e099c792b91cb24c0", "filename": "src/test/ui/type/type-check/point-at-inference-3.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+fn main() {\n+    let mut v = Vec::new();\n+    v.push(0i32);\n+    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    v.push(0);\n+    v.push(1i32); //~ ERROR mismatched types\n+    //~^ NOTE expected `i32`, found `u32`\n+    //~| NOTE arguments to this method are incorrect\n+    //~| NOTE associated function defined here\n+    //~| HELP change the type of the numeric literal from `u32` to `i32`\n+}"}, {"sha": "92910ae1a31141e82618bda673ae8ae6f55e1ae0", "filename": "src/test/ui/type/type-check/point-at-inference-3.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+fn main() {\n+    let mut v = Vec::new();\n+    v.push(0i32);\n+    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    v.push(0);\n+    v.push(1u32); //~ ERROR mismatched types\n+    //~^ NOTE expected `i32`, found `u32`\n+    //~| NOTE arguments to this method are incorrect\n+    //~| NOTE associated function defined here\n+    //~| HELP change the type of the numeric literal from `u32` to `i32`\n+}"}, {"sha": "999c3148362f615873293e4869fc2cea0682dd8c", "filename": "src/test/ui/type/type-check/point-at-inference-3.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-3.rs:7:12\n+   |\n+LL |     v.push(0i32);\n+   |            ---- this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+...\n+LL |     v.push(1u32);\n+   |       ---- ^^^^ expected `i32`, found `u32`\n+   |       |\n+   |       arguments to this method are incorrect\n+   |\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     v.push(1i32);\n+   |             ~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f41fbe59fba6c26b67786c9791f1bebc0d930273", "filename": "src/test/ui/type/type-check/point-at-inference.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(*i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "6419e42e70d12512c8bab82eac5d40f5f6a79e7a", "filename": "src/test/ui/type/type-check/point-at-inference.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "70428fe841b9c9425127119005f37b6cb480a7d0", "filename": "src/test/ui/type/type-check/point-at-inference.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0f08c193d67bfe6336796e0c54da35d330504/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=6ae0f08c193d67bfe6336796e0c54da35d330504", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference.rs:12:9\n+   |\n+LL |         foo.push(i);\n+   |                  - this is of type `&{integer}`, which causes `foo` to be inferred as `Vec<&{integer}>`\n+...\n+LL |     bar(foo);\n+   |     --- ^^^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference.rs:2:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+help: consider dereferencing the borrow\n+   |\n+LL |         foo.push(*i);\n+   |                  +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}