{"sha": "d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjhjMmU2NDJjNmY4Zjg1ZjI0ZGQ1ZDdmNDlkZTg5Yjk1YmY2ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T18:25:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T18:25:13Z"}, "message": "Auto merge of #60237 - saleemjaffer:issue-56166-miri-fntype-arg-passing, r=eddyb\n\nMove pointee_info_at from rustc_codegen_llvm to rustc_target.\n\nMakes progress towards #56166.\n\nThis is a continuation of https://github.com/rust-lang/rust/pull/57150.\n\n@oli-obk Should I close the older PR?", "tree": {"sha": "def3c31e34937115a64751b9120d9d18b3a8446c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/def3c31e34937115a64751b9120d9d18b3a8446c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "html_url": "https://github.com/rust-lang/rust/commit/d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "html_url": "https://github.com/rust-lang/rust/commit/c6b16987645dd8980f40efe7c72d4f3fd4b399d3"}, {"sha": "968eb7ff5a5db0d842527cba15be6dba741103a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/968eb7ff5a5db0d842527cba15be6dba741103a2", "html_url": "https://github.com/rust-lang/rust/commit/968eb7ff5a5db0d842527cba15be6dba741103a2"}], "stats": {"total": 387, "additions": 233, "deletions": 154}, "files": [{"sha": "d1a8a9a34e1559fd57d3a72b80ed29ab2f717446", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 160, "deletions": 18, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -12,6 +12,7 @@ use std::iter;\n use std::mem;\n use std::ops::Bound;\n \n+use crate::hir;\n use crate::ich::StableHashingContext;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -1518,6 +1519,10 @@ pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n }\n \n+pub trait HasParamEnv<'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+}\n+\n impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n@@ -1530,6 +1535,12 @@ impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'tcx, C> HasParamEnv<'tcx> for LayoutCx<'tcx, C> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.tcx.data_layout()\n@@ -1543,25 +1554,32 @@ impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n }\n \n pub trait MaybeResult<T> {\n-    fn from_ok(x: T) -> Self;\n-    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self;\n+    type Error;\n+\n+    fn from(x: Result<T, Self::Error>) -> Self;\n+    fn to_result(self) -> Result<T, Self::Error>;\n }\n \n impl<T> MaybeResult<T> for T {\n-    fn from_ok(x: T) -> Self {\n+    type Error = !;\n+\n+    fn from(x: Result<T, Self::Error>) -> Self {\n+        let Ok(x) = x;\n         x\n     }\n-    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n-        f(self)\n+    fn to_result(self) -> Result<T, Self::Error> {\n+        Ok(self)\n     }\n }\n \n impl<T, E> MaybeResult<T> for Result<T, E> {\n-    fn from_ok(x: T) -> Self {\n-        Ok(x)\n+    type Error = E;\n+\n+    fn from(x: Result<T, Self::Error>) -> Self {\n+        x\n     }\n-    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n-        self.map(f)\n+    fn to_result(self) -> Result<T, Self::Error> {\n+        self\n     }\n }\n \n@@ -1656,18 +1674,18 @@ impl ty::query::TyCtxtAt<'a, 'tcx, '_> {\n \n impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n-          C::TyLayout: MaybeResult<TyLayout<'tcx>>\n+          C::TyLayout: MaybeResult<TyLayout<'tcx>>,\n+          C: HasParamEnv<'tcx>\n {\n     fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n         let details = match this.variants {\n             Variants::Single { index } if index == variant_index => this.details,\n \n             Variants::Single { index } => {\n                 // Deny calling for_variant more than once for non-Single enums.\n-                cx.layout_of(this.ty).map_same(|layout| {\n+                if let Ok(layout) = cx.layout_of(this.ty).to_result() {\n                     assert_eq!(layout.variants, Variants::Single { index });\n-                    layout\n-                });\n+                }\n \n                 let fields = match this.ty.sty {\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n@@ -1700,10 +1718,10 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n         let tcx = cx.tcx();\n         let discr_layout = |discr: &Scalar| -> C::TyLayout {\n             let layout = LayoutDetails::scalar(cx, discr.clone());\n-            MaybeResult::from_ok(TyLayout {\n+            MaybeResult::from(Ok(TyLayout {\n                 details: tcx.intern_layout(layout),\n-                ty: discr.value.to_ty(tcx)\n-            })\n+                ty: discr.value.to_ty(tcx),\n+            }))\n         };\n \n         cx.layout_of(match this.ty.sty {\n@@ -1737,10 +1755,10 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     } else {\n                         tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n                     };\n-                    return cx.layout_of(ptr_ty).map_same(|mut ptr_layout| {\n+                    return MaybeResult::from(cx.layout_of(ptr_ty).to_result().map(|mut ptr_layout| {\n                         ptr_layout.ty = this.ty;\n                         ptr_layout\n-                    });\n+                    }));\n                 }\n \n                 match tcx.struct_tail(pointee).sty {\n@@ -1824,6 +1842,130 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n         })\n     }\n+\n+    fn pointee_info_at(\n+        this: TyLayout<'tcx>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo> {\n+        match this.ty.sty {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                cx.layout_of(mt.ty).to_result().ok()\n+                    .map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                    })\n+            }\n+\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                let tcx = cx.tcx();\n+                let is_freeze = ty.is_freeze(tcx, cx.param_env(), DUMMY_SP);\n+                let kind = match mt {\n+                    hir::MutImmutable => if is_freeze {\n+                        PointerKind::Frozen\n+                    } else {\n+                        PointerKind::Shared\n+                    },\n+                    hir::MutMutable => {\n+                        // Previously we would only emit noalias annotations for LLVM >= 6 or in\n+                        // panic=abort mode. That was deemed right, as prior versions had many bugs\n+                        // in conjunction with unwinding, but later versions didn\u2019t seem to have\n+                        // said issues. See issue #31681.\n+                        //\n+                        // Alas, later on we encountered a case where noalias would generate wrong\n+                        // code altogether even with recent versions of LLVM in *safe* code with no\n+                        // unwinding involved. See #54462.\n+                        //\n+                        // For now, do not enable mutable_noalias by default at all, while the\n+                        // issue is being figured out.\n+                        let mutable_noalias = tcx.sess.opts.debugging_opts.mutable_noalias\n+                            .unwrap_or(false);\n+                        if mutable_noalias {\n+                            PointerKind::UniqueBorrowed\n+                        } else {\n+                            PointerKind::Shared\n+                        }\n+                    }\n+                };\n+\n+                cx.layout_of(ty).to_result().ok()\n+                    .map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: Some(kind),\n+                    })\n+            }\n+\n+            _ => {\n+                let mut data_variant = match this.variants {\n+                    // Within the discriminant field, only the niche itself is\n+                    // always initialized, so we only check for a pointer at its\n+                    // offset.\n+                    //\n+                    // If the niche is a pointer, it's either valid (according\n+                    // to its type), or null (which the niche field's scalar\n+                    // validity range encodes).  This allows using\n+                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                    // this will continue to work as long as we don't start\n+                    // using more niches than just null (e.g., the first page of\n+                    // the address space, or unaligned pointers).\n+                    Variants::Multiple {\n+                        discr_kind: DiscriminantKind::Niche {\n+                            dataful_variant,\n+                            ..\n+                        },\n+                        discr_index,\n+                        ..\n+                    } if this.fields.offset(discr_index) == offset =>\n+                        Some(this.for_variant(cx, dataful_variant)),\n+                    _ => Some(this),\n+                };\n+\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let FieldPlacement::Union(_) = variant.fields {\n+                        data_variant = None;\n+                    }\n+                }\n+\n+                let mut result = None;\n+\n+                if let Some(variant) = data_variant {\n+                    let ptr_end = offset + Pointer.size(cx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(cx, i);\n+                            result = field.to_result().ok()\n+                                .and_then(|field| {\n+                                    if ptr_end <= field_start + field.size {\n+                                        // We found the right field, look inside it.\n+                                        field.pointee_info_at(cx, offset - field_start)\n+                                    } else {\n+                                        None\n+                                    }\n+                                });\n+                            if result.is_some() {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::Adt(def, _) = this.ty.sty {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                        }\n+                    }\n+                }\n+\n+                result\n+            }\n+        }\n+    }\n }\n \n struct Niche {"}, {"sha": "70d184240fccd1a6bd85d94813809eaa7ab14860", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -2,8 +2,8 @@ use crate::llvm::{self, AttributePlace};\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n-use crate::type_of::{LayoutLlvmExt, PointerKind};\n use crate::value::Value;\n+use crate::type_of::{LayoutLlvmExt};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n@@ -13,7 +13,7 @@ use rustc_codegen_ssa::traits::*;\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty, Instance};\n-use rustc::ty::layout;\n+use rustc::ty::layout::{self, PointerKind};\n \n use libc::c_uint;\n "}, {"sha": "bc2bb97a19e5471f5a8e6e5739eca5d200f8fe8f", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -66,6 +66,12 @@ impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n+impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.cx.param_env()\n+    }\n+}\n+\n impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;"}, {"sha": "7bf8f705ea8ad84d2427bb70c3a6b557463ae385", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -8,15 +8,16 @@ use rustc::hir;\n \n use crate::monomorphize::partitioning::CodegenUnit;\n use crate::type_::Type;\n-use crate::type_of::PointeeInfo;\n use rustc_codegen_ssa::traits::*;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout, VariantIdx};\n+use rustc::ty::layout::{\n+    LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx, HasParamEnv\n+};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n@@ -862,3 +863,9 @@ impl LayoutOf for CodegenCx<'ll, 'tcx> {\n             })\n     }\n }\n+\n+impl<'tcx, 'll> HasParamEnv<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        ty::ParamEnv::reveal_all()\n+    }\n+}"}, {"sha": "ff25ed9256613c867cae9a3b9315a5549b34b67d", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 3, "deletions": 131, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -1,10 +1,9 @@\n use crate::abi::{FnType, FnTypeExt};\n use crate::common::*;\n use crate::type_::Type;\n-use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n-use rustc_target::abi::FloatTy;\n+use rustc::ty::layout::{self, Align, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;\n \n@@ -174,28 +173,6 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum PointerKind {\n-    /// Most general case, we know no restrictions to tell LLVM.\n-    Shared,\n-\n-    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n-    Frozen,\n-\n-    /// `&mut T`, when we know `noalias` is safe for LLVM.\n-    UniqueBorrowed,\n-\n-    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n-    UniqueOwned\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PointeeInfo {\n-    pub size: Size,\n-    pub align: Align,\n-    pub safe: Option<PointerKind>,\n-}\n-\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n@@ -406,112 +383,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             return pointee;\n         }\n \n-        let mut result = None;\n-        match self.ty.sty {\n-            ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(mt.ty);\n-                result = Some(PointeeInfo {\n-                    size,\n-                    align,\n-                    safe: None\n-                });\n-            }\n-\n-            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(ty);\n-\n-                let kind = match mt {\n-                    hir::MutImmutable => if cx.type_is_freeze(ty) {\n-                        PointerKind::Frozen\n-                    } else {\n-                        PointerKind::Shared\n-                    },\n-                    hir::MutMutable => {\n-                        // Previously we would only emit noalias annotations for LLVM >= 6 or in\n-                        // panic=abort mode. That was deemed right, as prior versions had many bugs\n-                        // in conjunction with unwinding, but later versions didn\u2019t seem to have\n-                        // said issues. See issue #31681.\n-                        //\n-                        // Alas, later on we encountered a case where noalias would generate wrong\n-                        // code altogether even with recent versions of LLVM in *safe* code with no\n-                        // unwinding involved. See #54462.\n-                        //\n-                        // For now, do not enable mutable_noalias by default at all, while the\n-                        // issue is being figured out.\n-                        let mutable_noalias = cx.tcx.sess.opts.debugging_opts.mutable_noalias\n-                            .unwrap_or(false);\n-                        if mutable_noalias {\n-                            PointerKind::UniqueBorrowed\n-                        } else {\n-                            PointerKind::Shared\n-                        }\n-                    }\n-                };\n-\n-                result = Some(PointeeInfo {\n-                    size,\n-                    align,\n-                    safe: Some(kind)\n-                });\n-            }\n-\n-            _ => {\n-                let mut data_variant = match self.variants {\n-                    // Within the discriminant field, only the niche itself is\n-                    // always initialized, so we only check for a pointer at its\n-                    // offset.\n-                    //\n-                    // If the niche is a pointer, it's either valid (according\n-                    // to its type), or null (which the niche field's scalar\n-                    // validity range encodes).  This allows using\n-                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                    // this will continue to work as long as we don't start\n-                    // using more niches than just null (e.g., the first page of\n-                    // the address space, or unaligned pointers).\n-                    layout::Variants::Multiple {\n-                        discr_kind: layout::DiscriminantKind::Niche {\n-                            dataful_variant,\n-                            ..\n-                        },\n-                        discr_index,\n-                        ..\n-                    } if self.fields.offset(discr_index) == offset =>\n-                        Some(self.for_variant(cx, dataful_variant)),\n-                    _ => Some(*self),\n-                };\n-\n-                if let Some(variant) = data_variant {\n-                    // We're not interested in any unions.\n-                    if let layout::FieldPlacement::Union(_) = variant.fields {\n-                        data_variant = None;\n-                    }\n-                }\n-\n-                if let Some(variant) = data_variant {\n-                    let ptr_end = offset + layout::Pointer.size(cx);\n-                    for i in 0..variant.fields.count() {\n-                        let field_start = variant.fields.offset(i);\n-                        if field_start <= offset {\n-                            let field = variant.field(cx, i);\n-                            if ptr_end <= field_start + field.size {\n-                                // We found the right field, look inside it.\n-                                result = field.pointee_info_at(cx, offset - field_start);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = self.ty.sty {\n-                        if def.is_box() && offset.bytes() == 0 {\n-                            pointee.safe = Some(PointerKind::UniqueOwned);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        let result = Ty::pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}, {"sha": "a3f99cd869e28f5851aebc854d63d57dc9c175da", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -10,7 +10,7 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n use rustc::ty::Ty;\n-use rustc::ty::layout::{Align, Size};\n+use rustc::ty::layout::{Align, Size, HasParamEnv};\n use std::ops::Range;\n use std::iter::TrustedLen;\n \n@@ -29,6 +29,8 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     + IntrinsicCallMethods<'tcx>\n     + AsmBuilderMethods<'tcx>\n     + StaticBuilderMethods<'tcx>\n+    + HasParamEnv<'tcx>\n+\n {\n     fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;"}, {"sha": "c237cd8bd2645b009b33536175a1dada09b4dd90", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -41,6 +41,8 @@ pub use self::type_::{\n     ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n+use rustc::ty::layout::{HasParamEnv};\n+\n \n use std::fmt;\n \n@@ -58,6 +60,7 @@ pub trait CodegenMethods<'tcx>:\n     + DeclareMethods<'tcx>\n     + AsmMethods<'tcx>\n     + PreDefineMethods<'tcx>\n+    + HasParamEnv<'tcx>\n {\n }\n \n@@ -72,6 +75,7 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + DeclareMethods<'tcx>\n         + AsmMethods<'tcx>\n         + PreDefineMethods<'tcx>\n+        + HasParamEnv<'tcx>\n {\n }\n "}, {"sha": "db827afdb94f4481096d600aa8db0cd5ec599e9d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -175,6 +175,14 @@ impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'a, 'mir, 'tcx,\n     }\n }\n \n+impl<'a, 'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n+    where M: Machine<'a, 'mir, 'tcx>\n+{\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     for InterpretCx<'a, 'mir, 'tcx, M>\n {"}, {"sha": "7041a5593abbfe861d664f081f1fd74be0cdd81c", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -7,6 +7,7 @@ use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::layout::TargetDataLayout;\n use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::HasParamEnv;\n use rustc::ty::ParamEnv;\n use rustc::ty::Ty;\n use rustc::ty::TyCtxt;\n@@ -122,6 +123,12 @@ impl<'me, 'tcx> HasTyCtxt<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n     }\n }\n \n+impl<'me, 'tcx> HasParamEnv<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n impl<'me, 'tcx> HasDataLayout for UnwrapLayoutCx<'me, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.tcx.data_layout()"}, {"sha": "4b61057e5cf6cec4b5c5d13dc807880517297261", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d628c2e642c6f8f85f24dd5d7f49de89b95bf682/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=d628c2e642c6f8f85f24dd5d7f49de89b95bf682", "patch": "@@ -910,13 +910,40 @@ pub trait LayoutOf {\n     fn layout_of(&self, ty: Self::Ty) -> Self::TyLayout;\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum PointerKind {\n+    /// Most general case, we know no restrictions to tell LLVM.\n+    Shared,\n+\n+    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n+    Frozen,\n+\n+    /// `&mut T`, when we know `noalias` is safe for LLVM.\n+    UniqueBorrowed,\n+\n+    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n+    UniqueOwned\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+}\n+\n pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n     fn for_variant(\n         this: TyLayout<'a, Self>,\n         cx: &C,\n         variant_index: VariantIdx,\n     ) -> TyLayout<'a, Self>;\n     fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n+    fn pointee_info_at(\n+        this: TyLayout<'a, Self>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo>;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {\n@@ -928,6 +955,10 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::field(self, cx, i)\n     }\n+    pub fn pointee_info_at<C>(self, cx: &C, offset: Size) -> Option<PointeeInfo>\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n+        Ty::pointee_info_at(self, cx, offset)\n+    }\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {"}]}