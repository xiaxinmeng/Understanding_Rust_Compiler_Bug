{"sha": "718ba0d23bc13cd987acbb1b2286552eeee88a1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOGJhMGQyM2JjMTNjZDk4N2FjYmIxYjIyODY1NTJlZWVlODhhMWQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-31T22:27:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-31T22:27:18Z"}, "message": "Rollup merge of #68770 - ssomers:btree_drain_filter, r=Amanieu\n\nBTreeMap/BTreeSet: implement drain_filter\n\nProvide an implementation of drain_filter for BTreeMap and BTreeSet. Should be optimal when the predicate picks only elements in leaf nodes with at least MIN_LEN remaining elements, which is a common case, at least when draining only a fraction of the map/set, and also when the predicate picks elements stored in internal nodes where the right subtree can easily let go of a replacement element.\n\nThe first commit adds benchmarks with an external, naive implementation. to compare how much this claimed optimality-in-some-cases is actually worth.", "tree": {"sha": "362ee678f2b2043b594c1e330ae3c223c271c7ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/362ee678f2b2043b594c1e330ae3c223c271c7ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/718ba0d23bc13cd987acbb1b2286552eeee88a1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeg8PHCRBK7hj4Ov3rIwAAdHIIAKvIw/e1k2Htl8syCyz1MVYs\naIM0ki0u6pWLuM8MQrc9XFXvw5QGqy3fignnJmYNc4WzIoKZRgRWny/3ZeHnR10w\n+4xnteRduzbRGfBgdOvz46QIop6nC8FWS7REodXsvAyblgoSklXt4u+n/HjjgUBK\nCx/+gACGTUXk8O0R/P5/Tz6z50SNC0nymo1q/P+er19PAeO9DeOLnBBTU4l5/mq+\nrNy5mPWuXQA1+hqToTbpbfojkXJSagaHrqPNGsHAlp7HA3/mwsyv2f5phGxzolIu\nZ6iPGyFiYyhSFcXMC7GEdCsd28YY8tJXQT0ytPE24+wDz3P6hh1LgNdsW+q63W8=\n=fkg9\n-----END PGP SIGNATURE-----\n", "payload": "tree 362ee678f2b2043b594c1e330ae3c223c271c7ec\nparent a5b09d35473615e7142f5570f5c5fad0caf68bd2\nparent 0405db3a341a094f421a762a15c14b392fec94f8\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585693638 +0200\ncommitter GitHub <noreply@github.com> 1585693638 +0200\n\nRollup merge of #68770 - ssomers:btree_drain_filter, r=Amanieu\n\nBTreeMap/BTreeSet: implement drain_filter\n\nProvide an implementation of drain_filter for BTreeMap and BTreeSet. Should be optimal when the predicate picks only elements in leaf nodes with at least MIN_LEN remaining elements, which is a common case, at least when draining only a fraction of the map/set, and also when the predicate picks elements stored in internal nodes where the right subtree can easily let go of a replacement element.\n\nThe first commit adds benchmarks with an external, naive implementation. to compare how much this claimed optimality-in-some-cases is actually worth.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/718ba0d23bc13cd987acbb1b2286552eeee88a1d", "html_url": "https://github.com/rust-lang/rust/commit/718ba0d23bc13cd987acbb1b2286552eeee88a1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/718ba0d23bc13cd987acbb1b2286552eeee88a1d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b09d35473615e7142f5570f5c5fad0caf68bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "html_url": "https://github.com/rust-lang/rust/commit/a5b09d35473615e7142f5570f5c5fad0caf68bd2"}, {"sha": "0405db3a341a094f421a762a15c14b392fec94f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0405db3a341a094f421a762a15c14b392fec94f8", "html_url": "https://github.com/rust-lang/rust/commit/0405db3a341a094f421a762a15c14b392fec94f8"}], "stats": {"total": 685, "additions": 671, "deletions": 14}, "files": [{"sha": "2518506b9b5f3915996f9bc84fbc0f688c1e05af", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -62,6 +62,22 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_100_and_drain_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_100_and_drain_half(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.len(), 100 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n     let src = pos(100);\n@@ -115,6 +131,22 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.len(), 10_000 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n     let src = pos(10_000);"}, {"sha": "f31717d9fd517e76b860364f430e7170d2194822", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -1,3 +1,4 @@\n+#![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]"}, {"sha": "bbeced1751d1451830e5c3673f1489a6b6953de3", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 200, "deletions": 10, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -1256,6 +1256,48 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let odds = map;\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.drain_filter_inner() }\n+    }\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+    }\n+\n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n         fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n@@ -1653,6 +1695,124 @@ impl<K, V> Clone for Values<'_, K, V> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeMap.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord, // This Ord bound should be removed before stabilization.\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    pred: F,\n+    inner: DrainFilterInner<'a, K, V>,\n+}\n+pub(super) struct DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    length: &'a mut usize,\n+    cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Drop for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + fmt::Debug + Ord,\n+    V: 'a + fmt::Debug,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Iterator for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next(&mut self.pred)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a, K, V> DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    /// Allow Debug implementations to predict the next element.\n+    pub(super) fn peek(&self) -> Option<(&K, &V)> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n+    }\n+\n+    unsafe fn next_kv(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        ptr::read(edge).next_kv().ok()\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        while let Some(kv) = unsafe { self.next_kv() } {\n+            let (k, v) = unsafe { ptr::read(&kv) }.into_kv_mut();\n+            if pred(k, v) {\n+                *self.length -= 1;\n+                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n+                // `remove_kv_tracking` has either preserved or invalidated `self.cur_leaf_edge`\n+                if let Some(node) = leaf_edge_location {\n+                    match search::search_tree(node, &k) {\n+                        search::SearchResult::Found(_) => unreachable!(),\n+                        search::SearchResult::GoDown(leaf) => self.cur_leaf_edge = Some(leaf),\n+                    }\n+                };\n+                return Some((k, v));\n+            }\n+            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n+        }\n+        None\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(*self.length))\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F>\n+where\n+    K: Ord,\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -2531,12 +2691,31 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n+        (old_key, old_val)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the whereabouts of the leaf edge corresponding to that former pair:\n+    /// if None is returned, the leaf edge is still the left leaf edge of the KV handle;\n+    /// if a node is returned, it heads the subtree where the leaf edge may be found.\n+    fn remove_kv_tracking(\n+        self,\n+    ) -> (K, V, Option<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>>) {\n+        let mut levels_down_handled: isize;\n+        let (small_leaf, old_key, old_val) = match self.force() {\n             Leaf(leaf) => {\n+                levels_down_handled = 1; // handled at same level, but affects only the right side\n                 let (hole, old_key, old_val) = leaf.remove();\n                 (hole.into_node(), old_key, old_val)\n             }\n             Internal(mut internal) => {\n+                // Replace the location freed in the internal node with the next KV,\n+                // and remove that next KV from its leaf.\n+                levels_down_handled = unsafe { ptr::read(&internal).into_node().height() } as isize;\n+\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n@@ -2556,27 +2735,39 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         let mut cur_node = small_leaf.forget_type();\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n-                AtRoot => break,\n+                AtRoot(root) => {\n+                    cur_node = root;\n+                    break;\n+                }\n                 EmptyParent(_) => unreachable!(),\n                 Merged(parent) => {\n+                    levels_down_handled -= 1;\n                     if parent.len() == 0 {\n                         // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        let root = parent.into_root_mut();\n+                        root.pop_level();\n+                        cur_node = root.as_mut();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n                     }\n                 }\n-                Stole(_) => break,\n+                Stole(internal_node) => {\n+                    levels_down_handled -= 1;\n+                    cur_node = internal_node.forget_type();\n+                    // This internal node might be underfull, but only if it's the root.\n+                    break;\n+                }\n             }\n         }\n \n-        (old_key, old_val)\n+        let leaf_edge_location = if levels_down_handled > 0 { None } else { Some(cur_node) };\n+        (old_key, old_val, leaf_edge_location)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n+    AtRoot(NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>),\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n@@ -2585,10 +2776,9 @@ enum UnderflowResult<'a, K, V> {\n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n-    let parent = if let Ok(parent) = node.ascend() {\n-        parent\n-    } else {\n-        return AtRoot;\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(root) => return AtRoot(root),\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {"}, {"sha": "0b02223def4f85dc76c4b894e2cd5c94d222f69a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -8,8 +8,8 @@ use core::fmt::{self, Debug};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n+use super::map::{BTreeMap, Keys};\n use super::Recover;\n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -102,7 +102,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: btree_map::IntoIter<T, ()>,\n+    iter: super::map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -115,7 +115,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: btree_map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, ()>,\n }\n \n /// Core of SymmetricDifference and Union.\n@@ -944,6 +944,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<i32> = (0..8).collect();\n+    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let odds = set;\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    where\n+        F: 'a + FnMut(&T) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+    }\n }\n \n impl<T> BTreeSet<T> {\n@@ -1055,6 +1090,66 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeSet.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    pred: F,\n+    inner: super::map::DrainFilterInner<'a, T, ()>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> fmt::Debug for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord + fmt::Debug,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, 'f, T, F> Iterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + 'f + FnMut(&T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let pred = &mut self.pred;\n+        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> FusedIterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "14f12ca2d779a453881489ade0410bfc55c05023", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 258, "deletions": 1, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -5,7 +5,7 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n@@ -609,6 +609,263 @@ fn test_range_mut() {\n     }\n }\n \n+mod test_drain_filter {\n+    use super::*;\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq(pairs));\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq(std::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq(0..3));\n+        assert!(map.values().copied().eq(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..3));\n+    }\n+\n+    #[test]\n+    fn underfull_removing_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for doomed in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for sacred in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+    }\n+\n+    #[test]\n+    fn height_0_removing_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for doomed in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for sacred in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_removing_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_half() {\n+        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n+        assert_eq!(map.len(), 8);\n+    }\n+\n+    #[test]\n+    fn height_1_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_1_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_1_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_2_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            }))\n+        }))\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+}\n+\n #[test]\n fn test_borrow() {\n     // make sure these compile -- using the Borrow trait"}, {"sha": "136018b9f7df53e1f44985883524fca60aac293f", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -1,5 +1,7 @@\n use std::collections::BTreeSet;\n use std::iter::FromIterator;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -302,6 +304,85 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_drain_filter() {\n+    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            match d.0 {\n+                0 => true,\n+                _ => panic!(),\n+            }\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(set.len(), 2);\n+    assert_eq!(set.first().unwrap().0, 4);\n+    assert_eq!(set.last().unwrap().0, 8);\n+}\n+\n #[test]\n fn test_clear() {\n     let mut x = BTreeSet::new();"}, {"sha": "ad6feaeebc67f884208e0fd4721935579fd8f662", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718ba0d23bc13cd987acbb1b2286552eeee88a1d/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=718ba0d23bc13cd987acbb1b2286552eeee88a1d", "patch": "@@ -1,5 +1,6 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(map_first_last)]"}]}