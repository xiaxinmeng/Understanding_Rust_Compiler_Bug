{"sha": "5c7cd6419caf764bb0a78351b8e97fb68db8a352", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjN2NkNjQxOWNhZjc2NGJiMGE3ODM1MWI4ZTk3ZmI2OGRiOGEzNTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-24T01:31:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-24T01:31:16Z"}, "message": "Modify translation of obj methods to accept an initial recursive-self-typed (in the LLVM sense) obj argument.", "tree": {"sha": "7943bbf45042bd646eb0dacaa93b58dd23b34a7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7943bbf45042bd646eb0dacaa93b58dd23b34a7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c7cd6419caf764bb0a78351b8e97fb68db8a352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c7cd6419caf764bb0a78351b8e97fb68db8a352", "html_url": "https://github.com/rust-lang/rust/commit/5c7cd6419caf764bb0a78351b8e97fb68db8a352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c7cd6419caf764bb0a78351b8e97fb68db8a352/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2195d8b0adda5aa10e95c2bc31a3206211eadda", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2195d8b0adda5aa10e95c2bc31a3206211eadda", "html_url": "https://github.com/rust-lang/rust/commit/f2195d8b0adda5aa10e95c2bc31a3206211eadda"}], "stats": {"total": 193, "additions": 133, "deletions": 60}, "files": [{"sha": "986e965e8ef78bc355d4e474eedc2a4520f32bb5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 133, "deletions": 60, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/5c7cd6419caf764bb0a78351b8e97fb68db8a352/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7cd6419caf764bb0a78351b8e97fb68db8a352/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5c7cd6419caf764bb0a78351b8e97fb68db8a352", "patch": "@@ -74,6 +74,7 @@ state type crate_ctxt = rec(session.session sess,\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n+                         mutable option.t[ValueRef] llself,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          hashmap[ast.def_id, ValueRef] lltydescs,\n@@ -283,7 +284,10 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n+fn type_of_fn_full(@crate_ctxt cx,\n+                   option.t[TypeRef] obj_self,\n+                   vec[ty.arg] inputs,\n+                   @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = vec(T_taskptr());\n \n     auto fn_ty = ty.plain_ty(ty.ty_fn(inputs, output));\n@@ -294,6 +298,14 @@ fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n         i += 1u;\n     }\n \n+    alt (obj_self) {\n+        case (some[TypeRef](?t)) {\n+            check (t as int != 0);\n+            atys += t;\n+        }\n+        case (_) { }\n+    }\n+\n     for (ty.arg arg in inputs) {\n         let TypeRef t = type_of(cx, arg.ty);\n         alt (arg.mode) {\n@@ -315,6 +327,10 @@ fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n     ret T_fn(atys, ret_ty);\n }\n \n+fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n+    ret type_of_fn_full(cx, none[TypeRef], inputs, output);\n+}\n+\n fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     alt (t.struct) {\n         case (ty.ty_nil) { ret T_nil(); }\n@@ -364,16 +380,25 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             ret type_of_fn(cx, args, out);\n         }\n         case (ty.ty_obj(?meths)) {\n+            auto th = mk_type_handle();\n+            auto self_ty = llvm.LLVMResolveTypeHandle(th.llth);\n+\n             let vec[TypeRef] mtys = vec();\n             for (ty.method m in meths) {\n-                let TypeRef mty = type_of_fn(cx, m.inputs, m.output);\n+                let TypeRef mty =\n+                    type_of_fn_full(cx,\n+                                    some[TypeRef](self_ty),\n+                                    m.inputs, m.output);\n                 mtys += T_ptr(mty);\n             }\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair =\n                 T_struct(vec(T_ptr(vtbl),\n                              T_ptr(T_box(T_nil()))));\n-            ret pair;\n+            auto abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n+            llvm.LLVMRefineType(abs_pair, pair);\n+            abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n+            ret abs_pair;\n         }\n         case (ty.ty_var(_)) {\n             log \"ty_var in trans.type_of\";\n@@ -1092,7 +1117,6 @@ fn build_memcpy(@block_ctxt cx,\n     //   lib.llvm.llvm.LLVMAlignOf(llty);\n     // but this makes it upset because it's not a constant.\n \n-    log \"building memcpy\";\n     auto volatile = C_integral(0, T_i1());\n     ret res(cx, cx.build.Call(memcpy,\n                               vec(dst_ptr, src_ptr,\n@@ -1605,44 +1629,51 @@ impure fn trans_alt(@block_ctxt cx, @ast.expr expr, vec[ast.arm] arms)\n     ret res(last_cx, C_nil());\n }\n \n-// The additional bool returned indicates whether it's mem (that is\n-// represented as an alloca or heap, hence needs a 'load' to be used as an\n-// immediate).\n+type lval_result = rec(result res,\n+                       bool is_mem,\n+                       option.t[ValueRef] llobj);\n+\n+fn lval_mem(@block_ctxt cx, ValueRef val) -> lval_result {\n+    ret rec(res=res(cx, val),\n+            is_mem=true,\n+            llobj=none[ValueRef]);\n+}\n+\n+fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n+    ret rec(res=res(cx, val),\n+            is_mem=false,\n+            llobj=none[ValueRef]);\n+}\n \n fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n-    -> tup(result, bool) {\n+    -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n             alt (def) {\n                 case (ast.def_arg(?did)) {\n                     check (cx.fcx.llargs.contains_key(did));\n-                    ret tup(res(cx, cx.fcx.llargs.get(did)),\n-                            true);\n+                    ret lval_mem(cx, cx.fcx.llargs.get(did));\n                 }\n                 case (ast.def_local(?did)) {\n                     check (cx.fcx.lllocals.contains_key(did));\n-                    ret tup(res(cx, cx.fcx.lllocals.get(did)),\n-                            true);\n+                    ret lval_mem(cx, cx.fcx.lllocals.get(did));\n                 }\n                 case (ast.def_binding(?did)) {\n                     check (cx.fcx.lllocals.contains_key(did));\n-                    ret tup(res(cx, cx.fcx.lllocals.get(did)), true);\n+                    ret lval_mem(cx, cx.fcx.lllocals.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n                     check (cx.fcx.ccx.item_ids.contains_key(did));\n-                    ret tup(res(cx, cx.fcx.ccx.item_ids.get(did)),\n-                            false);\n+                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(did));\n                 }\n                 case (ast.def_obj(?did)) {\n                     check (cx.fcx.ccx.item_ids.contains_key(did));\n-                    ret tup(res(cx, cx.fcx.ccx.item_ids.get(did)),\n-                            false);\n+                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(did));\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     check (cx.fcx.ccx.tags.contains_key(tid));\n                     check (cx.fcx.ccx.item_ids.contains_key(vid));\n-                    ret tup(res(cx, cx.fcx.ccx.item_ids.get(vid)),\n-                            false);\n+                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(vid));\n                 }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n@@ -1657,20 +1688,21 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n }\n \n impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n-                      &ast.ident field, &ast.ann ann) -> tup(result, bool) {\n+                      &ast.ident field, &ast.ann ann) -> lval_result {\n     auto lv = trans_lval(cx, base);\n-    auto r = lv._0;\n+    auto r = lv.res;\n+    check (lv.is_mem);\n     auto t = ty.expr_ty(base);\n     alt (t.struct) {\n         case (ty.ty_tup(?fields)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n-            ret tup(res(r.bcx, v), true);\n+            ret lval_mem(r.bcx, v);\n         }\n         case (ty.ty_rec(?fields)) {\n             let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n-            ret tup(res(r.bcx, v), true);\n+            ret lval_mem(r.bcx, v);\n         }\n         case (ty.ty_obj(?methods)) {\n             let uint ix = ty.method_idx(cx.fcx.ccx.sess, sp, field, methods);\n@@ -1680,15 +1712,17 @@ impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n             vtbl = r.bcx.build.Load(vtbl);\n             auto v =  r.bcx.build.GEP(vtbl, vec(C_int(0),\n                                                 C_int(ix as int)));\n-            ret tup(res(r.bcx, v), true);\n+\n+            auto lvo = lval_mem(r.bcx, v);\n+            ret rec(llobj = some[ValueRef](r.val) with lvo);\n         }\n         case (_) { cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\"); }\n     }\n     fail;\n }\n \n impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n-                      @ast.expr idx, &ast.ann ann) -> tup(result, bool) {\n+                      @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n     auto ix = trans_expr(lv.bcx, idx);\n@@ -1718,14 +1752,14 @@ impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n \n     auto body = next_cx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_data)));\n     auto elt = next_cx.build.GEP(body, vec(C_int(0), ix.val));\n-    ret tup(res(next_cx, elt), true);\n+    ret lval_mem(next_cx, elt);\n }\n \n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n \n-impure fn trans_lval(@block_ctxt cx, @ast.expr e) -> tup(result, bool) {\n+impure fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     alt (e.node) {\n         case (ast.expr_name(?n, ?dopt, _)) {\n             ret trans_name(cx, n, dopt);\n@@ -1773,7 +1807,8 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n \n-impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @ty.t fn_ty)\n+impure fn trans_args(@block_ctxt cx, option.t[ValueRef] llobj,\n+                     &vec[@ast.expr] es, @ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n@@ -1784,6 +1819,16 @@ impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @ty.t fn_ty)\n         case (_) { fail; }\n     }\n \n+    alt (llobj) {\n+        case (some[ValueRef](?ob)) {\n+            // Every object is always found in memory,\n+            // and not-yet-loaded (as part of an lval x.y\n+            // doted method-call).\n+            vs += cx.build.Load(ob);\n+        }\n+        case (_) { }\n+    }\n+\n     auto i = 0u;\n     for (@ast.expr e in es) {\n         auto mode = args.(i).mode;\n@@ -1798,21 +1843,23 @@ impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @ty.t fn_ty)\n             }\n         } else {\n             if (mode == ast.alias) {\n-                let tup(result, bool /* is a pointer? */) pair;\n+                let lval_result lv;\n                 if (ty.is_lval(e)) {\n-                    pair = trans_lval(bcx, e);\n+                    lv = trans_lval(bcx, e);\n                 } else {\n-                    pair = tup(trans_expr(bcx, e), false);\n+                    auto r = trans_expr(bcx, e);\n+                    lv = lval_val(r.bcx, r.val);\n                 }\n \n-                if (!pair._1) {\n-                    // Have to synthesize a pointer here...\n-                    auto llty = val_ty(pair._0.val);\n-                    auto llptr = pair._0.bcx.build.Alloca(llty);\n-                    pair._0.bcx.build.Store(pair._0.val, llptr);\n-                    re = res(pair._0.bcx, llptr);\n+                if (!lv.is_mem) {\n+                    // Non-mem but we're trying to alias; synthesize an\n+                    // alloca, spill to it and pass its address.\n+                    auto llty = val_ty(lv.res.val);\n+                    auto llptr = lv.res.bcx.build.Alloca(llty);\n+                    lv.res.bcx.build.Store(lv.res.val, llptr);\n+                    re = res(lv.res.bcx, llptr);\n                 } else {\n-                    re = pair._0;\n+                    re = lv.res;\n                 }\n             } else {\n                 re = trans_expr(bcx, e);\n@@ -1831,13 +1878,13 @@ impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @ty.t fn_ty)\n impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                      vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n-    auto faddr = f_res._0.val;\n-    if (f_res._1) {\n-        faddr = f_res._0.bcx.build.Load(faddr);\n+    auto faddr = f_res.res.val;\n+    if (f_res.is_mem) {\n+        faddr = f_res.res.bcx.build.Load(faddr);\n     }\n     auto fn_ty = ty.expr_ty(f);\n     auto ret_ty = ty.ann_to_type(ann);\n-    auto args_res = trans_args(f_res._0.bcx, args, fn_ty);\n+    auto args_res = trans_args(f_res.res.bcx, f_res.llobj, args, fn_ty);\n \n     auto real_retval = args_res._0.build.FastCall(faddr, args_res._1);\n     auto retval;\n@@ -1987,23 +2034,23 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n         case (ast.expr_assign(?dst, ?src, ?ann)) {\n             auto lhs_res = trans_lval(cx, dst);\n-            check (lhs_res._1);\n-            auto rhs_res = trans_expr(lhs_res._0.bcx, src);\n+            check (lhs_res.is_mem);\n+            auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n-            ret copy_ty(rhs_res.bcx, false, lhs_res._0.val, rhs_res.val, t);\n+            ret copy_ty(rhs_res.bcx, false, lhs_res.res.val, rhs_res.val, t);\n         }\n \n         case (ast.expr_assign_op(?op, ?dst, ?src, ?ann)) {\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n-            check (lhs_res._1);\n-            auto lhs_val = load_non_structural(lhs_res._0.bcx,\n-                                               lhs_res._0.val, t);\n-            auto rhs_res = trans_expr(lhs_res._0.bcx, src);\n+            check (lhs_res.is_mem);\n+            auto lhs_val = load_non_structural(lhs_res.res.bcx,\n+                                               lhs_res.res.val, t);\n+            auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto v = trans_eager_binop(rhs_res.bcx, op, lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n-            ret copy_ty(rhs_res.bcx, false, lhs_res._0.val, v, t);\n+            ret copy_ty(rhs_res.bcx, false, lhs_res.res.val, v, t);\n         }\n \n         case (ast.expr_call(?f, ?args, ?ann)) {\n@@ -2032,8 +2079,8 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         case (_) {\n             auto t = ty.expr_ty(e);\n             auto sub = trans_lval(cx, e);\n-            ret res(sub._0.bcx,\n-                    load_non_structural(sub._0.bcx, sub._0.val, t));\n+            ret res(sub.res.bcx,\n+                    load_non_structural(sub.res.bcx, sub.res.val, t));\n         }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n@@ -2327,23 +2374,37 @@ fn new_fn_ctxt(@crate_ctxt cx,\n \n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n+             mutable llself=none[ValueRef],\n              llargs=llargs,\n              lllocals=lllocals,\n              lltydescs=lltydescs,\n              ccx=cx);\n }\n \n \n-fn create_llargs_for_fn_args(&@fn_ctxt cx, &vec[ast.arg] args,\n+fn create_llargs_for_fn_args(&@fn_ctxt cx,\n+                             option.t[TypeRef] ty_self,\n+                             &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n     let uint arg_n = 1u;\n+\n     for (ast.ty_param tp in ty_params) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n         check (llarg as int != 0);\n         cx.lltydescs.insert(tp.id, llarg);\n         arg_n += 1u;\n     }\n \n+    alt (ty_self) {\n+        case (some[TypeRef](_)) {\n+            auto llself = llvm.LLVMGetParam(cx.llfn, arg_n);\n+            check (llself as int != 0);\n+            cx.llself = some[ValueRef](llself);\n+            arg_n += 1u;\n+        }\n+        case (_) { }\n+    }\n+\n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n         check (llarg as int != 0);\n@@ -2406,7 +2467,7 @@ impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, f.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, none[TypeRef], f.inputs, ty_params);\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n@@ -2420,12 +2481,21 @@ impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     }\n }\n \n-impure fn trans_vtbl(@crate_ctxt cx, &ast._obj ob,\n+impure fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n+                     &ast._obj ob,\n                      &vec[ast.ty_param] ty_params) -> ValueRef {\n     let vec[ValueRef] methods = vec();\n     for (@ast.method m in ob.methods) {\n \n-        auto llfnty = node_type(cx, m.node.ann);\n+        auto llfnty = T_nil();\n+        alt (node_ann_type(cx, m.node.ann).struct) {\n+            case (ty.ty_fn(?inputs, ?output)) {\n+                llfnty = type_of_fn_full(cx,\n+                                         some[TypeRef](self_ty),\n+                                         inputs, output);\n+            }\n+        }\n+\n         let str s = cx.names.next(\"_rust_method\") + \".\" + cx.path;\n         let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfnty);\n         cx.item_ids.insert(m.node.id, llfn);\n@@ -2458,15 +2528,17 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     }\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llctor_decl);\n-    create_llargs_for_fn_args(fcx, fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, none[TypeRef],\n+                              fn_args, ty_params);\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n     let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n     copy_args_to_allocas(bcx, fn_args, arg_tys);\n \n-    auto pair = bcx.build.Alloca(type_of(cx, ret_ty_of_fn(ann)));\n-    auto vtbl = trans_vtbl(cx, ob, ty_params);\n+    auto llself_ty = type_of(cx, ret_ty_of_fn(ann));\n+    auto pair = bcx.build.Alloca(llself_ty);\n+    auto vtbl = trans_vtbl(cx, llself_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    vec(C_int(0),\n                                        C_int(abi.obj_field_vtbl)));\n@@ -2564,7 +2636,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, none[TypeRef], fn_args, ty_params);\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n@@ -2829,6 +2901,7 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n+                    mutable llself=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     lltydescs=new_def_hash[ValueRef](),"}]}