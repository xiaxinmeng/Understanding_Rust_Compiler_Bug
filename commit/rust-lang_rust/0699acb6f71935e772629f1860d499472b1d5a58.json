{"sha": "0699acb6f71935e772629f1860d499472b1d5a58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OTlhY2I2ZjcxOTM1ZTc3MjYyOWYxODYwZDQ5OTQ3MmIxZDVhNTg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T10:21:32Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T11:09:45Z"}, "message": "Rudimentary checking of safe alias returns", "tree": {"sha": "8e2abd831f9fe51e96233dc75efdcf5c924e87ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e2abd831f9fe51e96233dc75efdcf5c924e87ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0699acb6f71935e772629f1860d499472b1d5a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0699acb6f71935e772629f1860d499472b1d5a58", "html_url": "https://github.com/rust-lang/rust/commit/0699acb6f71935e772629f1860d499472b1d5a58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0699acb6f71935e772629f1860d499472b1d5a58/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "html_url": "https://github.com/rust-lang/rust/commit/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b"}], "stats": {"total": 79, "additions": 52, "deletions": 27}, "files": [{"sha": "630c1636d70ca8e865a5d043e90aa09335437873", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0699acb6f71935e772629f1860d499472b1d5a58/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0699acb6f71935e772629f1860d499472b1d5a58/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=0699acb6f71935e772629f1860d499472b1d5a58", "patch": "@@ -22,7 +22,7 @@ type binding = @{node_id: node_id,\n                  unsafe_tys: [ty::t],\n                  mutable ok: valid,\n                  mutable copied: copied};\n-type scope = [binding]; // {bs: [binding], ret_style: ast::ret_style}\n+type scope = {bs: [binding], ret_style: ast::ret_style};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n               unsafe: [ty::t]) -> binding {\n@@ -47,25 +47,32 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> copy_map {\n                local_map: std::map::new_int_hash(),\n                mutable next_local: 0u,\n                copy_map: std::map::new_int_hash()};\n-    let v = @{visit_fn: visit_fn,\n+    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_decl: bind visit_decl(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    visit::visit_crate(*crate, [], visit::mk_vt(v));\n+    visit::visit_crate(*crate, {bs: [], ret_style: ast::return_val},\n+                       visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret cx.copy_map;\n }\n \n-fn visit_fn(f: ast::_fn, _tp: [ast::ty_param], _sp: span, _name: fn_ident,\n-            _id: ast::node_id, sc: scope, v: vt<scope>) {\n+fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], _sp: span,\n+            _name: fn_ident, _id: ast::node_id, sc: scope, v: vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    let scope = alt f.proto {\n+    let bs = alt f.proto {\n       // Blocks need to obey any restrictions from the enclosing scope.\n-      ast::proto_block. | ast::proto_closure. { sc }\n+      ast::proto_block. | ast::proto_closure. { sc.bs }\n       // Non capturing functions start out fresh.\n       _ { [] }\n     };\n-    v.visit_block(f.body, scope, v);\n+    if f.decl.cf == ast::return_ref && !is_none(f.body.node.expr) {\n+        // FIXME this will be easier to lift once have DPS\n+        cx.tcx.sess.span_err(option::get(f.body.node.expr).span,\n+                             \"reference-returning functions may not \" +\n+                             \"return implicitly\");\n+    }\n+    v.visit_block(f.body, {bs: bs, ret_style: f.decl.cf}, v);\n }\n \n fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n@@ -111,7 +118,9 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         check_assign(cx, dest, src, sc, v);\n       }\n       ast::expr_ret(oexpr) {\n-        \n+        if sc.ret_style == ast::return_ref && !is_none(oexpr) {\n+            check_ret_ref(*cx, option::get(oexpr));\n+        }\n         handled = false;\n       }\n       _ { handled = false; }\n@@ -256,12 +265,33 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     ret bindings;\n }\n \n+fn check_ret_ref(cx: ctx, expr: @ast::expr) {\n+    let root = expr_root(cx.tcx, expr, false);\n+    let bad = none;\n+    alt path_def(cx, root.ex) {\n+      none. { bad = some(\"temporary\"); }\n+      some(ast::def_arg(_, mode)) {\n+        if mode == ast::by_move { bad = some(\"move-mode parameter\"); }\n+        if mut_field(root.ds) { bad = some(\"mutable field\"); }\n+      }\n+      // FIXME allow references to constants and static items?\n+      _ { bad = some(\"non-argument value\"); }\n+    }\n+    alt bad {\n+      some(name) {\n+        cx.tcx.sess.span_err(expr.span, \"can not return a reference \" +\n+                             \"to a \" + name);\n+      }\n+      _ {}\n+    }\n+}\n+\n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n              v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n     let root = expr_root(cx.tcx, input, true);\n     for a: ast::arm in arms {\n-        let new_sc = sc;\n+        let new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n         let pat_id_map = ast_util::pat_id_map(a.pats[0]);\n         type info = {id: node_id, mutable unsafe: [ty::t], span: span};\n@@ -283,11 +313,11 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n             }\n         }\n         for info in binding_info {\n-            new_sc += [mk_binding(cx, info.id, info.span, root_var,\n-                                  info.unsafe)];\n+            new_bs += [mk_binding(cx, info.id, info.span, root_var,\n+                                  copy info.unsafe)];\n         }\n         register_locals(cx, a.pats[0]);\n-        visit::visit_arm(a, new_sc, v);\n+        visit::visit_arm(a, {bs: new_bs with sc}, v);\n     }\n }\n \n@@ -296,13 +326,13 @@ fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n     v.visit_expr(call, sc, v);\n     alt call.node {\n       ast::expr_call(f, args) {\n-        let new_sc = sc + check_call(cx, f, args);\n+        let new_bs = sc.bs + check_call(cx, f, args);\n         for proot in *pattern_roots(cx.tcx, [], local.node.pat) {\n-            new_sc += [mk_binding(cx, proot.id, proot.span, none,\n+            new_bs += [mk_binding(cx, proot.id, proot.span, none,\n                                   inner_mut(proot.ds))];\n         }\n         register_locals(cx, local.node.pat);\n-        visit::visit_block(blk, new_sc, v);\n+        visit::visit_block(blk, {bs: new_bs with sc}, v);\n       }\n     }\n }\n@@ -324,13 +354,13 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n       _ {}\n     }\n     let root_var = path_def_id(cx, root.ex);\n-    let new_sc = sc;\n+    let new_bs = sc.bs;\n     for proot in *pattern_roots(cx.tcx, ext_ds, local.node.pat) {\n-        new_sc += [mk_binding(cx, proot.id, proot.span, root_var,\n+        new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n                               inner_mut(proot.ds))];\n     }\n     register_locals(cx, local.node.pat);\n-    visit::visit_block(blk, new_sc, v);\n+    visit::visit_block(blk, {bs: new_bs with sc}, v);\n }\n \n fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n@@ -341,7 +371,7 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n     let my_local_id =\n         alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n-    for b in sc {\n+    for b in sc.bs {\n         // excludes variables introduced since the alias was made\n         if my_local_id < b.local_id {\n             for ty in b.unsafe_tys {\n@@ -360,7 +390,7 @@ fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n         let dnum = ast_util::def_id_of_def(def).node;\n-        for b in sc {\n+        for b in sc.bs {\n             if b.root_var == some(dnum) { b.ok = overwritten(dest.span, p); }\n         }\n       }\n@@ -378,7 +408,7 @@ fn test_scope(cx: ctx, sc: scope, b: binding, p: ast::path) {\n     let prob = b.ok;\n     alt b.root_var {\n       some(dn) {\n-        for other in sc {\n+        for other in sc.bs {\n             if other.node_id == dn {\n                 prob = other.ok;\n                 if prob != valid { break; }\n@@ -461,11 +491,6 @@ fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n             ret true;\n           }\n           ty::ty_obj(_) { ret true; }\n-\n-\n-\n-\n-\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be"}]}