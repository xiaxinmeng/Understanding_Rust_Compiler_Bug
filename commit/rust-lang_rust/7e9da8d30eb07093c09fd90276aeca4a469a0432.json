{"sha": "7e9da8d30eb07093c09fd90276aeca4a469a0432", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOWRhOGQzMGViMDcwOTNjMDlmZDkwMjc2YWVjYTRhNDY5YTA0MzI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-05-08T16:20:51Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-05-29T22:01:52Z"}, "message": "Add `measureme` integration for profiling the interpreted program\n\nThis PR uses the `measureme` crate to profile the call stack of the\nprogram being interpreted by Miri. This is accomplished by starting a\nmeasureme 'event' when we enter a function call, and ending the event\nwhen we exit the call. The `measureme` tooling can be used to produce a\ncall stack from the generated profile data.\n\nLimitations:\n* We currently record every single entry/exit. This might generate very\n  large profile outputs for programs with a large number of function\n  calls. In follow-up work, we might want to explore sampling (e.g. only\n  recording every N function calls).\n* This does not integrate very well with Miri's concurrency support.\n  Each event we record starts when we push a frame, and ends when we pop\n  a frame. As a result, switching between virtual threads will cause\n  events from different threads to be interleaved. Additionally, the\n  recorded for a particular frame will include all of the work Miri does\n  before that frame completes, including executing another thread.\n\nThe `measureme` integration is off by default, and must be enabled via\n`-Zmiri-measureme=<output_name>`", "tree": {"sha": "1ab9fcadf147c4af29057df77fb7c0e1c5bda87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab9fcadf147c4af29057df77fb7c0e1c5bda87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e9da8d30eb07093c09fd90276aeca4a469a0432", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmCyudIACgkQtAh+UQ6Y\nsWQyEA/8DOtPVFOCZT1vgUvSZ9I5JXUleXhkCyroX+IYhHPcBQQU9FtCWfr9bsUL\n2eZNuDJ1bBGjAJNiXguc9EQDiYfmO7i+dHjxYAR9q+41iTfiPSIjq7qKOcTvShVn\n4DWPaEcHXoJspVJegIePW7Ku6U+isMxQUmQp/1BvhdZsn3OWhmA6es9mpyAuVnGY\nTvSf2AZWS4aF3gc+rdITNPg36Y2RuQkzTZNJrUD3adPw09YEFrQoZwEYnAZtJYVH\n4g6vhiHcAjMRhShFjLc9PoJBqfjJCRgQXHiVFgiydwm5K4p3GDk/gE4DPx//OTJ6\n1Kf7kZ2MMpQPz5plzoTjRg6tlcQFBB7i+SCl3c8zCWqSCgk22Fuj2p1tZopaiftE\nLs/pD/er3SaJY5cMXS88u6q0mTbBWT/Z1l5cTCBSqCyOC4fCEa91Y/VLoUvfKr3m\nbQfwuhnvT3PUFsCy/cFtoRQ+STqReuMAt7f7ExusE+WG19XSXAeqR7TgZ1S6VrD8\nfydVPXKa3QkCXoRW64Qk+sLGlM9jlK4ZtzE5TacgJsLWtHi2sMje5KYpBx+NZ8MP\nTZCuCi8yYhsCwdPJzYpHf/DIsIyX5ZyHhCwHsy8XiVB7xn32NPYY+3Io7SCuOLRQ\nNaeL5HLM3h1REJ5ot/kr8ctYGLF2h2iuejImOciZ9yS0QNoNZRQ=\n=Mltc\n-----END PGP SIGNATURE-----", "payload": "tree 1ab9fcadf147c4af29057df77fb7c0e1c5bda87b\nparent 4fa9363ebba236f7c29ae11180db6051d7d2ce3b\nauthor Aaron Hill <aa1ronham@gmail.com> 1620490851 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1622325712 -0500\n\nAdd `measureme` integration for profiling the interpreted program\n\nThis PR uses the `measureme` crate to profile the call stack of the\nprogram being interpreted by Miri. This is accomplished by starting a\nmeasureme 'event' when we enter a function call, and ending the event\nwhen we exit the call. The `measureme` tooling can be used to produce a\ncall stack from the generated profile data.\n\nLimitations:\n* We currently record every single entry/exit. This might generate very\n  large profile outputs for programs with a large number of function\n  calls. In follow-up work, we might want to explore sampling (e.g. only\n  recording every N function calls).\n* This does not integrate very well with Miri's concurrency support.\n  Each event we record starts when we push a frame, and ends when we pop\n  a frame. As a result, switching between virtual threads will cause\n  events from different threads to be interleaved. Additionally, the\n  recorded for a particular frame will include all of the work Miri does\n  before that frame completes, including executing another thread.\n\nThe `measureme` integration is off by default, and must be enabled via\n`-Zmiri-measureme=<output_name>`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9da8d30eb07093c09fd90276aeca4a469a0432", "html_url": "https://github.com/rust-lang/rust/commit/7e9da8d30eb07093c09fd90276aeca4a469a0432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e9da8d30eb07093c09fd90276aeca4a469a0432/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa9363ebba236f7c29ae11180db6051d7d2ce3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa9363ebba236f7c29ae11180db6051d7d2ce3b", "html_url": "https://github.com/rust-lang/rust/commit/4fa9363ebba236f7c29ae11180db6051d7d2ce3b"}], "stats": {"total": 153, "additions": 143, "deletions": 10}, "files": [{"sha": "3ae2700321805dab81844b1e087171adf08cdee3", "filename": "Cargo.lock", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -167,6 +167,15 @@ version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n+[[package]]\n+name = \"instant\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61124eeebbd69b8190558df225adf7e4caafce0d743919e5d6b19652314ec5ec\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"0.4.7\"\n@@ -185,6 +194,15 @@ version = \"0.2.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"56d855069fafbb9b344c0f962150cd2c1187975cb1c22c1522c240d8c4986714\"\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a3c91c24eae6777794bb1997ad98bbb87daf92890acab859f7eaa4320333176\"\n+dependencies = [\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.14\"\n@@ -194,12 +212,34 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"measureme\"\n+version = \"9.1.1\"\n+source = \"git+https://github.com/rust-lang/measureme?rev=501d6a3c192beee5e633a6c5f79130bedfdadcb5#501d6a3c192beee5e633a6c5f79130bedfdadcb5\"\n+dependencies = [\n+ \"log\",\n+ \"memmap2\",\n+ \"parking_lot\",\n+ \"perf-event-open-sys\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0ee1c47aaa256ecabcaea351eae4a9b01ef39ed810004e298d2511ed284b1525\"\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"397d1a6d6d0563c0f5462bbdae662cf6c784edf5e828e40c7257f85d82bf56dd\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"miow\"\n version = \"0.3.7\"\n@@ -220,6 +260,7 @@ dependencies = [\n  \"hex\",\n  \"libc\",\n  \"log\",\n+ \"measureme\",\n  \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -237,6 +278,40 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.11.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d7744ac029df22dca6284efe4e898991d28e3085c706c972bcd7da4a27a15eb\"\n+dependencies = [\n+ \"instant\",\n+ \"lock_api\",\n+ \"parking_lot_core\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.8.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fa7a782938e745763fe6907fc6ba86946d72f49fe7e21de074e08128a99fb018\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"instant\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"perf-event-open-sys\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce9bedf5da2c234fdf2391ede2b90fabf585355f33100689bc364a3ea558561a\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"pest\"\n version = \"2.1.3\"\n@@ -355,6 +430,12 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n@@ -394,6 +475,12 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n+\n [[package]]\n name = \"semver\"\n version = \"0.11.0\""}, {"sha": "fd212e43047eb0369ca25119e7670320ff1af52a", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -18,6 +18,7 @@ test = false # we have no unit tests\n doctest = false # and no doc tests\n \n [dependencies]\n+measureme = { git = \"https://github.com/rust-lang/measureme\", rev = \"501d6a3c192beee5e633a6c5f79130bedfdadcb5\" }\n getrandom = { version = \"0.2\", features = [\"std\"] }\n env_logger = \"0.8\"\n log = \"0.4\""}, {"sha": "87f6b87c6626949b82d57e7ca2a471a69bd9ac62", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -258,6 +258,10 @@ environment variable:\n   this pointer. Note that it is not currently guaranteed that code that works\n   with `-Zmiri-track-raw-pointers` also works without\n   `-Zmiri-track-raw-pointers`, but for the vast majority of code, this will be the case.\n+* `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n+   This can be used to find which parts of your program are executing slowly under Miri.\n+   The profile is written out to a file with the prefix `<name>`, and can be processed\n+   using the tools in the repository https://github.com/rust-lang/measureme\n \n Some native rustc `-Z` flags are also very relevant for Miri:\n "}, {"sha": "47cde5c353e133ba708cdc447b1dd0b8b8872bd4", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -318,6 +318,10 @@ fn main() {\n                     };\n                     miri_config.cmpxchg_weak_failure_rate = rate;\n                 }\n+                arg if arg.starts_with(\"-Zmiri-measureme=\") => {\n+                    let measureme_out = arg.strip_prefix(\"-Zmiri-measureme=\").unwrap();\n+                    miri_config.measureme_out = Some(measureme_out.to_string());\n+                }\n                 _ => {\n                     // Forward to rustc.\n                     rustc_args.push(arg);"}, {"sha": "a5268b58a2d12c296515a250f3d07f312c167ccb", "filename": "src/eval.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -54,6 +54,9 @@ pub struct MiriConfig {\n     /// Rate of spurious failures for compare_exchange_weak atomic operations,\n     /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n     pub cmpxchg_weak_failure_rate: f64,\n+    /// If `Some`, enable the `measureme` profiler, writing results to the specified\n+    /// directory.\n+    pub measureme_out: Option<String>,\n }\n \n impl Default for MiriConfig {\n@@ -73,6 +76,7 @@ impl Default for MiriConfig {\n             track_raw: false,\n             data_race_detector: true,\n             cmpxchg_weak_failure_rate: 0.8,\n+            measureme_out: None,\n         }\n     }\n }\n@@ -92,7 +96,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx,\n         rustc_span::source_map::DUMMY_SP,\n         param_env,\n-        Evaluator::new(config.communicate, config.validate, layout_cx),\n+        Evaluator::new(&config, layout_cx),\n         MemoryExtra::new(&config),\n     );\n     // Complete initialization."}, {"sha": "77c606a83f47ab288ae37e86df720d5b4a170ac3", "filename": "src/machine.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -10,6 +10,8 @@ use std::time::Instant;\n use log::trace;\n use rand::rngs::StdRng;\n use rand::SeedableRng;\n+use std::collections::hash_map::Entry;\n+use measureme::{Profiler, StringId, EventId, DetachedTiming};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::{\n@@ -34,7 +36,6 @@ pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n /// Extra data stored with each stack frame\n-#[derive(Debug)]\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n     pub call_id: stacked_borrows::CallId,\n@@ -43,6 +44,8 @@ pub struct FrameData<'tcx> {\n     /// called by `try`). When this frame is popped during unwinding a panic,\n     /// we stop unwinding, use the `CatchUnwindData` to handle catching.\n     pub catch_unwind: Option<CatchUnwindData<'tcx>>,\n+\n+    pub timing: Option<DetachedTiming>,\n }\n \n /// Extra memory kinds\n@@ -270,16 +273,21 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Allocations that are considered roots of static memory (that may leak).\n     pub(crate) static_roots: Vec<AllocId>,\n+\n+    profiler: Option<Profiler>,\n+    string_cache: FxHashMap<String, StringId>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     pub(crate) fn new(\n-        communicate: bool,\n-        validate: bool,\n+        config: &MiriConfig,\n         layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n     ) -> Self {\n         let layouts =\n             PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n+        let profiler = config.measureme_out.as_ref().map(|out| {\n+            Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n+        });\n         Evaluator {\n             // `env_vars` could be initialized properly here if `Memory` were available before\n             // calling this method.\n@@ -288,14 +296,16 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             argv: None,\n             cmd_line: None,\n             tls: TlsData::default(),\n-            communicate,\n-            validate,\n+            communicate: config.communicate,\n+            validate: config.validate,\n             file_handler: Default::default(),\n             dir_handler: Default::default(),\n             time_anchor: Instant::now(),\n             layouts,\n             threads: ThreadManager::default(),\n             static_roots: Vec::new(),\n+            profiler,\n+            string_cache: Default::default(),\n         }\n     }\n }\n@@ -601,7 +611,26 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n             stacked_borrows.borrow_mut().new_call()\n         });\n-        let extra = FrameData { call_id, catch_unwind: None };\n+        let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            let fn_name = frame.instance.to_string();\n+            let entry = ecx.machine.string_cache.entry(fn_name.clone());\n+            let name = match entry {\n+                Entry::Occupied(e) => *e.get(),\n+                Entry::Vacant(e) => {\n+                    *e.insert(profiler.alloc_string(&*fn_name))\n+                }\n+            };\n+\n+            Some(profiler.start_recording_interval_event_detached(\n+                name,\n+                EventId::from_label(name),\n+                0\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        let extra = FrameData { call_id, catch_unwind: None, timing };\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -625,10 +654,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n+        mut frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n-        ecx.handle_stack_pop(frame.extra, unwinding)\n+        let timing = frame.extra.timing.take();\n+        let res = ecx.handle_stack_pop(frame.extra, unwinding);\n+        if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            profiler.finish_recording_interval_event(timing.unwrap());\n+        }\n+        res\n     }\n \n     #[inline(always)]"}, {"sha": "6b08ee8e18404e11216e77904de499f4835f2fbe", "filename": "src/shims/panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9da8d30eb07093c09fd90276aeca4a469a0432/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=7e9da8d30eb07093c09fd90276aeca4a469a0432", "patch": "@@ -119,7 +119,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let this = self.eval_context_mut();\n \n-        trace!(\"handle_stack_pop(extra = {:?}, unwinding = {})\", extra, unwinding);\n         if let Some(stacked_borrows) = &this.memory.extra.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(extra.call_id);\n         }"}]}