{"sha": "e833e037834102c829dadeff0069b9219efc047b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MzNlMDM3ODM0MTAyYzgyOWRhZGVmZjAwNjliOTIxOWVmYzA0N2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-23T21:48:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-23T21:48:45Z"}, "message": "Merge #3954\n\n3954: Improve autocompletion by looking on the type and name r=matklad a=bnjjj\n\nThis tweet (https://twitter.com/tjholowaychuk/status/1248918374731714560) gaves me the idea to implement that in rust-analyzer.\r\n\r\nBasically for this first example I made some examples when we are in a function call definition. I look on the parameter list to prioritize autocompletions for the same types and if it's the same type + the same name then it's displayed first in the completion list.\r\n\r\nSo here is a draft, first step to open a discussion and know what you think about the implementation. It works (cf tests) but maybe I can make a better implementation at some places. Be careful the code needs some refactoring to be better and concise.\r\n\r\nPS: It was lot of fun writing this haha\n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "9f264b1ddd2811da0a3a0a6fec595b7b50f94284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f264b1ddd2811da0a3a0a6fec595b7b50f94284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e833e037834102c829dadeff0069b9219efc047b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeog09CRBK7hj4Ov3rIwAAdHIIABD28pIsGq+a+JoH/j6BD4bq\njVpOQIa39+tmuNV9sygHhpoKHwKRLhB4ap+t5RrpKwxrur0NRVoOG7kZxSApfvng\nvNvn9I/dfKH7D7FJw1fsLbamC0R9QMCOGEezqf9Zi0VPArUUJHoCjyI6CLzEqef/\nCLaBLYXhF2nu0ZeKIXzFVnOcbCmG8LY+unj+QwFAVdydYx+8qBsi5X5qamaWh4ul\nvpeeLzOo5k9zyRhzsGmeNITtKDtjJDCVhY0tQdktv6O1GYk/NfZloo8d8vzbPtO5\nC7jfbvsRExo+ng00p9wi8W3/mOt/dVZK/PkXr0vz4npF/C483IWOeIZY4Pio49M=\n=0EZI\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f264b1ddd2811da0a3a0a6fec595b7b50f94284\nparent 01f1f10feccb3f4bc25d5c39b60c0d4a59e17b52\nparent da6b136ea5b0e37d3dae9b78f3dbff2f18a9e5ea\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587678525 +0000\ncommitter GitHub <noreply@github.com> 1587678525 +0000\n\nMerge #3954\n\n3954: Improve autocompletion by looking on the type and name r=matklad a=bnjjj\n\nThis tweet (https://twitter.com/tjholowaychuk/status/1248918374731714560) gaves me the idea to implement that in rust-analyzer.\r\n\r\nBasically for this first example I made some examples when we are in a function call definition. I look on the parameter list to prioritize autocompletions for the same types and if it's the same type + the same name then it's displayed first in the completion list.\r\n\r\nSo here is a draft, first step to open a discussion and know what you think about the implementation. It works (cf tests) but maybe I can make a better implementation at some places. Be careful the code needs some refactoring to be better and concise.\r\n\r\nPS: It was lot of fun writing this haha\n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e833e037834102c829dadeff0069b9219efc047b", "html_url": "https://github.com/rust-lang/rust/commit/e833e037834102c829dadeff0069b9219efc047b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e833e037834102c829dadeff0069b9219efc047b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01f1f10feccb3f4bc25d5c39b60c0d4a59e17b52", "url": "https://api.github.com/repos/rust-lang/rust/commits/01f1f10feccb3f4bc25d5c39b60c0d4a59e17b52", "html_url": "https://github.com/rust-lang/rust/commit/01f1f10feccb3f4bc25d5c39b60c0d4a59e17b52"}, {"sha": "da6b136ea5b0e37d3dae9b78f3dbff2f18a9e5ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/da6b136ea5b0e37d3dae9b78f3dbff2f18a9e5ea", "html_url": "https://github.com/rust-lang/rust/commit/da6b136ea5b0e37d3dae9b78f3dbff2f18a9e5ea"}], "stats": {"total": 452, "additions": 412, "deletions": 40}, "files": [{"sha": "19bc4321c1875ccc7d2a9439834a9ad2fd2e65cf", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -29,7 +29,7 @@ use crate::{\n };\n \n pub use crate::completion::completion_item::{\n-    CompletionItem, CompletionItemKind, InsertTextFormat,\n+    CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n };\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "44288f92e69459b117c00c315a9dc0025e96f9b5", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 235, "deletions": 2, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -2,9 +2,11 @@\n \n use hir::{HasVisibility, Type};\n \n-use crate::completion::completion_item::CompletionKind;\n use crate::{\n-    completion::{completion_context::CompletionContext, completion_item::Completions},\n+    completion::{\n+        completion_context::CompletionContext,\n+        completion_item::{CompletionKind, Completions},\n+    },\n     CompletionItem,\n };\n use rustc_hash::FxHashSet;\n@@ -103,6 +105,237 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_completion_in_func_call() {\n+        assert_debug_snapshot!(\n+        do_ref_completion(\n+                r\"\n+                struct A { another_field: i64, the_field: u32, my_string: String }\n+                fn test(my_param: u32) -> u32 { my_param }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"my_string\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"my_string\",\n+                kind: Field,\n+                detail: \"{unknown}\",\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_func_call_with_type_and_name() {\n+        assert_debug_snapshot!(\n+        do_ref_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                fn test(the_field: u32) -> u32 { the_field }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_record_lit() {\n+        assert_debug_snapshot!(\n+        do_ref_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: a.<|>\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_record_lit_and_fn_call() {\n+        assert_debug_snapshot!(\n+        do_ref_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: test(a.<|>)\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_fn_call_and_record_lit() {\n+        assert_debug_snapshot!(\n+        do_ref_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    test(B {\n+                        the_field: a.<|>\n+                    });\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_completion_self() {\n         assert_debug_snapshot!("}, {"sha": "dd7c8a873dbda7fba857a32ebaa03715603c2fa1", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -21,6 +21,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n     pub(super) offset: TextUnit,\n+    pub(super) file_position: FilePosition,\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -31,6 +32,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n     pub(super) record_lit_syntax: Option<ast::RecordLit>,\n     pub(super) record_pat_syntax: Option<ast::RecordPat>,\n+    pub(super) record_field_syntax: Option<ast::RecordField>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n@@ -88,12 +90,14 @@ impl<'a> CompletionContext<'a> {\n             original_token,\n             token,\n             offset: position.offset,\n+            file_position: position,\n             krate,\n             name_ref_syntax: None,\n             function_syntax: None,\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_pat_syntax: None,\n+            record_field_syntax: None,\n             impl_def: None,\n             is_param: false,\n             is_pat_binding_or_const: false,\n@@ -279,6 +283,14 @@ impl<'a> CompletionContext<'a> {\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n \n+        self.record_field_syntax = self\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n+            .take_while(|it| {\n+                it.kind() != SOURCE_FILE && it.kind() != MODULE && it.kind() != CALL_EXPR\n+            })\n+            .find_map(ast::RecordField::cast);\n+\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,"}, {"sha": "e17586aa5bf83a8a56ab6a41db2d97a94c35a6a5", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -51,6 +51,9 @@ pub struct CompletionItem {\n     /// If completing a function call, ask the editor to show parameter popup\n     /// after completion.\n     trigger_call_info: bool,\n+\n+    /// Score is usefull to pre select or display in better order completion items\n+    score: Option<CompletionScore>,\n }\n \n // We use custom debug for CompletionItem to make `insta`'s diffs more readable.\n@@ -80,6 +83,9 @@ impl fmt::Debug for CompletionItem {\n         if self.deprecated {\n             s.field(\"deprecated\", &true);\n         }\n+        if let Some(score) = &self.score {\n+            s.field(\"score\", score);\n+        }\n         if self.trigger_call_info {\n             s.field(\"trigger_call_info\", &true);\n         }\n@@ -147,6 +153,7 @@ impl CompletionItem {\n             text_edit: None,\n             deprecated: None,\n             trigger_call_info: None,\n+            score: None,\n         }\n     }\n     /// What user sees in pop-up in the UI.\n@@ -186,6 +193,14 @@ impl CompletionItem {\n         self.deprecated\n     }\n \n+    pub fn score(&self) -> Option<CompletionScore> {\n+        self.score.clone()\n+    }\n+\n+    pub fn set_score(&mut self, score: CompletionScore) {\n+        self.score = Some(score);\n+    }\n+\n     pub fn trigger_call_info(&self) -> bool {\n         self.trigger_call_info\n     }\n@@ -206,6 +221,7 @@ pub(crate) struct Builder {\n     text_edit: Option<TextEdit>,\n     deprecated: Option<bool>,\n     trigger_call_info: Option<bool>,\n+    score: Option<CompletionScore>,\n }\n \n impl Builder {\n@@ -235,6 +251,7 @@ impl Builder {\n             completion_kind: self.completion_kind,\n             deprecated: self.deprecated.unwrap_or(false),\n             trigger_call_info: self.trigger_call_info.unwrap_or(false),\n+            score: self.score,\n         }\n     }\n     pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n@@ -285,6 +302,11 @@ impl Builder {\n         self.deprecated = Some(deprecated);\n         self\n     }\n+    #[allow(unused)]\n+    pub(crate) fn set_score(mut self, score: CompletionScore) -> Builder {\n+        self.score = Some(score);\n+        self\n+    }\n     pub(crate) fn trigger_call_info(mut self) -> Builder {\n         self.trigger_call_info = Some(true);\n         self\n@@ -297,6 +319,14 @@ impl<'a> Into<CompletionItem> for Builder {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum CompletionScore {\n+    /// If only type match\n+    TypeMatch,\n+    /// If type and name match\n+    TypeAndNameMatch,\n+}\n+\n /// Represents an in-progress set of completions being built.\n #[derive(Debug, Default)]\n pub(crate) struct Completions {"}, {"sha": "f8dac1d54178aecc3363382d8224be267766ecb7", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -6,12 +6,13 @@ use stdx::SepBy;\n use test_utils::tested_by;\n \n use crate::{\n+    call_info::call_info,\n     completion::{\n         completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n         CompletionKind, Completions,\n     },\n     display::{const_label, macro_label, type_label, FunctionSignature},\n-    RootDatabase,\n+    CompletionScore, RootDatabase,\n };\n \n impl Completions {\n@@ -22,7 +23,7 @@ impl Completions {\n         ty: &Type,\n     ) {\n         let is_deprecated = is_deprecated(field, ctx.db);\n-        CompletionItem::new(\n+        let mut completion_item = CompletionItem::new(\n             CompletionKind::Reference,\n             ctx.source_range(),\n             field.name(ctx.db).to_string(),\n@@ -31,7 +32,11 @@ impl Completions {\n         .detail(ty.display(ctx.db).to_string())\n         .set_documentation(field.docs(ctx.db))\n         .set_deprecated(is_deprecated)\n-        .add_to(self);\n+        .build();\n+\n+        compute_score(&mut completion_item, ctx);\n+\n+        self.add(completion_item);\n     }\n \n     pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n@@ -300,6 +305,42 @@ impl Completions {\n     }\n }\n \n+pub(crate) fn compute_score(completion_item: &mut CompletionItem, ctx: &CompletionContext) {\n+    let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n+        if let Some((struct_field, _)) = ctx.sema.resolve_record_field(record_field) {\n+            (\n+                struct_field.name(ctx.db).to_string(),\n+                struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n+            )\n+        } else {\n+            return;\n+        }\n+    } else if let Some(call_info) = call_info(ctx.db, ctx.file_position) {\n+        if call_info.active_parameter_type().is_some()\n+            && call_info.active_parameter_name().is_some()\n+        {\n+            (call_info.active_parameter_name().unwrap(), call_info.active_parameter_type().unwrap())\n+        } else {\n+            return;\n+        }\n+    } else {\n+        return;\n+    };\n+\n+    // Compute score\n+    // For the same type\n+    if let Some(a_parameter_type) = completion_item.detail() {\n+        if &active_type == a_parameter_type {\n+            // If same type + same name then go top position\n+            if active_name == completion_item.label() {\n+                completion_item.set_score(CompletionScore::TypeAndNameMatch);\n+            } else {\n+                completion_item.set_score(CompletionScore::TypeMatch);\n+            }\n+        }\n+    }\n+}\n+\n enum Params {\n     Named(Vec<String>),\n     Anonymous(usize),"}, {"sha": "b5e2785fe0429a4744619b939f90fe797b87ba27", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -36,6 +36,8 @@ pub struct FunctionSignature {\n     pub parameters: Vec<String>,\n     /// Parameter names of the function\n     pub parameter_names: Vec<String>,\n+    /// Parameter types of the function\n+    pub parameter_types: Vec<String>,\n     /// Optional return type\n     pub ret_type: Option<String>,\n     /// Where predicates\n@@ -62,14 +64,20 @@ impl FunctionSignature {\n             return None;\n         };\n \n-        let params = st\n-            .fields(db)\n-            .into_iter()\n-            .map(|field: hir::StructField| {\n-                let ty = field.signature_ty(db);\n-                format!(\"{}\", ty.display(db))\n-            })\n-            .collect();\n+        let mut params = vec![];\n+        let mut parameter_types = vec![];\n+        for field in st.fields(db).into_iter() {\n+            let ty = field.signature_ty(db);\n+            let raw_param = format!(\"{}\", ty.display(db));\n+\n+            if let Some(param_type) = raw_param.split(':').nth(1) {\n+                parameter_types.push(param_type[1..].to_string());\n+            } else {\n+                // useful when you have tuple struct\n+                parameter_types.push(raw_param.clone());\n+            }\n+            params.push(raw_param);\n+        }\n \n         Some(\n             FunctionSignature {\n@@ -79,6 +87,7 @@ impl FunctionSignature {\n                 ret_type: node.name().map(|n| n.text().to_string()),\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types,\n                 generic_parameters: generic_parameters(&node),\n                 where_predicates: where_predicates(&node),\n                 doc: None,\n@@ -99,15 +108,21 @@ impl FunctionSignature {\n \n         let name = format!(\"{}::{}\", parent_name, variant.name(db));\n \n-        let params = variant\n-            .fields(db)\n-            .into_iter()\n-            .map(|field: hir::StructField| {\n-                let name = field.name(db);\n-                let ty = field.signature_ty(db);\n-                format!(\"{}: {}\", name, ty.display(db))\n-            })\n-            .collect();\n+        let mut params = vec![];\n+        let mut parameter_types = vec![];\n+        for field in variant.fields(db).into_iter() {\n+            let ty = field.signature_ty(db);\n+            let raw_param = format!(\"{}\", ty.display(db));\n+            if let Some(param_type) = raw_param.split(':').nth(1) {\n+                parameter_types.push(param_type[1..].to_string());\n+            } else {\n+                // The unwrap_or_else is useful when you have tuple\n+                parameter_types.push(raw_param);\n+            }\n+            let name = field.name(db);\n+\n+            params.push(format!(\"{}: {}\", name, ty.display(db)));\n+        }\n \n         Some(\n             FunctionSignature {\n@@ -117,6 +132,7 @@ impl FunctionSignature {\n                 ret_type: None,\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types,\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n@@ -139,6 +155,7 @@ impl FunctionSignature {\n                 ret_type: None,\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types: vec![],\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n@@ -151,18 +168,27 @@ impl FunctionSignature {\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n     fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>) {\n+        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>, Vec<String>) {\n             let mut res = vec![];\n+            let mut res_types = vec![];\n             let mut has_self_param = false;\n             if let Some(param_list) = node.param_list() {\n                 if let Some(self_param) = param_list.self_param() {\n                     has_self_param = true;\n-                    res.push(self_param.syntax().text().to_string())\n+                    let raw_param = self_param.syntax().text().to_string();\n+\n+                    res_types.push(\n+                        raw_param.split(':').nth(1).unwrap_or_else(|| \" Self\")[1..].to_string(),\n+                    );\n+                    res.push(raw_param);\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n+                res_types.extend(param_list.params().map(|param| {\n+                    param.syntax().text().to_string().split(':').nth(1).unwrap()[1..].to_string()\n+                }));\n             }\n-            (has_self_param, res)\n+            (has_self_param, res, res_types)\n         }\n \n         fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n@@ -192,7 +218,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n             res\n         }\n \n-        let (has_self_param, parameters) = param_list(node);\n+        let (has_self_param, parameters, parameter_types) = param_list(node);\n \n         FunctionSignature {\n             kind: CallableKind::Function,\n@@ -204,6 +230,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                 .map(|n| n.syntax().text().to_string()),\n             parameters,\n             parameter_names: param_name_list(node),\n+            parameter_types,\n             generic_parameters: generic_parameters(node),\n             where_predicates: where_predicates(node),\n             // docs are processed separately"}, {"sha": "ddaa30a1606b2643aa017e0e96f8b5c48a214e47", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -67,7 +67,9 @@ use crate::display::ToNav;\n pub use crate::{\n     assists::{Assist, AssistId},\n     call_hierarchy::CallItem,\n-    completion::{CompletionConfig, CompletionItem, CompletionItemKind, InsertTextFormat},\n+    completion::{\n+        CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n+    },\n     diagnostics::Severity,\n     display::{file_structure, FunctionSignature, NavigationTarget, StructureNode},\n     expand_macro::ExpandedMacro,\n@@ -127,6 +129,21 @@ pub struct CallInfo {\n     pub active_parameter: Option<usize>,\n }\n \n+impl CallInfo {\n+    pub fn active_parameter_type(&self) -> Option<String> {\n+        if let Some(id) = self.active_parameter {\n+            return self.signature.parameter_types.get(id).map(|param_ty| param_ty.clone());\n+        }\n+        None\n+    }\n+    pub fn active_parameter_name(&self) -> Option<String> {\n+        if let Some(id) = self.active_parameter {\n+            return self.signature.parameter_names.get(id).map(|param_ty| param_ty.clone());\n+        }\n+        None\n+    }\n+}\n+\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug)]\n pub struct AnalysisHost {"}, {"sha": "7e30956cc30302b504e5fa85db764b04ad793a43", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -9,10 +9,10 @@ use lsp_types::{\n     TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, WorkspaceEdit,\n };\n use ra_ide::{\n-    translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n-    InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo,\n-    ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n+    translate_offset_with_edit, CompletionItem, CompletionItemKind, CompletionScore, FileId,\n+    FilePosition, FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier,\n+    HighlightTag, InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget,\n+    RangeInfo, ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n@@ -114,31 +114,31 @@ impl Conv for Severity {\n     }\n }\n \n-impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n+impl ConvWith<(&LineIndex, LineEndings, &mut usize)> for CompletionItem {\n     type Output = ::lsp_types::CompletionItem;\n \n-    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> ::lsp_types::CompletionItem {\n+    fn conv_with(self, ctx: (&LineIndex, LineEndings, &mut usize)) -> ::lsp_types::CompletionItem {\n         let mut additional_text_edits = Vec::new();\n         let mut text_edit = None;\n         // LSP does not allow arbitrary edits in completion, so we have to do a\n         // non-trivial mapping here.\n         for atom_edit in self.text_edit().as_atoms() {\n             if self.source_range().is_subrange(&atom_edit.delete) {\n                 text_edit = Some(if atom_edit.delete == self.source_range() {\n-                    atom_edit.conv_with(ctx)\n+                    atom_edit.conv_with((ctx.0, ctx.1))\n                 } else {\n                     assert!(self.source_range().end() == atom_edit.delete.end());\n                     let range1 =\n                         TextRange::from_to(atom_edit.delete.start(), self.source_range().start());\n                     let range2 = self.source_range();\n                     let edit1 = AtomTextEdit::replace(range1, String::new());\n                     let edit2 = AtomTextEdit::replace(range2, atom_edit.insert.clone());\n-                    additional_text_edits.push(edit1.conv_with(ctx));\n-                    edit2.conv_with(ctx)\n+                    additional_text_edits.push(edit1.conv_with((ctx.0, ctx.1)));\n+                    edit2.conv_with((ctx.0, ctx.1))\n                 })\n             } else {\n                 assert!(self.source_range().intersection(&atom_edit.delete).is_none());\n-                additional_text_edits.push(atom_edit.conv_with(ctx));\n+                additional_text_edits.push(atom_edit.conv_with((ctx.0, ctx.1)));\n             }\n         }\n         let text_edit = text_edit.unwrap();\n@@ -165,6 +165,15 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n             ..Default::default()\n         };\n \n+        if let Some(score) = self.score() {\n+            match score {\n+                CompletionScore::TypeAndNameMatch => res.preselect = Some(true),\n+                CompletionScore::TypeMatch => {}\n+            }\n+            res.sort_text = Some(format!(\"{:02}\", *ctx.2));\n+            *ctx.2 += 1;\n+        }\n+\n         if self.deprecated() {\n             res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n         }"}, {"sha": "ee669f3832169130a980a7df0bb2bee75e60fc0c", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e833e037834102c829dadeff0069b9219efc047b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e833e037834102c829dadeff0069b9219efc047b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=e833e037834102c829dadeff0069b9219efc047b", "patch": "@@ -423,8 +423,11 @@ pub fn handle_completion(\n     };\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n-    let items: Vec<CompletionItem> =\n-        items.into_iter().map(|item| item.conv_with((&line_index, line_endings))).collect();\n+    let mut count_sort_text_item = 0usize;\n+    let items: Vec<CompletionItem> = items\n+        .into_iter()\n+        .map(|item| item.conv_with((&line_index, line_endings, &mut count_sort_text_item)))\n+        .collect();\n \n     Ok(Some(items.into()))\n }"}]}