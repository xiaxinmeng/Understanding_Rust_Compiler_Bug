{"sha": "39f51b31dfe917bf2bbe3f12bed5431160966625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjUxYjMxZGZlOTE3YmYyYmJlM2YxMmJlZDU0MzExNjA5NjY2MjU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-09T06:32:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-09T06:32:18Z"}, "message": "Quad counters are revealing. Move drops out-of-line, cut 200kb from rustc.", "tree": {"sha": "0e122ab268dcd0c7062fc849adf5df8b3283cfb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e122ab268dcd0c7062fc849adf5df8b3283cfb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f51b31dfe917bf2bbe3f12bed5431160966625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f51b31dfe917bf2bbe3f12bed5431160966625", "html_url": "https://github.com/rust-lang/rust/commit/39f51b31dfe917bf2bbe3f12bed5431160966625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f51b31dfe917bf2bbe3f12bed5431160966625/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef5a64e2cf8e4ee5b31c9e040867fd107692c835", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5a64e2cf8e4ee5b31c9e040867fd107692c835", "html_url": "https://github.com/rust-lang/rust/commit/ef5a64e2cf8e4ee5b31c9e040867fd107692c835"}], "stats": {"total": 271, "additions": 168, "deletions": 103}, "files": [{"sha": "d4579211c3878b268eb6e5997661e2225e79f6dd", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 168, "deletions": 103, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/39f51b31dfe917bf2bbe3f12bed5431160966625/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/39f51b31dfe917bf2bbe3f12bed5431160966625/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=39f51b31dfe917bf2bbe3f12bed5431160966625", "patch": "@@ -280,6 +280,18 @@ let trans_visitor\n     string_of_name (path_to_name cx.ctxt_curr_path)\n   in\n \n+  let should_inline_structure_helpers t =\n+    let n = 2 in\n+      match t with\n+          Ast.TY_tag ttag ->\n+            get_n_tag_tups cx ttag > n\n+        | Ast.TY_rec elts ->\n+            Array.length elts > 3\n+        | Ast.TY_tup elts ->\n+            Array.length elts > 3\n+        | _ -> false\n+  in\n+\n   let based (reg:Il.reg) : Il.mem =\n     Il.RegIn (reg, None)\n   in\n@@ -361,7 +373,9 @@ let trans_visitor\n   in\n \n   let get_element_ptr =\n-    Il.get_element_ptr word_bits abi.Abi.abi_str_of_hardreg\n+    Session.time_inner \"trans GEP\" cx.ctxt_sess\n+      (fun _ ->\n+         Il.get_element_ptr word_bits abi.Abi.abi_str_of_hardreg)\n   in\n \n   let get_variant_ptr (mem_cell:Il.cell) (i:int) : Il.cell =\n@@ -383,10 +397,12 @@ let trans_visitor\n     word_at (fp_imm frame_crate_ptr)\n \n   and crate_rel_to_ptr (rel:Il.operand) (rty:Il.referent_ty) : Il.cell =\n-    let cell = next_vreg_cell (Il.AddrTy rty) in\n-      mov cell (Il.Cell (curr_crate_ptr()));\n-      add_to cell rel;\n-      cell\n+    (in_quad_category \"crate_rel -> ptr\"\n+       (fun _ ->\n+          let cell = next_vreg_cell (Il.AddrTy rty) in\n+            mov cell (Il.Cell (curr_crate_ptr()));\n+            add_to cell rel;\n+            cell))\n \n   (* \n    * Note: alias *requires* its cell to be in memory already, and should\n@@ -648,11 +664,11 @@ let trans_visitor\n         (fun _ -> fold_ty cx fold t)\n   in\n \n-  let rec calculate_sz (ty_params:Il.cell) (size:size) : Il.operand =\n+  let rec calculate_sz_full (ty_params:Il.cell) (size:size) : Il.operand =\n     iflog (fun _ -> annotate\n              (Printf.sprintf \"calculating size %s\"\n                 (string_of_size size)));\n-    let sub_sz = calculate_sz ty_params in\n+    let sub_sz = calculate_sz_full ty_params in\n     match htab_search (emitter_size_cache()) size with\n         Some op ->\n           iflog (fun _ -> annotate\n@@ -754,6 +770,9 @@ let trans_visitor\n             htab_put (emitter_size_cache()) size res;\n             res\n \n+  and calculate_sz c s =\n+    in_quad_category \"size calc\"\n+      (fun _ -> calculate_sz_full c s)\n \n   and calculate_sz_in_current_frame (size:size) : Il.operand =\n     calculate_sz (get_ty_params_of_current_frame()) size\n@@ -1222,7 +1241,8 @@ let trans_visitor\n       (initializing:bool)\n       (lv:Ast.lval)\n       : (Il.cell * Ast.ty) =\n-    trans_lval_full initializing lv\n+    in_quad_category \"lval\"\n+      (fun _ -> trans_lval_full initializing lv)\n \n   and trans_lval_init (lv:Ast.lval) : (Il.cell * Ast.ty) =\n     trans_lval_maybe_init true lv\n@@ -1582,10 +1602,13 @@ let trans_visitor\n     let framesz = SIZE_fixup_mem_sz spill in\n       push_new_emitter_with_vregs None;\n       iflog (fun _ -> annotate \"prologue\");\n-      abi.Abi.abi_emit_fn_prologue (emitter())\n-        framesz callsz nabi_rust (upcall_fixup \"upcall_grow_task\")\n-        false cx.ctxt_sess.Session.sess_minimal;\n-      write_frame_info_ptrs None;\n+      in_native_quad_category \"prologue\"\n+        (fun _ ->\n+           abi.Abi.abi_emit_fn_prologue (emitter())\n+             framesz callsz nabi_rust (upcall_fixup \"upcall_grow_task\")\n+             false cx.ctxt_sess.Session.sess_minimal);\n+      (in_quad_category \"prologue\"\n+         (fun _ -> write_frame_info_ptrs None));\n       (* FIXME: not clear why, but checking interrupt in glue context\n        * causes many.rs to crash when run on a sufficiently large number\n        * of tasks; possibly a weird interaction with growing? *)\n@@ -1740,7 +1763,7 @@ let trans_visitor\n     let callsz = SIZE_fixed (word_n n_outgoing_args) in\n       trans_glue_frame_entry callsz spill false\n \n-  and get_mem_glue (g:glue) (inner:Il.mem -> unit) : fixup =\n+  and get_mem_glue_full (g:glue) (inner:Il.mem -> unit) : fixup =\n     match htab_search cx.ctxt_glue_code g with\n         Some code -> code.code_fixup\n       | None ->\n@@ -1766,6 +1789,9 @@ let trans_visitor\n                 fix\n           end\n \n+  and get_mem_glue g i =\n+    in_quad_category \"mem glue\" (fun _ -> get_mem_glue_full g i)\n+\n   and get_typed_mem_glue\n       (g:glue)\n       (fty:Ast.ty)\n@@ -1822,7 +1848,7 @@ let trans_visitor\n       let cell = get_element_ptr args 1 in\n         note_drop_step ty \"in drop-glue, dropping\";\n         trace_word cx.ctxt_sess.Session.sess_trace_drop cell;\n-        drop_ty ty_params (deref cell) ty;\n+        drop_ty_full true ty_params (deref cell) ty;\n         note_drop_step ty \"drop-glue complete\";\n     in\n     let ty_params_ptr = ty_params_covering ty in\n@@ -3080,19 +3106,30 @@ let trans_visitor\n     iter_ty_parts_full ty_params cell cell ty\n       (fun _ src_cell ty -> f src_cell ty)\n \n-  and drop_ty\n+  and drop_ty tp c t =\n+    (in_quad_category \"drop\" (fun _ -> drop_ty_normal tp c t))\n+\n+  and drop_ty_normal tp c t =\n+    drop_ty_full false tp c t\n+\n+  and drop_ty_full\n+      (force_inline:bool)\n       (ty_params:Il.cell)\n       (cell:Il.cell)\n       (ty:Ast.ty)\n       : unit =\n \n     let mctrl = ty_mem_ctrl cx ty in\n     let ty = strip_mutable_or_constrained_ty ty in\n+    let call_out_of_line _ =\n+      trans_call_simple_static_glue (get_drop_glue ty)\n+        ty_params [| alias cell |] None;\n+    in\n \n       match ty with\n \n           Ast.TY_fn _\n-        | Ast.TY_obj _ ->\n+        | Ast.TY_obj _ when force_inline ->\n             note_drop_step ty \"drop_ty: obj/fn path\";\n             let box_ptr =\n               get_element_ptr cell Abi.binding_field_bound_data\n@@ -3148,8 +3185,11 @@ let trans_visitor\n               patch null_jmp;\n               note_drop_step ty \"drop_ty: done obj path\";\n \n+        | Ast.TY_fn _\n+        | Ast.TY_obj _ ->\n+            call_out_of_line()\n \n-      | Ast.TY_param (i, _) ->\n+        | Ast.TY_param (i, _) ->\n           note_drop_step ty \"drop_ty: parametric-ty path\";\n           aliasing false cell\n             begin\n@@ -3163,51 +3203,61 @@ let trans_visitor\n             end;\n           note_drop_step ty \"drop_ty: done parametric-ty path\";\n \n-      | _ ->\n-          match mctrl with\n-              MEM_gc\n-            | MEM_rc_opaque\n-            | MEM_rc_struct ->\n+        | _ ->\n+            match mctrl with\n+                MEM_gc\n+              | MEM_rc_opaque\n+              | MEM_rc_struct when force_inline ->\n \n-                note_drop_step ty \"drop_ty: box-drop path\";\n+                  note_drop_step ty \"drop_ty: box-drop path\";\n \n-                let _ = check_box_rty cell in\n-                let null_jmp = null_check cell in\n-                let j = drop_refcount_and_cmp cell in\n+                  let _ = check_box_rty cell in\n+                  let null_jmp = null_check cell in\n+                  let j = drop_refcount_and_cmp cell in\n \n-                  (* FIXME (issue #25): check to see that the box has\n-                   * further box members; if it doesn't we can elide the\n-                   * call to the glue function.  *)\n+                    (* FIXME (issue #25): check to see that the box has\n+                     * further box members; if it doesn't we can elide the\n+                     * call to the glue function.  *)\n \n-                  trans_call_simple_static_glue\n-                    (get_free_glue ty (mctrl = MEM_gc))\n-                    ty_params\n-                    [| cell |]\n-                    None;\n+                    trans_call_simple_static_glue\n+                      (get_free_glue ty (mctrl = MEM_gc))\n+                      ty_params\n+                      [| cell |]\n+                      None;\n+\n+                    (* Null the slot out to prevent double-free if the frame\n+                     * unwinds.  *)\n+                    mov cell zero;\n+                    patch j;\n+                    patch null_jmp;\n+                    note_drop_step ty \"drop_ty: done box-drop path\";\n+\n+              | MEM_gc\n+              | MEM_rc_opaque\n+              | MEM_rc_struct ->\n+                  call_out_of_line()\n+\n+              | MEM_interior\n+                  when type_points_to_heap cx ty ||\n+                    (n_used_type_params cx ty > 0) ->\n+                  begin\n+                    note_drop_step ty\n+                      \"drop_ty possibly-heap-referencing path\";\n+                    if force_inline || should_inline_structure_helpers ty\n+                    then iter_ty_parts ty_params cell ty\n+                      (drop_ty ty_params)\n+                    else\n+                      call_out_of_line();\n \n-                  (* Null the slot out to prevent double-free if the frame\n-                   * unwinds.\n-                   *)\n-                  mov cell zero;\n-                  patch j;\n-                  patch null_jmp;\n-                  note_drop_step ty \"drop_ty: done box-drop path\";\n-\n-            | MEM_interior\n-                when type_points_to_heap cx ty ||\n-                  (n_used_type_params cx ty > 0) ->\n-                note_drop_step ty \"drop_ty possibly-heap-referencing path\";\n-                iter_ty_parts ty_params cell ty\n-                  (drop_ty ty_params);\n-                note_drop_step ty\n-                  \"drop_ty: done possibly-heap-referencing path\";\n-\n-            | MEM_interior ->\n-                note_drop_step ty \"drop_ty: no-op simple-interior path\";\n-                (* Interior allocation of all-interior value not caught above:\n-                 * nothing to do.\n-                 *)\n-                ()\n+                    note_drop_step ty\n+                      \"drop_ty: done possibly-heap-referencing path\";\n+                  end\n+\n+              | MEM_interior ->\n+                  note_drop_step ty \"drop_ty: no-op simple-interior path\";\n+                  (* Interior allocation of all-interior value not caught\n+                   * above: nothing to do.  *)\n+                  ()\n \n   and sever_ty\n       (ty_params:Il.cell)\n@@ -3414,42 +3464,54 @@ let trans_visitor\n    * the null case (i.e. fall-through means not null).\n    *)\n   and null_check (cell:Il.cell) : quad_idx =\n-    emit (Il.cmp (Il.Cell cell) zero);\n-    let j = mark() in\n-      emit (Il.jmp Il.JE Il.CodeNone);\n-      j\n+    in_quad_category \"null check\"\n+      begin\n+        fun _ ->\n+          emit (Il.cmp (Il.Cell cell) zero);\n+          let j = mark() in\n+            emit (Il.jmp Il.JE Il.CodeNone);\n+            j\n+      end\n \n   (* Returns a mark for a jmp that must be patched to the continuation of\n    * the non-zero refcount case (i.e. fall-through means zero refcount).\n    *)\n   and drop_refcount_and_cmp (boxed:Il.cell) : quad_idx =\n-    iflog (fun _ -> annotate \"drop refcount and maybe free\");\n-    let rc = box_rc_cell boxed in\n-    if cx.ctxt_sess.Session.sess_trace_gc ||\n-      cx.ctxt_sess.Session.sess_trace_drop\n-    then\n+    in_quad_category \"drop refcnt + free\"\n       begin\n-        trace_str true \"refcount--\";\n-        trace_word true boxed;\n-        trace_word true rc\n-      end;\n-    emit (Il.binary Il.SUB rc (Il.Cell rc) one);\n-    emit (Il.cmp (Il.Cell rc) zero);\n-    let j = mark () in\n-      emit (Il.jmp Il.JNE Il.CodeNone);\n-      j\n+        fun _ ->\n+          iflog (fun _ -> annotate \"drop refcount and maybe free\");\n+          let rc = box_rc_cell boxed in\n+            if cx.ctxt_sess.Session.sess_trace_gc ||\n+              cx.ctxt_sess.Session.sess_trace_drop\n+            then\n+              begin\n+                trace_str true \"refcount--\";\n+                trace_word true boxed;\n+                trace_word true rc\n+              end;\n+            emit (Il.binary Il.SUB rc (Il.Cell rc) one);\n+            emit (Il.cmp (Il.Cell rc) zero);\n+            let j = mark () in\n+              emit (Il.jmp Il.JNE Il.CodeNone);\n+              j\n+      end\n \n   and incr_refcount (boxed:Il.cell) : unit =\n-    let rc = box_rc_cell boxed in\n-      if cx.ctxt_sess.Session.sess_trace_gc ||\n-        cx.ctxt_sess.Session.sess_trace_drop\n-      then\n-        begin\n-          trace_str true \"refcount++\";\n-          trace_word true boxed;\n-          trace_word true rc\n-        end;\n-      add_to rc one\n+    in_quad_category \"incr refcnt\"\n+      begin\n+        fun _ ->\n+          let rc = box_rc_cell boxed in\n+            if cx.ctxt_sess.Session.sess_trace_gc ||\n+              cx.ctxt_sess.Session.sess_trace_drop\n+            then\n+              begin\n+                trace_str true \"refcount++\";\n+                trace_word true boxed;\n+                trace_word true rc\n+              end;\n+            add_to rc one\n+      end\n \n   and drop_slot\n       (ty_params:Il.cell)\n@@ -3615,24 +3677,27 @@ let trans_visitor\n               (cell_str dst) (cell_str src);\n         end;\n       assert (simplified_ty src_ty = simplified_ty dst_ty);\n-      match (ty_mem_ctrl cx src_ty, ty_mem_ctrl cx dst_ty) with\n-\n-        | (MEM_rc_opaque, MEM_rc_opaque)\n-        | (MEM_gc, MEM_gc)\n-        | (MEM_rc_struct, MEM_rc_struct) ->\n-            (* Lightweight copy: twiddle refcounts, move pointer. *)\n-            anno \"refcounted light\";\n-            incr_refcount src;\n-            if not initializing\n-            then\n-              drop_ty ty_params dst dst_ty;\n-            mov dst (Il.Cell src)\n+      in_quad_category \"copy\"\n+        begin\n+          fun _ ->\n+            match (ty_mem_ctrl cx src_ty, ty_mem_ctrl cx dst_ty) with\n+                (MEM_rc_opaque, MEM_rc_opaque)\n+              | (MEM_gc, MEM_gc)\n+              | (MEM_rc_struct, MEM_rc_struct) ->\n+                  (* Lightweight copy: twiddle refcounts, move pointer. *)\n+                  anno \"refcounted light\";\n+                  incr_refcount src;\n+                  if not initializing\n+                  then\n+                    drop_ty ty_params dst dst_ty;\n+                  mov dst (Il.Cell src)\n \n-        | _ ->\n-            (* Heavyweight copy: duplicate 1 level of the referent. *)\n-            anno \"heavy\";\n-            trans_copy_ty_heavy ty_params initializing\n-              dst dst_ty src src_ty\n+              | _ ->\n+                  (* Heavyweight copy: duplicate 1 level of the referent. *)\n+                  anno \"heavy\";\n+                  trans_copy_ty_heavy ty_params initializing\n+                    dst dst_ty src src_ty\n+        end\n \n   (* NB: heavyweight copying here does not mean \"producing a deep\n    * clone of the entire data tree rooted at the src operand\". It means\n@@ -6084,7 +6149,7 @@ let fixup_assigning_visitor\n \n   let visit_crate_pre c =\n     enter_file_for c.id;\n-    inner.Walk.visit_crate_pre c\n+    inner.Walk.visit_crate_pre c;\n   in\n \n   { inner with"}]}