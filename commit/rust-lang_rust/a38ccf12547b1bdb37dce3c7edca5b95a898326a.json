{"sha": "a38ccf12547b1bdb37dce3c7edca5b95a898326a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOGNjZjEyNTQ3YjFiZGIzN2RjZTNjN2VkY2E1Yjk1YTg5ODMyNmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-13T21:41:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-13T21:41:18Z"}, "message": "rustc: Thread the use site around in ast_ty_to_ty", "tree": {"sha": "fd1bdabb628d4e14e50bb6442814f5f51388a8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1bdabb628d4e14e50bb6442814f5f51388a8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a38ccf12547b1bdb37dce3c7edca5b95a898326a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a38ccf12547b1bdb37dce3c7edca5b95a898326a", "html_url": "https://github.com/rust-lang/rust/commit/a38ccf12547b1bdb37dce3c7edca5b95a898326a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a38ccf12547b1bdb37dce3c7edca5b95a898326a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0837a6ba04bd3cf8330901678dc38b6f2c953f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/0837a6ba04bd3cf8330901678dc38b6f2c953f20", "html_url": "https://github.com/rust-lang/rust/commit/0837a6ba04bd3cf8330901678dc38b6f2c953f20"}], "stats": {"total": 287, "additions": 152, "deletions": 135}, "files": [{"sha": "8341c8f2e7b37cca9adbf30cfbba860512c51872", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 152, "deletions": 135, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/a38ccf12547b1bdb37dce3c7edca5b95a898326a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38ccf12547b1bdb37dce3c7edca5b95a898326a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=a38ccf12547b1bdb37dce3c7edca5b95a898326a", "patch": "@@ -247,8 +247,9 @@ enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n-    fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n-        -> ty::ty_param_bounds_and_ty {\n+    fn getter(tcx: ty::ctxt, _use_site: ast::node_id, mode: mode,\n+              id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        // FIXME (pcwalton): Doesn't work with region inference.\n         alt mode {\n           m_check | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n           m_collect {\n@@ -269,23 +270,14 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n         }\n     }\n-    alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n-      some(ty::atttce_resolved(ty)) { ret ty; }\n-      some(ty::atttce_unresolved) {\n-        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n-                                          insert a enum in the cycle, \\\n-                                          if this is desired)\");\n-      }\n-      some(ty::atttce_has_regions) | none { /* go on */ }\n-    }\n-\n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n-    fn ast_mt_to_mt(tcx: ty::ctxt, mode: mode, mt: ast::mt) -> ty::mt {\n-        ret {ty: ast_ty_to_ty(tcx, mode, mt.ty), mutbl: mt.mutbl};\n+    fn ast_mt_to_mt(tcx: ty::ctxt, use_site: ast::node_id, mode: mode,\n+                    mt: ast::mt) -> ty::mt {\n+        ret {ty: do_ast_ty_to_ty(tcx, use_site, mode, mt.ty),\n+             mutbl: mt.mutbl};\n     }\n-    fn instantiate(tcx: ty::ctxt, sp: span, mode: mode,\n-                   id: ast::def_id, args: [@ast::ty]) -> ty::t {\n-        let ty_param_bounds_and_ty = getter(tcx, mode, id);\n+    fn instantiate(tcx: ty::ctxt, use_site: ast::node_id, sp: span,\n+                   mode: mode, id: ast::def_id, args: [@ast::ty]) -> ty::t {\n+        let ty_param_bounds_and_ty = getter(tcx, use_site, mode, id);\n         if vec::len(*ty_param_bounds_and_ty.bounds) == 0u {\n             ret ty_param_bounds_and_ty.ty;\n         }\n@@ -297,142 +289,167 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                      polymorphic type\");\n         }\n         for ast_ty: @ast::ty in args {\n-            param_bindings += [ast_ty_to_ty(tcx, mode, ast_ty)];\n+            param_bindings += [do_ast_ty_to_ty(tcx, use_site, mode, ast_ty)];\n         }\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n                                        ty_param_bounds_and_ty.ty);\n         ret typ;\n     }\n-    let typ = alt ast_ty.node {\n-      ast::ty_nil { ty::mk_nil(tcx) }\n-      ast::ty_bot { ty::mk_bot(tcx) }\n-      ast::ty_box(mt) {\n-        ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt))\n-      }\n-      ast::ty_uniq(mt) {\n-        ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt))\n-      }\n-      ast::ty_vec(mt) {\n-        ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt))\n-      }\n-      ast::ty_ptr(mt) {\n-        ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n-      }\n-      ast::ty_rptr(region, mt) {\n-        let region = alt region.node {\n-            ast::re_inferred | ast::re_self {\n-                tcx.region_map.ast_type_to_inferred_region.get(ast_ty.id)\n-            }\n-            ast::re_named(_) {\n-                tcx.region_map.ast_type_to_region.get(region.id)\n-            }\n-        };\n-        ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n-      }\n-      ast::ty_tup(fields) {\n-        let flds = vec::map(fields, bind ast_ty_to_ty(tcx, mode, _));\n-        ty::mk_tup(tcx, flds)\n-      }\n-      ast::ty_rec(fields) {\n-        let flds: [field] = [];\n-        for f: ast::ty_field in fields {\n-            let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n-            flds += [{ident: f.node.ident, mt: tm}];\n-        }\n-        ty::mk_rec(tcx, flds)\n-      }\n-      ast::ty_fn(proto, decl) {\n-        ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl))\n-      }\n-      ast::ty_path(path, id) {\n-        let a_def = alt tcx.def_map.find(id) {\n-          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n-                                                   path_to_str(path))); }\n-          some(d) { d }};\n-        alt a_def {\n-          ast::def_ty(id) {\n-            instantiate(tcx, ast_ty.span, mode, id, path.node.types)\n-          }\n-          ast::def_prim_ty(nty) {\n-            alt nty {\n-              ast::ty_bool { ty::mk_bool(tcx) }\n-              ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n-              ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n-              ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n-              ast::ty_str { ty::mk_str(tcx) }\n-            }\n+    fn do_ast_ty_to_ty(tcx: ty::ctxt, use_site: ast::node_id, mode: mode,\n+                       &&ast_ty: @ast::ty) -> ty::t {\n+        alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n+          some(ty::atttce_resolved(ty)) { ret ty; }\n+          some(ty::atttce_unresolved) {\n+            tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n+                                              insert a enum in the cycle, \\\n+                                              if this is desired)\");\n+          }\n+          some(ty::atttce_has_regions) | none { /* go on */ }\n+        }\n+\n+        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n+        let typ = alt ast_ty.node {\n+          ast::ty_nil { ty::mk_nil(tcx) }\n+          ast::ty_bot { ty::mk_bot(tcx) }\n+          ast::ty_box(mt) {\n+            ty::mk_box(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n           }\n-          ast::def_ty_param(id, n) {\n-            if vec::len(path.node.types) > 0u {\n-                tcx.sess.span_err(ast_ty.span, \"provided type parameters to \\\n-                                                a type parameter\");\n+          ast::ty_uniq(mt) {\n+            ty::mk_uniq(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+          }\n+          ast::ty_vec(mt) {\n+            ty::mk_vec(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+          }\n+          ast::ty_ptr(mt) {\n+            ty::mk_ptr(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+          }\n+          ast::ty_rptr(region, mt) {\n+            let region = alt region.node {\n+                ast::re_inferred | ast::re_self {\n+                    tcx.region_map.ast_type_to_inferred_region.get(ast_ty.id)\n+                }\n+                ast::re_named(_) {\n+                    tcx.region_map.ast_type_to_region.get(region.id)\n+                }\n+            };\n+            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, use_site, mode, mt))\n+          }\n+          ast::ty_tup(fields) {\n+            let flds = vec::map(fields,\n+                                bind do_ast_ty_to_ty(tcx, use_site, mode, _));\n+            ty::mk_tup(tcx, flds)\n+          }\n+          ast::ty_rec(fields) {\n+            let flds: [field] = [];\n+            for f: ast::ty_field in fields {\n+                let tm = ast_mt_to_mt(tcx, use_site, mode, f.node.mt);\n+                flds += [{ident: f.node.ident, mt: tm}];\n             }\n-            ty::mk_param(tcx, n, id)\n-          }\n-          ast::def_self(self_id) {\n-            alt check tcx.items.get(self_id) {\n-              ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n-                if vec::len(tps) != vec::len(path.node.types) {\n-                    tcx.sess.span_err(ast_ty.span, \"incorrect number of type \\\n-                                                    parameter to self type\");\n+            ty::mk_rec(tcx, flds)\n+          }\n+          ast::ty_fn(proto, decl) {\n+            ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl))\n+          }\n+          ast::ty_path(path, id) {\n+            let a_def = alt tcx.def_map.find(id) {\n+              none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n+                                                       path_to_str(path))); }\n+              some(d) { d }};\n+            alt a_def {\n+              ast::def_ty(id) {\n+                instantiate(tcx, use_site, ast_ty.span, mode, id,\n+                            path.node.types)\n+              }\n+              ast::def_prim_ty(nty) {\n+                alt nty {\n+                  ast::ty_bool { ty::mk_bool(tcx) }\n+                  ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n+                  ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n+                  ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n+                  ast::ty_str { ty::mk_str(tcx) }\n                 }\n-                ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n-                    ast_ty_to_ty(tcx, mode, ast_ty)\n-                }))\n               }\n-            }\n-          }\n-          ast::def_class(class_id) {\n-              alt tcx.items.find(class_id.node) {\n-                 some(ast_map::node_item(\n-                  @{node: ast::item_class(tps, _, _), _}, _)) {\n-                     if vec::len(tps) != vec::len(path.node.types) {\n+              ast::def_ty_param(id, n) {\n+                if vec::len(path.node.types) > 0u {\n+                    tcx.sess.span_err(ast_ty.span, \"provided type parameters \\\n+                                                    to a type parameter\");\n+                }\n+                ty::mk_param(tcx, n, id)\n+              }\n+              ast::def_self(self_id) {\n+                alt check tcx.items.get(self_id) {\n+                  ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n+                    if vec::len(tps) != vec::len(path.node.types) {\n                         tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n-                           type parameters to object type\");\n+                                                        type parameters to \\\n+                                                        self type\");\n+                    }\n+                    ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n+                        do_ast_ty_to_ty(tcx, use_site, mode, ast_ty)\n+                    }))\n+                  }\n+                }\n+              }\n+              ast::def_class(class_id) {\n+                  alt tcx.items.find(class_id.node) {\n+                     some(ast_map::node_item(\n+                      @{node: ast::item_class(tps, _, _), _}, _)) {\n+                         if vec::len(tps) != vec::len(path.node.types) {\n+                            tcx.sess.span_err(ast_ty.span, \"incorrect number \\\n+                               of type parameters to object type\");\n+                         }\n+                         ty::mk_class(tcx, class_id,\n+                                      vec::map(path.node.types, {|ast_ty|\n+                                                    do_ast_ty_to_ty(tcx,\n+                                                                    use_site,\n+                                                                    mode,\n+                                                                    ast_ty)\n+                                               }))\n                      }\n-                     ty::mk_class(tcx, class_id, vec::map(path.node.types,\n-                        {|ast_ty| ast_ty_to_ty(tcx, mode, ast_ty)}))\n-                 }\n-                 _ {\n-                     tcx.sess.span_bug(ast_ty.span, \"class id is unbound \\\n-                       in items\");\n-                 }\n+                     _ {\n+                         tcx.sess.span_bug(ast_ty.span, \"class id is unbound \\\n+                           in items\");\n+                     }\n+                  }\n               }\n+              _ {\n+                tcx.sess.span_fatal(ast_ty.span,\n+                                    \"found type name used as a variable\");\n+              }\n+            }\n           }\n-          _ {\n-            tcx.sess.span_fatal(ast_ty.span,\n-                                \"found type name used as a variable\");\n+          ast::ty_constr(t, cs) {\n+            let out_cs = [];\n+            for constr: @ast::ty_constr in cs {\n+                out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n+            }\n+            ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, use_site, mode, t),\n+                          out_cs)\n+          }\n+          ast::ty_infer {\n+            alt mode {\n+              m_check_tyvar(fcx) { ret next_ty_var(fcx); }\n+              _ { tcx.sess.span_bug(ast_ty.span,\n+                                    \"found `ty_infer` in unexpected place\"); }\n+            }\n           }\n+          ast::ty_mac(_) {\n+              tcx.sess.span_bug(ast_ty.span,\n+                                    \"found `ty_mac` in unexpected place\");\n+          }\n+        };\n+\n+        if ty::type_has_rptrs(typ) {\n+            tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_has_regions);\n+        } else {\n+            tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n         }\n-      }\n-      ast::ty_constr(t, cs) {\n-        let out_cs = [];\n-        for constr: @ast::ty_constr in cs {\n-            out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n-        }\n-        ty::mk_constr(tcx, ast_ty_to_ty(tcx, mode, t), out_cs)\n-      }\n-      ast::ty_infer {\n-        alt mode {\n-          m_check_tyvar(fcx) { ret next_ty_var(fcx); }\n-          _ { tcx.sess.span_bug(ast_ty.span,\n-                                \"found `ty_infer` in unexpected place\"); }\n-        }\n-      }\n-      ast::ty_mac(_) {\n-          tcx.sess.span_bug(ast_ty.span,\n-                                \"found `ty_mac` in unexpected place\");\n-      }\n-    };\n \n-    if ty::type_has_rptrs(typ) {\n-        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_has_regions);\n-    } else {\n-        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n+        ret typ;\n     }\n \n-    ret typ;\n+    ret do_ast_ty_to_ty(tcx, ast_ty.id, mode, ast_ty);\n }\n \n fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)"}]}