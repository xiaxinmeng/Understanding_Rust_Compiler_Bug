{"sha": "298728ed652fd48583c563eddb1707b392e7a18b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODcyOGVkNjUyZmQ0ODU4M2M1NjNlZGRiMTcwN2IzOTJlN2ExOGI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-30T13:26:35Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-30T13:26:35Z"}, "message": "Merge pull request #258 from birkenfeld/collect-exhaust\n\nnew lint: using collect() to just exhaust an iterator", "tree": {"sha": "470c1d393bdcaad8ec756a69947dc8d943b38d3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/470c1d393bdcaad8ec756a69947dc8d943b38d3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298728ed652fd48583c563eddb1707b392e7a18b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298728ed652fd48583c563eddb1707b392e7a18b", "html_url": "https://github.com/rust-lang/rust/commit/298728ed652fd48583c563eddb1707b392e7a18b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298728ed652fd48583c563eddb1707b392e7a18b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92563a99703ad11d3b5dbc7eb804728a5cb11223", "url": "https://api.github.com/repos/rust-lang/rust/commits/92563a99703ad11d3b5dbc7eb804728a5cb11223", "html_url": "https://github.com/rust-lang/rust/commit/92563a99703ad11d3b5dbc7eb804728a5cb11223"}, {"sha": "16df79a0549ba44afdfcecfbb3cbb210d2a7863f", "url": "https://api.github.com/repos/rust-lang/rust/commits/16df79a0549ba44afdfcecfbb3cbb210d2a7863f", "html_url": "https://github.com/rust-lang/rust/commit/16df79a0549ba44afdfcecfbb3cbb210d2a7863f"}], "stats": {"total": 169, "additions": 154, "deletions": 15}, "files": [{"sha": "4d5c59f2aefd7ede2e56f49e5f26bffbdc2c3ad8", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 49 lints included in this crate:\n+There are 51 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -56,6 +56,8 @@ name\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                 | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n [unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+[unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                     | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n+[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n [zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                 | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!"}, {"sha": "5e9205e32f9cbce500d08383f2ecc9d67dd05cba", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -96,6 +96,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        loops::UNUSED_COLLECT,\n+        loops::WHILE_LET_LOOP,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,"}, {"sha": "fe901794d6cf8a7021c7c38daa479935bebaba74", "filename": "src/loops.rs", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -4,7 +4,8 @@ use syntax::visit::{Visitor, walk_expr};\n use rustc::middle::ty;\n use std::collections::HashSet;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, walk_ptrs_ty};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, walk_ptrs_ty,\n+            in_external_macro, expr_block, span_help_and_lint};\n use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n@@ -16,12 +17,20 @@ declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n                \"for-looping over `_.next()` which is probably not intended\" }\n \n+declare_lint!{ pub WHILE_LET_LOOP, Warn,\n+               \"`loop { if let { ... } else break }` can be written as a `while let` loop\" }\n+\n+declare_lint!{ pub UNUSED_COLLECT, Warn,\n+               \"`collect()`ing an iterator without using the result; this is usually better \\\n+                written as a for loop\" }\n+\n #[derive(Copy, Clone)]\n pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP)\n+        lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n+                    WHILE_LET_LOOP, UNUSED_COLLECT)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -36,7 +45,8 @@ impl LintPass for LoopsPass {\n                     walk_expr(&mut visitor, body);\n                     // linting condition: we only indexed one variable\n                     if visitor.indexed.len() == 1 {\n-                        let indexed = visitor.indexed.into_iter().next().expect(\"Len was nonzero, but no contents found\");\n+                        let indexed = visitor.indexed.into_iter().next().expect(\n+                            \"Len was nonzero, but no contents found\");\n                         if visitor.nonindex {\n                             span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n                                 \"the loop variable `{}` is used to index `{}`. Consider using \\\n@@ -77,6 +87,48 @@ impl LintPass for LoopsPass {\n                 }\n             }\n         }\n+        // check for `loop { if let {} else break }` that could be `while let`\n+        // (also matches explicit \"match\" instead of \"if let\")\n+        if let ExprLoop(ref block, _) = expr.node {\n+            // extract a single expression\n+            if let Some(inner) = extract_single_expr(block) {\n+                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                    // ensure \"if let\" compatible match structure\n+                    match *source {\n+                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => if\n+                            arms.len() == 2 &&\n+                            arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                            arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                            // finally, check for \"break\" in the second clause\n+                            is_break_expr(&arms[1].body)\n+                        {\n+                            if in_external_macro(cx, expr.span) { return; }\n+                            span_help_and_lint(cx, WHILE_LET_LOOP, expr.span,\n+                                               \"this loop could be written as a `while let` loop\",\n+                                               &format!(\"try\\nwhile let {} = {} {}\",\n+                                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                        snippet(cx, matchexpr.span, \"..\"),\n+                                                        expr_block(cx, &arms[0].body, \"..\")));\n+                        },\n+                        _ => ()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, stmt: &Stmt) {\n+        if let StmtSemi(ref expr, _) = stmt.node {\n+            if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+                if args.len() == 1 && method.node.name == \"collect\" {\n+                    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+                        span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n+                            \"you are collect()ing an iterator and throwing away the result. \\\n+                             Consider using an explicit for loop to exhaust the iterator\"));\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -158,3 +210,28 @@ fn is_array(ty: ty::Ty) -> bool {\n         _ => false\n     }\n }\n+\n+/// If block consists of a single expression (with or without semicolon), return it.\n+fn extract_single_expr(block: &Block) -> Option<&Expr> {\n+    match (&block.stmts.len(), &block.expr) {\n+        (&1, &None) => match block.stmts[0].node {\n+            StmtExpr(ref expr, _) |\n+            StmtSemi(ref expr, _) => Some(expr),\n+            _ => None,\n+        },\n+        (&0, &Some(ref expr)) => Some(expr),\n+        _ => None\n+    }\n+}\n+\n+/// Return true if expr contains a single break expr (maybe within a block).\n+fn is_break_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprBreak(None) => true,\n+        ExprBlock(ref b) => match extract_single_expr(b) {\n+            Some(ref subexpr) => is_break_expr(subexpr),\n+            None => false,\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "3d04c9210ce6ce6d659330dc7a418c9892e11318", "filename": "src/matches.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -1,10 +1,8 @@\n use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n-use std::borrow::Cow;\n \n-use utils::{snippet, snippet_block};\n-use utils::{span_lint, span_help_and_lint, in_external_macro};\n+use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n \n declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n@@ -38,21 +36,14 @@ impl LintPass for MatchPass {\n                 is_unit_expr(&arms[1].body)\n             {\n                 if in_external_macro(cx, expr.span) {return;}\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n                 span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n                       \"you seem to be trying to use match for \\\n                       destructuring a single pattern. Did you mean to \\\n                       use `if let`?\",\n                       &format!(\"try\\nif let {} = {} {}\",\n                                snippet(cx, arms[0].pats[0].span, \"..\"),\n                                snippet(cx, ex.span, \"..\"),\n-                               body_code)\n-                );\n+                               expr_block(cx, &arms[0].body, \"..\")));\n             }\n \n             // check preconditions for MATCH_REF_PATS"}, {"sha": "f16387f606db61d55525fd668419bd9571c07238", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -103,6 +103,16 @@ pub fn snippet_block<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a,\n     trim_multiline(snip, true)\n }\n \n+/// Like snippet_block, but add braces if the expr is not an ExprBlock\n+pub fn expr_block<'a>(cx: &Context, expr: &Expr, default: &'a str) -> Cow<'a, str> {\n+    let code = snippet_block(cx, expr.span, default);\n+    if let ExprBlock(_) = expr.node {\n+        code\n+    } else {\n+        Cow::Owned(format!(\"{{ {} }}\", code))\n+    }\n+}\n+\n /// Trim indentation from a multiline string\n /// with possibility of ignoring the first line\n pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {"}, {"sha": "6683865135619cfb12543298668c122cc55df701", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -15,6 +15,7 @@ impl Unrelated {\n }\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop)]\n+#[deny(unused_collect)]\n #[allow(linkedlist)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n@@ -56,4 +57,8 @@ fn main() {\n     let u = Unrelated(vec![]);\n     for _v in u.next() { } // no error\n     for _v in u.iter() { } // no error\n+\n+    let mut out = vec![];\n+    vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); //~ERROR you are collect()ing an iterator\n+    let _y = vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n }"}, {"sha": "bc09168fad039bae561155672d478bf535bf2202", "filename": "tests/compile-fail/while_loop.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/298728ed652fd48583c563eddb1707b392e7a18b/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298728ed652fd48583c563eddb1707b392e7a18b/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=298728ed652fd48583c563eddb1707b392e7a18b", "patch": "@@ -0,0 +1,52 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(while_let_loop)]\n+fn main() {\n+    let y = Some(true);\n+    loop { //~ERROR\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        } else {\n+            break;\n+        }\n+    }\n+    loop { //~ERROR\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        } else {\n+            break\n+        }\n+    }\n+    loop { // no error, break is not in else clause\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        }\n+        break;\n+    }\n+    loop { //~ERROR\n+        match y {\n+            Some(_x) => true,\n+            None => break\n+        };\n+    }\n+    loop { // no error, match is not the only statement\n+        match y {\n+            Some(_x) => true,\n+            None => break\n+        };\n+        let _x = 1;\n+    }\n+    loop { // no error, else branch does something other than break\n+        match y {\n+            Some(_x) => true,\n+            _ => {\n+                let _z = 1;\n+                break;\n+            }\n+        };\n+    }\n+    while let Some(x) = y { // no error, obviously\n+        println!(\"{}\", x);\n+    }\n+}"}]}