{"sha": "a45682ed96f18f962ac403419b4d143d59ba5283", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NTY4MmVkOTZmMThmOTYyYWM0MDM0MTliNGQxNDNkNTliYTUyODM=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-22T06:23:43Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "Move iteration over all files into the SSR crate\n\nThe methods `edits_for_file` and `find_matches_in_file` are replaced with just `edits` and `matches`. This simplifies the API a bit, but more importantly it makes it possible in a subsequent commit for SSR to decide to not search all files.", "tree": {"sha": "5f2178b2957b2e7cfddac94ec1748edb3dd19f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f2178b2957b2e7cfddac94ec1748edb3dd19f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a45682ed96f18f962ac403419b4d143d59ba5283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a45682ed96f18f962ac403419b4d143d59ba5283", "html_url": "https://github.com/rust-lang/rust/commit/a45682ed96f18f962ac403419b4d143d59ba5283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a45682ed96f18f962ac403419b4d143d59ba5283/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13f901f636846e330699a4414059591ec2e67cd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/13f901f636846e330699a4414059591ec2e67cd1", "html_url": "https://github.com/rust-lang/rust/commit/13f901f636846e330699a4414059591ec2e67cd1"}], "stats": {"total": 181, "additions": 92, "deletions": 89}, "files": [{"sha": "ca7e0ad866baa511be5a878efeec07fa338f6da4", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -1,5 +1,4 @@\n-use ra_db::SourceDatabaseExt;\n-use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n+use ra_ide_db::RootDatabase;\n \n use crate::SourceFileEdit;\n use ra_ssr::{MatchFinder, SsrError, SsrRule};\n@@ -44,20 +43,11 @@ pub fn parse_search_replace(\n     parse_only: bool,\n     db: &RootDatabase,\n ) -> Result<Vec<SourceFileEdit>, SsrError> {\n-    let mut edits = vec![];\n     let rule: SsrRule = rule.parse()?;\n     if parse_only {\n-        return Ok(edits);\n+        return Ok(Vec::new());\n     }\n     let mut match_finder = MatchFinder::new(db);\n     match_finder.add_rule(rule);\n-    for &root in db.local_roots().iter() {\n-        let sr = db.source_root(root);\n-        for file_id in sr.iter() {\n-            if let Some(edit) = match_finder.edits_for_file(file_id) {\n-                edits.push(SourceFileEdit { file_id, edit });\n-            }\n-        }\n-    }\n-    Ok(edits)\n+    Ok(match_finder.edits())\n }"}, {"sha": "7b640980628b31066841052e8ba0dc92a69bbbee", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -17,8 +17,9 @@ pub use crate::matching::Match;\n use crate::matching::MatchFailureReason;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n+use ra_ide_db::source_change::SourceFileEdit;\n use ra_syntax::{ast, AstNode, SyntaxNode, TextRange};\n-use ra_text_edit::TextEdit;\n+use rustc_hash::FxHashMap;\n \n // A structured search replace rule. Create by calling `parse` on a str.\n #[derive(Debug)]\n@@ -60,32 +61,37 @@ impl<'db> MatchFinder<'db> {\n         self.add_parsed_rules(rule.parsed_rules);\n     }\n \n+    /// Finds matches for all added rules and returns edits for all found matches.\n+    pub fn edits(&self) -> Vec<SourceFileEdit> {\n+        use ra_db::SourceDatabaseExt;\n+        let mut matches_by_file = FxHashMap::default();\n+        for m in self.matches().matches {\n+            matches_by_file\n+                .entry(m.range.file_id)\n+                .or_insert_with(|| SsrMatches::default())\n+                .matches\n+                .push(m);\n+        }\n+        let mut edits = vec![];\n+        for (file_id, matches) in matches_by_file {\n+            let edit =\n+                replacing::matches_to_edit(&matches, &self.sema.db.file_text(file_id), &self.rules);\n+            edits.push(SourceFileEdit { file_id, edit });\n+        }\n+        edits\n+    }\n+\n     /// Adds a search pattern. For use if you intend to only call `find_matches_in_file`. If you\n     /// intend to do replacement, use `add_rule` instead.\n     pub fn add_search_pattern(&mut self, pattern: SsrPattern) {\n         self.add_parsed_rules(pattern.parsed_rules);\n     }\n \n-    pub fn edits_for_file(&self, file_id: FileId) -> Option<TextEdit> {\n-        let matches = self.find_matches_in_file(file_id);\n-        if matches.matches.is_empty() {\n-            None\n-        } else {\n-            use ra_db::SourceDatabaseExt;\n-            Some(replacing::matches_to_edit(\n-                &matches,\n-                &self.sema.db.file_text(file_id),\n-                &self.rules,\n-            ))\n-        }\n-    }\n-\n-    pub fn find_matches_in_file(&self, file_id: FileId) -> SsrMatches {\n-        let file = self.sema.parse(file_id);\n-        let code = file.syntax();\n-        let mut matches = SsrMatches::default();\n-        self.slow_scan_node(code, &None, &mut matches.matches);\n-        matches\n+    /// Returns matches for all added rules.\n+    pub fn matches(&self) -> SsrMatches {\n+        let mut matches = Vec::new();\n+        self.find_all_matches(&mut matches);\n+        SsrMatches { matches }\n     }\n \n     /// Finds all nodes in `file_id` whose text is exactly equal to `snippet` and attempts to match"}, {"sha": "064e3a204d613b38252229e5246b5f424a3dcf9b", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -570,13 +570,12 @@ mod tests {\n     #[test]\n     fn parse_match_replace() {\n         let rule: SsrRule = \"foo($x) ==>> bar($x)\".parse().unwrap();\n-        let input = \"fn foo() {} fn main() { foo(1+2); }\";\n+        let input = \"fn foo() {} fn bar() {} fn main() { foo(1+2); }\";\n \n-        use ra_db::fixture::WithFixture;\n-        let (db, file_id) = ra_ide_db::RootDatabase::with_single_file(input);\n+        let (db, _) = crate::tests::single_file(input);\n         let mut match_finder = MatchFinder::new(&db);\n         match_finder.add_rule(rule);\n-        let matches = match_finder.find_matches_in_file(file_id);\n+        let matches = match_finder.matches();\n         assert_eq!(matches.matches.len(), 1);\n         assert_eq!(matches.matches[0].matched_node.text(), \"foo(1+2)\");\n         assert_eq!(matches.matches[0].placeholder_values.len(), 1);\n@@ -589,9 +588,11 @@ mod tests {\n             \"1+2\"\n         );\n \n-        let edit = crate::replacing::matches_to_edit(&matches, input, &match_finder.rules);\n+        let edits = match_finder.edits();\n+        assert_eq!(edits.len(), 1);\n+        let edit = &edits[0];\n         let mut after = input.to_string();\n-        edit.apply(&mut after);\n-        assert_eq!(after, \"fn foo() {} fn main() { bar(1+2); }\");\n+        edit.edit.apply(&mut after);\n+        assert_eq!(after, \"fn foo() {} fn bar() {} fn main() { bar(1+2); }\");\n     }\n }"}, {"sha": "ec3addcf892a170b89260612d4835a33d93b845c", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -5,7 +5,26 @@ use ra_db::FileRange;\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n impl<'db> MatchFinder<'db> {\n-    pub(crate) fn slow_scan_node(\n+    pub(crate) fn find_all_matches(&self, matches_out: &mut Vec<Match>) {\n+        // FIXME: Use resolved paths in the pattern to find places to search instead of always\n+        // scanning every node.\n+        self.slow_scan(matches_out);\n+    }\n+\n+    fn slow_scan(&self, matches_out: &mut Vec<Match>) {\n+        use ra_db::SourceDatabaseExt;\n+        use ra_ide_db::symbol_index::SymbolsDatabase;\n+        for &root in self.sema.db.local_roots().iter() {\n+            let sr = self.sema.db.source_root(root);\n+            for file_id in sr.iter() {\n+                let file = self.sema.parse(file_id);\n+                let code = file.syntax();\n+                self.slow_scan_node(code, &None, matches_out);\n+            }\n+        }\n+    }\n+\n+    fn slow_scan_node(\n         &self,\n         code: &SyntaxNode,\n         restrict_range: &Option<FileRange>,"}, {"sha": "c7c37af2f57ff7054cd894884a628fbf6df815ff", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -1,6 +1,8 @@\n use crate::{MatchFinder, SsrRule};\n use expect::{expect, Expect};\n-use ra_db::{FileId, SourceDatabaseExt};\n+use ra_db::{salsa::Durability, FileId, SourceDatabaseExt};\n+use rustc_hash::FxHashSet;\n+use std::sync::Arc;\n use test_utils::mark;\n \n fn parse_error_text(query: &str) -> String {\n@@ -57,9 +59,15 @@ fn parser_undefined_placeholder_in_replacement() {\n     );\n }\n \n-fn single_file(code: &str) -> (ra_ide_db::RootDatabase, FileId) {\n+pub(crate) fn single_file(code: &str) -> (ra_ide_db::RootDatabase, FileId) {\n     use ra_db::fixture::WithFixture;\n-    ra_ide_db::RootDatabase::with_single_file(code)\n+    use ra_ide_db::symbol_index::SymbolsDatabase;\n+    let (db, file_id) = ra_ide_db::RootDatabase::with_single_file(code);\n+    let mut db = db;\n+    let mut local_roots = FxHashSet::default();\n+    local_roots.insert(ra_db::fixture::WORKSPACE);\n+    db.set_local_roots_with_durability(Arc::new(local_roots), Durability::HIGH);\n+    (db, file_id)\n }\n \n fn assert_ssr_transform(rule: &str, input: &str, expected: Expect) {\n@@ -73,15 +81,16 @@ fn assert_ssr_transforms(rules: &[&str], input: &str, expected: Expect) {\n         let rule: SsrRule = rule.parse().unwrap();\n         match_finder.add_rule(rule);\n     }\n-    if let Some(edits) = match_finder.edits_for_file(file_id) {\n-        // Note, db.file_text is not necessarily the same as `input`, since fixture parsing alters\n-        // stuff.\n-        let mut actual = db.file_text(file_id).to_string();\n-        edits.apply(&mut actual);\n-        expected.assert_eq(&actual);\n-    } else {\n+    let edits = match_finder.edits();\n+    if edits.is_empty() {\n         panic!(\"No edits were made\");\n     }\n+    assert_eq!(edits[0].file_id, file_id);\n+    // Note, db.file_text is not necessarily the same as `input`, since fixture parsing alters\n+    // stuff.\n+    let mut actual = db.file_text(file_id).to_string();\n+    edits[0].edit.apply(&mut actual);\n+    expected.assert_eq(&actual);\n }\n \n fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet: &str) {\n@@ -100,13 +109,8 @@ fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n     let (db, file_id) = single_file(code);\n     let mut match_finder = MatchFinder::new(&db);\n     match_finder.add_search_pattern(pattern.parse().unwrap());\n-    let matched_strings: Vec<String> = match_finder\n-        .find_matches_in_file(file_id)\n-        .flattened()\n-        .matches\n-        .iter()\n-        .map(|m| m.matched_text())\n-        .collect();\n+    let matched_strings: Vec<String> =\n+        match_finder.matches().flattened().matches.iter().map(|m| m.matched_text()).collect();\n     if matched_strings != expected && !expected.is_empty() {\n         print_match_debug_info(&match_finder, file_id, &expected[0]);\n     }\n@@ -117,7 +121,7 @@ fn assert_no_match(pattern: &str, code: &str) {\n     let (db, file_id) = single_file(code);\n     let mut match_finder = MatchFinder::new(&db);\n     match_finder.add_search_pattern(pattern.parse().unwrap());\n-    let matches = match_finder.find_matches_in_file(file_id).flattened().matches;\n+    let matches = match_finder.matches().flattened().matches;\n     if !matches.is_empty() {\n         print_match_debug_info(&match_finder, file_id, &matches[0].matched_text());\n         panic!(\"Got {} matches when we expected none: {:#?}\", matches.len(), matches);"}, {"sha": "014bc70a4560d467341574f5a8a9d6cbbe79c2b6", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45682ed96f18f962ac403419b4d143d59ba5283/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=a45682ed96f18f962ac403419b4d143d59ba5283", "patch": "@@ -1,27 +1,17 @@\n //! Applies structured search replace rules from the command line.\n \n use crate::cli::{load_cargo::load_cargo, Result};\n-use ra_ide::SourceFileEdit;\n use ra_ssr::{MatchFinder, SsrPattern, SsrRule};\n \n pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n     use ra_db::SourceDatabaseExt;\n-    use ra_ide_db::symbol_index::SymbolsDatabase;\n     let (host, vfs) = load_cargo(&std::env::current_dir()?, true, true)?;\n     let db = host.raw_database();\n     let mut match_finder = MatchFinder::new(db);\n     for rule in rules {\n         match_finder.add_rule(rule);\n     }\n-    let mut edits = Vec::new();\n-    for &root in db.local_roots().iter() {\n-        let sr = db.source_root(root);\n-        for file_id in sr.iter() {\n-            if let Some(edit) = match_finder.edits_for_file(file_id) {\n-                edits.push(SourceFileEdit { file_id, edit });\n-            }\n-        }\n-    }\n+    let edits = match_finder.edits();\n     for edit in edits {\n         if let Some(path) = vfs.file_path(edit.file_id).as_path() {\n             let mut contents = db.file_text(edit.file_id).to_string();\n@@ -38,34 +28,27 @@ pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n pub fn search_for_patterns(patterns: Vec<SsrPattern>, debug_snippet: Option<String>) -> Result<()> {\n     use ra_db::SourceDatabaseExt;\n     use ra_ide_db::symbol_index::SymbolsDatabase;\n-    let (host, vfs) = load_cargo(&std::env::current_dir()?, true, true)?;\n+    let (host, _vfs) = load_cargo(&std::env::current_dir()?, true, true)?;\n     let db = host.raw_database();\n     let mut match_finder = MatchFinder::new(db);\n     for pattern in patterns {\n         match_finder.add_search_pattern(pattern);\n     }\n-    for &root in db.local_roots().iter() {\n-        let sr = db.source_root(root);\n-        for file_id in sr.iter() {\n-            if let Some(debug_snippet) = &debug_snippet {\n+    if let Some(debug_snippet) = &debug_snippet {\n+        for &root in db.local_roots().iter() {\n+            let sr = db.source_root(root);\n+            for file_id in sr.iter() {\n                 for debug_info in match_finder.debug_where_text_equal(file_id, debug_snippet) {\n                     println!(\"{:#?}\", debug_info);\n                 }\n-            } else {\n-                let matches = match_finder.find_matches_in_file(file_id);\n-                if !matches.matches.is_empty() {\n-                    let matches = matches.flattened().matches;\n-                    if let Some(path) = vfs.file_path(file_id).as_path() {\n-                        println!(\"{} matches in '{}'\", matches.len(), path.to_string_lossy());\n-                    }\n-                    // We could possibly at some point do something more useful than just printing\n-                    // the matched text. For now though, that's the easiest thing to do.\n-                    for m in matches {\n-                        println!(\"{}\", m.matched_text());\n-                    }\n-                }\n             }\n         }\n+    } else {\n+        for m in match_finder.matches().flattened().matches {\n+            // We could possibly at some point do something more useful than just printing\n+            // the matched text. For now though, that's the easiest thing to do.\n+            println!(\"{}\", m.matched_text());\n+        }\n     }\n     Ok(())\n }"}]}