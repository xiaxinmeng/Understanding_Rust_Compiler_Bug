{"sha": "e0a80ee332dc347d588bfcea66c11896c04263bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYTgwZWUzMzJkYzM0N2Q1ODhiZmNlYTY2YzExODk2YzA0MjYzYmI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-17T07:34:24Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: support async/threadpool & sync paths in uv_fs_* calls + add sync test", "tree": {"sha": "e0544d466b565abca9e78fd6f20e8ffd4694e76b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0544d466b565abca9e78fd6f20e8ffd4694e76b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0a80ee332dc347d588bfcea66c11896c04263bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a80ee332dc347d588bfcea66c11896c04263bb", "html_url": "https://github.com/rust-lang/rust/commit/e0a80ee332dc347d588bfcea66c11896c04263bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0a80ee332dc347d588bfcea66c11896c04263bb/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c49c2921b0250fee51b935e3d164cc1bdb8a9445", "url": "https://api.github.com/repos/rust-lang/rust/commits/c49c2921b0250fee51b935e3d164cc1bdb8a9445", "html_url": "https://github.com/rust-lang/rust/commit/c49c2921b0250fee51b935e3d164cc1bdb8a9445"}], "stats": {"total": 204, "additions": 169, "deletions": 35}, "files": [{"sha": "35e425ce65917d502cb67535392d6ba2769971fd", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 169, "deletions": 35, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e0a80ee332dc347d588bfcea66c11896c04263bb/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a80ee332dc347d588bfcea66c11896c04263bb/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=e0a80ee332dc347d588bfcea66c11896c04263bb", "patch": "@@ -147,49 +147,92 @@ impl FileDescriptor {\n         FileDescriptor::new(req.get_result())\n     }\n \n+    fn open_common(loop_: Loop, path: Path, flags: int, mode: int,\n+               cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.to_str().to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n     pub fn open(loop_: Loop, path: Path, flags: int, mode: int,\n                cb: FsCallback) -> int {\n-        let req = FsRequest::new(Some(cb));\n-        path.to_str().to_c_str().with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                          req.native_handle(), p, flags, mode, complete_cb) as int\n-        })\n+        FileDescriptor::open_common(loop_, path, flags, mode, Some(cb))\n+    }\n+    pub fn open_sync(loop_: Loop, path: Path, flags: int, mode: int) -> int {\n+        FileDescriptor::open_common(loop_, path, flags, mode, None)\n     }\n \n-    pub fn unlink(loop_: Loop, path: Path, cb: FsCallback) -> int {\n-        let req = FsRequest::new(Some(cb));\n-        path.to_str().to_c_str().with_ref(|p| unsafe {\n+    fn unlink_common(loop_: Loop, path: Path, cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = path.to_str().to_c_str().with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n-                          req.native_handle(), p, complete_cb) as int\n-        })\n+                          req.native_handle(), p, complete_cb_ptr) as int\n+        });\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn unlink(loop_: Loop, path: Path, cb: FsCallback) -> int {\n+        FileDescriptor::unlink_common(loop_, path, Some(cb))\n+    }\n+    pub fn unlink_sync(loop_: Loop, path: Path) -> int {\n+        FileDescriptor::unlink_common(loop_, path, None)\n     }\n \n     // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n-    pub fn write(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: FsCallback)\n+    fn write_common(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: Option<FsCallback>)\n           -> int {\n-        let mut req = FsRequest::new(Some(cb));\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let mut req = FsRequest::new(cb);\n         let len = buf.len();\n         let buf = vec_to_uv_buf(buf);\n         let base_ptr = buf.base as *c_void;\n         req.get_req_data().buf = Some(buf);\n         req.get_req_data().raw_fd = Some(self.native_handle());\n-        unsafe {\n+        let result = unsafe {\n             uvll::fs_write(loop_.native_handle(), req.native_handle(),\n                            self.native_handle(), base_ptr,\n-                           len, offset, complete_cb) as int\n-        }\n+                           len, offset, complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn write(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: FsCallback)\n+          -> int {\n+        self.write_common(loop_, buf, offset, Some(cb))\n+    }\n+    pub fn write_sync(&self, loop_: Loop, buf: ~[u8], offset: i64)\n+          -> int {\n+        self.write_common(loop_, buf, offset, None)\n     }\n \n-    // really contemplated having this just take a read_len param and have\n-    // the buf live in the scope of this request.. but decided that exposing\n-    // an unsafe mechanism that takes a buf_ptr and len would be much more\n-    // flexible, but the caller is now in the position of managing that\n-    // buf (with all of the sadface that this entails)\n-    pub fn read(&self, loop_: Loop, buf_ptr: Option<*c_void>, len: uint, offset: i64, cb: FsCallback)\n+    fn read_common(&self, loop_: Loop, buf_ptr: Option<*c_void>,\n+                   len: uint, offset: i64, cb: Option<FsCallback>)\n           -> int {\n-        let mut req = FsRequest::new(Some(cb));\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let mut req = FsRequest::new(cb);\n         req.get_req_data().raw_fd = Some(self.native_handle());\n-        unsafe {\n+        let result = unsafe {\n             let buf_ptr = match buf_ptr {\n                 Some(ptr) => ptr,\n                 None => {\n@@ -201,19 +244,43 @@ impl FileDescriptor {\n             };\n             uvll::fs_read(loop_.native_handle(), req.native_handle(),\n                            self.native_handle(), buf_ptr,\n-                           len, offset, complete_cb) as int\n-        }\n+                           len, offset, complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn read(&self, loop_: Loop, buf_ptr: Option<*c_void>,\n+                len: uint, offset: i64, cb: FsCallback)\n+          -> int {\n+        self.read_common(loop_, buf_ptr, len, offset, Some(cb))\n+    }\n+    pub fn read_sync(&self, loop_: Loop, buf_ptr: Option<*c_void>, len: uint, offset: i64)\n+          -> int {\n+        self.read_common(loop_, buf_ptr, len, offset, None)\n     }\n \n-    pub fn close(self, loop_: Loop, cb: FsCallback) -> int {\n-        let req = FsRequest::new(Some(cb));\n-        unsafe {\n+    fn close_common(self, loop_: Loop, cb: Option<FsCallback>) -> int {\n+        let complete_cb_ptr = match cb {\n+            Some(_) => compl_cb,\n+            None => 0 as *u8\n+        };\n+        let is_sync = cb.is_none();\n+        let req = FsRequest::new(cb);\n+        let result = unsafe {\n             uvll::fs_close(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), complete_cb) as int\n-        }\n+                           self.native_handle(), complete_cb_ptr) as int\n+        };\n+        if is_sync { req.cleanup_and_delete(); }\n+        result\n+    }\n+    pub fn close(self, loop_: Loop, cb: FsCallback) -> int {\n+        self.close_common(loop_, Some(cb))\n+    }\n+    pub fn close_sync(self, loop_: Loop) -> int {\n+        self.close_common(loop_, None)\n     }\n }\n-extern fn complete_cb(req: *uv_fs_t) {\n+extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n     let loop_ = req.get_loop();\n     // pull the user cb out of the req data\n@@ -249,17 +316,18 @@ impl NativeHandle<c_int> for FileDescriptor {\n mod test {\n     use super::*;\n     //use rt::test::*;\n-    use libc::{STDOUT_FILENO};\n+    use option::{Some};\n+    use libc::{STDOUT_FILENO, c_void};\n+    use vec;\n     use str;\n     use unstable::run_in_bare_thread;\n     use path::Path;\n-    use rt::uv::{Loop, vec_from_uv_buf};//, slice_to_uv_buf};\n+    use rt::uv::{Loop, vec_to_uv_buf, vec_from_uv_buf,\n+                 status_to_maybe_uv_error_with_loop};\n     use option::{None};\n \n     fn file_test_full_simple_impl() {\n-        debug!(\"hello?\")\n         do run_in_bare_thread {\n-            debug!(\"In bare thread\")\n             let mut loop_ = Loop::new();\n             let create_flags = map_flag(O_RDWR) |\n                 map_flag(O_CREAT);\n@@ -321,12 +389,78 @@ mod test {\n             loop_.close();\n         }\n     }\n+    fn file_test_full_simple_impl_sync() {\n+        do run_in_bare_thread {\n+            // setup\n+            let mut loop_ = Loop::new();\n+            let create_flags = map_flag(O_RDWR) |\n+                map_flag(O_CREAT);\n+            let read_flags = map_flag(O_RDONLY);\n+            // 0644\n+            let mode = map_mode(S_IWUSR) |\n+                map_mode(S_IRUSR) |\n+                map_mode(S_IRGRP) |\n+                map_mode(S_IROTH);\n+            let path_str = \"./file_full_simple_sync.txt\";\n+            let write_val = \"hello\";\n+            // open/create\n+            let result = FileDescriptor::open_sync(loop_, Path(path_str), create_flags, mode);\n+            assert!(status_to_maybe_uv_error_with_loop(\n+                loop_.native_handle(), result as i32).is_none());\n+            let fd = FileDescriptor(result as i32);\n+            let msg: ~[u8] = write_val.as_bytes().to_owned();\n+            // write\n+            let result = fd.write_sync(loop_, msg, -1);\n+            assert!(status_to_maybe_uv_error_with_loop(\n+                loop_.native_handle(), result as i32).is_none());\n+            // close\n+            let result = fd.close_sync(loop_);\n+            assert!(status_to_maybe_uv_error_with_loop(\n+                loop_.native_handle(), result as i32).is_none());\n+            // re-open\n+            let result = FileDescriptor::open_sync(loop_, Path(path_str), read_flags,0);\n+            assert!(status_to_maybe_uv_error_with_loop(\n+                loop_.native_handle(), result as i32).is_none());\n+            let len = 1028;\n+            let fd = FileDescriptor(result as i32);\n+            // read\n+            let buf: ~[u8] = vec::from_elem(len, 0u8);\n+            let buf = vec_to_uv_buf(buf);\n+            let buf_ptr = buf.base as *c_void;\n+            let result = fd.read_sync(loop_, Some(buf_ptr), len, 0);\n+            assert!(status_to_maybe_uv_error_with_loop(\n+                loop_.native_handle(), result as i32).is_none());\n+            let nread = result;\n+            // nread == 0 would be EOF.. we know it's >= zero because otherwise\n+            // the above assert would fail\n+            if nread > 0 {\n+                let buf = vec_from_uv_buf(buf).take_unwrap();\n+                let read_str = str::from_bytes(\n+                    buf.slice(0, nread as uint));\n+                assert!(read_str == ~\"hello\");\n+                // close\n+                let result = fd.close_sync(loop_);\n+                assert!(status_to_maybe_uv_error_with_loop(\n+                    loop_.native_handle(), result as i32).is_none());\n+                // unlink\n+                let result = FileDescriptor::unlink_sync(loop_, Path(path_str));\n+                assert!(status_to_maybe_uv_error_with_loop(\n+                    loop_.native_handle(), result as i32).is_none());\n+            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n+            loop_.close();\n+        }\n+    }\n \n     #[test]\n     fn file_test_full_simple() {\n         file_test_full_simple_impl();\n     }\n \n+    #[test]\n+    fn file_test_full_simple_sync() {\n+        file_test_full_simple_impl_sync();\n+    }\n+\n     fn naive_print(loop_: Loop, input: ~str) {\n         let stdout = FileDescriptor(STDOUT_FILENO);\n         let msg = input.as_bytes().to_owned();"}]}