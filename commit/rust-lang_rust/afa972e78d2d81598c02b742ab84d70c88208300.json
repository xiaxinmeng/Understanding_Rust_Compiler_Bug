{"sha": "afa972e78d2d81598c02b742ab84d70c88208300", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYTk3MmU3OGQyZDgxNTk4YzAyYjc0MmFiODRkNzBjODgyMDgzMDA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T13:05:54Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T13:05:54Z"}, "message": "Merge #403\n\n403: initial support for macros r=matklad a=matklad\n\nI'll write a more comprehensive description when this is closer to being done. Basically this investigates one question: \"how do we represent code which is a result of a macro call\". This is an interesting question: currently everything is `FileId` based, but macro expansion does not have a file!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2ec32a586d0ee00e0d35a489efeaf31c91d14a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ec32a586d0ee00e0d35a489efeaf31c91d14a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afa972e78d2d81598c02b742ab84d70c88208300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afa972e78d2d81598c02b742ab84d70c88208300", "html_url": "https://github.com/rust-lang/rust/commit/afa972e78d2d81598c02b742ab84d70c88208300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afa972e78d2d81598c02b742ab84d70c88208300/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e4ffd7b31780b1f2ac6dcb731566b583bf562647", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ffd7b31780b1f2ac6dcb731566b583bf562647", "html_url": "https://github.com/rust-lang/rust/commit/e4ffd7b31780b1f2ac6dcb731566b583bf562647"}, {"sha": "1076e82856f353763de8426d378fcd1e371cbed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1076e82856f353763de8426d378fcd1e371cbed4", "html_url": "https://github.com/rust-lang/rust/commit/1076e82856f353763de8426d378fcd1e371cbed4"}], "stats": {"total": 1122, "additions": 778, "deletions": 344}, "files": [{"sha": "4dead36896222533502a9aaa332c1346b88496a9", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -27,7 +27,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n             match res.import {\n                 None => true,\n                 Some(import) => {\n-                    let range = import.range(ctx.db, module.source().file_id());\n+                    let range = import.range(ctx.db, module.file_id());\n                     !range.is_subrange(&ctx.leaf.range())\n                 }\n             }"}, {"sha": "d7740f0c4ed7173ded851f51390a3dbdb09b240e", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -1,7 +1,6 @@\n use std::{fmt, sync::Arc};\n use salsa::{self, Database};\n use ra_db::{LocationIntener, BaseDatabase};\n-use hir::{self, DefId, DefLoc};\n \n use crate::{\n     symbol_index,\n@@ -15,7 +14,8 @@ pub(crate) struct RootDatabase {\n \n #[derive(Default)]\n struct IdMaps {\n-    defs: LocationIntener<DefLoc, DefId>,\n+    defs: LocationIntener<hir::DefLoc, hir::DefId>,\n+    macros: LocationIntener<hir::MacroCallLoc, hir::MacroCallId>,\n }\n \n impl fmt::Debug for IdMaps {\n@@ -59,12 +59,18 @@ impl salsa::ParallelDatabase for RootDatabase {\n \n impl BaseDatabase for RootDatabase {}\n \n-impl AsRef<LocationIntener<DefLoc, DefId>> for RootDatabase {\n-    fn as_ref(&self) -> &LocationIntener<DefLoc, DefId> {\n+impl AsRef<LocationIntener<hir::DefLoc, hir::DefId>> for RootDatabase {\n+    fn as_ref(&self) -> &LocationIntener<hir::DefLoc, hir::DefId> {\n         &self.id_maps.defs\n     }\n }\n \n+impl AsRef<LocationIntener<hir::MacroCallLoc, hir::MacroCallId>> for RootDatabase {\n+    fn as_ref(&self) -> &LocationIntener<hir::MacroCallLoc, hir::MacroCallId> {\n+        &self.id_maps.macros\n+    }\n+}\n+\n salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n         impl ra_db::FilesDatabase {\n@@ -85,6 +91,8 @@ salsa::database_storage! {\n             fn library_symbols() for symbol_index::LibrarySymbolsQuery;\n         }\n         impl hir::db::HirDatabase {\n+            fn hir_source_file() for hir::db::HirSourceFileQuery;\n+            fn expand_macro_invocation() for hir::db::ExpandMacroCallQuery;\n             fn module_tree() for hir::db::ModuleTreeQuery;\n             fn fn_scopes() for hir::db::FnScopesQuery;\n             fn file_items() for hir::db::SourceFileItemsQuery;"}, {"sha": "f1b77f9819a093e57f9ba3db98c7a03c1e70ba36", "filename": "crates/ra_analysis/src/extend_selection.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -18,15 +18,15 @@ pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRang\n }\n \n fn extend_selection_in_macro(\n-    db: &RootDatabase,\n+    _db: &RootDatabase,\n     source_file: &SourceFileNode,\n     frange: FileRange,\n ) -> Option<TextRange> {\n     let macro_call = find_macro_call(source_file.syntax(), frange.range)?;\n-    let exp = crate::macros::expand(db, frange.file_id, macro_call)?;\n-    let dst_range = exp.map_range_forward(frange.range)?;\n-    let dst_range = ra_editor::extend_selection(exp.source_file().syntax(), dst_range)?;\n-    let src_range = exp.map_range_back(dst_range)?;\n+    let (off, exp) = hir::MacroDef::ast_expand(macro_call)?;\n+    let dst_range = exp.map_range_forward(frange.range - off)?;\n+    let dst_range = ra_editor::extend_selection(exp.syntax().borrowed(), dst_range)?;\n+    let src_range = exp.map_range_back(dst_range)? + off;\n     Some(src_range)\n }\n "}, {"sha": "ec7da437a1c4aed49baa2bc20705981ac19710af", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -230,7 +230,7 @@ impl AnalysisImpl {\n             Some(it) => it,\n         };\n         let root = descr.crate_root();\n-        let file_id = root.source().file_id();\n+        let file_id = root.file_id();\n \n         let crate_graph = self.db.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n@@ -283,7 +283,7 @@ impl AnalysisImpl {\n                     if let Some(child_module) =\n                         source_binder::module_from_declaration(&*self.db, position.file_id, module)?\n                     {\n-                        let file_id = child_module.source().file_id();\n+                        let file_id = child_module.file_id();\n                         let name = match child_module.name() {\n                             Some(name) => name.to_string().into(),\n                             None => \"\".into(),"}, {"sha": "08ecb125a362a20d825f0cb3afb5964c6481a734", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -19,7 +19,6 @@ mod runnables;\n \n mod extend_selection;\n mod syntax_highlighting;\n-mod macros;\n \n use std::{fmt, sync::Arc};\n "}, {"sha": "b9feb7fad4d02f0c931aa78344be892b04a93e07", "filename": "crates/ra_analysis/src/macros.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e4ffd7b31780b1f2ac6dcb731566b583bf562647/crates%2Fra_analysis%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4ffd7b31780b1f2ac6dcb731566b583bf562647/crates%2Fra_analysis%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmacros.rs?ref=e4ffd7b31780b1f2ac6dcb731566b583bf562647", "patch": "@@ -1,75 +0,0 @@\n-/// Begining of macro expansion.\n-///\n-/// This code should be moved out of ra_analysis into hir (?) ideally.\n-use ra_syntax::{ast, AstNode, SourceFileNode, TextRange};\n-\n-use crate::{db::RootDatabase, FileId};\n-\n-pub(crate) fn expand(\n-    _db: &RootDatabase,\n-    _file_id: FileId,\n-    macro_call: ast::MacroCall,\n-) -> Option<MacroExpansion> {\n-    let path = macro_call.path()?;\n-    if path.qualifier().is_some() {\n-        return None;\n-    }\n-    let name_ref = path.segment()?.name_ref()?;\n-    if name_ref.text() != \"ctry\" {\n-        return None;\n-    }\n-\n-    let arg = macro_call.token_tree()?;\n-    let text = format!(\n-        r\"\n-        fn dummy() {{\n-            match {} {{\n-                None => return Ok(None),\n-                Some(it) => it,\n-            }}\n-        }}\",\n-        arg.syntax().text()\n-    );\n-    let file = SourceFileNode::parse(&text);\n-    let match_expr = file.syntax().descendants().find_map(ast::MatchExpr::cast)?;\n-    let match_arg = match_expr.expr()?;\n-    let ranges_map = vec![(arg.syntax().range(), match_arg.syntax().range())];\n-    let res = MacroExpansion {\n-        source_file: file,\n-        ranges_map,\n-    };\n-    Some(res)\n-}\n-\n-pub(crate) struct MacroExpansion {\n-    pub(crate) source_file: SourceFileNode,\n-    pub(crate) ranges_map: Vec<(TextRange, TextRange)>,\n-}\n-\n-impl MacroExpansion {\n-    pub(crate) fn source_file(&self) -> &SourceFileNode {\n-        &self.source_file\n-    }\n-    pub(crate) fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if tgt_range.is_subrange(&t_range) {\n-                let tgt_at_zero_range = tgt_range - tgt_range.start();\n-                let tgt_range_offset = tgt_range.start() - t_range.start();\n-                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-    pub(crate) fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if src_range.is_subrange(&s_range) {\n-                let src_at_zero_range = src_range - src_range.start();\n-                let src_range_offset = src_range.start() - s_range.start();\n-                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-}"}, {"sha": "ccea4aee39e5418cc1f9775f88ed34b9e4aee21d", "filename": "crates/ra_analysis/src/syntax_highlighting.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -15,13 +15,13 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Hi\n         .descendants()\n         .filter_map(ast::MacroCall::cast)\n     {\n-        if let Some(exp) = crate::macros::expand(db, file_id, macro_call) {\n-            let mapped_ranges = ra_editor::highlight(exp.source_file().syntax())\n+        if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n+            let mapped_ranges = ra_editor::highlight(exp.syntax().borrowed())\n                 .into_iter()\n                 .filter_map(|r| {\n                     let mapped_range = exp.map_range_back(r.range)?;\n                     let res = HighlightedRange {\n-                        range: mapped_range,\n+                        range: mapped_range + off,\n                         tag: r.tag,\n                     };\n                     Some(res)\n@@ -44,7 +44,7 @@ mod tests {\n             fn main() {\n                 ctry!({ let x = 92; x});\n             }\n-        \",\n+            \",\n         );\n         let highlights = analysis.highlight(file_id).unwrap();\n         assert_eq_dbg(\n@@ -60,4 +60,26 @@ mod tests {\n             &highlights,\n         )\n     }\n+\n+    // FIXME: this test is not really necessary: artifact of the inital hacky\n+    // macros implementation.\n+    #[test]\n+    fn highlight_query_group_macro() {\n+        let (analysis, file_id) = single_file(\n+            \"\n+            salsa::query_group! {\n+                pub trait HirDatabase: SyntaxDatabase {}\n+            }\n+            \",\n+        );\n+        let highlights = analysis.highlight(file_id).unwrap();\n+        assert_eq_dbg(\n+            r#\"[HighlightedRange { range: [20; 32), tag: \"macro\" },\n+                HighlightedRange { range: [13; 18), tag: \"text\" },\n+                HighlightedRange { range: [51; 54), tag: \"keyword\" },\n+                HighlightedRange { range: [55; 60), tag: \"keyword\" },\n+                HighlightedRange { range: [61; 72), tag: \"function\" }]\"#,\n+            &highlights,\n+        )\n+    }\n }"}, {"sha": "c6463235c4e7272b7cb02ae1dea4c60ac848415e", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -1,9 +1,10 @@\n use std::sync::Arc;\n \n+use ra_db::Cancelable;\n use ra_syntax::ast::{self, NameOwner, StructFlavor};\n \n use crate::{\n-    DefId, Cancelable, Name, AsName,\n+    DefId, Name, AsName,\n     db::HirDatabase,\n     type_ref::TypeRef,\n };"}, {"sha": "73a4cdc5c828f28ad99780411e3df2bc77755828", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -1,13 +1,14 @@\n use std::sync::Arc;\n \n-use ra_syntax::SyntaxNode;\n-use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n+use ra_syntax::{SyntaxNode, SourceFileNode};\n+use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n-    DefLoc, DefId, Name,\n+    DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n     FnScopes,\n+    macros::MacroExpansion,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n     ty::{InferenceResult, Ty},\n@@ -18,7 +19,17 @@ salsa::query_group! {\n \n pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n+    + AsRef<LocationIntener<MacroCallLoc, MacroCallId>>\n {\n+    fn hir_source_file(file_id: HirFileId) -> SourceFileNode {\n+        type HirSourceFileQuery;\n+        use fn HirFileId::hir_source_file;\n+    }\n+    fn expand_macro_invocation(invoc: MacroCallId) -> Option<Arc<MacroExpansion>> {\n+        type ExpandMacroCallQuery;\n+        use fn crate::macros::expand_macro_invocation;\n+    }\n+\n     fn fn_scopes(def_id: DefId) -> Arc<FnScopes> {\n         type FnScopesQuery;\n         use fn query_definitions::fn_scopes;\n@@ -49,7 +60,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::ty::type_for_field;\n     }\n \n-    fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n+    fn file_items(file_id: HirFileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;\n     }"}, {"sha": "a09dee8b1d317c756d43c8fb1100edd919612ea3", "filename": "crates/ra_hir/src/ids.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -0,0 +1,280 @@\n+use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n+use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n+\n+use crate::{\n+    HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum,\n+    arena::{Arena, Id},\n+};\n+\n+/// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n+/// can think of id as a pointer (but without a lifetime) or a file descriptor\n+/// (but for hir objects).\n+///\n+/// This module defines a bunch of ids we are using. The most important ones are\n+/// probably `HirFileId` and `DefId`.\n+\n+/// Input to the analyzer is a set of file, where each file is indetified by\n+/// `FileId` and contains source code. However, another source of source code in\n+/// Rust are macros: each macro can be thought of as producing a \"temporary\n+/// file\". To assign id to such file, we use the id of a macro call that\n+/// produced the file. So, a `HirFileId` is either a `FileId` (source code\n+/// written by user), or a `MacroCallId` (source code produced by macro).\n+///\n+/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file containin\n+/// the call plus the offset of the macro call in the file. Note that this is a\n+/// recursive definition! Nethetheless, size_of of `HirFileId` is finite\n+/// (because everything bottoms out at the real `FileId`) and small\n+/// (`MacroCallId` uses location interner).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct HirFileId(HirFileIdRepr);\n+\n+impl HirFileId {\n+    /// For macro-expansion files, returns the file original source file the\n+    /// expansionoriginated from.\n+    pub(crate) fn original_file(self, db: &impl HirDatabase) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::File(file_id) => file_id,\n+            HirFileIdRepr::Macro(macro_call_id) => {\n+                let loc = macro_call_id.loc(db);\n+                loc.source_item_id.file_id.original_file(db)\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn as_original_file(self) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::File(file_id) => file_id,\n+            HirFileIdRepr::Macro(_r) => panic!(\"macro generated file: {:?}\", self),\n+        }\n+    }\n+\n+    pub(crate) fn hir_source_file(db: &impl HirDatabase, file_id: HirFileId) -> SourceFileNode {\n+        match file_id.0 {\n+            HirFileIdRepr::File(file_id) => db.source_file(file_id),\n+            HirFileIdRepr::Macro(m) => {\n+                if let Some(exp) = db.expand_macro_invocation(m) {\n+                    return exp.file();\n+                }\n+                // returning an empty string looks fishy...\n+                SourceFileNode::parse(\"\")\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+enum HirFileIdRepr {\n+    File(FileId),\n+    Macro(MacroCallId),\n+}\n+\n+impl From<FileId> for HirFileId {\n+    fn from(file_id: FileId) -> HirFileId {\n+        HirFileId(HirFileIdRepr::File(file_id))\n+    }\n+}\n+\n+impl From<MacroCallId> for HirFileId {\n+    fn from(macro_call_id: MacroCallId) -> HirFileId {\n+        HirFileId(HirFileIdRepr::Macro(macro_call_id))\n+    }\n+}\n+\n+/// `MacroCallId` identifies a particular macro invocation, like\n+/// `println!(\"Hello, {}\", world)`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroCallId(u32);\n+ra_db::impl_numeric_id!(MacroCallId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroCallLoc {\n+    pub(crate) source_root_id: SourceRootId,\n+    pub(crate) module_id: ModuleId,\n+    pub(crate) source_item_id: SourceItemId,\n+}\n+\n+impl MacroCallId {\n+    pub(crate) fn loc(\n+        self,\n+        db: &impl AsRef<LocationIntener<MacroCallLoc, MacroCallId>>,\n+    ) -> MacroCallLoc {\n+        db.as_ref().id2loc(self)\n+    }\n+}\n+\n+impl MacroCallLoc {\n+    #[allow(unused)]\n+    pub(crate) fn id(\n+        &self,\n+        db: &impl AsRef<LocationIntener<MacroCallLoc, MacroCallId>>,\n+    ) -> MacroCallId {\n+        db.as_ref().loc2id(&self)\n+    }\n+}\n+\n+/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n+/// in a specific module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct DefId(u32);\n+ra_db::impl_numeric_id!(DefId);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DefLoc {\n+    pub(crate) kind: DefKind,\n+    pub(crate) source_root_id: SourceRootId,\n+    pub(crate) module_id: ModuleId,\n+    pub(crate) source_item_id: SourceItemId,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum DefKind {\n+    Module,\n+    Function,\n+    Struct,\n+    Enum,\n+    Item,\n+\n+    StructCtor,\n+}\n+\n+impl DefId {\n+    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+        db.as_ref().id2loc(self)\n+    }\n+\n+    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n+        let loc = self.loc(db);\n+        let res = match loc.kind {\n+            DefKind::Module => {\n+                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n+                Def::Module(module)\n+            }\n+            DefKind::Function => {\n+                let function = Function::new(self);\n+                Def::Function(function)\n+            }\n+            DefKind::Struct => {\n+                let struct_def = Struct::new(self);\n+                Def::Struct(struct_def)\n+            }\n+            DefKind::Enum => {\n+                let enum_def = Enum::new(self);\n+                Def::Enum(enum_def)\n+            }\n+            DefKind::StructCtor => Def::Item,\n+            DefKind::Item => Def::Item,\n+        };\n+        Ok(res)\n+    }\n+\n+    /// For a module, returns that module; for any other def, returns the containing module.\n+    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.loc(db);\n+        Module::new(db, loc.source_root_id, loc.module_id)\n+    }\n+}\n+\n+impl DefLoc {\n+    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+        db.as_ref().loc2id(&self)\n+    }\n+}\n+\n+impl DefKind {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n+        match kind {\n+            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n+            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n+            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n+            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n+            // These define items, but don't have their own DefKinds yet:\n+            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n+            _ => PerNs::none(),\n+        }\n+    }\n+}\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SourceItemId {\n+    pub(crate) file_id: HirFileId,\n+    /// None for the whole file.\n+    pub(crate) item_id: Option<SourceFileItemId>,\n+}\n+\n+/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct SourceFileItems {\n+    file_id: HirFileId,\n+    arena: Arena<SyntaxNode>,\n+}\n+\n+impl SourceFileItems {\n+    pub(crate) fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n+        let mut res = SourceFileItems {\n+            file_id,\n+            arena: Arena::default(),\n+        };\n+        res.init(source_file);\n+        res\n+    }\n+\n+    fn init(&mut self, source_file: SourceFile) {\n+        source_file.syntax().descendants().for_each(|it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                self.alloc(module_item.syntax().owned());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                self.alloc(macro_call.syntax().owned());\n+            }\n+        });\n+    }\n+\n+    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(item)\n+    }\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n+        assert_eq!(\n+            self.file_id, file_id,\n+            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n+            self.file_id, file_id\n+        );\n+        self.id_of_unchecked(item)\n+    }\n+    pub(crate) fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n+            return id;\n+        }\n+        // This should not happen. Let's try to give a sensible diagnostics.\n+        if let Some((id, i)) = self.arena.iter().find(|(_id, i)| i.range() == item.range()) {\n+            // FIXME(#288): whyyy are we getting here?\n+            log::error!(\n+                \"unequal syntax nodes with the same range:\\n{:?}\\n{:?}\",\n+                item,\n+                i\n+            );\n+            return id;\n+        }\n+        panic!(\n+            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n+            item,\n+            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+        );\n+    }\n+    pub fn id_of_source_file(&self) -> SourceFileItemId {\n+        let (id, _syntax) = self.arena.iter().next().unwrap();\n+        id\n+    }\n+}\n+\n+impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNode;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n+        &self.arena[idx]\n+    }\n+}"}, {"sha": "a0821d15dd2d551ae4080bce8aed0750b054a414", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -1,6 +1,6 @@\n-pub use ra_db::CrateId;\n+pub use ra_db::{CrateId, Cancelable};\n \n-use crate::{HirDatabase, Module, Cancelable, Name, AsName};\n+use crate::{HirDatabase, Module, Name, AsName, HirFileId};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -35,6 +35,7 @@ impl Crate {\n         let crate_graph = db.crate_graph();\n         let file_id = crate_graph.crate_root(self.crate_id);\n         let source_root_id = db.file_source_root(file_id);\n+        let file_id = HirFileId::from(file_id);\n         let module_tree = db.module_tree(source_root_id)?;\n         // FIXME: teach module tree about crate roots instead of guessing\n         let (module_id, _) = ctry!(module_tree"}, {"sha": "8ee52a466dd51faf5ba077aaec6d722a8e79f5c4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 163, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -22,29 +22,29 @@ mod path;\n mod arena;\n pub mod source_binder;\n \n+mod ids;\n+mod macros;\n mod name;\n+// can't use `crate` or `r#crate` here :(\n mod krate;\n mod module;\n mod function;\n mod adt;\n mod type_ref;\n mod ty;\n \n-use std::ops::Index;\n-\n-use ra_syntax::{SyntaxNodeRef, SyntaxNode, SyntaxKind};\n-use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n-\n use crate::{\n     db::HirDatabase,\n-    arena::{Arena, Id},\n     name::{AsName, KnownName},\n+    ids::{DefKind, SourceItemId, SourceFileItemId, SourceFileItems},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n     krate::Crate,\n+    ids::{HirFileId, DefId, DefLoc, MacroCallId, MacroCallLoc},\n+    macros::{MacroDef, MacroInput, MacroExpansion},\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n     adt::{Struct, Enum},\n@@ -53,167 +53,10 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n-/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n-/// in a specific module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct DefId(u32);\n-ra_db::impl_numeric_id!(DefId);\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefKind {\n-    Module,\n-    Function,\n-    Struct,\n-    Enum,\n-    Item,\n-\n-    StructCtor,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DefLoc {\n-    pub(crate) kind: DefKind,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-    source_item_id: SourceItemId,\n-}\n-\n-impl DefKind {\n-    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n-        match kind {\n-            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n-            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n-            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n-            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n-            // These define items, but don't have their own DefKinds yet:\n-            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n-            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n-            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n-            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n-            _ => PerNs::none(),\n-        }\n-    }\n-}\n-\n-impl DefId {\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n-        db.as_ref().id2loc(self)\n-    }\n-}\n-\n-impl DefLoc {\n-    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n-        db.as_ref().loc2id(&self)\n-    }\n-}\n-\n pub enum Def {\n     Module(Module),\n     Function(Function),\n     Struct(Struct),\n     Enum(Enum),\n     Item,\n }\n-\n-impl DefId {\n-    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n-        let loc = self.loc(db);\n-        let res = match loc.kind {\n-            DefKind::Module => {\n-                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n-                Def::Module(module)\n-            }\n-            DefKind::Function => {\n-                let function = Function::new(self);\n-                Def::Function(function)\n-            }\n-            DefKind::Struct => {\n-                let struct_def = Struct::new(self);\n-                Def::Struct(struct_def)\n-            }\n-            DefKind::Enum => {\n-                let enum_def = Enum::new(self);\n-                Def::Enum(enum_def)\n-            }\n-            DefKind::StructCtor => Def::Item,\n-            DefKind::Item => Def::Item,\n-        };\n-        Ok(res)\n-    }\n-\n-    /// For a module, returns that module; for any other def, returns the containing module.\n-    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n-        let loc = self.loc(db);\n-        Module::new(db, loc.source_root_id, loc.module_id)\n-    }\n-}\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    file_id: FileId,\n-    /// None for the whole file.\n-    item_id: Option<SourceFileItemId>,\n-}\n-\n-/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: FileId,\n-    arena: Arena<SyntaxNode>,\n-}\n-\n-impl SourceFileItems {\n-    fn new(file_id: FileId) -> SourceFileItems {\n-        SourceFileItems {\n-            file_id,\n-            arena: Arena::default(),\n-        }\n-    }\n-\n-    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(item)\n-    }\n-    pub fn id_of(&self, file_id: FileId, item: SyntaxNodeRef) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n-            return id;\n-        }\n-        // This should not happen. Let's try to give a sensible diagnostics.\n-        if let Some((id, i)) = self.arena.iter().find(|(_id, i)| i.range() == item.range()) {\n-            // FIXME(#288): whyyy are we getting here?\n-            log::error!(\n-                \"unequal syntax nodes with the same range:\\n{:?}\\n{:?}\",\n-                item,\n-                i\n-            );\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-    pub fn id_of_source_file(&self) -> SourceFileItemId {\n-        let (id, _syntax) = self.arena.iter().next().unwrap();\n-        id\n-    }\n-}\n-\n-impl Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNode;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n-        &self.arena[idx]\n-    }\n-}"}, {"sha": "b7b75e70221fc54847ab5e470a65c1e4225d6234", "filename": "crates/ra_hir/src/macros.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -0,0 +1,181 @@\n+/// Machinery for macro expansion.\n+///\n+/// One of the more complicated things about macros is managing the source code\n+/// that is produced after expansion. See `HirFileId` and `MacroCallId` for how\n+/// do we do that.\n+///\n+/// When file-management question is resolved, all that is left is a token tree\n+/// to token tree transformation plus hygent. We don't have either of thouse\n+/// yet, so all macros are string based at the moment!\n+use std::sync::Arc;\n+\n+use ra_db::LocalSyntaxPtr;\n+use ra_syntax::{\n+    TextRange, TextUnit, SourceFileNode, AstNode, SyntaxNode,\n+    ast::{self, NameOwner},\n+};\n+\n+use crate::{HirDatabase, MacroCallId};\n+\n+// Hard-coded defs for now :-(\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum MacroDef {\n+    CTry,\n+    QueryGroup,\n+}\n+\n+impl MacroDef {\n+    /// Expands macro call, returning the expansion and offset to be used to\n+    /// convert ranges between expansion and original source.\n+    pub fn ast_expand(macro_call: ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n+        let (def, input) = MacroDef::from_call(macro_call)?;\n+        let exp = def.expand(input)?;\n+        let off = macro_call.token_tree()?.syntax().range().start();\n+        Some((off, exp))\n+    }\n+\n+    fn from_call(macro_call: ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n+        let def = {\n+            let path = macro_call.path()?;\n+            let name_ref = path.segment()?.name_ref()?;\n+            if name_ref.text() == \"ctry\" {\n+                MacroDef::CTry\n+            } else if name_ref.text() == \"query_group\" {\n+                MacroDef::QueryGroup\n+            } else {\n+                return None;\n+            }\n+        };\n+\n+        let input = {\n+            let arg = macro_call.token_tree()?.syntax();\n+            MacroInput {\n+                text: arg.text().to_string(),\n+            }\n+        };\n+        Some((def, input))\n+    }\n+\n+    fn expand(self, input: MacroInput) -> Option<MacroExpansion> {\n+        match self {\n+            MacroDef::CTry => self.expand_ctry(input),\n+            MacroDef::QueryGroup => self.expand_query_group(input),\n+        }\n+    }\n+    fn expand_ctry(self, input: MacroInput) -> Option<MacroExpansion> {\n+        let text = format!(\n+            r\"\n+                fn dummy() {{\n+                    match {} {{\n+                        None => return Ok(None),\n+                        Some(it) => it,\n+                    }}\n+                }}\",\n+            input.text\n+        );\n+        let file = SourceFileNode::parse(&text);\n+        let match_expr = file.syntax().descendants().find_map(ast::MatchExpr::cast)?;\n+        let match_arg = match_expr.expr()?;\n+        let ptr = LocalSyntaxPtr::new(match_arg.syntax());\n+        let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n+        let ranges_map = vec![(src_range, match_arg.syntax().range())];\n+        let res = MacroExpansion {\n+            text,\n+            ranges_map,\n+            ptr,\n+        };\n+        Some(res)\n+    }\n+    fn expand_query_group(self, input: MacroInput) -> Option<MacroExpansion> {\n+        let anchor = \"trait \";\n+        let pos = input.text.find(anchor)? + anchor.len();\n+        let trait_name = input.text[pos..]\n+            .chars()\n+            .take_while(|c| c.is_alphabetic())\n+            .collect::<String>();\n+        if trait_name.is_empty() {\n+            return None;\n+        }\n+        let src_range = TextRange::offset_len((pos as u32).into(), TextUnit::of_str(&trait_name));\n+        let text = format!(r\"trait {} {{ }}\", trait_name);\n+        let file = SourceFileNode::parse(&text);\n+        let trait_def = file.syntax().descendants().find_map(ast::TraitDef::cast)?;\n+        let name = trait_def.name()?;\n+        let ptr = LocalSyntaxPtr::new(trait_def.syntax());\n+        let ranges_map = vec![(src_range, name.syntax().range())];\n+        let res = MacroExpansion {\n+            text,\n+            ranges_map,\n+            ptr,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroInput {\n+    // Should be token trees\n+    pub text: String,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MacroExpansion {\n+    /// The result of macro expansion. Should be token tree as well.\n+    text: String,\n+    /// Correspondence between ranges in the original source code and ranges in\n+    /// the macro.\n+    ranges_map: Vec<(TextRange, TextRange)>,\n+    /// Implementation detail: internally, a macro is expanded to the whole file,\n+    /// even if it is an expression. This `ptr` selects the actual expansion from\n+    /// the expanded file.\n+    ptr: LocalSyntaxPtr,\n+}\n+\n+impl MacroExpansion {\n+    // FIXME: does not really make sense, macro expansion is not neccessary a\n+    // whole file. See `MacroExpansion::ptr` as well.\n+    pub(crate) fn file(&self) -> SourceFileNode {\n+        SourceFileNode::parse(&self.text)\n+    }\n+\n+    pub fn syntax(&self) -> SyntaxNode {\n+        self.ptr.resolve(&self.file())\n+    }\n+    /// Maps range in the source code to the range in the expanded code.\n+    pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n+        for (s_range, t_range) in self.ranges_map.iter() {\n+            if src_range.is_subrange(&s_range) {\n+                let src_at_zero_range = src_range - src_range.start();\n+                let src_range_offset = src_range.start() - s_range.start();\n+                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n+                return Some(src_range);\n+            }\n+        }\n+        None\n+    }\n+    /// Maps range in the expanded code to the range in the source code.\n+    pub fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n+        for (s_range, t_range) in self.ranges_map.iter() {\n+            if tgt_range.is_subrange(&t_range) {\n+                let tgt_at_zero_range = tgt_range - tgt_range.start();\n+                let tgt_range_offset = tgt_range.start() - t_range.start();\n+                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n+                return Some(src_range);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+pub(crate) fn expand_macro_invocation(\n+    db: &impl HirDatabase,\n+    invoc: MacroCallId,\n+) -> Option<Arc<MacroExpansion>> {\n+    let loc = invoc.loc(db);\n+    let syntax = db.file_item(loc.source_item_id);\n+    let syntax = syntax.borrowed();\n+    let macro_call = ast::MacroCall::cast(syntax).unwrap();\n+\n+    let (def, input) = MacroDef::from_call(macro_call)?;\n+    def.expand(input).map(Arc::new)\n+}"}, {"sha": "89b18194ac0f8402b8cde1feaa0b1df1eff7d166", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -6,7 +6,7 @@ use ra_db::{LocationIntener, BaseDatabase, FilePosition, FileId, CrateGraph, Sou\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n-use crate::{db, DefId, DefLoc};\n+use crate::{db, DefId, DefLoc, MacroCallId, MacroCallLoc};\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n@@ -95,6 +95,7 @@ impl MockDatabase {\n #[derive(Debug, Default)]\n struct IdMaps {\n     defs: LocationIntener<DefLoc, DefId>,\n+    macros: LocationIntener<MacroCallLoc, MacroCallId>,\n }\n \n impl salsa::Database for MockDatabase {\n@@ -144,6 +145,11 @@ impl AsRef<LocationIntener<DefLoc, DefId>> for MockDatabase {\n         &self.id_maps.defs\n     }\n }\n+impl AsRef<LocationIntener<MacroCallLoc, MacroCallId>> for MockDatabase {\n+    fn as_ref(&self) -> &LocationIntener<MacroCallLoc, MacroCallId> {\n+        &self.id_maps.macros\n+    }\n+}\n \n impl MockDatabase {\n     pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n@@ -183,6 +189,8 @@ salsa::database_storage! {\n             fn file_lines() for ra_db::FileLinesQuery;\n         }\n         impl db::HirDatabase {\n+            fn hir_source_file() for db::HirSourceFileQuery;\n+            fn expand_macro_invocation() for db::ExpandMacroCallQuery;\n             fn module_tree() for db::ModuleTreeQuery;\n             fn fn_scopes() for db::FnScopesQuery;\n             fn file_items() for db::SourceFileItemsQuery;"}, {"sha": "26171d27c39b6a0e45c3db20380806091c6f2ebe", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -15,6 +15,7 @@ use relative_path::RelativePathBuf;\n use crate::{\n     Def, DefKind, DefLoc, DefId,\n     Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n+    HirFileId,\n     arena::{Arena, Id},\n };\n \n@@ -48,13 +49,17 @@ impl Module {\n     /// Returns `None` for the root module\n     pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n         let link = self.module_id.parent_link(&self.tree)?;\n-        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n+        let file_id = link\n+            .owner(&self.tree)\n+            .source(&self.tree)\n+            .file_id()\n+            .as_original_file();\n         let src = link.bind_source(&self.tree, db);\n         Some((file_id, src))\n     }\n \n-    pub fn source(&self) -> ModuleSource {\n-        self.module_id.source(&self.tree)\n+    pub fn file_id(&self) -> FileId {\n+        self.source().file_id().as_original_file()\n     }\n \n     /// Parent module. Returns `None` if this is a root module.\n@@ -69,7 +74,7 @@ impl Module {\n     /// Returns the crate this module is part of.\n     pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n         let root_id = self.module_id.crate_root(&self.tree);\n-        let file_id = root_id.source(&self.tree).file_id();\n+        let file_id = root_id.source(&self.tree).file_id().as_original_file();\n         let crate_graph = db.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n         Some(Crate::new(crate_id))\n@@ -162,6 +167,10 @@ impl Module {\n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }\n+\n+    pub(crate) fn source(&self) -> ModuleSource {\n+        self.module_id.source(&self.tree)\n+    }\n }\n \n /// Physically, rust source is organized as a set of files, but logically it is\n@@ -291,18 +300,18 @@ pub struct ModuleData {\n \n impl ModuleSource {\n     // precondition: item_id **must** point to module\n-    fn new(file_id: FileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n+    fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n         let source_item_id = SourceItemId { file_id, item_id };\n         ModuleSource(source_item_id)\n     }\n \n-    pub(crate) fn new_file(file_id: FileId) -> ModuleSource {\n+    pub(crate) fn new_file(file_id: HirFileId) -> ModuleSource {\n         ModuleSource::new(file_id, None)\n     }\n \n     pub(crate) fn new_inline(\n         db: &impl HirDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n         m: ast::Module,\n     ) -> ModuleSource {\n         assert!(!m.has_semi());\n@@ -311,7 +320,7 @@ impl ModuleSource {\n         ModuleSource::new(file_id, Some(item_id))\n     }\n \n-    pub fn file_id(self) -> FileId {\n+    pub(crate) fn file_id(self) -> HirFileId {\n         self.0.file_id\n     }\n "}, {"sha": "3849026dbdd7a745ccee4a1a840c019ec6d156b3", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -64,7 +64,7 @@ fn create_module_tree<'a>(\n \n     let source_root = db.source_root(source_root);\n     for &file_id in source_root.files.values() {\n-        let source = ModuleSource::new_file(file_id);\n+        let source = ModuleSource::new_file(file_id.into());\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n         }\n@@ -123,7 +123,7 @@ fn build_subtree(\n                             visited,\n                             roots,\n                             Some(link),\n-                            ModuleSource::new_file(file_id),\n+                            ModuleSource::new_file(file_id.into()),\n                         ),\n                     })\n                     .collect::<Cancelable<Vec<_>>>()?;\n@@ -155,7 +155,7 @@ fn resolve_submodule(\n     name: &Name,\n ) -> (Vec<FileId>, Option<Problem>) {\n     // FIXME: handle submodules of inline modules properly\n-    let file_id = source.file_id();\n+    let file_id = source.file_id().original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n     let root = RelativePathBuf::default();"}, {"sha": "40aa33ffa7c939603855e6d06bde335f2826348f", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -22,10 +22,10 @@ use ra_syntax::{\n     SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n-use ra_db::SourceRootId;\n+use ra_db::{SourceRootId, Cancelable, FileId};\n \n use crate::{\n-    Cancelable, FileId,\n+    HirFileId,\n     DefId, DefLoc, DefKind,\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n@@ -70,7 +70,7 @@ pub struct InputModuleItems {\n \n #[derive(Debug, PartialEq, Eq)]\n struct ModuleItem {\n-    id: SourceFileItemId,\n+    id: SourceItemId,\n     name: Name,\n     kind: SyntaxKind,\n     vis: Vis,\n@@ -95,9 +95,11 @@ pub struct NamedImport {\n }\n \n impl NamedImport {\n+    // FIXME: this is only here for one use-case in completion. Seems like a\n+    // pretty gross special case.\n     pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n         let source_item_id = SourceItemId {\n-            file_id,\n+            file_id: file_id.into(),\n             item_id: Some(self.file_item_id),\n         };\n         let syntax = db.file_item(source_item_id);\n@@ -209,34 +211,44 @@ impl<T> PerNs<T> {\n }\n \n impl InputModuleItems {\n-    pub(crate) fn new<'a>(\n+    pub(crate) fn add_item(\n+        &mut self,\n+        file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        items: impl Iterator<Item = ast::ModuleItem<'a>>,\n-    ) -> InputModuleItems {\n-        let mut res = InputModuleItems::default();\n-        for item in items {\n-            res.add_item(file_items, item);\n-        }\n-        res\n-    }\n-\n-    fn add_item(&mut self, file_items: &SourceFileItems, item: ast::ModuleItem) -> Option<()> {\n+        item: ast::ModuleItem,\n+    ) -> Option<()> {\n         match item {\n-            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::StructDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::EnumDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::FnDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::TraitDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::TypeDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n             ast::ModuleItem::ImplItem(_) => {\n                 // impls don't define items\n             }\n             ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n             ast::ModuleItem::ExternCrateItem(_) => {\n                 // TODO\n             }\n-            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::ConstDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::StaticDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItem::Module(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n         }\n         Some(())\n     }\n@@ -258,11 +270,16 @@ impl InputModuleItems {\n }\n \n impl ModuleItem {\n-    fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n+    fn new<'a>(\n+        file_id: HirFileId,\n+        file_items: &SourceFileItems,\n+        item: impl ast::NameOwner<'a>,\n+    ) -> Option<ModuleItem> {\n         let name = item.name()?.as_name();\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n-        let id = file_items.id_of_unchecked(item.syntax());\n+        let item_id = Some(file_items.id_of_unchecked(item.syntax()));\n+        let id = SourceItemId { file_id, item_id };\n         let res = ModuleItem {\n             id,\n             name,\n@@ -302,7 +319,7 @@ where\n \n     pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n         for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, items)?;\n+            self.populate_module(module_id, Arc::clone(items))?;\n         }\n \n         for &module_id in self.input.keys() {\n@@ -312,17 +329,20 @@ where\n         Ok(self.result)\n     }\n \n-    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) -> Cancelable<()> {\n-        let file_id = module_id.source(&self.module_tree).file_id();\n-\n+    fn populate_module(\n+        &mut self,\n+        module_id: ModuleId,\n+        input: Arc<InputModuleItems>,\n+    ) -> Cancelable<()> {\n         let mut module_items = ModuleScope::default();\n \n         // Populate extern crates prelude\n         {\n             let root_id = module_id.crate_root(&self.module_tree);\n             let file_id = root_id.source(&self.module_tree).file_id();\n             let crate_graph = self.db.crate_graph();\n-            if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id) {\n+            if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id.as_original_file())\n+            {\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n@@ -362,10 +382,7 @@ where\n                     kind: k,\n                     source_root_id: self.source_root,\n                     module_id,\n-                    source_item_id: SourceItemId {\n-                        file_id,\n-                        item_id: Some(item.id),\n-                    },\n+                    source_item_id: item.id,\n                 };\n                 def_loc.id(self.db)\n             });"}, {"sha": "a6a0bea3160e4189e9815aa56179c0f1903801f3", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -77,6 +77,35 @@ fn item_map_smoke_test() {\n     );\n }\n \n+#[test]\n+fn item_map_contains_items_from_expansions() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        salsa::query_group! {\n+            trait Baz {}\n+        }\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t\n+            foo: t\n+        \",\n+    );\n+}\n+\n #[test]\n fn item_map_using_self() {\n     let (item_map, module_id) = item_map(\n@@ -141,6 +170,59 @@ fn item_map_across_crates() {\n \n #[test]\n fn typing_inside_a_function_should_not_invalidate_item_map() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        <|>\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 1 + 1 }\n+            }\n+        }\n+        \",\n+    );\n+    let source_root = db.file_source_root(pos.file_id);\n+    {\n+        let events = db.log_executed(|| {\n+            db.item_map(source_root).unwrap();\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n+    }\n+\n+    let new_text = \"\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 92 }\n+            }\n+        }\n+    \"\n+    .to_string();\n+\n+    db.query_mut(ra_db::FileTextQuery)\n+        .set(pos.file_id, Arc::new(new_text));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            db.item_map(source_root).unwrap();\n+        });\n+        assert!(\n+            !format!(\"{:?}\", events).contains(\"item_map\"),\n+            \"{:#?}\",\n+            events\n+        )\n+    }\n+}\n+\n+#[test]\n+fn typing_inside_a_function_inside_a_macro_should_not_invalidate_item_map() {\n     let (mut db, pos) = MockDatabase::with_position(\n         \"\n         //- /lib.rs\n@@ -183,7 +265,7 @@ fn typing_inside_a_function_should_not_invalidate_item_map() {\n             db.item_map(source_root).unwrap();\n         });\n         assert!(\n-            !format!(\"{:?}\", events).contains(\"_item_map\"),\n+            !format!(\"{:?}\", events).contains(\"item_map\"),\n             \"{:#?}\",\n             events\n         )"}, {"sha": "a5d99bedae3ab34181989263414a94c75eba2009", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -8,10 +8,11 @@ use ra_syntax::{\n     AstNode, SyntaxNode,\n     ast::{self, NameOwner, ModuleItemOwner}\n };\n-use ra_db::{SourceRootId, FileId, Cancelable,};\n+use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName, HirFileId,\n+    MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n     module::{\n@@ -47,25 +48,17 @@ pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<\n     Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n }\n \n-pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n-    let mut res = SourceFileItems::new(file_id);\n-    let source_file = db.source_file(file_id);\n+pub(super) fn file_items(db: &impl HirDatabase, file_id: HirFileId) -> Arc<SourceFileItems> {\n+    let source_file = db.hir_source_file(file_id);\n     let source_file = source_file.borrowed();\n-    source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::ModuleItem::cast)\n-        .map(|it| it.syntax().owned())\n-        .for_each(|it| {\n-            res.alloc(it);\n-        });\n+    let res = SourceFileItems::new(file_id, source_file);\n     Arc::new(res)\n }\n \n pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n     match source_item_id.item_id {\n         Some(id) => db.file_items(source_item_id.file_id)[id].clone(),\n-        None => db.source_file(source_item_id.file_id).syntax().owned(),\n+        None => db.hir_source_file(source_item_id.file_id).syntax().owned(),\n     }\n }\n \n@@ -87,7 +80,7 @@ pub(crate) fn submodules(\n \n     fn collect_submodules<'a>(\n         db: &impl HirDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n         root: impl ast::ModuleItemOwner<'a>,\n     ) -> Vec<Submodule> {\n         modules(root)\n@@ -119,24 +112,48 @@ pub(crate) fn modules<'a>(\n \n pub(super) fn input_module_items(\n     db: &impl HirDatabase,\n-    source_root: SourceRootId,\n+    source_root_id: SourceRootId,\n     module_id: ModuleId,\n ) -> Cancelable<Arc<InputModuleItems>> {\n-    let module_tree = db.module_tree(source_root)?;\n+    let module_tree = db.module_tree(source_root_id)?;\n     let source = module_id.source(&module_tree);\n-    let file_items = db.file_items(source.file_id());\n-    let res = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => {\n-            let items = it.borrowed().items();\n-            InputModuleItems::new(&file_items, items)\n+    let file_id = source.file_id();\n+    let file_items = db.file_items(file_id);\n+    let fill = |acc: &mut InputModuleItems, items: &mut Iterator<Item = ast::ItemOrMacro>| {\n+        for item in items {\n+            match item {\n+                ast::ItemOrMacro::Item(it) => {\n+                    acc.add_item(file_id, &file_items, it);\n+                }\n+                ast::ItemOrMacro::Macro(macro_call) => {\n+                    let item_id = file_items.id_of_unchecked(macro_call.syntax());\n+                    let loc = MacroCallLoc {\n+                        source_root_id,\n+                        module_id,\n+                        source_item_id: SourceItemId {\n+                            file_id,\n+                            item_id: Some(item_id),\n+                        },\n+                    };\n+                    let id = loc.id(db);\n+                    let file_id = HirFileId::from(id);\n+                    let file_items = db.file_items(file_id);\n+                    //FIXME: expand recursively\n+                    for item in db.hir_source_file(file_id).borrowed().items() {\n+                        acc.add_item(file_id, &file_items, item);\n+                    }\n+                }\n+            }\n         }\n+    };\n+\n+    let mut res = InputModuleItems::default();\n+    match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => fill(&mut res, &mut it.borrowed().items_with_macros()),\n         ModuleSourceNode::Module(it) => {\n-            let items = it\n-                .borrowed()\n-                .item_list()\n-                .into_iter()\n-                .flat_map(|it| it.items());\n-            InputModuleItems::new(&file_items, items)\n+            if let Some(item_list) = it.borrowed().item_list() {\n+                fill(&mut res, &mut item_list.items_with_macros())\n+            }\n         }\n     };\n     Ok(Arc::new(res))"}, {"sha": "24490d119c73e5e267eaa13a6418c6a445b797c4", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -20,7 +20,7 @@ use crate::{\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable<Option<Module>> {\n-    let module_source = ModuleSource::new_file(file_id);\n+    let module_source = ModuleSource::new_file(file_id.into());\n     module_from_source(db, module_source)\n }\n \n@@ -50,8 +50,8 @@ pub fn module_from_position(\n ) -> Cancelable<Option<Module>> {\n     let file = db.source_file(position.file_id);\n     let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n-        _ => ModuleSource::new_file(position.file_id),\n+        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id.into(), m),\n+        _ => ModuleSource::new_file(position.file_id.into()),\n     };\n     module_from_source(db, module_source)\n }\n@@ -67,9 +67,9 @@ pub fn module_from_child_node(\n         .filter_map(ast::Module::cast)\n         .find(|it| !it.has_semi())\n     {\n-        ModuleSource::new_inline(db, file_id, m)\n+        ModuleSource::new_inline(db, file_id.into(), m)\n     } else {\n-        ModuleSource::new_file(file_id)\n+        ModuleSource::new_file(file_id.into())\n     };\n     module_from_source(db, module_source)\n }\n@@ -78,7 +78,7 @@ fn module_from_source(\n     db: &impl HirDatabase,\n     module_source: ModuleSource,\n ) -> Cancelable<Option<Module>> {\n-    let source_root_id = db.file_source_root(module_source.file_id());\n+    let source_root_id = db.file_source_root(module_source.file_id().as_original_file());\n     let module_tree = db.module_tree(source_root_id)?;\n     let m = module_tree\n         .modules_with_sources()"}, {"sha": "3e948800ede9a9f8c9e8b2a8e63ff19b40c57db6", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -48,10 +48,40 @@ pub trait FnDefOwner<'a>: AstNode<'a> {\n     }\n }\n \n+// ModuleItem\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ItemOrMacro<'a> {\n+    Item(ModuleItem<'a>),\n+    Macro(MacroCall<'a>),\n+}\n+\n+impl<'a> AstNode<'a> for ItemOrMacro<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        let res = if let Some(item) = ModuleItem::cast(syntax) {\n+            ItemOrMacro::Item(item)\n+        } else if let Some(macro_call) = MacroCall::cast(syntax) {\n+            ItemOrMacro::Macro(macro_call)\n+        } else {\n+            return None;\n+        };\n+        Some(res)\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n+        match self {\n+            ItemOrMacro::Item(it) => it.syntax(),\n+            ItemOrMacro::Macro(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n pub trait ModuleItemOwner<'a>: AstNode<'a> {\n     fn items(self) -> AstChildren<'a, ModuleItem<'a>> {\n         children(self)\n     }\n+\n+    fn items_with_macros(self) -> AstChildren<'a, ItemOrMacro<'a>> {\n+        children(self)\n+    }\n }\n \n pub trait TypeParamsOwner<'a>: AstNode<'a> {"}, {"sha": "6753c513f3ed08d05e40b82d0712d597160c4bf1", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -51,7 +51,7 @@ use ra_text_edit::AtomTextEdit;\n use crate::yellow::GreenNode;\n \n /// `SourceFileNode` represents a parse tree for a single Rust file.\n-pub use crate::ast::SourceFileNode;\n+pub use crate::ast::{SourceFile, SourceFileNode};\n \n impl SourceFileNode {\n     fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SourceFileNode {"}]}