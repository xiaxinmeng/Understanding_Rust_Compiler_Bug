{"sha": "18f3be7704a4ec7976fcd1272c728974243d29bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZjNiZTc3MDRhNGVjNzk3NmZjZDEyNzJjNzI4OTc0MjQzZDI5YmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T20:08:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T20:08:50Z"}, "message": "Auto merge of #75278 - cuviper:indexmap, r=Mark-Simulacrum\n\nUpgrade indexmap and use it more\n\nFirst this upgrades `indexmap` to 1.5.1, which is now based on `hashbrown::raw::RawTable`. This means it shares a lot of the same performance characteristics for insert, lookup, etc., while keeping items in insertion order.\n\nThen across various rustc crates, this replaces a lot of `Vec`+`HashMap` pairs with a single `IndexMap` or `IndexSet`.\n\nCloses #60608.\nr? @eddyb", "tree": {"sha": "8d1f3d2e296e7b27e17ab74ca450c32132683002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1f3d2e296e7b27e17ab74ca450c32132683002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f3be7704a4ec7976fcd1272c728974243d29bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f3be7704a4ec7976fcd1272c728974243d29bd", "html_url": "https://github.com/rust-lang/rust/commit/18f3be7704a4ec7976fcd1272c728974243d29bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f3be7704a4ec7976fcd1272c728974243d29bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39e593ab14c53fda63c3f2756716c5ad3cbb6465", "url": "https://api.github.com/repos/rust-lang/rust/commits/39e593ab14c53fda63c3f2756716c5ad3cbb6465", "html_url": "https://github.com/rust-lang/rust/commit/39e593ab14c53fda63c3f2756716c5ad3cbb6465"}, {"sha": "ca0b89aa040acf5df95d39579cbd7ff03c73baf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0b89aa040acf5df95d39579cbd7ff03c73baf1", "html_url": "https://github.com/rust-lang/rust/commit/ca0b89aa040acf5df95d39579cbd7ff03c73baf1"}], "stats": {"total": 337, "additions": 144, "deletions": 193}, "files": [{"sha": "2685de2244e9414f7bb5134bc0dff7d00b3b030a", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -1382,9 +1382,13 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.0.2\"\n+version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n+checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n \n [[package]]\n name = \"installer\""}, {"sha": "b50b3b6d975c5e3daf144ea8d719d580f98fdbee", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -6,7 +6,7 @@ use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n \n use std::ffi::CString;\n@@ -76,13 +76,12 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n }\n \n struct CoverageMapGenerator {\n-    filenames: Vec<CString>,\n-    filename_to_index: FxHashMap<CString, u32>,\n+    filenames: FxIndexSet<CString>,\n }\n \n impl CoverageMapGenerator {\n     fn new() -> Self {\n-        Self { filenames: Vec::new(), filename_to_index: FxHashMap::default() }\n+        Self { filenames: FxIndexSet::default() }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n@@ -122,16 +121,8 @@ impl CoverageMapGenerator {\n                 let c_filename =\n                     CString::new(file_name).expect(\"null error converting filename to C string\");\n                 debug!(\"  file_id: {} = '{:?}'\", current_file_id, c_filename);\n-                let filenames_index = match self.filename_to_index.get(&c_filename) {\n-                    Some(index) => *index,\n-                    None => {\n-                        let index = self.filenames.len() as u32;\n-                        self.filenames.push(c_filename.clone());\n-                        self.filename_to_index.insert(c_filename.clone(), index);\n-                        index\n-                    }\n-                };\n-                virtual_file_mapping.push(filenames_index);\n+                let (filenames_index, _) = self.filenames.insert_full(c_filename);\n+                virtual_file_mapping.push(filenames_index as u32);\n             }\n             mapping_regions.push(CounterMappingRegion::code_region(\n                 counter,"}, {"sha": "90831f0bcfbeebe6ce2c4f15d549b6e57ae80985", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -97,8 +97,11 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer: &RustString) {\n-    let c_str_vec = filenames.iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n+pub(crate) fn write_filenames_section_to_buffer<'a>(\n+    filenames: impl IntoIterator<Item = &'a CString>,\n+    buffer: &RustString,\n+) {\n+    let c_str_vec = filenames.into_iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n     unsafe {\n         llvm::LLVMRustCoverageWriteFilenamesSectionToBuffer(\n             c_str_vec.as_ptr(),"}, {"sha": "d0dbad5d2afe599658ec47b274745af867c5532f", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n ena = \"0.14\"\n-indexmap = \"1\"\n+indexmap = \"1.5.1\"\n log = { package = \"tracing\", version = \"0.1\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\""}, {"sha": "7d137a55033f7ac89ee6e3a038c3f78a1c451b5f", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -1,4 +1,4 @@\n-use crate::fx::FxHashMap;\n+use crate::fx::FxIndexSet;\n use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n@@ -13,10 +13,7 @@ mod tests;\n #[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Eq + Hash> {\n     // List of elements. This is used to map from a T to a usize.\n-    elements: Vec<T>,\n-\n-    // Maps each element to an index.\n-    map: FxHashMap<T, Index>,\n+    elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n@@ -39,7 +36,6 @@ impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     fn default() -> Self {\n         TransitiveRelation {\n             elements: Default::default(),\n-            map: Default::default(),\n             edges: Default::default(),\n             closure: Default::default(),\n         }\n@@ -65,20 +61,16 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.map.get(a).cloned()\n+        self.elements.get_index_of(a).map(Index)\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let &mut TransitiveRelation { ref mut elements, ref mut closure, ref mut map, .. } = self;\n-\n-        *map.entry(a.clone()).or_insert_with(|| {\n-            elements.push(a);\n-\n+        let (index, added) = self.elements.insert_full(a);\n+        if added {\n             // if we changed the dimensions, clear the cache\n-            *closure.get_mut() = None;\n-\n-            Index(elements.len() - 1)\n-        })\n+            *self.closure.get_mut() = None;\n+        }\n+        Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n@@ -430,14 +422,11 @@ where\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n-            let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            let map = elements\n-                .iter()\n-                .enumerate()\n-                .map(|(index, elem)| (elem.clone(), Index(index)))\n-                .collect();\n-            Ok(TransitiveRelation { elements, edges, map, closure: Lock::new(None) })\n+            Ok(TransitiveRelation {\n+                elements: d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?,\n+                edges: d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?,\n+                closure: Lock::new(None),\n+            })\n         })\n     }\n }\n@@ -452,8 +441,6 @@ where\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n-            // \"map\" is just a copy of elements vec\n-            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _,\n         } = *self;"}, {"sha": "6723e236a1fe981e0fb9a9b022eb457231183eb9", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -4,7 +4,7 @@ use crate::rmeta::*;\n use log::{debug, trace};\n use rustc_ast::ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n@@ -48,8 +48,7 @@ struct EncodeContext<'a, 'tcx> {\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n-    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n-    interpret_allocs_inverse: Vec<interpret::AllocId>,\n+    interpret_allocs: FxIndexSet<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n     // The `usize` is an index into the `MonotonicVec`\n@@ -331,17 +330,7 @@ impl<'a, 'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'a, '\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        use std::collections::hash_map::Entry;\n-        let index = match self.interpret_allocs.entry(*alloc_id) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                let idx = self.interpret_allocs_inverse.len();\n-                self.interpret_allocs_inverse.push(*alloc_id);\n-                e.insert(idx);\n-                idx\n-            }\n-        };\n-\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n         index.encode(self)\n     }\n }\n@@ -583,15 +572,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let mut n = 0;\n             trace!(\"beginning to encode alloc ids\");\n             loop {\n-                let new_n = self.interpret_allocs_inverse.len();\n+                let new_n = self.interpret_allocs.len();\n                 // if we have found new ids, serialize those, too\n                 if n == new_n {\n                     // otherwise, abort\n                     break;\n                 }\n                 trace!(\"encoding {} further alloc ids\", new_n - n);\n                 for idx in n..new_n {\n-                    let id = self.interpret_allocs_inverse[idx];\n+                    let id = self.interpret_allocs[idx];\n                     let pos = self.position() as u32;\n                     interpret_alloc_index.push(pos);\n                     interpret::specialized_encode_alloc_id(self, tcx, id).unwrap();\n@@ -2019,7 +2008,6 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         predicate_shorthands: Default::default(),\n         source_file_cache: (source_map_files[0].clone(), 0),\n         interpret_allocs: Default::default(),\n-        interpret_allocs_inverse: Default::default(),\n         required_source_files: Some(GrowableBitSet::with_capacity(source_map_files.len())),\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,"}, {"sha": "08b0bfecf49099ec0642a466c1e3d4c80fdc8dec", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -5,7 +5,7 @@ use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n@@ -212,7 +212,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n-                interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n                 hygiene_context: &hygiene_encode_context,\n@@ -267,15 +266,15 @@ impl<'sess> OnDiskCache<'sess> {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n-                    let new_n = encoder.interpret_allocs_inverse.len();\n+                    let new_n = encoder.interpret_allocs.len();\n                     // If we have found new IDs, serialize those too.\n                     if n == new_n {\n                         // Otherwise, abort.\n                         break;\n                     }\n                     interpret_alloc_index.reserve(new_n - n);\n                     for idx in n..new_n {\n-                        let id = encoder.interpret_allocs_inverse[idx];\n+                        let id = encoder.interpret_allocs[idx];\n                         let pos = encoder.position() as u32;\n                         interpret_alloc_index.push(pos);\n                         interpret::specialized_encode_alloc_id(&mut encoder, tcx, id)?;\n@@ -767,8 +766,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n-    interpret_allocs_inverse: Vec<interpret::AllocId>,\n+    interpret_allocs: FxIndexSet<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n     hygiene_context: &'a HygieneEncodeContext,\n@@ -807,17 +805,7 @@ where\n     E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        use std::collections::hash_map::Entry;\n-        let index = match self.interpret_allocs.entry(*alloc_id) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                let idx = self.interpret_allocs_inverse.len();\n-                self.interpret_allocs_inverse.push(*alloc_id);\n-                e.insert(idx);\n-                idx\n-            }\n-        };\n-\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n         index.encode(self)\n     }\n }"}, {"sha": "b4299fbc5a1fe8128e5710c8cfb742d3d6095526", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -3,9 +3,8 @@ use crate::borrow_check::path_utils::allow_two_phase_borrow;\n use crate::borrow_check::place_ext::PlaceExt;\n use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Body, Local, Location};\n@@ -15,14 +14,11 @@ use std::ops::Index;\n \n crate struct BorrowSet<'tcx> {\n     /// The fundamental map relating bitvector indexes to the borrows\n-    /// in the MIR.\n-    crate borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-\n-    /// Each borrow is also uniquely identified in the MIR by the\n-    /// `Location` of the assignment statement in which it appears on\n-    /// the right hand side; we map each such location to the\n-    /// corresponding `BorrowIndex`.\n-    crate location_map: FxHashMap<Location, BorrowIndex>,\n+    /// in the MIR. Each borrow is also uniquely identified in the MIR\n+    /// by the `Location` of the assignment statement in which it\n+    /// appears on the right hand side. Thus the location is the map\n+    /// key, and its position in the map corresponds to `BorrowIndex`.\n+    crate location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n \n     /// Locations which activate borrows.\n     /// NOTE: a given location may activate more than one borrow in the future\n@@ -40,7 +36,7 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     type Output = BorrowData<'tcx>;\n \n     fn index(&self, index: BorrowIndex) -> &BorrowData<'tcx> {\n-        &self.borrows[index]\n+        &self.location_map[index.as_usize()]\n     }\n }\n \n@@ -129,7 +125,6 @@ impl<'tcx> BorrowSet<'tcx> {\n         let mut visitor = GatherBorrows {\n             tcx,\n             body: &body,\n-            idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n             local_map: Default::default(),\n@@ -146,7 +141,6 @@ impl<'tcx> BorrowSet<'tcx> {\n         }\n \n         BorrowSet {\n-            borrows: visitor.idx_vec,\n             location_map: visitor.location_map,\n             activation_map: visitor.activation_map,\n             local_map: visitor.local_map,\n@@ -157,13 +151,32 @@ impl<'tcx> BorrowSet<'tcx> {\n     crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n         self.activation_map.get(&location).map(|activations| &activations[..]).unwrap_or(&[])\n     }\n+\n+    crate fn len(&self) -> usize {\n+        self.location_map.len()\n+    }\n+\n+    crate fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n+        BorrowIndex::from_usize(0)..BorrowIndex::from_usize(self.len())\n+    }\n+\n+    crate fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n+        self.indices().zip(self.location_map.values())\n+    }\n+\n+    crate fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n+        self.location_map.get_index_of(location).map(BorrowIndex::from)\n+    }\n+\n+    crate fn contains(&self, location: &Location) -> bool {\n+        self.location_map.contains_key(location)\n+    }\n }\n \n struct GatherBorrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-    location_map: FxHashMap<Location, BorrowIndex>,\n+    location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n@@ -203,8 +216,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 borrowed_place: *borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n-            let idx = self.idx_vec.push(borrow);\n-            self.location_map.insert(location, idx);\n+            let (idx, _) = self.location_map.insert_full(location, borrow);\n+            let idx = BorrowIndex::from(idx);\n \n             self.insert_as_pending_if_two_phase(location, assigned_place, kind, idx);\n \n@@ -224,7 +237,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         //\n         //     TMP = &mut place\n         if let Some(&borrow_index) = self.pending_activations.get(temp) {\n-            let borrow_data = &mut self.idx_vec[borrow_index];\n+            let borrow_data = &mut self.location_map[borrow_index.as_usize()];\n \n             // Watch out: the use of TMP in the borrow itself\n             // doesn't count as an activation. =)\n@@ -265,8 +278,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n             // double-check that we already registered a BorrowData for this\n \n-            let borrow_index = self.location_map[&location];\n-            let borrow_data = &self.idx_vec[borrow_index];\n+            let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n@@ -316,7 +328,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         // Consider the borrow not activated to start. When we find an activation, we'll update\n         // this field.\n         {\n-            let borrow_data = &mut self.idx_vec[borrow_index];\n+            let borrow_data = &mut self.location_map[borrow_index.as_usize()];\n             borrow_data.activation_location = TwoPhaseActivation::NotActivated;\n         }\n \n@@ -332,7 +344,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n                        at borrow_index: {:?} with associated data {:?}\",\n                 temp,\n                 old_index,\n-                self.idx_vec[old_index]\n+                self.location_map[old_index.as_usize()]\n             );\n         }\n     }"}, {"sha": "33b09dcb888ed680cfa676663cd5010b850e35da", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -217,7 +217,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n                                 self.body,\n-                                self.borrow_set.borrows[borrow_index].borrowed_place,\n+                                self.borrow_set[borrow_index].borrowed_place,\n                                 place,\n                                 places_conflict::PlaceConflictBias::NoOverlap,\n                             );"}, {"sha": "2de2124dc5e0eaab2cc85e6590422bc2f06ec330", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -166,8 +166,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n                 let resume = self.location_table.start_index(resume.start_location());\n-                for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n+                for (i, data) in borrow_set.iter_enumerated() {\n+                    if borrow_of_local_data(data.borrowed_place) {\n                         self.all_facts.invalidates.push((resume, i));\n                     }\n                 }\n@@ -178,8 +178,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n                 let start = self.location_table.start_index(location);\n-                for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n+                for (i, data) in borrow_set.iter_enumerated() {\n+                    if borrow_of_local_data(data.borrowed_place) {\n                         self.all_facts.invalidates.push((start, i));\n                     }\n                 }\n@@ -369,7 +369,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         let tcx = self.tcx;\n         let body = self.body;\n         let borrow_set = self.borrow_set.clone();\n-        let indices = self.borrow_set.borrows.indices();\n+        let indices = self.borrow_set.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,"}, {"sha": "6e211b42a052ee36575f983a59931655fa14e334", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -1131,11 +1131,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 (\n                     Reservation(WriteKind::MutableBorrow(bk)),\n                     BorrowKind::Shallow | BorrowKind::Shared,\n-                ) if {\n-                    tcx.migrate_borrowck() && this.borrow_set.location_map.contains_key(&location)\n-                } =>\n-                {\n-                    let bi = this.borrow_set.location_map[&location];\n+                ) if { tcx.migrate_borrowck() && this.borrow_set.contains(&location) } => {\n+                    let bi = this.borrow_set.get_index_of(&location).unwrap();\n                     debug!(\n                         \"recording invalid reservation of place: {:?} with \\\n                          borrow index {:?} as warning\","}, {"sha": "66a17cba6bb010b225a28b8d651531fbb3c0112c", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -206,7 +206,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         //   the `borrow_set`, their `BorrowIndex` are synthesized as the universal region index\n         //   added to the existing number of loans, as if they succeeded them in the set.\n         //\n-        let borrow_count = borrow_set.borrows.len();\n+        let borrow_count = borrow_set.len();\n         debug!(\n             \"compute_regions: polonius placeholders, num_universals={}, borrow_count={}\",\n             universal_regions.len(),"}, {"sha": "8a5a600cfdd8a76863167cc4e1dda98412b7e019", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n@@ -193,26 +193,25 @@ impl<N: Idx> LivenessValues<N> {\n /// NLL.\n #[derive(Default)]\n crate struct PlaceholderIndices {\n-    to_index: FxHashMap<ty::PlaceholderRegion, PlaceholderIndex>,\n-    from_index: IndexVec<PlaceholderIndex, ty::PlaceholderRegion>,\n+    indices: FxIndexSet<ty::PlaceholderRegion>,\n }\n \n impl PlaceholderIndices {\n     crate fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n-        let PlaceholderIndices { to_index, from_index } = self;\n-        *to_index.entry(placeholder).or_insert_with(|| from_index.push(placeholder))\n+        let (index, _) = self.indices.insert_full(placeholder);\n+        index.into()\n     }\n \n     crate fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n-        self.to_index[&placeholder]\n+        self.indices.get_index_of(&placeholder).unwrap().into()\n     }\n \n     crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::PlaceholderRegion {\n-        self.from_index[placeholder]\n+        self.indices[placeholder.index()]\n     }\n \n     crate fn len(&self) -> usize {\n-        self.from_index.len()\n+        self.indices.len()\n     }\n }\n "}, {"sha": "ff98de5475ecff8076a2b9b64ccc64568d834466", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -2469,11 +2469,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // example).\n         if let Some(all_facts) = all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n-            if let Some(borrow_index) = borrow_set.location_map.get(&location) {\n+            if let Some(borrow_index) = borrow_set.get_index_of(&location) {\n                 let region_vid = borrow_region.to_region_vid();\n                 all_facts.borrow_region.push((\n                     region_vid,\n-                    *borrow_index,\n+                    borrow_index,\n                     location_table.mid_index(location),\n                 ));\n             }"}, {"sha": "7e7b7f2cc76fae2849c7db753683a930a49cf2ad", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -136,9 +136,9 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n         let mut borrows_out_of_scope_at_location = FxHashMap::default();\n-        for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n+        for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n-            let location = borrow_set.borrows[borrow_index].reserve_location;\n+            let location = borrow_data.reserve_location;\n \n             precompute_borrows_out_of_scope(\n                 body,\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n-        &self.borrow_set.borrows[idx].reserve_location\n+        &self.borrow_set[idx].reserve_location\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n-                self.borrow_set.borrows[i].borrowed_place,\n+                self.borrow_set[i].borrowed_place,\n                 place,\n                 PlaceConflictBias::NoOverlap,\n             )\n@@ -232,7 +232,7 @@ impl<'tcx> dataflow::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     const NAME: &'static str = \"borrows\";\n \n     fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.borrow_set.borrows.len() * 2\n+        self.borrow_set.len() * 2\n     }\n \n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n@@ -271,11 +271,11 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n                     ) {\n                         return;\n                     }\n-                    let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n+                    let index = self.borrow_set.get_index_of(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n-                    trans.gen(*index);\n+                    trans.gen(index);\n                 }\n \n                 // Make sure there are no remaining borrows for variables"}, {"sha": "5f87cb364b891de29159e869aed9739529ee79d7", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -11,7 +11,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::thir::{self, *};\n use rustc_data_structures::{\n-    fx::{FxHashMap, FxHashSet},\n+    fx::{FxHashSet, FxIndexMap},\n     stack::ensure_sufficient_stack,\n };\n use rustc_hir::HirId;\n@@ -817,9 +817,7 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: Vec<u128>,\n-        /// Reverse map used to ensure that the values in `options` are unique.\n-        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n@@ -1396,14 +1394,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt { switch_ty, ref mut options } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n                         &match_place,\n                         candidate,\n                         switch_ty,\n                         options,\n-                        indices,\n                     ) {\n                         break;\n                     }"}, {"sha": "87977d6fe8904e84a7996150c9ec992c82960e92", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -9,7 +9,7 @@ use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n use crate::thir::*;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::RangeEnd;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n@@ -44,8 +44,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n-                        options: vec![],\n-                        indices: Default::default(),\n+                        options: Default::default(),\n                     },\n                 }\n             }\n@@ -83,8 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut Vec<u128>,\n-        indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> bool {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n             Some(match_pair) => match_pair,\n@@ -95,9 +93,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n-                indices.entry(value).or_insert_with(|| {\n-                    options.push(value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty));\n-                    options.len() - 1\n+                options.entry(value).or_insert_with(|| {\n+                    value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty)\n                 });\n                 true\n             }\n@@ -106,7 +103,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             PatKind::Range(range) => {\n                 // Check that none of the switch values are in the range.\n-                self.values_not_contained_in_range(range, indices).unwrap_or(false)\n+                self.values_not_contained_in_range(range, options).unwrap_or(false)\n             }\n             PatKind::Slice { .. }\n             | PatKind::Array { .. }\n@@ -216,7 +213,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n             }\n \n-            TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n+            TestKind::SwitchInt { switch_ty, ref options } => {\n                 let target_blocks = make_target_blocks(self);\n                 let terminator = if switch_ty.kind == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n@@ -236,7 +233,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n                         switch_ty,\n-                        values: options.clone().into(),\n+                        values: options.values().copied().collect(),\n                         targets: target_blocks,\n                     }\n                 };\n@@ -532,20 +529,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n             (\n-                &TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Constant { ref value },\n             ) if is_switch_ty(match_pair.pattern.ty) => {\n-                let index = indices[value];\n+                let index = options.get_index_of(value).unwrap();\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n             (\n-                &TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Range(range),\n             ) => {\n                 let not_contained =\n-                    self.values_not_contained_in_range(range, indices).unwrap_or(false);\n+                    self.values_not_contained_in_range(range, options).unwrap_or(false);\n \n                 if not_contained {\n                     // No switch values are contained in the pattern range,\n@@ -777,9 +774,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> Option<bool> {\n-        for &val in indices.keys() {\n+        for &val in options.keys() {\n             if self.const_range_contains(range, val)? {\n                 return Some(false);\n             }"}, {"sha": "b05e01d666bd6917e32f4451640c4c4748a7f0ce", "filename": "src/librustc_span/span_encoding.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_span%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_span%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fspan_encoding.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -8,7 +8,7 @@ use crate::hygiene::SyntaxContext;\n use crate::SESSION_GLOBALS;\n use crate::{BytePos, SpanData};\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n \n /// A compressed span.\n ///\n@@ -111,25 +111,18 @@ impl Span {\n \n #[derive(Default)]\n pub struct SpanInterner {\n-    spans: FxHashMap<SpanData, u32>,\n-    span_data: Vec<SpanData>,\n+    spans: FxIndexSet<SpanData>,\n }\n \n impl SpanInterner {\n     fn intern(&mut self, span_data: &SpanData) -> u32 {\n-        if let Some(index) = self.spans.get(span_data) {\n-            return *index;\n-        }\n-\n-        let index = self.spans.len() as u32;\n-        self.span_data.push(*span_data);\n-        self.spans.insert(*span_data, index);\n-        index\n+        let (index, _) = self.spans.insert_full(*span_data);\n+        index as u32\n     }\n \n     #[inline]\n     fn get(&self, index: u32) -> &SpanData {\n-        &self.span_data[index as usize]\n+        &self.spans[index as usize]\n     }\n }\n "}, {"sha": "ca9702784a268a5928662c047016fb4823dae721", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -1481,6 +1481,10 @@ impl<CTX> ToStableHashKey<CTX> for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n+//\n+// The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278\n+// found that to regress performance up to 2% in some cases. This might be\n+// revisited after further improvements to `indexmap`.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,"}, {"sha": "93fdf93e9e3944af3f8d8eecbf5f2dda7e267e46", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -4,7 +4,7 @@\n //! types computed here.\n \n use super::FnCtxt;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -16,7 +16,7 @@ use rustc_span::Span;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    types: FxHashMap<ty::GeneratorInteriorTypeCause<'tcx>, usize>,\n+    types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n@@ -88,18 +88,15 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                     .span_note(yield_data.span, &*note)\n                     .emit();\n             } else {\n-                // Map the type to the number of types added before it\n-                let entries = self.types.len();\n+                // Insert the type into the ordered set.\n                 let scope_span = scope.map(|s| s.span(self.fcx.tcx, self.region_scope_tree));\n-                self.types\n-                    .entry(ty::GeneratorInteriorTypeCause {\n-                        span: source_span,\n-                        ty: &ty,\n-                        scope_span,\n-                        yield_span: yield_data.span,\n-                        expr: expr.map(|e| e.hir_id),\n-                    })\n-                    .or_insert(entries);\n+                self.types.insert(ty::GeneratorInteriorTypeCause {\n+                    span: source_span,\n+                    ty: &ty,\n+                    scope_span,\n+                    yield_span: yield_data.span,\n+                    expr: expr.map(|e| e.hir_id),\n+                });\n             }\n         } else {\n             debug!(\n@@ -132,7 +129,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n-        types: FxHashMap::default(),\n+        types: FxIndexSet::default(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n         expr_count: 0,\n         kind,\n@@ -144,10 +141,8 @@ pub fn resolve_interior<'a, 'tcx>(\n     let region_expr_count = visitor.region_scope_tree.body_expr_count(body_id).unwrap();\n     assert_eq!(region_expr_count, visitor.expr_count);\n \n-    let mut types: Vec<_> = visitor.types.drain().collect();\n-\n-    // Sort types by insertion order\n-    types.sort_by_key(|t| t.1);\n+    // The types are already kept in insertion order.\n+    let types = visitor.types;\n \n     // The types in the generator interior contain lifetimes local to the generator itself,\n     // which should not be exposed outside of the generator. Therefore, we replace these\n@@ -164,7 +159,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     let mut captured_tys = FxHashSet::default();\n     let type_causes: Vec<_> = types\n         .into_iter()\n-        .filter_map(|(mut cause, _)| {\n+        .filter_map(|mut cause| {\n             // Erase regions and canonicalize late-bound regions to deduplicate as many types as we\n             // can.\n             let erased = fcx.tcx.erase_regions(&cause.ty);"}, {"sha": "b47ef34600404c1c7e5d37d48af1fb8fca744eee", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f3be7704a4ec7976fcd1272c728974243d29bd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=18f3be7704a4ec7976fcd1272c728974243d29bd", "patch": "@@ -22,7 +22,7 @@ use rustc_ast::ast;\n use rustc_ast::ast::MetaItemKind;\n use rustc_attr::{list_contains_name, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -1718,21 +1718,17 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     /// A data structure with unique elements, which preserves order of insertion.\n     /// Preserving the order of insertion is important here so as not to break\n     /// compile-fail UI tests.\n-    // FIXME(eddyb) just use `IndexSet` from `indexmap`.\n     struct UniquePredicates<'tcx> {\n-        predicates: Vec<(ty::Predicate<'tcx>, Span)>,\n-        uniques: FxHashSet<(ty::Predicate<'tcx>, Span)>,\n+        predicates: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n     }\n \n     impl<'tcx> UniquePredicates<'tcx> {\n         fn new() -> Self {\n-            UniquePredicates { predicates: vec![], uniques: FxHashSet::default() }\n+            UniquePredicates { predicates: FxIndexSet::default() }\n         }\n \n         fn push(&mut self, value: (ty::Predicate<'tcx>, Span)) {\n-            if self.uniques.insert(value) {\n-                self.predicates.push(value);\n-            }\n+            self.predicates.insert(value);\n         }\n \n         fn extend<I: IntoIterator<Item = (ty::Predicate<'tcx>, Span)>>(&mut self, iter: I) {\n@@ -2014,7 +2010,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }))\n     }\n \n-    let mut predicates = predicates.predicates;\n+    let mut predicates: Vec<_> = predicates.predicates.into_iter().collect();\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come"}]}