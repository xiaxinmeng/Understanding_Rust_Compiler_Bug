{"sha": "af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMDlmNzIwZDYwYzEyMjZiNWQ0MmFhZWUzY2MwYzBlNjdlYmU1Y2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-24T21:14:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:38Z"}, "message": "preliminary support for may-dangle attribute and drop constraints", "tree": {"sha": "18ddf05c453ecff95afca75a105daf853b50846a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ddf05c453ecff95afca75a105daf853b50846a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "html_url": "https://github.com/rust-lang/rust/commit/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02937848b9316d393577171ede62a3423132583", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02937848b9316d393577171ede62a3423132583", "html_url": "https://github.com/rust-lang/rust/commit/e02937848b9316d393577171ede62a3423132583"}], "stats": {"total": 176, "additions": 163, "deletions": 13}, "files": [{"sha": "1e008ec38f22a75df333192765a94d6c1bbdac9e", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 112, "deletions": 12, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "patch": "@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::Mir;\n+use rustc::mir::{Location, Mir};\n+use rustc::mir::transform::MirSource;\n use rustc::infer::InferCtxt;\n+use rustc::traits::{self, ObligationCause};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::codemap::DUMMY_SP;\n \n use super::LivenessResults;\n use super::ToRegionIndex;\n@@ -19,13 +26,15 @@ pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext,\n     mir: &Mir<'tcx>,\n+    mir_source: MirSource,\n     liveness: &LivenessResults,\n ) {\n     ConstraintGeneration {\n         infcx,\n         regioncx,\n         mir,\n         liveness,\n+        mir_source,\n     }.add_constraints();\n }\n \n@@ -34,6 +43,7 @@ struct ConstraintGeneration<'constrain, 'gcx: 'tcx, 'tcx: 'constrain> {\n     regioncx: &'constrain mut RegionInferenceContext,\n     mir: &'constrain Mir<'tcx>,\n     liveness: &'constrain LivenessResults,\n+    mir_source: MirSource,\n }\n \n impl<'constrain, 'gcx, 'tcx> ConstraintGeneration<'constrain, 'gcx, 'tcx> {\n@@ -47,29 +57,119 @@ impl<'constrain, 'gcx, 'tcx> ConstraintGeneration<'constrain, 'gcx, 'tcx> {\n     /// > If a variable V is live at point P, then all regions R in the type of V\n     /// > must include the point P.\n     fn add_liveness_constraints(&mut self) {\n-        let tcx = self.infcx.tcx;\n-\n         debug!(\"add_liveness_constraints()\");\n         for bb in self.mir.basic_blocks().indices() {\n             debug!(\"add_liveness_constraints: bb={:?}\", bb);\n \n             self.liveness\n                 .regular\n                 .simulate_block(self.mir, bb, |location, live_locals| {\n-                    debug!(\n-                        \"add_liveness_constraints: location={:?} live_locals={:?}\",\n-                        location,\n-                        live_locals\n-                    );\n+                    for live_local in live_locals.iter() {\n+                        let live_local_ty = self.mir.local_decls[live_local].ty;\n+                        self.add_regular_live_constraint(live_local_ty, location);\n+                    }\n+                });\n \n+            self.liveness\n+                .drop\n+                .simulate_block(self.mir, bb, |location, live_locals| {\n                     for live_local in live_locals.iter() {\n                         let live_local_ty = self.mir.local_decls[live_local].ty;\n-                        tcx.for_each_free_region(&live_local_ty, |live_region| {\n-                            let vid = live_region.to_region_index();\n-                            self.regioncx.add_live_point(vid, location);\n-                        })\n+                        self.add_drop_live_constraint(live_local_ty, location);\n                     }\n                 });\n         }\n     }\n+\n+    /// Some variable with type `live_ty` is \"regular live\" at\n+    /// `location` -- i.e., it may be used later. This means that all\n+    /// regions appearing in the type `live_ty` must be live at\n+    /// `location`.\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n+            live_ty,\n+            location\n+        );\n+\n+        self.infcx\n+            .tcx\n+            .for_each_free_region(&live_ty, |live_region| {\n+                let vid = live_region.to_region_index();\n+                self.regioncx.add_live_point(vid, location);\n+            });\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+        debug!(\n+            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            dropped_ty,\n+            location\n+        );\n+\n+        let tcx = self.infcx.tcx;\n+        let mut types = vec![(dropped_ty, 0)];\n+        let mut known = FxHashSet();\n+        while let Some((ty, depth)) = types.pop() {\n+            let span = DUMMY_SP; // FIXME\n+            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                Ok(result) => result,\n+                Err(ErrorReported) => {\n+                    continue;\n+                }\n+            };\n+\n+            let ty::DtorckConstraint {\n+                outlives,\n+                dtorck_types,\n+            } = result;\n+\n+            // All things in the `outlives` array may be touched by\n+            // the destructor and must be live at this point.\n+            for outlive in outlives {\n+                if let Some(ty) = outlive.as_type() {\n+                    self.add_regular_live_constraint(ty, location);\n+                } else if let Some(r) = outlive.as_region() {\n+                    self.add_regular_live_constraint(r, location);\n+                } else {\n+                    bug!()\n+                }\n+            }\n+\n+            // However, there may also be some types that\n+            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+            // associated types and parameters). We need to normalize\n+            // associated types here and possibly recursively process.\n+            let def_id = tcx.hir.local_def_id(self.mir_source.item_id());\n+            let param_env = self.infcx.tcx.param_env(def_id);\n+            for ty in dtorck_types {\n+                // FIXME -- I think that this may disregard some region obligations\n+                // or something. Do we care? -nmatsakis\n+                let cause = ObligationCause::dummy();\n+                match traits::fully_normalize(self.infcx, cause, param_env, &ty) {\n+                    Ok(ty) => match ty.sty {\n+                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            self.add_regular_live_constraint(ty, location);\n+                        }\n+\n+                        _ => if known.insert(ty) {\n+                            types.push((ty, depth + 1));\n+                        },\n+                    },\n+\n+                    Err(errors) => {\n+                        self.infcx.report_fulfillment_errors(&errors, None);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "6139be69566c7933ae6491907e7e628afc6f280d", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "patch": "@@ -65,7 +65,7 @@ impl MirPass for NLL {\n             // Create the region inference context, generate the constraints,\n             // and then solve them.\n             let regioncx = &mut RegionInferenceContext::new(num_region_variables);\n-            constraint_generation::generate_constraints(infcx, regioncx, mir, liveness);\n+            constraint_generation::generate_constraints(infcx, regioncx, mir, source, liveness);\n             regioncx.solve(infcx, mir);\n \n             // Dump MIR results into a file, if that is enabled."}, {"sha": "5f4da966281e21ca0d1cd3881baf162ad725092c", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=af09f720d60c1226b5d42aaee3cc0c0e67ebe5cc", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p: Wrap<& /* R1 */ usize> = Wrap { value: &v[0] };\n+    if true {\n+        use_x(*p.value);\n+    } else {\n+        use_x(22);\n+    }\n+\n+    // `p` will get dropped here. Because the `#[may_dangle]`\n+    // attribute is not present on `Wrap`, we must conservatively\n+    // assume that the dtor may access the `value` field, and hence we\n+    // must consider R1 to be live.\n+}\n+\n+struct Wrap<T> {\n+    value: T\n+}\n+\n+// Look ma, no `#[may_dangle]` attribute here.\n+impl<T> Drop for Wrap<T> {\n+    fn drop(&mut self) { }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | R4: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1], bb2[2], bb3[0], bb4[0], bb4[1], bb4[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n+// END rustc.node12.nll.0.mir"}]}