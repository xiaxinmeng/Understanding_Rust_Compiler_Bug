{"sha": "ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMzMxZWU2ZWUwMTA0MzhkMWE1OGM3ZGE4Y2VkNGYyNmQ2OWEyMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-02T11:42:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-02T11:42:38Z"}, "message": "Auto merge of #86806 - GuillaumeGomez:rollup-pr5r37w, r=GuillaumeGomez\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #85749 (Revert \"Don't load all extern crates unconditionally\")\n - #86714 (Add linked list cursor end methods)\n - #86737 (Document rustfmt on nightly-rustc)\n - #86776 (Skip layout query when computing integer type size during mangling)\n - #86797 (Stabilize `Bound::cloned()`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dbe87a9389300b43acff319a3b312623a0f8e921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbe87a9389300b43acff319a3b312623a0f8e921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "html_url": "https://github.com/rust-lang/rust/commit/ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0", "html_url": "https://github.com/rust-lang/rust/commit/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0"}, {"sha": "cd3a48fdb650f6ce7c6c8a31d2136073fc3338f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3a48fdb650f6ce7c6c8a31d2136073fc3338f5", "html_url": "https://github.com/rust-lang/rust/commit/cd3a48fdb650f6ce7c6c8a31d2136073fc3338f5"}], "stats": {"total": 501, "additions": 327, "deletions": 174}, "files": [{"sha": "1a9d04a75ec6abac73bb84ffae25289367501be5", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -3,9 +3,11 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, FloatTy, Instance, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_target::abi::Integer;\n use rustc_target::spec::abi::Abi;\n \n use std::fmt::Write;\n@@ -553,11 +555,9 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Uint(_) | ty::Bool | ty::Char => {\n                 ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty)\n             }\n-            ty::Int(_) => {\n-                let param_env = ty::ParamEnv::reveal_all();\n-                ct.try_eval_bits(self.tcx, param_env, ct.ty).and_then(|b| {\n-                    let sz = self.tcx.layout_of(param_env.and(ct.ty)).ok()?.size;\n-                    let val = sz.sign_extend(b) as i128;\n+            ty::Int(ity) => {\n+                ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty).and_then(|b| {\n+                    let val = Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(b) as i128;\n                     if val < 0 {\n                         neg = true;\n                     }"}, {"sha": "ea216786ea2d45a6a815565f92baa662e408b33d", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -1243,6 +1243,20 @@ impl<'a, T> Cursor<'a, T> {\n             prev.map(|prev| &(*prev.as_ptr()).element)\n         }\n     }\n+\n+    /// Provides a reference to the front element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front(&self) -> Option<&'a T> {\n+        self.list.front()\n+    }\n+\n+    /// Provides a reference to the back element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back(&self) -> Option<&'a T> {\n+        self.list.back()\n+    }\n }\n \n impl<'a, T> CursorMut<'a, T> {\n@@ -1506,6 +1520,135 @@ impl<'a, T> CursorMut<'a, T> {\n         self.index = 0;\n         unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n     }\n+\n+    /// Appends an element to the front of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    // `push_front` continues to point to \"ghost\" when it addes a node to mimic\n+    // the behavior of `insert_before` on an empty list.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_front(&mut self, elt: T) {\n+        // Safety: We know that `push_front` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_front(elt);\n+        self.index += 1;\n+    }\n+\n+    /// Appends an element to the back of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_back(&mut self, elt: T) {\n+        // Safety: We know that `push_back` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_back(elt);\n+        if self.current().is_none() {\n+            // The index of \"ghost\" is the length of the list, so we just need\n+            // to increment self.index to reflect the new length of the list.\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Removes the first element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the front element. In that case, it\n+    /// points to the new front element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        // We can't check if current is empty, we must check the list directly.\n+        // It is possible for `self.current == None` and the list to be\n+        // non-empty.\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            // We can't point to the node that we pop. Copying the behavior of\n+            // `remove_current`, we move on the the next node in the sequence.\n+            // If the list is of length 1 then we end pointing to the \"ghost\"\n+            // node at index 0, which is expected.\n+            if self.list.head == self.current {\n+                self.move_next();\n+            } else {\n+                self.index -= 1;\n+            }\n+            self.list.pop_front()\n+        }\n+    }\n+\n+    /// Removes the last element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the back element. In that case, it\n+    /// points to the \"ghost\" element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            if self.list.tail == self.current {\n+                // The index now reflects the length of the list. It was the\n+                // length of the list minus 1, but now the list is 1 smaller. No\n+                // change is needed for `index`.\n+                self.current = None;\n+            } else if self.current.is_none() {\n+                self.index = self.list.len - 1;\n+            }\n+            self.list.pop_back()\n+        }\n+    }\n+\n+    /// Provides a reference to the front element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front(&self) -> Option<&T> {\n+        self.list.front()\n+    }\n+\n+    /// Provides a mutable reference to the front element of the cursor's\n+    /// parent list, or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n+        self.list.front_mut()\n+    }\n+\n+    /// Provides a reference to the back element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back(&self) -> Option<&T> {\n+        self.list.back()\n+    }\n+\n+    /// Provides a mutable reference to back element of the cursor's parent\n+    /// list, or `None` if the list is empty.\n+    ///\n+    /// # Examples\n+    /// Building and mutating a list with a cursor, then getting the back element:\n+    /// ```\n+    /// #![feature(linked_list_cursors)]\n+    /// use std::collections::LinkedList;\n+    /// let mut dl = LinkedList::new();\n+    /// dl.push_front(3);\n+    /// dl.push_front(2);\n+    /// dl.push_front(1);\n+    /// let mut cursor = dl.cursor_front_mut();\n+    /// *cursor.current().unwrap() = 99;\n+    /// *cursor.back_mut().unwrap() = 0;\n+    /// let mut contents = dl.into_iter();\n+    /// assert_eq!(contents.next(), Some(99));\n+    /// assert_eq!(contents.next(), Some(2));\n+    /// assert_eq!(contents.next(), Some(0));\n+    /// assert_eq!(contents.next(), None);\n+    /// ```\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n+        self.list.back_mut()\n+    }\n }\n \n /// An iterator produced by calling `drain_filter` on LinkedList."}, {"sha": "5a65ed7a962e9eabdca357380e8d7da19bfbc872", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -428,3 +428,50 @@ fn test_cursor_mut_insert() {\n     check_links(&m);\n     assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n }\n+\n+#[test]\n+fn test_cursor_push_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+    let mut c = ll.cursor_front_mut();\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.index(), Some(0));\n+    c.push_front(0);\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.peek_prev(), Some(&mut 0));\n+    assert_eq!(c.index(), Some(1));\n+    c.push_back(11);\n+    drop(c);\n+    let p = ll.cursor_back().front().unwrap();\n+    assert_eq!(p, &0);\n+    assert_eq!(ll, (0..12).collect());\n+    check_links(&ll);\n+}\n+\n+#[test]\n+fn test_cursor_pop_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut c = ll.cursor_back_mut();\n+    assert_eq!(c.pop_front(), Some(1));\n+    c.move_prev();\n+    c.move_prev();\n+    c.move_prev();\n+    assert_eq!(c.pop_back(), Some(6));\n+    let c = c.as_cursor();\n+    assert_eq!(c.front(), Some(&2));\n+    assert_eq!(c.back(), Some(&5));\n+    assert_eq!(c.index(), Some(1));\n+    drop(c);\n+    assert_eq!(ll, (2..6).collect());\n+    check_links(&ll);\n+    let mut c = ll.cursor_back_mut();\n+    assert_eq!(c.current(), Some(&mut 5));\n+    assert_eq!(c.index, 3);\n+    assert_eq!(c.pop_back(), Some(5));\n+    assert_eq!(c.current(), None);\n+    assert_eq!(c.index, 3);\n+    assert_eq!(c.pop_back(), Some(4));\n+    assert_eq!(c.current(), None);\n+    assert_eq!(c.index, 2);\n+}"}, {"sha": "9bf0382312e989ece3f4ee28215ff56e9e5f0361", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -737,14 +737,13 @@ impl<T: Clone> Bound<&T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(bound_cloned)]\n     /// use std::ops::Bound::*;\n     /// use std::ops::RangeBounds;\n     ///\n     /// assert_eq!((1..12).start_bound(), Included(&1));\n     /// assert_eq!((1..12).start_bound().cloned(), Included(1));\n     /// ```\n-    #[unstable(feature = \"bound_cloned\", issue = \"61356\")]\n+    #[stable(feature = \"bound_cloned\", since = \"1.55.0\")]\n     pub fn cloned(self) -> Bound<T> {\n         match self {\n             Bound::Unbounded => Bound::Unbounded,"}, {"sha": "dee2478886d9a742c73b43bd8b0f408a6e34aae4", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -4,7 +4,6 @@\n #![feature(array_map)]\n #![feature(array_windows)]\n #![feature(bool_to_option)]\n-#![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n #![feature(cfg_panic)]"}, {"sha": "9b155db6d7b1bae4775ee46f2cc8ec06de6c6dcc", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -31,7 +31,6 @@\n #![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n-#![feature(bound_cloned)]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]"}, {"sha": "56ecc6e68a98c8af8f1f233985b06ab89c84ab5f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -465,6 +465,7 @@ impl<'a> Builder<'a> {\n                 doc::Std,\n                 doc::Rustc,\n                 doc::Rustdoc,\n+                doc::Rustfmt,\n                 doc::ErrorIndex,\n                 doc::Nomicon,\n                 doc::Reference,"}, {"sha": "8603361362cc77bbc3a60528f74e477e7967ab0d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -593,84 +593,97 @@ impl Step for Rustc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustdoc {\n-    stage: u32,\n-    target: TargetSelection,\n-}\n-\n-impl Step for Rustdoc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.krate(\"rustdoc-tool\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc { stage: run.builder.top_stage, target: run.target });\n-    }\n-\n-    /// Generates compiler documentation.\n-    ///\n-    /// This will generate all documentation for compiler and dependencies.\n-    /// Compiler documentation is distributed separately, so we make sure\n-    /// we do not merge it with the other documentation from std, test and\n-    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} rustdoc ({})\", stage, target));\n-\n-        // This is the intended out directory for compiler documentation.\n-        let out = builder.compiler_doc_out(target);\n-        t!(fs::create_dir_all(&out));\n+macro_rules! tool_doc {\n+    ($tool: ident, $should_run: literal, $path: literal, [$($krate: literal),+ $(,)?] $(, binary=$bin:expr)?) => {\n+        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $tool {\n+            stage: u32,\n+            target: TargetSelection,\n+        }\n \n-        let compiler = builder.compiler(stage, builder.config.build);\n+        impl Step for $tool {\n+            type Output = ();\n+            const DEFAULT: bool = true;\n+            const ONLY_HOSTS: bool = true;\n \n-        if !builder.config.compiler_docs {\n-            builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n-            return;\n-        }\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+                run.krate($should_run)\n+            }\n \n-        // Build rustc docs so that we generate relative links.\n-        builder.ensure(Rustc { stage, target });\n+            fn make_run(run: RunConfig<'_>) {\n+                run.builder.ensure($tool { stage: run.builder.top_stage, target: run.target });\n+            }\n \n-        // Build rustdoc.\n-        builder.ensure(tool::Rustdoc { compiler });\n+            /// Generates compiler documentation.\n+            ///\n+            /// This will generate all documentation for compiler and dependencies.\n+            /// Compiler documentation is distributed separately, so we make sure\n+            /// we do not merge it with the other documentation from std, test and\n+            /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+            fn run(self, builder: &Builder<'_>) {\n+                let stage = self.stage;\n+                let target = self.target;\n+                builder.info(&format!(\"Documenting stage{} {} ({})\", stage, stringify!($tool).to_lowercase(), target));\n \n-        // Symlink compiler docs to the output directory of rustdoc documentation.\n-        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target.triple).join(\"doc\");\n-        t!(fs::create_dir_all(&out_dir));\n-        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+                // This is the intended out directory for compiler documentation.\n+                let out = builder.compiler_doc_out(target);\n+                t!(fs::create_dir_all(&out));\n \n-        // Build cargo command.\n-        let mut cargo = prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolRustc,\n-            target,\n-            \"doc\",\n-            \"src/tools/rustdoc\",\n-            SourceType::InTree,\n-            &[],\n-        );\n+                let compiler = builder.compiler(stage, builder.config.build);\n \n-        cargo.arg(\"-Zskip-rustdoc-fingerprint\");\n-        // Only include compiler crates, no dependencies of those, such as `libc`.\n-        cargo.arg(\"--no-deps\");\n-        cargo.arg(\"-p\").arg(\"rustdoc\");\n-        cargo.arg(\"-p\").arg(\"rustdoc-json-types\");\n+                if !builder.config.compiler_docs {\n+                    builder.info(\"\\tskipping - compiler/tool docs disabled\");\n+                    return;\n+                }\n \n-        cargo.rustdocflag(\"--document-private-items\");\n-        cargo.rustdocflag(\"--enable-index-page\");\n-        cargo.rustdocflag(\"--show-type-layout\");\n-        cargo.rustdocflag(\"-Zunstable-options\");\n-        builder.run(&mut cargo.into());\n+                // Build rustc docs so that we generate relative links.\n+                builder.ensure(Rustc { stage, target });\n+\n+                // Symlink compiler docs to the output directory of rustdoc documentation.\n+                let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target.triple).join(\"doc\");\n+                t!(fs::create_dir_all(&out_dir));\n+                t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+                // Build cargo command.\n+                let mut cargo = prepare_tool_cargo(\n+                    builder,\n+                    compiler,\n+                    Mode::ToolRustc,\n+                    target,\n+                    \"doc\",\n+                    $path,\n+                    SourceType::InTree,\n+                    &[],\n+                );\n+\n+                cargo.arg(\"-Zskip-rustdoc-fingerprint\");\n+                // Only include compiler crates, no dependencies of those, such as `libc`.\n+                cargo.arg(\"--no-deps\");\n+                $(\n+                    cargo.arg(\"-p\").arg($krate);\n+                )+\n+\n+                $(if !$bin {\n+                    cargo.rustdocflag(\"--document-private-items\");\n+                })?\n+                cargo.rustdocflag(\"--enable-index-page\");\n+                cargo.rustdocflag(\"--show-type-layout\");\n+                cargo.rustdocflag(\"-Zunstable-options\");\n+                builder.run(&mut cargo.into());\n+            }\n+        }\n     }\n }\n \n+tool_doc!(Rustdoc, \"rustdoc-tool\", \"src/tools/rustdoc\", [\"rustdoc\", \"rustdoc-json-types\"]);\n+tool_doc!(\n+    Rustfmt,\n+    \"rustfmt-nightly\",\n+    \"src/tools/rustfmt\",\n+    [\"rustfmt-nightly\", \"rustfmt-config_proc_macro\"],\n+    binary = true\n+);\n+\n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n     pub target: TargetSelection,"}, {"sha": "66f4f481292691662fb7d107ed9042a45b9e2837", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -1,12 +1,12 @@\n-use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n+use rustc_hir::def::Namespace::TypeNS;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::HirId;\n use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n@@ -23,7 +23,7 @@ use rustc_session::DiagnosticOutput;\n use rustc_session::Session;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::cell::RefCell;\n use std::mem;\n@@ -300,16 +300,41 @@ crate fn create_config(\n }\n \n crate fn create_resolver<'a>(\n+    externs: config::Externs,\n     queries: &Queries<'a>,\n     sess: &Session,\n ) -> Rc<RefCell<interface::BoxedResolver>> {\n-    let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n-    let resolver = resolver.clone();\n-\n-    let mut loader = crate::passes::collect_intra_doc_links::IntraLinkCrateLoader::new(resolver);\n-    ast::visit::walk_crate(&mut loader, krate);\n+    let extern_names: Vec<String> = externs\n+        .iter()\n+        .filter(|(_, entry)| entry.add_prelude)\n+        .map(|(name, _)| name)\n+        .cloned()\n+        .collect();\n+\n+    let (_, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n+\n+    // Before we actually clone it, let's force all the extern'd crates to\n+    // actually be loaded, just in case they're only referred to inside\n+    // intra-doc links\n+    resolver.borrow_mut().access(|resolver| {\n+        sess.time(\"load_extern_crates\", || {\n+            for extern_name in &extern_names {\n+                debug!(\"loading extern crate {}\", extern_name);\n+                if let Err(()) = resolver\n+                    .resolve_str_path_error(\n+                        DUMMY_SP,\n+                        extern_name,\n+                        TypeNS,\n+                        LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n+                  ) {\n+                    warn!(\"unable to resolve external crate {} (do you have an unused `--extern` crate?)\", extern_name)\n+                  }\n+            }\n+        });\n+    });\n \n-    loader.resolver\n+    // Now we're good to clone the resolver because everything should be loaded\n+    resolver.clone()\n }\n \n crate fn run_global_ctxt("}, {"sha": "64a9905b33f155406839e3ca9a640e9643a975fc", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -31,7 +31,6 @@ extern crate tracing;\n // Dependencies listed in Cargo.toml do not need `extern crate`.\n \n extern crate rustc_ast;\n-extern crate rustc_ast_lowering;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_data_structures;\n@@ -714,6 +713,7 @@ fn main_options(options: config::Options) -> MainResult {\n     let default_passes = options.default_passes;\n     let output_format = options.output_format;\n     // FIXME: fix this clone (especially render_options)\n+    let externs = options.externs.clone();\n     let manual_passes = options.manual_passes.clone();\n     let render_options = options.render_options.clone();\n     let config = core::create_config(options);\n@@ -731,7 +731,7 @@ fn main_options(options: config::Options) -> MainResult {\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n-            let resolver = core::create_resolver(queries, &sess);\n+            let resolver = core::create_resolver(externs, queries, &sess);\n \n             if sess.has_errors() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");"}, {"sha": "1113d61012852637870290e45ca48f8f46ad2e28", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -37,9 +37,6 @@ use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n \n-mod early;\n-crate use early::IntraLinkCrateLoader;\n-\n crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,"}, {"sha": "7cba2523d1a3b938e45b20671e9976e9ac976ec4", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0", "patch": "@@ -1,63 +0,0 @@\n-use rustc_ast as ast;\n-use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_interface::interface;\n-\n-use std::cell::RefCell;\n-use std::mem;\n-use std::rc::Rc;\n-\n-// Letting the resolver escape at the end of the function leads to inconsistencies between the\n-// crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n-// after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n-crate struct IntraLinkCrateLoader {\n-    current_mod: DefId,\n-    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n-}\n-\n-impl IntraLinkCrateLoader {\n-    crate fn new(resolver: Rc<RefCell<interface::BoxedResolver>>) -> Self {\n-        let crate_id = LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id();\n-        Self { current_mod: crate_id, resolver }\n-    }\n-}\n-\n-impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        use crate::html::markdown::markdown_links;\n-        use crate::passes::collect_intra_doc_links::preprocess_link;\n-\n-        if let Some(doc) = attr.doc_str() {\n-            for link in markdown_links(&doc.as_str()) {\n-                let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n-                    x.path_str\n-                } else {\n-                    continue;\n-                };\n-                self.resolver.borrow_mut().access(|resolver| {\n-                    let _ = resolver.resolve_str_path_error(\n-                        attr.span,\n-                        &path_str,\n-                        TypeNS,\n-                        self.current_mod,\n-                    );\n-                });\n-            }\n-        }\n-        ast::visit::walk_attribute(self, attr);\n-    }\n-\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        use rustc_ast_lowering::ResolverAstLowering;\n-\n-        if let ast::ItemKind::Mod(..) = item.kind {\n-            let new_mod =\n-                self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n-            let old_mod = mem::replace(&mut self.current_mod, new_mod.to_def_id());\n-            ast::visit::walk_item(self, item);\n-            self.current_mod = old_mod;\n-        } else {\n-            ast::visit::walk_item(self, item);\n-        }\n-    }\n-}"}, {"sha": "390ab1694a05bedd980a6ed5e43dce41db63167e", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -30,7 +30,7 @@ crate use self::unindent_comments::UNINDENT_COMMENTS;\n mod propagate_doc_cfg;\n crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n-crate mod collect_intra_doc_links;\n+mod collect_intra_doc_links;\n crate use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n mod doc_test_lints;"}, {"sha": "17b26850d4d2518d8b718f92354e570667e1dd9e", "filename": "src/test/rustdoc-ui/auxiliary/panic-item.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fpanic-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fpanic-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fpanic-item.rs?ref=f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0", "patch": "@@ -1,17 +0,0 @@\n-// no-prefer-dynamic\n-#![crate_type = \"lib\"]\n-#![no_std]\n-#![feature(lang_items)]\n-\n-use core::panic::PanicInfo;\n-use core::sync::atomic::{self, Ordering};\n-\n-#[panic_handler]\n-fn panic(_info: &PanicInfo) -> ! {\n-    loop {\n-        atomic::compiler_fence(Ordering::SeqCst);\n-    }\n-}\n-\n-#[lang = \"eh_personality\"]\n-fn foo() {}"}, {"sha": "f703a183790745c007db89829e286e4430ac57c1", "filename": "src/test/rustdoc-ui/unused-extern-crate.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Ftest%2Frustdoc-ui%2Funused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0/src%2Ftest%2Frustdoc-ui%2Funused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funused-extern-crate.rs?ref=f9fa13f705bb8b1c57c6b6fe95055ec4995a40f0", "patch": "@@ -1,3 +0,0 @@\n-// check-pass\n-// aux-crate:panic_item=panic-item.rs\n-// @has unused_extern_crate/index.html"}, {"sha": "2f3d069bd51c36665d483943ee79d60dded77367", "filename": "src/test/rustdoc/auxiliary/issue-66159-1.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-66159-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-66159-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-66159-1.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -0,0 +1,2 @@\n+/// This will be referred to by the test docstring\n+pub struct Something;"}, {"sha": "003d079a470c0cc2756f75d6fde1c83991bf30da", "filename": "src/test/rustdoc/issue-66159.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftest%2Frustdoc%2Fissue-66159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftest%2Frustdoc%2Fissue-66159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-66159.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -0,0 +1,10 @@\n+// aux-crate:priv:issue_66159_1=issue-66159-1.rs\n+// compile-flags:-Z unstable-options\n+\n+// The issue was an ICE which meant that we never actually generated the docs\n+// so if we have generated the docs, we're okay.\n+// Since we don't generate the docs for the auxiliary files, we can't actually\n+// verify that the struct is linked correctly.\n+\n+// @has issue_66159/index.html\n+//! [issue_66159_1::Something]"}, {"sha": "ce8a45eea65312dd5fee34d9918b852e9ce10114", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce331ee6ee010438d1a58c7da8ced4f26d69a20e/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=ce331ee6ee010438d1a58c7da8ced4f26d69a20e", "patch": "@@ -1,6 +1,7 @@\n #![feature(rustc_private)]\n #![deny(rust_2018_idioms)]\n #![warn(unreachable_pub)]\n+#![recursion_limit = \"256\"]\n \n #[macro_use]\n extern crate derive_new;"}]}