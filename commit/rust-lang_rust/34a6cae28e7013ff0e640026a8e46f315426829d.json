{"sha": "34a6cae28e7013ff0e640026a8e46f315426829d", "node_id": "C_kwDOAAsO6NoAKDM0YTZjYWUyOGU3MDEzZmYwZTY0MDAyNmE4ZTQ2ZjMxNTQyNjgyOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T20:00:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T20:00:58Z"}, "message": "Auto merge of #100150 - notriddle:notriddle/implementors-js, r=GuillaumeGomez\n\nrustdoc: use a more compact encoding for implementors/trait.*.js\n\nThe exact amount that this reduces the size of an implementors file depends on whether most of the impls are synthetic or not. For `Send`, it reduces the file from 128K to 112K, while for `Clone` it went from 64K to 44K.", "tree": {"sha": "23a9d47a0b2760c9d66f3f8e485de45f41e14780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a9d47a0b2760c9d66f3f8e485de45f41e14780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34a6cae28e7013ff0e640026a8e46f315426829d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34a6cae28e7013ff0e640026a8e46f315426829d", "html_url": "https://github.com/rust-lang/rust/commit/34a6cae28e7013ff0e640026a8e46f315426829d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34a6cae28e7013ff0e640026a8e46f315426829d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63e4312e6bd50ec9859c363402209809fb8155d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/63e4312e6bd50ec9859c363402209809fb8155d5", "html_url": "https://github.com/rust-lang/rust/commit/63e4312e6bd50ec9859c363402209809fb8155d5"}, {"sha": "fc31fce670ad76db14044a519a15870347253766", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc31fce670ad76db14044a519a15870347253766", "html_url": "https://github.com/rust-lang/rust/commit/fc31fce670ad76db14044a519a15870347253766"}], "stats": {"total": 95, "additions": 73, "deletions": 22}, "files": [{"sha": "3dee4d1acc819f4a5ac7fcbdfda502cffe64e1d2", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=34a6cae28e7013ff0e640026a8e46f315426829d", "patch": "@@ -152,7 +152,7 @@ impl Buffer {\n     }\n }\n \n-fn comma_sep<T: fmt::Display>(\n+pub(crate) fn comma_sep<T: fmt::Display>(\n     items: impl Iterator<Item = T>,\n     space_after_comma: bool,\n ) -> impl fmt::Display {"}, {"sha": "f9abb46207d748e957b70261d8fa2c4451425505", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=34a6cae28e7013ff0e640026a8e46f315426829d", "patch": "@@ -1,5 +1,4 @@\n use std::ffi::OsStr;\n-use std::fmt::Write;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -10,7 +9,8 @@ use std::sync::LazyLock as Lazy;\n use itertools::Itertools;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use serde::Serialize;\n+use serde::ser::SerializeSeq;\n+use serde::{Serialize, Serializer};\n \n use super::{collect_paths_for_type, ensure_trailing_slash, Context, BASIC_KEYWORDS};\n use crate::clean::Crate;\n@@ -284,25 +284,43 @@ pub(super) fn write_shared(\n         cx.write_shared(SharedResource::Unversioned { name }, contents, &options.emit)?;\n     }\n \n-    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+    /// Read a file and return all lines that match the `\"{crate}\":{data},` format,\n+    /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n+    ///\n+    /// This forms the payload of files that look like this:\n+    ///\n+    /// ```javascript\n+    /// var data = {\n+    /// \"{crate1}\":{data},\n+    /// \"{crate2}\":{data}\n+    /// };\n+    /// use_data(data);\n+    /// ```\n+    ///\n+    /// The file needs to be formatted so that *only crate data lines start with `\"`*.\n+    fn collect(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n \n         if path.exists() {\n-            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n-                if !line.starts_with(key) {\n+                if !line.starts_with('\"') {\n                     continue;\n                 }\n                 if line.starts_with(&prefix) {\n                     continue;\n                 }\n-                ret.push(line.to_string());\n+                if line.ends_with(\",\") {\n+                    ret.push(line[..line.len() - 1].to_string());\n+                } else {\n+                    // No comma (it's the case for the last added crate line)\n+                    ret.push(line.to_string());\n+                }\n                 krates.push(\n-                    line[key.len() + 2..]\n-                        .split('\"')\n-                        .next()\n+                    line.split('\"')\n+                        .find(|s| !s.is_empty())\n                         .map(|s| s.to_owned())\n                         .unwrap_or_else(String::new),\n                 );\n@@ -311,6 +329,20 @@ pub(super) fn write_shared(\n         Ok((ret, krates))\n     }\n \n+    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\</code> format,\n+    /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n+    ///\n+    /// This forms the payload of files that look like this:\n+    ///\n+    /// ```javascript\n+    /// var data = JSON.parse('{\\\n+    /// \"{crate1}\":{data},\\\n+    /// \"{crate2}\":{data}\\\n+    /// }');\n+    /// use_data(data);\n+    /// ```\n+    ///\n+    /// The file needs to be formatted so that *only crate data lines start with `\"`*.\n     fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n@@ -526,13 +558,27 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n             },\n         };\n \n-        #[derive(Serialize)]\n         struct Implementor {\n             text: String,\n             synthetic: bool,\n             types: Vec<String>,\n         }\n \n+        impl Serialize for Implementor {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+            where\n+                S: Serializer,\n+            {\n+                let mut seq = serializer.serialize_seq(None)?;\n+                seq.serialize_element(&self.text)?;\n+                if self.synthetic {\n+                    seq.serialize_element(&1)?;\n+                    seq.serialize_element(&self.types)?;\n+                }\n+                seq.end()\n+            }\n+        }\n+\n         let implementors = imps\n             .iter()\n             .filter_map(|imp| {\n@@ -563,9 +609,9 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n         }\n \n         let implementors = format!(\n-            r#\"implementors[\"{}\"] = {};\"#,\n+            r#\"\"{}\":{}\"#,\n             krate.name(cx.tcx()),\n-            serde_json::to_string(&implementors).unwrap()\n+            serde_json::to_string(&implementors).expect(\"failed serde conversion\"),\n         );\n \n         let mut mydst = dst.clone();\n@@ -576,16 +622,15 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n         mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n \n         let (mut all_implementors, _) =\n-            try_err!(collect(&mydst, krate.name(cx.tcx()).as_str(), \"implementors\"), &mydst);\n+            try_err!(collect(&mydst, krate.name(cx.tcx()).as_str()), &mydst);\n         all_implementors.push(implementors);\n         // Sort the implementors by crate so the file will be generated\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n-        for implementor in &all_implementors {\n-            writeln!(v, \"{}\", *implementor).unwrap();\n-        }\n+        let mut v = String::from(\"(function() {var implementors = {\\n\");\n+        v.push_str(&all_implementors.join(\",\\n\"));\n+        v.push_str(\"\\n};\");\n         v.push_str(\n             \"if (window.register_implementors) {\\\n                  window.register_implementors(implementors);\\"}, {"sha": "2e05c4be2f3e9b857b4b5ebb9bdb5dfbf14f5666", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/34a6cae28e7013ff0e640026a8e46f315426829d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=34a6cae28e7013ff0e640026a8e46f315426829d", "patch": "@@ -501,6 +501,10 @@ function loadCss(cssFileName) {\n         const synthetic_implementors = document.getElementById(\"synthetic-implementors-list\");\n         const inlined_types = new Set();\n \n+        const TEXT_IDX = 0;\n+        const SYNTHETIC_IDX = 1;\n+        const TYPES_IDX = 2;\n+\n         if (synthetic_implementors) {\n             // This `inlined_types` variable is used to avoid having the same implementation\n             // showing up twice. For example \"String\" in the \"Sync\" doc page.\n@@ -536,10 +540,12 @@ function loadCss(cssFileName) {\n \n             struct_loop:\n             for (const struct of structs) {\n-                const list = struct.synthetic ? synthetic_implementors : implementors;\n+                const list = struct[SYNTHETIC_IDX] ? synthetic_implementors : implementors;\n \n-                if (struct.synthetic) {\n-                    for (const struct_type of struct.types) {\n+                // The types list is only used for synthetic impls.\n+                // If this changes, `main.js` and `write_shared.rs` both need changed.\n+                if (struct[SYNTHETIC_IDX]) {\n+                    for (const struct_type of struct[TYPES_IDX]) {\n                         if (inlined_types.has(struct_type)) {\n                             continue struct_loop;\n                         }\n@@ -548,7 +554,7 @@ function loadCss(cssFileName) {\n                 }\n \n                 const code = document.createElement(\"h3\");\n-                code.innerHTML = struct.text;\n+                code.innerHTML = struct[TEXT_IDX];\n                 addClass(code, \"code-header\");\n                 addClass(code, \"in-band\");\n "}]}