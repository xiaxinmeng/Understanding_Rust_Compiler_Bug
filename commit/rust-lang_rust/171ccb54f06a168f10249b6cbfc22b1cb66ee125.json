{"sha": "171ccb54f06a168f10249b6cbfc22b1cb66ee125", "node_id": "C_kwDOAAsO6NoAKDE3MWNjYjU0ZjA2YTE2OGYxMDI0OWI2Y2JmYzIyYjFjYjY2ZWUxMjU", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-02-20T19:56:50Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-03T19:10:02Z"}, "message": "avoid zero-copy ops for File->Pipe and File->Socket in io::copy", "tree": {"sha": "acff6f3a91f9bd9a1bc09ada880f674349218bc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acff6f3a91f9bd9a1bc09ada880f674349218bc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/171ccb54f06a168f10249b6cbfc22b1cb66ee125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/171ccb54f06a168f10249b6cbfc22b1cb66ee125", "html_url": "https://github.com/rust-lang/rust/commit/171ccb54f06a168f10249b6cbfc22b1cb66ee125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/171ccb54f06a168f10249b6cbfc22b1cb66ee125/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c96c30aeedd753b4e7f4eaa51f7589fed09f40a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96c30aeedd753b4e7f4eaa51f7589fed09f40a1", "html_url": "https://github.com/rust-lang/rust/commit/c96c30aeedd753b4e7f4eaa51f7589fed09f40a1"}], "stats": {"total": 62, "additions": 46, "deletions": 16}, "files": [{"sha": "16c8e0c0ebfc50f34aa4b1a12e5649b500f1a3d0", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/171ccb54f06a168f10249b6cbfc22b1cb66ee125/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/171ccb54f06a168f10249b6cbfc22b1cb66ee125/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=171ccb54f06a168f10249b6cbfc22b1cb66ee125", "patch": "@@ -17,11 +17,9 @@\n //! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n //! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n //! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n-//! Since those syscalls have requirements that cannot be fully checked in advance and\n-//! gathering additional information about file descriptors would require additional syscalls\n-//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n-//! figure out which one works and falls back to the generic read-write copy loop if none of them\n-//! does.\n+//! Since those syscalls have requirements that cannot be fully checked in advance it attempts\n+//! to use them one after another (guided by hints) to figure out which one works and\n+//! falls back to the generic read-write copy loop if none of them does.\n //! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n //! until the copy operation is completed.\n //!\n@@ -84,14 +82,10 @@ pub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n /// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n /// type may be wrong.\n enum FdMeta {\n-    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n-    /// because it is cheaper than probing all possible syscalls (reader side)\n     Metadata(Metadata),\n     Socket,\n     Pipe,\n-    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n-    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n-    /// (writer side)\n+    /// We don't have any metadata because the stat syscall failed\n     NoneObtained,\n }\n \n@@ -131,6 +125,39 @@ impl FdMeta {\n     }\n }\n \n+/// Returns true either if changes made to the source after a sendfile/splice call won't become\n+/// visible in the sink or the source has explicitly opted into such behavior (e.g. by splicing\n+/// a file into a pipe, the pipe being the source in this case).\n+///\n+/// This will prevent File -> Pipe and File -> Socket splicing/sendfile optimizations to uphold\n+/// the Read/Write API semantics of io::copy.\n+///\n+/// Note: This is not 100% airtight, the caller can use the RawFd conversion methods to turn a\n+/// regular file into a TcpSocket which will be treated as a socket here without checking.\n+fn safe_kernel_copy(source: &FdMeta, sink: &FdMeta) -> bool {\n+    match (source, sink) {\n+        // Data arriving from a socket is safe because the sender can't modify the socket buffer.\n+        // Data arriving from a pipe is safe(-ish) because either the sender *copied*\n+        // the bytes into the pipe OR explicitly performed an operation that enables zero-copy,\n+        // thus promising not to modify the data later.\n+        (FdMeta::Socket, _) => true,\n+        (FdMeta::Pipe, _) => true,\n+        (FdMeta::Metadata(meta), _)\n+            if meta.file_type().is_fifo() || meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        // Data going into non-pipes/non-sockets is safe because the \"later changes may become visible\" issue\n+        // only happens for pages sitting in send buffers or pipes.\n+        (_, FdMeta::Metadata(meta))\n+            if !meta.file_type().is_fifo() && !meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        _ => false,\n+    }\n+}\n+\n struct CopyParams(FdMeta, Option<RawFd>);\n \n struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n@@ -186,7 +213,8 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n             // So we just try and fallback if needed.\n             // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n             // fall back to the generic copy loop.\n-            if input_meta.potential_sendfile_source() {\n+            if input_meta.potential_sendfile_source() && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -197,7 +225,9 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n                 }\n             }\n \n-            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+            if (input_meta.maybe_fifo() || output_meta.maybe_fifo())\n+                && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -298,13 +328,13 @@ impl CopyRead for &File {\n \n impl CopyWrite for File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for &File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n     }\n }\n \n@@ -401,13 +431,13 @@ impl CopyRead for StdinLock<'_> {\n \n impl CopyWrite for StdoutLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for StderrLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n "}]}