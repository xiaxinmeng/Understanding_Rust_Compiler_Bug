{"sha": "6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYzBiYTNjM2ExZmMyMGUxNzkyMzcyNGUxZTc2MzUxMzFlYjE5ZDY=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-07-07T11:50:23Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-07-08T17:40:40Z"}, "message": "Improve Vec::resize so that it can be used in Read::read_to_end\n\nWe needed a more efficient way to zerofill the vector in read_to_end.\nThis to reduce the memory intialization overhead to a minimum.\n\nUse the implementation of `std::vec::from_elem` (used for the vec![]\nmacro) for Vec::resize as well. For simple element types like u8, this\ncompiles to memset, so it makes Vec::resize much more efficient.", "tree": {"sha": "24e01203766715d1e62275c80453cbc4acbf6974", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e01203766715d1e62275c80453cbc4acbf6974"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "html_url": "https://github.com/rust-lang/rust/commit/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876", "html_url": "https://github.com/rust-lang/rust/commit/26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "3848263c5309760d5491a848861da21f75206140", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "patch": "@@ -67,7 +67,7 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{repeat, FromIterator};\n+use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Index, IndexMut, Deref};\n@@ -1106,12 +1106,35 @@ impl<T: Clone> Vec<T> {\n         let len = self.len();\n \n         if new_len > len {\n-            self.extend(repeat(value).take(new_len - len));\n+            self.extend_with_element(new_len - len, value);\n         } else {\n             self.truncate(new_len);\n         }\n     }\n \n+    /// Extend the vector by `n` additional clones of `value`.\n+    fn extend_with_element(&mut self, n: usize, value: T) {\n+        self.reserve(n);\n+\n+        unsafe {\n+            let len = self.len();\n+            let mut ptr = self.as_mut_ptr().offset(len as isize);\n+            // Write all elements except the last one\n+            for i in 1..n {\n+                ptr::write(ptr, value.clone());\n+                ptr = ptr.offset(1);\n+                // Increment the length in every step in case clone() panics\n+                self.set_len(len + i);\n+            }\n+\n+            if n > 0 {\n+                // We can write the last element directly without cloning needlessly\n+                ptr::write(ptr, value);\n+                self.set_len(len + n);\n+            }\n+        }\n+    }\n+\n     /// Appends all elements in a slice to the `Vec`.\n     ///\n     /// Iterates over the slice `other`, clones each element, and then appends\n@@ -1294,25 +1317,9 @@ unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n #[doc(hidden)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n-    unsafe {\n-        let mut v = Vec::with_capacity(n);\n-        let mut ptr = v.as_mut_ptr();\n-\n-        // Write all elements except the last one\n-        for i in 1..n {\n-            ptr::write(ptr, Clone::clone(&elem));\n-            ptr = ptr.offset(1);\n-            v.set_len(i); // Increment the length in every step in case Clone::clone() panics\n-        }\n-\n-        if n > 0 {\n-            // We can write the last element directly without cloning needlessly\n-            ptr::write(ptr, elem);\n-            v.set_len(n);\n-        }\n-\n-        v\n-    }\n+    let mut v = Vec::with_capacity(n);\n+    v.extend_with_element(n, elem);\n+    v\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "50c44299dc70975087463486fdfc29ae64376046", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "patch": "@@ -16,7 +16,7 @@ use cmp;\n use rustc_unicode::str as core_str;\n use error as std_error;\n use fmt;\n-use iter::{self, Iterator, Extend};\n+use iter::{Iterator};\n use marker::Sized;\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n@@ -106,7 +106,7 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n             if new_write_size < DEFAULT_BUF_SIZE {\n                 new_write_size *= 2;\n             }\n-            buf.extend(iter::repeat(0).take(new_write_size));\n+            buf.resize(len + new_write_size, 0);\n         }\n \n         match r.read(&mut buf[len..]) {\n@@ -984,6 +984,14 @@ mod tests {\n         let mut v = Vec::new();\n         assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n         assert_eq!(v, b\"1\");\n+\n+        let cap = 1024 * 1024;\n+        let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n+        let mut v = Vec::new();\n+        let (a, b) = data.split_at(data.len() / 2);\n+        assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n+        assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n+        assert_eq!(v, data);\n     }\n \n     #[test]"}, {"sha": "caf3f497e10b4c22e6a54088b9902def278c7655", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac0ba3c3a1fc20e17923724e1e7635131eb19d6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6ac0ba3c3a1fc20e17923724e1e7635131eb19d6", "patch": "@@ -146,6 +146,7 @@\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(vec_push_all)]\n+#![feature(vec_resize)]\n #![feature(wrapping)]\n #![feature(zero_one)]\n #![cfg_attr(windows, feature(str_utf16))]"}]}