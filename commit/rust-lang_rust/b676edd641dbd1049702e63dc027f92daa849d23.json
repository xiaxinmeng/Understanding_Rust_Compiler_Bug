{"sha": "b676edd641dbd1049702e63dc027f92daa849d23", "node_id": "C_kwDOAAsO6NoAKGI2NzZlZGQ2NDFkYmQxMDQ5NzAyZTYzZGMwMjdmOTJkYWE4NDlkMjM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-18T18:09:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-14T20:44:27Z"}, "message": "Do not modify the resolver outputs.", "tree": {"sha": "813983058e889c79571e4ac016b4b96aa87548da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/813983058e889c79571e4ac016b4b96aa87548da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b676edd641dbd1049702e63dc027f92daa849d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b676edd641dbd1049702e63dc027f92daa849d23", "html_url": "https://github.com/rust-lang/rust/commit/b676edd641dbd1049702e63dc027f92daa849d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b676edd641dbd1049702e63dc027f92daa849d23/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "603746a35e35827b7a25604145832e9dc8057ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/603746a35e35827b7a25604145832e9dc8057ece", "html_url": "https://github.com/rust-lang/rust/commit/603746a35e35827b7a25604145832e9dc8057ece"}], "stats": {"total": 158, "additions": 83, "deletions": 75}, "files": [{"sha": "1a125a9751bcf3fcf2aef4784abc09cb40af8286", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=b676edd641dbd1049702e63dc027f92daa849d23", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n-                            let node_id = self.resolver.next_node_id();\n+                            let node_id = self.next_node_id();\n                             self.create_def(\n                                 parent_def_id,\n                                 node_id,"}, {"sha": "619debba6da202b83f2dd7babbe29bc816826894", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b676edd641dbd1049702e63dc027f92daa849d23", "patch": "@@ -355,7 +355,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n                 let parent_def_id = self.current_hir_id_owner;\n-                let node_id = self.resolver.next_node_id();\n+                let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n                 self.create_def(\n@@ -724,7 +724,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n-        let loop_node_id = self.resolver.next_node_id();\n+        let loop_node_id = self.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);"}, {"sha": "81a55ce8a4334c6fa2a96625c2a8d3e857e80db2", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=b676edd641dbd1049702e63dc027f92daa849d23", "patch": "@@ -62,6 +62,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         owner: NodeId,\n         f: impl FnOnce(&mut LoweringContext<'_, 'hir>) -> hir::OwnerNode<'hir>,\n     ) {\n+        let next_node_id = self.resolver.next_node_id;\n         let mut lctx = LoweringContext {\n             // Pseudo-globals.\n             sess: &self.sess,\n@@ -79,6 +80,8 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             node_id_to_local_id: Default::default(),\n             local_id_to_def_id: SortedMap::new(),\n             trait_map: Default::default(),\n+            local_node_id_to_def_id: FxHashMap::default(),\n+            next_node_id,\n \n             // Lowering state.\n             catch_scope: None,\n@@ -126,8 +129,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self, c))]\n     fn lower_crate(&mut self, c: &Crate) {\n-        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n-\n+        debug_assert_eq!(self.resolver.node_id_to_def_id[&CRATE_NODE_ID], CRATE_DEF_ID);\n         self.with_lctx(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, &c.spans);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n@@ -141,7 +143,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n     }\n \n     fn lower_assoc_item(&mut self, item: &AssocItem, ctxt: AssocCtxt) {\n-        let def_id = self.resolver.local_def_id(item.id);\n+        let def_id = self.resolver.node_id_to_def_id[&item.id];\n \n         let parent_id = {\n             let parent = self.definitions.def_key(def_id).parent;\n@@ -185,7 +187,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.resolver.local_def_id(i.id) }];\n+        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -201,7 +203,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n+                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -210,7 +212,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n+                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n                 }\n             }\n         }\n@@ -475,7 +477,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n                 let body = P(self.lower_mac_args(body));\n-                let macro_kind = self.resolver.decl_macro_kind(self.resolver.local_def_id(id));\n+                let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n                 hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n@@ -535,7 +537,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n-                    let new_id = self.resolver.local_def_id(new_node_id);\n+                    let new_id = self.local_def_id(new_node_id);\n                     let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n                         let _old = self.children.insert(\n@@ -548,7 +550,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n-                        seg.id = self.resolver.next_node_id();\n+                        seg.id = self.next_node_id();\n                     }\n                     let span = path.span;\n \n@@ -611,13 +613,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.resolver.local_def_id(id);\n+                    let new_hir_id = self.local_def_id(id);\n \n                     let mut prefix = prefix.clone();\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.resolver.next_node_id();\n+                        seg.id = self.next_node_id();\n                     }\n \n                     // Each `use` import is an item and thus are owners of the\n@@ -691,7 +693,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.resolver.local_def_id(i.id) },\n+            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -847,7 +849,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.resolver.local_def_id(i.id) };\n+        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n         let defaultness = hir::Defaultness::Default { has_value: has_default };\n         hir::TraitItemRef {\n             id,\n@@ -927,7 +929,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.resolver.local_def_id(i.id) },\n+            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             defaultness,\n@@ -1339,7 +1341,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         generics\n                             .params\n                             .iter()\n-                            .any(|p| def_id == self.resolver.local_def_id(p.id).to_def_id())\n+                            .any(|p| def_id == self.local_def_id(p.id).to_def_id())\n                     }\n                     // Either the `bounded_ty` is not a plain type parameter, or\n                     // it's not found in the generic type parameters list.\n@@ -1443,7 +1445,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {\n-                let def_id = self.resolver.local_def_id(id).to_def_id();\n+                let def_id = self.local_def_id(id).to_def_id();\n                 let ty_path = self.arena.alloc(hir::Path {\n                     span: param_span,\n                     res: Res::Def(DefKind::TyParam, def_id),\n@@ -1466,7 +1468,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n                     panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n                 });\n-                let lt_id = self.resolver.next_node_id();\n+                let lt_id = self.next_node_id();\n                 let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n                 Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     lifetime,"}, {"sha": "6903e02f3a5b8c6301e4b7da549bf02d305f6d24", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b676edd641dbd1049702e63dc027f92daa849d23/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b676edd641dbd1049702e63dc027f92daa849d23", "patch": "@@ -133,6 +133,10 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// NodeIds that are lowered inside the current HIR owner.\n     node_id_to_local_id: FxHashMap<NodeId, hir::ItemLocalId>,\n \n+    // The next_node_id is reset for each item.\n+    next_node_id: ast::NodeId,\n+    local_node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+\n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n     allow_into_future: Option<Lrc<[Symbol]>>,\n@@ -167,9 +171,6 @@ trait ResolverAstLoweringExt {\n     fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n-    fn next_node_id(&mut self) -> NodeId;\n-    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n-    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n }\n \n@@ -229,24 +230,6 @@ impl ResolverAstLoweringExt for ResolverOutputs {\n         self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n     }\n \n-    fn next_node_id(&mut self) -> NodeId {\n-        let next = self\n-            .next_node_id\n-            .as_usize()\n-            .checked_add(1)\n-            .expect(\"input too large; ran out of NodeIds\");\n-        self.next_node_id = NodeId::from_usize(next);\n-        self.next_node_id\n-    }\n-\n-    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n-        self.node_id_to_def_id.get(&node).copied()\n-    }\n-\n-    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n-    }\n-\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n         self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n     }\n@@ -359,17 +342,17 @@ enum AstOwner<'a> {\n }\n \n fn index_crate<'a>(\n-    resolver: &ResolverOutputs,\n+    node_id_to_def_id: &FxHashMap<NodeId, LocalDefId>,\n     krate: &'a Crate,\n ) -> IndexVec<LocalDefId, AstOwner<'a>> {\n-    let mut indexer = Indexer { resolver, index: IndexVec::new() };\n+    let mut indexer = Indexer { node_id_to_def_id, index: IndexVec::new() };\n     indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner);\n     indexer.index[CRATE_DEF_ID] = AstOwner::Crate(krate);\n     visit::walk_crate(&mut indexer, krate);\n     return indexer.index;\n \n     struct Indexer<'s, 'a> {\n-        resolver: &'s ResolverOutputs,\n+        node_id_to_def_id: &'s FxHashMap<NodeId, LocalDefId>,\n         index: IndexVec<LocalDefId, AstOwner<'a>>,\n     }\n \n@@ -380,21 +363,21 @@ fn index_crate<'a>(\n         }\n \n         fn visit_item(&mut self, item: &'a ast::Item) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::Item(item);\n             visit::walk_item(self, item)\n         }\n \n         fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: visit::AssocCtxt) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::AssocItem(item, ctxt);\n             visit::walk_assoc_item(self, item, ctxt);\n         }\n \n         fn visit_foreign_item(&mut self, item: &'a ast::ForeignItem) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::ForeignItem(item);\n             visit::walk_foreign_item(self, item);\n@@ -436,7 +419,7 @@ pub fn lower_crate<'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n-    let ast_index = index_crate(resolver, krate);\n+    let ast_index = index_crate(&resolver.node_id_to_def_id, krate);\n \n     let mut owners =\n         IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, definitions.def_index_count());\n@@ -488,11 +471,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n     ) -> LocalDefId {\n         assert!(\n-            !self.resolver.node_id_to_def_id.contains_key(&node_id),\n+            self.opt_local_def_id(node_id).is_none(),\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.definitions.def_key(self.resolver.node_id_to_def_id[&node_id]),\n+            self.definitions.def_key(self.local_def_id(node_id)),\n         );\n \n         let def_id = self.definitions.create_def(parent, data, expn_id, span);\n@@ -502,20 +485,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // we don't need a mapping from `NodeId` to `LocalDefId`.\n         if node_id != ast::DUMMY_NODE_ID {\n             debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n-            self.resolver.node_id_to_def_id.insert(node_id, def_id);\n+            self.local_node_id_to_def_id.insert(node_id, def_id);\n         }\n-        assert_eq!(self.resolver.def_id_to_node_id.push(node_id), def_id);\n \n         def_id\n     }\n \n+    fn next_node_id(&mut self) -> NodeId {\n+        let next = self\n+            .next_node_id\n+            .as_usize()\n+            .checked_add(1)\n+            .expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = NodeId::from_usize(next);\n+        self.next_node_id\n+    }\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        if node <= self.resolver.next_node_id {\n+            self.resolver.node_id_to_def_id.get(&node).copied()\n+        } else {\n+            self.local_node_id_to_def_id.get(&node).copied()\n+        }\n+    }\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n+\n     #[instrument(level = \"debug\", skip(self, f))]\n     fn with_hir_id_owner(\n         &mut self,\n         owner: NodeId,\n         f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n     ) {\n-        let def_id = self.resolver.local_def_id(owner);\n+        let def_id = self.local_def_id(owner);\n \n         let current_attrs = std::mem::take(&mut self.attrs);\n         let current_bodies = std::mem::take(&mut self.bodies);\n@@ -527,6 +531,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n         let current_impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);\n+        // Do not reset `next_node_id` and `node_id_to_def_id` as we want to refer to the\n+        // subdefinitions' nodes.\n \n         // Always allocate the first `HirId` for the owner itself.\n         let _old = self.node_id_to_local_id.insert(owner, hir::ItemLocalId::new(0));\n@@ -633,7 +639,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.item_local_id_counter.increment_by(1);\n \n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n-                if let Some(def_id) = self.resolver.opt_local_def_id(ast_node_id) {\n+                if let Some(def_id) = self.opt_local_def_id(ast_node_id) {\n                     // Do not override a `MaybeOwner::Owner` that may already here.\n                     self.children.entry(def_id).or_insert(hir::MaybeOwner::NonOwner(hir_id));\n                     self.local_id_to_def_id.insert(local_id, def_id);\n@@ -649,7 +655,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n-        let node_id = self.resolver.next_node_id();\n+        let node_id = self.next_node_id();\n         self.lower_node_id(node_id)\n     }\n \n@@ -991,7 +997,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let parent_def_id = self.current_hir_id_owner;\n-                    let impl_trait_node_id = self.resolver.next_node_id();\n+                    let impl_trait_node_id = self.next_node_id();\n                     self.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n@@ -1001,7 +1007,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n-                        let node_id = this.resolver.next_node_id();\n+                        let node_id = this.next_node_id();\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: node_id,\n@@ -1101,7 +1107,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n                                 let parent_def_id = self.current_hir_id_owner;\n-                                let node_id = self.resolver.next_node_id();\n+                                let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n                                 self.create_def(\n@@ -1180,7 +1186,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         debug_assert_eq!(start.plus(1), end);\n                         start\n                     } else {\n-                        self.resolver.next_node_id()\n+                        self.next_node_id()\n                     };\n                     let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n@@ -1323,7 +1329,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n \n         let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n@@ -1341,7 +1347,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n                 |(_, &(span, p_id, p_name, _))| {\n                     let hir_id = lctx.lower_node_id(p_id);\n-                    debug_assert_ne!(lctx.resolver.opt_local_def_id(p_id), None);\n+                    debug_assert_ne!(lctx.opt_local_def_id(p_id), None);\n \n                     let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n                         hir::LifetimeParamKind::Elided\n@@ -1380,7 +1386,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let lifetimes = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n             |(_, (span, _, p_name, res))| {\n-                let id = self.resolver.next_node_id();\n+                let id = self.next_node_id();\n                 let ident = Ident::new(p_name.ident().name, span);\n                 let l = self.new_named_lifetime_with_res(id, span, ident, res);\n                 hir::GenericArg::Lifetime(l)\n@@ -1489,7 +1495,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match fn_node_id {\n                         Some(fn_node_id) if kind.impl_trait_return_allowed() => {\n-                            let fn_def_id = self.resolver.local_def_id(fn_node_id);\n+                            let fn_def_id = self.local_def_id(fn_node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             }\n@@ -1563,8 +1569,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n-        let fn_def_id = self.resolver.local_def_id(fn_node_id);\n+        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n+        let fn_def_id = self.local_def_id(fn_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1614,8 +1620,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?extra_lifetime_params);\n         for (ident, outer_node_id, outer_res) in extra_lifetime_params {\n             let Ident { name, span } = ident;\n-            let outer_def_id = self.resolver.local_def_id(outer_node_id);\n-            let inner_node_id = self.resolver.next_node_id();\n+            let outer_def_id = self.local_def_id(outer_node_id);\n+            let inner_node_id = self.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n             self.create_def(\n@@ -1665,7 +1671,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let generic_params =\n                 this.arena.alloc_from_iter(captures.iter().map(|(_, &(span, p_id, p_name, _))| {\n                     let hir_id = this.lower_node_id(p_id);\n-                    debug_assert_ne!(this.resolver.opt_local_def_id(p_id), None);\n+                    debug_assert_ne!(this.opt_local_def_id(p_id), None);\n \n                     let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n                         hir::LifetimeParamKind::Elided\n@@ -1717,7 +1723,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // generate `'_`.\n         let generic_args =\n             self.arena.alloc_from_iter(captures.into_iter().map(|(_, (span, _, p_name, res))| {\n-                let id = self.resolver.next_node_id();\n+                let id = self.next_node_id();\n                 let ident = Ident::new(p_name.ident().name, span);\n                 let l = self.new_named_lifetime_with_res(id, span, ident, res);\n                 hir::GenericArg::Lifetime(l)\n@@ -1811,9 +1817,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n                     if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n                         match captured_lifetimes.captures.entry(param) {\n-                            Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n+                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n                             Entry::Vacant(v) => {\n-                                let p_id = self.resolver.next_node_id();\n+                                let p_id = self.next_node_id();\n                                 let p_def_id = self.create_def(\n                                     captured_lifetimes.parent_def_id,\n                                     p_id,\n@@ -1837,9 +1843,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n                     if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n                         match captured_lifetimes.captures.entry(param) {\n-                            Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n+                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n                             Entry::Vacant(v) => {\n-                                let p_id = self.resolver.next_node_id();\n+                                let p_id = self.next_node_id();\n                                 let p_def_id = self.create_def(\n                                     captured_lifetimes.parent_def_id,\n                                     p_id,\n@@ -1862,7 +1868,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let mut l_name = None;\n                 if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n                     if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                        let p_id = self.resolver.next_node_id();\n+                        let p_id = self.next_node_id();\n                         let p_def_id = self.create_def(\n                             captured_lifetimes.parent_def_id,\n                             p_id,\n@@ -2011,7 +2017,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds: &[GenericBound],\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n-        let def_id = self.resolver.local_def_id(node_id);\n+        let def_id = self.local_def_id(node_id);\n \n         let hir_bounds = self.lower_param_bounds(bounds, ImplTraitContext::Universal);\n         // Set the name to `impl Bound1 + Bound2`."}]}