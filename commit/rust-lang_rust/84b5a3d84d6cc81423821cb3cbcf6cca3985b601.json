{"sha": "84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YjVhM2Q4NGQ2Y2M4MTQyMzgyMWNiM2NiY2Y2Y2NhMzk4NWI2MDE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-26T11:57:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:28Z"}, "message": "rustc_trans: remove the in_memory_type_of distinction.", "tree": {"sha": "030db46accfc3558ce9f5a0f3b7140c5b02c88dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/030db46accfc3558ce9f5a0f3b7140c5b02c88dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "html_url": "https://github.com/rust-lang/rust/commit/84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "html_url": "https://github.com/rust-lang/rust/commit/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb"}], "stats": {"total": 189, "additions": 77, "deletions": 112}, "files": [{"sha": "f4f37cdef514d2b95907c6ae511e09ffe155ffd2", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -32,7 +32,6 @@ use cabi_nvptx64;\n use cabi_hexagon;\n use mir::lvalue::LvalueRef;\n use type_::Type;\n-use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n@@ -564,7 +563,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     /// Get the LLVM type for an lvalue of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        type_of::type_of(ccx, self.layout.ty)\n+        ccx.llvm_type_of(self.layout.ty)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n@@ -975,7 +974,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         } else if let Some(cast) = self.ret.cast {\n             cast.llvm_type(ccx)\n         } else {\n-            type_of::immediate_type_of(ccx, self.ret.layout.ty)\n+            ccx.immediate_llvm_type_of(self.ret.layout.ty)\n         };\n \n         for arg in &self.args {\n@@ -992,7 +991,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             } else if let Some(cast) = arg.cast {\n                 cast.llvm_type(ccx)\n             } else {\n-                type_of::immediate_type_of(ccx, arg.layout.ty)\n+                ccx.immediate_llvm_type_of(arg.layout.ty)\n             };\n \n             llargument_tys.push(llarg_ty);"}, {"sha": "c2988cd3da3f269429326daa3dd27198c819f243", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -46,7 +46,6 @@ use rustc::ty::layout::{self, Align, HasDataLayout, LayoutTyper, Size, TyLayout}\n \n use context::CrateContext;\n use type_::Type;\n-use type_of;\n \n /// LLVM-level types are a little complicated.\n ///\n@@ -110,7 +109,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if let layout::Scalar { value: layout::Pointer, .. } = *nnfield {\n                 Type::i8p(cx)\n             } else {\n-                type_of::type_of(cx, nnfield.ty)\n+                cx.llvm_type_of(nnfield.ty)\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n@@ -237,7 +236,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             result.push(Type::array(&Type::i8(cx), padding.bytes()));\n             debug!(\"    padding before: {:?}\", padding);\n         }\n-        let llty = type_of::in_memory_type_of(cx, field.ty);\n+        let llty = cx.llvm_type_of(field.ty);\n         result.push(llty);\n \n         if variant.packed {"}, {"sha": "f4fbde2535fcb3984aa4461721c0887ae79d8df8", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -12,7 +12,6 @@\n \n use llvm::{self, ValueRef};\n use common::*;\n-use type_of;\n use type_::Type;\n use builder::Builder;\n \n@@ -52,7 +51,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         if out.is_indirect {\n             indirect_outputs.push(val.unwrap().immediate());\n         } else {\n-            output_types.push(type_of::type_of(bcx.ccx, ty));\n+            output_types.push(bcx.ccx.llvm_type_of(ty));\n         }\n     }\n     if !indirect_outputs.is_empty() {"}, {"sha": "a987fa4a40e55246e57024eb0156ce5bc90dc9f5", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -231,13 +231,13 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            let ptr_ty = bcx.ccx.llvm_type_of(b).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            let ptr_ty = bcx.ccx.llvm_type_of(b).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),"}, {"sha": "bb271a574a5e958f7f4b9d4800dcb7656834be76", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -25,7 +25,6 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc_back::PanicStrategy;\n-use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -56,7 +55,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n-    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n+    let llptrty = ccx.llvm_type_of(fn_ptr_ty);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "339405ab1baf01907b4f7cf25775c9371e434a1c", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -21,7 +21,6 @@ use common::{self, CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n-use type_of;\n use rustc::ty;\n use rustc::ty::layout::Align;\n \n@@ -113,7 +112,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.llvm_type_of(ty);\n         let (g, attrs) = match ccx.tcx().hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n@@ -158,7 +157,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                         }\n                     };\n                     let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => type_of::type_of(ccx, mt.ty),\n+                        ty::TyRawPtr(ref mt) => ccx.llvm_type_of(mt.ty),\n                         _ => {\n                             ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n                         }\n@@ -207,7 +206,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));\n+        let g = declare::declare_global(ccx, &sym, ccx.llvm_type_of(ty));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n@@ -267,7 +266,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n         let ty = common::instance_ty(ccx.tcx(), &instance);\n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.llvm_type_of(ty);\n         let g = if val_llty == llty {\n             g\n         } else {"}, {"sha": "dbb8ef261f83dd7e39712e056e3376b7c9c8a816", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -20,7 +20,6 @@ use base::*;\n use common::*;\n use declare;\n use glue;\n-use type_of;\n use type_::Type;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n@@ -105,7 +104,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n \n-    let llret_ty = type_of::type_of(ccx, ret_ty);\n+    let llret_ty = ccx.llvm_type_of(ret_ty);\n     let result = LvalueRef::new_sized(llresult, ret_ty, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);"}, {"sha": "380ed5266e9a5e64edbb5fa1e76a3e0e2ce2c4e3", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -23,7 +23,7 @@ use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use meth;\n use monomorphize;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n \n use syntax::symbol::Symbol;\n@@ -916,7 +916,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             src: &mir::Operand<'tcx>,\n                             dst: LvalueRef<'tcx>) {\n         let val = self.trans_operand(bcx, src);\n-        let llty = type_of::type_of(bcx.ccx, val.ty);\n+        let llty = bcx.ccx.llvm_type_of(val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());"}, {"sha": "e253701903f224223a18b26e4be276f3ab19747e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> Const<'tcx> {\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.llvm_type_of(ty);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let llty = type_of::immediate_type_of(ccx, self.ty);\n+        let llty = ccx.immediate_llvm_type_of(self.ty);\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, iv as u64)\n                         } else {\n-                            C_undef(type_of::type_of(self.ccx, projected_ty))\n+                            C_undef(self.ccx.llvm_type_of(projected_ty))\n                         };\n \n                         (Base::Value(llelem), ptr::null_mut())\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n             bug!(\"bad array type {:?}\", array_ty)\n         });\n-        let llunitty = type_of::type_of(self.ccx, elem_ty);\n+        let llunitty = self.ccx.llvm_type_of(elem_ty);\n         // If the array contains enums, an LLVM array won't work.\n         let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n             C_array(llunitty, fields)\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                         let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = type_of::in_memory_type_of(self.ccx, unsized_ty).ptr_to();\n+                        let ptr_ty = self.ccx.llvm_type_of(unsized_ty).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);\n                         let info = base::unsized_info(self.ccx, pointee_ty,\n                                                       unsized_ty, old_info);\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_out = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let ll_t_out = self.ccx.immediate_llvm_type_of(cast_ty);\n                         let llval = operand.llval;\n                         let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let l = self.ccx.layout_of(operand.ty);\n@@ -738,7 +738,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n+                                let llcast_ty = self.ccx.immediate_llvm_type_of(cast_ty);\n                                 consts::ptrcast(data_ptr, llcast_ty)\n                             }\n                         } else {\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = type_of::type_of(bcx.ccx, ty);\n+            let llty = bcx.ccx.llvm_type_of(ty);\n             Const::new(C_undef(llty), ty)\n         });\n \n@@ -1137,7 +1137,7 @@ fn trans_const_adt<'a, 'tcx>(\n                 assert_eq!(vals.len(), 1);\n                 Const::new(vals[0].llval, t)\n             } else {\n-                Const::new(C_null(type_of::type_of(ccx, t)), t)\n+                Const::new(C_null(ccx.llvm_type_of(t)), t)\n             }\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n@@ -1146,7 +1146,7 @@ fn trans_const_adt<'a, 'tcx>(\n             } else {\n                 // Always use null even if it's not the `discrfield`th\n                 // field; see #8506.\n-                Const::new(C_null(type_of::type_of(ccx, t)), t)\n+                Const::new(C_null(ccx.llvm_type_of(t)), t)\n             }\n         }\n         _ => bug!(\"trans_const_adt: cannot handle type {} repreented as {:#?}\", t, l)"}, {"sha": "77d99427da30f4c99ce6d2b1b225fbf4b37ead69", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -20,7 +20,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, C_usize, C_u8, C_u32, C_int, C_null, val_ty};\n use consts;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n use glue;\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n         let tmp = bcx.alloca(\n-            type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n+            bcx.ccx.llvm_type_of(ty), name, bcx.ccx.over_align_of(ty));\n         assert!(!ty.has_param_types());\n         Self::new_sized(tmp, ty, Alignment::AbiAligned)\n     }\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         // Handle all the non-aggregate cases first.\n         match *l {\n             layout::UntaggedUnion { .. } => {\n-                let ty = type_of::in_memory_type_of(ccx, fty);\n+                let ty = ccx.llvm_type_of(fty);\n                 return LvalueRef::new_sized(\n                     bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n             }\n@@ -222,14 +222,14 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 if l.variant_index.unwrap() as u64 != nndiscr => {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.d., Result of Either with (), as one side.)\n-                let ty = type_of::type_of(ccx, fty);\n+                let ty = ccx.llvm_type_of(fty);\n                 assert_eq!(ccx.size_of(fty).bytes(), 0);\n                 return LvalueRef::new_sized(\n                     bcx.pointercast(self.llval, ty.ptr_to()), fty,\n                     Alignment::Packed(Align::from_bytes(1, 1).unwrap()));\n             }\n             layout::RawNullablePointer { .. } => {\n-                let ty = type_of::type_of(ccx, fty);\n+                let ty = ccx.llvm_type_of(fty);\n                 return LvalueRef::new_sized(\n                     bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n             }\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = type_of::in_memory_type_of(ccx, fty);\n+        let ll_fty = ccx.llvm_type_of(fty);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         LvalueRef {\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             },\n             _ => bug!(\"{} is not an enum\", l.ty)\n         };\n-        let cast_to = type_of::immediate_type_of(bcx.ccx, cast_to);\n+        let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n         bcx.intcast(val, cast_to, adt::is_discr_signed(&l))\n     }\n \n@@ -581,7 +581,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // must cast the lvalue pointer type to the new\n                                 // array type (*[%_; new_len]).\n                                 subslice.llval = bcx.pointercast(subslice.llval,\n-                                    type_of::type_of(bcx.ccx, subslice.ty.to_ty(tcx)).ptr_to())\n+                                    bcx.ccx.llvm_type_of(subslice.ty.to_ty(tcx)).ptr_to())\n                             }\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.has_extra());"}, {"sha": "a03408390f95e7dd24d04a1257d46f0c31547b1e", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -483,7 +483,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     ty::TyAdt(def, _) if def.is_box() => arg_ty.boxed_ty(),\n                     _ => bug!()\n                 };\n-                let data_llty = type_of::in_memory_type_of(bcx.ccx, pointee);\n+                let data_llty = bcx.ccx.llvm_type_of(pointee);\n                 let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n \n                 let llarg = bcx.pointercast(llarg, data_llty.ptr_to());"}, {"sha": "b65a6453e6178e7cb42f5deaa3ab30a416ddda34", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -19,7 +19,7 @@ use base;\n use common::{self, CrateContext, C_undef};\n use builder::Builder;\n use value::Value;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n \n use std::fmt;\n use std::ptr;\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n                    ty: Ty<'tcx>) -> OperandRef<'tcx> {\n         assert!(common::type_is_zero_size(ccx, ty));\n-        let llty = type_of::type_of(ccx, ty);\n+        let llty = ccx.llvm_type_of(ty);\n         Const::new(C_undef(llty), ty).to_operand(ccx)\n     }\n \n@@ -116,7 +116,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n-            let llty = type_of::type_of(bcx.ccx, self.ty);\n+            let llty = bcx.ccx.llvm_type_of(self.ty);\n             let mut llpair = C_undef(llty);\n             let elems = [a, b];\n             let layout = bcx.ccx.layout_of(self.ty);"}, {"sha": "592181df852971249930784c1c7f01e035a40035", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = type_of::immediate_type_of(bcx.ccx, cast_ty);\n+                                let llcast_ty = bcx.ccx.immediate_llvm_type_of(cast_ty);\n                                 let llval = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -272,8 +272,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         debug_assert!(common::type_is_immediate(bcx.ccx, cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = type_of::immediate_type_of(bcx.ccx, operand.ty);\n-                        let ll_t_out = type_of::immediate_type_of(bcx.ccx, cast_ty);\n+                        let ll_t_in = bcx.ccx.immediate_llvm_type_of(operand.ty);\n+                        let ll_t_out = bcx.ccx.immediate_llvm_type_of(cast_ty);\n                         let llval = operand.immediate();\n                         let l = bcx.ccx.layout_of(operand.ty);\n                         let signed = if let Layout::CEnum { signed, min, max, .. } = *l {\n@@ -457,7 +457,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let llsize = C_usize(bcx.ccx, size.bytes());\n                 let llalign = C_usize(bcx.ccx, align.abi());\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n-                let llty_ptr = type_of::type_of(bcx.ccx, box_ty);\n+                let llty_ptr = bcx.ccx.llvm_type_of(box_ty);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {"}, {"sha": "a452ed21aef49a9d1b538c4a19702368f1b9910a", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -30,7 +30,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n-use type_of;\n use std::fmt;\n \n pub use rustc::middle::trans::TransItem;\n@@ -173,7 +172,7 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let def_id = ccx.tcx().hir.local_def_id(node_id);\n     let instance = Instance::mono(ccx.tcx(), def_id);\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n-    let llty = type_of::type_of(ccx, ty);\n+    let llty = ccx.llvm_type_of(ty);\n \n     let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n         ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),"}, {"sha": "e3f6485d46245c66889d32a86685cc468aa8bcda", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b5a3d84d6cc81423821cb3cbcf6cca3985b601/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "patch": "@@ -22,10 +22,10 @@ pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     match ty.sty {\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n         ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if ccx.shared().type_has_metadata(t) => {\n-            in_memory_type_of(ccx, t).ptr_to()\n+            ccx.llvm_type_of(t).ptr_to()\n         }\n         ty::TyAdt(def, _) if def.is_box() => {\n-            in_memory_type_of(ccx, ty.boxed_ty()).ptr_to()\n+            ccx.llvm_type_of(ty.boxed_ty()).ptr_to()\n         }\n         _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n     }\n@@ -43,44 +43,7 @@ pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-pub fn immediate_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if t.is_bool() {\n-        Type::i1(cx)\n-    } else {\n-        type_of(cx, t)\n-    }\n-}\n-\n-/// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n-/// This is the right LLVM type for an alloca containing a value of that type,\n-/// and the pointee of an Lvalue Datum (which is always a LLVM pointer).\n-/// For unsized types, the returned type is a fat pointer, thus the resulting\n-/// LLVM type for a `Trait` Lvalue is `{ i8*, void(i8*)** }*`, which is a double\n-/// indirection to the actual data, unlike a `i8` Lvalue, which is just `i8*`.\n-/// This is needed due to the treatment of immediate values, as a fat pointer\n-/// is too large for it to be placed in SSA value (by our rules).\n-/// For the raw type without far pointer indirection, see `in_memory_type_of`.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    let ty = if cx.shared().type_has_metadata(ty) {\n-        cx.tcx().mk_imm_ptr(ty)\n-    } else {\n-        ty\n-    };\n-    in_memory_type_of(cx, ty)\n-}\n-\n-/// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n-/// This is the right LLVM type for a field/array element of that type,\n-/// and is the same as `type_of` for all Sized types.\n-/// Unsized types, however, are represented by a \"minimal unit\", e.g.\n-/// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n-/// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n-/// If the type is an unsized struct, the regular layout is generated,\n-/// with the inner-most trailing unsized field using the \"minimal unit\"\n-/// of that field's type - this is useful for taking the address of\n-/// that field and ensuring the struct has the right alignment.\n-/// For the LLVM type of a value as a whole, see `type_of`.\n-pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+fn compute_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n     if let Some(&llty) = cx.lltypes().borrow().get(&t) {\n         return llty;\n@@ -98,7 +61,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     let t_norm = cx.tcx().erase_regions(&t);\n \n     if t != t_norm {\n-        let llty = in_memory_type_of(cx, t_norm);\n+        let llty = cx.llvm_type_of(t_norm);\n         debug!(\"--> normalized {:?} to {:?} llty={:?}\", t, t_norm, llty);\n         cx.lltypes().borrow_mut().insert(t, llty);\n         return llty;\n@@ -111,12 +74,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                 // unsized).\n                 cx.str_slice_type()\n             } else {\n-                let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n+                let ptr_ty = cx.llvm_type_of(ty).ptr_to();\n                 let info_ty = unsized_info_ty(cx, ty);\n                 Type::struct_(cx, &[ptr_ty, info_ty], false)\n             }\n         } else {\n-            in_memory_type_of(cx, ty).ptr_to()\n+            cx.llvm_type_of(ty).ptr_to()\n         }\n     };\n \n@@ -147,7 +110,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n \n       ty::TyArray(ty, size) => {\n-          let llty = in_memory_type_of(cx, ty);\n+          let llty = cx.llvm_type_of(ty);\n           let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n           Type::array(&llty, size)\n       }\n@@ -156,7 +119,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       // traits have the type of u8. This is so that the data pointer inside\n       // fat pointers is of the right type (e.g. for array accesses), even\n       // when taking the address of an unsized field in a struct.\n-      ty::TySlice(ty) => in_memory_type_of(cx, ty),\n+      ty::TySlice(ty) => cx.llvm_type_of(ty),\n       ty::TyStr | ty::TyDynamic(..) | ty::TyForeign(..) => Type::i8(cx),\n \n       ty::TyFnDef(..) => Type::nil(cx),\n@@ -175,7 +138,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                                         a non-machine element type `{}`\",\n                                        t, e))\n           }\n-          let llet = in_memory_type_of(cx, e);\n+          let llet = cx.llvm_type_of(e);\n           let n = t.simd_size(cx.tcx()) as u64;\n           Type::vector(&llet, n)\n       }\n@@ -225,8 +188,8 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     }\n \n     /// Returns alignment if it is different than the primitive alignment.\n-    pub fn over_align_of(&self, t: Ty<'tcx>) -> Option<Align> {\n-        let layout = self.layout_of(t);\n+    pub fn over_align_of(&self, ty: Ty<'tcx>) -> Option<Align> {\n+        let layout = self.layout_of(ty);\n         let align = layout.align(self);\n         let primitive_align = layout.primitive_align(self);\n         if align != primitive_align {\n@@ -235,6 +198,29 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n             None\n         }\n     }\n+\n+    /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n+    /// The pointee type of the pointer in `LvalueRef` is always this type.\n+    /// For sized types, it is also the right LLVM type for an `alloca`\n+    /// containing a value of that type, and most immediates (except `bool`).\n+    /// Unsized types, however, are represented by a \"minimal unit\", e.g.\n+    /// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n+    /// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n+    /// If the type is an unsized struct, the regular layout is generated,\n+    /// with the inner-most trailing unsized field using the \"minimal unit\"\n+    /// of that field's type - this is useful for taking the address of\n+    /// that field and ensuring the struct has the right alignment.\n+    pub fn llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n+        compute_llvm_type(self, ty)\n+    }\n+\n+    pub fn immediate_llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n+        if ty.is_bool() {\n+            Type::i1(self)\n+        } else {\n+            self.llvm_type_of(ty)\n+        }\n+    }\n }\n \n pub trait LayoutLlvmExt {"}, {"sha": "5dd0cd8ba53138b43d5f5db9bf48820067c8c428", "filename": "src/test/run-pass/issue-30276.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Ftest%2Frun-pass%2Fissue-30276.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Ftest%2Frun-pass%2Fissue-30276.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30276.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Test([i32]);\n-fn main() {\n-    let _x: fn(_) -> Test = Test;\n-}"}]}