{"sha": "24c93efbb58f6644a62c231916144cc0af55a503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YzkzZWZiYjU4ZjY2NDRhNjJjMjMxOTE2MTQ0Y2MwYWY1NWE1MDM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-01T01:38:28Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:38:36Z"}, "message": "Move type of discriminant to AdtDef\n\nPreviously AdtDef variants contained ConstInt for each discriminant, which did not really reflect\nthe actual type of the discriminants. Moving the type into AdtDef allows to easily put the type\ninto metadata and also saves bytes from ConstVal overhead for each discriminant.\n\nAlso arguably the code is cleaner now :)", "tree": {"sha": "928dc8641d499d90bfcb515bb855d8a5b966c108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928dc8641d499d90bfcb515bb855d8a5b966c108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24c93efbb58f6644a62c231916144cc0af55a503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24c93efbb58f6644a62c231916144cc0af55a503", "html_url": "https://github.com/rust-lang/rust/commit/24c93efbb58f6644a62c231916144cc0af55a503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24c93efbb58f6644a62c231916144cc0af55a503/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98d1db7fe36fe5454937f40d9fcb4fe97f36bbeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d1db7fe36fe5454937f40d9fcb4fe97f36bbeb", "html_url": "https://github.com/rust-lang/rust/commit/98d1db7fe36fe5454937f40d9fcb4fe97f36bbeb"}], "stats": {"total": 227, "additions": 105, "deletions": 122}, "files": [{"sha": "19bb8a63aa277fe3879c6db734641707166b7d25", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -673,10 +673,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n+                         discr_ty: Option<attr::IntType>,\n                          variants: Vec<ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n+        let discr_ty = discr_ty.unwrap_or(attr::UnsignedInt(ast::UintTy::U8));\n+        let def = ty::AdtDef::new(self, did, kind, discr_ty, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n "}, {"sha": "4d3a17e51c1f2d8380bc8e0e4cca56b27202012e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -20,7 +20,6 @@ use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n-use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -1183,10 +1182,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n                                                             i64::min_value(),\n                                                             true);\n                     for v in &def.variants {\n-                        let x = match v.disr_val.erase_type() {\n-                            ConstInt::InferSigned(i) => i as i64,\n-                            ConstInt::Infer(i) => i as u64 as i64,\n-                            _ => bug!()\n+                        let x = match def.discr_ty {\n+                            attr::IntType::SignedInt(IntTy::I128) |\n+                            attr::IntType::UnsignedInt(UintTy::U128) =>\n+                                bug!(\"128-bit discriminants not yet supported\"),\n+                            attr::IntType::SignedInt(_) => v.disr_val as i64,\n+                            attr::IntType::UnsignedInt(_) => v.disr_val as u64 as i64,\n                         };\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n@@ -1247,7 +1248,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u128 != v.disr_val.to_u128_unchecked() {\n+                    if i as u128 != v.disr_val {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }"}, {"sha": "5ec27b57c37adb9103cfcbbcb9d177bfd0bcb2eb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -45,7 +45,6 @@ use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n-use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n \n use hir;\n@@ -72,6 +71,8 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::trait_def::{TraitDef, TraitFlags};\n \n+use rustc_i128::u128;\n+\n pub mod adjustment;\n pub mod cast;\n pub mod error;\n@@ -96,7 +97,7 @@ mod flags;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = ConstInt;\n+pub type Disr = u128;\n \n // Data types\n \n@@ -1325,6 +1326,7 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n+    pub discr_ty: attr::IntType, // Type of the discriminant\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n@@ -1387,6 +1389,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n+           discr_ty: attr::IntType,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -1410,6 +1413,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n         AdtDef {\n             did: did,\n+            discr_ty: discr_ty,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),"}, {"sha": "1df87da42274c292ed2cebe9aa183f16da537ae8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 12, "deletions": 49, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -23,7 +23,7 @@ use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n+use rustc_const_math::ConstInt;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n@@ -34,14 +34,15 @@ use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::Span;\n \n+use rustc_i128::i128;\n+\n use hir;\n \n pub trait IntTypeExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n     fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n                            -> Option<Disr>;\n-    fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n@@ -62,56 +63,18 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n-            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n-            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n-            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n-            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n-            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n-                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n-                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n-                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n-                _ => bug!(),\n-            },\n-            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n-            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n-            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n-            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n-            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n-            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n-                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n-                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n-                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n-                _ => bug!(),\n-            },\n-        }\n-    }\n-\n-    fn assert_ty_matches(&self, val: Disr) {\n-        match (*self, val) {\n-            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n-            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n-            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n-            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n-            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n-            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n-            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n-            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n-            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n-            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n-            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n-            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n-            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n-        }\n+    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n+        0\n     }\n \n+    /// None = overflow\n     fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr> {\n+    -> Option<Disr> {\n         if let Some(val) = val {\n-            self.assert_ty_matches(val);\n-            (val + ConstInt::Infer(1)).ok()\n+            match *self {\n+                SignedInt(it) => ConstInt::new_signed(val as i128, it, tcx.sess.target.int_type),\n+                UnsignedInt(it) => ConstInt::new_unsigned(val, it, tcx.sess.target.uint_type),\n+            }.and_then(|l| (l + ConstInt::Infer(1)).ok()).map(|v| v.to_u128_unchecked())\n         } else {\n             Some(self.initial_discriminant(tcx))\n         }"}, {"sha": "88c04d88a6fc01906fd87b543e9aa02bfb3c8689", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -25,8 +25,6 @@ use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n-use rustc_const_math::ConstInt;\n-\n use rustc::mir::Mir;\n \n use std::borrow::Cow;\n@@ -435,7 +433,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::Enum(_) => Def::Enum(did),\n+            EntryKind::Enum(..) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n@@ -535,7 +533,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            disr_val: ConstInt::Infer(data.disr),\n+            disr_val: data.disr,\n             ctor_kind: data.ctor_kind,\n         }, data.struct_ctor)\n     }\n@@ -546,6 +544,12 @@ impl<'a, 'tcx> CrateMetadata {\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n+        let (kind, ty) = match item.kind {\n+            EntryKind::Enum(dt, _) => (ty::AdtKind::Enum, Some(dt.decode(self))),\n+            EntryKind::Struct(_) => (ty::AdtKind::Struct, None),\n+            EntryKind::Union(_) => (ty::AdtKind::Union, None),\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n+        };\n         let mut ctor_index = None;\n         let variants = if let EntryKind::Enum(_) = item.kind {\n             item.children\n@@ -562,13 +566,13 @@ impl<'a, 'tcx> CrateMetadata {\n             vec![variant]\n         };\n         let (kind, repr) = match item.kind {\n-            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Enum(_, repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n+        let adt = tcx.alloc_adt_def(did, kind, ty, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n             tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);"}, {"sha": "b913f68e5842a9e0dec8545274639194017c4ed6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u128_unchecked(),\n+            disr: variant.disr_val,\n             struct_ctor: None,\n         };\n \n@@ -388,7 +388,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u128_unchecked(),\n+            disr: variant.disr_val,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -661,7 +661,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n+            hir::ItemEnum(..) => EntryKind::Enum(self.lazy(&tcx.lookup_adt_def(def_id).discr_ty), get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -678,7 +678,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u128_unchecked(),\n+                    disr: variant.disr_val,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u128_unchecked(),\n+                    disr: variant.disr_val,\n                     struct_ctor: None,\n                 }), repr_options)\n             }"}, {"sha": "777af02772ec17565a15c677ba691145d182e330", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -228,7 +228,7 @@ pub enum EntryKind<'tcx> {\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum(ReprOptions),\n+    Enum(Lazy<attr::IntType>, ReprOptions),\n     Field,\n     Variant(Lazy<VariantData>),\n     Struct(Lazy<VariantData>, ReprOptions),"}, {"sha": "9ae83991962a517b6cf477ac825d78274a536591", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -1473,7 +1473,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    v.disr_val.to_u128_unchecked() as u64)\n+                    v.disr_val as u64)\n             }\n         })\n         .collect();"}, {"sha": "f3a62bc85b8d93252c441c43ca62f63e9ab0e24e", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -27,7 +27,7 @@ impl ::std::ops::BitAnd for Disr {\n impl From<::rustc::ty::Disr> for Disr {\n     fn from(i: ::rustc::ty::Disr) -> Disr {\n         // FIXME: what if discr has 128 bit discr?\n-        Disr(i.to_u128_unchecked() as u64)\n+        Disr(i as u64)\n     }\n }\n "}, {"sha": "c1b4531f85e061757ed25755569ab752426dc33f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c93efbb58f6644a62c231916144cc0af55a503/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=24c93efbb58f6644a62c231916144cc0af55a503", "patch": "@@ -1004,9 +1004,8 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = ccx.tcx.hir.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n-    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n-                                               ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name, 0, def)];\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, None, variants,\n         ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n@@ -1023,63 +1022,69 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.hir.local_def_id(it.id);\n+<<<<<<< HEAD\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n \n     let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n+=======\n+    let variants = vec![convert_struct_variant(ccx, did, it.name, 0, def)];\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, None, variants);\n+>>>>>>> b1934037e6... Move type of discriminant to AdtDef\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n-    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n-                          -> Option<ty::Disr> {\n-        let e = &ccx.tcx.hir.body(body).value;\n-        debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n-\n-        let ty_hint = repr_ty.to_ty(ccx.tcx);\n-        let print_err = |cv: ConstVal| {\n-            struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n-                .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n-                .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n-                .emit();\n-        };\n+fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n+                      -> Option<ty::Disr> {\n+    let e = &ccx.tcx.hir.body(body).value;\n+    debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n+\n+    let ty_hint = repr_ty.to_ty(ccx.tcx);\n+    let print_err = |cv: ConstVal| {\n+        struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n+            .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n+            .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n+            .emit();\n+    };\n \n-        let hint = UncheckedExprHint(ty_hint);\n-        match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n-            Ok(ConstVal::Integral(i)) => {\n-                // FIXME: eval should return an error if the hint is wrong\n-                match (repr_ty, i) {\n-                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n-                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n-                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n-                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n-                    (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n-                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n-                    (_, i) => {\n-                        print_err(ConstVal::Integral(i));\n-                        None\n-                    },\n-                }\n-            },\n-            Ok(cv) => {\n-                print_err(cv);\n-                None\n-            },\n-            // enum variant evaluation happens before the global constant check\n-            // so we need to report the real error\n-            Err(err) => {\n-                let mut diag = report_const_eval_err(\n-                    ccx.tcx, &err, e.span, \"enum discriminant\");\n-                diag.emit();\n-                None\n+    let hint = UncheckedExprHint(ty_hint);\n+    match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n+        Ok(ConstVal::Integral(i)) => {\n+            // FIXME: eval should return an error if the hint is wrong\n+            match (repr_ty, i) {\n+                (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n+                (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n+                (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n+                (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n+                (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n+                (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) =>\n+                    Some(i.to_u128_unchecked()),\n+                (_, i) => {\n+                    print_err(ConstVal::Integral(i));\n+                    None\n+                },\n             }\n+        },\n+        Ok(cv) => {\n+            print_err(cv);\n+            None\n+        },\n+        // enum variant evaluation happens before the global constant check\n+        // so we need to report the real error\n+        Err(err) => {\n+            let mut diag = report_const_eval_err(\n+                ccx.tcx, &err, e.span, \"enum discriminant\");\n+            diag.emit();\n+            None\n         }\n     }\n+}\n \n fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               it: &hir::Item,\n@@ -1093,7 +1098,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_disr = None::<ty::Disr>;\n     let variants = def.variants.iter().map(|v| {\n-        let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n+        let wrapped_disr = prev_disr.map_or(initial, |d| d.wrapping_add(1));\n         let disr = if let Some(e) = v.node.disr_expr {\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n@@ -1113,7 +1118,11 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n \n+<<<<<<< HEAD\n     let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n+=======\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, Some(repr_type), variants);\n+>>>>>>> b1934037e6... Move type of discriminant to AdtDef\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}]}