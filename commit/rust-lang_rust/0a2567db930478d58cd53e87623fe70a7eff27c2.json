{"sha": "0a2567db930478d58cd53e87623fe70a7eff27c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMjU2N2RiOTMwNDc4ZDU4Y2Q1M2U4NzYyM2ZlNzBhN2VmZjI3YzI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-07-19T15:00:36Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-07-19T15:42:00Z"}, "message": "Implement RFC style for match\n\nPut the opening brace of match arm's body on the next line if the pattern has\nguard and consists of multi lines.", "tree": {"sha": "1bbea5ad2d6bdc57b6a78619ea1cb443e42fa67b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bbea5ad2d6bdc57b6a78619ea1cb443e42fa67b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2567db930478d58cd53e87623fe70a7eff27c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2567db930478d58cd53e87623fe70a7eff27c2", "html_url": "https://github.com/rust-lang/rust/commit/0a2567db930478d58cd53e87623fe70a7eff27c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2567db930478d58cd53e87623fe70a7eff27c2/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de403f4f65e0c22de2ebab9b034154203a204940", "url": "https://api.github.com/repos/rust-lang/rust/commits/de403f4f65e0c22de2ebab9b034154203a204940", "html_url": "https://github.com/rust-lang/rust/commit/de403f4f65e0c22de2ebab9b034154203a204940"}], "stats": {"total": 141, "additions": 76, "deletions": 65}, "files": [{"sha": "8aa82aa621d115ce04da2e9db7e9e058dba56dcf", "filename": "src/expr.rs", "status": "modified", "additions": 76, "deletions": 65, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0a2567db930478d58cd53e87623fe70a7eff27c2/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2567db930478d58cd53e87623fe70a7eff27c2/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0a2567db930478d58cd53e87623fe70a7eff27c2", "patch": "@@ -1549,45 +1549,6 @@ fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n     }\n }\n \n-fn rewrite_match_pattern(\n-    context: &RewriteContext,\n-    pats: &Vec<ptr::P<ast::Pat>>,\n-    guard: &Option<ptr::P<ast::Expr>>,\n-    shape: Shape,\n-) -> Option<String> {\n-    // Patterns\n-    // 5 = ` => {`\n-    let pat_shape = try_opt!(shape.sub_width(5));\n-\n-    let pat_strs = try_opt!(\n-        pats.iter()\n-            .map(|p| p.rewrite(context, pat_shape))\n-            .collect::<Option<Vec<_>>>()\n-    );\n-\n-    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n-    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n-    let fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \" |\",\n-        trailing_separator: SeparatorTactic::Never,\n-        shape: pat_shape,\n-        ends_with_newline: false,\n-        config: context.config,\n-    };\n-    let pats_str = try_opt!(write_list(&items, &fmt));\n-\n-    // Guard\n-    let guard_str = try_opt!(rewrite_guard(\n-        context,\n-        guard,\n-        shape,\n-        trimmed_last_line_width(&pats_str),\n-    ));\n-\n-    Some(format!(\"{}{}\", pats_str, guard_str))\n-}\n-\n fn rewrite_match_arms(\n     context: &RewriteContext,\n     arms: &[ast::Arm],\n@@ -1677,6 +1638,45 @@ fn rewrite_match_arm(context: &RewriteContext, arm: &ast::Arm, shape: Shape) ->\n     rewrite_match_body(context, &arm.body, &pats_str, shape, arm.guard.is_some())\n }\n \n+fn rewrite_match_pattern(\n+    context: &RewriteContext,\n+    pats: &Vec<ptr::P<ast::Pat>>,\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    shape: Shape,\n+) -> Option<String> {\n+    // Patterns\n+    // 5 = ` => {`\n+    let pat_shape = try_opt!(shape.sub_width(5));\n+\n+    let pat_strs = try_opt!(\n+        pats.iter()\n+            .map(|p| p.rewrite(context, pat_shape))\n+            .collect::<Option<Vec<_>>>()\n+    );\n+\n+    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \" |\",\n+        trailing_separator: SeparatorTactic::Never,\n+        shape: pat_shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n+    let pats_str = try_opt!(write_list(&items, &fmt));\n+\n+    // Guard\n+    let guard_str = try_opt!(rewrite_guard(\n+        context,\n+        guard,\n+        shape,\n+        trimmed_last_line_width(&pats_str),\n+    ));\n+\n+    Some(format!(\"{}{}\", pats_str, guard_str))\n+}\n+\n fn rewrite_match_body(\n     context: &RewriteContext,\n     body: &ptr::P<ast::Expr>,\n@@ -1699,48 +1699,56 @@ fn rewrite_match_body(\n     let comma = arm_comma(&context.config, body);\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let alt_block_sep = alt_block_sep.as_str();\n-    let is_block = if let ast::ExprKind::Block(..) = body.node {\n-        true\n+    let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n+        (true, is_empty_block(block, context.codemap))\n     } else {\n-        false\n+        (false, false)\n     };\n \n     let combine_orig_body = |body_str: &str| {\n         let block_sep = match context.config.control_brace_style() {\n             ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep,\n-            _ if has_guard && pats_str.contains('\\n') && is_block && body_str != \"{}\" => {\n-                alt_block_sep\n-            }\n             _ => \" \",\n         };\n \n         Some(format!(\"{} =>{}{}{}\", pats_str, block_sep, body_str, comma))\n     };\n \n+    let forbid_same_line = has_guard && pats_str.contains('\\n') && !is_empty_block;\n+    let next_line_indent = if is_block {\n+        shape.indent\n+    } else {\n+        shape.indent.block_indent(context.config)\n+    };\n     let combine_next_line_body = |body_str: &str| {\n-        let indent_str = shape\n-            .indent\n-            .block_indent(context.config)\n-            .to_string(context.config);\n+        if is_block {\n+            return Some(format!(\n+                \"{} =>\\n{}{}\",\n+                pats_str,\n+                next_line_indent.to_string(context.config),\n+                body_str\n+            ));\n+        }\n+\n+        let indent_str = shape.indent.to_string(context.config);\n+        let nested_indent_str = next_line_indent.to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n             let comma = if context.config.match_block_trailing_comma() {\n                 \",\"\n             } else {\n                 \"\"\n             };\n-            (\n-                \"{\",\n-                format!(\"\\n{}}}{}\", shape.indent.to_string(context.config), comma),\n-            )\n+            (\"{\", format!(\"\\n{}}}{}\", indent_str, comma))\n         } else {\n             (\"\", String::from(\",\"))\n         };\n \n         let block_sep = match context.config.control_brace_style() {\n             ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n             _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n-            _ => \" \".to_owned() + body_prefix + \"\\n\",\n-        } + &indent_str;\n+            _ if forbid_same_line => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n+            _ => format!(\" {}\\n\", body_prefix),\n+        } + &nested_indent_str;\n \n         Some(format!(\n             \"{} =>{}{}{}\",\n@@ -1753,19 +1761,20 @@ fn rewrite_match_body(\n \n     // Let's try and get the arm body on the same line as the condition.\n     // 4 = ` => `.len()\n-    let orig_arm_shape = shape\n+    let orig_body_shape = shape\n         .offset_left(extra_offset(&pats_str, shape) + 4)\n         .and_then(|shape| shape.sub_width(comma.len()));\n-    let orig_body = if let Some(arm_shape) = orig_arm_shape {\n+    let orig_body = if let Some(body_shape) = orig_body_shape {\n         let rewrite = nop_block_collapse(\n-            format_expr(body, ExprType::Statement, context, arm_shape),\n-            arm_shape.width,\n+            format_expr(body, ExprType::Statement, context, body_shape),\n+            body_shape.width,\n         );\n \n         match rewrite {\n             Some(ref body_str)\n-                if ((!body_str.contains('\\n')) && first_line_width(body_str) <= arm_shape.width) ||\n-                    is_block =>\n+                if !forbid_same_line &&\n+                    (is_block ||\n+                         (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n             {\n                 return combine_orig_body(body_str);\n             }\n@@ -1774,18 +1783,20 @@ fn rewrite_match_body(\n     } else {\n         None\n     };\n-    let orig_budget = orig_arm_shape.map_or(0, |shape| shape.width);\n+    let orig_budget = orig_body_shape.map_or(0, |shape| shape.width);\n \n     // Try putting body on the next line and see if it looks better.\n-    let next_line_body_shape =\n-        Shape::indented(shape.indent.block_indent(context.config), context.config);\n+    let next_line_body_shape = Shape::indented(next_line_indent, context.config);\n     let next_line_body = nop_block_collapse(\n         format_expr(body, ExprType::Statement, context, next_line_body_shape),\n         next_line_body_shape.width,\n     );\n     match (orig_body, next_line_body) {\n         (Some(ref orig_str), Some(ref next_line_str))\n-            if prefer_next_line(orig_str, next_line_str) => combine_next_line_body(next_line_str),\n+            if forbid_same_line || prefer_next_line(orig_str, next_line_str) =>\n+        {\n+            combine_next_line_body(next_line_str)\n+        }\n         (Some(ref orig_str), _) if extend && first_line_width(orig_str) <= orig_budget => {\n             combine_orig_body(orig_str)\n         }"}]}