{"sha": "c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "node_id": "C_kwDOAAsO6NoAKGM5ZTEzNGUxYjYwOWU1NzFmNGQ3ZDE4ZjkxZjBjY2IxYTBjYjY4NWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-01T15:40:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-01T15:40:43Z"}, "message": "Auto merge of #100024 - matthiaskrgr:rollup-36ab4wx, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #99340 (Fix ICE in Definitions::create_def)\n - #99629 (Improve `cannot move out of` error message)\n - #99864 (bootstrap: don't emit warn about duplicated deps with same/different features if some of sets actually empty)\n - #99911 (Remove some uses of `guess_head_span`)\n - #99976 (Make Rustdoc exit with correct error code when scraping examples from invalid files)\n - #100003 (Improve size assertions.)\n - #100012 (Avoid `Ty` to `String` conversions)\n - #100020 (better error when python is not found in x - issue #99648)\n\nFailed merges:\n\n - #99994 (Replace `guess_head_span` with `opt_span`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b38a9b292ee26403c80808d1c4cb74d67c011b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b38a9b292ee26403c80808d1c4cb74d67c011b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "html_url": "https://github.com/rust-lang/rust/commit/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcb444af0a417766dde9b7b8f537fa1ba1568daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb444af0a417766dde9b7b8f537fa1ba1568daf", "html_url": "https://github.com/rust-lang/rust/commit/dcb444af0a417766dde9b7b8f537fa1ba1568daf"}, {"sha": "058ea7a955982a7bcb3ba72c1b644558241c96e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/058ea7a955982a7bcb3ba72c1b644558241c96e4", "html_url": "https://github.com/rust-lang/rust/commit/058ea7a955982a7bcb3ba72c1b644558241c96e4"}], "stats": {"total": 744, "additions": 421, "deletions": 323}, "files": [{"sha": "116497109f1ddb0bcd0740db3702f8281fea94ae", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1111,10 +1111,6 @@ pub struct Expr {\n     pub tokens: Option<LazyTokenStream>,\n }\n \n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr, 104);\n-\n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n     /// for example, an `if` condition.\n@@ -2883,9 +2879,6 @@ pub enum ItemKind {\n     MacroDef(MacroDef),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ItemKind, 112);\n-\n impl ItemKind {\n     pub fn article(&self) -> &str {\n         use ItemKind::*;\n@@ -2957,9 +2950,6 @@ pub enum AssocItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n-\n impl AssocItemKind {\n     pub fn defaultness(&self) -> Defaultness {\n         match *self {\n@@ -3009,9 +2999,6 @@ pub enum ForeignItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n-\n impl From<ForeignItemKind> for ItemKind {\n     fn from(foreign_item_kind: ForeignItemKind) -> ItemKind {\n         match foreign_item_kind {\n@@ -3038,3 +3025,27 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n }\n \n pub type ForeignItem = Item<ForeignItemKind>;\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n+    rustc_data_structures::static_assert_size!(Attribute, 152);\n+    rustc_data_structures::static_assert_size!(Block, 48);\n+    rustc_data_structures::static_assert_size!(Expr, 104);\n+    rustc_data_structures::static_assert_size!(Fn, 192);\n+    rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n+    rustc_data_structures::static_assert_size!(GenericBound, 88);\n+    rustc_data_structures::static_assert_size!(Generics, 72);\n+    rustc_data_structures::static_assert_size!(Impl, 200);\n+    rustc_data_structures::static_assert_size!(Item, 200);\n+    rustc_data_structures::static_assert_size!(ItemKind, 112);\n+    rustc_data_structures::static_assert_size!(Lit, 48);\n+    rustc_data_structures::static_assert_size!(Pat, 120);\n+    rustc_data_structures::static_assert_size!(Path, 40);\n+    rustc_data_structures::static_assert_size!(PathSegment, 24);\n+    rustc_data_structures::static_assert_size!(Stmt, 32);\n+    rustc_data_structures::static_assert_size!(Ty, 96);\n+}"}, {"sha": "5da260f980fbb3126046819a188e5843ab88d103", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -39,7 +39,7 @@ use crate::{\n \n use super::{\n     explain_borrow::{BorrowExplanation, LaterUseKind},\n-    IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    DescribePlaceOpt, RegionName, RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -137,7 +137,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 partially_str,\n-                self.describe_place_with_options(moved_place, IncludingDowncast(true)),\n+                self.describe_place_with_options(\n+                    moved_place,\n+                    DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n+                ),\n             );\n \n             let reinit_spans = maybe_reinitialized_locations\n@@ -274,8 +277,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            let opt_name =\n-                self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n+            let opt_name = self.describe_place_with_options(\n+                place.as_ref(),\n+                DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n+            );\n             let note_msg = match opt_name {\n                 Some(ref name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n@@ -341,12 +346,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let (name, desc) =\n-            match self.describe_place_with_options(moved_place, IncludingDowncast(true)) {\n-                Some(name) => (format!(\"`{name}`\"), format!(\"`{name}` \")),\n-                None => (\"the variable\".to_string(), String::new()),\n-            };\n-        let path = match self.describe_place_with_options(used_place, IncludingDowncast(true)) {\n+        let (name, desc) = match self.describe_place_with_options(\n+            moved_place,\n+            DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n+        ) {\n+            Some(name) => (format!(\"`{name}`\"), format!(\"`{name}` \")),\n+            None => (\"the variable\".to_string(), String::new()),\n+        };\n+        let path = match self.describe_place_with_options(\n+            used_place,\n+            DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n+        ) {\n             Some(name) => format!(\"`{name}`\"),\n             None => \"value\".to_string(),\n         };"}, {"sha": "098e8de9420fb89ef02b228382f0654bdee29975", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -4,7 +4,7 @@ use itertools::Itertools;\n use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n-use rustc_hir::def::Namespace;\n+use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::GeneratorKind;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::tcx::PlaceTy;\n@@ -16,7 +16,7 @@ use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::{symbol::sym, Span, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n \n@@ -43,7 +43,15 @@ pub(crate) use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionError\n pub(crate) use region_name::{RegionName, RegionNameSource};\n pub(crate) use rustc_const_eval::util::CallKind;\n \n-pub(super) struct IncludingDowncast(pub(super) bool);\n+pub(super) struct DescribePlaceOpt {\n+    pub including_downcast: bool,\n+\n+    /// Enable/Disable tuple fields.\n+    /// For example `x` tuple. if it's `true` `x.0`. Otherwise `x`\n+    pub including_tuple_field: bool,\n+}\n+\n+pub(super) struct IncludingTupleField(pub(super) bool);\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Adds a suggestion when a closure is invoked twice with a moved variable or when a closure\n@@ -164,7 +172,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// End-user visible description of `place` if one can be found.\n     /// If the place is a temporary for instance, `None` will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n-        self.describe_place_with_options(place_ref, IncludingDowncast(false))\n+        self.describe_place_with_options(\n+            place_ref,\n+            DescribePlaceOpt { including_downcast: false, including_tuple_field: true },\n+        )\n     }\n \n     /// End-user visible description of `place` if one can be found. If the place is a temporary\n@@ -174,7 +185,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(super) fn describe_place_with_options(\n         &self,\n         place: PlaceRef<'tcx>,\n-        including_downcast: IncludingDowncast,\n+        opt: DescribePlaceOpt,\n     ) -> Option<String> {\n         let local = place.local;\n         let mut autoderef_index = None;\n@@ -224,7 +235,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         }\n                     }\n                 }\n-                ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n+                ProjectionElem::Downcast(..) if opt.including_downcast => return None,\n                 ProjectionElem::Downcast(..) => (),\n                 ProjectionElem::Field(field, _ty) => {\n                     // FIXME(project-rfc_2229#36): print capture precisely here.\n@@ -238,9 +249,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let field_name = self.describe_field(\n                             PlaceRef { local, projection: place.projection.split_at(index).0 },\n                             *field,\n+                            IncludingTupleField(opt.including_tuple_field),\n                         );\n-                        buf.push('.');\n-                        buf.push_str(&field_name);\n+                        if let Some(field_name_str) = field_name {\n+                            buf.push('.');\n+                            buf.push_str(&field_name_str);\n+                        }\n                     }\n                 }\n                 ProjectionElem::Index(index) => {\n@@ -261,6 +275,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         ok.ok().map(|_| buf)\n     }\n \n+    fn describe_name(&self, place: PlaceRef<'tcx>) -> Option<Symbol> {\n+        for elem in place.projection.into_iter() {\n+            match elem {\n+                ProjectionElem::Downcast(Some(name), _) => {\n+                    return Some(*name);\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+\n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     /// a name, or its name was generated by the compiler, then `Err` is returned\n     fn append_local_to_string(&self, local: Local, buf: &mut String) -> Result<(), ()> {\n@@ -275,7 +301,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, place: PlaceRef<'tcx>, field: Field) -> String {\n+    fn describe_field(\n+        &self,\n+        place: PlaceRef<'tcx>,\n+        field: Field,\n+        including_tuple_field: IncludingTupleField,\n+    ) -> Option<String> {\n         let place_ty = match place {\n             PlaceRef { local, projection: [] } => PlaceTy::from_ty(self.body.local_decls[local].ty),\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n@@ -289,7 +320,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n         };\n-        self.describe_field_from_ty(place_ty.ty, field, place_ty.variant_index)\n+        self.describe_field_from_ty(\n+            place_ty.ty,\n+            field,\n+            place_ty.variant_index,\n+            including_tuple_field,\n+        )\n     }\n \n     /// End-user visible description of the `field_index`nth field of `ty`\n@@ -298,10 +334,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         ty: Ty<'_>,\n         field: Field,\n         variant_index: Option<VariantIdx>,\n-    ) -> String {\n+        including_tuple_field: IncludingTupleField,\n+    ) -> Option<String> {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(ty.boxed_ty(), field, variant_index)\n+            self.describe_field_from_ty(ty.boxed_ty(), field, variant_index, including_tuple_field)\n         } else {\n             match *ty.kind() {\n                 ty::Adt(def, _) => {\n@@ -311,14 +348,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     } else {\n                         def.non_enum_variant()\n                     };\n-                    variant.fields[field.index()].name.to_string()\n+                    if !including_tuple_field.0 && variant.ctor_kind == CtorKind::Fn {\n+                        return None;\n+                    }\n+                    Some(variant.fields[field.index()].name.to_string())\n                 }\n-                ty::Tuple(_) => field.index().to_string(),\n+                ty::Tuple(_) => Some(field.index().to_string()),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index, including_tuple_field)\n                 }\n                 ty::Array(ty, _) | ty::Slice(ty) => {\n-                    self.describe_field_from_ty(ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index, including_tuple_field)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // We won't be borrowck'ing here if the closure came from another crate,\n@@ -335,7 +375,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .unwrap()\n                         .get_root_variable();\n \n-                    self.infcx.tcx.hir().name(var_id).to_string()\n+                    Some(self.infcx.tcx.hir().name(var_id).to_string())\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented"}, {"sha": "cb3cd479ae2b63dbe446495b3a115051d8516113", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -6,7 +6,7 @@ use rustc_mir_dataflow::move_paths::{\n };\n use rustc_span::Span;\n \n-use crate::diagnostics::UseSpans;\n+use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n \n@@ -368,13 +368,31 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             _ => {\n                 let source = self.borrowed_content_source(deref_base);\n-                match (self.describe_place(move_place.as_ref()), source.describe_for_named_place())\n-                {\n-                    (Some(place_desc), Some(source_desc)) => self.cannot_move_out_of(\n+                let move_place_ref = move_place.as_ref();\n+                match (\n+                    self.describe_place_with_options(\n+                        move_place_ref,\n+                        DescribePlaceOpt {\n+                            including_downcast: false,\n+                            including_tuple_field: false,\n+                        },\n+                    ),\n+                    self.describe_name(move_place_ref),\n+                    source.describe_for_named_place(),\n+                ) {\n+                    (Some(place_desc), Some(name), Some(source_desc)) => self.cannot_move_out_of(\n+                        span,\n+                        &format!(\"`{place_desc}` as enum variant `{name}` which is behind a {source_desc}\"),\n+                    ),\n+                    (Some(place_desc), Some(name), None) => self.cannot_move_out_of(\n+                        span,\n+                        &format!(\"`{place_desc}` as enum variant `{name}`\"),\n+                    ),\n+                    (Some(place_desc), _, Some(source_desc)) => self.cannot_move_out_of(\n                         span,\n                         &format!(\"`{place_desc}` which is behind a {source_desc}\"),\n                     ),\n-                    (_, _) => self.cannot_move_out_of(\n+                    (_, _, _) => self.cannot_move_out_of(\n                         span,\n                         &source.describe_for_unnamed_place(self.infcx.tcx),\n                     ),"}, {"sha": "94ba62c160c989e897c2bc534c1948dcca0e5fe6", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -37,9 +37,6 @@ pub enum Immediate<Prov: Provenance = AllocId> {\n     Uninit,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Immediate, 56);\n-\n impl<Prov: Provenance> From<ScalarMaybeUninit<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n     fn from(val: ScalarMaybeUninit<Prov>) -> Self {\n@@ -117,9 +114,6 @@ pub struct ImmTy<'tcx, Prov: Provenance = AllocId> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n-\n impl<Prov: Provenance> std::fmt::Display for ImmTy<'_, Prov> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n@@ -187,9 +181,6 @@ pub enum Operand<Prov: Provenance = AllocId> {\n     Indirect(MemPlace<Prov>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Operand, 64);\n-\n #[derive(Clone, Debug)]\n pub struct OpTy<'tcx, Prov: Provenance = AllocId> {\n     op: Operand<Prov>, // Keep this private; it helps enforce invariants.\n@@ -204,9 +195,6 @@ pub struct OpTy<'tcx, Prov: Provenance = AllocId> {\n     pub align: Option<Align>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(OpTy<'_>, 88);\n-\n impl<'tcx, Prov: Provenance> std::ops::Deref for OpTy<'tcx, Prov> {\n     type Target = Operand<Prov>;\n     #[inline(always)]\n@@ -830,3 +818,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(Immediate, 56);\n+    rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n+    rustc_data_structures::static_assert_size!(Operand, 64);\n+    rustc_data_structures::static_assert_size!(OpTy<'_>, 88);\n+}"}, {"sha": "f4571a1ca3d8a0438fc0ee435fc4a55dcd8b0115", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -25,9 +25,6 @@ pub enum MemPlaceMeta<Prov: Provenance = AllocId> {\n     None,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n-\n impl<Prov: Provenance> MemPlaceMeta<Prov> {\n     pub fn unwrap_meta(self) -> Scalar<Prov> {\n         match self {\n@@ -56,9 +53,6 @@ pub struct MemPlace<Prov: Provenance = AllocId> {\n     pub meta: MemPlaceMeta<Prov>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MemPlace, 40);\n-\n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n pub struct MPlaceTy<'tcx, Prov: Provenance = AllocId> {\n@@ -71,9 +65,6 @@ pub struct MPlaceTy<'tcx, Prov: Provenance = AllocId> {\n     pub align: Align,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Place<Prov: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -84,9 +75,6 @@ pub enum Place<Prov: Provenance = AllocId> {\n     Local { frame: usize, local: mir::Local },\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Place, 48);\n-\n #[derive(Clone, Debug)]\n pub struct PlaceTy<'tcx, Prov: Provenance = AllocId> {\n     place: Place<Prov>, // Keep this private; it helps enforce invariants.\n@@ -98,9 +86,6 @@ pub struct PlaceTy<'tcx, Prov: Provenance = AllocId> {\n     pub align: Align,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n-\n impl<'tcx, Prov: Provenance> std::ops::Deref for PlaceTy<'tcx, Prov> {\n     type Target = Place<Prov>;\n     #[inline(always)]\n@@ -901,3 +886,15 @@ where\n         Ok(mplace)\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n+    rustc_data_structures::static_assert_size!(MemPlace, 40);\n+    rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n+    rustc_data_structures::static_assert_size!(Place, 48);\n+    rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n+}"}, {"sha": "c2c551e78a41105af9ee32fe96fbabbd750a3b7e", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -338,7 +338,12 @@ impl Definitions {\n \n     /// Adds a definition with a parent definition.\n     pub fn create_def(&mut self, parent: LocalDefId, data: DefPathData) -> LocalDefId {\n-        debug!(\"create_def(parent={:?}, data={:?})\", parent, data);\n+        // We can't use `Debug` implementation for `LocalDefId` here, since it tries to acquire a\n+        // reference to `Definitions` and we're already holding a mutable reference.\n+        debug!(\n+            \"create_def(parent={}, data={data:?})\",\n+            self.def_path(parent).to_string_no_crate_verbose(),\n+        );\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);"}, {"sha": "7230555e961c9e5a3a6a27fd1318522222546bc6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -3489,17 +3489,18 @@ impl<'hir> Node<'hir> {\n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n-    rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n-    rustc_data_structures::static_assert_size!(super::Expr<'static>, 56);\n-    rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n-    rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n-    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n-    rustc_data_structures::static_assert_size!(super::GenericBound<'_>, 48);\n-    rustc_data_structures::static_assert_size!(super::Generics<'static>, 56);\n-    rustc_data_structures::static_assert_size!(super::Impl<'static>, 80);\n-\n-    rustc_data_structures::static_assert_size!(super::Item<'static>, 80);\n-    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 88);\n-    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 80);\n-    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 72);\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(Block<'static>, 48);\n+    rustc_data_structures::static_assert_size!(Expr<'static>, 56);\n+    rustc_data_structures::static_assert_size!(ForeignItem<'static>, 72);\n+    rustc_data_structures::static_assert_size!(GenericBound<'_>, 48);\n+    rustc_data_structures::static_assert_size!(Generics<'static>, 56);\n+    rustc_data_structures::static_assert_size!(ImplItem<'static>, 80);\n+    rustc_data_structures::static_assert_size!(Impl<'static>, 80);\n+    rustc_data_structures::static_assert_size!(Item<'static>, 80);\n+    rustc_data_structures::static_assert_size!(Pat<'static>, 88);\n+    rustc_data_structures::static_assert_size!(QPath<'static>, 24);\n+    rustc_data_structures::static_assert_size!(TraitItem<'static>, 88);\n+    rustc_data_structures::static_assert_size!(Ty<'static>, 72);\n }"}, {"sha": "bd58021f78fc022381f5c015b474704e7369e98f", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1364,7 +1364,6 @@ impl UnreachablePub {\n         cx: &LateContext<'_>,\n         what: &str,\n         def_id: LocalDefId,\n-        span: Span,\n         vis_span: Span,\n         exportable: bool,\n     ) {\n@@ -1373,7 +1372,7 @@ impl UnreachablePub {\n             if vis_span.from_expansion() {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n-            let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n+            let def_span = cx.tcx.def_span(def_id);\n             cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n                 let mut err = lint.build(fluent::lint::builtin_unreachable_pub);\n                 err.set_arg(\"what\", what);\n@@ -1399,36 +1398,22 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n         if let hir::ItemKind::Use(_, hir::UseKind::ListStem) = &item.kind {\n             return;\n         }\n-        self.perform_lint(cx, \"item\", item.def_id, item.span, item.vis_span, true);\n+        self.perform_lint(cx, \"item\", item.def_id, item.vis_span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n-        self.perform_lint(\n-            cx,\n-            \"item\",\n-            foreign_item.def_id,\n-            foreign_item.span,\n-            foreign_item.vis_span,\n-            true,\n-        );\n+        self.perform_lint(cx, \"item\", foreign_item.def_id, foreign_item.vis_span, true);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n         let def_id = cx.tcx.hir().local_def_id(field.hir_id);\n-        self.perform_lint(cx, \"field\", def_id, field.span, field.vis_span, false);\n+        self.perform_lint(cx, \"field\", def_id, field.vis_span, false);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // Only lint inherent impl items.\n         if cx.tcx.associated_item(impl_item.def_id).trait_item_def_id.is_none() {\n-            self.perform_lint(\n-                cx,\n-                \"item\",\n-                impl_item.def_id,\n-                impl_item.span,\n-                impl_item.vis_span,\n-                false,\n-            );\n+            self.perform_lint(cx, \"item\", impl_item.def_id, impl_item.vis_span, false);\n         }\n     }\n }"}, {"sha": "eb90169d0e3141acbbab8408bf7482c8d1ac3a04", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -800,9 +800,6 @@ pub struct Place<'tcx> {\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Place<'_>, 16);\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n@@ -866,11 +863,6 @@ pub enum ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n-// This type is fairly frequently used, so we shouldn't unintentionally increase\n-// its size.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PlaceElem<'_>, 24);\n-\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n@@ -913,9 +905,6 @@ pub enum Operand<'tcx> {\n     Constant(Box<Constant<'tcx>>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Operand<'_>, 24);\n-\n ///////////////////////////////////////////////////////////////////////////\n // Rvalues\n \n@@ -1067,9 +1056,6 @@ pub enum Rvalue<'tcx> {\n     CopyForDeref(Place<'tcx>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Rvalue<'_>, 40);\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum CastKind {\n     /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n@@ -1105,9 +1091,6 @@ pub enum AggregateKind<'tcx> {\n     Generator(LocalDefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(AggregateKind<'_>, 48);\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum NullOp {\n     /// Returns the size of a value of that type\n@@ -1171,3 +1154,15 @@ pub enum BinOp {\n     /// The `ptr.offset` operator\n     Offset,\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    static_assert_size!(AggregateKind<'_>, 48);\n+    static_assert_size!(Operand<'_>, 24);\n+    static_assert_size!(Place<'_>, 16);\n+    static_assert_size!(PlaceElem<'_>, 24);\n+    static_assert_size!(Rvalue<'_>, 40);\n+}"}, {"sha": "b856af1d8f835e5cc9e3ecf10eb7fac395c9f950", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -190,10 +190,6 @@ pub enum StmtKind<'tcx> {\n     },\n }\n \n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n-\n #[derive(Clone, Debug, Copy, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct LocalVarId(pub hir::HirId);\n@@ -812,3 +808,14 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n         }\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(Block, 56);\n+    rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n+    rustc_data_structures::static_assert_size!(Pat<'_>, 24);\n+    rustc_data_structures::static_assert_size!(Stmt<'_>, 120);\n+}"}, {"sha": "541763e294f18bf87f5d57c8a121d09cf7a58baa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1459,11 +1459,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         format!(\n-            \"{}[{}]{}\",\n+            \"{}[{:04x}]{}\",\n             crate_name,\n             // Don't print the whole stable crate id. That's just\n             // annoying in debug output.\n-            &(format!(\"{:08x}\", stable_crate_id.to_u64()))[..4],\n+            stable_crate_id.to_u64() >> 8 * 6,\n             self.def_path(def_id).to_string_no_crate_verbose()\n         )\n     }"}, {"sha": "bc6241b38100db4c1bc9d61881da6b7d1b43a814", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n-use rustc_hir::intravisit::FnKind;\n+use rustc_hir::def::DefKind;\n use rustc_middle::mir::{BasicBlock, BasicBlocks, Body, Operand, TerminatorKind};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n@@ -12,12 +12,7 @@ use std::ops::ControlFlow;\n pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n \n-    if let Some(fn_kind) = tcx.hir().get_by_def_id(def_id).fn_kind() {\n-        if let FnKind::Closure = fn_kind {\n-            // closures can't recur, so they don't matter.\n-            return;\n-        }\n-\n+    if let DefKind::Fn | DefKind::AssocFn = tcx.def_kind(def_id) {\n         // If this is trait/impl method, extract the trait's substs.\n         let trait_substs = match tcx.opt_associated_item(def_id.to_def_id()) {\n             Some(AssocItem {\n@@ -41,8 +36,8 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n \n         vis.reachable_recursive_calls.sort();\n \n+        let sp = tcx.def_span(def_id);\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span_with_body(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");"}, {"sha": "43e4d252676f4ed0a8712200cc112aee28c11aa4", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1754,8 +1754,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                 || self.in_assoc_ty\n                 || self.tcx.resolutions(()).has_pub_restricted\n             {\n-                let vis_span =\n-                    self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n+                let vis_span = self.tcx.def_span(def_id);\n                 if kind == \"trait\" {\n                     self.tcx.sess.emit_err(InPublicInterfaceTraits {\n                         span,"}, {"sha": "6d2aff38172facc9f4a0157dae89a56460442abb", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,4 +1,3 @@\n-use crate::dep_graph::DepContext;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryStackFrame};\n use rustc_hir::def::DefKind;\n@@ -536,17 +535,13 @@ pub(crate) fn report_cycle<'a>(\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     assert!(!stack.is_empty());\n \n-    let fix_span = |span: Span, query: &QueryStackFrame| {\n-        sess.source_map().guess_head_span(query.default_span(span))\n-    };\n-\n-    let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n+    let span = stack[0].query.default_span(stack[1 % stack.len()].span);\n     let mut err =\n         struct_span_err!(sess, span, E0391, \"cycle detected when {}\", stack[0].query.description);\n \n     for i in 1..stack.len() {\n         let query = &stack[i].query;\n-        let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n+        let span = query.default_span(stack[(i + 1) % stack.len()].span);\n         err.span_note(span, &format!(\"...which requires {}...\", query.description));\n     }\n \n@@ -577,7 +572,7 @@ pub(crate) fn report_cycle<'a>(\n     }\n \n     if let Some((span, query)) = usage {\n-        err.span_note(fix_span(span, &query), &format!(\"cycle used when {}\", query.description));\n+        err.span_note(query.default_span(span), &format!(\"cycle used when {}\", query.description));\n     }\n \n     err\n@@ -606,8 +601,7 @@ pub fn print_query_stack<CTX: QueryContext>(\n             Level::FailureNote,\n             &format!(\"#{} [{}] {}\", i, query_info.query.name, query_info.query.description),\n         );\n-        diag.span =\n-            tcx.dep_context().sess().source_map().guess_head_span(query_info.job.span).into();\n+        diag.span = query_info.job.span.into();\n         handler.force_print_diagnostic(diag);\n \n         current_query = query_info.job.parent;"}, {"sha": "8839fb1a151206068639d4a975a956725e3c5b1c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1587,11 +1587,7 @@ impl<'a> Resolver<'a> {\n         };\n         let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n             LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(\n-                self.session\n-                    .source_map()\n-                    .guess_head_span(self.cstore().get_span_untracked(def_id, self.session)),\n-            ),\n+            _ => Some(self.cstore().get_span_untracked(def_id, self.session)),\n         });\n         if let Some(def_span) = def_span {\n             if span.overlaps(def_span) {"}, {"sha": "2b1f2b88ec445887717dd197483884c4fa663f88", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -136,12 +136,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n             LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(\n-                self.r\n-                    .session\n-                    .source_map()\n-                    .guess_head_span(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n-            ),\n+            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n         }\n     }\n "}, {"sha": "e6907637c57b628fbd6dca7622411f3b2b97b968", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -223,8 +223,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the slice's type's original\n                     // signature with no type arguments resolved\n-                    let type_string = self.tcx.type_of(def.did()).to_string();\n-                    flags.push((sym::_Self, Some(format!(\"[{type_string}]\"))));\n+                    flags.push((sym::_Self, Some(format!(\"[{}]\", self.tcx.type_of(def.did())))));\n                 }\n                 if aty.is_integral() {\n                     flags.push((sym::_Self, Some(\"[{integral}]\".to_string())));\n@@ -242,10 +241,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the array's type's original\n                     // signature with no type arguments resolved\n-                    let type_string = self.tcx.type_of(def.did()).to_string();\n-                    flags.push((sym::_Self, Some(format!(\"[{type_string}; _]\"))));\n+                    let def_ty = self.tcx.type_of(def.did());\n+                    flags.push((sym::_Self, Some(format!(\"[{def_ty}; _]\"))));\n                     if let Some(n) = len {\n-                        flags.push((sym::_Self, Some(format!(\"[{type_string}; {n}]\"))));\n+                        flags.push((sym::_Self, Some(format!(\"[{def_ty}; {n}]\"))));\n                     }\n                 }\n                 if aty.is_integral() {"}, {"sha": "c3abb515b037884826e53daa1aafdb366a22d91b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1946,7 +1946,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n-            let original_span = self.tcx.sess.source_map().guess_head_span(original_span);\n             let mut span = MultiSpan::from_span(original_span);\n \n             let message = outer_generator"}, {"sha": "4f15592e6fbac9192a389fc9b59c0810b51ddff1", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -293,6 +293,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn if_cause(\n         &self,\n         span: Span,\n+        cond_span: Span,\n         then_expr: &'tcx hir::Expr<'tcx>,\n         else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n@@ -355,10 +356,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // 6 | |     };\n             //   | |_____^ expected integer, found `()`\n             // ```\n-            if block.expr.is_none() && block.stmts.is_empty()\n-                && let Some(outer_span) = &mut outer_span\n-            {\n-                *outer_span = self.tcx.sess.source_map().guess_head_span(*outer_span);\n+            if block.expr.is_none() && block.stmts.is_empty() && outer_span.is_some() {\n+                let sp = if let Some(cs) = cond_span.find_ancestor_inside(span) {\n+                    span.with_hi(cs.hi())\n+                } else {\n+                    span\n+                };\n+                outer_span = Some(sp);\n             }\n \n             (self.find_block_span(block), block.hir_id)"}, {"sha": "6e97b0bf2ab7dfba1d5add7d134e1f58a446147d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1003,8 +1003,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let else_diverges = self.diverges.get();\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n-            let if_cause =\n-                self.if_cause(sp, then_expr, else_expr, then_ty, else_ty, opt_suggest_box_span);\n+            let if_cause = self.if_cause(\n+                sp,\n+                cond_expr.span,\n+                then_expr,\n+                else_expr,\n+                then_ty,\n+                else_ty,\n+                opt_suggest_box_span,\n+            );\n \n             coerce.coerce(self, &if_cause, else_expr, else_ty);\n "}, {"sha": "06fa5039fdf9243cc4b5b62d7cdcd8381311699d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -158,34 +158,38 @@ impl Step for ToolBuild {\n                       a transitive dependency has different features activated \\\n                       than in a previous build:\\n\"\n             );\n-            eprintln!(\n-                \"the following dependencies are duplicated although they \\\n-                      have the same features enabled:\"\n-            );\n             let (same, different): (Vec<_>, Vec<_>) =\n                 duplicates.into_iter().partition(|(_, cur, prev)| cur.2 == prev.2);\n-            for (id, cur, prev) in same {\n-                eprintln!(\"  {}\", id);\n-                // same features\n-                eprintln!(\"    `{}` ({:?})\\n    `{}` ({:?})\", cur.0, cur.1, prev.0, prev.1);\n-            }\n-            eprintln!(\"the following dependencies have different features:\");\n-            for (id, cur, prev) in different {\n-                eprintln!(\"  {}\", id);\n-                let cur_features: HashSet<_> = cur.2.into_iter().collect();\n-                let prev_features: HashSet<_> = prev.2.into_iter().collect();\n-                eprintln!(\n-                    \"    `{}` additionally enabled features {:?} at {:?}\",\n-                    cur.0,\n-                    &cur_features - &prev_features,\n-                    cur.1\n-                );\n+            if !same.is_empty() {\n                 eprintln!(\n-                    \"    `{}` additionally enabled features {:?} at {:?}\",\n-                    prev.0,\n-                    &prev_features - &cur_features,\n-                    prev.1\n+                    \"the following dependencies are duplicated although they \\\n+                      have the same features enabled:\"\n                 );\n+                for (id, cur, prev) in same {\n+                    eprintln!(\"  {}\", id);\n+                    // same features\n+                    eprintln!(\"    `{}` ({:?})\\n    `{}` ({:?})\", cur.0, cur.1, prev.0, prev.1);\n+                }\n+            }\n+            if !different.is_empty() {\n+                eprintln!(\"the following dependencies have different features:\");\n+                for (id, cur, prev) in different {\n+                    eprintln!(\"  {}\", id);\n+                    let cur_features: HashSet<_> = cur.2.into_iter().collect();\n+                    let prev_features: HashSet<_> = prev.2.into_iter().collect();\n+                    eprintln!(\n+                        \"    `{}` additionally enabled features {:?} at {:?}\",\n+                        cur.0,\n+                        &cur_features - &prev_features,\n+                        cur.1\n+                    );\n+                    eprintln!(\n+                        \"    `{}` additionally enabled features {:?} at {:?}\",\n+                        prev.0,\n+                        &prev_features - &cur_features,\n+                        prev.1\n+                    );\n+                }\n             }\n             eprintln!();\n             eprintln!("}, {"sha": "1a46d077f1b0562f1847aa4e4e081e51feec6ee3", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -122,10 +122,6 @@ pub(crate) struct Crate {\n     pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n }\n \n-// `Crate` is frequently moved by-value. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Crate, 72);\n-\n impl Crate {\n     pub(crate) fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         ExternalCrate::LOCAL.name(tcx)\n@@ -389,10 +385,6 @@ impl fmt::Debug for Item {\n     }\n }\n \n-// `Item` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Item, 56);\n-\n pub(crate) fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     Span::new(def_id.as_local().map_or_else(\n         || tcx.def_span(def_id),\n@@ -771,10 +763,6 @@ pub(crate) enum ItemKind {\n     KeywordItem,\n }\n \n-// `ItemKind` is an enum and large variants can bloat up memory usage even for smaller ones\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ItemKind, 112);\n-\n impl ItemKind {\n     /// Some items contain others such as structs (for their fields) and Enums\n     /// (for their variants). This method returns those contained items.\n@@ -994,10 +982,6 @@ pub(crate) struct DocFragment {\n     pub(crate) indent: usize,\n }\n \n-// `DocFragment` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(DocFragment, 32);\n-\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub(crate) enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n@@ -1382,10 +1366,6 @@ pub(crate) struct GenericParamDef {\n     pub(crate) kind: GenericParamDefKind,\n }\n \n-// `GenericParamDef` is used in many places. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericParamDef, 56);\n-\n impl GenericParamDef {\n     pub(crate) fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n@@ -1590,10 +1570,6 @@ pub(crate) enum Type {\n     ImplTrait(Vec<GenericBound>),\n }\n \n-// `Type` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Type, 72);\n-\n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n     pub(crate) fn without_borrowed_ref(&self) -> &Type {\n@@ -2230,33 +2206,18 @@ pub(crate) enum GenericArg {\n     Infer,\n }\n \n-// `GenericArg` can occur many times in a single `Path`, so make sure it\n-// doesn't increase in size unexpectedly.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericArg, 80);\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) enum GenericArgs {\n     AngleBracketed { args: Box<[GenericArg]>, bindings: ThinVec<TypeBinding> },\n     Parenthesized { inputs: Box<[Type]>, output: Option<Box<Type>> },\n }\n \n-// `GenericArgs` is in every `PathSegment`, so its size can significantly\n-// affect rustdoc's memory usage.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericArgs, 32);\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) struct PathSegment {\n     pub(crate) name: Symbol,\n     pub(crate) args: GenericArgs,\n }\n \n-// `PathSegment` usually occurs multiple times in every `Path`, so its size can\n-// significantly affect rustdoc's memory usage.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PathSegment, 40);\n-\n #[derive(Clone, Debug)]\n pub(crate) struct Typedef {\n     pub(crate) type_: Type,\n@@ -2527,3 +2488,19 @@ impl SubstParam {\n         if let Self::Lifetime(lt) = self { Some(lt) } else { None }\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    // These are in alphabetical order, which is easy to maintain.\n+    rustc_data_structures::static_assert_size!(Crate, 72); // frequently moved by-value\n+    rustc_data_structures::static_assert_size!(DocFragment, 32);\n+    rustc_data_structures::static_assert_size!(GenericArg, 80);\n+    rustc_data_structures::static_assert_size!(GenericArgs, 32);\n+    rustc_data_structures::static_assert_size!(GenericParamDef, 56);\n+    rustc_data_structures::static_assert_size!(Item, 56);\n+    rustc_data_structures::static_assert_size!(ItemKind, 112);\n+    rustc_data_structures::static_assert_size!(PathSegment, 40);\n+    rustc_data_structures::static_assert_size!(Type, 72);\n+}"}, {"sha": "0d96840250332b5cb77c05c56334e2be8bdaa56a", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -304,6 +304,12 @@ pub(crate) fn run(\n         let mut finder = FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx, target_crates };\n         tcx.hir().visit_all_item_likes_in_crate(&mut finder);\n \n+        // The visitor might have found a type error, which we need to\n+        // promote to a fatal error\n+        if tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n+            return Err(String::from(\"Compilation failed, aborting rustdoc\"));\n+        }\n+\n         // Sort call locations within a given file in document order\n         for fn_calls in calls.values_mut() {\n             for file_calls in fn_calls.values_mut() {"}, {"sha": "8f4fde96d7e4bb6cd937cbf9eb7b698f1bcb6bad", "filename": "src/test/rustdoc-ui/scrape-examples-fail-if-type-error.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -0,0 +1,7 @@\n+// check-fail\n+// compile-flags: -Z unstable-options --scrape-examples-output-path {{build-base}}/t.calls --scrape-examples-target-crate foobar\n+\n+pub fn foo() {\n+  INVALID_FUNC();\n+  //~^ ERROR could not resolve path\n+}"}, {"sha": "750aa32071944948222a402011636ebdcac07679", "filename": "src/test/rustdoc-ui/scrape-examples-fail-if-type-error.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-fail-if-type-error.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -0,0 +1,14 @@\n+error[E0433]: failed to resolve: could not resolve path `INVALID_FUNC`\n+  --> $DIR/scrape-examples-fail-if-type-error.rs:5:3\n+   |\n+LL |   INVALID_FUNC();\n+   |   ^^^^^^^^^^^^ could not resolve path `INVALID_FUNC`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: Compilation failed, aborting rustdoc\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "e6f6e9e9f653fcfe659c2795822845a16b2d2aa2", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -35,7 +35,7 @@ note: cycle used when checking item types in top-level module\n   --> $DIR/no-const-async.rs:4:1\n    |\n LL | pub const async fn x() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "13a6277da14c0898b95ab55ef527e3b4fe8fa72e", "filename": "src/test/ui/borrowck/access-mode-in-closures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,4 +1,4 @@\n-error[E0507]: cannot move out of `s.0` which is behind a shared reference\n+error[E0507]: cannot move out of `s` which is behind a shared reference\n   --> $DIR/access-mode-in-closures.rs:8:15\n    |\n LL |         match *s { S(v) => v }"}, {"sha": "96246d9ae1a8909ce949a36ce288f00f3821828b", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,4 +1,4 @@\n-error[E0507]: cannot move out of `f.0` which is behind a shared reference\n+error[E0507]: cannot move out of `f` as enum variant `Foo1` which is behind a shared reference\n   --> $DIR/borrowck-move-error-with-note.rs:11:11\n    |\n LL |     match *f {"}, {"sha": "57f94f8c6ab52d04dbcad0223d5a98a1b40865d9", "filename": "src/test/ui/consts/issue-44415.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -2,18 +2,18 @@ error[E0391]: cycle detected when evaluating type-level constant\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                 ^^^^^^\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                 ^^^^^^\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                 ^^^^^^\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`..."}, {"sha": "d4976a0f9c9cd1c61bd52b2bc62d4728179b66bb", "filename": "src/test/ui/cycle-trait/cycle-trait-default-type-trait.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -8,8 +8,13 @@ LL | trait Foo<X = Box<dyn Foo>> {\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-default-type-trait.rs:4:1\n    |\n-LL | trait Foo<X = Box<dyn Foo>> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Foo<X = Box<dyn Foo>> {\n+LL | |\n+LL | |\n+LL | | }\n+LL | |\n+LL | | fn main() { }\n+   | |_____________^\n \n error[E0391]: cycle detected when computing type of `Foo::X`\n   --> $DIR/cycle-trait-default-type-trait.rs:4:23\n@@ -21,8 +26,13 @@ LL | trait Foo<X = Box<dyn Foo>> {\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-default-type-trait.rs:4:1\n    |\n-LL | trait Foo<X = Box<dyn Foo>> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Foo<X = Box<dyn Foo>> {\n+LL | |\n+LL | |\n+LL | | }\n+LL | |\n+LL | | fn main() { }\n+   | |_____________^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f6ffcc4b5aadcf8a5458ffe2b94fa13411ecab8f", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -13,8 +13,10 @@ LL | trait Chromosome: Chromosome {\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n    |\n-LL | trait Chromosome: Chromosome {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Chromosome: Chromosome {\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "1461e7fd2ddd7fbddddb647509cda2b91bfcfe72", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -4,12 +4,10 @@ warning: function cannot return without recursing\n LL | / fn no_hrtb<'b, T>(mut t: T)\n LL | | where\n LL | |     T: Bar<&'b isize>,\n-LL | | {\n-...  |\n-LL | |     no_hrtb(&mut t);\n-   | |     --------------- recursive call site\n-LL | | }\n-   | |_^ cannot return without recursing\n+   | |______________________^ cannot return without recursing\n+...\n+LL |       no_hrtb(&mut t);\n+   |       --------------- recursive call site\n    |\n    = note: `#[warn(unconditional_recursion)]` on by default\n    = help: a `loop` may express intention better if this is on purpose\n@@ -20,12 +18,10 @@ warning: function cannot return without recursing\n LL | / fn bar_hrtb<T>(mut t: T)\n LL | | where\n LL | |     T: for<'b> Bar<&'b isize>,\n-LL | | {\n-...  |\n-LL | |     bar_hrtb(&mut t);\n-   | |     ---------------- recursive call site\n-LL | | }\n-   | |_^ cannot return without recursing\n+   | |______________________________^ cannot return without recursing\n+...\n+LL |       bar_hrtb(&mut t);\n+   |       ---------------- recursive call site\n    |\n    = help: a `loop` may express intention better if this is on purpose\n \n@@ -35,14 +31,10 @@ warning: function cannot return without recursing\n LL | / fn foo_hrtb_bar_not<'b, T>(mut t: T)\n LL | | where\n LL | |     T: for<'a> Foo<&'a isize> + Bar<&'b isize>,\n-LL | | {\n-...  |\n-LL | |     foo_hrtb_bar_not(&mut t);\n-   | |     ------------------------ recursive call site\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^ cannot return without recursing\n+   | |_______________________________________________^ cannot return without recursing\n+...\n+LL |       foo_hrtb_bar_not(&mut t);\n+   |       ------------------------ recursive call site\n    |\n    = help: a `loop` may express intention better if this is on purpose\n \n@@ -70,12 +62,10 @@ warning: function cannot return without recursing\n LL | / fn foo_hrtb_bar_hrtb<T>(mut t: T)\n LL | | where\n LL | |     T: for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>,\n-LL | | {\n-LL | |     // OK -- now we have `T : for<'b> Bar<&'b isize>`.\n-LL | |     foo_hrtb_bar_hrtb(&mut t);\n-   | |     ------------------------- recursive call site\n-LL | | }\n-   | |_^ cannot return without recursing\n+   | |_______________________________________________________^ cannot return without recursing\n+...\n+LL |       foo_hrtb_bar_hrtb(&mut t);\n+   |       ------------------------- recursive call site\n    |\n    = help: a `loop` may express intention better if this is on purpose\n "}, {"sha": "789a1141c04f9e9502ff5664d0516ab64aeb69a3", "filename": "src/test/ui/issues/issue-12511.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -23,8 +23,10 @@ LL | trait T2 : T1 {\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-12511.rs:1:1\n    |\n-LL | trait T1 : T2 {\n-   | ^^^^^^^^^^^^^\n+LL | / trait T1 : T2 {\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "e021f500c66ae4f308ae2d661f1fc40bb2661145", "filename": "src/test/ui/lint/unreachable_pub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,8 +1,8 @@\n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:8:5\n+  --> $DIR/unreachable_pub.rs:8:13\n    |\n LL |     pub use std::fmt;\n-   |     ---^^^^^^^^^^^^^^\n+   |     ---     ^^^^^^^^\n    |     |\n    |     help: consider restricting its visibility: `pub(crate)`\n    |\n@@ -93,7 +93,7 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:33:5\n    |\n LL |     pub const CARBON: usize = 1;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ---^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     help: consider restricting its visibility: `pub(crate)`\n    |\n@@ -103,7 +103,7 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:34:5\n    |\n LL |     pub static NITROGEN: usize = 2;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ---^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     help: consider restricting its visibility: `pub(crate)`\n    |\n@@ -113,7 +113,7 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:35:5\n    |\n LL |     pub type Oxygen = bool;\n-   |     ---^^^^^^^^^^^^^^^^^^^^\n+   |     ---^^^^^^^^^^^^\n    |     |\n    |     help: consider restricting its visibility: `pub(crate)`\n    |\n@@ -123,7 +123,7 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:38:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n    |     ---------------------------------------------------\n@@ -138,7 +138,7 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:44:9\n    |\n LL |         pub fn catalyze() -> bool;\n-   |         ---^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ---^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         help: consider restricting its visibility: `pub(crate)`\n    |"}, {"sha": "f404cd3cd71253f5f2bba9c0c1f1056636a8c100", "filename": "src/test/ui/moves/issue-99470-move-out-of-some.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let x: &Option<Box<i32>> = &Some(Box::new(0));\n+\n+    match x {\n+    //~^ ERROR cannot move out of `x` as enum variant `Some` which is behind a shared reference\n+        &Some(_y) => (),\n+        &None => (),\n+    }\n+}"}, {"sha": "6e4a4e5ba22c100872731b44911e34d57d260fd1", "filename": "src/test/ui/moves/issue-99470-move-out-of-some.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -0,0 +1,16 @@\n+error[E0507]: cannot move out of `x` as enum variant `Some` which is behind a shared reference\n+  --> $DIR/issue-99470-move-out-of-some.rs:4:11\n+   |\n+LL |     match x {\n+   |           ^\n+LL |\n+LL |         &Some(_y) => (),\n+   |         ---------\n+   |         |     |\n+   |         |     data moved here\n+   |         |     move occurs because `_y` has type `Box<i32>`, which does not implement the `Copy` trait\n+   |         help: consider removing the `&`: `Some(_y)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "5ed91a0d5596340888162fbf5dcef12579104f49", "filename": "src/test/ui/moves/moves-based-on-type-block-bad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,4 +1,4 @@\n-error[E0507]: cannot move out of `hellothere.x.0` which is behind a shared reference\n+error[E0507]: cannot move out of `hellothere.x` as enum variant `Bar` which is behind a shared reference\n   --> $DIR/moves-based-on-type-block-bad.rs:22:19\n    |\n LL |             match hellothere.x {"}, {"sha": "b03fcf70babe25850fcc3d068e15a4e282b63dda", "filename": "src/test/ui/nll/move-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -45,7 +45,7 @@ LL |     let a = [A(\"\".to_string())][0];\n    |             move occurs because value has type `A`, which does not implement the `Copy` trait\n    |             help: consider borrowing here: `&[A(\"\".to_string())][0]`\n \n-error[E0507]: cannot move out of `a.0` which is behind a shared reference\n+error[E0507]: cannot move out of `a` which is behind a shared reference\n   --> $DIR/move-errors.rs:38:16\n    |\n LL |     let A(s) = *a;\n@@ -134,7 +134,7 @@ LL |         F(s, mut t) => (),\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n \n-error[E0507]: cannot move out of `x.0` which is behind a shared reference\n+error[E0507]: cannot move out of `x` as enum variant `Err` which is behind a shared reference\n   --> $DIR/move-errors.rs:110:11\n    |\n LL |     match *x {"}, {"sha": "20aeb7b995a6195b46c2b27429e55a0c8531c1e1", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -8,8 +8,14 @@ LL | impl dyn ToNbt<Self> {}\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-23305.rs:1:1\n    |\n-LL | pub trait ToNbt<T> {\n-   | ^^^^^^^^^^^^^^^^^^\n+LL | / pub trait ToNbt<T> {\n+LL | |     fn new(val: T) -> Self;\n+LL | | }\n+LL | |\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n \n error: aborting due to previous error\n "}, {"sha": "e5443290f9e7a603f60dec3ac74f75d5a3233c47", "filename": "src/test/ui/suggestions/dont-suggest-ref/simple.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -1,4 +1,4 @@\n-error[E0507]: cannot move out of `s.0` which is behind a shared reference\n+error[E0507]: cannot move out of `s` which is behind a shared reference\n   --> $DIR/simple.rs:38:17\n    |\n LL |     let X(_t) = *s;\n@@ -7,7 +7,7 @@ LL |     let X(_t) = *s;\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:42:30\n    |\n LL |     if let Either::One(_t) = *r { }\n@@ -16,7 +16,7 @@ LL |     if let Either::One(_t) = *r { }\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:46:33\n    |\n LL |     while let Either::One(_t) = *r { }\n@@ -25,7 +25,7 @@ LL |     while let Either::One(_t) = *r { }\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `Two` which is behind a shared reference\n   --> $DIR/simple.rs:50:11\n    |\n LL |     match *r {\n@@ -37,7 +37,7 @@ LL |         Either::One(_t)\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:57:11\n    |\n LL |     match *r {\n@@ -49,7 +49,7 @@ LL |         Either::One(_t) => (),\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `sm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `sm` which is behind a mutable reference\n   --> $DIR/simple.rs:66:17\n    |\n LL |     let X(_t) = *sm;\n@@ -58,7 +58,7 @@ LL |     let X(_t) = *sm;\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:70:30\n    |\n LL |     if let Either::One(_t) = *rm { }\n@@ -67,7 +67,7 @@ LL |     if let Either::One(_t) = *rm { }\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:74:33\n    |\n LL |     while let Either::One(_t) = *rm { }\n@@ -76,7 +76,7 @@ LL |     while let Either::One(_t) = *rm { }\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `Two` which is behind a mutable reference\n   --> $DIR/simple.rs:78:11\n    |\n LL |     match *rm {\n@@ -88,7 +88,7 @@ LL |         Either::One(_t)\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:85:11\n    |\n LL |     match *rm {\n@@ -100,7 +100,7 @@ LL |         Either::One(_t) => (),\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:93:11\n    |\n LL |     match *rm {\n@@ -226,7 +226,7 @@ LL |         Either::One(_t) => (),\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of `s.0` which is behind a shared reference\n+error[E0507]: cannot move out of `s` which is behind a shared reference\n   --> $DIR/simple.rs:168:18\n    |\n LL |     let &X(_t) = s;\n@@ -236,7 +236,7 @@ LL |     let &X(_t) = s;\n    |         |  move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n    |         help: consider removing the `&`: `X(_t)`\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:172:31\n    |\n LL |     if let &Either::One(_t) = r { }\n@@ -246,7 +246,7 @@ LL |     if let &Either::One(_t) = r { }\n    |            |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |            help: consider removing the `&`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:176:34\n    |\n LL |     while let &Either::One(_t) = r { }\n@@ -256,7 +256,7 @@ LL |     while let &Either::One(_t) = r { }\n    |               |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |               help: consider removing the `&`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `Two` which is behind a shared reference\n   --> $DIR/simple.rs:180:11\n    |\n LL |     match r {\n@@ -276,7 +276,7 @@ LL +\n LL ~         | &Either::Two(_t) => (),\n    |\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:188:11\n    |\n LL |     match r {\n@@ -289,7 +289,7 @@ LL |         &Either::One(_t) => (),\n    |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |         help: consider removing the `&`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `r.0` which is behind a shared reference\n+error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n   --> $DIR/simple.rs:195:11\n    |\n LL |     match r {\n@@ -302,7 +302,7 @@ LL |         &Either::One(_t) => (),\n    |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |         help: consider removing the `&`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `sm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `sm` which is behind a mutable reference\n   --> $DIR/simple.rs:207:22\n    |\n LL |     let &mut X(_t) = sm;\n@@ -312,7 +312,7 @@ LL |     let &mut X(_t) = sm;\n    |         |      move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n    |         help: consider removing the `&mut`: `X(_t)`\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:211:35\n    |\n LL |     if let &mut Either::One(_t) = rm { }\n@@ -322,7 +322,7 @@ LL |     if let &mut Either::One(_t) = rm { }\n    |            |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |            help: consider removing the `&mut`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:215:38\n    |\n LL |     while let &mut Either::One(_t) = rm { }\n@@ -332,7 +332,7 @@ LL |     while let &mut Either::One(_t) = rm { }\n    |               |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |               help: consider removing the `&mut`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `Two` which is behind a mutable reference\n   --> $DIR/simple.rs:219:11\n    |\n LL |     match rm {\n@@ -354,7 +354,7 @@ help: consider removing the `&mut`\n LL |         Either::Two(_t) => (),\n    |         ~~~~~~~~~~~~~~~\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:228:11\n    |\n LL |     match rm {\n@@ -367,7 +367,7 @@ LL |         &mut Either::One(_t) => (),\n    |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |         help: consider removing the `&mut`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:235:11\n    |\n LL |     match rm {\n@@ -380,7 +380,7 @@ LL |         &mut Either::One(_t) => (),\n    |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |         help: consider removing the `&mut`: `Either::One(_t)`\n \n-error[E0507]: cannot move out of `rm.0` which is behind a mutable reference\n+error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n   --> $DIR/simple.rs:242:11\n    |\n LL |     match rm {"}, {"sha": "f5d6d72afc2ca1092fc42c632e812c34944a195d", "filename": "src/test/ui/traits/issue-91949-hangs-on-recursion.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -4,11 +4,10 @@ warning: function cannot return without recursing\n LL | / fn recurse<T>(elements: T) -> Vec<char>\n LL | | where\n LL | |     T: Iterator<Item = ()>,\n-LL | | {\n-LL | |     recurse(IteratorOfWrapped(elements).map(|t| t.0))\n-   | |     ------------------------------------------------- recursive call site\n-LL | | }\n-   | |_^ cannot return without recursing\n+   | |___________________________^ cannot return without recursing\n+LL |   {\n+LL |       recurse(IteratorOfWrapped(elements).map(|t| t.0))\n+   |       ------------------------------------------------- recursive call site\n    |\n    = note: `#[warn(unconditional_recursion)]` on by default\n    = help: a `loop` may express intention better if this is on purpose"}, {"sha": "15faab16abeaf11376c539af85819312e1c38235", "filename": "src/test/ui/traits/trait-upcasting/cyclic-trait-resolution.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -14,7 +14,7 @@ note: cycle used when collecting item types in top-level module\n   --> $DIR/cyclic-trait-resolution.rs:1:1\n    |\n LL | trait A: B + A {}\n-   | ^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "4775e68820b523daac491f4ae3c7a4fdb9693f91", "filename": "src/test/ui/type-alias-enum-variants/self-in-enum-definition.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -2,18 +2,18 @@ error[E0391]: cycle detected when simplifying constant for the type system `Alph\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |\n LL |     V3 = Self::V1 {} as u8 + 2,\n-   |          ^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires simplifying constant for the type system `Alpha::V3::{constant#0}`...\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |\n LL |     V3 = Self::V1 {} as u8 + 2,\n-   |          ^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `Alpha::V3::{constant#0}`...\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |\n LL |     V3 = Self::V1 {} as u8 + 2,\n-   |          ^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Alpha`...\n    = note: ...which again requires simplifying constant for the type system `Alpha::V3::{constant#0}`, completing the cycle\n note: cycle used when collecting item types in top-level module"}, {"sha": "9187c3551d7de3f1427891fd2342739c942596dc", "filename": "src/tools/x/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2Fsrc%2Fmain.rs?ref=c9e134e1b609e571f4d7d18f91f0ccb1a0cb685d", "patch": "@@ -41,9 +41,9 @@ fn python() -> &'static str {\n     } else if python2 {\n         PYTHON2\n     } else {\n-        // We would have returned early if we found that python is installed ...\n-        // maybe this should panic with an error instead?\n-        PYTHON\n+        // Python was not found on path, so exit\n+        eprintln!(\"Unable to find python in your PATH. Please check it is installed.\");\n+        process::exit(1);\n     }\n }\n "}]}