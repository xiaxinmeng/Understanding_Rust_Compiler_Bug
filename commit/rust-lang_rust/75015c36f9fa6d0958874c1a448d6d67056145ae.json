{"sha": "75015c36f9fa6d0958874c1a448d6d67056145ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDE1YzM2ZjlmYTZkMDk1ODg3NGMxYTQ0OGQ2ZDY3MDU2MTQ1YWU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T03:42:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T05:26:04Z"}, "message": "deque: Change iterators to use the same index calculation as Deque\n\nThe previous implementation of reverse iterators used modulus (%) of\nnegative indices, which did work but was fragile due to dependency on\nthe divisor.", "tree": {"sha": "6a1f20a7e3d57d526fb453687828226290bcf4e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a1f20a7e3d57d526fb453687828226290bcf4e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75015c36f9fa6d0958874c1a448d6d67056145ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75015c36f9fa6d0958874c1a448d6d67056145ae", "html_url": "https://github.com/rust-lang/rust/commit/75015c36f9fa6d0958874c1a448d6d67056145ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75015c36f9fa6d0958874c1a448d6d67056145ae/comments", "author": null, "committer": null, "parents": [{"sha": "f88d532734dbddecf81bc1d0ce51d30cb9fc9731", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88d532734dbddecf81bc1d0ce51d30cb9fc9731", "html_url": "https://github.com/rust-lang/rust/commit/f88d532734dbddecf81bc1d0ce51d30cb9fc9731"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "e8f8a31d7be0b3e5ce3a2f9f09041a28d9ebf5ff", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/75015c36f9fa6d0958874c1a448d6d67056145ae/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75015c36f9fa6d0958874c1a448d6d67056145ae/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=75015c36f9fa6d0958874c1a448d6d67056145ae", "patch": "@@ -12,7 +12,6 @@\n \n use std::uint;\n use std::vec;\n-use std::cast::transmute;\n use std::iterator::FromIterator;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n@@ -92,13 +91,9 @@ impl<T> Deque<T> {\n         result\n     }\n \n-    /// Return index in underlying vec for element index\n+    /// Return index in underlying vec for a given logical element index\n     fn raw_index(&self, idx: uint) -> uint {\n-        if self.lo >= self.elts.len() - idx {\n-            (self.lo + idx) - self.elts.len()\n-        } else {\n-            (self.lo + idx)\n-        }\n+        raw_index(self.lo, self.elts.len(), idx)\n     }\n \n     /// Remove and return the last element in the deque\n@@ -159,83 +154,79 @@ impl<T> Deque<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n-    DequeIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n-    DequeMutIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Back-to-front iterator.\n     pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-    DequeRevIterator { idx: self.raw_index(self.nelts-1), nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                         lo: self.lo}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n     pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-    DequeMutRevIterator { idx: self.raw_index(self.nelts-1), nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                            lo: self.lo}\n     }\n }\n \n macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $step:expr) => {\n+    (impl $name:ident -> $elem:ty, $getter:ident, $step:expr) => {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n-                if self.used >= self.nelts {\n+                if self.nelts == 0 {\n                     return None;\n                 }\n-                let ret = unsafe {\n-                    match self.vec[self.idx % self.vec.len()] {\n-                        Some(ref e) => Some(transmute(e)),\n-                        None => None\n-                    }\n-                };\n-                self.idx += $step;\n-                self.used += 1;\n-                ret\n+                let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n+                self.index += $step;\n+                self.nelts -= 1;\n+                Some(self.elts[raw_index]. $getter ())\n             }\n         }\n     }\n }\n \n /// Deque iterator\n pub struct DequeIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeIterator -> &'self T, 1}\n+iterator!{impl DequeIterator -> &'self T, get_ref, 1}\n \n /// Deque reverse iterator\n pub struct DequeRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeRevIterator -> &'self T, -1}\n+iterator!{impl DequeRevIterator -> &'self T, get_ref, -1}\n \n /// Deque mutable iterator\n pub struct DequeMutIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n-\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutIterator -> &'self mut T, 1}\n+iterator!{impl DequeMutIterator -> &'self mut T, get_mut_ref, 1}\n \n /// Deque mutable reverse iterator\n pub struct DequeMutRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutRevIterator -> &'self mut T, -1}\n+iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n@@ -258,6 +249,15 @@ fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n     match elts[i] { Some(ref t) => t, _ => fail!() }\n }\n \n+/// Return index in underlying vec for a given logical element index\n+fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n+    if lo >= len - index {\n+        lo + index - len\n+    } else {\n+        lo + index\n+    }\n+}\n+\n impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n     fn from_iterator(iterator: &mut T) -> Deque<A> {\n         let mut deq = Deque::new();"}]}