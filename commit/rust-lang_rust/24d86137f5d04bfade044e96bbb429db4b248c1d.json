{"sha": "24d86137f5d04bfade044e96bbb429db4b248c1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZDg2MTM3ZjVkMDRiZmFkZTA0NGU5NmJiYjQyOWRiNGIyNDhjMWQ=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2016-04-19T13:43:10Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2016-05-03T09:51:19Z"}, "message": "Warn unused trait imports", "tree": {"sha": "3e61936eb5dfa3e07d3409d670507799a01805de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e61936eb5dfa3e07d3409d670507799a01805de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24d86137f5d04bfade044e96bbb429db4b248c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24d86137f5d04bfade044e96bbb429db4b248c1d", "html_url": "https://github.com/rust-lang/rust/commit/24d86137f5d04bfade044e96bbb429db4b248c1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24d86137f5d04bfade044e96bbb429db4b248c1d/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ad1900e1cdb2bd9dbf9560c8c50c5912578723c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ad1900e1cdb2bd9dbf9560c8c50c5912578723c", "html_url": "https://github.com/rust-lang/rust/commit/7ad1900e1cdb2bd9dbf9560c8c50c5912578723c"}], "stats": {"total": 194, "additions": 169, "deletions": 25}, "files": [{"sha": "8732df1437153d1ac241292d2581e00052826c84", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -59,6 +59,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckItemBody(D),\n     Dropck,\n     DropckImpl(D),\n+    UnusedTraitCheck,\n     CheckConst(D),\n     Privacy,\n     IntrinsicCheck(D),\n@@ -163,6 +164,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             CheckEntryFn => Some(CheckEntryFn),\n             Variance => Some(Variance),\n             Dropck => Some(Dropck),\n+            UnusedTraitCheck => Some(UnusedTraitCheck),\n             Privacy => Some(Privacy),\n             Reachability => Some(Reachability),\n             DeadCheck => Some(DeadCheck),"}, {"sha": "68e3e742d0316f31aa237133017a6b0cdc3228ec", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -1639,8 +1639,13 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n+pub struct TraitCandidate {\n+    pub def_id: DefId,\n+    pub import_id: Option<NodeId>,\n+}\n+\n // Trait method resolution\n-pub type TraitMap = NodeMap<Vec<DefId>>;\n+pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported."}, {"sha": "c7ae038eb7add3624f29ced6a24cb2718e217b02", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -289,6 +289,8 @@ pub struct TyCtxt<'tcx> {\n     // scratch every time.\n     pub freevars: RefCell<FreevarMap>,\n \n+    pub maybe_unused_trait_imports: NodeSet,\n+\n     // Records the type of every item.\n     pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n \n@@ -338,6 +340,10 @@ pub struct TyCtxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports.\n+    pub used_trait_imports: RefCell<NodeSet>,\n+\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n@@ -543,6 +549,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  named_region_map: resolve_lifetime::NamedRegionMap,\n                                  map: ast_map::Map<'tcx>,\n                                  freevars: FreevarMap,\n+                                 maybe_unused_trait_imports: NodeSet,\n                                  region_maps: RegionMaps,\n                                  lang_items: middle::lang_items::LanguageItems,\n                                  stability: stability::Index<'tcx>,\n@@ -581,6 +588,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n             freevars: RefCell::new(freevars),\n+            maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n@@ -595,6 +603,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n+            used_trait_imports: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             extern_const_statics: RefCell::new(DefIdMap()),"}, {"sha": "53b914936f5c9340cd4ea2838c49b01696130ea6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -795,6 +795,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let resolve::CrateMap {\n         def_map,\n         freevars,\n+        maybe_unused_trait_imports,\n         export_map,\n         trait_map,\n         glob_map,\n@@ -844,6 +845,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              named_region_map,\n                              hir_map,\n                              freevars,\n+                             maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "53c0e1f799273fd1098e036f70acd522060b026d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -132,7 +132,7 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let resolve::CrateMap { def_map, freevars, .. } =\n+    let resolve::CrateMap { def_map, freevars, maybe_unused_trait_imports, .. } =\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &def_map.borrow());\n     let region_map = region::resolve_crate(&sess, &ast_map);\n@@ -143,6 +143,7 @@ fn test_env<F>(source_string: &str,\n                                named_region_map.unwrap(),\n                                ast_map,\n                                freevars,\n+                               maybe_unused_trait_imports,\n                                region_map,\n                                lang_items,\n                                index,"}, {"sha": "e213a51fb3842f8267bbae6f589f779bbdc5cdbb", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -16,6 +16,8 @@\n // resolve data structures and because it finalises the privacy information for\n // `use` directives.\n //\n+// Unused trait imports can't be checked until the method resolution. We save\n+// candidates here, and do the acutal check in librustc_typeck/check_unused.rs.\n \n use std::ops::{Deref, DerefMut};\n \n@@ -55,10 +57,18 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn check_import(&mut self, id: ast::NodeId, span: Span) {\n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n+            if self.maybe_unused_trait_imports.contains(&id) {\n+                // Check later.\n+                return;\n+            }\n             self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n                                   id,\n                                   span,\n                                   \"unused import\".to_string());\n+        } else {\n+            // This trait import is definitely used, in a way other than\n+            // method resolution.\n+            self.maybe_unused_trait_imports.remove(&id);\n         }\n     }\n }"}, {"sha": "2e2b40fec4b983a7c5b88fcef8ea493a99169e6a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -52,8 +52,8 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::pat_bindings;\n use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n-use rustc::hir::{Freevar, FreevarMap, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n@@ -1042,6 +1042,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n+    maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n \n@@ -1137,13 +1138,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             module_map: module_map,\n-            used_imports: HashSet::new(),\n-            used_crates: HashSet::new(),\n \n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n+            used_imports: HashSet::new(),\n+            used_crates: HashSet::new(),\n+            maybe_unused_trait_imports: NodeSet(),\n+\n             privacy_errors: Vec::new(),\n \n             arenas: arenas,\n@@ -1177,7 +1180,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     #[inline]\n-    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+    fn record_use(&mut self, name: Name, binding: &'a NameBinding<'a>) {\n         // track extern crates for unused_extern_crate lint\n         if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n             self.used_crates.insert(krate);\n@@ -1189,7 +1192,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => return,\n         };\n \n-        self.used_imports.insert((directive.id, ns));\n         if let Some(error) = privacy_error.as_ref() {\n             self.privacy_errors.push((**error).clone());\n         }\n@@ -1492,7 +1494,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             false => module.resolve_name(name, namespace, false),\n         }.and_then(|binding| {\n             if record_used {\n-                self.record_use(name, namespace, binding);\n+                if let NameBindingKind::Import { directive, .. } = binding.kind {\n+                    self.used_imports.insert((directive.id, namespace));\n+                }\n+                self.record_use(name, binding);\n             }\n             Success(binding)\n         })\n@@ -3094,21 +3099,27 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n+    fn get_traits_containing_item(&mut self, name: Name) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", name);\n \n-        fn add_trait_info(found_traits: &mut Vec<DefId>, trait_def_id: DefId, name: Name) {\n+        fn add_trait_info(found_traits: &mut Vec<TraitCandidate>,\n+                          trait_def_id: DefId,\n+                          import_id: Option<NodeId>,\n+                          name: Name) {\n             debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n                    trait_def_id,\n                    name);\n-            found_traits.push(trait_def_id);\n+            found_traits.push(TraitCandidate {\n+                def_id: trait_def_id,\n+                import_id: import_id,\n+            });\n         }\n \n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((trait_def_id, _)) = self.current_trait_ref {\n             if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                add_trait_info(&mut found_traits, trait_def_id, name);\n+                add_trait_info(&mut found_traits, trait_def_id, None, name);\n             }\n         }\n \n@@ -3131,8 +3142,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n                     let trait_def_id = binding.def().unwrap().def_id();\n                     if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        add_trait_info(&mut found_traits, trait_def_id, name);\n-                        self.record_use(trait_name, TypeNS, binding);\n+                        let mut import_id = None;\n+                        if let NameBindingKind::Import { directive, .. } = binding.kind {\n+                            let id = directive.id;\n+                            self.maybe_unused_trait_imports.insert(id);\n+                            import_id = Some(id);\n+                        }\n+                        add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n+                        self.record_use(trait_name, binding);\n                     }\n                 }\n             };\n@@ -3506,6 +3523,7 @@ fn err_path_resolution() -> PathResolution {\n pub struct CrateMap {\n     pub def_map: RefCell<DefMap>,\n     pub freevars: FreevarMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n     pub glob_map: Option<GlobMap>,\n@@ -3543,6 +3561,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,\n+        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n         export_map: resolver.export_map,\n         trait_map: resolver.trait_map,\n         glob_map: if resolver.make_glob_map {"}, {"sha": "26d1f50f8c549b16d8d6cf87dc70942a683510e3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -128,6 +128,11 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n     let pick = probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id)?;\n+\n+    if let Some(import_id) = pick.import_id {\n+        fcx.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+    }\n+\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n@@ -339,8 +344,12 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = probe::probe(fcx, span, mode, method_name, self_ty, expr_id)?;\n-    let def = pick.item.def();\n \n+    if let Some(import_id) = pick.import_id {\n+        fcx.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+    }\n+\n+    let def = pick.item.def();\n     if let probe::InherentImplPick = pick.kind {\n         if !pick.item.vis().is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());"}, {"sha": "4716bab71bfb1aa3917cb9859a9e7fcb91a93e3c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -42,6 +42,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<DefId>,\n+    import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n     /// used for error reporting\n@@ -67,6 +68,7 @@ struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n     item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n+    import_id: Option<ast::NodeId>,\n }\n \n #[derive(Debug)]\n@@ -84,6 +86,7 @@ enum CandidateKind<'tcx> {\n pub struct Pick<'tcx> {\n     pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n+    pub import_id: Option<ast::NodeId>,\n \n     // Indicates that the source expression should be autoderef'd N times\n     //\n@@ -247,6 +250,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: HashSet::new(),\n+            import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n@@ -435,7 +439,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             item: item,\n-            kind: InherentImplCandidate(impl_substs, obligations)\n+            kind: InherentImplCandidate(impl_substs, obligations),\n+            import_id: self.import_id,\n         });\n     }\n \n@@ -463,7 +468,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: ObjectCandidate\n+                kind: ObjectCandidate,\n+                import_id: this.import_id,\n             });\n         });\n     }\n@@ -533,7 +539,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: WhereClauseCandidate(poly_trait_ref)\n+                kind: WhereClauseCandidate(poly_trait_ref),\n+                import_id: this.import_id,\n             });\n         });\n     }\n@@ -577,9 +584,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n-            for &trait_did in applicable_traits {\n+            for trait_candidate in applicable_traits {\n+                let trait_did = trait_candidate.def_id;\n                 if duplicates.insert(trait_did) {\n-                    self.assemble_extension_candidates_for_trait(trait_did)?;\n+                    self.import_id = trait_candidate.import_id;\n+                    let result = self.assemble_extension_candidates_for_trait(trait_did);\n+                    self.import_id = None;\n+                    result?;\n                 }\n             }\n         }\n@@ -679,7 +690,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations)\n+                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations),\n+                import_id: self.import_id,\n             });\n         });\n     }\n@@ -754,7 +766,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: TraitCandidate\n+                kind: TraitCandidate,\n+                import_id: self.import_id,\n             });\n         }\n \n@@ -811,7 +824,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n                         item: item.clone(),\n-                        kind: TraitCandidate\n+                        kind: TraitCandidate,\n+                        import_id: self.import_id,\n                     });\n                 }\n             }\n@@ -842,7 +856,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: WhereClauseCandidate(poly_bound)\n+                kind: WhereClauseCandidate(poly_bound),\n+                import_id: self.import_id,\n             });\n         }\n     }\n@@ -1140,6 +1155,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         Some(Pick {\n             item: probes[0].item.clone(),\n             kind: TraitPick,\n+            import_id: probes[0].import_id,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1345,6 +1361,7 @@ impl<'tcx> Candidate<'tcx> {\n                     WhereClausePick(trait_ref.clone())\n                 }\n             },\n+            import_id: self.import_id,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None"}, {"sha": "3c594ebdf0bfcfcc6e6579b9ad462cbb0101dc69", "filename": "src/librustc_typeck/check_unused.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lint;\n+use rustc::dep_graph::DepNode;\n+use rustc::ty::TyCtxt;\n+\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n+\n+use rustc::hir;\n+use rustc::hir::intravisit::Visitor;\n+\n+struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a TyCtxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n+    fn check_import(&self, id: ast::NodeId, span: Span) {\n+        if !self.tcx.maybe_unused_trait_imports.contains(&id) {\n+            return;\n+        }\n+        if self.tcx.used_trait_imports.borrow().contains(&id) {\n+            return;\n+        }\n+        self.tcx.sess.add_lint(lint::builtin::UNUSED_IMPORTS,\n+                               id,\n+                               span,\n+                               \"unused import\".to_string());\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if item.vis == hir::Public || item.span == DUMMY_SP {\n+            return;\n+        }\n+        if let hir::ItemUse(ref path) = item.node {\n+            match path.node {\n+                hir::ViewPathSimple(..) | hir::ViewPathGlob(..) => {\n+                    self.check_import(item.id, path.span);\n+                }\n+                hir::ViewPathList(_, ref path_list) => {\n+                    for path_item in path_list {\n+                        self.check_import(path_item.node.id(), path_item.span);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn check_crate(tcx: &TyCtxt) {\n+    let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n+    let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n+    tcx.map.krate().visit_all_items(&mut visitor);\n+}"}, {"sha": "ed393b54f0e2752e016cd55e7a7f32bf6269b3b0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -122,6 +122,7 @@ use std::cell::RefCell;\n pub mod diagnostics;\n \n pub mod check;\n+pub mod check_unused;\n mod rscope;\n mod astconv;\n pub mod collect;\n@@ -363,6 +364,7 @@ pub fn check_crate(tcx: &TyCtxt, trait_map: hir::TraitMap) -> CompileResult {\n \n     time(time_passes, \"drop-impl checking\", || check::check_drop_impls(&ccx))?;\n \n+    check_unused::check_crate(tcx);\n     check_for_entry_fn(&ccx);\n \n     let err_count = tcx.sess.err_count();"}, {"sha": "5e4f43af669ca540678b83f9c27388bdd78ace3d", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits-same-method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -15,6 +15,7 @@\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n+#![allow(unused_imports)]\n \n fn main() { }\n "}, {"sha": "40322f5a5b53b79f69c36a28fdde3e3c80ee7c6d", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d86137f5d04bfade044e96bbb429db4b248c1d/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=24d86137f5d04bfade044e96bbb429db4b248c1d", "patch": "@@ -24,6 +24,8 @@ use test::A;       //~ ERROR unused import\n // Be sure that if we just bring some methods into scope that they're also\n // counted as being used.\n use test::B;\n+// But only when actually used: do not get confused by the method with the same name.\n+use test::B2; //~ ERROR unused import\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n@@ -37,6 +39,7 @@ mod test2 {\n mod test {\n     pub trait A { fn a(&self) {} }\n     pub trait B { fn b(&self) {} }\n+    pub trait B2 { fn b(&self) {} }\n     pub struct C;\n     impl A for C {}\n     impl B for C {}"}]}