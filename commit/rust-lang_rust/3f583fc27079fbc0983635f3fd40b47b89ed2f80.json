{"sha": "3f583fc27079fbc0983635f3fd40b47b89ed2f80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNTgzZmMyNzA3OWZiYzA5ODM2MzVmM2ZkNDBiNDdiODllZDJmODA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T17:03:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-18T17:03:35Z"}, "message": "Rollup merge of #69189 - matthewjasper:erase-the-world, r=nikomatsakis\n\nErase regions in writeback\n\nRegions in `TypeckTables` (except canonicalized user annotations) are now erased. Further, we no longer do lexical region solving on item bodies with `-Zborrowck=mir`.\n\ncc #68261\nr? @nikomatsakis", "tree": {"sha": "4fd0e81ac0ae7afc0114fe89673033a192b0b479", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fd0e81ac0ae7afc0114fe89673033a192b0b479"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f583fc27079fbc0983635f3fd40b47b89ed2f80", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeclRnCRBK7hj4Ov3rIwAAdHIIAG0pT537NhdYC4/YT8RhDDt/\n37aGNwmKmUcsCLzKIXphEiMPVmLDU7ZZq/FWh/bNLhP4u/pjfuDlpELVwCn+qcW2\nCqAhJJlkh23acoQCWc1ZlzZZDVkPQItpzBo1vP7d2CGVyjt1dAVBXRkKahb1m+kc\nr+7gKtfw9x0aMfg/ipedd94UC3//J5kbh1cCIRH+kU+TEl2z7TA3Tx/Uhp5UhU1g\nkKWklCGrxTSQByFcfdauowoIoMvq6mtva9MZNHne2BtO/iXo+0iQfHA2C5dKbxbW\n569IxozKy6PpU40fqUJyXqWwye34fCkgff7qFLNXHW8SFgP9p9udpwsK7zLpyjI=\n=M7xX\n-----END PGP SIGNATURE-----\n", "payload": "tree 4fd0e81ac0ae7afc0114fe89673033a192b0b479\nparent 8188b2163dfe3de7b8e3b52ee86c9c2eac78ffa1\nparent 1ee5829575e73f217674f0a4e271c2e4246546e1\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584551015 +0100\ncommitter GitHub <noreply@github.com> 1584551015 +0100\n\nRollup merge of #69189 - matthewjasper:erase-the-world, r=nikomatsakis\n\nErase regions in writeback\n\nRegions in `TypeckTables` (except canonicalized user annotations) are now erased. Further, we no longer do lexical region solving on item bodies with `-Zborrowck=mir`.\n\ncc #68261\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f583fc27079fbc0983635f3fd40b47b89ed2f80", "html_url": "https://github.com/rust-lang/rust/commit/3f583fc27079fbc0983635f3fd40b47b89ed2f80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f583fc27079fbc0983635f3fd40b47b89ed2f80/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8188b2163dfe3de7b8e3b52ee86c9c2eac78ffa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8188b2163dfe3de7b8e3b52ee86c9c2eac78ffa1", "html_url": "https://github.com/rust-lang/rust/commit/8188b2163dfe3de7b8e3b52ee86c9c2eac78ffa1"}, {"sha": "1ee5829575e73f217674f0a4e271c2e4246546e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee5829575e73f217674f0a4e271c2e4246546e1", "html_url": "https://github.com/rust-lang/rust/commit/1ee5829575e73f217674f0a4e271c2e4246546e1"}], "stats": {"total": 501, "additions": 264, "deletions": 237}, "files": [{"sha": "d7a259cc870749b762281ff9c7adb0f0f069a8ff", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -23,7 +23,6 @@ use crate::mir::{\n };\n use crate::traits;\n use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n-use crate::ty::free_region_map::FreeRegionMap;\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n use crate::ty::steal::Steal;\n@@ -416,11 +415,6 @@ pub struct TypeckTables<'tcx> {\n     /// this field will be set to `true`.\n     pub tainted_by_errors: bool,\n \n-    /// Stores the free-region relationships that were deduced from\n-    /// its where-clauses and parameter types. These are then\n-    /// read-again by borrowck.\n-    pub free_region_map: FreeRegionMap<'tcx>,\n-\n     /// All the opaque types that are restricted to concrete types\n     /// by this function.\n     pub concrete_opaque_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n@@ -456,7 +450,6 @@ impl<'tcx> TypeckTables<'tcx> {\n             coercion_casts: Default::default(),\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: false,\n-            free_region_map: Default::default(),\n             concrete_opaque_types: Default::default(),\n             upvar_list: Default::default(),\n             generator_interior_types: Default::default(),\n@@ -719,7 +712,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n \n             ref used_trait_imports,\n             tainted_by_errors,\n-            ref free_region_map,\n             ref concrete_opaque_types,\n             ref upvar_list,\n             ref generator_interior_types,\n@@ -757,7 +749,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             coercion_casts.hash_stable(hcx, hasher);\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n-            free_region_map.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             upvar_list.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);"}, {"sha": "ebbfcb28db2f533244821293bf8f538c69f581c6", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -49,7 +49,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::infer::{self, SuppressRegionErrors};\n+use crate::infer;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -372,17 +372,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         region_scope_tree: &region::ScopeTree,\n         errors: &Vec<RegionResolutionError<'tcx>>,\n-        suppress: SuppressRegionErrors,\n     ) {\n-        debug!(\n-            \"report_region_errors(): {} errors to start, suppress = {:?}\",\n-            errors.len(),\n-            suppress\n-        );\n-\n-        if suppress.suppressed() {\n-            return;\n-        }\n+        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:"}, {"sha": "50b324c72278e1fa83d9a67671962e900221a6e6", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -3,6 +3,8 @@\n \n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::SubregionOrigin;\n use rustc::util::common::ErrorReported;\n \n use rustc_errors::struct_span_err;\n@@ -47,6 +49,15 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n         let (span, sub, sup) = self.regions()?;\n \n+        if let Some(RegionResolutionError::ConcreteFailure(\n+            SubregionOrigin::ReferenceOutlivesReferent(..),\n+            ..,\n+        )) = self.error\n+        {\n+            // This error doesn't make much sense in this case.\n+            return None;\n+        }\n+\n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = self.tcx().is_suitable_region(sup)?;\n "}, {"sha": "2357ee689d59e700a5d2c034b6f1d4a828bcbca3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -17,39 +17,28 @@ mod util;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        if let Some(tables) = self.in_progress_tables {\n-            let tables = tables.borrow();\n-            NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n-        } else {\n-            NiceRegionError::new(self, error.clone(), None).try_report().is_some()\n-        }\n+        NiceRegionError::new(self, error.clone()).try_report().is_some()\n     }\n }\n \n pub struct NiceRegionError<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n-    tables: Option<&'cx ty::TypeckTables<'tcx>>,\n }\n \n impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n-    pub fn new(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n-        error: RegionResolutionError<'tcx>,\n-        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n-    ) -> Self {\n-        Self { infcx, error: Some(error), regions: None, tables }\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n+        Self { infcx, error: Some(error), regions: None }\n     }\n \n     pub fn new_from_span(\n         infcx: &'cx InferCtxt<'cx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n-        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n     ) -> Self {\n-        Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n+        Self { infcx, error: None, regions: Some((span, sub, sup)) }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "de72c276595f769dc5b887a087e17615498b39d3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -51,52 +51,44 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        if let Some(hir_id) = hir.as_local_hir_id(id) {\n-            if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n-                let body = hir.body(body_id);\n-                let owner_id = hir.body_owner(body_id);\n-                let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n-                if let Some(tables) = self.tables {\n-                    body.params\n-                        .iter()\n-                        .enumerate()\n-                        .filter_map(|(index, param)| {\n-                            // May return None; sometimes the tables are not yet populated.\n-                            let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let param_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(param.hir_id)?;\n-                            let mut found_anon_region = false;\n-                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n-                                if *r == *anon_region {\n-                                    found_anon_region = true;\n-                                    replace_region\n-                                } else {\n-                                    r\n-                                }\n-                            });\n-                            if found_anon_region {\n-                                let is_first = index == 0;\n-                                Some(AnonymousParamInfo {\n-                                    param,\n-                                    param_ty: new_param_ty,\n-                                    param_ty_span,\n-                                    bound_region,\n-                                    is_first,\n-                                })\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .next()\n+        let hir_id = hir.as_local_hir_id(id)?;\n+        let body_id = hir.maybe_body_owned_by(hir_id)?;\n+        let body = hir.body(body_id);\n+        let owner_id = hir.body_owner(body_id);\n+        let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n+        let poly_fn_sig = self.tcx().fn_sig(id);\n+        let fn_sig = self.tcx().liberate_late_bound_regions(id, &poly_fn_sig);\n+        body.params\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, param)| {\n+                // May return None; sometimes the tables are not yet populated.\n+                let ty = fn_sig.inputs()[index];\n+                let mut found_anon_region = false;\n+                let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                    if *r == *anon_region {\n+                        found_anon_region = true;\n+                        replace_region\n+                    } else {\n+                        r\n+                    }\n+                });\n+                if found_anon_region {\n+                    let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                    let param_ty_span = hir.span(ty_hir_id);\n+                    let is_first = index == 0;\n+                    Some(AnonymousParamInfo {\n+                        param,\n+                        param_ty: new_param_ty,\n+                        param_ty_span,\n+                        bound_region,\n+                        is_first,\n+                    })\n                 } else {\n                     None\n                 }\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n+            })\n+            .next()\n     }\n \n     // Here, we check for the case where the anonymous region"}, {"sha": "3af10e850d534fe2c3112c58339f7075672fdfbb", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -7,6 +7,7 @@ use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n+use crate::infer::RegionckMode;\n use crate::infer::SubregionOrigin;\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::fold::TypeFoldable;\n@@ -33,12 +34,29 @@ pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n+    mode: RegionckMode,\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver { region_rels, var_infos, data };\n-    let values = resolver.infer_variable_values(&mut errors);\n-    (values, errors)\n+    match mode {\n+        RegionckMode::Solve => {\n+            let values = resolver.infer_variable_values(&mut errors);\n+            (values, errors)\n+        }\n+        RegionckMode::Erase { suppress_errors: false } => {\n+            // Do real inference to get errors, then erase the results.\n+            let mut values = resolver.infer_variable_values(&mut errors);\n+            let re_erased = region_rels.tcx.lifetimes.re_erased;\n+\n+            values.values.iter_mut().for_each(|v| *v = VarValue::Value(re_erased));\n+            (values, errors)\n+        }\n+        RegionckMode::Erase { suppress_errors: true } => {\n+            // Skip region inference entirely.\n+            (resolver.erased_data(region_rels.tcx), Vec::new())\n+        }\n+    }\n }\n \n /// Contains the result of lexical region resolution. Offers methods\n@@ -163,6 +181,19 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// An erased version of the lexical region resolutions. Used when we're\n+    /// erasing regions and suppressing errors: in item bodies with\n+    /// `-Zborrowck=mir`.\n+    fn erased_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n+        LexicalRegionResolutions {\n+            error_region: tcx.lifetimes.re_static,\n+            values: IndexVec::from_elem_n(\n+                VarValue::Value(tcx.lifetimes.re_erased),\n+                self.num_vars(),\n+            ),\n+        }\n+    }\n+\n     fn dump_constraints(&self, free_regions: &RegionRelations<'_, 'tcx>) {\n         debug!(\"----() Start constraint listing (context={:?}) ()----\", free_regions.context);\n         for (idx, (constraint, _)) in self.data.constraints.iter().enumerate() {"}, {"sha": "c5f06d53b8f73d4ad2952d94b2fade858b00ce9a", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -79,31 +79,50 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n-/// A flag that is used to suppress region errors. This is normally\n-/// false, but sometimes -- when we are doing region checks that the\n-/// NLL borrow checker will also do -- it might be set to true.\n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct SuppressRegionErrors {\n-    suppressed: bool,\n+/// How we should handle region solving.\n+///\n+/// This is used so that the region values inferred by HIR region solving are\n+/// not exposed, and so that we can avoid doing work in HIR typeck that MIR\n+/// typeck will also do.\n+#[derive(Copy, Clone, Debug)]\n+pub enum RegionckMode {\n+    /// The default mode: report region errors, don't erase regions.\n+    Solve,\n+    /// Erase the results of region after solving.\n+    Erase {\n+        /// A flag that is used to suppress region errors, when we are doing\n+        /// region checks that the NLL borrow checker will also do -- it might\n+        /// be set to true.\n+        suppress_errors: bool,\n+    },\n+}\n+\n+impl Default for RegionckMode {\n+    fn default() -> Self {\n+        RegionckMode::Solve\n+    }\n }\n \n-impl SuppressRegionErrors {\n+impl RegionckMode {\n     pub fn suppressed(self) -> bool {\n-        self.suppressed\n+        match self {\n+            Self::Solve => false,\n+            Self::Erase { suppress_errors } => suppress_errors,\n+        }\n     }\n \n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n+    pub fn for_item_body(tcx: TyCtxt<'_>) -> Self {\n         // FIXME(Centril): Once we actually remove `::Migrate` also make\n         // this always `true` and then proceed to eliminate the dead code.\n         match tcx.borrowck_mode() {\n             // If we're on Migrate mode, report AST region errors\n-            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n+            BorrowckMode::Migrate => RegionckMode::Erase { suppress_errors: false },\n \n             // If we're on MIR, don't report AST region errors as they should be reported by NLL\n-            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n+            BorrowckMode::Mir => RegionckMode::Erase { suppress_errors: true },\n         }\n     }\n }\n@@ -1207,29 +1226,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         region_context: DefId,\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-        suppress: SuppressRegionErrors,\n+        mode: RegionckMode,\n     ) {\n         assert!(\n             self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n             self.inner.borrow().region_obligations\n         );\n-\n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n         let (var_infos, data) = self\n             .inner\n             .borrow_mut()\n             .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+\n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n+            lexical_region_resolve::resolve(region_rels, var_infos, data, mode);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1240,7 +1260,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, suppress);\n+            self.report_region_errors(region_map, &errors);\n         }\n     }\n "}, {"sha": "494b6421fd5d49bcf9e9eae433e76813650b0b58", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -284,8 +284,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_region_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = self.infcx.tcx.typeck_tables_of(self.mir_def_id);\n-            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f, Some(tables));\n+            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 diag.buffer(&mut self.errors_buffer);\n                 return;"}, {"sha": "43a90c4a6c1649dd5e38ed771ce24441374b55bc", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -21,7 +21,7 @@ mod util;\n pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use crate::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use crate::traits::error_reporting::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc::middle::region;\n@@ -244,7 +244,7 @@ fn do_normalize_predicates<'tcx>(\n             region_context,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n \n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "e48ebbbb23514b153438220d9c04b8d3b185784d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Predicate, Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferOk, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n@@ -139,7 +139,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n             drop_impl_did,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n         Ok(())\n     })"}, {"sha": "b6d6d3a7a873f52fdf4b0ed6c00866d26aedba94", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -85,7 +85,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, RegionObligation, SuppressRegionErrors};\n+use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n use rustc_span::Span;\n use rustc_trait_selection::infer::OutlivesEnvironmentExt;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n@@ -124,10 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n         }\n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n-\n-        assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n+        rcx.resolve_regions_and_report_errors(RegionckMode::for_item_body(self.tcx));\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n@@ -145,7 +142,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::default());\n+        rcx.resolve_regions_and_report_errors(RegionckMode::default());\n     }\n \n     /// Region check a function body. Not invoked on closures, but\n@@ -168,13 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }\n \n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n-\n-        // In this mode, we also copy the free-region-map into the\n-        // tables of the enclosing fcx. In the other regionck modes\n-        // (e.g., `regionck_item`), we don't have an enclosing tables.\n-        assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n+        rcx.resolve_regions_and_report_errors(RegionckMode::for_item_body(self.tcx));\n     }\n }\n \n@@ -355,7 +346,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.select_all_obligations_or_error();\n     }\n \n-    fn resolve_regions_and_report_errors(&self, suppress: SuppressRegionErrors) {\n+    fn resolve_regions_and_report_errors(&self, mode: RegionckMode) {\n         self.infcx.process_registered_region_obligations(\n             self.outlives_environment.region_bound_pairs_map(),\n             self.implicit_region_bound,\n@@ -366,7 +357,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             self.subject_def_id,\n             &self.region_scope_tree,\n             &self.outlives_environment,\n-            suppress,\n+            mode,\n         );\n     }\n "}, {"sha": "8ed6cc3a94329821f1826804c767020773570abb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -62,7 +62,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_fru_field_types();\n         wbcx.visit_opaque_types(body.value.span);\n         wbcx.visit_coercion_casts();\n-        wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n         wbcx.visit_generator_interior_types();\n@@ -125,7 +124,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders());\n+        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n         self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n@@ -327,9 +326,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n-                    let r = upvar_borrow.region;\n-                    let r = self.resolve(&r, &upvar_id.var_path.hir_id);\n-                    ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: upvar_borrow.kind,\n+                        region: self.tcx().lifetimes.re_erased,\n+                    })\n                 }\n             };\n             debug!(\"Upvar capture for {:?} resolved to {:?}\", upvar_id, new_upvar_capture);\n@@ -358,11 +358,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_free_region_map(&mut self) {\n-        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n-        debug_assert!(!self.tables.free_region_map.elements().any(|r| r.has_local_value()));\n-    }\n-\n     fn visit_user_provided_tys(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n@@ -427,8 +422,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n-            let instantiated_ty =\n-                self.tcx().erase_regions(&self.resolve(&opaque_defn.concrete_ty, &hir_id));\n+            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n@@ -617,10 +611,8 @@ impl Locatable for hir::HirId {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// The Resolver. This is the type folding engine that detects\n-// unresolved types and so forth.\n-\n+/// The Resolver. This is the type folding engine that detects\n+/// unresolved types and so forth.\n struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -653,7 +645,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.infcx.fully_resolve(&t) {\n-            Ok(t) => t,\n+            Ok(t) => self.infcx.tcx.erase_regions(&t),\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_error(t);\n@@ -662,15 +654,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         }\n     }\n \n-    // FIXME This should be carefully checked\n-    // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        self.infcx.fully_resolve(&r).unwrap_or(self.tcx.lifetimes.re_static)\n+        debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n+        self.tcx.lifetimes.re_erased\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match self.infcx.fully_resolve(&ct) {\n-            Ok(ct) => ct,\n+            Ok(ct) => self.infcx.tcx.erase_regions(&ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 // FIXME: we'd like to use `self.report_error`, but it doesn't yet"}, {"sha": "e24d9bebf657fd730cee09280c26499a0b679507", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{RegionckMode, TyCtxtInferExt};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -307,7 +307,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n                             impl_did,\n                             &region_scope_tree,\n                             &outlives_env,\n-                            SuppressRegionErrors::default(),\n+                            RegionckMode::default(),\n                         );\n                     }\n                 }\n@@ -568,7 +568,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n             impl_did,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n \n         CoerceUnsizedInfo { custom_kind: kind }"}, {"sha": "cae88376118466d9bd0fb5b5efbac9097b76db30", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -75,7 +75,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n use rustc_span::Span;\n use rustc_trait_selection::traits::{self, translate_substs, wf};\n@@ -162,7 +162,7 @@ fn get_impl_substs<'tcx>(\n         impl1_def_id,\n         &ScopeTree::default(),\n         &outlives_env,\n-        SuppressRegionErrors::default(),\n+        RegionckMode::default(),\n     );\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,"}, {"sha": "8edece2c8d361402f4d878f981b64e0e3992ac4b", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -84,8 +84,8 @@ pub fn add_type_ascription_to_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_items, mir_built, typeck_tables_of\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner_items, typeck_tables_of\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;\n     let _: u32 = closure(1);"}, {"sha": "139c265164bc57d71760e6efd349b4d019c91cca", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -360,7 +360,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_items,generics_of,predicates_of,type_of,typeck_tables_of\"\n+        except=\"hir_owner,hir_owner_items,generics_of,predicates_of,type_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }"}, {"sha": "89aa0b1a58baa9eaa315010aeec03b04ead7555b", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -81,7 +81,7 @@ pub fn var_deref(x: &i32, y: &i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"hir_owner_items,optimized_mir,mir_built,typeck_tables_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner_items,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn var_deref(x: &i32, y: &i32) -> i32 {\n     *y"}, {"sha": "c858a4c5ee7c6cecce7253ae2b0de020c96606b7", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -4,9 +4,9 @@ extern \"C\" {\n \n static Y: i32 = 42;\n \n-static mut BAR: *const &'static i32 = [&Y].as_ptr();\n+static mut BAR: *const &i32 = [&Y].as_ptr();\n \n-static mut FOO: *const &'static i32 = [unsafe { &X }].as_ptr();\n+static mut FOO: *const &i32 = [unsafe { &X }].as_ptr();\n \n fn main() {}\n \n@@ -18,8 +18,8 @@ fn main() {}\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;\n-//     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n+//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n+//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }\n // ...\n // bb2: {\n@@ -35,8 +35,8 @@ fn main() {}\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;\n-//     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n+//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n+//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }\n // ...\n // bb2: {\n@@ -50,8 +50,8 @@ fn main() {}\n // ...\n //     _6 = const BAR::promoted[0];\n //     _2 = &(*_6);\n-//     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n+//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n+//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }\n // ...\n // bb2: {\n@@ -63,8 +63,8 @@ fn main() {}\n // ...\n //     _6 = const FOO::promoted[0];\n //     _2 = &(*_6);\n-//     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n+//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n+//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }\n // ...\n // bb2: {"}, {"sha": "74a606af28fc1cb222c25c1a7c888d790ec13aca", "filename": "src/test/mir-opt/no-drop-for-inactive-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -27,7 +27,7 @@ fn main() {\n //     }\n //     bb2: {\n //         ...\n-//         const std::rt::begin_panic::<&'static str>(const \"explicit panic\") -> bb5;\n+//         const std::rt::begin_panic::<&str>(const \"explicit panic\") -> bb5;\n //     }\n //     bb3: {\n //         unreachable;"}, {"sha": "ea106eaf595292d0d5b28baa180bbe207cfd777e", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -26,16 +26,16 @@ fn main() {\n //     goto -> bb7;\n // }\n // bb2: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb1];\n+//     switchInt((*(*((_1 as Some).0: &&i32)))) -> [0i32: bb3, otherwise: bb1];\n // }\n // bb3: {\n //     goto -> bb4;\n // }\n // bb4: {\n //     _4 = &shallow _1;\n-//     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n-//     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n-//     _7 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n+//     _5 = &shallow ((_1 as Some).0: &&i32);\n+//     _6 = &shallow (*((_1 as Some).0: &&i32));\n+//     _7 = &shallow (*(*((_1 as Some).0: &&i32)));\n //     StorageLive(_8);\n //     _8 = _2;\n //     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n@@ -72,7 +72,7 @@ fn main() {\n //     goto -> bb7;\n // }\n // bb2: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb1];\n+//     switchInt((*(*((_1 as Some).0: &&i32)))) -> [0i32: bb3, otherwise: bb1];\n // }\n // bb3: {\n //     goto -> bb4;"}, {"sha": "1c98766b9685c254a4d6f71fe1359c3430e3d574", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -35,12 +35,12 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.XXX.mir_map.0.mir\n-//    let mut _0: &'static Foo;\n-//    let _1: &'static Foo;\n+//    let mut _0: &Foo;\n+//    let _1: &Foo;\n //    let _2: Foo;\n-//    let mut _3: &'static [(u32, u32)];\n-//    let mut _4: &'static [(u32, u32); 42];\n-//    let _5: &'static [(u32, u32); 42];\n+//    let mut _3: &[(u32, u32)];\n+//    let mut _4: &[(u32, u32); 42];\n+//    let _5: &[(u32, u32); 42];\n //    let _6: [(u32, u32); 42];\n //    let mut _7: (u32, u32);\n //    let mut _8: (u32, u32);\n@@ -178,7 +178,7 @@ fn main() {\n //        _6 = [move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16, move _17, move _18, move _19, move _20, move _21, move _22, move _23, move _24, move _25, move _26, move _27, move _28, move _29, move _30, move _31, move _32, move _33, move _34, move _35, move _36, move _37, move _38, move _39, move _40, move _41, move _42, move _43, move _44, move _45, move _46, move _47, move _48];\n //        _5 = &_6;\n //        _4 = &(*_5);\n-//        _3 = move _4 as &'static [(u32, u32)] (Pointer(Unsize));\n+//        _3 = move _4 as &[(u32, u32)] (Pointer(Unsize));\n //        _2 = Foo { tup: const \"hi\", data: move _3 };\n //        _1 = &_2;\n //        _0 = &(*_1);"}, {"sha": "ee7586bae820af702cea233269c9cf9e9cdc65de", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -34,29 +34,29 @@\n                            ((::alloc::fmt::format as\n                                 for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((::core::fmt::Arguments::new_v1\n                                                                                                                     as\n-                                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n-                                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                                     &'static str)]\n-                                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                                   [&str; 1])\n-                                                                                                                                                                                                                                 as\n-                                                                                                                                                                                                                                 &[&str; 1]),\n-                                                                                                                                                                                                                             (&(match (()\n-                                                                                                                                                                                                                                          as\n-                                                                                                                                                                                                                                          ())\n-                                                                                                                                                                                                                                    {\n-                                                                                                                                                                                                                                    ()\n-                                                                                                                                                                                                                                    =>\n-                                                                                                                                                                                                                                    ([]\n-                                                                                                                                                                                                                                        as\n-                                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                                }\n-                                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                                   [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                                 as\n-                                                                                                                                                                                                                                 &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1]) -> std::fmt::Arguments {std::fmt::Arguments::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       &str)]\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     [&str; 1])\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &[&str; 1]),\n+                                                                                                                                                                                                               (&(match (()\n+                                                                                                                                                                                                                            as\n+                                                                                                                                                                                                                            ())\n+                                                                                                                                                                                                                      {\n+                                                                                                                                                                                                                      ()\n+                                                                                                                                                                                                                      =>\n+                                                                                                                                                                                                                      ([]\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          [std::fmt::ArgumentV1; 0]),\n+                                                                                                                                                                                                                  }\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     [std::fmt::ArgumentV1; 0])\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &[std::fmt::ArgumentV1; 0]))\n                                                                                                                    as\n-                                                                                                                   std::fmt::Arguments<'_>))\n+                                                                                                                   std::fmt::Arguments))\n                                as std::string::String);\n                        (res as std::string::String)\n                    } as std::string::String);"}, {"sha": "5a4777145962584d625b2f0067e8511e92630b9a", "filename": "src/test/ui/consts/transmute-size-mismatch-before-typeck.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -21,7 +21,7 @@ LL | const ZST: &[u8] = unsafe { std::mem::transmute(1usize) };\n    |                             ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: source type: `usize` (word size)\n-   = note: target type: `&'static [u8]` (2 * word size)\n+   = note: target type: `&[u8]` (2 * word size)\n \n error: could not evaluate constant pattern\n   --> $DIR/transmute-size-mismatch-before-typeck.rs:10:9"}, {"sha": "ad854837ae5bd678985e7f483a2fd97019929755", "filename": "src/test/ui/error-codes/E0121.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -14,7 +14,7 @@ LL | static BAR: _ = \"test\";\n    |             ^\n    |             |\n    |             not allowed in type signatures\n-   |             help: replace `_` with the correct type: `&'static str`\n+   |             help: replace `_` with the correct type: `&str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "09402c3d814101610a67760d90df1148e9abe146", "filename": "src/test/ui/issues/issue-21174.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fissues%2Fissue-21174.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fissues%2Fissue-21174.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21174.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -4,8 +4,8 @@ error[E0512]: cannot transmute between types of different sizes, or dependently-\n LL |     let new: T::B = unsafe { std::mem::transmute(value) };\n    |                              ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: source type: `<T as Trait<'a>>::A` (size can vary because of <T as Trait>::A)\n-   = note: target type: `<T as Trait<'a>>::B` (size can vary because of <T as Trait>::B)\n+   = note: source type: `<T as Trait>::A` (this type does not have a fixed size)\n+   = note: target type: `<T as Trait>::B` (this type does not have a fixed size)\n \n error: aborting due to previous error\n "}, {"sha": "bf0562713a497f1667792a8a37d2e2a7c512f7cf", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -1,4 +1,4 @@\n-error: the type `&'static T` does not permit zero-initialization\n+error: the type `&T` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:29:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n@@ -14,7 +14,7 @@ LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n    = note: references must be non-null\n \n-error: the type `&'static T` does not permit being left uninitialized\n+error: the type `&T` does not permit being left uninitialized\n   --> $DIR/uninitialized-zeroed.rs:30:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n@@ -25,7 +25,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    |\n    = note: references must be non-null\n \n-error: the type `Wrap<&'static T>` does not permit zero-initialization\n+error: the type `Wrap<&T>` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:32:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n@@ -40,7 +40,7 @@ note: references must be non-null (in this struct field)\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n-error: the type `Wrap<&'static T>` does not permit being left uninitialized\n+error: the type `Wrap<&T>` does not permit being left uninitialized\n   --> $DIR/uninitialized-zeroed.rs:33:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n@@ -121,7 +121,7 @@ LL |         let _val: Void = mem::uninitialized();\n    |\n    = note: enums with no variants have no valid value\n \n-error: the type `&'static i32` does not permit zero-initialization\n+error: the type `&i32` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:49:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n@@ -132,7 +132,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    |\n    = note: references must be non-null\n \n-error: the type `&'static i32` does not permit being left uninitialized\n+error: the type `&i32` does not permit being left uninitialized\n   --> $DIR/uninitialized-zeroed.rs:50:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n@@ -366,7 +366,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |\n    = note: `NonBig` must be initialized inside its custom valid range\n \n-error: the type `&'static i32` does not permit zero-initialization\n+error: the type `&i32` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:84:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n@@ -377,7 +377,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |\n    = note: references must be non-null\n \n-error: the type `&'static [i32]` does not permit zero-initialization\n+error: the type `&[i32]` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:85:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));"}, {"sha": "7d1cac8a442f5eae819c049f52de8966fb3d0fe7", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -21,7 +21,7 @@ fn uninhab_union() -> Foo {\n \n fn match_on_uninhab() {\n     match uninhab_ref() {\n-        //~^ ERROR non-exhaustive patterns: type `&'static !` is non-empty\n+        //~^ ERROR non-exhaustive patterns: type `&!` is non-empty\n     }\n \n     match uninhab_union() {"}, {"sha": "e1079f912d076821d3d95434b4df0c6754f55b7d", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -1,4 +1,4 @@\n-error[E0004]: non-exhaustive patterns: type `&'static !` is non-empty\n+error[E0004]: non-exhaustive patterns: type `&!` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:23:11\n    |\n LL |     match uninhab_ref() {"}, {"sha": "06e1b0f1ac262288cc384c6b59c8041037bce83e", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.migrate.stderr", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -1,32 +1,54 @@\n-error[E0623]: lifetime mismatch\n+error[E0491]: in type `&'b &'a usize`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-free-region-ordering-caller.rs:11:12\n    |\n-LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |                     ---------     ---------\n-   |                     |\n-   |                     these two types are declared with different lifetimes...\n LL |     let z: Option<&'b &'a usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ ...but data from `a` flows into `b` here\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'b` as defined on the function body at 10:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:10:14\n+   |\n+LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |              ^^\n+note: but the referenced data is only valid for the lifetime `'a` as defined on the function body at 10:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:10:10\n+   |\n+LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          ^^\n \n-error[E0623]: lifetime mismatch\n+error[E0491]: in type `&'b Paramd<'a>`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-free-region-ordering-caller.rs:17:12\n    |\n-LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |                     ---------     ---------\n-   |                     |\n-   |                     these two types are declared with different lifetimes...\n-LL |     let y: Paramd<'a> = Paramd { x: a };\n LL |     let z: Option<&'b Paramd<'a>> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ ...but data from `a` flows into `b` here\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'b` as defined on the function body at 15:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:15:14\n+   |\n+LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |              ^^\n+note: but the referenced data is only valid for the lifetime `'a` as defined on the function body at 15:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:15:10\n+   |\n+LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          ^^\n \n-error[E0623]: lifetime mismatch\n+error[E0491]: in type `&'a &'b usize`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-free-region-ordering-caller.rs:22:12\n    |\n-LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |                     ---------     --------- these two types are declared with different lifetimes...\n LL |     let z: Option<&'a &'b usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ ...but data from `b` flows into `a` here\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'a` as defined on the function body at 21:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:21:10\n+   |\n+LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          ^^\n+note: but the referenced data is only valid for the lifetime `'b` as defined on the function body at 21:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:21:14\n+   |\n+LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |              ^^\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0623`.\n+For more information about this error, try `rustc --explain E0491`."}, {"sha": "2bf4734cf73802137006e1cd64f2865447231f85", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -8,18 +8,18 @@\n struct Paramd<'a> { x: &'a usize }\n \n fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'b &'a usize> = None;//[migrate]~ ERROR E0623\n+    let z: Option<&'b &'a usize> = None;//[migrate]~ ERROR E0491\n     //[nll]~^ ERROR lifetime may not live long enough\n }\n \n fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n     let y: Paramd<'a> = Paramd { x: a };\n-    let z: Option<&'b Paramd<'a>> = None;//[migrate]~ ERROR E0623\n+    let z: Option<&'b Paramd<'a>> = None;//[migrate]~ ERROR E0491\n     //[nll]~^ ERROR lifetime may not live long enough\n }\n \n fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'a &'b usize> = None;//[migrate]~ ERROR E0623\n+    let z: Option<&'a &'b usize> = None;//[migrate]~ ERROR E0491\n     //[nll]~^ ERROR lifetime may not live long enough\n }\n "}, {"sha": "6b79697e9839e1947c11e1a04e4f16285d4ff51e", "filename": "src/test/ui/suggestions/const-no-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -43,4 +43,4 @@ static S = Vec::<String>::new();\n static mut SM = \"abc\";\n //~^ ERROR missing type for `static mut` item\n //~| HELP provide a type for the item\n-//~| SUGGESTION &'static str\n+//~| SUGGESTION &str"}, {"sha": "a7b5aa5e5b124397475ba3e421d4942d8427c6b0", "filename": "src/test/ui/suggestions/const-no-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -14,7 +14,7 @@ error: missing type for `static mut` item\n   --> $DIR/const-no-type.rs:43:12\n    |\n LL | static mut SM = \"abc\";\n-   |            ^^ help: provide a type for the item: `SM: &'static str`\n+   |            ^^ help: provide a type for the item: `SM: &str`\n \n error: missing type for `const` item\n   --> $DIR/const-no-type.rs:14:7"}, {"sha": "4e781318329bf0dd0c4cf925b290d132269564df", "filename": "src/test/ui/transmute/main.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ftransmute%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ftransmute%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmute%2Fmain.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -4,8 +4,7 @@ error[E0512]: cannot transmute between types of different sizes, or dependently-\n LL |     transmute(x)\n    |     ^^^^^^^^^\n    |\n-   = note: source type: `<C as TypeConstructor<'a>>::T` (size can vary because of <C as TypeConstructor>::T)\n-   = note: target type: `<C as TypeConstructor<'b>>::T` (size can vary because of <C as TypeConstructor>::T)\n+   = note: `<C as TypeConstructor>::T` does not have a fixed size\n \n error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --> $DIR/main.rs:20:17"}, {"sha": "dc86ab30dfe415a3a067627339659ae25c0a8a8f", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f583fc27079fbc0983635f3fd40b47b89ed2f80/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=3f583fc27079fbc0983635f3fd40b47b89ed2f80", "patch": "@@ -70,7 +70,7 @@ LL | static TEST3: _ = \"test\";\n    |               ^\n    |               |\n    |               not allowed in type signatures\n-   |               help: replace `_` with the correct type: `&'static str`\n+   |               help: replace `_` with the correct type: `&str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item.rs:15:15\n@@ -232,7 +232,7 @@ LL |     static FN_TEST3: _ = \"test\";\n    |                      ^\n    |                      |\n    |                      not allowed in type signatures\n-   |                      help: replace `_` with the correct type: `&'static str`\n+   |                      help: replace `_` with the correct type: `&str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item.rs:88:22"}]}