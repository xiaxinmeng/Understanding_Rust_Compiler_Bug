{"sha": "a008fc84aaf429a1966c422297302cf809df796d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMDhmYzg0YWFmNDI5YTE5NjZjNDIyMjk3MzAyY2Y4MDlkZjc5NmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-12T00:57:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-14T19:27:56Z"}, "message": "Fix rebase fallout. Sorry.", "tree": {"sha": "aa2beb459d8b66bf914d787dd5c3bd086c1b9035", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa2beb459d8b66bf914d787dd5c3bd086c1b9035"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a008fc84aaf429a1966c422297302cf809df796d", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a008fc84aaf429a1966c422297302cf809df796d", "html_url": "https://github.com/rust-lang/rust/commit/a008fc84aaf429a1966c422297302cf809df796d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a008fc84aaf429a1966c422297302cf809df796d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3096d9bf946d2e3e74b24dbb4a5d116a5d9ac7c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3096d9bf946d2e3e74b24dbb4a5d116a5d9ac7c7", "html_url": "https://github.com/rust-lang/rust/commit/3096d9bf946d2e3e74b24dbb4a5d116a5d9ac7c7"}], "stats": {"total": 105, "additions": 29, "deletions": 76}, "files": [{"sha": "92d1c176a1b92c8b28d8ef2faf7b2b56d6a6c811", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a008fc84aaf429a1966c422297302cf809df796d", "patch": "@@ -66,7 +66,6 @@ pub mod back {\n     pub mod lto;\n \n }\n->>>>>>> Extract librustc_back from librustc\n \n pub mod middle {\n     pub mod def;"}, {"sha": "bb33a5e4f8d2fa5a1b392a47d6212ae85d617f11", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=a008fc84aaf429a1966c422297302cf809df796d", "patch": "@@ -426,13 +426,13 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n             assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n             let order = if split.len() == 2 {\n-                lib::llvm::SequentiallyConsistent\n+                llvm::SequentiallyConsistent\n             } else {\n                 match *split.get(2) {\n-                    \"relaxed\" => lib::llvm::Monotonic,\n-                    \"acq\"     => lib::llvm::Acquire,\n-                    \"rel\"     => lib::llvm::Release,\n-                    \"acqrel\"  => lib::llvm::AcquireRelease,\n+                    \"relaxed\" => llvm::Monotonic,\n+                    \"acq\"     => llvm::Acquire,\n+                    \"rel\"     => llvm::Release,\n+                    \"acqrel\"  => llvm::AcquireRelease,\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 }\n             };\n@@ -443,23 +443,23 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n                     // of this, I assume that it's good enough for us to use for\n                     // now.\n                     let strongest_failure_ordering = match order {\n-                        lib::llvm::NotAtomic | lib::llvm::Unordered =>\n+                        llvm::NotAtomic | llvm::Unordered =>\n                             ccx.sess().fatal(\"cmpxchg must be atomic\"),\n \n-                        lib::llvm::Monotonic | lib::llvm::Release =>\n-                            lib::llvm::Monotonic,\n+                        llvm::Monotonic | llvm::Release =>\n+                            llvm::Monotonic,\n \n-                        lib::llvm::Acquire | lib::llvm::AcquireRelease =>\n-                            lib::llvm::Acquire,\n+                        llvm::Acquire | llvm::AcquireRelease =>\n+                            llvm::Acquire,\n \n-                        lib::llvm::SequentiallyConsistent =>\n-                            lib::llvm::SequentiallyConsistent\n+                        llvm::SequentiallyConsistent =>\n+                            llvm::SequentiallyConsistent\n                     };\n \n                     let res = AtomicCmpXchg(bcx, *llargs.get(0), *llargs.get(1),\n                                             *llargs.get(2), order,\n                                             strongest_failure_ordering);\n-                    if unsafe { lib::llvm::llvm::LLVMVersionMinor() >= 5 } {\n+                    if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n                     } else {\n                         res\n@@ -482,17 +482,17 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n                 // These are all AtomicRMW ops\n                 op => {\n                     let atom_op = match op {\n-                        \"xchg\"  => lib::llvm::Xchg,\n-                        \"xadd\"  => lib::llvm::Add,\n-                        \"xsub\"  => lib::llvm::Sub,\n-                        \"and\"   => lib::llvm::And,\n-                        \"nand\"  => lib::llvm::Nand,\n-                        \"or\"    => lib::llvm::Or,\n-                        \"xor\"   => lib::llvm::Xor,\n-                        \"max\"   => lib::llvm::Max,\n-                        \"min\"   => lib::llvm::Min,\n-                        \"umax\"  => lib::llvm::UMax,\n-                        \"umin\"  => lib::llvm::UMin,\n+                        \"xchg\"  => llvm::Xchg,\n+                        \"xadd\"  => llvm::Add,\n+                        \"xsub\"  => llvm::Sub,\n+                        \"and\"   => llvm::And,\n+                        \"nand\"  => llvm::Nand,\n+                        \"or\"    => llvm::Or,\n+                        \"xor\"   => llvm::Xor,\n+                        \"max\"   => llvm::Max,\n+                        \"min\"   => llvm::Min,\n+                        \"umax\"  => llvm::UMax,\n+                        \"umin\"  => llvm::UMin,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n "}, {"sha": "573965108ad9468671343b120ebb9b513209b7a9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=a008fc84aaf429a1966c422297302cf809df796d", "patch": "@@ -308,6 +308,7 @@ impl Type {\n     }\n }\n \n+\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n@@ -330,7 +331,7 @@ impl TypeNames {\n         self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: Type) -> String {\n+    pub fn type_to_string(&self, ty: Type) -> String {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n@@ -340,11 +341,11 @@ impl TypeNames {\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n+        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n         format!(\"[{}]\", strs.connect(\",\"))\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> String {\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);\n@@ -353,4 +354,3 @@ impl TypeNames {\n         }\n     }\n }\n-"}, {"sha": "e298e1dbfe94acba5f456f649dadfd6d8fce0434", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=a008fc84aaf429a1966c422297302cf809df796d", "patch": "@@ -230,7 +230,7 @@ mod test {\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n             get_install_prefix_lib_path: || fail!(),\n-            realpath: |p| p.clone()\n+            realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@loader_path/../lib\");"}, {"sha": "9ee8fa98c7499ca98654052dbf93557222c2e362", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a008fc84aaf429a1966c422297302cf809df796d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a008fc84aaf429a1966c422297302cf809df796d", "patch": "@@ -1869,52 +1869,6 @@ pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     }\n }\n \n-/* Memory-managed object interface to type handles. */\n-\n-pub struct TypeNames {\n-    named_types: RefCell<HashMap<String, TypeRef>>,\n-}\n-\n-impl TypeNames {\n-    pub fn new() -> TypeNames {\n-        TypeNames {\n-            named_types: RefCell::new(HashMap::new())\n-        }\n-    }\n-\n-    pub fn associate_type(&self, s: &str, t: &Type) {\n-        assert!(self.named_types.borrow_mut().insert(s.to_string(),\n-                                                     t.to_ref()));\n-    }\n-\n-    pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n-    }\n-\n-    pub fn type_to_string(&self, ty: Type) -> String {\n-        unsafe {\n-            let s = llvm::LLVMTypeToString(ty.to_ref());\n-            let ret = from_c_str(s);\n-            free(s as *mut c_void);\n-            ret.to_string()\n-        }\n-    }\n-\n-    pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n-        format!(\"[{}]\", strs.connect(\",\"))\n-    }\n-\n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        unsafe {\n-            let s = llvm::LLVMValueToString(val);\n-            let ret = from_c_str(s);\n-            free(s as *mut c_void);\n-            ret.to_string()\n-        }\n-    }\n-}\n-\n /* Memory-managed interface to target data. */\n \n pub struct TargetData {"}]}