{"sha": "e75ad93d958c0c3d4dceaa07cceccc253674a4f2", "node_id": "C_kwDOAAsO6NoAKGU3NWFkOTNkOTU4YzBjM2Q0ZGNlYWEwN2NjZWNjYzI1MzY3NGE0ZjI", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-08-31T15:43:53Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:10Z"}, "message": "Begin a semi-formal argument for correctness", "tree": {"sha": "ca774602829b0efa33b3efb3763625df04623109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca774602829b0efa33b3efb3763625df04623109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75ad93d958c0c3d4dceaa07cceccc253674a4f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75ad93d958c0c3d4dceaa07cceccc253674a4f2", "html_url": "https://github.com/rust-lang/rust/commit/e75ad93d958c0c3d4dceaa07cceccc253674a4f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75ad93d958c0c3d4dceaa07cceccc253674a4f2/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292869493ce64e4aa4305eae4f1f2a246d50d0b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/292869493ce64e4aa4305eae4f1f2a246d50d0b0", "html_url": "https://github.com/rust-lang/rust/commit/292869493ce64e4aa4305eae4f1f2a246d50d0b0"}], "stats": {"total": 28, "additions": 28, "deletions": 0}, "files": [{"sha": "8b913d708001b9e4708c21a551f4a73ba4f4a1b6", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e75ad93d958c0c3d4dceaa07cceccc253674a4f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75ad93d958c0c3d4dceaa07cceccc253674a4f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=e75ad93d958c0c3d4dceaa07cceccc253674a4f2", "patch": "@@ -15,6 +15,34 @@\n //! place. For example: Assume `let x = (0, 0)` and that we want to propagate values from `x.0` and\n //! `x.1` also through the assignment `let y = &x`. In this case, we should register `x.0`, `x.1`,\n //! `(*y).0` and `(*y).1`.\n+//!\n+//!\n+//! # Correctness\n+//!\n+//! Warning: This is a semi-formal attempt to argue for the correctness of this analysis. If you\n+//! find any weak spots, let me know! Recommended reading: Abstract Interpretation.\n+//!\n+//! In the following, we will assume a constant propagation analysis. Our analysis is correct if\n+//! every transfer function is correct. This is the case if for every pair (f, f#) and abstract\n+//! state s, we have f(y(s)) <= y(f#(s)), where s is a mapping from tracked place to top, bottom or\n+//! a constant. Since pointers (and mutable references) are not tracked, but can be used to change\n+//! values in the concrete domain, f# must assume that all places that can be affected in this way\n+//! for a given program point are marked with top (otherwise many assignments and function calls\n+//! would have no choice but to mark all tracked places with top). This leads us to an invariant:\n+//! For all possible program points where there could possibly exist a mutable reference or pointer\n+//! to a tracked place (in the concrete domain), this place must be assigned to top (in the\n+//! abstract domain). The concretization function y can be defined as expected for the constant\n+//! propagation analysis, although the concrete state of course contains all kinds of non-tracked\n+//! data. However, by the invariant above, no mutable references or pointers to tracked places that\n+//! are not marked with top may be introduced.\n+//!\n+//! Note that we (at least currently) do not differentiate between \"this place may assume different\n+//! values\" and \"a pointer to this place escaped the analysis\". However, we still want to handle\n+//! assignments to constants as usual for f#. This adds an assumption: Whenever we have an\n+//! assignment, all mutable access to the underlying place (which is not observed by the analysis)\n+//! must be invalidated. This is (hopefully) covered by Stacked Borrows.\n+//!\n+//! To be continued...\n \n use std::fmt::{Debug, Formatter};\n "}]}