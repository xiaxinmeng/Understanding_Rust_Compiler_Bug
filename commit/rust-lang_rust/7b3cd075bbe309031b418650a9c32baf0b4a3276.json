{"sha": "7b3cd075bbe309031b418650a9c32baf0b4a3276", "node_id": "C_kwDOAAsO6NoAKDdiM2NkMDc1YmJlMzA5MDMxYjQxODY1MGE5YzMyYmFmMGI0YTMyNzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T17:44:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T17:44:33Z"}, "message": "Auto merge of #90788 - ecstatic-morse:issue-90752, r=wesleywiser\n\nMark places as initialized when mutably borrowed\n\nFixes the example in #90752, but does not handle some corner cases involving raw pointers and unsafe. See [this comment](https://github.com/rust-lang/rust/issues/90752#issuecomment-965822895) for more information, or the second test.\n\nAlthough I talked about both `MaybeUninitializedPlaces` and `MaybeInitializedPlaces` in #90752, this PR only changes the latter. That's because \"maybe uninitialized\" is the conservative choice, and marking them as definitely initialized (`!maybe_uninitialized`) when a mutable borrow is created could lead to problems if `addr_of_mut` to an uninitialized local is allowed. Additionally, places cannot become uninitialized via a mutable reference, so if a place is definitely initialized, taking a mutable reference to it should not change that.\n\nI think it's correct to ignore interior mutability as nbdd0121 suggests below. Their analysis doesn't work inside of `core::cell`, which *does* have access to `UnsafeCell`'s field, but that won't be an issue unless we explicitly instantiate one with an `enum` within that module.\n\nr? `@wesleywiser`", "tree": {"sha": "3497a521d0204eb2a83f6659c429c50576ebd693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3497a521d0204eb2a83f6659c429c50576ebd693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b3cd075bbe309031b418650a9c32baf0b4a3276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3cd075bbe309031b418650a9c32baf0b4a3276", "html_url": "https://github.com/rust-lang/rust/commit/7b3cd075bbe309031b418650a9c32baf0b4a3276", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b3cd075bbe309031b418650a9c32baf0b4a3276/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "html_url": "https://github.com/rust-lang/rust/commit/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b"}, {"sha": "22d937ddfc64bdf1f8724a27a782f2da2ae72be0", "url": "https://api.github.com/repos/rust-lang/rust/commits/22d937ddfc64bdf1f8724a27a782f2da2ae72be0", "html_url": "https://github.com/rust-lang/rust/commit/22d937ddfc64bdf1f8724a27a782f2da2ae72be0"}], "stats": {"total": 169, "additions": 163, "deletions": 6}, "files": [{"sha": "2585701f60c66b5ff2e0c90f4d418f98bd973a44", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7b3cd075bbe309031b418650a9c32baf0b4a3276/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3cd075bbe309031b418650a9c32baf0b4a3276/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=7b3cd075bbe309031b418650a9c32baf0b4a3276", "patch": "@@ -4,17 +4,18 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n+use rustc_middle::mir::visit::{MirVisitable, Visitor};\n use rustc_middle::mir::{self, Body, Location};\n use rustc_middle::ty::{self, TyCtxt};\n \n-use crate::drop_flag_effects;\n use crate::drop_flag_effects_for_function_entry;\n use crate::drop_flag_effects_for_location;\n use crate::elaborate_drops::DropFlagState;\n use crate::framework::SwitchIntEdgeEffects;\n-use crate::move_paths::{HasMoveData, InitIndex, InitKind, MoveData, MovePathIndex};\n+use crate::move_paths::{HasMoveData, InitIndex, InitKind, LookupResult, MoveData, MovePathIndex};\n use crate::on_lookup_result_bits;\n use crate::MoveDataParamEnv;\n+use crate::{drop_flag_effects, on_all_children_bits};\n use crate::{lattice, AnalysisDomain, GenKill, GenKillAnalysis};\n \n mod borrowed_locals;\n@@ -307,22 +308,45 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n-        _statement: &mir::Statement<'tcx>,\n+        statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n+        });\n+\n+        if !self.tcx.sess.opts.debugging_opts.precise_enum_drop_elaboration {\n+            return;\n+        }\n+\n+        // Mark all places as \"maybe init\" if they are mutably borrowed. See #90752.\n+        for_each_mut_borrow(statement, location, |place| {\n+            let LookupResult::Exact(mpi) = self.move_data().rev_lookup.find(place.as_ref()) else { return };\n+            on_all_children_bits(self.tcx, self.body, self.move_data(), mpi, |child| {\n+                trans.gen(child);\n+            })\n         })\n     }\n \n     fn terminator_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n-        _terminator: &mir::Terminator<'tcx>,\n+        terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n+        });\n+\n+        if !self.tcx.sess.opts.debugging_opts.precise_enum_drop_elaboration {\n+            return;\n+        }\n+\n+        for_each_mut_borrow(terminator, location, |place| {\n+            let LookupResult::Exact(mpi) = self.move_data().rev_lookup.find(place.as_ref()) else { return };\n+            on_all_children_bits(self.tcx, self.body, self.move_data(), mpi, |child| {\n+                trans.gen(child);\n+            })\n         })\n     }\n \n@@ -427,7 +451,10 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n-        })\n+        });\n+\n+        // Unlike in `MaybeInitializedPlaces` above, we don't need to change the state when a\n+        // mutable borrow occurs. Places cannot become uninitialized through a mutable reference.\n     }\n \n     fn terminator_effect(\n@@ -438,7 +465,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n-        })\n+        });\n     }\n \n     fn call_return_effect(\n@@ -704,3 +731,37 @@ fn switch_on_enum_discriminant(\n         _ => None,\n     }\n }\n+\n+struct OnMutBorrow<F>(F);\n+\n+impl<F> Visitor<'_> for OnMutBorrow<F>\n+where\n+    F: FnMut(&mir::Place<'_>),\n+{\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'_>, location: Location) {\n+        // FIXME: Does `&raw const foo` allow mutation? See #90413.\n+        match rvalue {\n+            mir::Rvalue::Ref(_, mir::BorrowKind::Mut { .. }, place)\n+            | mir::Rvalue::AddressOf(_, place) => (self.0)(place),\n+\n+            _ => {}\n+        }\n+\n+        self.super_rvalue(rvalue, location)\n+    }\n+}\n+\n+/// Calls `f` for each mutable borrow or raw reference in the program.\n+///\n+/// This DOES NOT call `f` for a shared borrow of a type with interior mutability.  That's okay for\n+/// initializedness, because we cannot move from an `UnsafeCell` (outside of `core::cell`), but\n+/// other analyses will likely need to check for `!Freeze`.\n+fn for_each_mut_borrow<'tcx>(\n+    mir: &impl MirVisitable<'tcx>,\n+    location: Location,\n+    f: impl FnMut(&mir::Place<'_>),\n+) {\n+    let mut vis = OnMutBorrow(f);\n+\n+    mir.apply(location, &mut vis);\n+}"}, {"sha": "4e67b35949e28dbfb62db238816ad25b6eb93427", "filename": "src/test/ui/drop/issue-90752-raw-ptr-shenanigans.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fdrop%2Fissue-90752-raw-ptr-shenanigans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fdrop%2Fissue-90752-raw-ptr-shenanigans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-90752-raw-ptr-shenanigans.rs?ref=7b3cd075bbe309031b418650a9c32baf0b4a3276", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+use std::cell::RefCell;\n+\n+struct S<'a>(i32, &'a RefCell<Vec<i32>>);\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(self.0);\n+    }\n+}\n+\n+fn test(drops: &RefCell<Vec<i32>>) {\n+    let mut foo = None;\n+    let pfoo: *mut _ = &mut foo;\n+\n+    match foo {\n+        None => (),\n+        _ => return,\n+    }\n+\n+    // Both S(0) and S(1) should be dropped, but aren't.\n+    unsafe { *pfoo = Some((S(0, drops), S(1, drops))); }\n+\n+    match foo {\n+        Some((_x, _)) => {}\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    let drops = RefCell::new(Vec::new());\n+    test(&drops);\n+\n+    // Ideally, we want this...\n+    //assert_eq!(*drops.borrow(), &[0, 1]);\n+\n+    // But the delayed access through the raw pointer confuses drop elaboration,\n+    // causing S(1) to be leaked.\n+    assert_eq!(*drops.borrow(), &[0]);\n+}"}, {"sha": "4395e45e7733acc2a8e57870df61e16b369a2c9b", "filename": "src/test/ui/drop/issue-90752.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fdrop%2Fissue-90752.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fdrop%2Fissue-90752.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-90752.rs?ref=7b3cd075bbe309031b418650a9c32baf0b4a3276", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+\n+use std::cell::RefCell;\n+\n+struct S<'a>(i32, &'a RefCell<Vec<i32>>);\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(self.0);\n+    }\n+}\n+\n+fn test(drops: &RefCell<Vec<i32>>) {\n+    let mut foo = None;\n+    match foo {\n+        None => (),\n+        _ => return,\n+    }\n+\n+    *(&mut foo) = Some((S(0, drops), S(1, drops))); // Both S(0) and S(1) should be dropped\n+\n+    match foo {\n+        Some((_x, _)) => {}\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    let drops = RefCell::new(Vec::new());\n+    test(&drops);\n+    assert_eq!(*drops.borrow(), &[0, 1]);\n+}"}, {"sha": "f2f64e43cd2de19ca60cb793aad389d721bb5692", "filename": "src/test/ui/moves/move-of-addr-of-mut.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.rs?ref=7b3cd075bbe309031b418650a9c32baf0b4a3276", "patch": "@@ -0,0 +1,12 @@\n+// Ensure that taking a mutable raw ptr to an uninitialized variable does not change its\n+// initializedness.\n+\n+struct S;\n+\n+fn main() {\n+    let mut x: S;\n+    std::ptr::addr_of_mut!(x); //~ borrow of\n+\n+    let y = x; // Should error here if `addr_of_mut` is ever allowed on uninitialized variables\n+    drop(y);\n+}"}, {"sha": "ce8fb0283165c0b4f95cb38f6f4343965ab78590", "filename": "src/test/ui/moves/move-of-addr-of-mut.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b3cd075bbe309031b418650a9c32baf0b4a3276/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-of-addr-of-mut.stderr?ref=7b3cd075bbe309031b418650a9c32baf0b4a3276", "patch": "@@ -0,0 +1,11 @@\n+error[E0381]: borrow of possibly-uninitialized variable: `x`\n+  --> $DIR/move-of-addr-of-mut.rs:8:5\n+   |\n+LL |     std::ptr::addr_of_mut!(x);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `x`\n+   |\n+   = note: this error originates in the macro `std::ptr::addr_of_mut` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0381`."}]}