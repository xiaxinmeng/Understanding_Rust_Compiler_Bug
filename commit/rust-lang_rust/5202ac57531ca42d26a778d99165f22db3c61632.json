{"sha": "5202ac57531ca42d26a778d99165f22db3c61632", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMDJhYzU3NTMxY2E0MmQyNmE3NzhkOTkxNjVmMjJkYjNjNjE2MzI=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2017-04-07T03:29:16Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2017-04-07T03:29:16Z"}, "message": "Correct book examples for hardware re-ordering", "tree": {"sha": "496d94027dd50188c8e34469edd5ca02d1bf62a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/496d94027dd50188c8e34469edd5ca02d1bf62a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5202ac57531ca42d26a778d99165f22db3c61632", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDrgUCxKUwmVd3b8M1krJ1nF23HEFAljnB4wACgkQ1krJ1nF2\n3HF1VQ/+OGP7lvWmH0qSJ6oKnj3CtbEwD+1q0jnBo6YYvBd2P0AksnvuU9WQgTDi\nnDYZAXE8ddlwTagFWceYEvc9A5WL/DWk5bLUISk6ZxfdeykkHY8aWxt/0FRen2mt\nMHks7KlXkHzf8TuZhjB0rmiU43rkcbQCyfUJmpaqx+Vj3F85JpFarFwUHjY6KzAP\nCeiBZW5vCUpWlf4rls2e5gjLvapQgKzfwD6Dp7rGyB6wOil5pe5H541nPZFVz2Im\nLrcp/Oq2g5HdflA1gmFkbXsSe6rWw6YN1p/88a0XhYl5LUB0PROKi9krf1HAwG/O\nGUgG2AdUqPnEnHfTAx8+snJup3ZOJsEOYO8OZq7wAl4oBlXaqoD2PAo6AmtA9Hgq\nLMxkuDQEuAYQORM58DFSsiqbOQDwkLoedDWQaTigLJVMoJG1z9T6HV+uUW2HaUpF\n5xc+AbLD7rCUJSgnpR5nrPTNjtEH1IsxI5g99OQO7kYvTK80p94TrgwKdJu0cGn7\n+sn89JHcEtyY3y0jlL8OZmyRvuXTW410nIPidFnDoPUOSf2neYMCpgdyJKORkkbn\nmHOHcxk+wVtdLMpcdzOYAYoQ/HwYiUTn2R2kxql8zqWDqokQ7XQ8g2fDiKB3oOdi\nIRdf+BfXWaRU7Vu0/rW/Uq/kMvUgANth666o/USIa9i5j553Tdk=\n=VcDq\n-----END PGP SIGNATURE-----", "payload": "tree 496d94027dd50188c8e34469edd5ca02d1bf62a6\nparent 5c6f7fafbdcfe412f0ee836562c3682818604132\nauthor Jon Gjengset <jon@thesquareplanet.com> 1491535756 -0400\ncommitter Jon Gjengset <jon@thesquareplanet.com> 1491535756 -0400\n\nCorrect book examples for hardware re-ordering\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5202ac57531ca42d26a778d99165f22db3c61632", "html_url": "https://github.com/rust-lang/rust/commit/5202ac57531ca42d26a778d99165f22db3c61632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5202ac57531ca42d26a778d99165f22db3c61632/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c6f7fafbdcfe412f0ee836562c3682818604132", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6f7fafbdcfe412f0ee836562c3682818604132", "html_url": "https://github.com/rust-lang/rust/commit/5c6f7fafbdcfe412f0ee836562c3682818604132"}], "stats": {"total": 116, "additions": 62, "deletions": 54}, "files": [{"sha": "3108494aa79f0f6ad2ab5d4872631a8b2108e3f4", "filename": "src/doc/unstable-book/src/compiler-barriers.md", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5202ac57531ca42d26a778d99165f22db3c61632/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md", "raw_url": "https://github.com/rust-lang/rust/raw/5202ac57531ca42d26a778d99165f22db3c61632/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md?ref=5202ac57531ca42d26a778d99165f22db3c61632", "patch": "@@ -21,78 +21,86 @@ A `compiler_barrier` restricts the kinds of memory re-ordering the\n compiler is allowed to do. Specifically, depending on the given ordering\n semantics, the compiler may be disallowed from moving reads or writes\n from before or after the call to the other side of the call to\n-`compiler_barrier`.\n+`compiler_barrier`. Note that it does **not** prevent the *hardware*\n+from doing such re-orderings -- for that, the `volatile_*` class of\n+functions, or full memory fences, need to be used.\n \n ## Examples\n \n-The need to prevent re-ordering of reads and writes often arises when\n-working with low-level devices. Consider a piece of code that interacts\n-with an ethernet card with a set of internal registers that are accessed\n-through an address port register (`a: &mut usize`) and a data port\n-register (`d: &usize`). To read internal register 5, the following code\n-might then be used:\n+`compiler_barrier` is generally only useful for preventing a thread from\n+racing *with itself*. That is, if a given thread is executing one piece\n+of code, and is then interrupted, and starts executing code elsewhere\n+(while still in the same thread, and conceptually still on the same\n+core). In traditional programs, this can only occur when a signal\n+handler is registered. Consider the following code:\n \n ```rust\n-fn read_fifth(a: &mut usize, d: &usize) -> usize {\n-    *a = 5;\n-    *d\n+#use std::sync::atomic::{AtomicBool, AtomicUsize};\n+#use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n+#use std::sync::atomic::Ordering;\n+static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n+static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+fn main() {\n+    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n+    IS_READY.store(true, Ordering::Relaxed);\n+}\n+\n+fn signal_handler() {\n+    if IS_READY.load(Ordering::Relaxed) {\n+        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n+    }\n }\n ```\n \n-In this case, the compiler is free to re-order these two statements if\n-it thinks doing so might result in better performance, register use, or\n-anything else compilers care about. However, in doing so, it would break\n-the code, as `x` would be set to the value of some other device\n-register!\n+The way it is currently written, the `assert_eq!` is *not* guaranteed to\n+succeed, despite everything happening in a single thread. To see why,\n+remember that the compiler is free to swap the stores to\n+`IMPORTANT_VARIABLE` and `IS_READ` since they are both\n+`Ordering::Relaxed`. If it does, and the signal handler is invoked right\n+after `IS_READY` is updated, then the signal handler will see\n+`IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n \n-By inserting a compiler barrier, we can force the compiler to not\n-re-arrange these two statements, making the code function correctly\n-again:\n+Using a `compiler_barrier`, we can remedy this situation:\n \n ```rust\n #![feature(compiler_barriers)]\n-use std::sync::atomic;\n-\n-fn read_fifth(a: &mut usize, d: &usize) -> usize {\n-    *a = 5;\n-    atomic::compiler_barrier(atomic::Ordering::SeqCst);\n-    *d\n+#use std::sync::atomic::{AtomicBool, AtomicUsize};\n+#use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n+#use std::sync::atomic::Ordering;\n+use std::sync::atomic::compiler_barrier;\n+\n+static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n+static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+fn main() {\n+    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n+    // prevent earlier writes from being moved beyond this point\n+    compiler_barrier(Ordering::Release);\n+    IS_READY.store(true, Ordering::Relaxed);\n }\n-```\n-\n-Compiler barriers are also useful in code that implements low-level\n-synchronization primitives. Consider a structure with two different\n-atomic variables, with a dependency chain between them:\n \n-```rust\n-use std::sync::atomic;\n-\n-fn thread1(x: &atomic::AtomicUsize, y: &atomic::AtomicUsize) {\n-    x.store(1, atomic::Ordering::Release);\n-    let v1 = y.load(atomic::Ordering::Acquire);\n-}\n-fn thread2(x: &atomic::AtomicUsize, y: &atomic::AtomicUsize) {\n-    y.store(1, atomic::Ordering::Release);\n-    let v2 = x.load(atomic::Ordering::Acquire);\n+fn signal_handler() {\n+    if IS_READY.load(Ordering::Relaxed) {\n+        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n+    }\n }\n ```\n \n-This code will guarantee that `thread1` sees any writes to `y` made by\n-`thread2`, and that `thread2` sees any writes to `x`. Intuitively, one\n-might also expect that if `thread2` sees `v2 == 0`, `thread1` must see\n-`v1 == 1` (since `thread2`'s store happened before its `load`, and its\n-load did not see `thread1`'s store). However, the code as written does\n-*not* guarantee this, because the compiler is allowed to re-order the\n-store and load within each thread. To enforce this particular behavior,\n-a call to `compiler_barrier(Ordering::SeqCst)` would need to be inserted\n-between the `store` and `load` in both functions.\n-\n-Compiler barriers with weaker re-ordering semantics (such as\n-`Ordering::Acquire`) can also be useful, but are beyond the scope of\n-this text. Curious readers are encouraged to read the Linux kernel's\n-discussion of [memory barriers][1], as well as C++ references on\n-[`std::memory_order`][2] and [`atomic_signal_fence`][3].\n+In more advanced cases (for example, if `IMPORTANT_VARIABLE` was an\n+`AtomicPtr` that starts as `NULL`), it may also be unsafe for the\n+compiler to hoist code using `IMPORTANT_VARIABLE` above the\n+`IS_READY.load`. In that case, a `compiler_barrier(Ordering::Acquire)`\n+should be placed at the top of the `if` to prevent this optimizations.\n+\n+A deeper discussion of compiler barriers with various re-ordering\n+semantics (such as `Ordering::SeqCst`) is beyond the scope of this text.\n+Curious readers are encouraged to read the Linux kernel's discussion of\n+[memory barriers][1], the C++ references on [`std::memory_order`][2] and\n+[`atomic_signal_fence`][3], and [this StackOverflow answer][4] for\n+further details.\n \n [1]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n [2]: http://en.cppreference.com/w/cpp/atomic/memory_order\n [3]: http://www.cplusplus.com/reference/atomic/atomic_signal_fence/\n+[4]: http://stackoverflow.com/a/18454971/472927"}]}