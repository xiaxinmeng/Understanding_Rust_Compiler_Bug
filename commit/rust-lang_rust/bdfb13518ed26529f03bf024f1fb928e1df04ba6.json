{"sha": "bdfb13518ed26529f03bf024f1fb928e1df04ba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZmIxMzUxOGVkMjY1MjlmMDNiZjAyNGYxZmI5MjhlMWRmMDRiYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-14T00:10:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-14T00:10:28Z"}, "message": "Auto merge of #29781 - arielb1:mir-casts, r=nikomatsakis\n\nI am also planning to implement casts, but I will probably do it in a separate PR.\n\nr? @nikomatsakis", "tree": {"sha": "c209893b02f3d7354d89cebb4bd58e3bc3961e9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c209893b02f3d7354d89cebb4bd58e3bc3961e9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdfb13518ed26529f03bf024f1fb928e1df04ba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfb13518ed26529f03bf024f1fb928e1df04ba6", "html_url": "https://github.com/rust-lang/rust/commit/bdfb13518ed26529f03bf024f1fb928e1df04ba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdfb13518ed26529f03bf024f1fb928e1df04ba6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c10569cac5561167c10359d20a3ca38dc4ae2efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/c10569cac5561167c10359d20a3ca38dc4ae2efa", "html_url": "https://github.com/rust-lang/rust/commit/c10569cac5561167c10359d20a3ca38dc4ae2efa"}, {"sha": "b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "html_url": "https://github.com/rust-lang/rust/commit/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3"}], "stats": {"total": 1287, "additions": 998, "deletions": 289}, "files": [{"sha": "c546a264be1bb9e2bb38b27af5b22ff7c06aa094", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -386,14 +386,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     };\n                 }\n \n-                if let Some(target) = adj.unsize {\n-                    expr = Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        ty: target,\n-                        span: self.span,\n-                        kind: ExprKind::Unsize { source: expr.to_ref() },\n-                    };\n-                } else if let Some(autoref) = adj.autoref {\n+                if let Some(autoref) = adj.autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n                         ty::adjustment::AutoPtr(r, m) => {\n@@ -433,6 +426,15 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         }\n                     }\n                 }\n+\n+                if let Some(target) = adj.unsize {\n+                    expr = Expr {\n+                        temp_lifetime: temp_lifetime,\n+                        ty: target,\n+                        span: self.span,\n+                        kind: ExprKind::Unsize { source: expr.to_ref() },\n+                    };\n+                }\n             }\n         }\n "}, {"sha": "15a49fc9d8572dd8fa098456e3d372020696b44e", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -16,6 +16,7 @@\n use repr::*;\n use rustc::middle::subst::Substs;\n use rustc::middle::ty::{self, AdtDef, Ty};\n+use rustc_front::hir;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LvalueTy<'tcx> {\n@@ -102,6 +103,31 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n+    pub fn binop_ty(&self,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    op: BinOp,\n+                    lhs_ty: Ty<'tcx>,\n+                    rhs_ty: Ty<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        // FIXME: handle SIMD correctly\n+        match op {\n+            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem |\n+            BinOp::BitXor | BinOp::BitAnd | BinOp::BitOr => {\n+                // these should be integers or floats of the same size.\n+                assert_eq!(lhs_ty, rhs_ty);\n+                lhs_ty\n+            }\n+            BinOp::Shl | BinOp::Shr => {\n+                lhs_ty // lhs_ty can be != rhs_ty\n+            }\n+            BinOp::Eq | BinOp::Lt | BinOp::Le |\n+            BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+                tcx.types.bool\n+            }\n+        }\n+    }\n+\n     pub fn lvalue_ty(&self,\n                      tcx: &ty::ctxt<'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n@@ -123,3 +149,40 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n }\n+\n+impl BorrowKind {\n+    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n+        match self {\n+            BorrowKind::Mut => hir::MutMutable,\n+            BorrowKind::Shared => hir::MutImmutable,\n+\n+            // We have no type corresponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            BorrowKind::Unique => hir::MutMutable,\n+        }\n+    }\n+}\n+\n+impl BinOp {\n+    pub fn to_hir_binop(self) -> hir::BinOp_ {\n+        match self {\n+            BinOp::Add => hir::BinOp_::BiAdd,\n+            BinOp::Sub => hir::BinOp_::BiSub,\n+            BinOp::Mul => hir::BinOp_::BiMul,\n+            BinOp::Div => hir::BinOp_::BiDiv,\n+            BinOp::Rem => hir::BinOp_::BiRem,\n+            BinOp::BitXor => hir::BinOp_::BiBitXor,\n+            BinOp::BitAnd => hir::BinOp_::BiBitAnd,\n+            BinOp::BitOr => hir::BinOp_::BiBitOr,\n+            BinOp::Shl => hir::BinOp_::BiShl,\n+            BinOp::Shr => hir::BinOp_::BiShr,\n+            BinOp::Eq => hir::BinOp_::BiEq,\n+            BinOp::Ne => hir::BinOp_::BiNe,\n+            BinOp::Lt => hir::BinOp_::BiLt,\n+            BinOp::Gt => hir::BinOp_::BiGt,\n+            BinOp::Le => hir::BinOp_::BiLe,\n+            BinOp::Ge => hir::BinOp_::BiGe\n+        }\n+    }\n+}"}, {"sha": "8023f776dde2f60bf3221bf63f4079d7b56ef4c9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 201, "deletions": 1, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -55,7 +55,7 @@ use trans::builder::{Builder, noname};\n use trans::callee;\n use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n-use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n+use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -312,6 +312,49 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_)\n     }\n }\n \n+pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    lhs_addr: ValueRef,\n+                                    lhs_extra: ValueRef,\n+                                    rhs_addr: ValueRef,\n+                                    rhs_extra: ValueRef,\n+                                    _t: Ty<'tcx>,\n+                                    op: hir::BinOp_,\n+                                    debug_loc: DebugLoc)\n+                                    -> ValueRef {\n+    match op {\n+        hir::BiEq => {\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n+            And(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiNe => {\n+            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n+            Or(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n+            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+            let (op, strict_op) = match op {\n+                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n+                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n+                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n+                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n+                _ => unreachable!()\n+            };\n+\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n+            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n+\n+            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n+            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n+        }\n+        _ => {\n+            bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n+        }\n+    }\n+}\n+\n pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n@@ -336,6 +379,17 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n         }\n+        ty::TyRawPtr(_) => {\n+            let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n+            let lhs_extra = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_EXTRA]));\n+\n+            let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n+            let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n+            compare_fat_ptrs(bcx,\n+                             lhs_addr, lhs_extra,\n+                             rhs_addr, rhs_extra,\n+                             t, op, debug_loc)\n+        }\n         ty::TyInt(_) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n         }\n@@ -523,6 +577,129 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     return cx;\n }\n \n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be drived\n+/// from the old one.\n+pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+                                source: Ty<'tcx>,\n+                                target: Ty<'tcx>,\n+                                old_info: Option<ValueRef>,\n+                                param_substs: &'tcx Substs<'tcx>)\n+                                -> ValueRef {\n+    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n+        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n+            // Note that we preserve binding levels here:\n+            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n+            let substs = ccx.tcx().mk_substs(substs);\n+            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs });\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n+                            Type::vtable_ptr(ccx))\n+        }\n+        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                                     source,\n+                                     target))\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   src: ValueRef,\n+                                   src_ty: Ty<'tcx>,\n+                                   dst_ty: Ty<'tcx>)\n+                                   -> (ValueRef, ValueRef) {\n+    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::TyBox(a), &ty::TyBox(b)) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(common::type_is_sized(bcx.tcx(), a));\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n+            (PointerCast(bcx, src, ptr_ty),\n+             unsized_info(bcx.ccx(), a, b, None, bcx.fcx.param_substs))\n+        }\n+        _ => bcx.sess().bug(\n+            &format!(\"unsize_thin_ptr: called on bad types\"))\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       src: ValueRef,\n+                                       src_ty: Ty<'tcx>,\n+                                       dst: ValueRef,\n+                                       dst_ty: Ty<'tcx>) {\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::TyBox(..), &ty::TyBox(..)) |\n+        (&ty::TyRef(..), &ty::TyRef(..)) |\n+        (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n+        (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n+            let (base, info) = if common::type_is_fat_ptr(bcx.tcx(), src_ty) {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                load_fat_ptr(bcx, src, src_ty)\n+            } else {\n+                let base = load_ty(bcx, src, src_ty);\n+                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+            };\n+            store_fat_ptr(bcx, base, info, dst, dst_ty);\n+        }\n+\n+        // This can be extended to enums and tuples in the future.\n+        // (&ty::TyEnum(def_id_a, _), &ty::TyEnum(def_id_b, _)) |\n+        (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n+            let src_fields = match &*src_repr {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+            };\n+            let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n+            let dst_fields = match &*dst_repr {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+            };\n+\n+            let iter = src_fields.iter().zip(dst_fields).enumerate();\n+            for (i, (src_fty, dst_fty)) in iter {\n+                if type_is_zero_size(bcx.ccx(), dst_fty) { continue; }\n+\n+                let src_f = adt::trans_field_ptr(bcx, &src_repr, src, 0, i);\n+                let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, 0, i);\n+                if src_fty == dst_fty {\n+                    memcpy_ty(bcx, dst_f, src_f, src_fty);\n+                } else {\n+                    coerce_unsized_into(\n+                        bcx,\n+                        src_f, src_fty,\n+                        dst_f, dst_fty\n+                    );\n+                }\n+            }\n+        }\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                                     src_ty,\n+                                     dst_ty))\n+    }\n+}\n+\n pub fn cast_shift_expr_rhs(cx: Block,\n                            op: hir::BinOp_,\n                            lhs: ValueRef,\n@@ -828,6 +1005,10 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         return;\n     }\n \n+    debug!(\"store_ty: {} : {:?} <- {}\",\n+           cx.val_to_string(dst), t,\n+           cx.val_to_string(v));\n+\n     if common::type_is_fat_ptr(cx.tcx(), t) {\n         Store(cx, ExtractValue(cx, v, abi::FAT_PTR_ADDR), expr::get_dataptr(cx, dst));\n         Store(cx, ExtractValue(cx, v, abi::FAT_PTR_EXTRA), expr::get_meta(cx, dst));\n@@ -839,6 +1020,25 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     }\n }\n \n+pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                 data: ValueRef,\n+                                 extra: ValueRef,\n+                                 dst: ValueRef,\n+                                 _ty: Ty<'tcx>) {\n+    // FIXME: emit metadata\n+    Store(cx, data, expr::get_dataptr(cx, dst));\n+    Store(cx, extra, expr::get_meta(cx, dst));\n+}\n+\n+pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                src: ValueRef,\n+                                _ty: Ty<'tcx>) -> (ValueRef, ValueRef)\n+{\n+    // FIXME: emit metadata\n+    (Load(cx, expr::get_dataptr(cx, src)),\n+     Load(cx, expr::get_meta(cx, src)))\n+}\n+\n pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))"}, {"sha": "275f4628788d386f70854cb880a62293c17a404d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -1223,4 +1223,4 @@ pub fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         base::get_extern_const(ccx, did, ty)\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "91f17a50e2c41c48250f5fa430842a292b775476", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -410,7 +410,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n-                let info = expr::unsized_info(cx, pointee_ty, unsized_ty,\n+                let info = base::unsized_info(cx, pointee_ty, unsized_ty,\n                                               old_info, param_substs);\n \n                 if old_info.is_none() {"}, {"sha": "728b53dcd4aee0103a87855b239bea5a11b628a5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 89, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -326,42 +326,6 @@ pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_meta(bcx, src_ptr)), get_meta(bcx, dst_ptr));\n }\n \n-/// Retrieve the information we are losing (making dynamic) in an unsizing\n-/// adjustment.\n-///\n-/// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be drived\n-/// from the old one.\n-pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n-                                source: Ty<'tcx>,\n-                                target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>,\n-                                param_substs: &'tcx Substs<'tcx>)\n-                                -> ValueRef {\n-    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n-    match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n-        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n-        }\n-        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n-            // Note that we preserve binding levels here:\n-            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n-            let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs });\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n-                            Type::vtable_ptr(ccx))\n-        }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                                     source,\n-                                     target))\n-    }\n-}\n-\n fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &hir::Expr) -> bool {\n     let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {\n@@ -1725,58 +1689,6 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_fat_ptr_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   binop_expr: &hir::Expr,\n-                                   binop_ty: Ty<'tcx>,\n-                                   op: hir::BinOp,\n-                                   lhs: Datum<'tcx, Rvalue>,\n-                                   rhs: Datum<'tcx, Rvalue>)\n-                                   -> DatumBlock<'blk, 'tcx, Expr>\n-{\n-    let debug_loc = binop_expr.debug_loc();\n-\n-    let lhs_addr = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_ADDR]));\n-    let lhs_extra = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_EXTRA]));\n-\n-    let rhs_addr = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_ADDR]));\n-    let rhs_extra = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_EXTRA]));\n-\n-    let val = match op.node {\n-        hir::BiEq => {\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-            And(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiNe => {\n-            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-            Or(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-            let (op, strict_op) = match op.node {\n-                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => unreachable!()\n-            };\n-\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-        }\n-        _ => {\n-            bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n-        }\n-    };\n-\n-    immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n-}\n-\n fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   binop_expr: &hir::Expr,\n                                   binop_ty: Ty<'tcx>,\n@@ -2005,7 +1917,15 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n                 assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n                         \"built-in binary operators on fat pointers are homogeneous\");\n-                trans_fat_ptr_binop(bcx, expr, binop_ty, op, lhs, rhs)\n+                assert_eq!(binop_ty, bcx.tcx().types.bool);\n+                let val = base::compare_scalar_types(\n+                    bcx,\n+                    lhs.val,\n+                    rhs.val,\n+                    lhs.ty,\n+                    op.node,\n+                    expr.debug_loc());\n+                immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n             } else {\n                 assert!(!type_is_fat_ptr(ccx.tcx(), rhs.ty),\n                         \"built-in binary operators on fat pointers are homogeneous\");"}, {"sha": "fc76d1e787da5119802ce3ce37e763c0384ef066", "filename": "src/librustc_trans/trans/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -27,15 +27,15 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n     for (index, temp_decl) in mir.temp_decls.iter().enumerate() {\n         let ty = bcx.monomorphize(&temp_decl.ty);\n         debug!(\"temp {:?} has type {:?}\", index, ty);\n-        if\n-            ty.is_scalar() ||\n+        if ty.is_scalar() ||\n             ty.is_unique() ||\n-            (ty.is_region_ptr() && !common::type_is_fat_ptr(bcx.tcx(), ty)) ||\n+            ty.is_region_ptr() ||\n             ty.is_simd()\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-            assert!(common::type_is_immediate(bcx.ccx(), ty));\n+            assert!(common::type_is_immediate(bcx.ccx(), ty) ||\n+                    common::type_is_fat_ptr(bcx.tcx(), ty));\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly"}, {"sha": "181a03790eeec1eb557856d3b58c1358cf458046", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -43,7 +43,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let cond = self.trans_operand(bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n                 let llfalse = self.llblock(false_bb);\n-                build::CondBr(bcx, cond.llval, lltrue, llfalse, DebugLoc::None);\n+                build::CondBr(bcx, cond.immediate(), lltrue, llfalse, DebugLoc::None);\n             }\n \n             mir::Terminator::Switch { .. } => {\n@@ -55,7 +55,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr = build::Load(bcx, self.trans_lvalue(bcx, discr).llval);\n                 let switch = build::Switch(bcx, discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let llval = self.trans_constval(bcx, value, switch_ty);\n+                    let llval = self.trans_constval(bcx, value, switch_ty).immediate();\n                     let llbb = self.llblock(*target);\n                     build::AddCase(switch, llval, llbb)\n                 }"}, {"sha": "8c0d8b10bfe47a8f26d8de942530ed839f5277d0", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -8,35 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use middle::ty::Ty;\n use rustc::middle::const_eval::ConstVal;\n use rustc_mir::repr as mir;\n use trans::consts::{self, TrueConst};\n use trans::common::{self, Block};\n+use trans::common::{C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n use trans::type_of;\n \n+use super::operand::OperandRef;\n use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constval(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n                           cv: &ConstVal,\n                           ty: Ty<'tcx>)\n-                          -> ValueRef\n+                          -> OperandRef<'tcx>\n     {\n+        use super::operand::OperandValue::{Ref, Immediate};\n+\n         let ccx = bcx.ccx();\n         let llty = type_of::type_of(ccx, ty);\n-        match *cv {\n-            ConstVal::Float(v) => common::C_floating_f64(v, llty),\n-            ConstVal::Bool(v) => common::C_bool(ccx, v),\n-            ConstVal::Int(v) => common::C_integral(llty, v as u64, true),\n-            ConstVal::Uint(v) => common::C_integral(llty, v, false),\n-            ConstVal::Str(ref v) => common::C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(ref v) => consts::addr_of(ccx,\n-                                                        common::C_bytes(ccx, v),\n-                                                        1,\n-                                                        \"byte_str\"),\n+        let val = match *cv {\n+            ConstVal::Float(v) => Immediate(C_floating_f64(v, llty)),\n+            ConstVal::Bool(v) => Immediate(C_bool(ccx, v)),\n+            ConstVal::Int(v) => Immediate(C_integral(llty, v as u64, true)),\n+            ConstVal::Uint(v) => Immediate(C_integral(llty, v, false)),\n+            ConstVal::Str(ref v) => Immediate(C_str_slice(ccx, v.clone())),\n+            ConstVal::ByteStr(ref v) => {\n+                Immediate(consts::addr_of(ccx,\n+                                          C_bytes(ccx, v),\n+                                          1,\n+                                          \"byte_str\"))\n+            }\n+\n             ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n                 let expr = bcx.tcx().map.expect_expr(id);\n                 let (llval, _) = match consts::const_expr(ccx,\n@@ -47,18 +53,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     Ok(v) => v,\n                     Err(_) => panic!(\"constant eval failure\"),\n                 };\n-                llval\n+                if common::type_is_immediate(bcx.ccx(), ty) {\n+                    Immediate(llval)\n+                } else {\n+                    Ref(llval)\n+                }\n             }\n             ConstVal::Function(_) => {\n                 unimplemented!()\n             }\n+        };\n+        OperandRef {\n+            ty: ty,\n+            val: val\n         }\n     }\n \n     pub fn trans_constant(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n-                          -> ValueRef\n+                          -> OperandRef<'tcx>\n     {\n         let constant_ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {"}, {"sha": "ff80451d2b1665d379adab88b9051833cd83362c", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::ty::{self, Ty};\n use rustc_mir::repr as mir;\n use rustc_mir::tcx::LvalueTy;\n use trans::adt;\n@@ -18,7 +18,8 @@ use trans::build;\n use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n use trans::machine;\n-use trans::tvec;\n+\n+use std::ptr;\n \n use super::{MirContext, TempRef};\n \n@@ -27,13 +28,16 @@ pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n     pub llval: ValueRef,\n \n+    /// This lvalue's extra data if it is unsized, or null\n+    pub llextra: ValueRef,\n+\n     /// Monomorphized type of this lvalue, including variant information\n     pub ty: LvalueTy<'tcx>,\n }\n \n impl<'tcx> LvalueRef<'tcx> {\n-    pub fn new(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n-        LvalueRef { llval: llval, ty: lvalue_ty }\n+    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n     pub fn alloca<'bcx>(bcx: Block<'bcx, 'tcx>,\n@@ -42,11 +46,25 @@ impl<'tcx> LvalueRef<'tcx> {\n                         -> LvalueRef<'tcx>\n     {\n         let lltemp = base::alloc_ty(bcx, ty, name);\n-        LvalueRef::new(lltemp, LvalueTy::from_ty(ty))\n+        LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn lvalue_len(&mut self,\n+                      bcx: Block<'bcx, 'tcx>,\n+                      lvalue: LvalueRef<'tcx>)\n+                      -> ValueRef {\n+        match lvalue.ty.to_ty(bcx.tcx()).sty {\n+            ty::TyArray(_, n) => common::C_uint(bcx.ccx(), n),\n+            ty::TySlice(_) | ty::TyStr => {\n+                assert!(lvalue.llextra != ptr::null_mut());\n+                lvalue.llextra\n+            }\n+            _ => bcx.sess().bug(\"unexpected type in get_base_and_len\"),\n+        }\n+    }\n+\n     pub fn trans_lvalue(&mut self,\n                         bcx: Block<'bcx, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n@@ -67,20 +85,27 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.mir.lvalue_ty(tcx, lvalue);\n-                LvalueRef::new(common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)), const_ty)\n+                LvalueRef::new_sized(\n+                    common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)),\n+                    const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n                 let return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 let llval = fcx.get_ret_slot(bcx, return_ty, \"return\");\n-                LvalueRef::new(llval, LvalueTy::from_ty(return_ty.unwrap()))\n+                LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty.unwrap()))\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                let llprojected = match projection.elem {\n+                let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        base::load_ty(bcx, tr_base.llval, base_ty)\n+                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                            (base::load_ty(bcx, tr_base.llval, base_ty),\n+                             ptr::null_mut())\n+                        } else {\n+                            base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n+                        }\n                     }\n                     mir::ProjectionElem::Field(ref field) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n@@ -90,44 +115,44 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n                         };\n                         let discr = discr as u64;\n-                        adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index())\n+                        (adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index()),\n+                         if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                             ptr::null_mut()\n+                         } else {\n+                             tr_base.llextra\n+                         })\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n                         let index = self.trans_operand(bcx, index);\n-                        let llindex = self.prepare_index(bcx, index.llval);\n-                        let (llbase, _) = tvec::get_base_and_len(bcx, tr_base.llval, base_ty);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        let llindex = self.prepare_index(bcx, index.immediate());\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n                         let llindex = self.prepare_index(bcx, lloffset);\n-                        let (llbase, _) = tvec::get_base_and_len(bcx,\n-                                                                 tr_base.llval,\n-                                                                 base_ty);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        let (llbase, lllen) = tvec::get_base_and_len(bcx,\n-                                                                     tr_base.llval,\n-                                                                     base_ty);\n+                        let lllen = self.lvalue_len(bcx, tr_base);\n                         let llindex = build::Sub(bcx, lllen, lloffset, DebugLoc::None);\n                         let llindex = self.prepare_index(bcx, llindex);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n-                        tr_base.llval\n+                        (tr_base.llval, tr_base.llextra)\n                     }\n                 };\n                 LvalueRef {\n                     llval: llprojected,\n+                    llextra: llextra,\n                     ty: projected_ty,\n                 }\n             }"}, {"sha": "c8eef7ff4487d8d4d5474e21edb3237d3049a3a6", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -180,7 +180,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n                base::store_ty(bcx, llarg, lltemp, arg_ty);\n                lltemp\n            };\n-           LvalueRef::new(llval, LvalueTy::from_ty(arg_ty))\n+           LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n        })\n        .collect()\n }\n@@ -192,4 +192,3 @@ mod lvalue;\n mod rvalue;\n mod operand;\n mod statement;\n-"}, {"sha": "63abdfe2dd9176c46fa3695e9c475936725817d7", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 85, "deletions": 19, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -12,22 +12,72 @@ use llvm::ValueRef;\n use rustc::middle::ty::Ty;\n use rustc_mir::repr as mir;\n use trans::base;\n-use trans::build;\n-use trans::common::Block;\n+use trans::common::{self, Block};\n use trans::datum;\n \n use super::{MirContext, TempRef};\n \n+/// The representation of a Rust value. The enum variant is in fact\n+/// uniquely determined by the value's type, but is kept as a\n+/// safety check.\n+#[derive(Copy, Clone)]\n+pub enum OperandValue {\n+    /// A reference to the actual operand. The data is guaranteed\n+    /// to be valid for the operand's lifetime.\n+    Ref(ValueRef),\n+    /// A single LLVM value.\n+    Immediate(ValueRef),\n+    /// A fat pointer. The first ValueRef is the data and the second\n+    /// is the extra.\n+    FatPtr(ValueRef, ValueRef)\n+}\n+\n+/// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n+/// its type.\n+///\n+/// NOTE: unless you know a value's type exactly, you should not\n+/// generate LLVM opcodes acting on it and instead act via methods,\n+/// to avoid nasty edge cases. In particular, using `build::Store`\n+/// directly is sure to cause problems - use `store_operand` instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n-    // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n-    // ByRef, and otherwise ByValue.\n-    pub llval: ValueRef,\n+    // The value.\n+    pub val: OperandValue,\n \n     // The type of value being returned.\n     pub ty: Ty<'tcx>\n }\n \n+impl<'tcx> OperandRef<'tcx> {\n+    /// Asserts that this operand refers to a scalar and returns\n+    /// a reference to its value.\n+    pub fn immediate(self) -> ValueRef {\n+        match self.val {\n+            OperandValue::Immediate(s) => s,\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    pub fn repr<'bcx>(self, bcx: Block<'bcx, 'tcx>) -> String {\n+        match self.val {\n+            OperandValue::Ref(r) => {\n+                format!(\"OperandRef(Ref({}) @ {:?})\",\n+                        bcx.val_to_string(r), self.ty)\n+            }\n+            OperandValue::Immediate(i) => {\n+                format!(\"OperandRef(Immediate({}) @ {:?})\",\n+                        bcx.val_to_string(i), self.ty)\n+            }\n+            OperandValue::FatPtr(a, d) => {\n+                format!(\"OperandRef(FatPtr({}, {}) @ {:?})\",\n+                        bcx.val_to_string(a),\n+                        bcx.val_to_string(d),\n+                        self.ty)\n+            }\n+        }\n+    }\n+}\n+\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_operand(&mut self,\n                          bcx: Block<'bcx, 'tcx>,\n@@ -62,23 +112,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n                        bcx.val_to_string(tr_lvalue.llval),\n                        ty);\n-                let llval = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-                    datum::ByValue => build::Load(bcx, tr_lvalue.llval),\n-                    datum::ByRef => tr_lvalue.llval,\n+                let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+                    datum::ByValue => {\n+                        OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n+                    }\n+                    datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n+                        let (lldata, llextra) = base::load_fat_ptr(bcx, tr_lvalue.llval, ty);\n+                        OperandValue::FatPtr(lldata, llextra)\n+                    }\n+                    datum::ByRef => OperandValue::Ref(tr_lvalue.llval)\n                 };\n                 OperandRef {\n-                    llval: llval,\n+                    val: val,\n                     ty: ty\n                 }\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let llval = self.trans_constant(bcx, constant);\n-                let ty = bcx.monomorphize(&constant.ty);\n-                OperandRef {\n-                    llval: llval,\n-                    ty: ty,\n-                }\n+                self.trans_constant(bcx, constant)\n             }\n         }\n     }\n@@ -92,10 +143,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                bcx.val_to_string(lldest),\n                operand);\n \n+        // FIXME: consider not copying constants through the\n+        // stack.\n+\n         let o = self.trans_operand(bcx, operand);\n-        match datum::appropriate_rvalue_mode(bcx.ccx(), o.ty) {\n-            datum::ByValue => base::store_ty(bcx, o.llval, lldest, o.ty),\n-            datum::ByRef => base::memcpy_ty(bcx, lldest, o.llval, o.ty),\n-        };\n+        self.store_operand(bcx, lldest, o);\n+    }\n+\n+    pub fn store_operand(&mut self,\n+                         bcx: Block<'bcx, 'tcx>,\n+                         lldest: ValueRef,\n+                         operand: OperandRef<'tcx>)\n+    {\n+        debug!(\"store_operand: operand={}\", operand.repr(bcx));\n+        match operand.val {\n+            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n+            OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n+            OperandValue::FatPtr(data, extra) => {\n+                base::store_fat_ptr(bcx, data, extra, lldest, operand.ty);\n+            }\n+        }\n     }\n }"}, {"sha": "cce71b2570263b2b4e757c7b0877d23df3e7e4e4", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 231, "deletions": 123, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::Ty;\n-use rustc_front::hir;\n+use rustc::middle::ty::{self, Ty};\n use rustc_mir::repr as mir;\n \n use trans::asm;\n@@ -26,7 +25,7 @@ use trans::type_of;\n use trans::tvec;\n \n use super::MirContext;\n-use super::operand::OperandRef;\n+use super::operand::{OperandRef, OperandValue};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -45,17 +44,52 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Cast(..) => {\n-                unimplemented!()\n+            mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n+                if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                    // into-coerce of a thin pointer to a fat pointer - just\n+                    // use the operand path.\n+                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                    self.store_operand(bcx, lldest, temp);\n+                    return bcx;\n+                }\n+\n+                // Unsize of a nontrivial struct. I would prefer for\n+                // this to be eliminated by MIR translation, but\n+                // `CoerceUnsized` can be passed by a where-clause,\n+                // so the (generic) MIR may not be able to expand it.\n+                let operand = self.trans_operand(bcx, operand);\n+                match operand.val {\n+                    OperandValue::FatPtr(..) => unreachable!(),\n+                    OperandValue::Immediate(llval) => {\n+                        // unsize from an immediate structure. We don't\n+                        // really need a temporary alloca here, but\n+                        // avoiding it would require us to have\n+                        // `coerce_unsized_into` use extractvalue to\n+                        // index into the struct, and this case isn't\n+                        // important enough for it.\n+                        debug!(\"trans_rvalue: creating ugly alloca\");\n+                        let lltemp = base::alloc_ty(bcx, operand.ty, \"__unsize_temp\");\n+                        base::store_ty(bcx, llval, lltemp, operand.ty);\n+                        base::coerce_unsized_into(bcx,\n+                                                  lltemp, operand.ty,\n+                                                  lldest, cast_ty);\n+                    }\n+                    OperandValue::Ref(llref) => {\n+                        base::coerce_unsized_into(bcx,\n+                                                  llref, operand.ty,\n+                                                  lldest, cast_ty);\n+                    }\n+                }\n+                bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.trans_operand(bcx, elem);\n-                let size = self.trans_constant(bcx, count);\n+                let size = self.trans_constant(bcx, count).immediate();\n                 let base = expr::get_dataptr(bcx, lldest);\n-                tvec::iter_vec_raw(bcx, base, elem.ty, size, |b, vref, _| {\n-                    build::Store(b, elem.llval, vref);\n-                    b\n+                tvec::iter_vec_raw(bcx, base, elem.ty, size, |bcx, llslot, _| {\n+                    self.store_operand(bcx, llslot, elem);\n+                    bcx\n                 })\n             }\n \n@@ -93,7 +127,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                build::Store(bcx, temp.llval, lldest);\n+                self.store_operand(bcx, lldest, temp);\n                 bcx\n             }\n         }\n@@ -112,152 +146,128 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n-            mir::Rvalue::Cast(..) => {\n-                unimplemented!()\n+            mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                debug!(\"cast operand is {}\", operand.repr(bcx));\n+                let cast_ty = bcx.monomorphize(&cast_ty);\n+\n+                let val = match *kind {\n+                    mir::CastKind::ReifyFnPointer |\n+                    mir::CastKind::UnsafeFnPointer => {\n+                        // these are no-ops at the LLVM level\n+                        operand.val\n+                    }\n+                    mir::CastKind::Unsize => {\n+                        // unsize targets other than to a fat pointer currently\n+                        // can't be operands.\n+                        assert!(common::type_is_fat_ptr(bcx.tcx(), cast_ty));\n+\n+                        match operand.val {\n+                            OperandValue::FatPtr(..) => {\n+                                // unsize from a fat pointer - this is a\n+                                // \"trait-object-to-supertrait\" coercion, for\n+                                // example,\n+                                //   &'a fmt::Debug+Send => &'a fmt::Debug,\n+                                // and is a no-op at the LLVM level\n+                                operand.val\n+                            }\n+                            OperandValue::Immediate(lldata) => {\n+                                // \"standard\" unsize\n+                                let (lldata, llextra) =\n+                                    base::unsize_thin_ptr(bcx, lldata,\n+                                                          operand.ty, cast_ty);\n+                                OperandValue::FatPtr(lldata, llextra)\n+                            }\n+                            OperandValue::Ref(_) => {\n+                                bcx.sess().bug(\n+                                    &format!(\"by-ref operand {} in trans_rvalue_operand\",\n+                                             operand.repr(bcx)));\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::Misc => unimplemented!()\n+                };\n+                (bcx, OperandRef {\n+                    val: val,\n+                    ty: cast_ty\n+                })\n             }\n \n-            mir::Rvalue::Ref(_, _, ref lvalue) => {\n+            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n \n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                let ref_ty = bcx.tcx().mk_ref(\n+                    bcx.tcx().mk_region(ty::ReStatic),\n+                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n+                );\n+\n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                (bcx, OperandRef {\n-                    llval: tr_lvalue.llval,\n-                    ty: tr_lvalue.ty.to_ty(bcx.tcx()),\n-                })\n+                if common::type_is_sized(bcx.tcx(), ty) {\n+                    (bcx, OperandRef {\n+                        val: OperandValue::Immediate(tr_lvalue.llval),\n+                        ty: ref_ty,\n+                    })\n+                } else {\n+                    (bcx, OperandRef {\n+                        val: OperandValue::FatPtr(tr_lvalue.llval,\n+                                                  tr_lvalue.llextra),\n+                        ty: ref_ty,\n+                    })\n+                }\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let (_, lllen) = tvec::get_base_and_len(bcx,\n-                                                        tr_lvalue.llval,\n-                                                        tr_lvalue.ty.to_ty(bcx.tcx()));\n                 (bcx, OperandRef {\n-                    llval: lllen,\n+                    val: OperandValue::Immediate(self.lvalue_len(bcx, tr_lvalue)),\n                     ty: bcx.tcx().types.usize,\n                 })\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(bcx, lhs);\n                 let rhs = self.trans_operand(bcx, rhs);\n-                let is_float = lhs.ty.is_fp();\n-                let is_signed = lhs.ty.is_signed();\n-                let binop_debug_loc = DebugLoc::None;\n-                let llval = match op {\n-                    mir::BinOp::Add => if is_float {\n-                        build::FAdd(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Add(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Sub => if is_float {\n-                        build::FSub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Sub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Mul => if is_float {\n-                        build::FMul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Mul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Div => if is_float {\n-                        build::FDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else if is_signed {\n-                        build::SDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::UDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Rem => if is_float {\n-                        // LLVM currently always lowers the `frem` instructions appropriate\n-                        // library calls typically found in libm. Notably f64 gets wired up\n-                        // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n-                        // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n-                        // instead just an inline function in a header that goes up to a\n-                        // f64, uses `fmod`, and then comes back down to a f32.\n-                        //\n-                        // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n-                        // still unconditionally lower frem instructions over 32-bit floats\n-                        // to a call to `fmodf`. To work around this we special case MSVC\n-                        // 32-bit float rem instructions and instead do the call out to\n-                        // `fmod` ourselves.\n-                        //\n-                        // Note that this is currently duplicated with src/libcore/ops.rs\n-                        // which does the same thing, and it would be nice to perhaps unify\n-                        // these two implementations one day! Also note that we call `fmod`\n-                        // for both 32 and 64-bit floats because if we emit any FRem\n-                        // instruction at all then LLVM is capable of optimizing it into a\n-                        // 32-bit FRem (which we're trying to avoid).\n-                        let tcx = bcx.tcx();\n-                        let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n-                            tcx.sess.target.target.arch == \"x86\";\n-                        if use_fmod {\n-                            let f64t = Type::f64(bcx.ccx());\n-                            let fty = Type::func(&[f64t, f64t], &f64t);\n-                            let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n-                                                            tcx.types.f64);\n-                            if lhs.ty == tcx.types.f32 {\n-                                let lllhs = build::FPExt(bcx, lhs.llval, f64t);\n-                                let llrhs = build::FPExt(bcx, rhs.llval, f64t);\n-                                let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n-                                                        None, binop_debug_loc);\n-                                build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n-                            } else {\n-                                build::Call(bcx, llfn, &[lhs.llval, rhs.llval],\n-                                            None, binop_debug_loc)\n-                            }\n-                        } else {\n-                            build::FRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n+                    match (lhs.val, rhs.val) {\n+                        (OperandValue::FatPtr(lhs_addr, lhs_extra),\n+                         OperandValue::FatPtr(rhs_addr, rhs_extra)) => {\n+                            base::compare_fat_ptrs(bcx,\n+                                                   lhs_addr, lhs_extra,\n+                                                   rhs_addr, rhs_extra,\n+                                                   lhs.ty, op.to_hir_binop(),\n+                                                   DebugLoc::None)\n                         }\n-                    } else if is_signed {\n-                        build::SRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::URem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::BitOr => build::Or(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::BitAnd => build::And(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::BitXor => build::Xor(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n-                                                                      lhs.llval,\n-                                                                      rhs.llval,\n-                                                                      binop_debug_loc),\n-                    mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n-                                                                      lhs.ty,\n-                                                                      lhs.llval,\n-                                                                      rhs.llval,\n-                                                                      binop_debug_loc),\n-                    mir::BinOp::Eq => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiEq, binop_debug_loc),\n-                    mir::BinOp::Lt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiLt, binop_debug_loc),\n-                    mir::BinOp::Le => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiLe, binop_debug_loc),\n-                    mir::BinOp::Ne => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiNe, binop_debug_loc),\n-                    mir::BinOp::Ge => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiGe, binop_debug_loc),\n-                    mir::BinOp::Gt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiGt, binop_debug_loc),\n+                        _ => unreachable!()\n+                    }\n+\n+                } else {\n+                    self.trans_scalar_binop(bcx, op,\n+                                            lhs.immediate(), rhs.immediate(),\n+                                            lhs.ty, DebugLoc::None)\n                 };\n                 (bcx, OperandRef {\n-                    llval: llval,\n-                    ty: lhs.ty,\n+                    val: OperandValue::Immediate(llresult),\n+                    ty: self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty),\n                 })\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(bcx, operand);\n+                let lloperand = operand.immediate();\n                 let is_float = operand.ty.is_fp();\n                 let debug_loc = DebugLoc::None;\n                 let llval = match op {\n-                    mir::UnOp::Not => build::Not(bcx, operand.llval, debug_loc),\n+                    mir::UnOp::Not => build::Not(bcx, lloperand, debug_loc),\n                     mir::UnOp::Neg => if is_float {\n-                        build::FNeg(bcx, operand.llval, debug_loc)\n+                        build::FNeg(bcx, lloperand, debug_loc)\n                     } else {\n-                        build::Neg(bcx, operand.llval, debug_loc)\n+                        build::Neg(bcx, lloperand, debug_loc)\n                     }\n                 };\n                 (bcx, OperandRef {\n-                    llval: llval,\n+                    val: OperandValue::Immediate(llval),\n                     ty: operand.ty,\n                 })\n             }\n@@ -277,7 +287,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                       llalign,\n                                                                       DebugLoc::None);\n                 (bcx, OperandRef {\n-                    llval: llval,\n+                    val: OperandValue::Immediate(llval),\n                     ty: box_ty,\n                 })\n             }\n@@ -290,6 +300,104 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_scalar_binop(&mut self,\n+                              bcx: Block<'bcx, 'tcx>,\n+                              op: mir::BinOp,\n+                              lhs: ValueRef,\n+                              rhs: ValueRef,\n+                              input_ty: Ty<'tcx>,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+        let is_float = input_ty.is_fp();\n+        let is_signed = input_ty.is_signed();\n+        match op {\n+            mir::BinOp::Add => if is_float {\n+                build::FAdd(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Add(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Sub => if is_float {\n+                build::FSub(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Sub(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Mul => if is_float {\n+                build::FMul(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Mul(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Div => if is_float {\n+                build::FDiv(bcx, lhs, rhs, debug_loc)\n+            } else if is_signed {\n+                build::SDiv(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::UDiv(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Rem => if is_float {\n+                // LLVM currently always lowers the `frem` instructions appropriate\n+                // library calls typically found in libm. Notably f64 gets wired up\n+                // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n+                // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n+                // instead just an inline function in a header that goes up to a\n+                // f64, uses `fmod`, and then comes back down to a f32.\n+                //\n+                // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n+                // still unconditionally lower frem instructions over 32-bit floats\n+                // to a call to `fmodf`. To work around this we special case MSVC\n+                // 32-bit float rem instructions and instead do the call out to\n+                // `fmod` ourselves.\n+                //\n+                // Note that this is currently duplicated with src/libcore/ops.rs\n+                // which does the same thing, and it would be nice to perhaps unify\n+                // these two implementations one day! Also note that we call `fmod`\n+                // for both 32 and 64-bit floats because if we emit any FRem\n+                // instruction at all then LLVM is capable of optimizing it into a\n+                // 32-bit FRem (which we're trying to avoid).\n+                let tcx = bcx.tcx();\n+                let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n+                    tcx.sess.target.target.arch == \"x86\";\n+                if use_fmod {\n+                    let f64t = Type::f64(bcx.ccx());\n+                    let fty = Type::func(&[f64t, f64t], &f64t);\n+                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n+                                                    tcx.types.f64);\n+                    if input_ty == tcx.types.f32 {\n+                        let lllhs = build::FPExt(bcx, lhs, f64t);\n+                        let llrhs = build::FPExt(bcx, rhs, f64t);\n+                        let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n+                                                None, debug_loc);\n+                        build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n+                    } else {\n+                        build::Call(bcx, llfn, &[lhs, rhs],\n+                                    None, debug_loc)\n+                    }\n+                } else {\n+                    build::FRem(bcx, lhs, rhs, debug_loc)\n+                }\n+            } else if is_signed {\n+                build::SRem(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::URem(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::BitOr => build::Or(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::BitAnd => build::And(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::BitXor => build::Xor(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n+                                                              lhs,\n+                                                              rhs,\n+                                                              debug_loc),\n+            mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n+                                                              input_ty,\n+                                                              lhs,\n+                                                              rhs,\n+                                                              debug_loc),\n+            mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n+            mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n+                base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n+                                           op.to_hir_binop(), debug_loc)\n+            }\n+        }\n+    }\n }\n \n pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {"}, {"sha": "c1897f79f22c6e9652541b24736be7669d7ed677", "filename": "src/test/run-pass/mir_coercions.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_coercions.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs, coerce_unsized, unsize)]\n+\n+use std::ops::CoerceUnsized;\n+use std::marker::Unsize;\n+\n+#[rustc_mir]\n+fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n+    x\n+}\n+#[rustc_mir]\n+fn fn_coercions(f: &fn(u32) -> u32) ->\n+    (unsafe fn(u32) -> u32,\n+     &(Fn(u32) -> u32+Send))\n+{\n+    (*f, f)\n+}\n+\n+#[rustc_mir]\n+fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n+\n+fn square(a: u32) -> u32 { a * a }\n+\n+#[derive(PartialEq,Eq)]\n+struct PtrWrapper<'a, T: 'a+?Sized>(u32, u32, (), &'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n+\n+struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n+\n+#[rustc_mir]\n+fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n+    p\n+}\n+\n+#[rustc_mir]\n+fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n+    p\n+}\n+\n+#[rustc_mir]\n+fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n+                          -> PtrWrapper<Fn(u32) -> u32> {\n+    p\n+}\n+\n+\n+fn main() {\n+    let a = [0,1,2];\n+    let square_local : fn(u32) -> u32 = square;\n+    let (f,g) = fn_coercions(&square_local);\n+    assert_eq!(f as usize, square as usize);\n+    assert_eq!(g(4), 16);\n+    assert_eq!(identity_coercion(g)(5), 25);\n+\n+    assert_eq!(simple_array_coercion(&a), &a);\n+    let w = coerce_ptr_wrapper(PtrWrapper(2,3,(),&a));\n+    assert!(w == PtrWrapper(2,3,(),&a) as PtrWrapper<[u8]>);\n+\n+    let w = coerce_triv_ptr_wrapper(TrivPtrWrapper(&a));\n+    assert_eq!(&w.0, &a);\n+\n+    let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n+    assert_eq!((z.3)(6), 36);\n+}"}, {"sha": "1916e608a8c79bdc2139f5ddbe95c09dc4d9e76d", "filename": "src/test/run-pass/mir_fat_ptr.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that ordinary fat pointer operations work.\n+\n+#![feature(rustc_attrs)]\n+\n+struct Wrapper<T: ?Sized>(u32, T);\n+\n+struct FatPtrContainer<'a> {\n+    ptr: &'a [u8]\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n+    &a.1\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n+    a\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n+    let x = a;\n+    x\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n+    s.ptr\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n+    FatPtrContainer { ptr: a }\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n+    *b = a;\n+}\n+\n+fn main() {\n+    let a = Wrapper(4, [7,6,5]);\n+\n+    let p = fat_ptr_project(&a);\n+    let p = fat_ptr_simple(p);\n+    let p = fat_ptr_via_local(p);\n+    let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n+\n+    let mut target : &[u8] = &[42];\n+    fat_ptr_store_to(p, &mut target);\n+    assert_eq!(target, &a.1);\n+}"}, {"sha": "20c3357d7d232ed5f5c87ed5411cfa803149b343", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfb13518ed26529f03bf024f1fb928e1df04ba6/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=bdfb13518ed26529f03bf024f1fb928e1df04ba6", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// check raw fat pointer ops in mir\n+// FIXME: please improve this when we get monomorphization support\n+\n+use std::mem;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ComparisonResults {\n+    lt: bool,\n+    le: bool,\n+    gt: bool,\n+    ge: bool,\n+    eq: bool,\n+    ne: bool\n+}\n+\n+const LT: ComparisonResults = ComparisonResults {\n+    lt: true,\n+    le: true,\n+    gt: false,\n+    ge: false,\n+    eq: false,\n+    ne: true\n+};\n+\n+const EQ: ComparisonResults = ComparisonResults {\n+    lt: false,\n+    le: true,\n+    gt: false,\n+    ge: true,\n+    eq: true,\n+    ne: false\n+};\n+\n+const GT: ComparisonResults = ComparisonResults {\n+    lt: false,\n+    le: false,\n+    gt: true,\n+    ge: true,\n+    eq: false,\n+    ne: true\n+};\n+\n+#[rustc_mir]\n+fn compare_su8(a: *const S<[u8]>, b: *const S<[u8]>) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir]\n+fn compare_au8(a: *const [u8], b: *const [u8]) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir(graphviz=\"comparefoo.gv\")]\n+fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir(graphviz=\"simpleeq.gv\")]\n+fn simple_eq<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> bool {\n+    let result = a == b;\n+    result\n+}\n+\n+fn assert_inorder<T: Copy>(a: &[T],\n+                           compare: fn(T, T) -> ComparisonResults) {\n+    for i in 0..a.len() {\n+        for j in 0..a.len() {\n+            let cres = compare(a[i], a[j]);\n+            if i < j {\n+                assert_eq!(cres, LT);\n+            } else if i == j {\n+                assert_eq!(cres, EQ);\n+            } else {\n+                assert_eq!(cres, GT);\n+            }\n+        }\n+    }\n+}\n+\n+trait Foo { fn foo(&self) -> usize; }\n+impl<T> Foo for T {\n+    fn foo(&self) -> usize {\n+        mem::size_of::<T>()\n+    }\n+}\n+\n+struct S<T:?Sized>(u32, T);\n+\n+fn main() {\n+    let array = [0,1,2,3,4];\n+    let array2 = [5,6,7,8,9];\n+\n+    // fat ptr comparison: addr then extra\n+\n+    // check ordering for arrays\n+    let mut ptrs: Vec<*const [u8]> = vec![\n+        &array[0..0], &array[0..1], &array, &array[1..]\n+    ];\n+\n+    let array_addr = &array as *const [u8] as *const u8 as usize;\n+    let array2_addr = &array2 as *const [u8] as *const u8 as usize;\n+    if array2_addr < array_addr {\n+        ptrs.insert(0, &array2);\n+    } else {\n+        ptrs.push(&array2);\n+    }\n+    assert_inorder(&ptrs, compare_au8);\n+\n+    let u8_ = (0u8, 1u8);\n+    let u32_ = (4u32, 5u32);\n+\n+    // check ordering for ptrs\n+    let buf: &mut [*const Foo] = &mut [\n+        &u8_, &u8_.0,\n+        &u32_, &u32_.0,\n+    ];\n+    buf.sort_by(|u,v| {\n+        let u : [*const (); 2] = unsafe { mem::transmute(*u) };\n+        let v : [*const (); 2] = unsafe { mem::transmute(*v) };\n+        u.cmp(&v)\n+    });\n+    assert_inorder(buf, compare_foo);\n+\n+    // check ordering for structs containing arrays\n+    let ss: (S<[u8; 2]>,\n+             S<[u8; 3]>,\n+             S<[u8; 2]>) = (\n+        S(7, [8, 9]),\n+        S(10, [11, 12, 13]),\n+        S(4, [5, 6])\n+    );\n+    assert_inorder(&[\n+        &ss.0 as *const S<[u8]>,\n+        &ss.1 as *const S<[u8]>,\n+        &ss.2 as *const S<[u8]>\n+            ], compare_su8);\n+\n+    assert!(simple_eq(&0u8 as *const _, &0u8 as *const _));\n+    assert!(!simple_eq(&0u8 as *const _, &1u8 as *const _));\n+}"}]}