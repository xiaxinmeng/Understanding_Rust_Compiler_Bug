{"sha": "687cc292fd681be9739dc973acd5eaa5f73a5ce7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4N2NjMjkyZmQ2ODFiZTk3MzlkYzk3M2FjZDVlYWE1ZjczYTVjZTc=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-18T03:51:20Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-18T06:29:55Z"}, "message": "Remove `array_vec.rs`.\n\n`SparseBitSet` is the only remaining user of `ArrayVec`. This commit\nswitches it to using `SmallVec`, and removes `array_vec.rs`.\n\nWhy the switch? Although `SparseBitSet` is size-limited and doesn't need\nthe ability to spill to the heap, `SmallVec` has many more features than\n`ArrayVec`. In particular, it's now possible to keep `SparseBitSet`'s\nelements in sorted order, which gives in-order iteration, which is a\nrequirement for the next commit.", "tree": {"sha": "1315287b80e6b885f3afe751365569c79c7be682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1315287b80e6b885f3afe751365569c79c7be682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/687cc292fd681be9739dc973acd5eaa5f73a5ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/687cc292fd681be9739dc973acd5eaa5f73a5ce7", "html_url": "https://github.com/rust-lang/rust/commit/687cc292fd681be9739dc973acd5eaa5f73a5ce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/687cc292fd681be9739dc973acd5eaa5f73a5ce7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c42765a5470ae7a5cce01977fd58062365733ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c42765a5470ae7a5cce01977fd58062365733ee9", "html_url": "https://github.com/rust-lang/rust/commit/c42765a5470ae7a5cce01977fd58062365733ee9"}], "stats": {"total": 343, "additions": 21, "deletions": 322}, "files": [{"sha": "45fb56570618093f556f85134daa61a450e0da69", "filename": "src/librustc_data_structures/array_vec.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/c42765a5470ae7a5cce01977fd58062365733ee9/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42765a5470ae7a5cce01977fd58062365733ee9/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=c42765a5470ae7a5cce01977fd58062365733ee9", "patch": "@@ -1,305 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A stack-allocated vector, allowing storage of N elements on the stack.\n-\n-use std::marker::Unsize;\n-use std::iter::Extend;\n-use std::ptr::{self, drop_in_place, NonNull};\n-use std::ops::{Deref, DerefMut, Range};\n-use std::hash::{Hash, Hasher};\n-use std::slice;\n-use std::fmt;\n-use std::mem;\n-use std::mem::ManuallyDrop;\n-use std::ops::Bound::{Excluded, Included, Unbounded};\n-use std::ops::RangeBounds;\n-\n-pub unsafe trait Array {\n-    type Element;\n-    type PartialStorage: Unsize<[ManuallyDrop<Self::Element>]>;\n-    const LEN: usize;\n-}\n-\n-unsafe impl<T> Array for [T; 1] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 1];\n-    const LEN: usize = 1;\n-}\n-\n-unsafe impl<T> Array for [T; 8] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 8];\n-    const LEN: usize = 8;\n-}\n-\n-unsafe impl<T> Array for [T; 32] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 32];\n-    const LEN: usize = 32;\n-}\n-\n-pub struct ArrayVec<A: Array> {\n-    count: usize,\n-    values: A::PartialStorage\n-}\n-\n-impl<A> Hash for ArrayVec<A>\n-    where A: Array,\n-          A::Element: Hash {\n-    fn hash<H>(&self, state: &mut H) where H: Hasher {\n-        (&self[..]).hash(state);\n-    }\n-}\n-\n-impl<A> Clone for ArrayVec<A>\n-    where A: Array,\n-          A::Element: Clone {\n-    fn clone(&self) -> Self {\n-        let mut v = ArrayVec::new();\n-        v.extend(self.iter().cloned());\n-        v\n-    }\n-}\n-\n-impl<A: Array> ArrayVec<A> {\n-    pub fn new() -> Self {\n-        ArrayVec {\n-            count: 0,\n-            values: unsafe { ::std::mem::uninitialized() },\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.count\n-    }\n-\n-    pub unsafe fn set_len(&mut self, len: usize) {\n-        self.count = len;\n-    }\n-\n-    /// Panics when the stack vector is full.\n-    pub fn push(&mut self, el: A::Element) {\n-        let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-        arr[self.count] = ManuallyDrop::new(el);\n-        self.count += 1;\n-    }\n-\n-    pub fn pop(&mut self) -> Option<A::Element> {\n-        if self.count > 0 {\n-            let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-            self.count -= 1;\n-            unsafe {\n-                let value = ptr::read(&*arr[self.count]);\n-                Some(value)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n-        where R: RangeBounds<usize>\n-    {\n-        // Memory safety\n-        //\n-        // When the Drain is first created, it shortens the length of\n-        // the source vector to make sure no uninitialized or moved-from elements\n-        // are accessible at all if the Drain's destructor never gets to run.\n-        //\n-        // Drain will ptr::read out the values to remove.\n-        // When finished, remaining tail of the vec is copied back to cover\n-        // the hole, and the vector length is restored to the new length.\n-        //\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded    => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded    => len,\n-        };\n-        assert!(start <= end);\n-        assert!(end <= len);\n-\n-        unsafe {\n-            // set self.vec length's to start, to be safe in case Drain is leaked\n-            self.set_len(start);\n-            // Use the borrow in the IterMut to indicate borrowing behavior of the\n-            // whole Drain iterator (like &mut T).\n-            let range_slice = {\n-                let arr = &mut self.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                slice::from_raw_parts_mut(arr.as_mut_ptr().add(start),\n-                                          end - start)\n-            };\n-            Drain {\n-                tail_start: end,\n-                tail_len: len - end,\n-                iter: range_slice.iter(),\n-                array_vec: NonNull::from(self),\n-            }\n-        }\n-    }\n-}\n-\n-impl<A> Default for ArrayVec<A>\n-    where A: Array {\n-    fn default() -> Self {\n-        ArrayVec::new()\n-    }\n-}\n-\n-impl<A> fmt::Debug for ArrayVec<A>\n-    where A: Array,\n-          A::Element: fmt::Debug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n-\n-impl<A: Array> Deref for ArrayVec<A> {\n-    type Target = [A::Element];\n-    fn deref(&self) -> &Self::Target {\n-        unsafe {\n-            slice::from_raw_parts(&self.values as *const _ as *const A::Element, self.count)\n-        }\n-    }\n-}\n-\n-impl<A: Array> DerefMut for ArrayVec<A> {\n-    fn deref_mut(&mut self) -> &mut [A::Element] {\n-        unsafe {\n-            slice::from_raw_parts_mut(&mut self.values as *mut _ as *mut A::Element, self.count)\n-        }\n-    }\n-}\n-\n-impl<A: Array> Drop for ArrayVec<A> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_in_place(&mut self[..])\n-        }\n-    }\n-}\n-\n-impl<A: Array> Extend<A::Element> for ArrayVec<A> {\n-    fn extend<I>(&mut self, iter: I) where I: IntoIterator<Item=A::Element> {\n-        for el in iter {\n-            self.push(el);\n-        }\n-    }\n-}\n-\n-pub struct Iter<A: Array> {\n-    indices: Range<usize>,\n-    store: A::PartialStorage,\n-}\n-\n-impl<A: Array> Drop for Iter<A> {\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n-impl<A: Array> Iterator for Iter<A> {\n-    type Item = A::Element;\n-\n-    fn next(&mut self) -> Option<A::Element> {\n-        let arr = &self.store as &[ManuallyDrop<_>];\n-        unsafe {\n-            self.indices.next().map(|i| ptr::read(&*arr[i]))\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.indices.size_hint()\n-    }\n-}\n-\n-pub struct Drain<'a, A: Array>\n-        where A::Element: 'a\n-{\n-    tail_start: usize,\n-    tail_len: usize,\n-    iter: slice::Iter<'a, ManuallyDrop<A::Element>>,\n-    array_vec: NonNull<ArrayVec<A>>,\n-}\n-\n-impl<'a, A: Array> Iterator for Drain<'a, A> {\n-    type Item = A::Element;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A::Element> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(&**elt) })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a, A: Array> Drop for Drain<'a, A> {\n-    fn drop(&mut self) {\n-        // exhaust self first\n-        self.for_each(drop);\n-\n-        if self.tail_len > 0 {\n-            unsafe {\n-                let source_array_vec: &mut ArrayVec<A> = self.array_vec.as_mut();\n-                // memmove back untouched tail, update to new length\n-                let start = source_array_vec.len();\n-                let tail = self.tail_start;\n-                {\n-                    let arr =\n-                        &mut source_array_vec.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                    let src = arr.as_ptr().add(tail);\n-                    let dst = arr.as_mut_ptr().add(start);\n-                    ptr::copy(src, dst, self.tail_len);\n-                };\n-                source_array_vec.set_len(start + self.tail_len);\n-            }\n-        }\n-    }\n-}\n-\n-impl<A: Array> IntoIterator for ArrayVec<A> {\n-    type Item = A::Element;\n-    type IntoIter = Iter<A>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        let store = unsafe {\n-            ptr::read(&self.values)\n-        };\n-        let indices = 0..self.count;\n-        mem::forget(self);\n-        Iter {\n-            indices,\n-            store,\n-        }\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a ArrayVec<A> {\n-    type Item = &'a A::Element;\n-    type IntoIter = slice::Iter<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n-    type Item = &'a mut A::Element;\n-    type IntoIter = slice::IterMut<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter_mut()\n-    }\n-}"}, {"sha": "d9e928559322d98212afa04c49fd02dccdd80f07", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/687cc292fd681be9739dc973acd5eaa5f73a5ce7/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687cc292fd681be9739dc973acd5eaa5f73a5ce7/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=687cc292fd681be9739dc973acd5eaa5f73a5ce7", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use array_vec::ArrayVec;\n use indexed_vec::{Idx, IndexVec};\n use rustc_serialize;\n+use smallvec::SmallVec;\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n@@ -320,16 +320,17 @@ fn bitwise<Op>(out_vec: &mut [Word], in_vec: &[Word], op: Op) -> bool\n const SPARSE_MAX: usize = 8;\n \n /// A fixed-size bitset type with a sparse representation and a maximum of\n-/// SPARSE_MAX elements. The elements are stored as an unsorted vector with no\n-/// duplicates.\n+/// `SPARSE_MAX` elements. The elements are stored as a sorted `SmallVec` with\n+/// no duplicates; although `SmallVec` can spill its elements to the heap, that\n+/// never happens within this type because of the `SPARSE_MAX` limit.\n ///\n-/// This type is used by HybridBitSet; do not use directly.\n+/// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+pub struct SparseBitSet<T: Idx>(SmallVec<[T; SPARSE_MAX]>);\n \n impl<T: Idx> SparseBitSet<T> {\n     fn new_empty() -> Self {\n-        SparseBitSet(ArrayVec::new())\n+        SparseBitSet(SmallVec::new())\n     }\n \n     fn len(&self) -> usize {\n@@ -341,21 +342,26 @@ impl<T: Idx> SparseBitSet<T> {\n     }\n \n     fn insert(&mut self, elem: T) -> bool {\n-        // Ensure there are no duplicates.\n-        if self.0.contains(&elem) {\n-            false\n+        assert!(self.len() < SPARSE_MAX);\n+        if let Some(i) = self.0.iter().position(|&e| e >= elem) {\n+            if self.0[i] == elem {\n+                // `elem` is already in the set.\n+                false\n+            } else {\n+                // `elem` is smaller than one or more existing elements.\n+                self.0.insert(i, elem);\n+                true\n+            }\n         } else {\n+            // `elem` is larger than all existing elements.\n             self.0.push(elem);\n             true\n         }\n     }\n \n     fn remove(&mut self, elem: T) -> bool {\n         if let Some(i) = self.0.iter().position(|&e| e == elem) {\n-            // Swap the found element to the end, then pop it.\n-            let len = self.0.len();\n-            self.0.swap(i, len - 1);\n-            self.0.pop();\n+            self.0.remove(i);\n             true\n         } else {\n             false\n@@ -396,8 +402,8 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n }\n \n /// A fixed-size bitset type with a hybrid representation: sparse when there\n-/// are up to a SPARSE_MAX elements in the set, but dense when there are more\n-/// than SPARSE_MAX.\n+/// are up to a `SPARSE_MAX` elements in the set, but dense when there are more\n+/// than `SPARSE_MAX`.\n ///\n /// This type is especially efficient for sets that typically have a small\n /// number of elements, but a large `domain_size`, and are cleared frequently.\n@@ -479,7 +485,6 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n-    /// Iteration order is unspecified.\n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n             HybridBitSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),"}, {"sha": "70b960ac351c0031069b153b00cff8cedfb5402d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/687cc292fd681be9739dc973acd5eaa5f73a5ce7/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687cc292fd681be9739dc973acd5eaa5f73a5ce7/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=687cc292fd681be9739dc973acd5eaa5f73a5ce7", "patch": "@@ -60,7 +60,6 @@ extern crate rustc_cratesio_shim;\n pub use rustc_serialize::hex::ToHex;\n \n pub mod svh;\n-pub mod array_vec;\n pub mod base_n;\n pub mod bit_set;\n pub mod const_cstr;"}]}