{"sha": "3df383aa3cc803ef000796b9221b084ffb1bd68a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZjM4M2FhM2NjODAzZWYwMDA3OTZiOTIyMWIwODRmZmIxYmQ2OGE=", "commit": {"author": {"name": "Adam H. Leventhal", "email": "ahl@oxide.computer", "date": "2020-04-22T05:57:54Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2020-11-29T19:26:58Z"}, "message": "fixes #4115, #4029, #3898", "tree": {"sha": "6564cf7d0eef6278ebcdd35cb4aa15bd8629d080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6564cf7d0eef6278ebcdd35cb4aa15bd8629d080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3df383aa3cc803ef000796b9221b084ffb1bd68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3df383aa3cc803ef000796b9221b084ffb1bd68a", "html_url": "https://github.com/rust-lang/rust/commit/3df383aa3cc803ef000796b9221b084ffb1bd68a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3df383aa3cc803ef000796b9221b084ffb1bd68a/comments", "author": {"login": "ahl", "id": 677483, "node_id": "MDQ6VXNlcjY3NzQ4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/677483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahl", "html_url": "https://github.com/ahl", "followers_url": "https://api.github.com/users/ahl/followers", "following_url": "https://api.github.com/users/ahl/following{/other_user}", "gists_url": "https://api.github.com/users/ahl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahl/subscriptions", "organizations_url": "https://api.github.com/users/ahl/orgs", "repos_url": "https://api.github.com/users/ahl/repos", "events_url": "https://api.github.com/users/ahl/events{/privacy}", "received_events_url": "https://api.github.com/users/ahl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c77c6a405d9584a8b3b2d7b18bd9153d19ddb6ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77c6a405d9584a8b3b2d7b18bd9153d19ddb6ff", "html_url": "https://github.com/rust-lang/rust/commit/c77c6a405d9584a8b3b2d7b18bd9153d19ddb6ff"}], "stats": {"total": 184, "additions": 91, "deletions": 93}, "files": [{"sha": "9f77941e5518c279d269bbeedb1e19a7242caba2", "filename": "src/attr.rs", "status": "modified", "additions": 91, "deletions": 93, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/3df383aa3cc803ef000796b9221b084ffb1bd68a/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df383aa3cc803ef000796b9221b084ffb1bd68a/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=3df383aa3cc803ef000796b9221b084ffb1bd68a", "patch": "@@ -63,15 +63,6 @@ fn is_derive(attr: &ast::Attribute) -> bool {\n     attr.has_name(sym::derive)\n }\n \n-/// Returns the arguments of `#[derive(...)]`.\n-fn get_derive_spans<'a>(attr: &'a ast::Attribute) -> Option<impl Iterator<Item = Span> + 'a> {\n-    attr.meta_item_list().map(|meta_item_list| {\n-        meta_item_list\n-            .into_iter()\n-            .map(|nested_meta_item| nested_meta_item.span())\n-    })\n-}\n-\n // The shape of the arguments to a function-like attribute.\n fn argument_shape(\n     left: usize,\n@@ -100,36 +91,104 @@ fn argument_shape(\n }\n \n fn format_derive(\n-    derive_args: &[Span],\n-    prefix: &str,\n+    derives: &[ast::Attribute],\n     shape: Shape,\n     context: &RewriteContext<'_>,\n ) -> Option<String> {\n-    let mut result = String::with_capacity(128);\n-    result.push_str(prefix);\n-    result.push_str(\"[derive(\");\n-\n-    let argument_shape = argument_shape(10 + prefix.len(), 2, false, shape, context)?;\n-    let item_str = format_arg_list(\n-        derive_args.iter(),\n-        |_| DUMMY_SP.lo(),\n-        |_| DUMMY_SP.hi(),\n-        |sp| Some(context.snippet(**sp).to_owned()),\n-        DUMMY_SP,\n-        context,\n-        argument_shape,\n-        // 10 = \"[derive()]\", 3 = \"()\" and \"]\"\n-        shape.offset_left(10 + prefix.len())?.sub_width(3)?,\n-        None,\n+    // Collect all items from all attributes\n+    let all_items = derives\n+        .iter()\n+        .map(|attr| {\n+            // Parse the derive items and extract the span for each item; if any\n+            // attribute is not parseable, none of the attributes will be\n+            // reformatted.\n+            let item_spans = attr.meta_item_list().map(|meta_item_list| {\n+                meta_item_list\n+                    .into_iter()\n+                    .map(|nested_meta_item| nested_meta_item.span())\n+            })?;\n+\n+            let items = itemize_list(\n+                context.snippet_provider,\n+                item_spans,\n+                \")\",\n+                \",\",\n+                |span| span.lo(),\n+                |span| span.hi(),\n+                |span| Some(context.snippet(*span).to_owned()),\n+                attr.span.lo(),\n+                attr.span.hi(),\n+                false,\n+            );\n+\n+            Some(items)\n+        })\n+        // Fail if any attribute failed.\n+        .collect::<Option<Vec<_>>>()?\n+        // Collect the results into a single, flat, Vec.\n+        .into_iter()\n+        .flatten()\n+        .collect::<Vec<_>>();\n+\n+    // Collect formatting parameters.\n+    let prefix = attr_prefix(&derives[0]);\n+    let argument_shape = argument_shape(\n+        \"[derive()]\".len() + prefix.len(),\n+        \")]\".len(),\n         false,\n+        shape,\n+        context,\n     )?;\n+    let one_line_shape = shape\n+        .offset_left(\"[derive()]\".len() + prefix.len())?\n+        .sub_width(\"()]\".len())?;\n+    let one_line_budget = one_line_shape.width;\n \n-    result.push_str(&item_str);\n-    if item_str.starts_with('\\n') {\n-        result.push(',');\n+    let tactic = definitive_tactic(\n+        &all_items,\n+        ListTactic::HorizontalVertical,\n+        Separator::Comma,\n+        argument_shape.width,\n+    );\n+    let trailing_separator = match context.config.indent_style() {\n+        // We always add the trailing comma and remove it if it is not needed.\n+        IndentStyle::Block => SeparatorTactic::Always,\n+        IndentStyle::Visual => SeparatorTactic::Never,\n+    };\n+\n+    // Format the collection of items.\n+    let fmt = ListFormatting::new(argument_shape, context.config)\n+        .tactic(tactic)\n+        .trailing_separator(trailing_separator)\n+        .ends_with_newline(false);\n+    let item_str = write_list(&all_items, &fmt)?;\n+\n+    debug!(\"item_str: '{}'\", item_str);\n+\n+    // Determine if the result will be nested, i.e. if we're using the block\n+    // indent style and either the items are on multiple lines or we've exceeded\n+    // our budget to fit on a single line.\n+    let nested = context.config.indent_style() == IndentStyle::Block\n+        && (item_str.contains('\\n') || item_str.len() > one_line_budget);\n+\n+    // Format the final result.\n+    let mut result = String::with_capacity(128);\n+    result.push_str(prefix);\n+    result.push_str(\"[derive(\");\n+    if nested {\n+        let nested_indent = argument_shape.indent.to_string_with_newline(context.config);\n+        result.push_str(&nested_indent);\n+        result.push_str(&item_str);\n         result.push_str(&shape.indent.to_string_with_newline(context.config));\n+    } else if let SeparatorTactic::Always = context.config.trailing_comma() {\n+        // Retain the trailing comma.\n+        result.push_str(&item_str);\n+    } else {\n+        // Remove the trailing comma.\n+        result.push_str(&item_str[..item_str.len() - 1]);\n     }\n     result.push_str(\")]\");\n+\n     Some(result)\n }\n \n@@ -255,7 +314,7 @@ impl Rewrite for ast::MetaItem {\n                 // width. Since a literal is basically unformattable unless it\n                 // is a string literal (and only if `format_strings` is set),\n                 // we might be better off ignoring the fact that the attribute\n-                // is longer than the max width and contiue on formatting.\n+                // is longer than the max width and continue on formatting.\n                 // See #2479 for example.\n                 let value = rewrite_literal(context, literal, lit_shape)\n                     .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n@@ -265,61 +324,6 @@ impl Rewrite for ast::MetaItem {\n     }\n }\n \n-fn format_arg_list<I, T, F1, F2, F3>(\n-    list: I,\n-    get_lo: F1,\n-    get_hi: F2,\n-    get_item_string: F3,\n-    span: Span,\n-    context: &RewriteContext<'_>,\n-    shape: Shape,\n-    one_line_shape: Shape,\n-    one_line_limit: Option<usize>,\n-    combine: bool,\n-) -> Option<String>\n-where\n-    I: Iterator<Item = T>,\n-    F1: Fn(&T) -> BytePos,\n-    F2: Fn(&T) -> BytePos,\n-    F3: Fn(&T) -> Option<String>,\n-{\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        list,\n-        \")\",\n-        \",\",\n-        get_lo,\n-        get_hi,\n-        get_item_string,\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    );\n-    let item_vec = items.collect::<Vec<_>>();\n-    let tactic = if let Some(limit) = one_line_limit {\n-        ListTactic::LimitedHorizontalVertical(limit)\n-    } else {\n-        ListTactic::HorizontalVertical\n-    };\n-\n-    let tactic = definitive_tactic(&item_vec, tactic, Separator::Comma, shape.width);\n-    let fmt = ListFormatting::new(shape, context.config)\n-        .tactic(tactic)\n-        .ends_with_newline(false);\n-    let item_str = write_list(&item_vec, &fmt)?;\n-\n-    let one_line_budget = one_line_shape.width;\n-    if context.config.indent_style() == IndentStyle::Visual\n-        || combine\n-        || (!item_str.contains('\\n') && item_str.len() <= one_line_budget)\n-    {\n-        Some(item_str)\n-    } else {\n-        let nested_indent = shape.indent.to_string_with_newline(context.config);\n-        Some(format!(\"{}{}\", nested_indent, item_str))\n-    }\n-}\n-\n impl Rewrite for ast::Attribute {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let snippet = context.snippet(self.span);\n@@ -424,13 +428,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n             // Handle derives if we will merge them.\n             if context.config.merge_derives() && is_derive(&attrs[0]) {\n                 let derives = take_while_with_pred(context, attrs, is_derive);\n-                let derive_spans: Vec<_> = derives\n-                    .iter()\n-                    .filter_map(get_derive_spans)\n-                    .flatten()\n-                    .collect();\n-                let derive_str =\n-                    format_derive(&derive_spans, attr_prefix(&attrs[0]), shape, context)?;\n+                let derive_str = format_derive(derives, shape, context)?;\n                 result.push_str(&derive_str);\n \n                 let missing_span = attrs"}]}