{"sha": "682ef4db8060a0b26266cdcf5631c5776cd45e0a", "node_id": "C_kwDOAAsO6NoAKDY4MmVmNGRiODA2MGEwYjI2MjY2Y2RjZjU2MzFjNTc3NmNkNDVlMGE", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-01-13T14:50:11Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-01-20T21:05:25Z"}, "message": "Exclude \"test\" from doc_auto_cfg rendering", "tree": {"sha": "9f529b6b110b51a1adfd2e8d47c8e038c9bf23bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f529b6b110b51a1adfd2e8d47c8e038c9bf23bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/682ef4db8060a0b26266cdcf5631c5776cd45e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/682ef4db8060a0b26266cdcf5631c5776cd45e0a", "html_url": "https://github.com/rust-lang/rust/commit/682ef4db8060a0b26266cdcf5631c5776cd45e0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/682ef4db8060a0b26266cdcf5631c5776cd45e0a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fbbefea8d13683cca5eee62e4740706cb3144a", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fbbefea8d13683cca5eee62e4740706cb3144a", "html_url": "https://github.com/rust-lang/rust/commit/74fbbefea8d13683cca5eee62e4740706cb3144a"}], "stats": {"total": 66, "additions": 50, "deletions": 16}, "files": [{"sha": "2c1dcad1afc6d5471fb8a0af30ca916ad19439fe", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/682ef4db8060a0b26266cdcf5631c5776cd45e0a/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/682ef4db8060a0b26266cdcf5631c5776cd45e0a/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=682ef4db8060a0b26266cdcf5631c5776cd45e0a", "patch": "@@ -43,23 +43,22 @@ crate struct InvalidCfgError {\n \n impl Cfg {\n     /// Parses a `NestedMetaItem` into a `Cfg`.\n-    fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n+    fn parse_nested(\n+        nested_cfg: &NestedMetaItem,\n+        exclude: &[Symbol],\n+    ) -> Result<Option<Cfg>, InvalidCfgError> {\n         match nested_cfg {\n-            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse_without(cfg, exclude),\n             NestedMetaItem::Literal(ref lit) => {\n                 Err(InvalidCfgError { msg: \"unexpected literal\", span: lit.span })\n             }\n         }\n     }\n \n-    /// Parses a `MetaItem` into a `Cfg`.\n-    ///\n-    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g., `unix` or\n-    /// `target_os = \"redox\"`.\n-    ///\n-    /// If the content is not properly formatted, it will return an error indicating what and where\n-    /// the error is.\n-    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    crate fn parse_without(\n+        cfg: &MetaItem,\n+        exclude: &[Symbol],\n+    ) -> Result<Option<Cfg>, InvalidCfgError> {\n         let name = match cfg.ident() {\n             Some(ident) => ident.name,\n             None => {\n@@ -70,9 +69,21 @@ impl Cfg {\n             }\n         };\n         match cfg.kind {\n-            MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n+            MetaItemKind::Word => {\n+                if exclude.contains(&name) {\n+                    Ok(None)\n+                } else {\n+                    Ok(Some(Cfg::Cfg(name, None)))\n+                }\n+            }\n             MetaItemKind::NameValue(ref lit) => match lit.kind {\n-                LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n+                LitKind::Str(value, _) => {\n+                    if exclude.contains(&name) {\n+                        Ok(None)\n+                    } else {\n+                        Ok(Some(Cfg::Cfg(name, Some(value))))\n+                    }\n+                }\n                 _ => Err(InvalidCfgError {\n                     // FIXME: if the main #[cfg] syntax decided to support non-string literals,\n                     // this should be changed as well.\n@@ -81,23 +92,43 @@ impl Cfg {\n                 }),\n             },\n             MetaItemKind::List(ref items) => {\n-                let mut sub_cfgs = items.iter().map(Cfg::parse_nested);\n-                match name {\n+                let sub_cfgs = items.iter().filter_map(|i| match Cfg::parse_nested(i, exclude) {\n+                    Ok(Some(c)) => Some(Ok(c)),\n+                    Err(e) => Some(Err(e)),\n+                    _ => None,\n+                });\n+                let ret = match name {\n                     sym::all => sub_cfgs.fold(Ok(Cfg::True), |x, y| Ok(x? & y?)),\n                     sym::any => sub_cfgs.fold(Ok(Cfg::False), |x, y| Ok(x? | y?)),\n                     sym::not => {\n+                        let mut sub_cfgs = sub_cfgs.collect::<Vec<_>>();\n                         if sub_cfgs.len() == 1 {\n-                            Ok(!sub_cfgs.next().unwrap()?)\n+                            Ok(!sub_cfgs.pop().unwrap()?)\n                         } else {\n                             Err(InvalidCfgError { msg: \"expected 1 cfg-pattern\", span: cfg.span })\n                         }\n                     }\n                     _ => Err(InvalidCfgError { msg: \"invalid predicate\", span: cfg.span }),\n+                };\n+                match ret {\n+                    Ok(c) => Ok(Some(c)),\n+                    Err(e) => Err(e),\n                 }\n             }\n         }\n     }\n \n+    /// Parses a `MetaItem` into a `Cfg`.\n+    ///\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g., `unix` or\n+    /// `target_os = \"redox\"`.\n+    ///\n+    /// If the content is not properly formatted, it will return an error indicating what and where\n+    /// the error is.\n+    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+        Self::parse_without(cfg, &[]).map(|ret| ret.unwrap())\n+    }\n+\n     /// Checks whether the given configuration can be matched in the current session.\n     ///\n     /// Equivalent to `attr::cfg_matches`."}, {"sha": "347f9d0a47cb76c1e25f8791ed0b8f8588f63baa", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/682ef4db8060a0b26266cdcf5631c5776cd45e0a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/682ef4db8060a0b26266cdcf5631c5776cd45e0a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=682ef4db8060a0b26266cdcf5631c5776cd45e0a", "patch": "@@ -831,7 +831,10 @@ impl AttributesExt for [ast::Attribute] {\n                 self.iter()\n                     .filter(|attr| attr.has_name(sym::cfg))\n                     .filter_map(|attr| single(attr.meta_item_list()?))\n-                    .filter_map(|attr| Cfg::parse(attr.meta_item()?).ok())\n+                    .filter_map(|attr| match Cfg::parse_without(attr.meta_item()?, &[sym::test]) {\n+                        Ok(Some(c)) => Some(c),\n+                        _ => None,\n+                    })\n                     .filter(|cfg| !hidden_cfg.contains(cfg))\n                     .fold(Cfg::True, |cfg, new_cfg| cfg & new_cfg)\n             } else {"}]}