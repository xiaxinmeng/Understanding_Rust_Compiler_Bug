{"sha": "deb6476b2921bde505125042b1624efe05e7c3ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYjY0NzZiMjkyMWJkZTUwNTEyNTA0MmIxNjI0ZWZlMDVlN2MzZmY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-12T19:00:07Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-13T01:16:00Z"}, "message": "Use unsafe pointers for recv_packet::header, because the region system is hard and this isn't safe anyway.", "tree": {"sha": "b4ae3f0b87b702682dc20f35fe8fed4eb739ac9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4ae3f0b87b702682dc20f35fe8fed4eb739ac9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deb6476b2921bde505125042b1624efe05e7c3ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deb6476b2921bde505125042b1624efe05e7c3ff", "html_url": "https://github.com/rust-lang/rust/commit/deb6476b2921bde505125042b1624efe05e7c3ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deb6476b2921bde505125042b1624efe05e7c3ff/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aba665da32708017c2fcbe7f922eb087a8dbe3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/aba665da32708017c2fcbe7f922eb087a8dbe3b1", "html_url": "https://github.com/rust-lang/rust/commit/aba665da32708017c2fcbe7f922eb087a8dbe3b1"}], "stats": {"total": 30, "additions": 17, "deletions": 13}, "files": [{"sha": "da11e77339af7ece27c9cf2c2b4b9c28e118ad4d", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/deb6476b2921bde505125042b1624efe05e7c3ff/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deb6476b2921bde505125042b1624efe05e7c3ff/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=deb6476b2921bde505125042b1624efe05e7c3ff", "patch": "@@ -169,7 +169,7 @@ fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n \n /// Returns true if messages are available.\n pure fn peek<T: send>(p: recv_packet<T>) -> bool {\n-    alt p.header().state {\n+    alt unsafe {(*p.header()).state} {\n       empty { false }\n       blocked { fail \"peeking on blocked packet\" }\n       full | terminated { true }\n@@ -219,14 +219,16 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n     }\n }\n \n-impl private_methods for packet_header {\n+impl private_methods for *packet_header {\n     // Returns the old state.\n-    fn mark_blocked(this: *rust_task) -> state {\n+    unsafe fn mark_blocked(this: *rust_task) -> state {\n+        let self = &*self;\n         self.blocked_task = some(this);\n         swap_state_acq(self.state, blocked)\n     }\n \n-    fn unblock() {\n+    unsafe fn unblock() {\n+        let self = &*self;\n         alt swap_state_acq(self.state, empty) {\n           empty | blocked { }\n           terminated { self.state = terminated; }\n@@ -237,19 +239,19 @@ impl private_methods for packet_header {\n \n #[doc = \"Returns when one of the packet headers reports data is\n available.\"]\n-fn wait_many(pkts: &[&a.packet_header]) -> uint {\n+fn wait_many(pkts: &[*packet_header]) -> uint {\n     let this = rustrt::rust_get_task();\n \n     rustrt::task_clear_event_reject(this);\n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    for pkts.eachi |i, p| {\n+    for pkts.eachi |i, p| unsafe {\n         let old = p.mark_blocked(this);\n         alt old {\n           full | terminated {\n             data_avail = true;\n             ready_packet = i;\n-            p.state = old;\n+            (*p).state = old;\n             break;\n           }\n           blocked { fail \"blocking on blocked packet\" }\n@@ -260,7 +262,7 @@ fn wait_many(pkts: &[&a.packet_header]) -> uint {\n     while !data_avail {\n         #debug(\"sleeping on %? packets\", pkts.len());\n         let event = wait_event(this) as *packet_header;\n-        let pos = vec::position(pkts, |p| ptr::addr_of(*p) == event);\n+        let pos = vec::position(pkts, |p| p == event);\n \n         alt pos {\n           some(i) {\n@@ -275,12 +277,14 @@ fn wait_many(pkts: &[&a.packet_header]) -> uint {\n \n     #debug(\"%?\", pkts[ready_packet]);\n \n-    for pkts.each |p| { p.unblock() }\n+    for pkts.each |p| { unsafe{p.unblock()} }\n \n     #debug(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n-    assert pkts[ready_packet].state == full\n-        || pkts[ready_packet].state == terminated;\n+    unsafe {\n+        assert (*pkts[ready_packet]).state == full\n+            || (*pkts[ready_packet]).state == terminated;\n+    }\n \n     ready_packet\n }\n@@ -370,12 +374,12 @@ class recv_packet<T: send> {\n         option::unwrap(p)\n     }\n \n-    pure fn header() -> &self.packet_header {\n+    pure fn header() -> *packet_header {\n         alt self.p {\n           some(packet) {\n             unsafe {\n                 let packet = uniquify(packet);\n-                let header = reinterpret_cast(&packet.header);\n+                let header = ptr::addr_of(packet.header);\n                 forget(packet);\n                 header\n             }"}]}