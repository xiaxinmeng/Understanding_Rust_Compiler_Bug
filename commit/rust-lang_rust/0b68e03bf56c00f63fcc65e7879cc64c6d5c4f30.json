{"sha": "0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNjhlMDNiZjU2YzAwZjYzZmNjNjVlNzg3OWNjNjRjNmQ1YzRmMzA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-30T11:10:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-30T11:10:20Z"}, "message": "Merge #8256\n\n8256: Item movers improvements r=ivan770 a=ivan770\n\nCloses #8236\n\nCo-authored-by: ivan770 <leshenko.ivan770@gmail.com>", "tree": {"sha": "7315bbd5fc4e27b40d6f677627e5f66e83ef67dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7315bbd5fc4e27b40d6f677627e5f66e83ef67dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgYwccCRBK7hj4Ov3rIwAAdHIIACX6rOmwk5mPCDYSmQ2rHlXO\nu5O+wqglXR+baf18sFyKg0kufCvyw3X9ghQLm3yiWC5cBWpjSZiSpSQS23AeXuLB\ndD9BvvFYIPFbcz5nkIGN4ek0GUZzSxvfzsYkDgLFZNyfW2JPR2vGexs0xfw6g45Y\nqXAKqFaeCAn+MGWuvnpxCJhiwwKJKiutdNIYuca5p1xssRGaXlOK8w8fZF1j6a1l\nJFIv3HItSZ02J1UDrNphNUDS7AKDbvB2FqzjtlMBxgpJas0HIkq/wDchkBYzsSlB\naNVSAGRXJvu3fccwgKAOOulLTq5nyYB9XCkeliguTZCKE2SYEHQMWryAEipbYDI=\n=fpck\n-----END PGP SIGNATURE-----\n", "payload": "tree 7315bbd5fc4e27b40d6f677627e5f66e83ef67dc\nparent 563464bfaeec9e39de52cd12c435c299fe544b71\nparent 4fcba8b1bf1b94839902c0803501163b7628b33d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617102620 +0000\ncommitter GitHub <noreply@github.com> 1617102620 +0000\n\nMerge #8256\n\n8256: Item movers improvements r=ivan770 a=ivan770\n\nCloses #8236\n\nCo-authored-by: ivan770 <leshenko.ivan770@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "html_url": "https://github.com/rust-lang/rust/commit/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "563464bfaeec9e39de52cd12c435c299fe544b71", "url": "https://api.github.com/repos/rust-lang/rust/commits/563464bfaeec9e39de52cd12c435c299fe544b71", "html_url": "https://github.com/rust-lang/rust/commit/563464bfaeec9e39de52cd12c435c299fe544b71"}, {"sha": "4fcba8b1bf1b94839902c0803501163b7628b33d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fcba8b1bf1b94839902c0803501163b7628b33d", "html_url": "https://github.com/rust-lang/rust/commit/4fcba8b1bf1b94839902c0803501163b7628b33d"}], "stats": {"total": 269, "additions": 256, "deletions": 13}, "files": [{"sha": "02a1a5b37f943db831029d98959cfba7ad20013c", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "patch": "@@ -470,6 +470,7 @@ fn find_std_module(famous_defs: &FamousDefs, name: &str) -> Option<hir::Module>\n \n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n+\n     fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n             IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,"}, {"sha": "d36dcd4e4f9ef8fd355eff9b947015fa19609a66", "filename": "crates/ide/src/move_item.rs", "status": "modified", "additions": 255, "deletions": 13, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30/crates%2Fide%2Fsrc%2Fmove_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30/crates%2Fide%2Fsrc%2Fmove_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmove_item.rs?ref=0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "patch": "@@ -4,10 +4,12 @@ use hir::Semantics;\n use ide_db::{base_db::FileRange, RootDatabase};\n use itertools::Itertools;\n use syntax::{\n-    algo, ast, match_ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n+    algo, ast, match_ast, AstNode, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,\n+    TokenAtOffset,\n };\n use text_edit::{TextEdit, TextEditBuilder};\n \n+#[derive(Copy, Clone, Debug)]\n pub enum Direction {\n     Up,\n     Down,\n@@ -31,14 +33,19 @@ pub(crate) fn move_item(\n     let sema = Semantics::new(db);\n     let file = sema.parse(range.file_id);\n \n-    let item = file.syntax().covering_element(range.range);\n+    let item = if range.range.is_empty() {\n+        SyntaxElement::Token(pick_best(file.syntax().token_at_offset(range.range.start()))?)\n+    } else {\n+        file.syntax().covering_element(range.range)\n+    };\n+\n     find_ancestors(item, direction, range.range)\n }\n \n fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -> Option<TextEdit> {\n     let root = match item {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent()?,\n+        SyntaxElement::Node(node) => node,\n+        SyntaxElement::Token(token) => token.parent()?,\n     };\n \n     let movable = [\n@@ -51,6 +58,11 @@ fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -\n         SyntaxKind::PARAM,\n         SyntaxKind::LET_STMT,\n         SyntaxKind::EXPR_STMT,\n+        SyntaxKind::IF_EXPR,\n+        SyntaxKind::FOR_EXPR,\n+        SyntaxKind::LOOP_EXPR,\n+        SyntaxKind::WHILE_EXPR,\n+        SyntaxKind::RETURN_EXPR,\n         SyntaxKind::MATCH_EXPR,\n         SyntaxKind::MACRO_CALL,\n         SyntaxKind::TYPE_ALIAS,\n@@ -83,11 +95,11 @@ fn move_in_direction(\n ) -> Option<TextEdit> {\n     match_ast! {\n         match node {\n-            ast::ArgList(it) => swap_sibling_in_list(it.args(), range, direction),\n-            ast::GenericParamList(it) => swap_sibling_in_list(it.generic_params(), range, direction),\n-            ast::GenericArgList(it) => swap_sibling_in_list(it.generic_args(), range, direction),\n-            ast::VariantList(it) => swap_sibling_in_list(it.variants(), range, direction),\n-            ast::TypeBoundList(it) => swap_sibling_in_list(it.bounds(), range, direction),\n+            ast::ArgList(it) => swap_sibling_in_list(node, it.args(), range, direction),\n+            ast::GenericParamList(it) => swap_sibling_in_list(node, it.generic_params(), range, direction),\n+            ast::GenericArgList(it) => swap_sibling_in_list(node, it.generic_args(), range, direction),\n+            ast::VariantList(it) => swap_sibling_in_list(node, it.variants(), range, direction),\n+            ast::TypeBoundList(it) => swap_sibling_in_list(node, it.bounds(), range, direction),\n             _ => Some(replace_nodes(node, &match direction {\n                 Direction::Up => node.prev_sibling(),\n                 Direction::Down => node.next_sibling(),\n@@ -97,19 +109,27 @@ fn move_in_direction(\n }\n \n fn swap_sibling_in_list<A: AstNode + Clone, I: Iterator<Item = A>>(\n+    node: &SyntaxNode,\n     list: I,\n     range: TextRange,\n     direction: Direction,\n ) -> Option<TextEdit> {\n-    let (l, r) = list\n+    let list_lookup = list\n         .tuple_windows()\n         .filter(|(l, r)| match direction {\n             Direction::Up => r.syntax().text_range().contains_range(range),\n             Direction::Down => l.syntax().text_range().contains_range(range),\n         })\n-        .next()?;\n-\n-    Some(replace_nodes(l.syntax(), r.syntax()))\n+        .next();\n+\n+    if let Some((l, r)) = list_lookup {\n+        Some(replace_nodes(l.syntax(), r.syntax()))\n+    } else {\n+        // Cursor is beyond any movable list item (for example, on curly brace in enum).\n+        // It's not necessary, that parent of list is movable (arg list's parent is not, for example),\n+        // and we have to continue tree traversal to find suitable node.\n+        find_ancestors(SyntaxElement::Node(node.parent()?), direction, range)\n+    }\n }\n \n fn replace_nodes(first: &SyntaxNode, second: &SyntaxNode) -> TextEdit {\n@@ -121,6 +141,18 @@ fn replace_nodes(first: &SyntaxNode, second: &SyntaxNode) -> TextEdit {\n     edit.finish()\n }\n \n+fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n+    return tokens.max_by_key(priority);\n+\n+    fn priority(n: &SyntaxToken) -> usize {\n+        match n.kind() {\n+            SyntaxKind::IDENT | SyntaxKind::LIFETIME_IDENT => 2,\n+            kind if kind.is_trivia() => 0,\n+            _ => 1,\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::fixture;\n@@ -260,6 +292,107 @@ fn main() {\n             expect![[r#\"\n fn main() {\n     println!(\"All I want to say is...\");\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    if true {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    if true {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    for i in 0..10 {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    for i in 0..10 {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    loop {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    loop {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    while true {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    while true {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    return 123;$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    return 123;\n+\n     println!(\"Hello, world\");\n }\n             \"#]],\n@@ -614,6 +747,115 @@ fn test() {\n         );\n     }\n \n+    #[test]\n+    fn test_cursor_at_item_start() {\n+        check(\n+            r#\"\n+$0$0#[derive(Debug)]\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+#[derive(Debug)]\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+$0$0enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+struct Test;\n+\n+trait SomeTrait {}\n+\n+$0$0impl SomeTrait for Test {}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+struct Test;\n+\n+impl SomeTrait for Test {}\n+\n+trait SomeTrait {}\n+\n+fn main() {}\n+            \"#]],\n+            Direction::Up,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cursor_at_item_end() {\n+        check(\n+            r#\"\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}$0$0\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+struct Test;\n+\n+trait SomeTrait {}\n+\n+impl SomeTrait for Test {}$0$0\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+struct Test;\n+\n+impl SomeTrait for Test {}\n+\n+trait SomeTrait {}\n+\n+fn main() {}\n+            \"#]],\n+            Direction::Up,\n+        );\n+    }\n+\n     #[test]\n     fn handles_empty_file() {\n         check(r#\"$0$0\"#, expect![[r#\"\"#]], Direction::Up);"}]}