{"sha": "e02d1eb1717fee3c513baa0cb5fc39b8fa630335", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMmQxZWIxNzE3ZmVlM2M1MTNiYWEwY2I1ZmMzOWI4ZmE2MzAzMzU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-18T19:32:35Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-27T05:20:40Z"}, "message": "std: Micro-optimize vec.with_c_str for short vectors\n\nThis now makes it unsafe to save the pointer returned by .with_c_str\nas that pointer now may be pointing at a stack allocated array.\n\nI arbitrarily chose 32 bytes as the length of the stack vector, and\nso it might not be the most optimal size.\n\nbefore:\n\ntest c_str::bench::bench_with_c_str_long ... bench: 539 ns/iter (+/- 91)\ntest c_str::bench::bench_with_c_str_medium ... bench: 97 ns/iter (+/- 2)\ntest c_str::bench::bench_with_c_str_short ... bench: 70 ns/iter (+/- 5)\n\nafter:\n\ntest c_str::bench::bench_with_c_str_long ... bench: 542 ns/iter (+/- 13)\ntest c_str::bench::bench_with_c_str_medium ... bench: 53 ns/iter (+/- 6)\ntest c_str::bench::bench_with_c_str_short ... bench: 19 ns/iter (+/- 0)", "tree": {"sha": "6f21aca82d147d6fba8dbb2000d5acabeefdf923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f21aca82d147d6fba8dbb2000d5acabeefdf923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02d1eb1717fee3c513baa0cb5fc39b8fa630335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02d1eb1717fee3c513baa0cb5fc39b8fa630335", "html_url": "https://github.com/rust-lang/rust/commit/e02d1eb1717fee3c513baa0cb5fc39b8fa630335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02d1eb1717fee3c513baa0cb5fc39b8fa630335/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410a96cc79df4fbb3c2f30bdb2682b867df41a7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/410a96cc79df4fbb3c2f30bdb2682b867df41a7e", "html_url": "https://github.com/rust-lang/rust/commit/410a96cc79df4fbb3c2f30bdb2682b867df41a7e"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "8b5b780012bca81a49cb7a5b08dafec443f6efc8", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e02d1eb1717fee3c513baa0cb5fc39b8fa630335/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02d1eb1717fee3c513baa0cb5fc39b8fa630335/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=e02d1eb1717fee3c513baa0cb5fc39b8fa630335", "patch": "@@ -61,16 +61,17 @@ do my_string.with_c_str |c_buffer| {\n */\n \n use cast;\n+use container::Container;\n use iter::{Iterator, range};\n use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n-use str;\n use str::StrSlice;\n-use vec::{ImmutableVector, CopyableVector};\n-use container::Container;\n+use str;\n+use vec::{CopyableVector, ImmutableVector, MutableVector};\n+use unstable::intrinsics;\n \n /// Resolution options for the `null_byte` condition\n pub enum NullByteResolution {\n@@ -241,24 +242,22 @@ impl<'self> ToCStr for &'self str {\n     unsafe fn to_c_str_unchecked(&self) -> CString {\n         self.as_bytes().to_c_str_unchecked()\n     }\n+\n+    #[inline]\n+    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+        self.as_bytes().with_c_str(f)\n+    }\n }\n \n+// The length of the stack allocated buffer for `vec.with_c_str()`\n+static BUF_LEN: uint = 32;\n+\n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n         #[fixed_stack_segment]; #[inline(never)];\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n         do cs.with_mut_ref |buf| {\n-            for i in range(0, self.len()) {\n-                unsafe {\n-                    let p = buf.offset(i as int);\n-                    if *p == 0 {\n-                        match null_byte::cond.raise(self.to_owned()) {\n-                            Truncate => break,\n-                            ReplaceWith(c) => *p = c\n-                        }\n-                    }\n-                }\n-            }\n+            check_for_null(*self, buf);\n         }\n         cs\n     }\n@@ -277,6 +276,45 @@ impl<'self> ToCStr for &'self [u8] {\n             CString::new(buf as *libc::c_char, true)\n         }\n     }\n+\n+    /// WARNING: This function uses an optimization to only malloc a temporary\n+    /// CString when the source string is small. Do not save a reference to\n+    /// the `*libc::c_char` as it may be invalid after this function call.\n+    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+        if self.len() < BUF_LEN {\n+            do self.as_imm_buf |self_buf, self_len| {\n+                unsafe {\n+                    let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n+\n+                    do buf.as_mut_buf |buf, _| {\n+                        ptr::copy_memory(buf, self_buf, self_len);\n+                        *ptr::mut_offset(buf, self_len as int) = 0;\n+\n+                        check_for_null(*self, buf as *mut libc::c_char);\n+\n+                        f(buf as *libc::c_char)\n+                    }\n+                }\n+            }\n+        } else {\n+            self.to_c_str().with_ref(f)\n+        }\n+    }\n+}\n+\n+#[inline]\n+fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n+    for i in range(0, v.len()) {\n+        unsafe {\n+            let p = buf.offset(i as int);\n+            if *p == 0 {\n+                match null_byte::cond.raise(v.to_owned()) {\n+                    Truncate => break,\n+                    ReplaceWith(c) => *p = c\n+                }\n+            }\n+        }\n+    }\n }\n \n /// External iterator for a CString's bytes."}]}