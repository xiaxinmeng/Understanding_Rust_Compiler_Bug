{"sha": "dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "node_id": "C_kwDOAAsO6NoAKGRjNTk1MWE2ZTVjNjRkOTM0OGE5NmU3YzE2MWQwN2IyMjFiMjZkZDI", "commit": {"author": {"name": "Jacob Hughes", "email": "j@distanthills.org", "date": "2022-03-10T09:55:24Z"}, "committer": {"name": "Jacob Hughes", "email": "j@distanthills.org", "date": "2022-06-14T17:54:03Z"}, "message": "BTreeMap: Add alloc param", "tree": {"sha": "e75f9e1f9d9f37e5b86c4e4eed710a0d70110bd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e75f9e1f9d9f37e5b86c4e4eed710a0d70110bd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "html_url": "https://github.com/rust-lang/rust/commit/dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/comments", "author": {"login": "exrook", "id": 534850, "node_id": "MDQ6VXNlcjUzNDg1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/534850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exrook", "html_url": "https://github.com/exrook", "followers_url": "https://api.github.com/users/exrook/followers", "following_url": "https://api.github.com/users/exrook/following{/other_user}", "gists_url": "https://api.github.com/users/exrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/exrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exrook/subscriptions", "organizations_url": "https://api.github.com/users/exrook/orgs", "repos_url": "https://api.github.com/users/exrook/repos", "events_url": "https://api.github.com/users/exrook/events{/privacy}", "received_events_url": "https://api.github.com/users/exrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "exrook", "id": 534850, "node_id": "MDQ6VXNlcjUzNDg1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/534850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exrook", "html_url": "https://github.com/exrook", "followers_url": "https://api.github.com/users/exrook/followers", "following_url": "https://api.github.com/users/exrook/following{/other_user}", "gists_url": "https://api.github.com/users/exrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/exrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exrook/subscriptions", "organizations_url": "https://api.github.com/users/exrook/orgs", "repos_url": "https://api.github.com/users/exrook/repos", "events_url": "https://api.github.com/users/exrook/events{/privacy}", "received_events_url": "https://api.github.com/users/exrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "872503d918b2c3266d828f85e42951df74f5e303", "url": "https://api.github.com/repos/rust-lang/rust/commits/872503d918b2c3266d828f85e42951df74f5e303", "html_url": "https://github.com/rust-lang/rust/commit/872503d918b2c3266d828f85e42951df74f5e303"}], "stats": {"total": 1016, "additions": 676, "deletions": 340}, "files": [{"sha": "5434ffbc3cb61b1dd4d0ced0b649ee15962701b9", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -1,5 +1,6 @@\n use super::merge_iter::MergeIterInner;\n use super::node::{self, Root};\n+use core::alloc::Allocator;\n use core::iter::FusedIterator;\n \n impl<K, V> Root<K, V> {\n@@ -14,22 +15,27 @@ impl<K, V> Root<K, V> {\n     /// a `BTreeMap`, both iterators should produce keys in strictly ascending\n     /// order, each greater than all keys in the tree, including any keys\n     /// already in the tree upon entry.\n-    pub fn append_from_sorted_iters<I>(&mut self, left: I, right: I, length: &mut usize)\n-    where\n+    pub fn append_from_sorted_iters<I, A: Allocator>(\n+        &mut self,\n+        left: I,\n+        right: I,\n+        length: &mut usize,\n+        alloc: &A,\n+    ) where\n         K: Ord,\n         I: Iterator<Item = (K, V)> + FusedIterator,\n     {\n         // We prepare to merge `left` and `right` into a sorted sequence in linear time.\n         let iter = MergeIter(MergeIterInner::new(left, right));\n \n         // Meanwhile, we build a tree from the sorted sequence in linear time.\n-        self.bulk_push(iter, length)\n+        self.bulk_push(iter, length, alloc)\n     }\n \n     /// Pushes all key-value pairs to the end of the tree, incrementing a\n     /// `length` variable along the way. The latter makes it easier for the\n     /// caller to avoid a leak when the iterator panicks.\n-    pub fn bulk_push<I>(&mut self, iter: I, length: &mut usize)\n+    pub fn bulk_push<I, A: Allocator>(&mut self, iter: I, length: &mut usize, alloc: &A)\n     where\n         I: Iterator<Item = (K, V)>,\n     {\n@@ -58,17 +64,17 @@ impl<K, V> Root<K, V> {\n                         }\n                         Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = self.push_internal_level();\n+                            open_node = self.push_internal_level(alloc);\n                             break;\n                         }\n                     }\n                 }\n \n                 // Push key-value pair and new right subtree.\n                 let tree_height = open_node.height() - 1;\n-                let mut right_tree = Root::new();\n+                let mut right_tree = Root::new(alloc);\n                 for _ in 0..tree_height {\n-                    right_tree.push_internal_level();\n+                    right_tree.push_internal_level(alloc);\n                 }\n                 open_node.push(key, value, right_tree);\n "}, {"sha": "f139ab10f2c42aac0096a100393e650de0da7b3e", "filename": "library/alloc/src/collections/btree/fix.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -1,13 +1,15 @@\n use super::map::MIN_LEN;\n use super::node::{marker, ForceResult::*, Handle, LeftOrRight::*, NodeRef, Root};\n+use core::alloc::Allocator;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Stocks up a possibly underfull node by merging with or stealing from a\n     /// sibling. If successful but at the cost of shrinking the parent node,\n     /// returns that shrunk parent node. Returns an `Err` if the node is\n     /// an empty root.\n-    fn fix_node_through_parent(\n+    fn fix_node_through_parent<A: Allocator>(\n         self,\n+        alloc: &A,\n     ) -> Result<Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>>, Self> {\n         let len = self.len();\n         if len >= MIN_LEN {\n@@ -16,7 +18,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             match self.choose_parent_kv() {\n                 Ok(Left(mut left_parent_kv)) => {\n                     if left_parent_kv.can_merge() {\n-                        let parent = left_parent_kv.merge_tracking_parent();\n+                        let parent = left_parent_kv.merge_tracking_parent(alloc);\n                         Ok(Some(parent))\n                     } else {\n                         left_parent_kv.bulk_steal_left(MIN_LEN - len);\n@@ -25,7 +27,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n                 Ok(Right(mut right_parent_kv)) => {\n                     if right_parent_kv.can_merge() {\n-                        let parent = right_parent_kv.merge_tracking_parent();\n+                        let parent = right_parent_kv.merge_tracking_parent(alloc);\n                         Ok(Some(parent))\n                     } else {\n                         right_parent_kv.bulk_steal_right(MIN_LEN - len);\n@@ -52,9 +54,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     ///\n     /// This method does not expect ancestors to already be underfull upon entry\n     /// and panics if it encounters an empty ancestor.\n-    pub fn fix_node_and_affected_ancestors(mut self) -> bool {\n+    pub fn fix_node_and_affected_ancestors<A: Allocator>(mut self, alloc: &A) -> bool {\n         loop {\n-            match self.fix_node_through_parent() {\n+            match self.fix_node_through_parent(alloc) {\n                 Ok(Some(parent)) => self = parent.forget_type(),\n                 Ok(None) => return true,\n                 Err(_) => return false,\n@@ -65,29 +67,29 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n \n impl<K, V> Root<K, V> {\n     /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n-    pub fn fix_top(&mut self) {\n+    pub fn fix_top<A: Allocator>(&mut self, alloc: &A) {\n         while self.height() > 0 && self.len() == 0 {\n-            self.pop_internal_level();\n+            self.pop_internal_level(alloc);\n         }\n     }\n \n     /// Stocks up or merge away any underfull nodes on the right border of the\n     /// tree. The other nodes, those that are not the root nor a rightmost edge,\n     /// must already have at least MIN_LEN elements.\n-    pub fn fix_right_border(&mut self) {\n-        self.fix_top();\n+    pub fn fix_right_border<A: Allocator>(&mut self, alloc: &A) {\n+        self.fix_top(alloc);\n         if self.len() > 0 {\n-            self.borrow_mut().last_kv().fix_right_border_of_right_edge();\n-            self.fix_top();\n+            self.borrow_mut().last_kv().fix_right_border_of_right_edge(alloc);\n+            self.fix_top(alloc);\n         }\n     }\n \n     /// The symmetric clone of `fix_right_border`.\n-    pub fn fix_left_border(&mut self) {\n-        self.fix_top();\n+    pub fn fix_left_border<A: Allocator>(&mut self, alloc: &A) {\n+        self.fix_top(alloc);\n         if self.len() > 0 {\n-            self.borrow_mut().first_kv().fix_left_border_of_left_edge();\n-            self.fix_top();\n+            self.borrow_mut().first_kv().fix_left_border_of_left_edge(alloc);\n+            self.fix_top(alloc);\n         }\n     }\n \n@@ -113,16 +115,16 @@ impl<K, V> Root<K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    fn fix_left_border_of_left_edge(mut self) {\n+    fn fix_left_border_of_left_edge<A: Allocator>(mut self, alloc: &A) {\n         while let Internal(internal_kv) = self.force() {\n-            self = internal_kv.fix_left_child().first_kv();\n+            self = internal_kv.fix_left_child(alloc).first_kv();\n             debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n         }\n     }\n \n-    fn fix_right_border_of_right_edge(mut self) {\n+    fn fix_right_border_of_right_edge<A: Allocator>(mut self, alloc: &A) {\n         while let Internal(internal_kv) = self.force() {\n-            self = internal_kv.fix_right_child().last_kv();\n+            self = internal_kv.fix_right_child(alloc).last_kv();\n             debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n         }\n     }\n@@ -133,12 +135,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// provisions an extra element to allow merging its children in turn\n     /// without becoming underfull.\n     /// Returns the left child.\n-    fn fix_left_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    fn fix_left_child<A: Allocator>(\n+        self,\n+        alloc: &A,\n+    ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let mut internal_kv = self.consider_for_balancing();\n         let left_len = internal_kv.left_child_len();\n         debug_assert!(internal_kv.right_child_len() >= MIN_LEN);\n         if internal_kv.can_merge() {\n-            internal_kv.merge_tracking_child()\n+            internal_kv.merge_tracking_child(alloc)\n         } else {\n             // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n             let count = (MIN_LEN + 1).saturating_sub(left_len);\n@@ -153,12 +158,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// provisions an extra element to allow merging its children in turn\n     /// without becoming underfull.\n     /// Returns wherever the right child ended up.\n-    fn fix_right_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    fn fix_right_child<A: Allocator>(\n+        self,\n+        alloc: &A,\n+    ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let mut internal_kv = self.consider_for_balancing();\n         let right_len = internal_kv.right_child_len();\n         debug_assert!(internal_kv.left_child_len() >= MIN_LEN);\n         if internal_kv.can_merge() {\n-            internal_kv.merge_tracking_child()\n+            internal_kv.merge_tracking_child(alloc)\n         } else {\n             // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n             let count = (MIN_LEN + 1).saturating_sub(right_len);"}, {"sha": "da2964aa5d7a58eecb12a256ff5bfbd7d5b115db", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 256, "deletions": 130, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -9,6 +9,8 @@ use core::mem::{self, ManuallyDrop};\n use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::borrow::DormantMutRef;\n use super::dedup_sorted_iter::DedupSortedIter;\n use super::navigate::{LazyLeafRange, LeafRange};\n@@ -163,31 +165,41 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeMap\")]\n #[rustc_insignificant_dtor]\n-pub struct BTreeMap<K, V> {\n+pub struct BTreeMap<\n+    K,\n+    V,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     root: Option<Root<K, V>>,\n     length: usize,\n+    pub(super) alloc: ManuallyDrop<A>,\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n+unsafe impl<#[may_dangle] K, #[may_dangle] V, A: Allocator> Drop for BTreeMap<K, V, A> {\n     fn drop(&mut self) {\n         drop(unsafe { ptr::read(self) }.into_iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n-    fn clone(&self) -> BTreeMap<K, V> {\n-        fn clone_subtree<'a, K: Clone, V: Clone>(\n+impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n+    fn clone(&self) -> BTreeMap<K, V, A> {\n+        fn clone_subtree<'a, K: Clone, V: Clone, A: Clone + Allocator>(\n             node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n-        ) -> BTreeMap<K, V>\n+            alloc: &A,\n+        ) -> BTreeMap<K, V, A>\n         where\n             K: 'a,\n             V: 'a,\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: Some(Root::new()), length: 0 };\n+                    let mut out_tree = BTreeMap {\n+                        root: Some(Root::new(alloc)),\n+                        length: 0,\n+                        alloc: ManuallyDrop::new((*alloc).clone()),\n+                    };\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n@@ -209,19 +221,19 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     out_tree\n                 }\n                 Internal(internal) => {\n-                    let mut out_tree = clone_subtree(internal.first_edge().descend());\n+                    let mut out_tree = clone_subtree(internal.first_edge().descend(), alloc);\n \n                     {\n                         let out_root = out_tree.root.as_mut().unwrap();\n-                        let mut out_node = out_root.push_internal_level();\n+                        let mut out_node = out_root.push_internal_level(alloc);\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n                             in_edge = kv.right_edge();\n \n                             let k = (*k).clone();\n                             let v = (*v).clone();\n-                            let subtree = clone_subtree(in_edge.descend());\n+                            let subtree = clone_subtree(in_edge.descend(), alloc);\n \n                             // We can't destructure subtree directly\n                             // because BTreeMap implements Drop\n@@ -232,7 +244,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot.unwrap_or_else(Root::new));\n+                            out_node.push(k, v, subroot.unwrap_or_else(|| Root::new(alloc)));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -243,14 +255,14 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         }\n \n         if self.is_empty() {\n-            BTreeMap::new()\n+            BTreeMap::new_in(ManuallyDrop::into_inner(self.alloc.clone()))\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().reborrow()) // unwrap succeeds because not empty\n+            clone_subtree(self.root.as_ref().unwrap().reborrow(), &*self.alloc) // unwrap succeeds because not empty\n         }\n     }\n }\n \n-impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n+impl<K, Q: ?Sized, A: Allocator> super::Recover<Q> for BTreeMap<K, (), A>\n where\n     K: Borrow<Q> + Ord,\n     Q: Ord,\n@@ -269,21 +281,29 @@ where\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         match root_node.search_tree(key) {\n-            Found(handle) => {\n-                Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_kv().0)\n-            }\n+            Found(handle) => Some(\n+                OccupiedEntry { handle, dormant_map, alloc: &*map.alloc, _marker: PhantomData }\n+                    .remove_kv()\n+                    .0,\n+            ),\n             GoDown(_) => None,\n         }\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.get_or_insert_with(Root::new).borrow_mut();\n+        let root_node = map.root.get_or_insert_with(|| Root::new(&*map.alloc)).borrow_mut();\n         match root_node.search_tree::<K>(&key) {\n             Found(mut kv) => Some(mem::replace(kv.key_mut(), key)),\n             GoDown(handle) => {\n-                VacantEntry { key, handle: Some(handle), dormant_map, _marker: PhantomData }\n-                    .insert(());\n+                VacantEntry {\n+                    key,\n+                    handle: Some(handle),\n+                    dormant_map,\n+                    alloc: &*map.alloc,\n+                    _marker: PhantomData,\n+                }\n+                .insert(());\n                 None\n             }\n         }\n@@ -343,12 +363,17 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n /// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_insignificant_dtor]\n-pub struct IntoIter<K, V> {\n+pub struct IntoIter<\n+    K,\n+    V,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     range: LazyLeafRange<marker::Dying, K, V>,\n     length: usize,\n+    alloc: A,\n }\n \n-impl<K, V> IntoIter<K, V> {\n+impl<K, V, A: Allocator> IntoIter<K, V, A> {\n     /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n@@ -357,7 +382,7 @@ impl<K, V> IntoIter<K, V> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n+impl<K: Debug, V: Debug, A: Allocator> Debug for IntoIter<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n@@ -371,7 +396,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n /// [`keys`]: BTreeMap::keys\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Keys<'a, K: 'a, V: 'a> {\n+pub struct Keys<'a, K, V> {\n     inner: Iter<'a, K, V>,\n }\n \n@@ -390,7 +415,7 @@ impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// [`values`]: BTreeMap::values\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Values<'a, K: 'a, V: 'a> {\n+pub struct Values<'a, K, V> {\n     inner: Iter<'a, K, V>,\n }\n \n@@ -409,7 +434,7 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n /// [`values_mut`]: BTreeMap::values_mut\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-pub struct ValuesMut<'a, K: 'a, V: 'a> {\n+pub struct ValuesMut<'a, K, V> {\n     inner: IterMut<'a, K, V>,\n }\n \n@@ -428,12 +453,12 @@ impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n /// [`into_keys`]: BTreeMap::into_keys\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-pub struct IntoKeys<K, V> {\n-    inner: IntoIter<K, V>,\n+pub struct IntoKeys<K, V, A: Allocator = Global> {\n+    inner: IntoIter<K, V, A>,\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n+impl<K: fmt::Debug, V, A: Allocator> fmt::Debug for IntoKeys<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(key, _)| key)).finish()\n     }\n@@ -447,12 +472,16 @@ impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n /// [`into_values`]: BTreeMap::into_values\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-pub struct IntoValues<K, V> {\n-    inner: IntoIter<K, V>,\n+pub struct IntoValues<\n+    K,\n+    V,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    inner: IntoIter<K, V, A>,\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V: fmt::Debug> fmt::Debug for IntoValues<K, V> {\n+impl<K, V: fmt::Debug, A: Allocator> fmt::Debug for IntoValues<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n     }\n@@ -521,9 +550,11 @@ impl<K, V> BTreeMap<K, V> {\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n     #[must_use]\n     pub const fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: None, length: 0 }\n+        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(Global) }\n     }\n+}\n \n+impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n     /// Clears the map, removing all elements.\n     ///\n     /// # Examples\n@@ -540,9 +571,37 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = BTreeMap::new();\n+        let alloc = unsafe {\n+            // drop all elements and retrieve allocator\n+            ptr::read(self).into_iter().into_alloc()\n+        };\n+        *self = BTreeMap::new_in(alloc);\n     }\n \n+    /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(allocator_api)]\n+    /// # #![feature(btreemap_alloc)]\n+    /// use std::collections::BTreeMap;\n+    /// use std::alloc::Global;\n+    ///\n+    /// let mut map = BTreeMap::new_in(Global);\n+    ///\n+    /// // entries can now be inserted into the empty map\n+    /// map.insert(1, \"a\");\n+    /// ```\n+    #[unstable(feature = \"btreemap_alloc\", issue = \"32838\")]\n+    pub fn new_in(alloc: A) -> BTreeMap<K, V, A> {\n+        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(alloc) }\n+    }\n+}\n+\n+impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -648,14 +707,19 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V, A>>\n     where\n         K: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n-        Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            dormant_map,\n+            alloc: &*map.alloc,\n+            _marker: PhantomData,\n+        })\n     }\n \n     /// Removes and returns the first element in the map.\n@@ -731,14 +795,19 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V, A>>\n     where\n         K: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n-        Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            dormant_map,\n+            alloc: &*map.alloc,\n+            _marker: PhantomData,\n+        })\n     }\n \n     /// Removes and returns the last element in the map.\n@@ -891,7 +960,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(err.value, \"b\");\n     /// ```\n     #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>>\n+    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V, A>>\n     where\n         K: Ord,\n     {\n@@ -955,9 +1024,10 @@ impl<K, V> BTreeMap<K, V> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         match root_node.search_tree(key) {\n-            Found(handle) => {\n-                Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_entry())\n-            }\n+            Found(handle) => Some(\n+                OccupiedEntry { handle, dormant_map, alloc: &*map.alloc, _marker: PhantomData }\n+                    .remove_entry(),\n+            ),\n             GoDown(_) => None,\n         }\n     }\n@@ -1019,6 +1089,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn append(&mut self, other: &mut Self)\n     where\n         K: Ord,\n+        A: Clone,\n     {\n         // Do we have to append anything at all?\n         if other.is_empty() {\n@@ -1031,10 +1102,14 @@ impl<K, V> BTreeMap<K, V> {\n             return;\n         }\n \n-        let self_iter = mem::take(self).into_iter();\n-        let other_iter = mem::take(other).into_iter();\n-        let root = self.root.get_or_insert_with(Root::new);\n-        root.append_from_sorted_iters(self_iter, other_iter, &mut self.length)\n+        let self_iter =\n+            mem::replace(self, Self::new_in(ManuallyDrop::into_inner(self.alloc.clone())))\n+                .into_iter();\n+        let other_iter =\n+            mem::replace(other, Self::new_in(ManuallyDrop::into_inner(self.alloc.clone())))\n+                .into_iter();\n+        let root = self.root.get_or_insert_with(|| Root::new(&*self.alloc));\n+        root.append_from_sorted_iters(self_iter, other_iter, &mut self.length, &*self.alloc)\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1141,21 +1216,31 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<'_, K, V>\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V, A>\n     where\n         K: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         match map.root {\n-            None => Vacant(VacantEntry { key, handle: None, dormant_map, _marker: PhantomData }),\n+            None => Vacant(VacantEntry {\n+                key,\n+                handle: None,\n+                dormant_map,\n+                alloc: &*map.alloc,\n+                _marker: PhantomData,\n+            }),\n             Some(ref mut root) => match root.borrow_mut().search_tree(&key) {\n-                Found(handle) => {\n-                    Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData })\n-                }\n+                Found(handle) => Occupied(OccupiedEntry {\n+                    handle,\n+                    dormant_map,\n+                    alloc: &*map.alloc,\n+                    _marker: PhantomData,\n+                }),\n                 GoDown(handle) => Vacant(VacantEntry {\n                     key,\n                     handle: Some(handle),\n                     dormant_map,\n+                    alloc: &*map.alloc,\n                     _marker: PhantomData,\n                 }),\n             },\n@@ -1195,20 +1280,25 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n         K: Borrow<Q> + Ord,\n+        A: Clone,\n     {\n         if self.is_empty() {\n-            return Self::new();\n+            return Self::new_in(ManuallyDrop::into_inner(self.alloc.clone()));\n         }\n \n         let total_num = self.len();\n         let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n-        let right_root = left_root.split_off(key);\n+        let right_root = left_root.split_off(key, &*self.alloc);\n \n         let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n         self.length = new_left_len;\n \n-        BTreeMap { root: Some(right_root), length: right_len }\n+        BTreeMap {\n+            root: Some(right_root),\n+            length: right_len,\n+            alloc: ManuallyDrop::new((*self.alloc).clone()),\n+        }\n     }\n \n     /// Creates an iterator that visits all elements (key-value pairs) in\n@@ -1244,28 +1334,39 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n     /// ```\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F, &A>\n     where\n         K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        DrainFilter { pred, inner: self.drain_filter_inner() }\n+        let (inner, alloc) = self.drain_filter_inner();\n+        DrainFilter { pred, inner, alloc }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V>\n+    pub(super) fn drain_filter_inner(&mut self) -> (DrainFilterInner<'_, K, V>, &A)\n     where\n         K: Ord,\n     {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n             let front = root.borrow_mut().first_leaf_edge();\n-            DrainFilterInner {\n-                length: &mut self.length,\n-                dormant_root: Some(dormant_root),\n-                cur_leaf_edge: Some(front),\n-            }\n+            (\n+                DrainFilterInner {\n+                    length: &mut self.length,\n+                    dormant_root: Some(dormant_root),\n+                    cur_leaf_edge: Some(front),\n+                },\n+                &*self.alloc,\n+            )\n         } else {\n-            DrainFilterInner { length: &mut self.length, dormant_root: None, cur_leaf_edge: None }\n+            (\n+                DrainFilterInner {\n+                    length: &mut self.length,\n+                    dormant_root: None,\n+                    cur_leaf_edge: None,\n+                },\n+                &*self.alloc,\n+            )\n         }\n     }\n \n@@ -1287,7 +1388,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-    pub fn into_keys(self) -> IntoKeys<K, V> {\n+    pub fn into_keys(self) -> IntoKeys<K, V, A> {\n         IntoKeys { inner: self.into_iter() }\n     }\n \n@@ -1309,25 +1410,25 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-    pub fn into_values(self) -> IntoValues<K, V> {\n+    pub fn into_values(self) -> IntoValues<K, V, A> {\n         IntoValues { inner: self.into_iter() }\n     }\n \n     /// Makes a `BTreeMap` from a sorted iterator.\n-    pub(crate) fn bulk_build_from_sorted_iter<I>(iter: I) -> Self\n+    pub(crate) fn bulk_build_from_sorted_iter<I>(iter: I, alloc: A) -> Self\n     where\n         K: Ord,\n         I: IntoIterator<Item = (K, V)>,\n     {\n-        let mut root = Root::new();\n+        let mut root = Root::new(&alloc);\n         let mut length = 0;\n-        root.bulk_push(DedupSortedIter::new(iter.into_iter()), &mut length);\n-        BTreeMap { root: Some(root), length }\n+        root.bulk_push(DedupSortedIter::new(iter.into_iter()), &mut length, &alloc);\n+        BTreeMap { root: Some(root), length, alloc: ManuallyDrop::new(alloc) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n+impl<'a, K, V, A: Allocator> IntoIterator for &'a BTreeMap<K, V, A> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -1396,7 +1497,7 @@ impl<K, V> Clone for Iter<'_, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n+impl<'a, K, V, A: Allocator> IntoIterator for &'a mut BTreeMap<K, V, A> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -1406,7 +1507,7 @@ impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n+impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1436,7 +1537,7 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n         if self.length == 0 {\n             None\n@@ -1466,28 +1567,41 @@ impl<'a, K, V> IterMut<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> IntoIterator for BTreeMap<K, V> {\n+impl<K, V, A: Allocator> IntoIterator for BTreeMap<K, V, A> {\n     type Item = (K, V);\n-    type IntoIter = IntoIter<K, V>;\n+    type IntoIter = IntoIter<K, V, A>;\n \n-    fn into_iter(self) -> IntoIter<K, V> {\n+    fn into_iter(self) -> IntoIter<K, V, A> {\n         let mut me = ManuallyDrop::new(self);\n         if let Some(root) = me.root.take() {\n             let full_range = root.into_dying().full_range();\n \n-            IntoIter { range: full_range, length: me.length }\n+            IntoIter {\n+                range: full_range,\n+                length: me.length,\n+                alloc: unsafe { ManuallyDrop::take(&mut me.alloc) },\n+            }\n         } else {\n-            IntoIter { range: LazyLeafRange::none(), length: 0 }\n+            IntoIter {\n+                range: LazyLeafRange::none(),\n+                length: 0,\n+                alloc: unsafe { ManuallyDrop::take(&mut me.alloc) },\n+            }\n         }\n     }\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-impl<K, V> Drop for IntoIter<K, V> {\n+impl<K, V, A: Allocator> Drop for IntoIter<K, V, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, K, V>(&'a mut IntoIter<K, V>);\n+        self.dealloc()\n+    }\n+}\n+impl<K, V, A: Allocator> IntoIter<K, V, A> {\n+    fn dealloc(&mut self) {\n+        struct DropGuard<'a, K, V, A: Allocator>(&'a mut IntoIter<K, V, A>);\n \n-        impl<'a, K, V> Drop for DropGuard<'a, K, V> {\n+        impl<'a, K, V, A: Allocator> Drop for DropGuard<'a, K, V, A> {\n             fn drop(&mut self) {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n@@ -1507,18 +1621,18 @@ impl<K, V> Drop for IntoIter<K, V> {\n     }\n }\n \n-impl<K, V> IntoIter<K, V> {\n+impl<K, V, A: Allocator> IntoIter<K, V, A> {\n     /// Core of a `next` method returning a dying KV handle,\n     /// invalidated by further calls to this function and some others.\n     fn dying_next(\n         &mut self,\n     ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {\n         if self.length == 0 {\n-            self.range.deallocating_end();\n+            self.range.deallocating_end(&self.alloc);\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.deallocating_next_unchecked() })\n+            Some(unsafe { self.range.deallocating_next_unchecked(&self.alloc) })\n         }\n     }\n \n@@ -1528,17 +1642,22 @@ impl<K, V> IntoIter<K, V> {\n         &mut self,\n     ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {\n         if self.length == 0 {\n-            self.range.deallocating_end();\n+            self.range.deallocating_end(&self.alloc);\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.deallocating_next_back_unchecked() })\n+            Some(unsafe { self.range.deallocating_next_back_unchecked(&self.alloc) })\n         }\n     }\n+    fn into_alloc(mut self) -> A {\n+        self.dealloc(); // Deallocate, then don't drop as drop will also call dealloc\n+        let iter = ManuallyDrop::new(self);\n+        unsafe { ptr::read(&iter.alloc) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> Iterator for IntoIter<K, V> {\n+impl<K, V, A: Allocator> Iterator for IntoIter<K, V, A> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n@@ -1552,22 +1671,22 @@ impl<K, V> Iterator for IntoIter<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n+impl<K, V, A: Allocator> DoubleEndedIterator for IntoIter<K, V, A> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         // SAFETY: we consume the dying handle immediately.\n         self.dying_next_back().map(unsafe { |kv| kv.into_key_val() })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n+impl<K, V, A: Allocator> ExactSizeIterator for IntoIter<K, V, A> {\n     fn len(&self) -> usize {\n         self.length\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<K, V> FusedIterator for IntoIter<K, V> {}\n+impl<K, V, A: Allocator> FusedIterator for IntoIter<K, V, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n@@ -1661,18 +1780,22 @@ impl<K, V> Clone for Values<'_, K, V> {\n \n /// An iterator produced by calling `drain_filter` on BTreeMap.\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-pub struct DrainFilter<'a, K, V, F>\n-where\n-    K: 'a,\n-    V: 'a,\n+pub struct DrainFilter<\n+    'a,\n+    K,\n+    V,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n     F: 'a + FnMut(&K, &mut V) -> bool,\n {\n     pred: F,\n     inner: DrainFilterInner<'a, K, V>,\n+    alloc: A,\n }\n /// Most of the implementation of DrainFilter are generic over the type\n /// of the predicate, thus also serving for BTreeSet::DrainFilter.\n-pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n+pub(super) struct DrainFilterInner<'a, K, V> {\n     /// Reference to the length field in the borrowed map, updated live.\n     length: &'a mut usize,\n     /// Buried reference to the root field in the borrowed map.\n@@ -1685,7 +1808,7 @@ pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F> Drop for DrainFilter<'_, K, V, F>\n+impl<K, V, F, A: Allocator> Drop for DrainFilter<'_, K, V, F, A>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -1707,44 +1830,47 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+impl<K, V, F, A: Allocator> Iterator for DrainFilter<'_, K, V, F, A>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next(&mut self.pred)\n+        self.inner.next(&mut self.pred, &self.alloc)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n+impl<'a, K, V> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n         let edge = self.cur_leaf_edge.as_ref()?;\n         edge.reborrow().next_kv().ok().map(Handle::into_kv)\n     }\n \n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n-    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    pub(super) fn next<F, A: Allocator>(&mut self, pred: &mut F, alloc: &A) -> Option<(K, V)>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (kv, pos) = kv.remove_kv_tracking(|| {\n-                    // SAFETY: we will touch the root in a way that will not\n-                    // invalidate the position returned.\n-                    let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n-                    root.pop_internal_level();\n-                    self.dormant_root = Some(DormantMutRef::new(root).1);\n-                });\n+                let (kv, pos) = kv.remove_kv_tracking(\n+                    || {\n+                        // SAFETY: we will touch the root in a way that will not\n+                        // invalidate the position returned.\n+                        let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n+                        root.pop_internal_level(alloc);\n+                        self.dormant_root = Some(DormantMutRef::new(root).1);\n+                    },\n+                    alloc,\n+                );\n                 self.cur_leaf_edge = Some(pos);\n                 return Some(kv);\n             }\n@@ -1822,7 +1948,7 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> Iterator for IntoKeys<K, V> {\n+impl<K, V, A: Allocator> Iterator for IntoKeys<K, V, A> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> {\n@@ -1847,24 +1973,24 @@ impl<K, V> Iterator for IntoKeys<K, V> {\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> DoubleEndedIterator for IntoKeys<K, V> {\n+impl<K, V, A: Allocator> DoubleEndedIterator for IntoKeys<K, V, A> {\n     fn next_back(&mut self) -> Option<K> {\n         self.inner.next_back().map(|(k, _)| k)\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n+impl<K, V, A: Allocator> ExactSizeIterator for IntoKeys<K, V, A> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> FusedIterator for IntoKeys<K, V> {}\n+impl<K, V, A: Allocator> FusedIterator for IntoKeys<K, V, A> {}\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> Iterator for IntoValues<K, V> {\n+impl<K, V, A: Allocator> Iterator for IntoValues<K, V, A> {\n     type Item = V;\n \n     fn next(&mut self) -> Option<V> {\n@@ -1881,21 +2007,21 @@ impl<K, V> Iterator for IntoValues<K, V> {\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> DoubleEndedIterator for IntoValues<K, V> {\n+impl<K, V, A: Allocator> DoubleEndedIterator for IntoValues<K, V, A> {\n     fn next_back(&mut self) -> Option<V> {\n         self.inner.next_back().map(|(_, v)| v)\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n+impl<K, V, A: Allocator> ExactSizeIterator for IntoValues<K, V, A> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V> FusedIterator for IntoValues<K, V> {}\n+impl<K, V, A: Allocator> FusedIterator for IntoValues<K, V, A> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n@@ -1956,12 +2082,12 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n \n         // use stable sort to preserve the insertion order.\n         inputs.sort_by(|a, b| a.0.cmp(&b.0));\n-        BTreeMap::bulk_build_from_sorted_iter(inputs)\n+        BTreeMap::bulk_build_from_sorted_iter(inputs, Global)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n+impl<K: Ord, V, A: Allocator> Extend<(K, V)> for BTreeMap<K, V, A> {\n     #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         iter.into_iter().for_each(move |(k, v)| {\n@@ -1976,7 +2102,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n+impl<'a, K: Ord + Copy, V: Copy, A: Allocator> Extend<(&'a K, &'a V)> for BTreeMap<K, V, A> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n@@ -1988,7 +2114,7 @@ impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n+impl<K: Hash, V: Hash, A: Allocator> Hash for BTreeMap<K, V, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         state.write_length_prefix(self.len());\n         for elt in self {\n@@ -2006,40 +2132,40 @@ impl<K, V> Default for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n-    fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n+impl<K: PartialEq, V: PartialEq, A: Allocator> PartialEq for BTreeMap<K, V, A> {\n+    fn eq(&self, other: &BTreeMap<K, V, A>) -> bool {\n         self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n+impl<K: Eq, V: Eq, A: Allocator> Eq for BTreeMap<K, V, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n+impl<K: PartialOrd, V: PartialOrd, A: Allocator> PartialOrd for BTreeMap<K, V, A> {\n     #[inline]\n-    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BTreeMap<K, V, A>) -> Option<Ordering> {\n         self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n+impl<K: Ord, V: Ord, A: Allocator> Ord for BTreeMap<K, V, A> {\n     #[inline]\n-    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n+    fn cmp(&self, other: &BTreeMap<K, V, A>) -> Ordering {\n         self.iter().cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n+impl<K: Debug, V: Debug, A: Allocator> Debug for BTreeMap<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n+impl<K, Q: ?Sized, V, A: Allocator> Index<&Q> for BTreeMap<K, V, A>\n where\n     K: Borrow<Q> + Ord,\n     Q: Ord,\n@@ -2075,11 +2201,11 @@ impl<K: Ord, V, const N: usize> From<[(K, V); N]> for BTreeMap<K, V> {\n \n         // use stable sort to preserve the insertion order.\n         arr.sort_by(|a, b| a.0.cmp(&b.0));\n-        BTreeMap::bulk_build_from_sorted_iter(arr)\n+        BTreeMap::bulk_build_from_sorted_iter(arr, Global)\n     }\n }\n \n-impl<K, V> BTreeMap<K, V> {\n+impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n     /// # Examples"}, {"sha": "61b2f89100d4f57d982b24eea7f4fa48da8d8574", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -2,6 +2,8 @@ use core::fmt::{self, Debug};\n use core::marker::PhantomData;\n use core::mem;\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::super::borrow::DormantMutRef;\n use super::super::node::{marker, Handle, NodeRef};\n use super::BTreeMap;\n@@ -15,18 +17,23 @@ use Entry::*;\n /// [`entry`]: BTreeMap::entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeEntry\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n+pub enum Entry<\n+    'a,\n+    K: 'a,\n+    V: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     /// A vacant entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V, A>),\n \n     /// An occupied entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V, A>),\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for Entry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n@@ -38,18 +45,25 @@ impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n /// A view into a vacant entry in a `BTreeMap`.\n /// It is part of the [`Entry`] enum.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+pub struct VacantEntry<\n+    'a,\n+    K,\n+    V,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     pub(super) key: K,\n     /// `None` for a (empty) map without root\n     pub(super) handle: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n-    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V, A>>,\n+\n+    pub(super) alloc: &'a A,\n \n     // Be invariant in `K` and `V`\n     pub(super) _marker: PhantomData<&'a mut (K, V)>,\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n+impl<K: Debug + Ord, V, A: Allocator> Debug for VacantEntry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n     }\n@@ -58,16 +72,23 @@ impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n /// A view into an occupied entry in a `BTreeMap`.\n /// It is part of the [`Entry`] enum.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+pub struct OccupiedEntry<\n+    'a,\n+    K,\n+    V,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n-    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V, A>>,\n+\n+    pub(super) alloc: &'a A,\n \n     // Be invariant in `K` and `V`\n     pub(super) _marker: PhantomData<&'a mut (K, V)>,\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedEntry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n     }\n@@ -77,15 +98,15 @@ impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n ///\n /// Contains the occupied entry, and the value that was not inserted.\n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-pub struct OccupiedError<'a, K: 'a, V: 'a> {\n+pub struct OccupiedError<'a, K: 'a, V: 'a, A: Allocator = Global> {\n     /// The entry in the map that was already occupied.\n-    pub entry: OccupiedEntry<'a, K, V>,\n+    pub entry: OccupiedEntry<'a, K, V, A>,\n     /// The value which was not inserted, because the entry was already occupied.\n     pub value: V,\n }\n \n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-impl<K: Debug + Ord, V: Debug> Debug for OccupiedError<'_, K, V> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedError<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedError\")\n             .field(\"key\", self.entry.key())\n@@ -96,7 +117,7 @@ impl<K: Debug + Ord, V: Debug> Debug for OccupiedError<'_, K, V> {\n }\n \n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-impl<'a, K: Debug + Ord, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n+impl<'a, K: Debug + Ord, V: Debug, A: Allocator> fmt::Display for OccupiedError<'a, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -108,7 +129,7 @@ impl<'a, K: Debug + Ord, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> Entry<'a, K, V> {\n+impl<'a, K: Ord, V, A: Allocator> Entry<'a, K, V, A> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n     ///\n@@ -236,7 +257,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n+impl<'a, K: Ord, V: Default, A: Allocator> Entry<'a, K, V, A> {\n     #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n     /// Ensures a value is in the entry by inserting the default value if empty,\n     /// and returns a mutable reference to the value in the entry.\n@@ -259,7 +280,7 @@ impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+impl<'a, K: Ord, V, A: Allocator> VacantEntry<'a, K, V, A> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n     ///\n@@ -317,13 +338,13 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n             None => {\n                 // SAFETY: There is no tree yet so no reference to it exists.\n                 let map = unsafe { self.dormant_map.awaken() };\n-                let mut root = NodeRef::new_leaf();\n+                let mut root = NodeRef::new_leaf(self.alloc);\n                 let val_ptr = root.borrow_mut().push(self.key, value) as *mut V;\n                 map.root = Some(root.forget_type());\n                 map.length = 1;\n                 val_ptr\n             }\n-            Some(handle) => match handle.insert_recursing(self.key, value) {\n+            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc) {\n                 (None, val_ptr) => {\n                     // SAFETY: We have consumed self.handle.\n                     let map = unsafe { self.dormant_map.awaken() };\n@@ -336,7 +357,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                     // remaining reference to the tree, ins.left.\n                     let map = unsafe { self.dormant_map.awaken() };\n                     let root = map.root.as_mut().unwrap(); // same as ins.left\n-                    root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);\n+                    root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right);\n                     map.length += 1;\n                     val_ptr\n                 }\n@@ -348,7 +369,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+impl<'a, K: Ord, V, A: Allocator> OccupiedEntry<'a, K, V, A> {\n     /// Gets a reference to the key in the entry.\n     ///\n     /// # Examples\n@@ -516,13 +537,14 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     // Body of `remove_entry`, probably separate because the name reflects the returned pair.\n     pub(super) fn remove_kv(self) -> (K, V) {\n         let mut emptied_internal_root = false;\n-        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n+        let (old_kv, _) =\n+            self.handle.remove_kv_tracking(|| emptied_internal_root = true, self.alloc);\n         // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n         let map = unsafe { self.dormant_map.awaken() };\n         map.length -= 1;\n         if emptied_internal_root {\n             let root = map.root.as_mut().unwrap();\n-            root.pop_internal_level();\n+            root.pop_internal_level(&*self.alloc);\n         }\n         old_kv\n     }"}, {"sha": "a4c24cd4593b069303df1d99bdfdc5d04eea5541", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -116,7 +116,11 @@ impl<K, V> BTreeMap<K, V> {\n     {\n         let iter = mem::take(self).into_iter();\n         if !iter.is_empty() {\n-            self.root.insert(Root::new()).bulk_push(iter, &mut self.length);\n+            self.root.insert(Root::new(&*self.alloc)).bulk_push(\n+                iter,\n+                &mut self.length,\n+                &*self.alloc,\n+            );\n         }\n     }\n }"}, {"sha": "d44cb57618dfa0ed2f6e8827e836f444cf9f9e9c", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -5,6 +5,7 @@ use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n+use crate::alloc::Allocator;\n // `front` and `back` are always both `None` or both `Some`.\n pub struct LeafRange<BorrowType, K, V> {\n     front: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n@@ -177,27 +178,29 @@ impl<K, V> LazyLeafRange<marker::Dying, K, V> {\n     }\n \n     #[inline]\n-    pub unsafe fn deallocating_next_unchecked(\n+    pub unsafe fn deallocating_next_unchecked<A: Allocator>(\n         &mut self,\n+        alloc: &A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         debug_assert!(self.front.is_some());\n         let front = self.init_front().unwrap();\n-        unsafe { front.deallocating_next_unchecked() }\n+        unsafe { front.deallocating_next_unchecked(alloc) }\n     }\n \n     #[inline]\n-    pub unsafe fn deallocating_next_back_unchecked(\n+    pub unsafe fn deallocating_next_back_unchecked<A: Allocator>(\n         &mut self,\n+        alloc: &A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         debug_assert!(self.back.is_some());\n         let back = self.init_back().unwrap();\n-        unsafe { back.deallocating_next_back_unchecked() }\n+        unsafe { back.deallocating_next_back_unchecked(alloc) }\n     }\n \n     #[inline]\n-    pub fn deallocating_end(&mut self) {\n+    pub fn deallocating_end<A: Allocator>(&mut self, alloc: &A) {\n         if let Some(front) = self.take_front() {\n-            front.deallocating_end()\n+            front.deallocating_end(alloc)\n         }\n     }\n }\n@@ -441,18 +444,21 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///   `deallocating_next_back`.\n     /// - The returned KV handle is only valid to access the key and value,\n     ///   and only valid until the next call to a `deallocating_` method.\n-    unsafe fn deallocating_next(\n+    unsafe fn deallocating_next<A: Allocator>(\n         self,\n+        alloc: &A,\n     ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n     {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.right_kv() {\n                 Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)),\n-                Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n-                    Some(parent_edge) => parent_edge.forget_node_type(),\n-                    None => return None,\n-                },\n+                Err(last_edge) => {\n+                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc) } {\n+                        Some(parent_edge) => parent_edge.forget_node_type(),\n+                        None => return None,\n+                    }\n+                }\n             }\n         }\n     }\n@@ -470,18 +476,21 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///   `deallocating_next`.\n     /// - The returned KV handle is only valid to access the key and value,\n     ///   and only valid until the next call to a `deallocating_` method.\n-    unsafe fn deallocating_next_back(\n+    unsafe fn deallocating_next_back<A: Allocator>(\n         self,\n+        alloc: &A,\n     ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n     {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.left_kv() {\n                 Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)),\n-                Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n-                    Some(parent_edge) => parent_edge.forget_node_type(),\n-                    None => return None,\n-                },\n+                Err(last_edge) => {\n+                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc) } {\n+                        Some(parent_edge) => parent_edge.forget_node_type(),\n+                        None => return None,\n+                    }\n+                }\n             }\n         }\n     }\n@@ -492,9 +501,9 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// both sides of the tree, and have hit the same edge. As it is intended\n     /// only to be called when all keys and values have been returned,\n     /// no cleanup is done on any of the keys or values.\n-    fn deallocating_end(self) {\n+    fn deallocating_end<A: Allocator>(self, alloc: &A) {\n         let mut edge = self.forget_node_type();\n-        while let Some(parent_edge) = unsafe { edge.into_node().deallocate_and_ascend() } {\n+        while let Some(parent_edge) = unsafe { edge.into_node().deallocate_and_ascend(alloc) } {\n             edge = parent_edge.forget_node_type();\n         }\n     }\n@@ -569,10 +578,13 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_back_unchecked` again.\n-    unsafe fn deallocating_next_unchecked(\n+    unsafe fn deallocating_next_unchecked<A: Allocator>(\n         &mut self,\n+        alloc: &A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n-        super::mem::replace(self, |leaf_edge| unsafe { leaf_edge.deallocating_next().unwrap() })\n+        super::mem::replace(self, |leaf_edge| unsafe {\n+            leaf_edge.deallocating_next(alloc).unwrap()\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key and value\n@@ -587,11 +599,12 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_unchecked` again.\n-    unsafe fn deallocating_next_back_unchecked(\n+    unsafe fn deallocating_next_back_unchecked<A: Allocator>(\n         &mut self,\n+        alloc: &A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n-            leaf_edge.deallocating_next_back().unwrap()\n+            leaf_edge.deallocating_next_back(alloc).unwrap()\n         })\n     }\n }"}, {"sha": "5ae0a554aeea6495608f54dcc69cbeee09dc14c0", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -36,7 +36,7 @@ use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull};\n use core::slice::SliceIndex;\n \n-use crate::alloc::{Allocator, Global, Layout};\n+use crate::alloc::{Allocator, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n@@ -78,9 +78,9 @@ impl<K, V> LeafNode<K, V> {\n     }\n \n     /// Creates a new boxed `LeafNode`.\n-    fn new() -> Box<Self> {\n+    fn new<A: Allocator>(alloc: &A) -> Box<Self, &A> {\n         unsafe {\n-            let mut leaf = Box::new_uninit();\n+            let mut leaf = Box::new_uninit_in(alloc);\n             LeafNode::init(leaf.as_mut_ptr());\n             leaf.assume_init()\n         }\n@@ -110,9 +110,9 @@ impl<K, V> InternalNode<K, V> {\n     /// An invariant of internal nodes is that they have at least one\n     /// initialized and valid edge. This function does not set up\n     /// such an edge.\n-    unsafe fn new() -> Box<Self> {\n+    unsafe fn new<A: Allocator>(alloc: &A) -> Box<Self, &A> {\n         unsafe {\n-            let mut node = Box::<Self>::new_uninit();\n+            let mut node = Box::<Self, _>::new_uninit_in(alloc);\n             // We only need to initialize the data; the edges are MaybeUninit.\n             LeafNode::init(ptr::addr_of_mut!((*node.as_mut_ptr()).data));\n             node.assume_init()\n@@ -213,25 +213,28 @@ unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type>\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    pub fn new_leaf() -> Self {\n-        Self::from_new_leaf(LeafNode::new())\n+    pub fn new_leaf<A: Allocator>(alloc: &A) -> Self {\n+        Self::from_new_leaf(LeafNode::new(alloc))\n     }\n \n-    fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n+    fn from_new_leaf<A: Allocator>(leaf: Box<LeafNode<K, V>, A>) -> Self {\n         NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }\n     }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    fn new_internal(child: Root<K, V>) -> Self {\n-        let mut new_node = unsafe { InternalNode::new() };\n+    fn new_internal<A: Allocator>(child: Root<K, V>, alloc: &A) -> Self {\n+        let mut new_node = unsafe { InternalNode::new(alloc) };\n         new_node.edges[0].write(child.node);\n         unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }\n     }\n \n     /// # Safety\n     /// `height` must not be zero.\n-    unsafe fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n+    unsafe fn from_new_internal<A: Allocator>(\n+        internal: Box<InternalNode<K, V>, A>,\n+        height: usize,\n+    ) -> Self {\n         debug_assert!(height > 0);\n         let node = NonNull::from(Box::leak(internal)).cast();\n         let mut this = NodeRef { height, node, _marker: PhantomData };\n@@ -387,14 +390,15 @@ impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocates the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend(\n+    pub unsafe fn deallocate_and_ascend<A: Allocator>(\n         self,\n+        alloc: &A,\n     ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Internal>, marker::Edge>> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n         unsafe {\n-            Global.deallocate(\n+            alloc.deallocate(\n                 node.cast(),\n                 if height > 0 {\n                     Layout::new::<InternalNode<K, V>>()\n@@ -555,15 +559,18 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Returns a new owned tree, with its own root node that is initially empty.\n-    pub fn new() -> Self {\n-        NodeRef::new_leaf().forget_type()\n+    pub fn new<A: Allocator>(alloc: &A) -> Self {\n+        NodeRef::new_leaf(alloc).forget_type()\n     }\n \n     /// Adds a new internal node with a single edge pointing to the previous root node,\n     /// make that new node the root node, and return it. This increases the height by 1\n     /// and is the opposite of `pop_internal_level`.\n-    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root).forget_type());\n+    pub fn push_internal_level<A: Allocator>(\n+        &mut self,\n+        alloc: &A,\n+    ) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+        super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root, alloc).forget_type());\n \n         // `self.borrow_mut()`, except that we just forgot we're internal now:\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n@@ -578,7 +585,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// it will not invalidate other handles or references to the root node.\n     ///\n     /// Panics if there is no internal level, i.e., if the root node is a leaf.\n-    pub fn pop_internal_level(&mut self) {\n+    pub fn pop_internal_level<A: Allocator>(&mut self, alloc: &A) {\n         assert!(self.height > 0);\n \n         let top = self.node;\n@@ -593,7 +600,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         self.clear_parent_link();\n \n         unsafe {\n-            Global.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n+            alloc.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -862,14 +869,19 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n-    fn insert(mut self, key: K, val: V) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n+    fn insert<A: Allocator>(\n+        mut self,\n+        key: K,\n+        val: V,\n+        alloc: &A,\n+    ) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let val_ptr = self.insert_fit(key, val);\n             (None, val_ptr)\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n-            let mut result = middle.split();\n+            let mut result = middle.split(alloc);\n             let mut insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n@@ -918,11 +930,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// Inserts a new key-value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key-value pair to the right of this edge. This method splits\n     /// the node if there isn't enough room.\n-    fn insert(\n+    fn insert<A: Allocator>(\n         mut self,\n         key: K,\n         val: V,\n         edge: Root<K, V>,\n+        alloc: &A,\n     ) -> Option<SplitResult<'a, K, V, marker::Internal>> {\n         assert!(edge.height == self.node.height - 1);\n \n@@ -932,7 +945,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n-            let mut result = middle.split();\n+            let mut result = middle.split(alloc);\n             let mut insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n@@ -955,19 +968,20 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// If the returned result is some `SplitResult`, the `left` field will be the root node.\n     /// The returned pointer points to the inserted value, which in the case of `SplitResult`\n     /// is in the `left` or `right` tree.\n-    pub fn insert_recursing(\n+    pub fn insert_recursing<A: Allocator>(\n         self,\n         key: K,\n         value: V,\n+        alloc: &A,\n     ) -> (Option<SplitResult<'a, K, V, marker::LeafOrInternal>>, *mut V) {\n-        let (mut split, val_ptr) = match self.insert(key, value) {\n+        let (mut split, val_ptr) = match self.insert(key, value, alloc) {\n             (None, val_ptr) => return (None, val_ptr),\n             (Some(split), val_ptr) => (split.forget_node_type(), val_ptr),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n-                Ok(parent) => match parent.insert(split.kv.0, split.kv.1, split.right) {\n+                Ok(parent) => match parent.insert(split.kv.0, split.kv.1, split.right, alloc) {\n                     None => return (None, val_ptr),\n                     Some(split) => split.forget_node_type(),\n                 },\n@@ -1112,8 +1126,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the key-value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n-    pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n-        let mut new_node = LeafNode::new();\n+    pub fn split<A: Allocator>(mut self, alloc: &A) -> SplitResult<'a, K, V, marker::Leaf> {\n+        let mut new_node = LeafNode::new(alloc);\n \n         let kv = self.split_leaf_data(&mut new_node);\n \n@@ -1144,10 +1158,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key-value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n-    pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n+    pub fn split<A: Allocator>(mut self, alloc: &A) -> SplitResult<'a, K, V, marker::Internal> {\n         let old_len = self.node.len();\n         unsafe {\n-            let mut new_node = InternalNode::new();\n+            let mut new_node = InternalNode::new(alloc);\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             move_to_slice(\n@@ -1252,9 +1266,11 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n         ) -> R,\n         R,\n+        A: Allocator,\n     >(\n         self,\n         result: F,\n+        alloc: &A,\n     ) -> R {\n         let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;\n         let old_parent_len = parent_node.len();\n@@ -1299,9 +1315,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n                 left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n \n-                Global.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                alloc.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n-                Global.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n+                alloc.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n             }\n         }\n         result(parent_node, left_node)\n@@ -1311,34 +1327,41 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     /// the left child node and returns the shrunk parent node.\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_parent(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-        self.do_merge(|parent, _child| parent)\n+    pub fn merge_tracking_parent<A: Allocator>(\n+        self,\n+        alloc: &A,\n+    ) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+        self.do_merge(|parent, _child| parent, alloc)\n     }\n \n     /// Merges the parent's key-value pair and both adjacent child nodes into\n     /// the left child node and returns that child node.\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-        self.do_merge(|_parent, child| child)\n+    pub fn merge_tracking_child<A: Allocator>(\n+        self,\n+        alloc: &A,\n+    ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+        self.do_merge(|_parent, child| child, alloc)\n     }\n \n     /// Merges the parent's key-value pair and both adjacent child nodes into\n     /// the left child node and returns the edge handle in that child node\n     /// where the tracked child edge ended up,\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_child_edge(\n+    pub fn merge_tracking_child_edge<A: Allocator>(\n         self,\n         track_edge_idx: LeftOrRight<usize>,\n+        alloc: &A,\n     ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n         let old_left_len = self.left_child.len();\n         let right_len = self.right_child.len();\n         assert!(match track_edge_idx {\n             LeftOrRight::Left(idx) => idx <= old_left_len,\n             LeftOrRight::Right(idx) => idx <= right_len,\n         });\n-        let child = self.merge_tracking_child();\n+        let child = self.merge_tracking_child(alloc);\n         let new_idx = match track_edge_idx {\n             LeftOrRight::Left(idx) => idx,\n             LeftOrRight::Right(idx) => old_left_len + 1 + idx,"}, {"sha": "c8634e6c06fe35aa49c05d163dfb7ac816ecf7f4", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -1,5 +1,6 @@\n use super::super::navigate;\n use super::*;\n+use crate::alloc::Global;\n use crate::fmt::Debug;\n use crate::string::String;\n \n@@ -67,10 +68,10 @@ fn test_splitpoint() {\n \n #[test]\n fn test_partial_eq() {\n-    let mut root1 = NodeRef::new_leaf();\n+    let mut root1 = NodeRef::new_leaf(&Global);\n     root1.borrow_mut().push(1, ());\n-    let mut root1 = NodeRef::new_internal(root1.forget_type()).forget_type();\n-    let root2 = Root::new();\n+    let mut root1 = NodeRef::new_internal(root1.forget_type(), &Global).forget_type();\n+    let root2 = Root::new(&Global);\n     root1.reborrow().assert_back_pointers();\n     root2.reborrow().assert_back_pointers();\n \n@@ -86,9 +87,9 @@ fn test_partial_eq() {\n     assert!(top_edge_1 == top_edge_1);\n     assert!(top_edge_1 != top_edge_2);\n \n-    root1.pop_internal_level();\n-    unsafe { root1.into_dying().deallocate_and_ascend() };\n-    unsafe { root2.into_dying().deallocate_and_ascend() };\n+    root1.pop_internal_level(&Global);\n+    unsafe { root1.into_dying().deallocate_and_ascend(&Global) };\n+    unsafe { root2.into_dying().deallocate_and_ascend(&Global) };\n }\n \n #[test]"}, {"sha": "693efd1765460d0d0a78ac22f6675bec580e39a4", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -1,26 +1,29 @@\n use super::map::MIN_LEN;\n use super::node::{marker, ForceResult::*, Handle, LeftOrRight::*, NodeRef};\n+use core::alloc::Allocator;\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key-value pair from the tree, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair. It's possible this empties\n     /// a root node that is internal, which the caller should pop from the map\n     /// holding the tree. The caller should also decrement the map's length.\n-    pub fn remove_kv_tracking<F: FnOnce()>(\n+    pub fn remove_kv_tracking<F: FnOnce(), A: Allocator>(\n         self,\n         handle_emptied_internal_root: F,\n+        alloc: &A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         match self.force() {\n-            Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root),\n-            Internal(node) => node.remove_internal_kv(handle_emptied_internal_root),\n+            Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root, alloc),\n+            Internal(node) => node.remove_internal_kv(handle_emptied_internal_root, alloc),\n         }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n-    fn remove_leaf_kv<F: FnOnce()>(\n+    fn remove_leaf_kv<F: FnOnce(), A: Allocator>(\n         self,\n         handle_emptied_internal_root: F,\n+        alloc: &A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let (old_kv, mut pos) = self.remove();\n         let len = pos.reborrow().into_node().len();\n@@ -32,7 +35,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n                 Ok(Left(left_parent_kv)) => {\n                     debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n                     if left_parent_kv.can_merge() {\n-                        left_parent_kv.merge_tracking_child_edge(Right(idx))\n+                        left_parent_kv.merge_tracking_child_edge(Right(idx), alloc)\n                     } else {\n                         debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n                         left_parent_kv.steal_left(idx)\n@@ -41,7 +44,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n                 Ok(Right(right_parent_kv)) => {\n                     debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n                     if right_parent_kv.can_merge() {\n-                        right_parent_kv.merge_tracking_child_edge(Left(idx))\n+                        right_parent_kv.merge_tracking_child_edge(Left(idx), alloc)\n                     } else {\n                         debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n                         right_parent_kv.steal_right(idx)\n@@ -60,7 +63,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             // rearrange the parent through the grandparent, thus change the\n             // link to the parent inside the leaf.\n             if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n-                if !parent.into_node().forget_type().fix_node_and_affected_ancestors() {\n+                if !parent.into_node().forget_type().fix_node_and_affected_ancestors(alloc) {\n                     handle_emptied_internal_root();\n                 }\n             }\n@@ -70,16 +73,17 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n-    fn remove_internal_kv<F: FnOnce()>(\n+    fn remove_internal_kv<F: FnOnce(), A: Allocator>(\n         self,\n         handle_emptied_internal_root: F,\n+        alloc: &A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         // Remove an adjacent KV from its leaf and then put it back in place of\n         // the element we were asked to remove. Prefer the left adjacent KV,\n         // for the reasons listed in `choose_parent_kv`.\n         let left_leaf_kv = self.left_edge().descend().last_leaf_edge().left_kv();\n         let left_leaf_kv = unsafe { left_leaf_kv.ok().unwrap_unchecked() };\n-        let (left_kv, left_hole) = left_leaf_kv.remove_leaf_kv(handle_emptied_internal_root);\n+        let (left_kv, left_hole) = left_leaf_kv.remove_leaf_kv(handle_emptied_internal_root, alloc);\n \n         // The internal node may have been stolen from or merged. Go back right\n         // to find where the original KV ended up."}, {"sha": "aeb5c30dba3465159a5bd7b6ce91bd60d3af240b", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 202, "deletions": 74, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -3,16 +3,20 @@\n \n use crate::vec::Vec;\n use core::borrow::Borrow;\n-use core::cmp::Ordering::{Equal, Greater, Less};\n+use core::cmp::Ordering::{self, Equal, Greater, Less};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n+use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n+use core::mem::ManuallyDrop;\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n use super::map::{BTreeMap, Keys};\n use super::merge_iter::MergeIterInner;\n use super::Recover;\n \n+use crate::alloc::{Allocator, Global};\n+\n // FIXME(conventions): implement bounded iterators\n \n /// An ordered set based on a B-Tree.\n@@ -71,15 +75,48 @@ use super::Recover;\n ///\n /// let set = BTreeSet::from([1, 2, 3]);\n /// ```\n-#[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n-pub struct BTreeSet<T> {\n-    map: BTreeMap<T, ()>,\n+pub struct BTreeSet<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    map: BTreeMap<T, (), A>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for BTreeSet<T> {\n+impl<T: Hash, A: Allocator> Hash for BTreeSet<T, A> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.map.hash(state)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialEq, A: Allocator> PartialEq for BTreeSet<T, A> {\n+    fn eq(&self, other: &BTreeSet<T, A>) -> bool {\n+        self.map.eq(&other.map)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq, A: Allocator> Eq for BTreeSet<T, A> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd, A: Allocator> PartialOrd for BTreeSet<T, A> {\n+    fn partial_cmp(&self, other: &BTreeSet<T, A>) -> Option<Ordering> {\n+        self.map.partial_cmp(&other.map)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord, A: Allocator> Ord for BTreeSet<T, A> {\n+    fn cmp(&self, other: &BTreeSet<T, A>) -> Ordering {\n+        self.map.cmp(&other.map)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone, A: Allocator + Clone> Clone for BTreeSet<T, A> {\n     fn clone(&self) -> Self {\n         BTreeSet { map: self.map.clone() }\n     }\n@@ -117,8 +154,11 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n /// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct IntoIter<T> {\n-    iter: super::map::IntoIter<T, ()>,\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    iter: super::map::IntoIter<T, (), A>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -143,11 +183,14 @@ pub struct Range<'a, T: 'a> {\n #[must_use = \"this returns the difference as an iterator, \\\n               without modifying either input set\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a, T: 'a> {\n-    inner: DifferenceInner<'a, T>,\n+pub struct Difference<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    inner: DifferenceInner<'a, T, A>,\n }\n-#[derive(Debug)]\n-enum DifferenceInner<'a, T: 'a> {\n+enum DifferenceInner<'a, T: 'a, A: Allocator> {\n     Stitch {\n         // iterate all of `self` and some of `other`, spotting matches along the way\n         self_iter: Iter<'a, T>,\n@@ -156,13 +199,32 @@ enum DifferenceInner<'a, T: 'a> {\n     Search {\n         // iterate `self`, look up in `other`\n         self_iter: Iter<'a, T>,\n-        other_set: &'a BTreeSet<T>,\n+        other_set: &'a BTreeSet<T, A>,\n     },\n     Iterate(Iter<'a, T>), // simply produce all elements in `self`\n }\n \n+// Explicit Debug impl necessary because of issue #26925\n+impl<T: Debug, A: Allocator> Debug for DifferenceInner<'_, T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            DifferenceInner::Stitch { self_iter, other_iter } => f\n+                .debug_struct(\"Stitch\")\n+                .field(\"self_iter\", self_iter)\n+                .field(\"other_iter\", other_iter)\n+                .finish(),\n+            DifferenceInner::Search { self_iter, other_set } => f\n+                .debug_struct(\"Search\")\n+                .field(\"self_iter\", self_iter)\n+                .field(\"other_iter\", other_set)\n+                .finish(),\n+            DifferenceInner::Iterate(x) => f.debug_tuple(\"Iterate\").field(x).finish(),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Difference<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n@@ -195,11 +257,14 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n #[must_use = \"this returns the intersection as an iterator, \\\n               without modifying either input set\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a, T: 'a> {\n-    inner: IntersectionInner<'a, T>,\n+pub struct Intersection<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    inner: IntersectionInner<'a, T, A>,\n }\n-#[derive(Debug)]\n-enum IntersectionInner<'a, T: 'a> {\n+enum IntersectionInner<'a, T: 'a, A: Allocator> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n         a: Iter<'a, T>,\n@@ -208,13 +273,30 @@ enum IntersectionInner<'a, T: 'a> {\n     Search {\n         // iterate a small set, look up in the large set\n         small_iter: Iter<'a, T>,\n-        large_set: &'a BTreeSet<T>,\n+        large_set: &'a BTreeSet<T, A>,\n     },\n     Answer(Option<&'a T>), // return a specific element or emptiness\n }\n \n+// Explicit Debug impl necessary because of issue #26925\n+impl<T: Debug, A: Allocator> Debug for IntersectionInner<'_, T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            IntersectionInner::Stitch { a, b } => {\n+                f.debug_struct(\"Stitch\").field(\"a\", a).field(\"b\", b).finish()\n+            }\n+            IntersectionInner::Search { small_iter, large_set } => f\n+                .debug_struct(\"Search\")\n+                .field(\"small_iter\", small_iter)\n+                .field(\"large_set\", large_set)\n+                .finish(),\n+            IntersectionInner::Answer(x) => f.debug_tuple(\"Answer\").field(x).finish(),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n+impl<T: Debug, A: Allocator> Debug for Intersection<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n@@ -265,6 +347,26 @@ impl<T> BTreeSet<T> {\n     pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n+}\n+\n+impl<T, A: Allocator> BTreeSet<T, A> {\n+    /// Makes a new `BTreeSet` with a reasonable choice of B.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(unused_mut)]\n+    /// # #![feature(allocator_api)]\n+    /// # #![feature(btreemap_alloc)]\n+    /// use std::collections::BTreeSet;\n+    /// use std::alloc::Global;\n+    ///\n+    /// let mut set: BTreeSet<i32> = BTreeSet::new_in(Global);\n+    /// ```\n+    #[unstable(feature = \"btreemap_alloc\", issue = \"32838\")]\n+    pub fn new_in(alloc: A) -> BTreeSet<T, A> {\n+        BTreeSet { map: BTreeMap::new_in(alloc) }\n+    }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the set.\n     /// The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will\n@@ -319,7 +421,7 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T>\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Difference<'a, T, A>\n     where\n         T: Ord,\n     {\n@@ -380,7 +482,10 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>) -> SymmetricDifference<'a, T>\n+    pub fn symmetric_difference<'a>(\n+        &'a self,\n+        other: &'a BTreeSet<T, A>,\n+    ) -> SymmetricDifference<'a, T>\n     where\n         T: Ord,\n     {\n@@ -408,7 +513,7 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T>\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Intersection<'a, T, A>\n     where\n         T: Ord,\n     {\n@@ -459,7 +564,7 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T>\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Union<'a, T>\n     where\n         T: Ord,\n     {\n@@ -479,7 +584,10 @@ impl<T> BTreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        A: Clone,\n+    {\n         self.map.clear()\n     }\n \n@@ -551,7 +659,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool\n+    pub fn is_disjoint(&self, other: &BTreeSet<T, A>) -> bool\n     where\n         T: Ord,\n     {\n@@ -577,7 +685,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool\n+    pub fn is_subset(&self, other: &BTreeSet<T, A>) -> bool\n     where\n         T: Ord,\n     {\n@@ -657,7 +765,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool\n+    pub fn is_superset(&self, other: &BTreeSet<T, A>) -> bool\n     where\n         T: Ord,\n     {\n@@ -931,6 +1039,7 @@ impl<T> BTreeSet<T> {\n     pub fn append(&mut self, other: &mut Self)\n     where\n         T: Ord,\n+        A: Clone,\n     {\n         self.map.append(&mut other.map);\n     }\n@@ -968,6 +1077,7 @@ impl<T> BTreeSet<T> {\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, value: &Q) -> Self\n     where\n         T: Borrow<Q> + Ord,\n+        A: Clone,\n     {\n         BTreeSet { map: self.map.split_off(value) }\n     }\n@@ -1002,12 +1112,13 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n     /// ```\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F, A>\n     where\n         T: Ord,\n         F: 'a + FnMut(&T) -> bool,\n     {\n-        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+        let (inner, alloc) = self.map.drain_filter_inner();\n+        DrainFilter { pred, inner, alloc }\n     }\n \n     /// Gets an iterator that visits the elements in the `BTreeSet` in ascending\n@@ -1093,14 +1204,14 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n \n         // use stable sort to preserve the insertion order.\n         inputs.sort();\n-        BTreeSet::from_sorted_iter(inputs.into_iter())\n+        BTreeSet::from_sorted_iter(inputs.into_iter(), Global)\n     }\n }\n \n-impl<T: Ord> BTreeSet<T> {\n-    fn from_sorted_iter<I: Iterator<Item = T>>(iter: I) -> BTreeSet<T> {\n+impl<T: Ord, A: Allocator> BTreeSet<T, A> {\n+    fn from_sorted_iter<I: Iterator<Item = T>>(iter: I, alloc: A) -> BTreeSet<T, A> {\n         let iter = iter.map(|k| (k, ()));\n-        let map = BTreeMap::bulk_build_from_sorted_iter(iter);\n+        let map = BTreeMap::bulk_build_from_sorted_iter(iter, alloc);\n         BTreeSet { map }\n     }\n }\n@@ -1124,15 +1235,15 @@ impl<T: Ord, const N: usize> From<[T; N]> for BTreeSet<T> {\n         // use stable sort to preserve the insertion order.\n         arr.sort();\n         let iter = IntoIterator::into_iter(arr).map(|k| (k, ()));\n-        let map = BTreeMap::bulk_build_from_sorted_iter(iter);\n+        let map = BTreeMap::bulk_build_from_sorted_iter(iter, Global);\n         BTreeSet { map }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for BTreeSet<T> {\n+impl<T, A: Allocator> IntoIterator for BTreeSet<T, A> {\n     type Item = T;\n-    type IntoIter = IntoIter<T>;\n+    type IntoIter = IntoIter<T, A>;\n \n     /// Gets an iterator for moving out the `BTreeSet`'s contents.\n     ///\n@@ -1146,13 +1257,13 @@ impl<T> IntoIterator for BTreeSet<T> {\n     /// let v: Vec<_> = set.into_iter().collect();\n     /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T, A> {\n         IntoIter { iter: self.map.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a BTreeSet<T, A> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1163,17 +1274,22 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n \n /// An iterator produced by calling `drain_filter` on BTreeSet.\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-pub struct DrainFilter<'a, T, F>\n-where\n+pub struct DrainFilter<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n     T: 'a,\n     F: 'a + FnMut(&T) -> bool,\n {\n     pred: F,\n     inner: super::map::DrainFilterInner<'a, T, ()>,\n+    alloc: &'a A,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F> Drop for DrainFilter<'_, T, F>\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&T) -> bool,\n {\n@@ -1183,7 +1299,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F> fmt::Debug for DrainFilter<'_, T, F>\n+impl<T, F, A: Allocator> fmt::Debug for DrainFilter<'_, T, F, A>\n where\n     T: fmt::Debug,\n     F: FnMut(&T) -> bool,\n@@ -1194,7 +1310,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F> Iterator for DrainFilter<'_, T, F>\n+impl<'a, T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n where\n     F: 'a + FnMut(&T) -> bool,\n {\n@@ -1203,7 +1319,7 @@ where\n     fn next(&mut self) -> Option<T> {\n         let pred = &mut self.pred;\n         let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n-        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+        self.inner.next(&mut mapped_pred, &self.alloc).map(|(k, _)| k)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -1212,10 +1328,10 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F> FusedIterator for DrainFilter<'_, T, F> where F: FnMut(&T) -> bool {}\n+impl<T, F, A: Allocator> FusedIterator for DrainFilter<'_, T, F, A> where F: FnMut(&T) -> bool {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Extend<T> for BTreeSet<T> {\n+impl<T: Ord, A: Allocator> Extend<T> for BTreeSet<T, A> {\n     #[inline]\n     fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n         iter.into_iter().for_each(move |elem| {\n@@ -1230,7 +1346,7 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n+impl<'a, T: 'a + Ord + Copy, A: Allocator> Extend<&'a T> for BTreeSet<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n@@ -1250,8 +1366,8 @@ impl<T> Default for BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord + Clone> Sub<&BTreeSet<T>> for &BTreeSet<T> {\n-    type Output = BTreeSet<T>;\n+impl<T: Ord + Clone, A: Allocator + Clone> Sub<&BTreeSet<T, A>> for &BTreeSet<T, A> {\n+    type Output = BTreeSet<T, A>;\n \n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -1266,14 +1382,17 @@ impl<T: Ord + Clone> Sub<&BTreeSet<T>> for &BTreeSet<T> {\n     /// let result = &a - &b;\n     /// assert_eq!(result, BTreeSet::from([1, 2]));\n     /// ```\n-    fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        BTreeSet::from_sorted_iter(self.difference(rhs).cloned())\n+    fn sub(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {\n+        BTreeSet::from_sorted_iter(\n+            self.difference(rhs).cloned(),\n+            ManuallyDrop::into_inner(self.map.alloc.clone()),\n+        )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord + Clone> BitXor<&BTreeSet<T>> for &BTreeSet<T> {\n-    type Output = BTreeSet<T>;\n+impl<T: Ord + Clone, A: Allocator + Clone> BitXor<&BTreeSet<T, A>> for &BTreeSet<T, A> {\n+    type Output = BTreeSet<T, A>;\n \n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -1288,14 +1407,17 @@ impl<T: Ord + Clone> BitXor<&BTreeSet<T>> for &BTreeSet<T> {\n     /// let result = &a ^ &b;\n     /// assert_eq!(result, BTreeSet::from([1, 4]));\n     /// ```\n-    fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        BTreeSet::from_sorted_iter(self.symmetric_difference(rhs).cloned())\n+    fn bitxor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {\n+        BTreeSet::from_sorted_iter(\n+            self.symmetric_difference(rhs).cloned(),\n+            ManuallyDrop::into_inner(self.map.alloc.clone()),\n+        )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord + Clone> BitAnd<&BTreeSet<T>> for &BTreeSet<T> {\n-    type Output = BTreeSet<T>;\n+impl<T: Ord + Clone, A: Allocator + Clone> BitAnd<&BTreeSet<T, A>> for &BTreeSet<T, A> {\n+    type Output = BTreeSet<T, A>;\n \n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -1310,14 +1432,17 @@ impl<T: Ord + Clone> BitAnd<&BTreeSet<T>> for &BTreeSet<T> {\n     /// let result = &a & &b;\n     /// assert_eq!(result, BTreeSet::from([2, 3]));\n     /// ```\n-    fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        BTreeSet::from_sorted_iter(self.intersection(rhs).cloned())\n+    fn bitand(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {\n+        BTreeSet::from_sorted_iter(\n+            self.intersection(rhs).cloned(),\n+            ManuallyDrop::into_inner(self.map.alloc.clone()),\n+        )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord + Clone> BitOr<&BTreeSet<T>> for &BTreeSet<T> {\n-    type Output = BTreeSet<T>;\n+impl<T: Ord + Clone, A: Allocator + Clone> BitOr<&BTreeSet<T, A>> for &BTreeSet<T, A> {\n+    type Output = BTreeSet<T, A>;\n \n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -1332,13 +1457,16 @@ impl<T: Ord + Clone> BitOr<&BTreeSet<T>> for &BTreeSet<T> {\n     /// let result = &a | &b;\n     /// assert_eq!(result, BTreeSet::from([1, 2, 3, 4, 5]));\n     /// ```\n-    fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        BTreeSet::from_sorted_iter(self.union(rhs).cloned())\n+    fn bitor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {\n+        BTreeSet::from_sorted_iter(\n+            self.union(rhs).cloned(),\n+            ManuallyDrop::into_inner(self.map.alloc.clone()),\n+        )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug> Debug for BTreeSet<T> {\n+impl<T: Debug, A: Allocator> Debug for BTreeSet<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_set().entries(self.iter()).finish()\n     }\n@@ -1391,7 +1519,7 @@ impl<T> ExactSizeIterator for Iter<'_, T> {\n impl<T> FusedIterator for Iter<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n@@ -1403,20 +1531,20 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|(k, _)| k)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n     fn len(&self) -> usize {\n         self.iter.len()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<T> Clone for Range<'_, T> {\n@@ -1457,7 +1585,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n impl<T> FusedIterator for Range<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Difference<'_, T> {\n+impl<T, A: Allocator + Clone> Clone for Difference<'_, T, A> {\n     fn clone(&self) -> Self {\n         Difference {\n             inner: match &self.inner {\n@@ -1474,7 +1602,7 @@ impl<T> Clone for Difference<'_, T> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Ord> Iterator for Difference<'a, T> {\n+impl<'a, T: Ord, A: Allocator> Iterator for Difference<'a, T, A> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n@@ -1521,7 +1649,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T: Ord> FusedIterator for Difference<'_, T> {}\n+impl<T: Ord, A: Allocator> FusedIterator for Difference<'_, T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n@@ -1559,7 +1687,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n impl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Intersection<'_, T> {\n+impl<T, A: Allocator + Clone> Clone for Intersection<'_, T, A> {\n     fn clone(&self) -> Self {\n         Intersection {\n             inner: match &self.inner {\n@@ -1575,7 +1703,7 @@ impl<T> Clone for Intersection<'_, T> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n+impl<'a, T: Ord, A: Allocator> Iterator for Intersection<'a, T, A> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n@@ -1616,7 +1744,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n+impl<T: Ord, A: Allocator> FusedIterator for Intersection<'_, T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {"}, {"sha": "3ccd1d1d8619b8d6bbfc5ab6eb6f5bad3a214552", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5951a6e5c64d9348a96e7c161d07b221b26dd2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=dc5951a6e5c64d9348a96e7c161d07b221b26dd2", "patch": "@@ -1,5 +1,6 @@\n use super::node::{ForceResult::*, Root};\n use super::search::SearchResult::*;\n+use core::alloc::Allocator;\n use core::borrow::Borrow;\n \n impl<K, V> Root<K, V> {\n@@ -28,12 +29,12 @@ impl<K, V> Root<K, V> {\n     /// and if the ordering of `Q` corresponds to that of `K`.\n     /// If `self` respects all `BTreeMap` tree invariants, then both\n     /// `self` and the returned tree will respect those invariants.\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n+    pub fn split_off<Q: ?Sized + Ord, A: Allocator>(&mut self, key: &Q, alloc: &A) -> Self\n     where\n         K: Borrow<Q>,\n     {\n         let left_root = self;\n-        let mut right_root = Root::new_pillar(left_root.height());\n+        let mut right_root = Root::new_pillar(left_root.height(), alloc);\n         let mut left_node = left_root.borrow_mut();\n         let mut right_node = right_root.borrow_mut();\n \n@@ -56,16 +57,16 @@ impl<K, V> Root<K, V> {\n             }\n         }\n \n-        left_root.fix_right_border();\n-        right_root.fix_left_border();\n+        left_root.fix_right_border(alloc);\n+        right_root.fix_left_border(alloc);\n         right_root\n     }\n \n     /// Creates a tree consisting of empty nodes.\n-    fn new_pillar(height: usize) -> Self {\n-        let mut root = Root::new();\n+    fn new_pillar<A: Allocator>(height: usize, alloc: &A) -> Self {\n+        let mut root = Root::new(alloc);\n         for _ in 0..height {\n-            root.push_internal_level();\n+            root.push_internal_level(alloc);\n         }\n         root\n     }"}]}