{"sha": "45112aa8c0a55f003acc3b20646e840909dea08f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MTEyYWE4YzBhNTVmMDAzYWNjM2IyMDY0NmU4NDA5MDlkZWEwOGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-24T19:21:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-24T19:21:25Z"}, "message": "internal: rename hypothetical -> speculative\n\nLets steal this good naming from Roslyn before I forget about it yet\nagain.", "tree": {"sha": "93437bb5e3f358bd183fb7167fb1498e5f4e8247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93437bb5e3f358bd183fb7167fb1498e5f4e8247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45112aa8c0a55f003acc3b20646e840909dea08f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45112aa8c0a55f003acc3b20646e840909dea08f", "html_url": "https://github.com/rust-lang/rust/commit/45112aa8c0a55f003acc3b20646e840909dea08f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45112aa8c0a55f003acc3b20646e840909dea08f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3926f60cb525592400018b0afb0c0553dabfdb32", "url": "https://api.github.com/repos/rust-lang/rust/commits/3926f60cb525592400018b0afb0c0553dabfdb32", "html_url": "https://github.com/rust-lang/rust/commit/3926f60cb525592400018b0afb0c0553dabfdb32"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "8d3c43d082e7c252d436660b6685b9624859d1a7", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=45112aa8c0a55f003acc3b20646e840909dea08f", "patch": "@@ -120,10 +120,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n-        hypothetical_args: &ast::TokenTree,\n+        speculative_args: &ast::TokenTree,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n-        self.imp.speculative_expand(actual_macro_call, hypothetical_args, token_to_map)\n+        self.imp.speculative_expand(actual_macro_call, speculative_args, token_to_map)\n     }\n \n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n@@ -335,7 +335,7 @@ impl<'db> SemanticsImpl<'db> {\n     fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n-        hypothetical_args: &ast::TokenTree,\n+        speculative_args: &ast::TokenTree,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n         let sa = self.analyze(actual_macro_call.syntax());\n@@ -344,10 +344,10 @@ impl<'db> SemanticsImpl<'db> {\n         let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n             sa.resolver.resolve_path_as_macro(self.db.upcast(), &path)\n         })?;\n-        hir_expand::db::expand_hypothetical(\n+        hir_expand::db::expand_speculative(\n             self.db.upcast(),\n             macro_call_id,\n-            hypothetical_args,\n+            speculative_args,\n             token_to_map,\n         )\n     }"}, {"sha": "db9d19b0c1c1a7ff9fc3f3caafb0cd0e4b144fe3", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=45112aa8c0a55f003acc3b20646e840909dea08f", "patch": "@@ -131,28 +131,28 @@ pub trait AstDatabase: SourceDatabase {\n /// used for completion, where we want to see what 'would happen' if we insert a\n /// token. The `token_to_map` mapped down into the expansion, with the mapped\n /// token returned.\n-pub fn expand_hypothetical(\n+pub fn expand_speculative(\n     db: &dyn AstDatabase,\n     actual_macro_call: MacroCallId,\n-    hypothetical_args: &ast::TokenTree,\n+    speculative_args: &ast::TokenTree,\n     token_to_map: SyntaxToken,\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n-    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(hypothetical_args.syntax());\n+    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(speculative_args.syntax());\n     let range =\n-        token_to_map.text_range().checked_sub(hypothetical_args.syntax().text_range().start())?;\n+        token_to_map.text_range().checked_sub(speculative_args.syntax().text_range().start())?;\n     let token_id = tmap_1.token_by_range(range)?;\n \n     let macro_def = {\n         let loc: MacroCallLoc = db.lookup_intern_macro(actual_macro_call);\n         db.macro_def(loc.def)?\n     };\n \n-    let hypothetical_expansion = macro_def.expand(db, actual_macro_call, &tt);\n+    let speculative_expansion = macro_def.expand(db, actual_macro_call, &tt);\n \n     let fragment_kind = macro_fragment_kind(db, actual_macro_call);\n \n     let (node, tmap_2) =\n-        mbe::token_tree_to_syntax_node(&hypothetical_expansion.value, fragment_kind).ok()?;\n+        mbe::token_tree_to_syntax_node(&speculative_expansion.value, fragment_kind).ok()?;\n \n     let token_id = macro_def.map_id_down(token_id);\n     let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n@@ -325,7 +325,7 @@ fn macro_expand_with_arg(\n     if let Some(eager) = &loc.eager {\n         if arg.is_some() {\n             return ExpandResult::str_err(\n-                \"hypothetical macro expansion not implemented for eager macro\".to_owned(),\n+                \"speculative macro expansion not implemented for eager macro\".to_owned(),\n             );\n         } else {\n             return ExpandResult {"}, {"sha": "c83933c73d492258194b3f9811b585854e686fb7", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=45112aa8c0a55f003acc3b20646e840909dea08f", "patch": "@@ -1026,7 +1026,7 @@ pub(crate) fn trait_environment_query(\n     };\n     if let Some(AssocContainerId::TraitId(trait_id)) = container {\n         // add `Self: Trait<T1, T2, ...>` to the environment in trait\n-        // function default implementations (and hypothetical code\n+        // function default implementations (and speculative code\n         // inside consts or type aliases)\n         cov_mark::hit!(trait_self_implements_self);\n         let substs = TyBuilder::type_params_subst(db, trait_id);"}, {"sha": "2f3fb17100fc112d68b2fd3c4c297bd327e23468", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=45112aa8c0a55f003acc3b20646e840909dea08f", "patch": "@@ -196,46 +196,46 @@ impl<'a> CompletionContext<'a> {\n         };\n \n         let mut original_file = original_file.syntax().clone();\n-        let mut hypothetical_file = file_with_fake_ident.syntax().clone();\n+        let mut speculative_file = file_with_fake_ident.syntax().clone();\n         let mut offset = position.offset;\n         let mut fake_ident_token = fake_ident_token;\n \n         // Are we inside a macro call?\n         while let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n             find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n-            find_node_at_offset::<ast::MacroCall>(&hypothetical_file, offset),\n+            find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n         ) {\n             if actual_macro_call.path().as_ref().map(|s| s.syntax().text())\n                 != macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text())\n             {\n                 break;\n             }\n-            let hypothetical_args = match macro_call_with_fake_ident.token_tree() {\n+            let speculative_args = match macro_call_with_fake_ident.token_tree() {\n                 Some(tt) => tt,\n                 None => break,\n             };\n-            if let (Some(actual_expansion), Some(hypothetical_expansion)) = (\n+            if let (Some(actual_expansion), Some(speculative_expansion)) = (\n                 ctx.sema.expand(&actual_macro_call),\n                 ctx.sema.speculative_expand(\n                     &actual_macro_call,\n-                    &hypothetical_args,\n+                    &speculative_args,\n                     fake_ident_token,\n                 ),\n             ) {\n-                let new_offset = hypothetical_expansion.1.text_range().start();\n+                let new_offset = speculative_expansion.1.text_range().start();\n                 if new_offset > actual_expansion.text_range().end() {\n                     break;\n                 }\n                 original_file = actual_expansion;\n-                hypothetical_file = hypothetical_expansion.0;\n-                fake_ident_token = hypothetical_expansion.1;\n+                speculative_file = speculative_expansion.0;\n+                fake_ident_token = speculative_expansion.1;\n                 offset = new_offset;\n             } else {\n                 break;\n             }\n         }\n-        ctx.fill_keyword_patterns(&hypothetical_file, offset);\n-        ctx.fill(&original_file, hypothetical_file, offset);\n+        ctx.fill_keyword_patterns(&speculative_file, offset);\n+        ctx.fill(&original_file, speculative_file, offset);\n         Some(ctx)\n     }\n "}, {"sha": "1152a985023fabb9605764275d7991d02c8a8a45", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45112aa8c0a55f003acc3b20646e840909dea08f/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=45112aa8c0a55f003acc3b20646e840909dea08f", "patch": "@@ -107,7 +107,7 @@ pub use crate::{\n /// identifier prefix/fuzzy match should be done higher in the stack, together\n /// with ordering of completions (currently this is done by the client).\n ///\n-/// # Hypothetical Completion Problem\n+/// # Speculative Completion Problem\n ///\n /// There's a curious unsolved problem in the current implementation. Often, you\n /// want to compute completions on a *slightly different* text document.\n@@ -121,7 +121,7 @@ pub use crate::{\n /// doesn't allow such \"phantom\" inputs.\n ///\n /// Another case where this would be instrumental is macro expansion. We want to\n-/// insert a fake ident and re-expand code. There's `expand_hypothetical` as a\n+/// insert a fake ident and re-expand code. There's `expand_speculative` as a\n /// work-around for this.\n ///\n /// A different use-case is completion of injection (examples and links in doc"}]}