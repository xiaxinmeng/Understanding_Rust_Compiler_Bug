{"sha": "34a6fcf19566e5015c1ef4c144a408a2f182cf4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YTZmY2YxOTU2NmU1MDE1YzFlZjRjMTQ0YTQwOGEyZjE4MmNmNGQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-12-19T10:37:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-12-19T11:07:17Z"}, "message": "debuginfo: Clean the debuginfo module up a bit.", "tree": {"sha": "28eef37a60643bad36fb0bf7b25e5af661a0683a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28eef37a60643bad36fb0bf7b25e5af661a0683a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34a6fcf19566e5015c1ef4c144a408a2f182cf4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34a6fcf19566e5015c1ef4c144a408a2f182cf4d", "html_url": "https://github.com/rust-lang/rust/commit/34a6fcf19566e5015c1ef4c144a408a2f182cf4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34a6fcf19566e5015c1ef4c144a408a2f182cf4d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0481147184a8ee70f066423dc077ffa0bd821b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0481147184a8ee70f066423dc077ffa0bd821b5", "html_url": "https://github.com/rust-lang/rust/commit/b0481147184a8ee70f066423dc077ffa0bd821b5"}], "stats": {"total": 162, "additions": 88, "deletions": 74}, "files": [{"sha": "1091a684b2328eeef6e705b5cdc8b14d16dce232", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/34a6fcf19566e5015c1ef4c144a408a2f182cf4d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34a6fcf19566e5015c1ef4c144a408a2f182cf4d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=34a6fcf19566e5015c1ef4c144a408a2f182cf4d", "patch": "@@ -182,7 +182,6 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n-use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -681,12 +680,8 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    repr: FunctionDebugContextRepr,\n-}\n-\n-enum FunctionDebugContextRepr {\n-    DebugInfo(Box<FunctionDebugContextData>),\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -696,13 +691,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match self.repr {\n-            DebugInfo(box ref data) => data,\n-            DebugInfoDisabled => {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionWithoutDebugInfo => {\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -846,6 +841,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -854,11 +851,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n-        let var_ident = path1.node;\n-\n-        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -867,10 +863,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n+                                      Referenced variable location is not an alloca!\");\n+        }\n+\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident,\n+                      var_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -983,7 +984,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_type = match binding.trmode {\n+    let var_access = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -1000,27 +1001,31 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_type,\n+                  var_access,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n-\n-    let def_map = &cx.tcx().def_map;\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    let def_map = &bcx.tcx().def_map;\n+    let scope_metadata = bcx\n+                         .fcx\n+                         .debug_context\n+                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .fn_metadata;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1029,40 +1034,47 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                    Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n+            let counter = &bcx\n+                          .fcx\n+                          .debug_context\n+                          .get_ref(bcx.ccx(), span)\n+                          .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      path1.node,\n-                      llarg.ty,\n+                      var_ident.node,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llarg.val },\n+                      DirectVariable { alloca: datum.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n /// Creates debug information for the given for-loop variable.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// loop variable in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n     let def_map = &bcx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, spanned_ident| {\n-        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1079,7 +1091,7 @@ pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      spanned_ident.node,\n+                      var_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -1156,13 +1168,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context.repr {\n-        DebugInfoDisabled => return,\n-        FunctionWithoutDebugInfo => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        DebugInfo(box ref function_debug_context) => {\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1199,8 +1211,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context.repr {\n-        DebugInfo(box ref data) => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1218,7 +1230,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext { repr: DebugInfoDisabled };\n+        return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1228,7 +1240,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1238,7 +1250,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n             match item.node {\n@@ -1255,9 +1267,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1296,9 +1306,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1319,7 +1327,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1328,7 +1336,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let loc = span_start(cx, span);\n@@ -1395,22 +1403,23 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n+    let scope_map = create_scope_map(cx,\n+                                     fn_decl.inputs.as_slice(),\n+                                     &*top_level_block,\n+                                     fn_metadata,\n+                                     fn_ast_id);\n+\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap::new()),\n+        scope_map: RefCell::new(scope_map),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    populate_scope_map(cx,\n-                       fn_decl.inputs.as_slice(),\n-                       &*top_level_block,\n-                       fn_metadata,\n-                       fn_ast_id,\n-                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3176,8 +3185,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context.repr {\n-        DebugInfo(_) => false,\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n         _ => true\n     }\n }\n@@ -3211,12 +3220,14 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn populate_scope_map(cx: &CrateContext,\n-                      args: &[ast::Arg],\n-                      fn_entry_block: &ast::Block,\n-                      fn_metadata: DISubprogram,\n-                      fn_ast_id: ast::NodeId,\n-                      scope_map: &mut NodeMap<DIScope>) {\n+fn create_scope_map(cx: &CrateContext,\n+                    args: &[ast::Arg],\n+                    fn_entry_block: &ast::Block,\n+                    fn_metadata: DISubprogram,\n+                    fn_ast_id: ast::NodeId)\n+                 -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap::new();\n+\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3242,11 +3253,14 @@ fn populate_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   scope_map,\n+                   &mut scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n+    return scope_map;\n+\n+\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3482,7 +3496,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3568,7 +3582,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3585,7 +3599,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3610,7 +3624,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n "}]}