{"sha": "1733a61141d125beb45587dd89d54cd4a01cdd5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MzNhNjExNDFkMTI1YmViNDU1ODdkZDg5ZDU0Y2Q0YTAxY2RkNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-06T00:44:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-06T00:44:21Z"}, "message": "Auto merge of #48456 - mark-i-m:whitelist, r=alexcrichton\n\nWhitelist rustc dependencies\n\nAs per https://internals.rust-lang.org/t/rustc-dependency-policy/6537/8?u=nikomatsakis\n\ncc @alexcrichton @nikomatsakis", "tree": {"sha": "b424ebbcb837730682c0ccd4da99e083f524512b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b424ebbcb837730682c0ccd4da99e083f524512b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1733a61141d125beb45587dd89d54cd4a01cdd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1733a61141d125beb45587dd89d54cd4a01cdd5a", "html_url": "https://github.com/rust-lang/rust/commit/1733a61141d125beb45587dd89d54cd4a01cdd5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1733a61141d125beb45587dd89d54cd4a01cdd5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9334404f06a188854af33835a0efe1e834e4ac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9334404f06a188854af33835a0efe1e834e4ac4", "html_url": "https://github.com/rust-lang/rust/commit/c9334404f06a188854af33835a0efe1e834e4ac4"}, {"sha": "e5d292013be6a0074d185e0de4c563545a4ed755", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d292013be6a0074d185e0de4c563545a4ed755", "html_url": "https://github.com/rust-lang/rust/commit/e5d292013be6a0074d185e0de4c563545a4ed755"}], "stats": {"total": 270, "additions": 243, "deletions": 27}, "files": [{"sha": "5e7909ff43552a8a08b7f34ef307862e65d0341f", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -2585,6 +2585,11 @@ dependencies = [\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"time\""}, {"sha": "48490493525f971708c1781b4a2fb1a984a1c0ba", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -528,6 +528,7 @@ impl Step for Tidy {\n         println!(\"tidy check ({})\", host);\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(&build.initial_cargo);\n         if !build.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }"}, {"sha": "f7b491823f838b3584c32f4e8d52545aff987813", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -2,3 +2,8 @@\n name = \"tidy\"\n version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]\n+serde = \"1.0.8\"\n+serde_derive = \"1.0.8\"\n+serde_json = \"1.0.2\""}, {"sha": "f40c7a72a452ec63e97267dc5af8fb16108ab585", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 222, "deletions": 26, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -10,9 +10,13 @@\n \n //! Check license of third-party deps by inspecting src/vendor\n \n+use std::collections::{BTreeSet, HashSet};\n use std::fs::File;\n use std::io::Read;\n use std::path::Path;\n+use std::process::Command;\n+\n+use serde_json;\n \n static LICENSES: &'static [&'static str] = &[\n     \"MIT/Apache-2.0\",\n@@ -24,52 +28,182 @@ static LICENSES: &'static [&'static str] = &[\n     \"Unlicense/MIT\",\n ];\n \n-// These are exceptions to Rust's permissive licensing policy, and\n-// should be considered bugs. Exceptions are only allowed in Rust\n-// tooling. It is _crucial_ that no exception crates be dependencies\n-// of the Rust runtime (std / test).\n+/// These are exceptions to Rust's permissive licensing policy, and\n+/// should be considered bugs. Exceptions are only allowed in Rust\n+/// tooling. It is _crucial_ that no exception crates be dependencies\n+/// of the Rust runtime (std / test).\n static EXCEPTIONS: &'static [&'static str] = &[\n-    \"mdbook\", // MPL2, mdbook\n-    \"openssl\", // BSD+advertising clause, cargo, mdbook\n-    \"pest\", // MPL2, mdbook via handlebars\n-    \"thread-id\", // Apache-2.0, mdbook\n-    \"toml-query\", // MPL-2.0, mdbook\n-    \"is-match\", // MPL-2.0, mdbook\n-    \"cssparser\", // MPL-2.0, rustdoc\n-    \"smallvec\", // MPL-2.0, rustdoc\n+    \"mdbook\",             // MPL2, mdbook\n+    \"openssl\",            // BSD+advertising clause, cargo, mdbook\n+    \"pest\",               // MPL2, mdbook via handlebars\n+    \"thread-id\",          // Apache-2.0, mdbook\n+    \"toml-query\",         // MPL-2.0, mdbook\n+    \"is-match\",           // MPL-2.0, mdbook\n+    \"cssparser\",          // MPL-2.0, rustdoc\n+    \"smallvec\",           // MPL-2.0, rustdoc\n     \"fuchsia-zircon-sys\", // BSD-3-Clause, rustdoc, rustc, cargo\n-    \"fuchsia-zircon\", // BSD-3-Clause, rustdoc, rustc, cargo (jobserver & tempdir)\n-    \"cssparser-macros\", // MPL-2.0, rustdoc\n-    \"selectors\", // MPL-2.0, rustdoc\n-    \"clippy_lints\", // MPL-2.0 rls\n+    \"fuchsia-zircon\",     // BSD-3-Clause, rustdoc, rustc, cargo (jobserver & tempdir)\n+    \"cssparser-macros\",   // MPL-2.0, rustdoc\n+    \"selectors\",          // MPL-2.0, rustdoc\n+    \"clippy_lints\",       // MPL-2.0 rls\n+];\n+\n+/// Which crates to check against the whitelist?\n+static WHITELIST_CRATES: &'static [CrateVersion] = &[\n+    CrateVersion(\"rustc\", \"0.0.0\"),\n+    CrateVersion(\"rustc_trans\", \"0.0.0\"),\n ];\n \n+/// Whitelist of crates rustc is allowed to depend on. Avoid adding to the list if possible.\n+static WHITELIST: &'static [Crate] = &[\n+    Crate(\"ar\"),\n+    Crate(\"backtrace\"),\n+    Crate(\"backtrace-sys\"),\n+    Crate(\"bitflags\"),\n+    Crate(\"byteorder\"),\n+    Crate(\"cc\"),\n+    Crate(\"cfg-if\"),\n+    Crate(\"cmake\"),\n+    Crate(\"ena\"),\n+    Crate(\"filetime\"),\n+    Crate(\"flate2\"),\n+    Crate(\"fuchsia-zircon\"),\n+    Crate(\"fuchsia-zircon-sys\"),\n+    Crate(\"jobserver\"),\n+    Crate(\"kernel32-sys\"),\n+    Crate(\"lazy_static\"),\n+    Crate(\"libc\"),\n+    Crate(\"log\"),\n+    Crate(\"log_settings\"),\n+    Crate(\"miniz-sys\"),\n+    Crate(\"num_cpus\"),\n+    Crate(\"owning_ref\"),\n+    Crate(\"parking_lot\"),\n+    Crate(\"parking_lot_core\"),\n+    Crate(\"rand\"),\n+    Crate(\"redox_syscall\"),\n+    Crate(\"rustc-demangle\"),\n+    Crate(\"smallvec\"),\n+    Crate(\"stable_deref_trait\"),\n+    Crate(\"tempdir\"),\n+    Crate(\"unicode-width\"),\n+    Crate(\"winapi\"),\n+    Crate(\"winapi-build\"),\n+    Crate(\"winapi-i686-pc-windows-gnu\"),\n+    Crate(\"winapi-x86_64-pc-windows-gnu\"),\n+];\n+\n+// Some types for Serde to deserialize the output of `cargo metadata` to...\n+\n+#[derive(Deserialize)]\n+struct Output {\n+    resolve: Resolve,\n+}\n+\n+#[derive(Deserialize)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(Deserialize)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n+/// A unique identifier for a crate\n+#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n+struct Crate<'a>(&'a str); // (name,)\n+\n+#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n+struct CrateVersion<'a>(&'a str, &'a str); // (name, version)\n+\n+impl<'a> Crate<'a> {\n+    pub fn id_str(&self) -> String {\n+        format!(\"{} \", self.0)\n+    }\n+}\n+\n+impl<'a> CrateVersion<'a> {\n+    /// Returns the struct and whether or not the dep is in-tree\n+    pub fn from_str(s: &'a str) -> (Self, bool) {\n+        let mut parts = s.split(\" \");\n+        let name = parts.next().unwrap();\n+        let version = parts.next().unwrap();\n+        let path = parts.next().unwrap();\n+\n+        let is_path_dep = path.starts_with(\"(path+\");\n+\n+        (CrateVersion(name, version), is_path_dep)\n+    }\n+\n+    pub fn id_str(&self) -> String {\n+        format!(\"{} {}\", self.0, self.1)\n+    }\n+}\n+\n+impl<'a> From<CrateVersion<'a>> for Crate<'a> {\n+    fn from(cv: CrateVersion<'a>) -> Crate<'a> {\n+        Crate(cv.0)\n+    }\n+}\n+\n+/// Checks the dependency at the given path. Changes `bad` to `true` if a check failed.\n+///\n+/// Specifically, this checks that the license is correct.\n pub fn check(path: &Path, bad: &mut bool) {\n+    // Check licences\n     let path = path.join(\"vendor\");\n     assert!(path.exists(), \"vendor directory missing\");\n     let mut saw_dir = false;\n-    'next_path: for dir in t!(path.read_dir()) {\n+    for dir in t!(path.read_dir()) {\n         saw_dir = true;\n         let dir = t!(dir);\n \n         // skip our exceptions\n-        for exception in EXCEPTIONS {\n-            if dir.path()\n+        if EXCEPTIONS.iter().any(|exception| {\n+            dir.path()\n                 .to_str()\n                 .unwrap()\n-                .contains(&format!(\"src/vendor/{}\", exception)) {\n-                continue 'next_path;\n-            }\n+                .contains(&format!(\"src/vendor/{}\", exception))\n+        }) {\n+            continue;\n         }\n \n         let toml = dir.path().join(\"Cargo.toml\");\n-        if !check_license(&toml) {\n-            *bad = true;\n-        }\n+        *bad = *bad || !check_license(&toml);\n     }\n     assert!(saw_dir, \"no vendored source\");\n }\n \n+/// Checks the dependency of WHITELIST_CRATES at the given path. Changes `bad` to `true` if a check\n+/// failed.\n+///\n+/// Specifically, this checks that the dependencies are on the WHITELIST.\n+pub fn check_whitelist(path: &Path, cargo: &Path, bad: &mut bool) {\n+    // Get dependencies from cargo metadata\n+    let resolve = get_deps(path, cargo);\n+\n+    // Get the whitelist into a convenient form\n+    let whitelist: HashSet<_> = WHITELIST.iter().cloned().collect();\n+\n+    // Check dependencies\n+    let mut visited = BTreeSet::new();\n+    let mut unapproved = BTreeSet::new();\n+    for &krate in WHITELIST_CRATES.iter() {\n+        let mut bad = check_crate_whitelist(&whitelist, &resolve, &mut visited, krate, false);\n+        unapproved.append(&mut bad);\n+    }\n+\n+    if unapproved.len() > 0 {\n+        println!(\"Dependencies not on the whitelist:\");\n+        for dep in unapproved {\n+            println!(\"* {}\", dep.id_str());\n+        }\n+        *bad = true;\n+    }\n+}\n+\n fn check_license(path: &Path) -> bool {\n     if !path.exists() {\n         panic!(\"{} does not exist\", path.display());\n@@ -102,9 +236,71 @@ fn extract_license(line: &str) -> String {\n     let first_quote = line.find('\"');\n     let last_quote = line.rfind('\"');\n     if let (Some(f), Some(l)) = (first_quote, last_quote) {\n-        let license = &line[f + 1 .. l];\n+        let license = &line[f + 1..l];\n         license.into()\n     } else {\n         \"bad-license-parse\".into()\n     }\n }\n+\n+/// Get the dependencies of the crate at the given path using `cargo metadata`.\n+fn get_deps(path: &Path, cargo: &Path) -> Resolve {\n+    // Run `cargo metadata` to get the set of dependencies\n+    let output = Command::new(cargo)\n+        .arg(\"metadata\")\n+        .arg(\"--format-version\")\n+        .arg(\"1\")\n+        .arg(\"--manifest-path\")\n+        .arg(path.join(\"Cargo.toml\"))\n+        .output()\n+        .expect(\"Unable to run `cargo metadata`\")\n+        .stdout;\n+    let output = String::from_utf8_lossy(&output);\n+    let output: Output = serde_json::from_str(&output).unwrap();\n+\n+    output.resolve\n+}\n+\n+/// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n+/// the whitelist. Returns a list of illegal dependencies.\n+fn check_crate_whitelist<'a, 'b>(\n+    whitelist: &'a HashSet<Crate>,\n+    resolve: &'a Resolve,\n+    visited: &'b mut BTreeSet<CrateVersion<'a>>,\n+    krate: CrateVersion<'a>,\n+    must_be_on_whitelist: bool,\n+) -> BTreeSet<Crate<'a>> {\n+    // Will contain bad deps\n+    let mut unapproved = BTreeSet::new();\n+\n+    // Check if we have already visited this crate\n+    if visited.contains(&krate) {\n+        return unapproved;\n+    }\n+\n+    visited.insert(krate);\n+\n+    // If this path is in-tree, we don't require it to be on the whitelist\n+    if must_be_on_whitelist {\n+        // If this dependency is not on the WHITELIST, add to bad set\n+        if !whitelist.contains(&krate.into()) {\n+            unapproved.insert(krate.into());\n+        }\n+    }\n+\n+    // Do a DFS in the crate graph (it's a DAG, so we know we have no cycles!)\n+    let to_check = resolve\n+        .nodes\n+        .iter()\n+        .find(|n| n.id.starts_with(&krate.id_str()))\n+        .expect(\"crate does not exist\");\n+\n+    for dep in to_check.dependencies.iter() {\n+        let (krate, is_path_dep) = CrateVersion::from_str(dep);\n+\n+        let mut bad = check_crate_whitelist(whitelist, resolve, visited, krate, !is_path_dep);\n+        unapproved.append(&mut bad);\n+    }\n+\n+    unapproved\n+}"}, {"sha": "c927ff19b279bc15af8f4e804d0596650c0298a4", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -15,6 +15,11 @@\n \n #![deny(warnings)]\n \n+extern crate serde;\n+extern crate serde_json;\n+#[macro_use]\n+extern crate serde_derive;\n+\n use std::fs;\n \n use std::path::Path;"}, {"sha": "afa3ebd198319c681427dd3a58301e4410ab7eda", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1733a61141d125beb45587dd89d54cd4a01cdd5a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=1733a61141d125beb45587dd89d54cd4a01cdd5a", "patch": "@@ -24,9 +24,12 @@ use std::path::PathBuf;\n use std::env;\n \n fn main() {\n-    let path = env::args_os().skip(1).next().expect(\"need an argument\");\n+    let path = env::args_os().skip(1).next().expect(\"need path to src\");\n     let path = PathBuf::from(path);\n \n+    let cargo = env::args_os().skip(2).next().expect(\"need path to cargo\");\n+    let cargo = PathBuf::from(cargo);\n+\n     let args: Vec<String> = env::args().skip(1).collect();\n \n     let mut bad = false;\n@@ -41,6 +44,7 @@ fn main() {\n     if !args.iter().any(|s| *s == \"--no-vendor\") {\n         deps::check(&path, &mut bad);\n     }\n+    deps::check_whitelist(&path, &cargo, &mut bad);\n \n     if bad {\n         eprintln!(\"some tidy checks failed\");"}]}