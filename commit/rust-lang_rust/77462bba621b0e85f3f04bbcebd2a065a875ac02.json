{"sha": "77462bba621b0e85f3f04bbcebd2a065a875ac02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NDYyYmJhNjIxYjBlODVmM2YwNGJiY2ViZDJhMDY1YTg3NWFjMDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-03T08:23:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T08:23:44Z"}, "message": "Merge #3746\n\n3746: Add create_function assist r=flodiebold a=TimoFreiberg\n\nThe function part of #3639, creating methods will come later\r\n\r\n- [X] Function arguments\r\n     - [X] Function call arguments\r\n     - [x] Method call arguments\r\n     - [x] Literal arguments\r\n     - [x] Variable reference arguments\r\n- [X] Migrate to `ast::make` API\r\n    Done, but there are some ugly spots.\r\n\r\nIssues to handle in another PR:\r\n- function reference arguments: Their type isn't printed properly right now.\r\n    The \"insert explicit type\" assist has the same issue and this is probably a relatively rare usecase.\r\n\r\n- generating proper names for all kinds of argument expressions (if, loop, ...?)\r\n    Without this, it's totally possible for the assist to generate invalid argument names.\r\n    I think the assist it's already helpful enough to be shipped as it is, at least for me the main usecase involves passing in named references.\r\n    Besides, the Rust tooling ecosystem is immature enough that some janky behaviour in a new assist probably won't scare anyone off.\r\n\r\n- select the generated placeholder body so it's a bit easier to overwrite it\r\n\r\n- create method (`self.foo<|>(..)` or `some_foo.foo<|>(..)`) instead of create_function.\r\n    The main difference would be finding (or creating) the impl block and inserting the `self` argument correctly\r\n\r\n- more specific default arg names for literals.\r\n    So far, every generated argument whose name can't be taken from the call site is called `arg` (with a number suffix if necessary).\r\n\r\n- creating functions in another module of the same crate.\r\n    E.g. when typing `some_mod::foo<|>(...)` when in `lib.rs`, I'd want to have `foo` generated in `some_mod.rs` and jump there.\r\n    Issues: the mod could exist in `some_mod.rs`, in `lib.rs` as `mod some_mod`, or inside another mod but be imported via `use other_mod::some_mod`.\r\n\r\n- refer to arguments of the generated function with a qualified path if the types aren't imported yet\r\n    (alternative: run autoimport. i think starting with a qualified path is cleaner and there's already an assist to replace a qualified path with an import and an unqualified path)\r\n\r\n- add type arguments of the arguments to the generated function\r\n\r\n- Autocomplete functions with information from unresolved calls (see https://github.com/rust-analyzer/rust-analyzer/pull/3746#issuecomment-605281323)\r\n    Issues: see https://github.com/rust-analyzer/rust-analyzer/pull/3746#issuecomment-605282542. The unresolved call could be anywhere. But just offering this autocompletion for unresolved calls in the same module would already be cool.\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>", "tree": {"sha": "c86a14f9389a183fc574a89d6364fdfa4771bb91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c86a14f9389a183fc574a89d6364fdfa4771bb91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77462bba621b0e85f3f04bbcebd2a065a875ac02", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehvKQCRBK7hj4Ov3rIwAAdHIIAI7HOUYhvWH1Jx2yB3Lixf9b\nclzy0NDRhh0iVRBHKrLi9hy7e9SpgblK92ZHnfLzm8KsRGRUl5DqUiADAgk4e4la\nf8J8LDrGUkLDATSvMW7nGaTf/SI4au2Ea0A/uYUemLib3+TsHtsWRho1cMCuuSDf\novQQ5mD9v2Q9M6nMziz85CfeVVL3hG0eaxsDepOGGSxZ3c0TqAe4ePEbdRbDfKP2\n05iBk+D8pOeM8ibKozBQNsMdGZ/TMdifmQQWurtlzpM7n/BopiHo3o24iHadxuHj\n+6VTOtRs4cM2bQmChsP/PiVEtf+Np1crmVZ/7Mj1t6toF3wRnfb2PjBlfGqIx88=\n=Mwhk\n-----END PGP SIGNATURE-----\n", "payload": "tree c86a14f9389a183fc574a89d6364fdfa4771bb91\nparent 2cee8531c5236ae7d66717bea604f1224c23ea56\nparent 10667753c71242c75e70e7b8c46486f37685c186\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585902224 +0000\ncommitter GitHub <noreply@github.com> 1585902224 +0000\n\nMerge #3746\n\n3746: Add create_function assist r=flodiebold a=TimoFreiberg\n\nThe function part of #3639, creating methods will come later\r\n\r\n- [X] Function arguments\r\n     - [X] Function call arguments\r\n     - [x] Method call arguments\r\n     - [x] Literal arguments\r\n     - [x] Variable reference arguments\r\n- [X] Migrate to `ast::make` API\r\n    Done, but there are some ugly spots.\r\n\r\nIssues to handle in another PR:\r\n- function reference arguments: Their type isn't printed properly right now.\r\n    The \"insert explicit type\" assist has the same issue and this is probably a relatively rare usecase.\r\n\r\n- generating proper names for all kinds of argument expressions (if, loop, ...?)\r\n    Without this, it's totally possible for the assist to generate invalid argument names.\r\n    I think the assist it's already helpful enough to be shipped as it is, at least for me the main usecase involves passing in named references.\r\n    Besides, the Rust tooling ecosystem is immature enough that some janky behaviour in a new assist probably won't scare anyone off.\r\n\r\n- select the generated placeholder body so it's a bit easier to overwrite it\r\n\r\n- create method (`self.foo<|>(..)` or `some_foo.foo<|>(..)`) instead of create_function.\r\n    The main difference would be finding (or creating) the impl block and inserting the `self` argument correctly\r\n\r\n- more specific default arg names for literals.\r\n    So far, every generated argument whose name can't be taken from the call site is called `arg` (with a number suffix if necessary).\r\n\r\n- creating functions in another module of the same crate.\r\n    E.g. when typing `some_mod::foo<|>(...)` when in `lib.rs`, I'd want to have `foo` generated in `some_mod.rs` and jump there.\r\n    Issues: the mod could exist in `some_mod.rs`, in `lib.rs` as `mod some_mod`, or inside another mod but be imported via `use other_mod::some_mod`.\r\n\r\n- refer to arguments of the generated function with a qualified path if the types aren't imported yet\r\n    (alternative: run autoimport. i think starting with a qualified path is cleaner and there's already an assist to replace a qualified path with an import and an unqualified path)\r\n\r\n- add type arguments of the arguments to the generated function\r\n\r\n- Autocomplete functions with information from unresolved calls (see https://github.com/rust-analyzer/rust-analyzer/pull/3746#issuecomment-605281323)\r\n    Issues: see https://github.com/rust-analyzer/rust-analyzer/pull/3746#issuecomment-605282542. The unresolved call could be anywhere. But just offering this autocompletion for unresolved calls in the same module would already be cool.\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77462bba621b0e85f3f04bbcebd2a065a875ac02", "html_url": "https://github.com/rust-lang/rust/commit/77462bba621b0e85f3f04bbcebd2a065a875ac02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77462bba621b0e85f3f04bbcebd2a065a875ac02/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cee8531c5236ae7d66717bea604f1224c23ea56", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cee8531c5236ae7d66717bea604f1224c23ea56", "html_url": "https://github.com/rust-lang/rust/commit/2cee8531c5236ae7d66717bea604f1224c23ea56"}, {"sha": "10667753c71242c75e70e7b8c46486f37685c186", "url": "https://api.github.com/repos/rust-lang/rust/commits/10667753c71242c75e70e7b8c46486f37685c186", "html_url": "https://github.com/rust-lang/rust/commit/10667753c71242c75e70e7b8c46486f37685c186"}], "stats": {"total": 868, "additions": 868, "deletions": 0}, "files": [{"sha": "64444ee3aa58e29097039c5f56d4d8c4c44eeb14", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=77462bba621b0e85f3f04bbcebd2a065a875ac02", "patch": "@@ -58,6 +58,33 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_add_function() {\n+    check(\n+        \"add_function\",\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar<|>(\"\", baz());\n+}\n+\n+\"#####,\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    unimplemented!()\n+}\n+\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_hash() {\n     check("}, {"sha": "488bae08f14f5bfeb6e36d32a4c89a27a0074399", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "added", "additions": 788, "deletions": 0, "changes": 788, "blob_url": "https://github.com/rust-lang/rust/blob/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=77462bba621b0e85f3f04bbcebd2a065a875ac02", "patch": "@@ -0,0 +1,788 @@\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxKind, SyntaxNode, TextUnit,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use ast::{edit::IndentLevel, ArgListOwner, CallExpr, Expr};\n+use hir::HirDisplay;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+// Assist: add_function\n+//\n+// Adds a stub function with a signature matching the function under the cursor.\n+//\n+// ```\n+// struct Baz;\n+// fn baz() -> Baz { Baz }\n+// fn foo() {\n+//      bar<|>(\"\", baz());\n+// }\n+//\n+// ```\n+// ->\n+// ```\n+// struct Baz;\n+// fn baz() -> Baz { Baz }\n+// fn foo() {\n+//      bar(\"\", baz());\n+// }\n+//\n+// fn bar(arg: &str, baz: Baz) {\n+//     unimplemented!()\n+// }\n+//\n+// ```\n+pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n+    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+    let path = path_expr.path()?;\n+\n+    if path.qualifier().is_some() {\n+        return None;\n+    }\n+\n+    if ctx.sema.resolve_path(&path).is_some() {\n+        // The function call already resolves, no need to add a function\n+        return None;\n+    }\n+\n+    let function_builder = FunctionBuilder::from_call(&ctx, &call)?;\n+\n+    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n+        edit.target(call.syntax().text_range());\n+\n+        if let Some(function_template) = function_builder.render() {\n+            edit.set_cursor(function_template.cursor_offset);\n+            edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n+        }\n+    })\n+}\n+\n+struct FunctionTemplate {\n+    insert_offset: TextUnit,\n+    cursor_offset: TextUnit,\n+    fn_def: ast::SourceFile,\n+}\n+\n+struct FunctionBuilder {\n+    append_fn_at: SyntaxNode,\n+    fn_name: ast::Name,\n+    type_params: Option<ast::TypeParamList>,\n+    params: ast::ParamList,\n+}\n+\n+impl FunctionBuilder {\n+    fn from_call(ctx: &AssistCtx, call: &ast::CallExpr) -> Option<Self> {\n+        let append_fn_at = next_space_for_fn(&call)?;\n+        let fn_name = fn_name(&call)?;\n+        let (type_params, params) = fn_args(ctx, &call)?;\n+        Some(Self { append_fn_at, fn_name, type_params, params })\n+    }\n+    fn render(self) -> Option<FunctionTemplate> {\n+        let placeholder_expr = ast::make::expr_unimplemented();\n+        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n+        let fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n+        let fn_def = ast::make::add_newlines(2, fn_def);\n+        let fn_def = IndentLevel::from_node(&self.append_fn_at).increase_indent(fn_def);\n+        let insert_offset = self.append_fn_at.text_range().end();\n+        let cursor_offset_from_fn_start = fn_def\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::MacroCall::cast)?\n+            .syntax()\n+            .text_range()\n+            .start();\n+        let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n+        Some(FunctionTemplate { insert_offset, cursor_offset, fn_def })\n+    }\n+}\n+\n+fn fn_name(call: &CallExpr) -> Option<ast::Name> {\n+    let name = call.expr()?.syntax().to_string();\n+    Some(ast::make::name(&name))\n+}\n+\n+/// Computes the type variables and arguments required for the generated function\n+fn fn_args(\n+    ctx: &AssistCtx,\n+    call: &CallExpr,\n+) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n+    let mut arg_names = Vec::new();\n+    let mut arg_types = Vec::new();\n+    for arg in call.arg_list()?.args() {\n+        let arg_name = match fn_arg_name(&arg) {\n+            Some(name) => name,\n+            None => String::from(\"arg\"),\n+        };\n+        arg_names.push(arg_name);\n+        arg_types.push(match fn_arg_type(ctx, &arg) {\n+            Some(ty) => ty,\n+            None => String::from(\"()\"),\n+        });\n+    }\n+    deduplicate_arg_names(&mut arg_names);\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n+    Some((None, ast::make::param_list(params)))\n+}\n+\n+/// Makes duplicate argument names unique by appending incrementing numbers.\n+///\n+/// ```\n+/// let mut names: Vec<String> =\n+///     vec![\"foo\".into(), \"foo\".into(), \"bar\".into(), \"baz\".into(), \"bar\".into()];\n+/// deduplicate_arg_names(&mut names);\n+/// let expected: Vec<String> =\n+///     vec![\"foo_1\".into(), \"foo_2\".into(), \"bar_1\".into(), \"baz\".into(), \"bar_2\".into()];\n+/// assert_eq!(names, expected);\n+/// ```\n+fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n+    let arg_name_counts = arg_names.iter().fold(FxHashMap::default(), |mut m, name| {\n+        *m.entry(name).or_insert(0) += 1;\n+        m\n+    });\n+    let duplicate_arg_names: FxHashSet<String> = arg_name_counts\n+        .into_iter()\n+        .filter(|(_, count)| *count >= 2)\n+        .map(|(name, _)| name.clone())\n+        .collect();\n+\n+    let mut counter_per_name = FxHashMap::default();\n+    for arg_name in arg_names.iter_mut() {\n+        if duplicate_arg_names.contains(arg_name) {\n+            let counter = counter_per_name.entry(arg_name.clone()).or_insert(1);\n+            arg_name.push('_');\n+            arg_name.push_str(&counter.to_string());\n+            *counter += 1;\n+        }\n+    }\n+}\n+\n+fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n+    match fn_arg {\n+        Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n+        _ => Some(\n+            fn_arg\n+                .syntax()\n+                .descendants()\n+                .filter(|d| ast::NameRef::can_cast(d.kind()))\n+                .last()?\n+                .to_string(),\n+        ),\n+    }\n+}\n+\n+fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n+    let ty = ctx.sema.type_of_expr(fn_arg)?;\n+    if ty.is_unknown() {\n+        return None;\n+    }\n+    Some(ty.display(ctx.sema.db).to_string())\n+}\n+\n+/// Returns the position inside the current mod or file\n+/// directly after the current block\n+/// We want to write the generated function directly after\n+/// fns, impls or macro calls, but inside mods\n+fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n+    let mut ancestors = expr.syntax().ancestors().peekable();\n+    let mut last_ancestor: Option<SyntaxNode> = None;\n+    while let Some(next_ancestor) = ancestors.next() {\n+        match next_ancestor.kind() {\n+            SyntaxKind::SOURCE_FILE => {\n+                break;\n+            }\n+            SyntaxKind::ITEM_LIST => {\n+                if ancestors.peek().map(|a| a.kind()) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            _ => {}\n+        }\n+        last_ancestor = Some(next_ancestor);\n+    }\n+    last_ancestor\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn add_function_with_no_args() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar<|>();\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar();\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_from_method() {\n+        // This ensures that the function is correctly generated\n+        // in the next outer mod or file\n+        check_assist(\n+            add_function,\n+            r\"\n+impl Foo {\n+    fn foo() {\n+        bar<|>();\n+    }\n+}\n+\",\n+            r\"\n+impl Foo {\n+    fn foo() {\n+        bar();\n+    }\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_directly_after_current_block() {\n+        // The new fn should not be created at the end of the file or module\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo1() {\n+    bar<|>();\n+}\n+\n+fn foo2() {}\n+\",\n+            r\"\n+fn foo1() {\n+    bar();\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\n+fn foo2() {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_no_args_in_same_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod baz {\n+    fn foo() {\n+        bar<|>();\n+    }\n+}\n+\",\n+            r\"\n+mod baz {\n+    fn foo() {\n+        bar();\n+    }\n+\n+    fn bar() {\n+        <|>unimplemented!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_function_call_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { unimplemented!() }\n+fn foo() {\n+    bar<|>(baz());\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { unimplemented!() }\n+fn foo() {\n+    bar(baz());\n+}\n+\n+fn bar(baz: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_function_with_method_call_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn foo(&self) -> Baz {\n+        ba<|>r(self.baz())\n+    }\n+    fn baz(&self) -> Baz {\n+        Baz\n+    }\n+}\n+\",\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn foo(&self) -> Baz {\n+        bar(self.baz())\n+    }\n+    fn baz(&self) -> Baz {\n+        Baz\n+    }\n+}\n+\n+fn bar(baz: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_string_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+fn foo() {\n+    <|>bar(\"bar\")\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    bar(\"bar\")\n+}\n+\n+fn bar(arg: &str) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_char_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+fn foo() {\n+    <|>bar('x')\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    bar('x')\n+}\n+\n+fn bar(arg: char) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_int_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(42)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(42)\n+}\n+\n+fn bar(arg: i32) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_cast_int_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(42 as u8)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(42 as u8)\n+}\n+\n+fn bar(arg: u8) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn name_of_cast_variable_is_used() {\n+        // Ensures that the name of the cast type isn't used\n+        // in the generated function signature.\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let x = 42;\n+    bar<|>(x as u8)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let x = 42;\n+    bar(x as u8)\n+}\n+\n+fn bar(x: u8) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_variable_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let worble = ();\n+    <|>bar(worble)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let worble = ();\n+    bar(worble)\n+}\n+\n+fn bar(worble: ()) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_impl_trait_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+trait Foo {}\n+fn foo() -> impl Foo {\n+    unimplemented!()\n+}\n+fn baz() {\n+    <|>bar(foo())\n+}\n+\",\n+            r\"\n+trait Foo {}\n+fn foo() -> impl Foo {\n+    unimplemented!()\n+}\n+fn baz() {\n+    bar(foo())\n+}\n+\n+fn bar(foo: impl Foo) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME print paths properly to make this test pass\n+    fn add_function_with_qualified_path_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod Baz {\n+    pub struct Bof;\n+    pub fn baz() -> Bof { Bof }\n+}\n+mod Foo {\n+    fn foo() {\n+        <|>bar(super::Baz::baz())\n+    }\n+}\n+\",\n+            r\"\n+mod Baz {\n+    pub struct Bof;\n+    pub fn baz() -> Bof { Bof }\n+}\n+mod Foo {\n+    fn foo() {\n+        bar(super::Baz::baz())\n+    }\n+\n+    fn bar(baz: super::Baz::Bof) {\n+        <|>unimplemented!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME fix printing the generics of a `Ty` to make this test pass\n+    fn add_function_with_generic_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo<T>(t: T) {\n+    <|>bar(t)\n+}\n+\",\n+            r\"\n+fn foo<T>(t: T) {\n+    bar(t)\n+}\n+\n+fn bar<T>(t: T) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME Fix function type printing to make this test pass\n+    fn add_function_with_fn_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn new() -> Self { Baz }\n+}\n+fn foo() {\n+    <|>bar(Baz::new);\n+}\n+\",\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn new() -> Self { Baz }\n+}\n+fn foo() {\n+    bar(Baz::new);\n+}\n+\n+fn bar(arg: fn() -> Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME Fix closure type printing to make this test pass\n+    fn add_function_with_closure_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let closure = |x: i64| x - 1;\n+    <|>bar(closure)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let closure = |x: i64| x - 1;\n+    bar(closure)\n+}\n+\n+fn bar(closure: impl Fn(i64) -> i64) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn unresolveable_types_default_to_unit() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(baz)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(baz)\n+}\n+\n+fn bar(baz: ()) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_names_dont_overlap() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    <|>bar(baz(), baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(baz(), baz())\n+}\n+\n+fn bar(baz_1: Baz, baz_2: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_name_counters_start_at_1_per_name() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    <|>bar(baz(), baz(), \"foo\", \"bar\")\n+}\n+\"#,\n+            r#\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(baz(), baz(), \"foo\", \"bar\")\n+}\n+\n+fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_function_already_exists() {\n+        check_assist_not_applicable(\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar<|>();\n+}\n+\n+fn bar() {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_unresolved_variable_in_call_is_selected() {\n+        check_assist_not_applicable(\n+            // bar is resolved, but baz isn't.\n+            // The assist is only active if the cursor is on an unresolved path,\n+            // but the assist should only be offered if the path is a function call.\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar(b<|>az);\n+}\n+\n+fn bar(baz: ()) {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_function_path_not_singleton() {\n+        // In the future this assist could be extended to generate functions\n+        // if the path is in the same crate (or even the same workspace).\n+        // For the beginning, I think this is fine.\n+        check_assist_not_applicable(\n+            add_function,\n+            r\"\n+fn foo() {\n+    other_crate::bar<|>();\n+}\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn create_method_with_no_args() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {\n+        self.bar()<|>;\n+    }\n+}\n+        \",\n+            r\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {\n+        self.bar();\n+    }\n+    fn bar(&self) {\n+        unimplemented!();\n+    }\n+}\n+        \",\n+        )\n+    }\n+}"}, {"sha": "fa3d3913f85ad389909f784d13e3dee0b306f435", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=77462bba621b0e85f3f04bbcebd2a065a875ac02", "patch": "@@ -96,6 +96,7 @@ mod handlers {\n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n@@ -129,6 +130,7 @@ mod handlers {\n             add_custom_impl::add_custom_impl,\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n+            add_function::add_function,\n             add_impl::add_impl,\n             add_missing_impl_members::add_missing_default_members,\n             add_missing_impl_members::add_missing_impl_members,"}, {"sha": "f39559e9ea1cb3d4540742c36da1cc9a6da85c80", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77462bba621b0e85f3f04bbcebd2a065a875ac02/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=77462bba621b0e85f3f04bbcebd2a065a875ac02", "patch": "@@ -270,6 +270,31 @@ pub fn unreachable_macro_call() -> ast::MacroCall {\n     ast_from_text(&format!(\"unreachable!()\"))\n }\n \n+pub fn param(name: String, ty: String) -> ast::Param {\n+    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n+}\n+\n+pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList {\n+    let args = pats.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n+}\n+\n+pub fn fn_def(\n+    fn_name: ast::Name,\n+    type_params: Option<ast::TypeParamList>,\n+    params: ast::ParamList,\n+    body: ast::BlockExpr,\n+) -> ast::FnDef {\n+    let type_params =\n+        if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n+    ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n+}\n+\n+pub fn add_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+    let newlines = \"\\n\".repeat(amount_of_newlines);\n+    ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let node = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}, {"sha": "754131f6fec11973c2a1970fc8148eaf37031c92", "filename": "docs/user/assists.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/77462bba621b0e85f3f04bbcebd2a065a875ac02/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/77462bba621b0e85f3f04bbcebd2a065a875ac02/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=77462bba621b0e85f3f04bbcebd2a065a875ac02", "patch": "@@ -56,6 +56,32 @@ fn main() {\n }\n ```\n \n+## `add_function`\n+\n+Adds a stub function with a signature matching the function under the cursor.\n+\n+```rust\n+// BEFORE\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar\u2503(\"\", baz());\n+}\n+\n+\n+// AFTER\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    unimplemented!()\n+}\n+\n+```\n+\n ## `add_hash`\n \n Adds a hash to a raw string literal."}]}