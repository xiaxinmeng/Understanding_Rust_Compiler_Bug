{"sha": "bc77f91cf6bec95176b32d0794775e5f00c25367", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNzdmOTFjZjZiZWM5NTE3NmIzMmQwNzk0Nzc1ZTVmMDBjMjUzNjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T07:16:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T07:16:28Z"}, "message": "rename def_id -> def", "tree": {"sha": "91a504f18b8f23bc21c105d2deeba1a3d40d5fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a504f18b8f23bc21c105d2deeba1a3d40d5fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc77f91cf6bec95176b32d0794775e5f00c25367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc77f91cf6bec95176b32d0794775e5f00c25367", "html_url": "https://github.com/rust-lang/rust/commit/bc77f91cf6bec95176b32d0794775e5f00c25367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc77f91cf6bec95176b32d0794775e5f00c25367/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e884ab05c216fc4a4a35d6267d08519dc5dda41d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e884ab05c216fc4a4a35d6267d08519dc5dda41d", "html_url": "https://github.com/rust-lang/rust/commit/e884ab05c216fc4a4a35d6267d08519dc5dda41d"}], "stats": {"total": 48, "additions": 17, "deletions": 31}, "files": [{"sha": "bd5fbfadf0494044bd35740ea00a06be9a6d1198", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=bc77f91cf6bec95176b32d0794775e5f00c25367", "patch": "@@ -59,7 +59,7 @@ impl ModuleScope {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: PerNs<ModuleDef>,\n+    pub def: PerNs<ModuleDef>,\n     /// ident by which this is imported into local scope.\n     pub import: Option<ImportId>,\n }\n@@ -211,11 +211,11 @@ where\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db) {\n-                        let def_id = module.into();\n+                        let def = module.into();\n                         self.add_module_item(\n                             &mut module_items,\n                             dep.name.clone(),\n-                            PerNs::types(def_id),\n+                            PerNs::types(def),\n                         );\n                     }\n                 }\n@@ -227,19 +227,16 @@ where\n                     module_items.items.insert(\n                         segment.name.clone(),\n                         Resolution {\n-                            def_id: PerNs::none(),\n+                            def: PerNs::none(),\n                             import: Some(import_id),\n                         },\n                     );\n                 }\n             }\n         }\n         // Populate explicitly declared items, except modules\n-        for (name, &def_id) in input.declarations.iter() {\n-            let resolution = Resolution {\n-                def_id,\n-                import: None,\n-            };\n+        for (name, &def) in input.declarations.iter() {\n+            let resolution = Resolution { def, import: None };\n             module_items.items.insert(name.clone(), resolution);\n         }\n \n@@ -255,16 +252,8 @@ where\n         self.result.per_module.insert(module_id, module_items);\n     }\n \n-    fn add_module_item(\n-        &self,\n-        module_items: &mut ModuleScope,\n-        name: Name,\n-        def_id: PerNs<ModuleDef>,\n-    ) {\n-        let resolution = Resolution {\n-            def_id,\n-            import: None,\n-        };\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def: PerNs<ModuleDef>) {\n+        let resolution = Resolution { def, import: None };\n         module_items.items.insert(name, resolution);\n     }\n \n@@ -295,15 +284,15 @@ where\n             krate: self.krate,\n             module_id,\n         };\n-        let (def_id, reached_fixedpoint) =\n+        let (def, reached_fixedpoint) =\n             self.result\n                 .resolve_path_fp(self.db, original_module, &import.path);\n \n         if reached_fixedpoint == ReachedFixedPoint::Yes {\n             let last_segment = import.path.segments.last().unwrap();\n             self.update(module_id, |items| {\n                 let res = Resolution {\n-                    def_id,\n+                    def,\n                     import: Some(import_id),\n                 };\n                 items.items.insert(last_segment.name.clone(), res);\n@@ -312,7 +301,7 @@ where\n                 \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n                 last_segment.name,\n                 import,\n-                def_id,\n+                def,\n             );\n         }\n         reached_fixedpoint\n@@ -388,12 +377,12 @@ impl ItemMap {\n                             kind: PathKind::Crate,\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let def_id = module.resolve_path(db, &path);\n-                        return (def_id, ReachedFixedPoint::Yes);\n+                        let def = module.resolve_path(db, &path);\n+                        return (def, ReachedFixedPoint::Yes);\n                     }\n \n                     match self.per_module[&module.module_id].items.get(&segment.name) {\n-                        Some(res) if !res.def_id.is_none() => res.def_id,\n+                        Some(res) if !res.def.is_none() => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n                             return (PerNs::none(), ReachedFixedPoint::No);"}, {"sha": "7e35c016fda41c0db42edb5f52a63d46cd948367", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=bc77f91cf6bec95176b32d0794775e5f00c25367", "patch": "@@ -37,8 +37,8 @@ fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n \n     fn dump_resolution(resolution: &Resolution) -> &'static str {\n         match (\n-            resolution.def_id.types.is_some(),\n-            resolution.def_id.values.is_some(),\n+            resolution.def.types.is_some(),\n+            resolution.def.values.is_some(),\n         ) {\n             (true, true) => \"t v\",\n             (true, false) => \"t\","}, {"sha": "b2b0477661d93f4e4b3c83b045c251500bbb64c3", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc77f91cf6bec95176b32d0794775e5f00c25367/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=bc77f91cf6bec95176b32d0794775e5f00c25367", "patch": "@@ -209,10 +209,7 @@ impl Builder {\n         ctx: &CompletionContext,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        let def = resolution\n-            .def_id\n-            .take_types()\n-            .or(resolution.def_id.take_values());\n+        let def = resolution.def.take_types().or(resolution.def.take_values());\n         let def = match def {\n             None => return self,\n             Some(it) => it,"}]}