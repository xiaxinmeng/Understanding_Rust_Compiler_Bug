{"sha": "549f8553dc487359b066c6857f7e4996e832d033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OWY4NTUzZGM0ODczNTliMDY2YzY4NTdmN2U0OTk2ZTgzMmQwMzM=", "commit": {"author": {"name": "Jimmy Brisson", "email": "theotherjimmy@gmail.com", "date": "2017-10-15T19:25:53Z"}, "committer": {"name": "Jimmy Brisson", "email": "theotherjimmy@gmail.com", "date": "2017-10-15T19:36:07Z"}, "message": "Refactor `ensure` and `try_get_with` into `read_node_index`\n\nThere was a bit of code shared between `try_get_with` and `ensure`, after I\nadded `ensure`. I refactored that shared code into a query-agnostic method\ncalled `read_node_index`.\n\nThe new method `read_node_index` will attempt to find the node\nindex (`DepNodeIndex`) of a query. When `read_node_index` finds the\n`DepNodeIndex`, it marks the current query as a reader of the node it's\nrequesting the index of.\n\nThis is used by `try_get_with` and `ensure` as it elides the unimportant (to\nthem) details of if the query is invalidated by previous changed computation (Red)\nor new and if they had to mark the query green. For both `try_get_with` and\n`ensure`, they just need to know if they can lookup the results or have to\nreevaluate.", "tree": {"sha": "3f1ced7adc2e6a43c772ad0c2ffc36e92a929cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f1ced7adc2e6a43c772ad0c2ffc36e92a929cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/549f8553dc487359b066c6857f7e4996e832d033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/549f8553dc487359b066c6857f7e4996e832d033", "html_url": "https://github.com/rust-lang/rust/commit/549f8553dc487359b066c6857f7e4996e832d033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/549f8553dc487359b066c6857f7e4996e832d033/comments", "author": {"login": "theotherjimmy", "id": 685409, "node_id": "MDQ6VXNlcjY4NTQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/685409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherjimmy", "html_url": "https://github.com/theotherjimmy", "followers_url": "https://api.github.com/users/theotherjimmy/followers", "following_url": "https://api.github.com/users/theotherjimmy/following{/other_user}", "gists_url": "https://api.github.com/users/theotherjimmy/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherjimmy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherjimmy/subscriptions", "organizations_url": "https://api.github.com/users/theotherjimmy/orgs", "repos_url": "https://api.github.com/users/theotherjimmy/repos", "events_url": "https://api.github.com/users/theotherjimmy/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherjimmy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "theotherjimmy", "id": 685409, "node_id": "MDQ6VXNlcjY4NTQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/685409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherjimmy", "html_url": "https://github.com/theotherjimmy", "followers_url": "https://api.github.com/users/theotherjimmy/followers", "following_url": "https://api.github.com/users/theotherjimmy/following{/other_user}", "gists_url": "https://api.github.com/users/theotherjimmy/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherjimmy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherjimmy/subscriptions", "organizations_url": "https://api.github.com/users/theotherjimmy/orgs", "repos_url": "https://api.github.com/users/theotherjimmy/repos", "events_url": "https://api.github.com/users/theotherjimmy/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherjimmy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2689fd2402590961dae32f35369a8685c89022fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2689fd2402590961dae32f35369a8685c89022fb", "html_url": "https://github.com/rust-lang/rust/commit/2689fd2402590961dae32f35369a8685c89022fb"}], "stats": {"total": 91, "additions": 43, "deletions": 48}, "files": [{"sha": "38a27305c2b7dcd2511f946e9755791919cc4cfa", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/549f8553dc487359b066c6857f7e4996e832d033/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/549f8553dc487359b066c6857f7e4996e832d033/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=549f8553dc487359b066c6857f7e4996e832d033", "patch": "@@ -427,6 +427,40 @@ impl DepGraph {\n         self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n     }\n \n+    /// Try to read a node index for the node dep_node.\n+    /// A node will have an index, when it's already been marked green, or when we can mark it\n+    /// green. This function will mark the current task as a reader of the specified node, when\n+    /// the a node index can be found for that node.\n+    pub fn read_node_index(&self, tcx: TyCtxt, dep_node: &DepNode) -> Option<DepNodeIndex> {\n+        match self.node_color(dep_node) {\n+            Some(DepNodeColor::Green(dep_node_index)) => {\n+                self.read_index(dep_node_index);\n+                Some(dep_node_index)\n+            }\n+            Some(DepNodeColor::Red) => {\n+                None\n+            }\n+            None => {\n+                // try_mark_green (called below) will panic when full incremental\n+                // compilation is disabled. If that's the case, we can't try to mark nodes\n+                // as green anyway, so we can safely return None here.\n+                if !self.is_fully_enabled() {\n+                    return None;\n+                }\n+                match self.try_mark_green(tcx, &dep_node) {\n+                    Some(dep_node_index) => {\n+                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+                        tcx.dep_graph.read_index(dep_node_index);\n+                        Some(dep_node_index)\n+                    }\n+                    None => {\n+                        None\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn try_mark_green(&self,\n                           tcx: TyCtxt,\n                           dep_node: &DepNode)"}, {"sha": "13880b3713613a5fe39f8f1b7207c29edeeab251", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 9, "deletions": 48, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/549f8553dc487359b066c6857f7e4996e832d033/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/549f8553dc487359b066c6857f7e4996e832d033/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=549f8553dc487359b066c6857f7e4996e832d033", "patch": "@@ -309,25 +309,8 @@ macro_rules! define_maps {\n                 }\n \n                 if !dep_node.kind.is_input() {\n-                    use dep_graph::DepNodeColor;\n-                    if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph\n-                                                                          .node_color(&dep_node) {\n+                    if let Some(dep_node_index) = tcx.dep_graph.read_node_index(tcx, &dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        span,\n-                                                                        dep_node_index)\n-                    }\n-\n-                    debug!(\"ty::queries::{}::try_get_with(key={:?}) - running try_mark_green\",\n-                           stringify!($name),\n-                           key);\n-\n-                    if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n-                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n@@ -357,36 +340,14 @@ macro_rules! define_maps {\n                 // Ensuring an \"input\" or anonymous query makes no sense\n                 assert!(!dep_node.kind.is_anon());\n                 assert!(!dep_node.kind.is_input());\n-                use dep_graph::DepNodeColor;\n-                match tcx.dep_graph.node_color(&dep_node) {\n-                    Some(DepNodeColor::Green(dep_node_index)) => {\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                    }\n-                    Some(DepNodeColor::Red) => {\n-                        // A DepNodeColor::Red DepNode means that this query was executed\n-                        // before. We can not call `dep_graph.read()` here as we don't have\n-                        // the DepNodeIndex. Instead, We call the query again to issue the\n-                        // appropriate `dep_graph.read()` call. The performance cost this\n-                        // introduces should be negligible as we'll immediately hit the\n-                        // in-memory cache.\n-                        let _ = tcx.$name(key);\n-                    }\n-                    None => {\n-                        // Huh\n-                        if !tcx.dep_graph.is_fully_enabled() {\n-                            let _ = tcx.$name(key);\n-                            return;\n-                        }\n-                        match tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n-                            Some(dep_node_index) => {\n-                                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                                tcx.dep_graph.read_index(dep_node_index);\n-                            }\n-                            None => {\n-                                let _ = tcx.$name(key);\n-                            }\n-                        }\n-                    }\n+                if tcx.dep_graph.read_node_index(tcx, &dep_node).is_none() {\n+                    // A None return from `read_node_index` means that this is either\n+                    // a new dep node or that the dep node has already been marked red.\n+                    // Either way, we can't call `dep_graph.read()` as we don't have the\n+                    // DepNodeIndex. We must invoke the query itself. The performance cost\n+                    // this introduces should be negligible as we'll immediately hit the\n+                    // in-memory cache, or another query down the line will.\n+                    let _ = tcx.$name(key);\n                 }\n             }\n "}]}