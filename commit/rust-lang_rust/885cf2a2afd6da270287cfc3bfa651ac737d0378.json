{"sha": "885cf2a2afd6da270287cfc3bfa651ac737d0378", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NWNmMmEyYWZkNmRhMjcwMjg3Y2ZjM2JmYTY1MWFjNzM3ZDAzNzg=", "commit": {"author": {"name": "Vardhan Thigle", "email": "vardhan.thigle@fortanix.com", "date": "2018-12-14T13:08:15Z"}, "committer": {"name": "Vardhan Thigle", "email": "vardhan.thigle@fortanix.com", "date": "2018-12-19T13:01:58Z"}, "message": "Adding unwinding support for x86_64_fortanix_unknown_sgx target.", "tree": {"sha": "a58756f602c09a61d71f9a3ea0367a0004f7c7ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a58756f602c09a61d71f9a3ea0367a0004f7c7ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/885cf2a2afd6da270287cfc3bfa651ac737d0378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/885cf2a2afd6da270287cfc3bfa651ac737d0378", "html_url": "https://github.com/rust-lang/rust/commit/885cf2a2afd6da270287cfc3bfa651ac737d0378", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/885cf2a2afd6da270287cfc3bfa651ac737d0378/comments", "author": null, "committer": null, "parents": [{"sha": "041254b81495a5aa67af839e00b890e78ed0cbeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/041254b81495a5aa67af839e00b890e78ed0cbeb", "html_url": "https://github.com/rust-lang/rust/commit/041254b81495a5aa67af839e00b890e78ed0cbeb"}], "stats": {"total": 198, "additions": 168, "deletions": 30}, "files": [{"sha": "cfe671c626bcf040b14c4b5dd328ddd535783232", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=885cf2a2afd6da270287cfc3bfa651ac737d0378", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n-    } else if #[cfg(any(target_arch = \"wasm32\", target_env = \"sgx\"))] {\n+    } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {"}, {"sha": "6a6aab2bea3664d9794162cb0f77825c2c7d6d0b", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=885cf2a2afd6da270287cfc3bfa651ac737d0378", "patch": "@@ -10,28 +10,29 @@\n \n use std::iter;\n \n-use super::{LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+use super::{LinkerFlavor, PanicStrategy, Target, TargetOptions};\n \n pub fn target() -> Result<Target, String> {\n     const PRE_LINK_ARGS: &[&str] = &[\n         \"-Wl,--as-needed\",\n         \"-Wl,-z,noexecstack\",\n         \"-m64\",\n-         \"-fuse-ld=gold\",\n-         \"-nostdlib\",\n-         \"-shared\",\n-         \"-Wl,-e,sgx_entry\",\n-         \"-Wl,-Bstatic\",\n-         \"-Wl,--gc-sections\",\n-         \"-Wl,-z,text\",\n-         \"-Wl,-z,norelro\",\n-         \"-Wl,--rosegment\",\n-         \"-Wl,--no-undefined\",\n-         \"-Wl,--error-unresolved-symbols\",\n-         \"-Wl,--no-undefined-version\",\n-         \"-Wl,-Bsymbolic\",\n-         \"-Wl,--export-dynamic\",\n+        \"-fuse-ld=gold\",\n+        \"-nostdlib\",\n+        \"-shared\",\n+        \"-Wl,-e,sgx_entry\",\n+        \"-Wl,-Bstatic\",\n+        \"-Wl,--gc-sections\",\n+        \"-Wl,-z,text\",\n+        \"-Wl,-z,norelro\",\n+        \"-Wl,--rosegment\",\n+        \"-Wl,--no-undefined\",\n+        \"-Wl,--error-unresolved-symbols\",\n+        \"-Wl,--no-undefined-version\",\n+        \"-Wl,-Bsymbolic\",\n+        \"-Wl,--export-dynamic\",\n     ];\n+\n     const EXPORT_SYMBOLS: &[&str] = &[\n         \"sgx_entry\",\n         \"HEAP_BASE\",\n@@ -41,19 +42,26 @@ pub fn target() -> Result<Target, String> {\n         \"ENCLAVE_SIZE\",\n         \"CFGDATA_BASE\",\n         \"DEBUG\",\n+        \"EH_FRM_HDR_BASE\",\n+        \"EH_FRM_HDR_SIZE\",\n+        \"TEXT_BASE\",\n+        \"TEXT_SIZE\",\n     ];\n     let opts = TargetOptions {\n         dynamic_linking: false,\n         executables: true,\n         linker_is_gnu: true,\n         max_atomic_width: Some(64),\n-        panic_strategy: PanicStrategy::Abort,\n+        panic_strategy: PanicStrategy::Unwind,\n         cpu: \"x86-64\".into(),\n         features: \"+rdrnd,+rdseed\".into(),\n         position_independent_executables: true,\n-        pre_link_args: iter::once(\n-                (LinkerFlavor::Gcc, PRE_LINK_ARGS.iter().cloned().map(String::from).collect())\n-        ).collect(),\n+        pre_link_args: iter::once((\n+            LinkerFlavor::Gcc,\n+            PRE_LINK_ARGS.iter().cloned().map(String::from).collect(),\n+        ))\n+        .collect(),\n+        post_link_objects: vec![\"libunwind.a\".into()],\n         override_export_symbols: Some(EXPORT_SYMBOLS.iter().cloned().map(String::from).collect()),\n         ..Default::default()\n     };"}, {"sha": "49ede0674ce42cbe3e43a042194aa8448ddaa980", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=885cf2a2afd6da270287cfc3bfa651ac737d0378", "patch": "@@ -56,6 +56,14 @@ IMAGE_BASE:\n     globvar CFGDATA_BASE 8\n     /*  Non-zero if debugging is enabled, zero otherwise */\n     globvar DEBUG 1\n+    /*  The base address (relative to enclave start) of the enclave text section */\n+    globvar TEXT_BASE 8\n+    /*  The size in bytes of enclacve text section */\n+    globvar TEXT_SIZE 8\n+    /*  The base address (relative to enclave start) of the enclave EH_FRM_HDR section */\n+    globvar EH_FRM_HDR_BASE 8\n+    /*  The size in bytes of enclacve EH_FRM_HDR section */\n+    globvar EH_FRM_HDR_SIZE 8\n \n .Lreentry_panic_msg:\n     .asciz \"Re-entered panicked enclave!\""}, {"sha": "d1af98bd4f525ccf9e89cd4a6da5dfed35be0dd4", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=885cf2a2afd6da270287cfc3bfa651ac737d0378", "patch": "@@ -9,22 +9,33 @@\n // except according to those terms.\n \n use num::NonZeroUsize;\n+use slice;\n+use str;\n \n-use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n+use super::waitqueue::{\n+    try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n+};\n+use mem;\n \n pub struct RWLock {\n     readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n     writer: SpinMutex<WaitVariable<bool>>,\n }\n \n+// Below is to check at compile time, that RWLock has size of 128 bytes.\n+#[allow(dead_code)]\n+unsafe fn rw_lock_size_assert(r: RWLock) {\n+    mem::transmute::<RWLock, [u8; 128]>(r);\n+}\n+\n //unsafe impl Send for RWLock {}\n //unsafe impl Sync for RWLock {} // FIXME\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n         RWLock {\n             readers: SpinMutex::new(WaitVariable::new(None)),\n-            writer: SpinMutex::new(WaitVariable::new(false))\n+            writer: SpinMutex::new(WaitVariable::new(false)),\n         }\n     }\n \n@@ -89,9 +100,11 @@ impl RWLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        let mut rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+    unsafe fn __read_unlock(\n+        &self,\n+        mut rguard: SpinMutexGuard<WaitVariable<Option<NonZeroUsize>>>,\n+        wguard: SpinMutexGuard<WaitVariable<bool>>,\n+    ) {\n         *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n         if rguard.lock_var().is_some() {\n             // There are other active readers\n@@ -107,9 +120,18 @@ impl RWLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write_unlock(&self) {\n+    pub unsafe fn read_unlock(&self) {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n+        self.__read_unlock(rguard, wguard);\n+    }\n+\n+    #[inline]\n+    unsafe fn __write_unlock(\n+        &self,\n+        rguard: SpinMutexGuard<WaitVariable<Option<NonZeroUsize>>>,\n+        wguard: SpinMutexGuard<WaitVariable<bool>>,\n+    ) {\n         if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n             // No writers waiting, release the write lock\n             *wguard.lock_var_mut() = false;\n@@ -128,6 +150,109 @@ impl RWLock {\n         }\n     }\n \n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        self.__write_unlock(rguard, wguard);\n+    }\n+\n+    #[inline]\n+    unsafe fn unlock(&self) {\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if *wguard.lock_var() == true {\n+            self.__write_unlock(rguard, wguard);\n+        } else {\n+            self.__read_unlock(rguard, wguard);\n+        }\n+    }\n+\n     #[inline]\n     pub unsafe fn destroy(&self) {}\n }\n+\n+const EINVAL: i32 = 22;\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).read();\n+    return 0;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).write();\n+    return 0;\n+}\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).unlock();\n+    return 0;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n+    if s < 0 {\n+        return;\n+    }\n+    let buf = slice::from_raw_parts(m as *const u8, s as _);\n+    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n+        eprint!(\"{}\", s);\n+    }\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_abort() {\n+    ::sys::abort_internal();\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::*;\n+    use core::array::FixedSizeArray;\n+    use mem::MaybeUninit;\n+    use {mem, ptr};\n+\n+    // The below test verifies that the bytes of initialized RWLock are the ones\n+    // we use in libunwind.\n+    // If they change we need to update src/UnwindRustSgx.h in libunwind.\n+    #[test]\n+    fn test_c_rwlock_initializer() {\n+        const RWLOCK_INIT: &[u8] = &[\n+            0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+        ];\n+\n+        let mut init = MaybeUninit::<RWLock>::zeroed();\n+        init.set(RWLock::new());\n+        assert_eq!(\n+            mem::transmute::<_, [u8; 128]>(init.into_inner()).as_slice(),\n+            RWLOCK_INIT\n+        );\n+    }\n+}"}, {"sha": "954eb9d6d03ba81b27c0ed6ed92ca2d0d85e11de", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885cf2a2afd6da270287cfc3bfa651ac737d0378/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=885cf2a2afd6da270287cfc3bfa651ac737d0378", "patch": "@@ -26,10 +26,7 @@ mod macros;\n cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n-    } else if #[cfg(any(\n-        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-        target_env = \"sgx\"\n-    ))] {\n+    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n         // no unwinder on the system!\n     } else {\n         extern crate libc;"}]}