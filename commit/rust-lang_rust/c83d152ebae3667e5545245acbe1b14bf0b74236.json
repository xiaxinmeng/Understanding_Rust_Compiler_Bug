{"sha": "c83d152ebae3667e5545245acbe1b14bf0b74236", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4M2QxNTJlYmFlMzY2N2U1NTQ1MjQ1YWNiZTFiMTRiZjBiNzQyMzY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-06-07T05:06:22Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-06-07T10:34:39Z"}, "message": "Introduce `ProcessResult`.\n\nA tri-valued enum is nicer than Result<Option<T>>, and it's slightly\nfaster.", "tree": {"sha": "e81b17824f09f84200991afef967d9b848f49f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e81b17824f09f84200991afef967d9b848f49f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c83d152ebae3667e5545245acbe1b14bf0b74236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c83d152ebae3667e5545245acbe1b14bf0b74236", "html_url": "https://github.com/rust-lang/rust/commit/c83d152ebae3667e5545245acbe1b14bf0b74236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c83d152ebae3667e5545245acbe1b14bf0b74236/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f14b5d9ee6327967fdb69d32fc3c1b7c989acda7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f14b5d9ee6327967fdb69d32fc3c1b7c989acda7", "html_url": "https://github.com/rust-lang/rust/commit/f14b5d9ee6327967fdb69d32fc3c1b7c989acda7"}], "stats": {"total": 202, "additions": 107, "deletions": 95}, "files": [{"sha": "78ebd2d139096cb8928224d5d61a6230dc779f8e", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c83d152ebae3667e5545245acbe1b14bf0b74236", "patch": "@@ -12,8 +12,8 @@ use infer::{RegionObligation, InferCtxt};\n use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n-use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n-use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n+use rustc_data_structures::obligation_forest::{Error, ForestObligation, ObligationForest};\n+use rustc_data_structures::obligation_forest::{ObligationProcessor, ProcessResult};\n use std::marker::PhantomData;\n use hir::def_id::DefId;\n use middle::const_val::{ConstEvalErr, ErrKind};\n@@ -263,16 +263,16 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     type Error = FulfillmentErrorCode<'tcx>;\n \n     /// Processes a predicate obligation and returns either:\n-    /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n-    /// - `Ok(None)` if we don't have enough info to be sure\n-    /// - `Err` if the predicate does not hold\n+    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n+    /// - `Unchanged` if we don't have enough info to be sure\n+    /// - `Error(e)` if the predicate does not hold\n     ///\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n     fn process_obligation(&mut self,\n                           pending_obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+                          -> ProcessResult<Self::Obligation, Self::Error>\n     {\n         // if we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n@@ -286,7 +286,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                        self.selcx.infcx()\n                            .resolve_type_vars_if_possible(&pending_obligation.obligation),\n                        pending_obligation.stalled_on);\n-                return Ok(None);\n+                return ProcessResult::Unchanged;\n             }\n             pending_obligation.stalled_on = vec![];\n         }\n@@ -308,15 +308,15 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                     if self.selcx.infcx().predicate_must_hold(&obligation) {\n                         debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n                                data, obligation.recursion_depth);\n-                        return Ok(Some(vec![]))\n+                        return ProcessResult::Changed(vec![])\n                     }\n                 }\n \n                 match self.selcx.select(&trait_obligation) {\n                     Ok(Some(vtable)) => {\n                         debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n                                data, obligation.recursion_depth);\n-                        Ok(Some(mk_pending(vtable.nested_obligations())))\n+                        ProcessResult::Changed(mk_pending(vtable.nested_obligations()))\n                     }\n                     Ok(None) => {\n                         debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n@@ -342,21 +342,21 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n                                pending_obligation.stalled_on);\n \n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n                     Err(selection_err) => {\n                         info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n                               data, obligation.recursion_depth);\n \n-                        Err(CodeSelectionError(selection_err))\n+                        ProcessResult::Error(CodeSelectionError(selection_err))\n                     }\n                 }\n             }\n \n             ty::Predicate::RegionOutlives(ref binder) => {\n                 match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n-                    Ok(()) => Ok(Some(Vec::new())),\n-                    Err(_) => Err(CodeSelectionError(Unimplemented)),\n+                    Ok(()) => ProcessResult::Changed(vec![]),\n+                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n             }\n \n@@ -373,7 +373,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             // If so, this obligation is an error (for now). Eventually we should be\n                             // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                             None => {\n-                                Err(CodeSelectionError(Unimplemented))\n+                                ProcessResult::Error(CodeSelectionError(Unimplemented))\n                             }\n                             // Otherwise, we have something of the form\n                             // `for<'a> T: 'a where 'a not in T`, which we can treat as\n@@ -389,7 +389,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                             cause: obligation.cause.clone(),\n                                         });\n                                 }\n-                                Ok(Some(vec![]))\n+                                ProcessResult::Changed(vec![])\n                             }\n                         }\n                     }\n@@ -404,7 +404,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                     cause: obligation.cause.clone()\n                                 });\n                         }\n-                        Ok(Some(vec![]))\n+                        ProcessResult::Changed(vec![])\n                     }\n                 }\n             }\n@@ -416,32 +416,32 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                         let tcx = self.selcx.tcx();\n                         pending_obligation.stalled_on =\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref(tcx));\n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n-                    Ok(Some(os)) => Ok(Some(mk_pending(os))),\n-                    Err(e) => Err(CodeProjectionError(e))\n+                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+                    Err(e) => ProcessResult::Error(CodeProjectionError(e))\n                 }\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 if !self.selcx.tcx().is_object_safe(trait_def_id) {\n-                    Err(CodeSelectionError(Unimplemented))\n+                    ProcessResult::Error(CodeSelectionError(Unimplemented))\n                 } else {\n-                    Ok(Some(Vec::new()))\n+                    ProcessResult::Changed(vec![])\n                 }\n             }\n \n             ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 match self.selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n-                            Ok(Some(vec![]))\n+                            ProcessResult::Changed(vec![])\n                         } else {\n-                            Err(CodeSelectionError(Unimplemented))\n+                            ProcessResult::Error(CodeSelectionError(Unimplemented))\n                         }\n                     }\n                     None => {\n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n                 }\n             }\n@@ -453,9 +453,9 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                           ty, obligation.cause.span) {\n                     None => {\n                         pending_obligation.stalled_on = vec![ty];\n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n-                    Some(os) => Ok(Some(mk_pending(os)))\n+                    Some(os) => ProcessResult::Changed(mk_pending(os))\n                 }\n             }\n \n@@ -467,24 +467,25 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                         // None means that both are unresolved.\n                         pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n                                                              subtype.skip_binder().b];\n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n                     Some(Ok(ok)) => {\n-                        Ok(Some(mk_pending(ok.obligations)))\n+                        ProcessResult::Changed(mk_pending(ok.obligations))\n                     }\n                     Some(Err(err)) => {\n                         let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n                                                                 subtype.skip_binder().a,\n                                                                 subtype.skip_binder().b);\n-                        Err(FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+                        ProcessResult::Error(\n+                            FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n                     }\n                 }\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 match self.selcx.tcx().lift_to_global(&obligation.param_env) {\n                     None => {\n-                        Ok(None)\n+                        ProcessResult::Unchanged\n                     }\n                     Some(param_env) => {\n                         match self.selcx.tcx().lift_to_global(&substs) {\n@@ -502,19 +503,22 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                     };\n                                     match self.selcx.tcx().at(obligation.cause.span)\n                                                           .const_eval(param_env.and(cid)) {\n-                                        Ok(_) => Ok(Some(vec![])),\n-                                        Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n+                                        Ok(_) => ProcessResult::Changed(vec![]),\n+                                        Err(err) => ProcessResult::Error(\n+                                            CodeSelectionError(ConstEvalFailure(err)))\n                                     }\n                                 } else {\n-                                    Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n-                                        span: obligation.cause.span,\n-                                        kind: ErrKind::CouldNotResolve.into(),\n-                                    })))\n+                                    ProcessResult::Error(\n+                                        CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n+                                            span: obligation.cause.span,\n+                                            kind: ErrKind::CouldNotResolve.into(),\n+                                        }))\n+                                    )\n                                 }\n                             },\n                             None => {\n                                 pending_obligation.stalled_on = substs.types().collect();\n-                                Ok(None)\n+                                ProcessResult::Unchanged\n                             }\n                         }\n                     }"}, {"sha": "1378f46b64cacdfd8b9ab525992c1c29ecaddf70", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=c83d152ebae3667e5545245acbe1b14bf0b74236", "patch": "@@ -41,7 +41,7 @@ pub trait ObligationProcessor {\n \n     fn process_obligation(&mut self,\n                           obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n+                          -> ProcessResult<Self::Obligation, Self::Error>;\n \n     /// As we do the cycle check, we invoke this callback when we\n     /// encounter an actual cycle. `cycle` is an iterator that starts\n@@ -57,6 +57,14 @@ pub trait ObligationProcessor {\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n+/// The result type used by `process_obligation`.\n+#[derive(Debug)]\n+pub enum ProcessResult<O, E> {\n+    Unchanged,\n+    Changed(Vec<O>),\n+    Error(E),\n+}\n+\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -136,8 +144,8 @@ pub struct Outcome<O, E> {\n \n     /// If true, then we saw no successful obligations, which means\n     /// there is no point in further iteration. This is based on the\n-    /// assumption that when trait matching returns `Err` or\n-    /// `Ok(None)`, those results do not affect environmental\n+    /// assumption that when trait matching returns `Error` or\n+    /// `Unchanged`, those results do not affect environmental\n     /// inference state. (Note that if we invoke `process_obligations`\n     /// with no pending obligations, stalled will be true.)\n     pub stalled: bool,\n@@ -270,11 +278,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                    result);\n \n             match result {\n-                Ok(None) => {\n-                    // no change in state\n+                ProcessResult::Unchanged => {\n+                    // No change in state.\n                 }\n-                Ok(Some(children)) => {\n-                    // if we saw a Some(_) result, we are not (yet) stalled\n+                ProcessResult::Changed(children) => {\n+                    // We are not (yet) stalled.\n                     stalled = false;\n                     self.nodes[index].state.set(NodeState::Success);\n \n@@ -290,7 +298,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                         }\n                     }\n                 }\n-                Err(err) => {\n+                ProcessResult::Error(err) => {\n                     stalled = false;\n                     let backtrace = self.error_at(index);\n                     errors.push(Error {"}, {"sha": "527a1ef0ec441052c60823cf079466316e330e90", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83d152ebae3667e5545245acbe1b14bf0b74236/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=c83d152ebae3667e5545245acbe1b14bf0b74236", "patch": "@@ -10,7 +10,7 @@\n \n #![cfg(test)]\n \n-use super::{ObligationForest, ObligationProcessor, Outcome, Error};\n+use super::{Error, ObligationForest, ObligationProcessor, Outcome, ProcessResult};\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -31,7 +31,7 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n \n #[allow(non_snake_case)]\n fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n-    where OF: FnMut(&mut O) -> Result<Option<Vec<O>>, &'static str>,\n+    where OF: FnMut(&mut O) -> ProcessResult<O, &'static str>,\n           BF: FnMut(&[O])\n {\n     ClosureObligationProcessor {\n@@ -44,15 +44,15 @@ fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'stati\n impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O, E>\n     where O: super::ForestObligation + fmt::Debug,\n           E: fmt::Debug,\n-          OF: FnMut(&mut O) -> Result<Option<Vec<O>>, E>,\n+          OF: FnMut(&mut O) -> ProcessResult<O, E>,\n           BF: FnMut(&[O])\n {\n     type Obligation = O;\n     type Error = E;\n \n     fn process_obligation(&mut self,\n                           obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+                          -> ProcessResult<Self::Obligation, Self::Error>\n     {\n         (self.process_obligation)(obligation)\n     }\n@@ -78,9 +78,9 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-                \"B\" => Err(\"B is for broken\"),\n-                \"C\" => Ok(Some(vec![])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+                \"B\" => ProcessResult::Error(\"B is for broken\"),\n+                \"C\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -101,10 +101,10 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(None),\n-                \"A.2\" => Ok(None),\n-                \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n-                \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n+                \"A.1\" => ProcessResult::Unchanged,\n+                \"A.2\" => ProcessResult::Unchanged,\n+                \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n+                \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -119,11 +119,11 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![])),\n-                \"A.2\" => Err(\"A is for apple\"),\n-                \"A.3.i\" => Ok(Some(vec![])),\n-                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                \"A.1\" => ProcessResult::Changed(vec![]),\n+                \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n+                \"A.3.i\" => ProcessResult::Changed(vec![]),\n+                \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n+                \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -138,8 +138,8 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D.1.i\" => Err(\"D is for dumb\"),\n-                \"D.2.i\" => Ok(Some(vec![])),\n+                \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n+                \"D.2.i\" => ProcessResult::Changed(vec![]),\n                 _ => panic!(\"unexpected obligation {:?}\", obligation),\n             }\n         }, |_| {}));\n@@ -167,7 +167,7 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -177,9 +177,9 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![])),\n-                \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n-                \"A.3\" => Ok(Some(vec![])),\n+                \"A.1\" => ProcessResult::Changed(vec![]),\n+                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n+                \"A.3\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -189,8 +189,8 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n-                \"A.2.ii\" => Ok(Some(vec![])),\n+                \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n+                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -200,7 +200,7 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.2.i.a\" => Ok(Some(vec![])),\n+                \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -223,7 +223,7 @@ fn to_errors_no_throw() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -244,7 +244,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -254,8 +254,8 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![\"D\"])),\n-                \"A.2\" => Ok(Some(vec![\"D\"])),\n+                \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n+                \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -266,7 +266,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => { d_count += 1; Ok(Some(vec![])) },\n+                \"D\" => { d_count += 1; ProcessResult::Changed(vec![]) },\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -281,7 +281,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A'\" => Ok(Some(vec![\"A'.1\", \"A'.2\"])),\n+                \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -291,8 +291,8 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A'.1\" => Ok(Some(vec![\"D'\", \"A'\"])),\n-                \"A'.2\" => Ok(Some(vec![\"D'\"])),\n+                \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n+                \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -303,7 +303,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D'\" => { d_count += 1; Err(\"operation failed\") },\n+                \"D'\" => { d_count += 1; ProcessResult::Error(\"operation failed\") },\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -329,7 +329,7 @@ fn done_dependency() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => Ok(Some(vec![])),\n+                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -340,11 +340,11 @@ fn done_dependency() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"(A,B,C): Sized\" => Ok(Some(vec![\n+                \"(A,B,C): Sized\" => ProcessResult::Changed(vec![\n                     \"A: Sized\",\n                     \"B: Sized\",\n                     \"C: Sized\"\n-                        ])),\n+                        ]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -367,10 +367,10 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"D\", \"E\"])),\n-                \"B\" => Ok(None),\n-                \"C1\" => Ok(Some(vec![])),\n-                \"C2\" => Ok(Some(vec![])),\n+                \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n+                \"B\" => ProcessResult::Unchanged,\n+                \"C1\" => ProcessResult::Changed(vec![]),\n+                \"C2\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -380,8 +380,8 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" | \"E\" => Ok(None),\n-                \"B\" => Ok(Some(vec![\"D\"])),\n+                \"D\" | \"E\" => ProcessResult::Unchanged,\n+                \"B\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -391,8 +391,8 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => Ok(None),\n-                \"E\" => Err(\"E is for error\"),\n+                \"D\" => ProcessResult::Unchanged,\n+                \"E\" => ProcessResult::Error(\"E is for error\"),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -405,7 +405,7 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => Err(\"D is dead\"),\n+                \"D\" => ProcessResult::Error(\"D is dead\"),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -429,8 +429,8 @@ fn simultaneous_register_and_error() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Err(\"An error\"),\n-                \"B\" => Ok(Some(vec![\"A\"])),\n+                \"A\" => ProcessResult::Error(\"An error\"),\n+                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -447,8 +447,8 @@ fn simultaneous_register_and_error() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Err(\"An error\"),\n-                \"B\" => Ok(Some(vec![\"A\"])),\n+                \"A\" => ProcessResult::Error(\"An error\"),\n+                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));"}]}