{"sha": "c8a5d4b6000146db63574196970e9f7d803a386d", "node_id": "C_kwDOAAsO6NoAKGM4YTVkNGI2MDAwMTQ2ZGI2MzU3NDE5Njk3MGU5ZjdkODAzYTM4NmQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-28T14:13:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-28T20:54:50Z"}, "message": "relative futex and condvar timeouts can work with isolation", "tree": {"sha": "14acb884fd80ca76abaee9bbc15d8c6f35cea8c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14acb884fd80ca76abaee9bbc15d8c6f35cea8c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a5d4b6000146db63574196970e9f7d803a386d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a5d4b6000146db63574196970e9f7d803a386d", "html_url": "https://github.com/rust-lang/rust/commit/c8a5d4b6000146db63574196970e9f7d803a386d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a5d4b6000146db63574196970e9f7d803a386d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "html_url": "https://github.com/rust-lang/rust/commit/a0fbf0d0775d37d61a62643f2f3bdf45f8763067"}], "stats": {"total": 107, "additions": 100, "deletions": 7}, "files": [{"sha": "292b9d2e7a17626a5641bfbb1d3d5bc7c7d6065d", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=c8a5d4b6000146db63574196970e9f7d803a386d", "patch": "@@ -90,9 +90,11 @@ pub fn futex<'tcx>(\n             let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n-                this.check_no_isolation(\n-                    \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\",\n-                )?;\n+                if op & futex_realtime != 0 {\n+                    this.check_no_isolation(\n+                        \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout with `FUTEX_CLOCK_REALTIME`\",\n+                    )?;\n+                }\n                 let duration = match this.read_timespec(&timeout)? {\n                     Some(duration) => duration,\n                     None => {"}, {"sha": "fcb006920794c52da58e605e4a7a7270223d116f", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=c8a5d4b6000146db63574196970e9f7d803a386d", "patch": "@@ -743,8 +743,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n-\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n@@ -761,6 +759,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n+            this.check_no_isolation(\"`pthread_cond_timedwait` with `CLOCK_REALTIME`\")?;\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n             Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())"}, {"sha": "8156ae8af1ef11128bc9d61a81709835d81bae32", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=c8a5d4b6000146db63574196970e9f7d803a386d", "patch": "@@ -254,8 +254,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n             None\n         } else {\n-            this.check_no_isolation(\"`WaitOnAddress` with non-infinite timeout\")?;\n-\n             let duration = Duration::from_millis(timeout_ms.into());\n             Some(Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap()))\n         };"}, {"sha": "103ce44006d3ad39ca76f8150716c7efcb392828", "filename": "src/tools/miri/tests/pass-dep/concurrency/libc_pthread_cond_isolated.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs?ref=c8a5d4b6000146db63574196970e9f7d803a386d", "patch": "@@ -0,0 +1,82 @@\n+//@ignore-target-windows: No libc on Windows\n+//@ignore-target-apple: pthread_condattr_setclock is not supported on MacOS.\n+\n+/// Test that conditional variable timeouts are working properly\n+/// with monotonic clocks even under isolation.\n+use std::mem::MaybeUninit;\n+use std::time::Instant;\n+\n+fn test_timed_wait_timeout(clock_id: i32) {\n+    unsafe {\n+        let mut attr: MaybeUninit<libc::pthread_condattr_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_condattr_init(attr.as_mut_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(attr.as_mut_ptr(), clock_id), 0);\n+\n+        let mut cond: MaybeUninit<libc::pthread_cond_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_cond_init(cond.as_mut_ptr(), attr.as_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_destroy(attr.as_mut_ptr()), 0);\n+\n+        let mut mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n+\n+        let mut now_mu: MaybeUninit<libc::timespec> = MaybeUninit::uninit();\n+        assert_eq!(libc::clock_gettime(clock_id, now_mu.as_mut_ptr()), 0);\n+        let now = now_mu.assume_init();\n+        // Waiting for a second... mostly because waiting less requires mich more tricky arithmetic.\n+        // FIXME: wait less.\n+        let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n+\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        let current_time = Instant::now();\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n+        );\n+        let elapsed_time = current_time.elapsed().as_millis();\n+        assert!(900 <= elapsed_time && elapsed_time <= 1300);\n+\n+        // Test calling `pthread_cond_timedwait` again with an already elapsed timeout.\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n+        );\n+\n+        // Test that invalid nanosecond values (above 10^9 or negative) are rejected with the\n+        // correct error code.\n+        let invalid_timeout_1 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: 1_000_000_000 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_1\n+            ),\n+            libc::EINVAL\n+        );\n+        let invalid_timeout_2 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: -1 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_2\n+            ),\n+            libc::EINVAL\n+        );\n+        // Test that invalid second values (negative) are rejected with the correct error code.\n+        let invalid_timeout_3 = libc::timespec { tv_sec: -1, tv_nsec: 0 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_3\n+            ),\n+            libc::EINVAL\n+        );\n+\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_cond_destroy(cond.as_mut_ptr()), 0);\n+    }\n+}\n+\n+fn main() {\n+    test_timed_wait_timeout(libc::CLOCK_MONOTONIC);\n+}"}, {"sha": "bf004012e8489113f1d3d9909c5c1fee1db4b5d7", "filename": "src/tools/miri/tests/pass/concurrency/thread_park_isolated.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a5d4b6000146db63574196970e9f7d803a386d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs?ref=c8a5d4b6000146db63574196970e9f7d803a386d", "patch": "@@ -0,0 +1,12 @@\n+//@ignore-target-apple: park_timeout on macOS uses the system clock\n+use std::thread;\n+use std::time::{Duration, Instant};\n+\n+fn main() {\n+    let start = Instant::now();\n+\n+    thread::park_timeout(Duration::from_millis(200));\n+\n+    // Thanks to deterministic execution, this will wiat *exactly* 200ms (rounded to 1ms).\n+    assert!((200..201).contains(&start.elapsed().as_millis()));\n+}"}]}