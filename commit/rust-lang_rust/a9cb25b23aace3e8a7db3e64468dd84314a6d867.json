{"sha": "a9cb25b23aace3e8a7db3e64468dd84314a6d867", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2IyNWIyM2FhY2UzZThhN2RiM2U2NDQ2OGRkODQzMTRhNmQ4Njc=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "nashenas88@users.noreply.github.com", "date": "2017-11-17T09:34:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:11Z"}, "message": "inform constraint generation using maybe-init\n\nIn particular, if we see a variable is DROP-LIVE, but it is not\nMAYBE-INIT, then we can ignore the drop. This leavess attempt to use\nmore complex refinements of the idea (e.g., for subpaths or subfields)\nto future work.", "tree": {"sha": "bbc932afb29cce1b628aab2700ca54c4181bccf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbc932afb29cce1b628aab2700ca54c4181bccf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cb25b23aace3e8a7db3e64468dd84314a6d867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cb25b23aace3e8a7db3e64468dd84314a6d867", "html_url": "https://github.com/rust-lang/rust/commit/a9cb25b23aace3e8a7db3e64468dd84314a6d867", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cb25b23aace3e8a7db3e64468dd84314a6d867/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08c8d7e91917dd7265042d6ccf204e241f17db32", "url": "https://api.github.com/repos/rust-lang/rust/commits/08c8d7e91917dd7265042d6ccf204e241f17db32", "html_url": "https://github.com/rust-lang/rust/commit/08c8d7e91917dd7265042d6ccf204e241f17db32"}], "stats": {"total": 452, "additions": 374, "deletions": 78}, "files": [{"sha": "446aba3d3d72c595b042b7a1d500a222c11e92bc", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "renamed", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -18,7 +18,6 @@ use rustc::ty::maps::Providers;\n use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Local, Location, Place};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n-use transform::nll;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n@@ -39,6 +38,7 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n \n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -77,7 +77,21 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n-    let move_data: MoveData<'tcx> = match MoveData::gather_moves(input_mir, tcx) {\n+    // Make our own copy of the MIR. This copy will be modified (in place) to\n+    // contain non-lexical lifetimes. It will have a lifetime tied\n+    // to the inference context.\n+    let mut mir: Mir<'tcx> = input_mir.clone();\n+    let free_regions = if !tcx.sess.opts.debugging_opts.nll {\n+        None\n+    } else {\n+        let mir = &mut mir;\n+\n+        // Replace all regions with fresh inference variables.\n+        Some(nll::replace_regions_in_mir(infcx, def_id, mir))\n+    };\n+    let mir = &mir;\n+\n+    let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n         Err((move_data, move_errors)) => {\n             for move_error in move_errors {\n@@ -110,69 +124,64 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    // Make our own copy of the MIR. This copy will be modified (in place) to\n-    // contain non-lexical lifetimes. It will have a lifetime tied\n-    // to the inference context.\n-    let mut mir: Mir<'tcx> = input_mir.clone();\n-    let mir = &mut mir;\n-\n-    // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let opt_regioncx = if !tcx.sess.opts.debugging_opts.nll {\n-        None\n-    } else {\n-        Some(nll::compute_regions(infcx, def_id, param_env, mir))\n-    };\n-\n     let mdpe = MoveDataParamEnv {\n         move_data: move_data,\n         param_env: param_env,\n     };\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-    let flow_borrows = do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx.as_ref()),\n-        |bd, i| bd.location(i),\n-    );\n-    let flow_inits = do_dataflow(\n+    let mut flow_inits = FlowInProgress::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n         &attributes,\n         &dead_unwinds,\n         MaybeInitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n-    );\n-    let flow_uninits = do_dataflow(\n+    ));\n+    let flow_uninits = FlowInProgress::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n         &attributes,\n         &dead_unwinds,\n         MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n-    );\n-    let flow_move_outs = do_dataflow(\n+    ));\n+    let flow_move_outs = FlowInProgress::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n         &attributes,\n         &dead_unwinds,\n         MovingOutStatements::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().moves[i],\n-    );\n-    let flow_ever_inits = do_dataflow(\n+    ));\n+    let flow_ever_inits = FlowInProgress::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n         &attributes,\n         &dead_unwinds,\n         EverInitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().inits[i],\n-    );\n+    ));\n+\n+    // If we are in non-lexical mode, compute the non-lexical lifetimes.\n+    let opt_regioncx = if let Some(free_regions) = free_regions {\n+        Some(nll::compute_regions(\n+            infcx,\n+            def_id,\n+            free_regions,\n+            mir,\n+            param_env,\n+            &mut flow_inits,\n+            &mdpe.move_data,\n+        ))\n+    } else {\n+        assert!(!tcx.sess.opts.debugging_opts.nll);\n+        None\n+    };\n+    let flow_inits = flow_inits; // remove mut\n \n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n@@ -183,6 +192,16 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         storage_dead_or_drop_error_reported: FxHashSet(),\n     };\n \n+    let flow_borrows = FlowInProgress::new(do_dataflow(\n+        tcx,\n+        mir,\n+        id,\n+        &attributes,\n+        &dead_unwinds,\n+        Borrows::new(tcx, mir, opt_regioncx),\n+        |bd, i| bd.location(i),\n+    ));\n+\n     let mut state = InProgress::new(\n         flow_borrows,\n         flow_inits,\n@@ -2318,19 +2337,19 @@ impl ContextKind {\n }\n \n impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n-    pub(super) fn new(\n-        borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n-        inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-        move_out: DataflowResults<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: DataflowResults<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    fn new(\n+        borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n+        inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+        uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n     ) -> Self {\n         InProgress {\n-            borrows: FlowInProgress::new(borrows),\n-            inits: FlowInProgress::new(inits),\n-            uninits: FlowInProgress::new(uninits),\n-            move_outs: FlowInProgress::new(move_out),\n-            ever_inits: FlowInProgress::new(ever_inits),\n+            borrows,\n+            inits,\n+            uninits,\n+            move_outs,\n+            ever_inits,\n         }\n     }\n \n@@ -2436,8 +2455,11 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'b, 'gcx, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>> {\n-    fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n+impl<'tcx, T> FlowInProgress<T>\n+where\n+    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n+{\n+    fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n         let move_data = self.base_results.operator().move_data();\n \n         let mut todo = vec![mpi];", "previous_filename": "src/librustc_mir/borrow_check.rs"}, {"sha": "460d49af20e51dfe93685721bcf8b6d861e6bf9b", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "renamed", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::mir::{Location, Place, Mir, Rvalue};\n+use rustc::mir::{Local, Location, Place, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n use rustc::mir::{PlaceProjection, ProjectionElem};\n@@ -20,36 +20,46 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n+use borrow_check::FlowInProgress;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::{MoveData, HasMoveData};\n \n use super::LivenessResults;\n use super::ToRegionVid;\n use super::region_infer::RegionInferenceContext;\n \n-pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     liveness: &LivenessResults,\n+    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n ) {\n     ConstraintGeneration {\n         infcx,\n         regioncx,\n         mir,\n         liveness,\n         param_env,\n+        flow_inits,\n+        move_data,\n     }.add_constraints();\n }\n \n-struct ConstraintGeneration<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    mir: &'cx Mir<'tcx>,\n-    liveness: &'cx LivenessResults,\n+/// 'cg = the duration of the constraint generation process itself.\n+struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    regioncx: &'cg mut RegionInferenceContext<'tcx>,\n+    mir: &'cg Mir<'tcx>,\n+    liveness: &'cg LivenessResults,\n     param_env: ty::ParamEnv<'tcx>,\n+    flow_inits: &'cg mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &'cg MoveData<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     fn add_constraints(&mut self) {\n         self.add_liveness_constraints();\n         self.add_borrow_constraints();\n@@ -73,14 +83,51 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n                     }\n                 });\n \n-            self.liveness\n-                .drop\n-                .simulate_block(self.mir, bb, |location, live_locals| {\n-                    for live_local in live_locals.iter() {\n+            let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+            self.liveness.drop.simulate_block(self.mir, bb, |location, live_locals| {\n+                all_live_locals.push((location, live_locals.iter().collect()));\n+            });\n+            debug!(\"add_liveness_constraints: all_live_locals={:#?}\", all_live_locals);\n+\n+            let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n+            self.flow_inits.reset_to_entry_of(bb);\n+            while let Some((location, live_locals)) = all_live_locals.pop() {\n+                for live_local in live_locals {\n+                    debug!(\"add_liveness_constraints: location={:?} live_local={:?}\", location,\n+                           live_local);\n+\n+                    self.flow_inits.each_state_bit(|mpi_init| {\n+                        debug!(\"add_liveness_constraints: location={:?} initialized={:?}\",\n+                               location,\n+                               &self.flow_inits\n+                                   .base_results\n+                                   .operator()\n+                                   .move_data()\n+                                   .move_paths[mpi_init]);\n+                    });\n+\n+                    let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                    if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n+                        debug!(\"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n+                               self.move_data.move_paths[mpi],\n+                               self.move_data.move_paths[initialized_child]);\n+\n                         let live_local_ty = self.mir.local_decls[live_local].ty;\n                         self.add_drop_live_constraint(live_local_ty, location);\n                     }\n-                });\n+                }\n+\n+                if location.statement_index == terminator_index {\n+                    debug!(\"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n+                           location);\n+                    self.flow_inits.reconstruct_terminator_effect(location);\n+                } else {\n+                    debug!(\"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n+                           location);\n+                    self.flow_inits.reconstruct_statement_effect(location);\n+                }\n+                self.flow_inits.apply_local_effect();\n+            }\n         }\n     }\n \n@@ -219,7 +266,7 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n+impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {", "previous_filename": "src/librustc_mir/transform/nll/constraint_generation.rs"}, {"sha": "92a8a714d525a09a369a08f55167c77879613f00", "filename": "src/librustc_mir/borrow_check/nll/free_regions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffree_regions.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "previous_filename": "src/librustc_mir/transform/nll/free_regions.rs"}, {"sha": "213cf52a8eb36434d860f81c41306762b14133ed", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "renamed", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -17,43 +17,62 @@ use std::collections::BTreeSet;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n+use borrow_check::FlowInProgress;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n mod subtype_constraint_generation;\n mod free_regions;\n+use self::free_regions::FreeRegions;\n \n pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n \n mod renumber;\n \n-/// Computes the (non-lexical) regions from the input MIR.\n-///\n-/// This may result in errors being reported.\n-pub fn compute_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+/// Rewrites the regions in the MIR to use NLL variables, also\n+/// scraping out the set of free regions (e.g., region parameters)\n+/// declared on the function. That set will need to be given to\n+/// `compute_regions`.\n+pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n-    param_env: ty::ParamEnv<'gcx>,\n     mir: &mut Mir<'tcx>,\n-) -> RegionInferenceContext<'tcx> {\n+) -> FreeRegions<'tcx> {\n     // Compute named region information.\n-    let free_regions = &free_regions::free_regions(infcx, def_id);\n+    let free_regions = free_regions::free_regions(infcx, def_id);\n \n     // Replace all regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, free_regions, mir);\n+    renumber::renumber_mir(infcx, &free_regions, mir);\n+\n+    free_regions\n+}\n \n+/// Computes the (non-lexical) regions from the input MIR.\n+///\n+/// This may result in errors being reported.\n+pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    def_id: DefId,\n+    free_regions: FreeRegions<'tcx>,\n+    mir: &Mir<'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n+    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) -> RegionInferenceContext<'tcx> {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, free_regions, mir, constraint_sets);\n+    let mut regioncx = RegionInferenceContext::new(var_origins, &free_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, &free_regions, mir, constraint_sets);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -75,7 +94,15 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n     };\n \n     // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, param_env, liveness);\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut regioncx,\n+        &mir,\n+        param_env,\n+        liveness,\n+        flow_inits,\n+        move_data,\n+    );\n \n     // Solve the region constraints.\n     regioncx.solve(infcx, &mir);", "previous_filename": "src/librustc_mir/transform/nll/mod.rs"}, {"sha": "f60bd3c6ecec5a89345de26bf97230bdbeab093c", "filename": "src/librustc_mir/borrow_check/nll/region_infer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "previous_filename": "src/librustc_mir/transform/nll/region_infer.rs"}, {"sha": "1076b774de6578851392bdf8c386d19d30c1f65a", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "previous_filename": "src/librustc_mir/transform/nll/renumber.rs"}, {"sha": "c1850c76541d78f75d4c1f6e06cf50ab6ab459f6", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "previous_filename": "src/librustc_mir/transform/nll/subtype_constraint_generation.rs"}, {"sha": "286ca768b16bf1639b82cbe512571d88cc5876ac", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -21,8 +21,8 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n \n use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n pub use dataflow::indexes::BorrowIndex;\n-use transform::nll::region_infer::RegionInferenceContext;\n-use transform::nll::ToRegionVid;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n@@ -38,7 +38,7 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>,\n+    nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -69,7 +69,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>)\n+               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>)\n                -> Self {\n         let mut visitor = GatherBorrows {\n             tcx,\n@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n-        if let Some(regioncx) = self.nonlexical_regioncx {\n+        if let Some(ref regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {"}, {"sha": "9d91e1344dc373b16f27c6a2b58a3ea47f0e516d", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -263,6 +263,10 @@ impl<'tcx> MovePathLookup<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn find_local(&self, local: Local) -> MovePathIndex {\n+        self.locals[local]\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "fb9daf07c71dc735a894c260d482496bec3e0a3c", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -43,7 +43,6 @@ pub mod instcombine;\n pub mod copy_prop;\n pub mod generator;\n pub mod inline;\n-pub mod nll;\n pub mod lower_128bit;\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "0047f6d59237c5d20e5282c9453e442ce6f01c17", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.b);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+    // FIXME ^ Should not error in the future with implicit dtors, only manually implemented ones\n+}"}, {"sha": "389334f9c1d8debb5033bfc8b6ce32c7414c0c4c", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:31:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "64a4d391000630ed5672184dba12ebf42473e783", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    std::mem::drop(wrap);\n+    x = 1; // OK, drop is inert\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867"}, {"sha": "3242136f005e713190e84a898f76c932534282c6", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.a);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "9edeca2d18801512fe7d73e8c64ca1c30bbeece3", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-with-fragment.rs:31:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "3e32818b8dcf33b651b1854e88679f0b837301b4", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.a);\n+    std::mem::drop(foo.b);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+    // FIXME ^ This currently errors and it should not.\n+}"}, {"sha": "24d0d6d04c8da34eef27e9814f6d9bae9ee8be7c", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-with-uninitialized-fragments.rs:32:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+32 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "291fcbd73f3e1e23406025aea6a2029d8779eb52", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "7b1b55d133ac56f467bf89f3c1845db0d2f8dc2b", "filename": "src/test/ui/nll/maybe-initialized-drop.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9cb25b23aace3e8a7db3e64468dd84314a6d867/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr?ref=a9cb25b23aace3e8a7db3e64468dd84314a6d867", "patch": "@@ -0,0 +1,10 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop.rs:26:5\n+   |\n+25 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+26 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}]}