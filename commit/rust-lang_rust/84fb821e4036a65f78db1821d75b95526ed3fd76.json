{"sha": "84fb821e4036a65f78db1821d75b95526ed3fd76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZmI4MjFlNDAzNmE2NWY3OGRiMTgyMWQ3NWI5NTUyNmVkM2ZkNzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-19T00:33:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-19T01:53:36Z"}, "message": "Try harder to disambig blocks followed by various exprs in pprust. Closes #840\n\nAs it turns out, it's not just unops we need to worry about. Also tuples and\nanything that requires parens.", "tree": {"sha": "bd6a26b5d8ad6d199924ed5bdeb8b101f8d5f239", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd6a26b5d8ad6d199924ed5bdeb8b101f8d5f239"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84fb821e4036a65f78db1821d75b95526ed3fd76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84fb821e4036a65f78db1821d75b95526ed3fd76", "html_url": "https://github.com/rust-lang/rust/commit/84fb821e4036a65f78db1821d75b95526ed3fd76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84fb821e4036a65f78db1821d75b95526ed3fd76/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d03b7b1fbb970320aff049b5135fecc81a24fdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d03b7b1fbb970320aff049b5135fecc81a24fdd", "html_url": "https://github.com/rust-lang/rust/commit/4d03b7b1fbb970320aff049b5135fecc81a24fdd"}], "stats": {"total": 154, "additions": 139, "deletions": 15}, "files": [{"sha": "5953168307493c962191542efd401927d79b97e4", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/84fb821e4036a65f78db1821d75b95526ed3fd76/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84fb821e4036a65f78db1821d75b95526ed3fd76/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=84fb821e4036a65f78db1821d75b95526ed3fd76", "patch": "@@ -7,6 +7,7 @@ import std::uint;\n import std::option;\n import parse::lexer;\n import syntax::codemap::codemap;\n+import syntax::visit;\n import ast;\n import option::some;\n import option::none;\n@@ -596,13 +597,13 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n \n     let last_stmt = option::none;\n     for st: @ast::stmt in blk.node.stmts {\n-        maybe_protect_unop(s, last_stmt, stmt_(st));\n+        maybe_protect_block(s, last_stmt, stmt_(st));\n         print_stmt(s, *st);\n         last_stmt = option::some(st);\n     }\n     alt blk.node.expr {\n       some(expr) {\n-        maybe_protect_unop(s, last_stmt, expr_(expr));\n+        maybe_protect_block(s, last_stmt, expr_(expr));\n         space_if_not_bol(s);\n         print_expr(s, expr);\n         maybe_print_trailing_comment(s, expr.span, some(blk.span.hi));\n@@ -615,11 +616,10 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n     tag expr_or_stmt { stmt_(@ast::stmt); expr_(@ast::expr); }\n \n     // The Rust syntax has an ambiguity when an if, alt, or block statement is\n-    // followed by a unary op statement. In those cases we have to add an\n-    // extra semi to make sure the unop is not parsed as a binop with the\n-    // if/alt/block expression.\n-    fn maybe_protect_unop(s: &ps, last: &option::t<@ast::stmt>,\n-                          next: &expr_or_stmt) {\n+    // followed by a unary op or paren. In those cases we have to add an\n+    // extra semi to make sure the output retains the same meaning.\n+    fn maybe_protect_block(s: &ps, last: &option::t<@ast::stmt>,\n+                           next: &expr_or_stmt) {\n         let last_expr_is_block = alt last {\n           option::some(@{node: ast::stmt_expr(e, _), _}) {\n             alt e.node {\n@@ -632,20 +632,74 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n           }\n           _ { false }\n         };\n-        let next_expr_is_unnop = alt next {\n-          expr_(@{node: ast::expr_unary(_, _), _}) { true }\n+\n+        if !last_expr_is_block { ret; }\n+\n+        let next_expr_is_ambig = alt next {\n+          expr_(e) { expr_is_ambig(e) }\n           stmt_(@{node: ast::stmt_expr(e, _), _}) {\n-            alt e.node {\n-              ast::expr_unary(_, _) { true }\n-              _ { false }\n-            }\n+            expr_is_ambig(e)\n           }\n           _ { false }\n         };\n \n-        if last_expr_is_block && next_expr_is_unnop {\n+        if last_expr_is_block && next_expr_is_ambig {\n             word(s.s, \";\");\n         }\n+\n+        fn expr_is_ambig(ex: @ast::expr) -> bool {\n+          // We're going to walk the expression to the 'left' looking for\n+          // various properties that might indicate ambiguity\n+\n+          type env = @mutable bool;\n+          let visitor = visit::mk_vt(@{\n+              visit_expr: visit_expr\n+                  with *visit::default_visitor()\n+          });\n+          let env = @mutable false;\n+          visit_expr(ex, env, visitor);\n+          ret *env;\n+\n+          fn visit_expr(ex: &@ast::expr, e: &env, v: &visit::vt<env>) {\n+              assert *e == false;\n+\n+              if expr_is_ambig(ex) {\n+                  *e = true;\n+                  ret;\n+              }\n+\n+              alt ex.node {\n+                ast::expr_assign(x, _) { v.visit_expr(x, e, v); }\n+                ast::expr_assign_op(_, x, _) { visit_expr(x, e, v); }\n+                ast::expr_move(x, _) { v.visit_expr(x, e, v); }\n+                ast::expr_field(x, _) { v.visit_expr(x, e, v); }\n+                ast::expr_index(x, _) { v.visit_expr(x, e, v); }\n+                ast::expr_binary(op, x, _) {\n+                  if need_parens(x, operator_prec(op)) {\n+                      *e = true;\n+                      ret;\n+                  }\n+                  v.visit_expr(x, e, v);\n+                }\n+                ast::expr_cast(x, _) {\n+                  if need_parens(x, parse::parser::as_prec) {\n+                      *e = true;\n+                      ret;\n+                  }\n+                }\n+                ast::expr_ternary(x, _, _) { v.visit_expr(x, e, v); }\n+                _ { }\n+              }\n+          }\n+\n+          fn expr_is_ambig(ex: @ast::expr) -> bool {\n+              alt ex.node {\n+                ast::expr_unary(_, _) { true }\n+                ast::expr_tup(_) { true }\n+                _ { false }\n+              }\n+          }\n+        }\n     }\n }\n \n@@ -1307,7 +1361,7 @@ fn operator_prec(op: ast::binop) -> int {\n     fail;\n }\n \n-fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n+fn need_parens(expr: &@ast::expr, outer_prec: int) -> bool {\n     let add_them;\n     alt expr.node {\n       ast::expr_binary(op, _, _) {\n@@ -1319,6 +1373,11 @@ fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n       }\n       _ { add_them = false; }\n     }\n+    ret add_them;\n+}\n+\n+fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n+    let add_them = need_parens(expr, outer_prec);\n     if add_them { popen(s); }\n     print_expr(s, expr);\n     if add_them { pclose(s); }"}, {"sha": "f035b9393c28d25043944fc2f68173429d2878e6", "filename": "src/test/pretty/block-disambig.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/84fb821e4036a65f78db1821d75b95526ed3fd76/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84fb821e4036a65f78db1821d75b95526ed3fd76/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=84fb821e4036a65f78db1821d75b95526ed3fd76", "patch": "@@ -0,0 +1,65 @@\n+// Tests that the pretty printer correctly disambiguates various scenarios\n+// involving block statements by ending them with a semi-colon\n+fn test1() {\n+    let val = @0;\n+    {};\n+    *val;\n+}\n+\n+fn test2() -> int {\n+    let val = @0;\n+    {};\n+    *val\n+}\n+\n+fn test3() {\n+    let regs = @{mutable eax: 0};\n+    alt true {\n+      true { }\n+    };\n+    (*regs).eax = 1;\n+}\n+\n+fn test4() -> bool {\n+    let regs = @true;\n+    if true { };\n+    *regs || false\n+}\n+\n+fn test5() -> (int, int) {\n+    {};\n+    (0, 1)\n+}\n+\n+fn test6() -> bool {\n+    {};\n+    (true || false) && true\n+}\n+\n+fn test7() -> uint {\n+    let regs = @0;\n+    alt true { true { } };\n+    (*regs < 2) as uint\n+}\n+\n+fn test8() -> int {\n+    let val = @0;\n+    alt true { true { } };\n+    *val < 1 ? 0 : 1\n+}\n+\n+fn test9() {\n+    let regs = @mutable 0;\n+    alt true {\n+      true { }\n+    };\n+    *regs += 1;\n+}\n+\n+fn test10() -> int {\n+    let regs = @mutable [0];\n+    alt true {\n+      true { }\n+    };\n+    (*regs).(0)\n+}"}]}