{"sha": "35dbc5ec47be07d8d2f029a19ae39cf76d521369", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZGJjNWVjNDdiZTA3ZDhkMmYwMjlhMTlhZTM5Y2Y3NmQ1MjEzNjk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-27T12:12:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-27T12:12:37Z"}, "message": "Rollup merge of #60292 - varkor:ty-tuple-substs, r=nikomatsakis\n\nReplace the `&'tcx List<Ty<'tcx>>` in `TyKind::Tuple` with `SubstsRef<'tcx>`\n\nPart of the suggested refactoring for https://github.com/rust-lang/rust/issues/42340. As expected, this is a little messy, because there are many places that the components of tuples are expected to be types, rather than arbitrary kinds. However, it should open up the way for a refactoring of `TyS` itself.\n\nr? @nikomatsakis", "tree": {"sha": "413575d0dfa661149af0210d1fe6dbf04f16581c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/413575d0dfa661149af0210d1fe6dbf04f16581c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35dbc5ec47be07d8d2f029a19ae39cf76d521369", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcxEc1CRBK7hj4Ov3rIwAAdHIIAIehiSYSK+TKONFsevxNgVqo\n6U5dLMZi0XB08LpcwlVh2SCN4kqY9EmwzxOMAboG9BxLLCzp1Py6vuwJamqhqzIq\nFhJQ+i1nbrSEhZn1D0MFXIHezaKXzjuy1lw85mqaqJNR7K5tiO2ubKglEp/zQaAP\n6khtUbA9gm9UlLQ+11Vh7d65hFH/qmoHQy8ivoHWh3Vc2OZvkQEIz1Bn5fRo/iAa\nwMFHKmZ8pA/zHPSMRLBoziX9LbtN9FBOidNY3qaK3N7HVviuuCLWJ0VxdVazBMLz\nZejh4guSkkfXc0RQBx1qWVAjNly8ibLvitcSrwthsyR676MRJe7KAcDKvnB/xHI=\n=tczd\n-----END PGP SIGNATURE-----\n", "payload": "tree 413575d0dfa661149af0210d1fe6dbf04f16581c\nparent d4a32d504a5aa49b951bfc70602a9615cb772acf\nparent a3470c61890710421ddb82fbe72b1ca8fdc8e078\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556367157 +0200\ncommitter GitHub <noreply@github.com> 1556367157 +0200\n\nRollup merge of #60292 - varkor:ty-tuple-substs, r=nikomatsakis\n\nReplace the `&'tcx List<Ty<'tcx>>` in `TyKind::Tuple` with `SubstsRef<'tcx>`\n\nPart of the suggested refactoring for https://github.com/rust-lang/rust/issues/42340. As expected, this is a little messy, because there are many places that the components of tuples are expected to be types, rather than arbitrary kinds. However, it should open up the way for a refactoring of `TyS` itself.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35dbc5ec47be07d8d2f029a19ae39cf76d521369", "html_url": "https://github.com/rust-lang/rust/commit/35dbc5ec47be07d8d2f029a19ae39cf76d521369", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35dbc5ec47be07d8d2f029a19ae39cf76d521369/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a32d504a5aa49b951bfc70602a9615cb772acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a32d504a5aa49b951bfc70602a9615cb772acf", "html_url": "https://github.com/rust-lang/rust/commit/d4a32d504a5aa49b951bfc70602a9615cb772acf"}, {"sha": "a3470c61890710421ddb82fbe72b1ca8fdc8e078", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3470c61890710421ddb82fbe72b1ca8fdc8e078", "html_url": "https://github.com/rust-lang/rust/commit/a3470c61890710421ddb82fbe72b1ca8fdc8e078"}], "stats": {"total": 239, "additions": 146, "deletions": 93}, "files": [{"sha": "5d1dca5a1f4c4f4ee90d126977fad2d978f4769d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n-            ty::Tuple(ref tys) => tys[f.index()],\n+            ty::Tuple(ref tys) => tys[f.index()].expect_ty(),\n             _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n         };\n         debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);"}, {"sha": "76a751536523d2d1ebdaf3d50e55f4eac1b16db4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -875,7 +875,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n                 let expected = match expected_ty.sty {\n                     ty::Tuple(ref tys) => tys.iter()\n-                        .map(|t| ArgKind::from_expected_ty(t, Some(span))).collect(),\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span))).collect(),\n                     _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n                 };\n \n@@ -1247,7 +1247,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n-                    inputs.iter().cloned(),\n+                    inputs.iter().map(|k| k.expect_ty()),\n                     tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n                     false,\n                     hir::Unsafety::Normal,"}, {"sha": "5800b024ad2459bfefd064b261e1df428cef5eda", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -217,7 +217,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t)),\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n         ty::Closure(def_id, ref substs) => substs\n             .upvar_tys(def_id, tcx)\n             .all(|t| trivial_dropck_outlives(tcx, t)),"}, {"sha": "8beabe058cf4f7ecf851993b825a967c74e7861c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -2429,7 +2429,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n-            ty::Tuple(tys) => Where(ty::Binder::bind(tys.last().into_iter().cloned().collect())),\n+            ty::Tuple(tys) => {\n+                Where(ty::Binder::bind(tys.last().into_iter().map(|k| k.expect_ty()).collect()))\n+            }\n \n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n@@ -2503,7 +2505,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(tys.to_vec()))\n+                Where(ty::Binder::bind(tys.iter().map(|k| k.expect_ty()).collect()))\n             }\n \n             ty::Closure(def_id, substs) => {\n@@ -2590,7 +2592,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Tuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                tys.to_vec()\n+                tys.iter().map(|k| k.expect_ty()).collect()\n             }\n \n             ty::Closure(def_id, ref substs) => substs.upvar_tys(def_id, self.tcx()).collect(),\n@@ -3495,7 +3497,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source tuple with the target's\n                 // last element is equal to the target.\n-                let new_tuple = tcx.mk_tup(a_mid.iter().cloned().chain(iter::once(b_last)));\n+                let new_tuple = tcx.mk_tup(\n+                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n+                );\n                 let InferOk { obligations, .. } = self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .eq(target, new_tuple)\n@@ -3508,7 +3512,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n-                    a_last,\n+                    a_last.expect_ty(),\n                     &[b_last.into()],\n                 ));\n             }"}, {"sha": "132477547a0d86d999e5edc097d716d24983beb5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -2431,7 +2431,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].sty {\n                 ty::Tuple(params) => {\n-                    params.into_iter().cloned()\n+                    params.into_iter().map(|k| k.expect_ty())\n                 }\n                 _ => bug!(),\n             };\n@@ -2573,11 +2573,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        self.mk_ty(Tuple(self.intern_type_list(ts)))\n+        let kinds: Vec<_> = ts.into_iter().map(|&t| Kind::from(t)).collect();\n+        self.mk_ty(Tuple(self.intern_substs(&kinds)))\n     }\n \n     pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(ts))))\n+        iter.intern_with(|ts| {\n+            let kinds: Vec<_> = ts.into_iter().map(|&t| Kind::from(t)).collect();\n+            self.mk_ty(Tuple(self.intern_substs(&kinds)))\n+        })\n     }\n \n     #[inline]"}, {"sha": "cb4724adc932cf6e2abd192641f3ecbe8d22ca53", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -195,8 +195,8 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n \n-            &ty::Tuple(ref ts) => {\n-                self.add_tys(&ts[..]);\n+            &ty::Tuple(ref substs) => {\n+                self.add_substs(substs);\n             }\n \n             &ty::FnDef(_, substs) => {"}, {"sha": "197d3325f51cfdb232dd3c8b3815a9788baca0c3", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n             Tuple(ref tys) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n-                    ty.uninhabited_from(tcx)\n+                    ty.expect_ty().uninhabited_from(tcx)\n                 }))\n             }\n "}, {"sha": "50f01522aeede4fb91ee7ac756fdd562f69d2ef0", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -626,8 +626,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     StructKind::MaybeUnsized\n                 };\n \n-                univariant(&tys.iter().map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n-                           &ReprOptions::default(), kind)?\n+                univariant(&tys.iter().map(|k| {\n+                    self.layout_of(k.expect_ty())\n+                }).collect::<Result<Vec<_>, _>>()?, &ReprOptions::default(), kind)?\n             }\n \n             // SIMD vector types.\n@@ -1723,7 +1724,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 substs.field_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::Tuple(tys) => tys[i],\n+            ty::Tuple(tys) => tys[i].expect_ty(),\n \n             // SIMD vector types.\n             ty::Adt(def, ..) if def.repr.simd() => {"}, {"sha": "b9c908b04d640afd598974d3a6d53b87f91b6176", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -2501,7 +2501,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             Tuple(ref tys) => {\n                 match tys.last() {\n                     None => vec![],\n-                    Some(ty) => self.sized_constraint_for_ty(tcx, ty)\n+                    Some(ty) => self.sized_constraint_for_ty(tcx, ty.expect_ty()),\n                 }\n             }\n "}, {"sha": "d5d4f648444630152aff6318204d807301e79268", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -264,7 +264,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n \n         ty::Tuple(ref tys) => tys.iter()\n-                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                   .filter_map(|ty| characteristic_def_id_of_type(ty.expect_ty()))\n                                    .next(),\n \n         ty::FnDef(def_id, _) |"}, {"sha": "e5803b7be4f63841d505e5e154e604ac87d66498", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -701,7 +701,8 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n                     let mut projections = predicates.projection_bounds();\n                     if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                        p!(pretty_fn_sig(args, false, proj.ty));\n+                        let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n+                        p!(pretty_fn_sig(&tys, false, proj.ty));\n                         resugared = true;\n                     }\n                 }"}, {"sha": "1f5a39cbef14e8208fe0df63bcc988263ae7b587", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -526,7 +526,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Tuple(as_), &ty::Tuple(bs)) =>\n         {\n             if as_.len() == bs.len() {\n-                Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| relation.relate(a, b)))?)\n+                Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| {\n+                    relation.relate(&a.expect_ty(), &b.expect_ty())\n+                }))?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(\n                     expected_found(relation, &as_.len(), &bs.len())))"}, {"sha": "1e8f3ebd0ddcad0931daa8ddc675e52d06f559a7", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -171,7 +171,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n-    Tuple(&'tcx List<Ty<'tcx>>),\n+    Tuple(SubstsRef<'tcx>),\n \n     /// The projection of an associated type. For example,\n     /// `<T as Trait<..>>::N`.\n@@ -1651,7 +1651,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     })\n                 })\n             }\n-            ty::Tuple(tys) => tys.iter().any(|ty| ty.conservative_is_privately_uninhabited(tcx)),\n+            ty::Tuple(tys) => tys.iter().any(|ty| {\n+                ty.expect_ty().conservative_is_privately_uninhabited(tcx)\n+            }),\n             ty::Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n@@ -2087,8 +2089,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) =>\n                 false,\n \n-            ty::Tuple(tys) =>\n-                tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n+            ty::Tuple(tys) => {\n+                tys.iter().all(|ty| ty.expect_ty().is_trivially_sized(tcx))\n+            }\n \n             ty::Adt(def, _substs) =>\n                 def.sized_constraint(tcx).is_empty(),"}, {"sha": "ed3da31fb89bd53a4ff111b65c2eb008cdb4cac6", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -123,6 +123,16 @@ impl<'tcx> Kind<'tcx> {\n             }\n         }\n     }\n+\n+    /// Unpack the `Kind` as a type when it is known certainly to be a type.\n+    /// This is true in cases where `Substs` is used in places where the kinds are known\n+    /// to be limited (e.g. in tuples, where the only parameters are type parameters).\n+    pub fn expect_ty(self) -> Ty<'tcx> {\n+        match self.unpack() {\n+            UnpackedKind::Type(ty) => ty,\n+            _ => bug!(\"expected a type, but found another kind\"),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n@@ -174,8 +184,7 @@ pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n-    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n-                             -> SubstsRef<'tcx> {\n+    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })"}, {"sha": "2db2ef59a6ba052fa84b38f85077236dd25ffd6e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                 ty::Tuple(tys) => {\n                     if let Some((&last_ty, _)) = tys.split_last() {\n-                        ty = last_ty;\n+                        ty = last_ty.expect_ty();\n                     } else {\n                         break;\n                     }\n@@ -316,8 +316,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 (&Tuple(a_tys), &Tuple(b_tys))\n                         if a_tys.len() == b_tys.len() => {\n                     if let Some(a_last) = a_tys.last() {\n-                        a = a_last;\n-                        b = b_tys.last().unwrap();\n+                        a = a_last.expect_ty();\n+                        b = b_tys.last().unwrap().expect_ty();\n                     } else {\n                         break;\n                     }\n@@ -795,7 +795,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 Tuple(ref ts) => {\n                     // Find non representable\n                     fold_repr(ts.iter().map(|ty| {\n-                        is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n+                        is_type_structurally_recursive(\n+                            tcx,\n+                            sp,\n+                            seen,\n+                            representable_cache,\n+                            ty.expect_ty(),\n+                        )\n                     }))\n                 }\n                 // Fixed-length vectors.\n@@ -1048,7 +1054,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // state transformation pass\n         ty::Generator(..) => true,\n \n-        ty::Tuple(ref tys) => tys.iter().cloned().any(needs_drop),\n+        ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).any(needs_drop),\n \n         // unions don't have destructors because of the child types,\n         // only if they manually implement `Drop` (handled above)."}, {"sha": "234407a7c4eafd0d2d8c9de5500c77764fb92488", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -120,7 +120,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n         ty::Tuple(ts) => {\n-            stack.extend(ts.iter().cloned().rev());\n+            stack.extend(ts.iter().map(|k| k.expect_ty()).rev());\n         }\n         ty::FnDef(_, substs) => {\n             stack.extend(substs.types().rev());"}, {"sha": "b793b37fb2ae109e5f9ed0dd7ae43585af246a2b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 ty::Tuple(ref tys) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n                         for elem in rest {\n-                            self.require_sized(elem, traits::TupleElem);\n+                            self.require_sized(elem.expect_ty(), traits::TupleElem);\n                         }\n                     }\n                 }"}, {"sha": "2c4a1ded97f39b4a9c32f209b8611e2fd41b0d8c", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -426,9 +426,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             assert!(!sig.c_variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n-                ty::Tuple(ref tupled_arguments) => {\n+                ty::Tuple(tupled_arguments) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments\n+                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n                 }\n                 _ => {\n                     bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n@@ -437,7 +437,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n         } else {\n             assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args\n+            extra_args.to_vec()\n         };\n \n         let target = &cx.sess().target.target;\n@@ -587,7 +587,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n \n         let mut fn_ty = FnType {\n             ret: arg_of(sig.output(), None),\n-            args: inputs.iter().chain(extra_args).enumerate().map(|(i, ty)| {\n+            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n                 arg_of(ty, Some(i))\n             }).collect(),\n             c_variadic: sig.c_variadic,"}, {"sha": "765992fd2b70e0f12962a75c92aedf30efa8ee3c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -722,9 +722,10 @@ pub fn type_metadata(\n             }\n         },\n         ty::Tuple(ref elements) => {\n+            let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &elements[..],\n+                                   &tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }"}, {"sha": "2154ac9b1d259a62aa8efc7aaef87d16d8bc8d32", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -392,7 +392,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                     signature.extend(\n                         args.iter().map(|argument_type| {\n-                            Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                            Some(type_metadata(cx, argument_type.expect_ty(), syntax_pos::DUMMY_SP))\n                         })\n                     );\n                 }"}, {"sha": "39aea4b9828fecb76d3c0823a8dac290292630d5", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -46,7 +46,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_debuginfo_type_name(tcx, component_type, true, output, visited);\n+                push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {"}, {"sha": "a883ae40dbf45458af5ad4b86968a78162d87d08", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -2213,7 +2213,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // Closure arguments are wrapped in a tuple, so we need to get the first\n                 // from that.\n                 if let ty::Tuple(elems) = argument_ty.sty {\n-                    let argument_ty = elems.first()?;\n+                    let argument_ty = elems.first()?.expect_ty();\n                     if let ty::Ref(_, _, _) = argument_ty.sty {\n                         return Some(AnnotatedBorrowFnSignature::Closure {\n                             argument_ty,"}, {"sha": "f9b571a7d60eb508f850cbed7192a868c93de4e6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -515,7 +515,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n                 (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n+                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))"}, {"sha": "6c26dc33e781d0a7c7f95a76b08dbcc861195fd0", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -779,7 +779,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 }\n                 ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n-                        Some(&ty) => Ok(ty),\n+                        Some(&ty) => Ok(ty.expect_ty()),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: tys.len(),\n                         }),"}, {"sha": "499bfd62b00b5411069f2a06b6c6ec7d1264bdfa", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -580,7 +580,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n \n                         tcx.mk_type_list(\n                             iter::once(closure_ty)\n-                                .chain(inputs.iter().cloned())\n+                                .chain(inputs.iter().map(|k| k.expect_ty()))\n                                 .chain(iter::once(output)),\n                         )\n                     },"}, {"sha": "edd36abc0b8a40cf7fc0aaa1a992ddcb5ea949b3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -1359,7 +1359,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::Tuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],"}, {"sha": "2fc0e08834a6e493772fd6b57a3401e7b778d5db", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Tuple(component_types) => {\n                 output.push('(');\n                 for &component_type in component_types {\n-                    self.push_type_name(component_type, output, debug);\n+                    self.push_type_name(component_type.expect_ty(), output, debug);\n                     output.push_str(\", \");\n                 }\n                 if !component_types.is_empty() {"}, {"sha": "a3708d064ec3b86100fff969a88a2d42292c1cbc", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -331,7 +331,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n+        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().map(|k| k.expect_ty())),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }"}, {"sha": "32c9953ee9e08be29bf2147e4928a5fe9aed6013", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -63,7 +63,7 @@ fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n         ty::Array(ty, ..) | ty::Slice(ty) =>\n             may_have_reference(ty, tcx),\n         ty::Tuple(tys) =>\n-            tys.iter().any(|ty| may_have_reference(ty, tcx)),\n+            tys.iter().any(|ty| may_have_reference(ty.expect_ty(), tcx)),\n         ty::Adt(adt, substs) =>\n             adt.variants.iter().any(|v| v.fields.iter().any(|f|\n                 may_have_reference(f.ty(tcx, substs), tcx)"}, {"sha": "b75321d031fdab2bf878a6f1cddd78ac29781e55", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -575,7 +575,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n                     // This is e.g., `tuple_tmp.0` in our example above.\n-                    let tuple_field = Operand::Move(tuple.clone().field(Field::new(i), ty));\n+                    let tuple_field = Operand::Move(tuple.clone().field(\n+                        Field::new(i),\n+                        ty.expect_ty(),\n+                    ));\n \n                     // Spill to a local to make e.g., `tmp0`.\n                     self.create_temp_if_necessary(tuple_field, callsite, caller_mir)"}, {"sha": "1c3545cc18ceff68edcc131a4a13704ac40147f3", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -797,7 +797,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.open_drop_for_tuple(&tys)\n             }\n             ty::Tuple(tys) => {\n-                self.open_drop_for_tuple(tys)\n+                let tys: Vec<_> = tys.iter().map(|k| k.expect_ty()).collect();\n+                self.open_drop_for_tuple(&tys)\n             }\n             ty::Adt(def, substs) => {\n                 if def.is_box() {"}, {"sha": "e2552bb1bdd5a880325d9c3eb2227fc1afeac769", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -5,7 +5,7 @@ use rustc::traits::{\n     ProgramClauseCategory,\n };\n use rustc::ty;\n-use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::subst::{Kind, InternalSubsts, Subst};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use crate::lowering::Lower;\n@@ -17,7 +17,7 @@ use crate::generic_types;\n fn builtin_impl_clause(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     ty: ty::Ty<'tcx>,\n-    nested: &[ty::Ty<'tcx>],\n+    nested: &[Kind<'tcx>],\n     trait_def_id: DefId\n ) -> ProgramClause<'tcx> {\n     ProgramClause {\n@@ -32,7 +32,7 @@ fn builtin_impl_clause(\n                 .cloned()\n                 .map(|nested_ty| ty::TraitRef {\n                     def_id: trait_def_id,\n-                    substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                    substs: tcx.mk_substs_trait(nested_ty.expect_ty(), &[]),\n                 })\n                 .map(|trait_ref| ty::TraitPredicate { trait_ref })\n                 .map(|pred| GoalKind::DomainGoal(pred.lower()))\n@@ -124,7 +124,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n     ty: ty::Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>\n ) {\n-    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n         // Bind innermost bound vars that may exist in `ty` and `nested`.\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n@@ -176,7 +176,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n         // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n         &ty::Tuple(type_list) => {\n             let type_list = generic_types::type_list(tcx, type_list.len());\n-            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &type_list);\n         }\n \n         // Struct def\n@@ -185,7 +185,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n             let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n             let sized_constraint = adt_def.sized_constraint(tcx)\n                 .iter()\n-                .map(|ty| ty.subst(tcx, substs))\n+                .map(|ty| Kind::from(ty.subst(tcx, substs)))\n                 .collect::<Vec<_>>();\n             push_builtin_impl(adt, &sized_constraint);\n         }\n@@ -228,7 +228,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n     ty: ty::Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>\n ) {\n-    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);\n         // Bind innermost bound vars that may exist in `ty` and `nested`.\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n@@ -253,7 +253,10 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         // These implement `Copy`/`Clone` if their element types do.\n         &ty::Array(_, length) => {\n             let element_ty = generic_types::bound(tcx, 0);\n-            push_builtin_impl(tcx.mk_ty(ty::Array(element_ty, length)), &[element_ty]);\n+            push_builtin_impl(\n+                tcx.mk_ty(ty::Array(element_ty, length)),\n+                &[Kind::from(element_ty)],\n+            );\n         }\n         &ty::Tuple(type_list) => {\n             let type_list = generic_types::type_list(tcx, type_list.len());\n@@ -262,7 +265,9 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         &ty::Closure(def_id, ..) => {\n             let closure_ty = generic_types::closure(tcx, def_id);\n             let upvar_tys: Vec<_> = match &closure_ty.sty {\n-                ty::Closure(_, substs) => substs.upvar_tys(def_id, tcx).collect(),\n+                ty::Closure(_, substs) => {\n+                    substs.upvar_tys(def_id, tcx).map(|ty| Kind::from(ty)).collect()\n+                },\n                 _ => bug!(),\n             };\n             push_builtin_impl(closure_ty, &upvar_tys);"}, {"sha": "5131bae137d014b2b22291a170d720f6c0826712", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -131,7 +131,7 @@ crate fn wf_clause_for_tuple<'tcx>(\n     let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n         .map(|ty| ty::TraitRef {\n             def_id: sized_trait,\n-            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n+            substs: tcx.mk_substs_trait(ty.expect_ty(), ty::List::empty()),\n         })\n         .map(|trait_ref| ty::TraitPredicate { trait_ref })\n         .map(|predicate| predicate.lower());"}, {"sha": "25ce5c8f9a6d86a5c77b3126292b86c14872609a", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -190,7 +190,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Tuple(tys) => tys.iter()\n-            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty.expect_ty()))\n             .collect(),\n \n         ty::Closure(def_id, substs) => substs"}, {"sha": "cf54260084e1150f2135b1917086424faef90a9f", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -1,7 +1,7 @@\n //! Utilities for creating generic types with bound vars in place of parameter values.\n \n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::InternalSubsts;\n+use rustc::ty::subst::{Kind, SubstsRef, InternalSubsts};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n@@ -44,11 +44,12 @@ crate fn fn_ptr(\n     tcx.mk_fn_ptr(fn_sig)\n }\n \n-crate fn type_list(tcx: ty::TyCtxt<'_, '_, 'tcx>, arity: usize) -> &'tcx ty::List<Ty<'tcx>> {\n-    tcx.mk_type_list(\n+crate fn type_list(tcx: ty::TyCtxt<'_, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n+    tcx.mk_substs(\n         (0..arity).into_iter()\n             .map(|i| ty::BoundVar::from(i))\n             .map(|var| tcx.mk_ty(ty::Bound(ty::INNERMOST, var.into())))\n+            .map(|ty| Kind::from(ty))\n     )\n }\n "}, {"sha": "f3cabced34dfcd0df21fa008527093b1ca8fd78c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -9,6 +9,7 @@ use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Kind;\n use syntax::ast;\n use syntax::source_map::Spanned;\n use syntax::ptr::P;\n@@ -304,11 +305,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 let max_len = cmp::max(expected_len, elements.len());\n \n-                let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n+                let element_tys_iter = (0..max_len).map(|_| {\n                     // FIXME: `MiscVariable` for now -- obtaining the span and name information\n                     // from all tuple elements isn't trivial.\n-                    TypeVariableOrigin::TypeInference(pat.span)));\n-                let element_tys = tcx.mk_type_list(element_tys_iter);\n+                    Kind::from(self.next_ty_var(TypeVariableOrigin::TypeInference(pat.span)))\n+                });\n+                let element_tys = tcx.mk_substs(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n                 if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n                     err.emit();\n@@ -321,7 +323,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_tup(element_tys_iter)\n                 } else {\n                     for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &element_tys[i], def_bm, match_discrim_span);\n+                        self.check_pat_walk(\n+                            elem,\n+                            &element_tys[i].expect_ty(),\n+                            def_bm,\n+                            match_discrim_span,\n+                        );\n                     }\n                     pat_ty\n                 }"}, {"sha": "4689456d11fe21cff3aaafc3ea3f0cf36228c995", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             ty::Tuple(fields) => match fields.last() {\n                 None => Some(PointerKind::Thin),\n-                Some(f) => self.pointer_kind(f, span)?\n+                Some(f) => self.pointer_kind(f.expect_ty(), span)?\n             },\n \n             // Pointers to foreign types are thin, despite being unsized"}, {"sha": "838874cc2bf074b25f1224162615f3a63c5398c4", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -274,8 +274,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let input_tys = match arg_param_ty.sty {\n-            ty::Tuple(tys) => tys.into_iter(),\n-            _ => return None\n+            ty::Tuple(tys) => tys.into_iter().map(|k| k.expect_ty()),\n+            _ => return None,\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let sig = self.tcx.mk_fn_sig(\n-            input_tys.cloned(),\n+            input_tys,\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,"}, {"sha": "edca00f69b12b08bd8de210c4e7489068a1407c9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -2859,7 +2859,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             sp: Span,\n                             expr_sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n-                            mut expected_arg_tys: &[Ty<'tcx>],\n+                            expected_arg_tys: &[Ty<'tcx>],\n                             args: &'gcx [hir::Expr],\n                             c_variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag,\n@@ -2915,29 +2915,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             err.emit();\n         };\n \n+        let mut expected_arg_tys = expected_arg_tys.to_vec();\n+\n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n                 ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n                     param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n-                    expected_arg_tys = &[];\n+                    expected_arg_tys = vec![];\n                     self.err_args(args.len())\n                 }\n                 ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::Tuple(ref tys) => &tys,\n-                            _ => &[]\n+                            ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n+                            _ => vec![],\n                         },\n-                        None => &[]\n+                        None => vec![],\n                     };\n-                    arg_types.to_vec()\n+                    arg_types.iter().map(|k| k.expect_ty()).collect()\n                 }\n                 _ => {\n                     span_err!(tcx.sess, sp, E0059,\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\");\n-                    expected_arg_tys = &[];\n+                    expected_arg_tys = vec![];\n                     self.err_args(args.len())\n                 }\n             }\n@@ -2948,7 +2950,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 fn_inputs.to_vec()\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_arg_tys = &[];\n+                expected_arg_tys = vec![];\n                 self.err_args(supplied_arg_count)\n             }\n         } else {\n@@ -2962,19 +2964,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n             param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n \n-            expected_arg_tys = &[];\n+            expected_arg_tys = vec![];\n             self.err_args(supplied_arg_count)\n         };\n+\n+        debug!(\"check_argument_types: formal_tys={:?}\",\n+               formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n+\n         // If there is no expectation, expect formal_tys.\n         let expected_arg_tys = if !expected_arg_tys.is_empty() {\n             expected_arg_tys\n         } else {\n-            &formal_tys\n+            formal_tys.clone()\n         };\n \n-        debug!(\"check_argument_types: formal_tys={:?}\",\n-               formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n-\n         // Check the arguments.\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n@@ -3560,7 +3563,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 autoderef.finalize(self);\n \n                                 self.write_field_index(expr.hir_id, index);\n-                                return field_ty;\n+                                return field_ty.expect_ty();\n                             }\n                         }\n                     }\n@@ -4630,7 +4633,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n                     let t = match flds {\n                         Some(ref fs) if i < fs.len() => {\n-                            let ety = fs[i];\n+                            let ety = fs[i].expect_ty();\n                             self.check_expr_coercable_to_type(&e, ety);\n                             ety\n                         }"}, {"sha": "5079a3bb55f899a97a27eb4c7e3c1c357534171c", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::Tuple(subtys) => {\n                 for &subty in subtys {\n-                    self.add_constraints_from_ty(current, subty, variance);\n+                    self.add_constraints_from_ty(current, subty.expect_ty(), variance);\n                 }\n             }\n "}, {"sha": "b0a0b96f6b5fd6c1cc5cb0f13ef4f6579a617de5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dbc5ec47be07d8d2f029a19ae39cf76d521369/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35dbc5ec47be07d8d2f029a19ae39cf76d521369", "patch": "@@ -1136,7 +1136,7 @@ fn external_generic_args(\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n             assert!(ty_sty.is_some());\n             let inputs = match ty_sty {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n                 _ => return GenericArgs::AngleBracketed { args, bindings },\n             };\n             let output = None;\n@@ -1181,7 +1181,7 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         for ty_s in trait_ref.input_types().skip(1) {\n             if let ty::Tuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let ty::Ref(ref reg, _, _) = ty_s.sty {\n+                    if let ty::Ref(ref reg, _, _) = ty_s.expect_ty().sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(Lifetime(name)) = reg.clean(cx) {\n@@ -3066,7 +3066,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::Tuple(ref t) => Tuple(t.clean(cx)),\n+            ty::Tuple(ref t) => {\n+                Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx))\n+            }\n \n             ty::Projection(ref data) => data.clean(cx),\n "}]}