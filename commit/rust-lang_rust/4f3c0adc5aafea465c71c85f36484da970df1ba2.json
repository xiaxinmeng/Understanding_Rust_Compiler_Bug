{"sha": "4f3c0adc5aafea465c71c85f36484da970df1ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmM2MwYWRjNWFhZmVhNDY1YzcxYzg1ZjM2NDg0ZGE5NzBkZjFiYTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-09T16:51:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-09T16:55:43Z"}, "message": "internal: introduce `ast::make::ext` module with common shortcuts\n\nThere's a tension between keeping a well-architectured minimal\northogonal set of constructs, and providing convenience functions.\nRelieve this pressure by introducing an dedicated module for\nnon-orthogonal shortcuts.\n\nThis is inspired by the django.shortcuts module which serves a similar\npurpose architecturally.", "tree": {"sha": "4cb502a6c345c3ecfb4090067ab1de2cfd69ed55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cb502a6c345c3ecfb4090067ab1de2cfd69ed55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3c0adc5aafea465c71c85f36484da970df1ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c0adc5aafea465c71c85f36484da970df1ba2", "html_url": "https://github.com/rust-lang/rust/commit/4f3c0adc5aafea465c71c85f36484da970df1ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c0adc5aafea465c71c85f36484da970df1ba2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680a0d54e4d2d474ae41f4f4a95c749495a02883", "url": "https://api.github.com/repos/rust-lang/rust/commits/680a0d54e4d2d474ae41f4f4a95c749495a02883", "html_url": "https://github.com/rust-lang/rust/commit/680a0d54e4d2d474ae41f4f4a95c749495a02883"}], "stats": {"total": 221, "additions": 104, "deletions": 117}, "files": [{"sha": "5eb6a57f07757c883d7132d89af6d8dc44668fa0", "filename": "crates/ide_assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -130,9 +130,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                                 once(make::ident_pat(make::name(\"it\")).into()),\n                             );\n                             let expr = {\n-                                let name_ref = make::name_ref(\"it\");\n-                                let segment = make::path_segment(name_ref);\n-                                let path = make::path_unqualified(segment);\n+                                let path = make::ext::ident_path(\"it\");\n                                 make::expr_path(path)\n                             };\n                             make::match_arm(once(pat.into()), expr)"}, {"sha": "da8d245e5f79c03d74daf25e4f33dac046f77266", "filename": "crates/ide_assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -65,8 +65,7 @@ pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Opti\n \n             let names_to_import = find_names_to_import(ctx, refs_in_target, imported_defs);\n             let expanded = make::use_tree_list(names_to_import.iter().map(|n| {\n-                let path =\n-                    make::path_unqualified(make::path_segment(make::name_ref(&n.to_string())));\n+                let path = make::ext::ident_path(&n.to_string());\n                 make::use_tree(path, None, None, false)\n             }))\n             .clone_for_update();"}, {"sha": "6311afc1f52b23bd3ce2faf44009d624a80e6d43", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -956,10 +956,10 @@ fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel)\n     let args = fun.params.iter().map(|param| param.to_arg(ctx));\n     let args = make::arg_list(args);\n     let call_expr = if fun.self_param.is_some() {\n-        let self_arg = make::expr_path(make_path_from_text(\"self\"));\n+        let self_arg = make::expr_path(make::ext::ident_path(\"self\"));\n         make::expr_method_call(self_arg, &fun.name, args)\n     } else {\n-        let func = make::expr_path(make_path_from_text(&fun.name));\n+        let func = make::expr_path(make::ext::ident_path(&fun.name));\n         make::expr_call(func, args)\n     };\n \n@@ -1054,11 +1054,11 @@ impl FlowHandler {\n                 make::expr_if(condition, block, None)\n             }\n             FlowHandler::IfOption { action } => {\n-                let path = make_path_from_text(\"Some\");\n+                let path = make::ext::ident_path(\"Some\");\n                 let value_pat = make::ident_pat(make::name(\"value\"));\n                 let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                 let cond = make::condition(call_expr, Some(pattern.into()));\n-                let value = make::expr_path(make_path_from_text(\"value\"));\n+                let value = make::expr_path(make::ext::ident_path(\"value\"));\n                 let action_expr = action.make_result_handler(Some(value));\n                 let action_stmt = make::expr_stmt(action_expr);\n                 let then = make::block_expr(iter::once(action_stmt.into()), None);\n@@ -1068,14 +1068,14 @@ impl FlowHandler {\n                 let some_name = \"value\";\n \n                 let some_arm = {\n-                    let path = make_path_from_text(\"Some\");\n+                    let path = make::ext::ident_path(\"Some\");\n                     let value_pat = make::ident_pat(make::name(some_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n-                    let value = make::expr_path(make_path_from_text(some_name));\n+                    let value = make::expr_path(make::ext::ident_path(some_name));\n                     make::match_arm(iter::once(pat.into()), value)\n                 };\n                 let none_arm = {\n-                    let path = make_path_from_text(\"None\");\n+                    let path = make::ext::ident_path(\"None\");\n                     let pat = make::path_pat(path);\n                     make::match_arm(iter::once(pat), none.make_result_handler(None))\n                 };\n@@ -1087,17 +1087,17 @@ impl FlowHandler {\n                 let err_name = \"value\";\n \n                 let ok_arm = {\n-                    let path = make_path_from_text(\"Ok\");\n+                    let path = make::ext::ident_path(\"Ok\");\n                     let value_pat = make::ident_pat(make::name(ok_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n-                    let value = make::expr_path(make_path_from_text(ok_name));\n+                    let value = make::expr_path(make::ext::ident_path(ok_name));\n                     make::match_arm(iter::once(pat.into()), value)\n                 };\n                 let err_arm = {\n-                    let path = make_path_from_text(\"Err\");\n+                    let path = make::ext::ident_path(\"Err\");\n                     let value_pat = make::ident_pat(make::name(err_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n-                    let value = make::expr_path(make_path_from_text(err_name));\n+                    let value = make::expr_path(make::ext::ident_path(err_name));\n                     make::match_arm(iter::once(pat.into()), err.make_result_handler(Some(value)))\n                 };\n                 let arms = make::match_arm_list(vec![ok_arm, err_arm]);\n@@ -1107,13 +1107,9 @@ impl FlowHandler {\n     }\n }\n \n-fn make_path_from_text(text: &str) -> ast::Path {\n-    make::path_unqualified(make::path_segment(make::name_ref(text)))\n-}\n-\n fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n     let name = var.name(ctx.db()).unwrap().to_string();\n-    make::expr_path(make_path_from_text(&name))\n+    make::expr_path(make::ext::ident_path(&name))\n }\n \n fn format_function(\n@@ -1179,37 +1175,29 @@ fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Opti\n             fun_ty.make_ty(ctx, module)\n         }\n         FlowHandler::Try { kind: TryKind::Option } => {\n-            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n+            make::ext::ty_option(fun_ty.make_ty(ctx, module))\n         }\n         FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n             let handler_ty = parent_ret_ty\n                 .type_arguments()\n                 .nth(1)\n                 .map(|ty| make_ty(&ty, ctx, module))\n                 .unwrap_or_else(make::ty_unit);\n-            make::ty_generic(\n-                make::name_ref(\"Result\"),\n-                vec![fun_ty.make_ty(ctx, module), handler_ty],\n-            )\n+            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n         }\n-        FlowHandler::If { .. } => make::ty_bool(),\n+        FlowHandler::If { .. } => make::ext::ty_bool(),\n         FlowHandler::IfOption { action } => {\n             let handler_ty = action\n                 .expr_ty(ctx)\n                 .map(|ty| make_ty(&ty, ctx, module))\n                 .unwrap_or_else(make::ty_unit);\n-            make::ty_generic(make::name_ref(\"Option\"), iter::once(handler_ty))\n-        }\n-        FlowHandler::MatchOption { .. } => {\n-            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n+            make::ext::ty_option(handler_ty)\n         }\n+        FlowHandler::MatchOption { .. } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),\n         FlowHandler::MatchResult { err } => {\n             let handler_ty =\n                 err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n-            make::ty_generic(\n-                make::name_ref(\"Result\"),\n-                vec![fun_ty.make_ty(ctx, module), handler_ty],\n-            )\n+            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n         }\n     };\n     Some(make::ret_type(ret_ty))\n@@ -1296,7 +1284,7 @@ fn make_body(\n                     TryKind::Option => \"Some\",\n                     TryKind::Result { .. } => \"Ok\",\n                 };\n-                let func = make::expr_path(make_path_from_text(constructor));\n+                let func = make::expr_path(make::ext::ident_path(constructor));\n                 let args = make::arg_list(iter::once(tail_expr));\n                 make::expr_call(func, args)\n             })\n@@ -1306,16 +1294,16 @@ fn make_body(\n             with_tail_expr(block, lit_false.into())\n         }\n         FlowHandler::IfOption { .. } => {\n-            let none = make::expr_path(make_path_from_text(\"None\"));\n+            let none = make::expr_path(make::ext::ident_path(\"None\"));\n             with_tail_expr(block, none)\n         }\n         FlowHandler::MatchOption { .. } => map_tail_expr(block, |tail_expr| {\n-            let some = make::expr_path(make_path_from_text(\"Some\"));\n+            let some = make::expr_path(make::ext::ident_path(\"Some\"));\n             let args = make::arg_list(iter::once(tail_expr));\n             make::expr_call(some, args)\n         }),\n         FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {\n-            let ok = make::expr_path(make_path_from_text(\"Ok\"));\n+            let ok = make::expr_path(make::ext::ident_path(\"Ok\"));\n             let args = make::arg_list(iter::once(tail_expr));\n             make::expr_call(ok, args)\n         }),\n@@ -1483,13 +1471,13 @@ fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Op\n         FlowHandler::IfOption { .. } => {\n             let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n             let args = make::arg_list(iter::once(expr));\n-            make::expr_call(make::expr_path(make_path_from_text(\"Some\")), args)\n+            make::expr_call(make::expr_path(make::ext::ident_path(\"Some\")), args)\n         }\n-        FlowHandler::MatchOption { .. } => make::expr_path(make_path_from_text(\"None\")),\n+        FlowHandler::MatchOption { .. } => make::expr_path(make::ext::ident_path(\"None\")),\n         FlowHandler::MatchResult { .. } => {\n             let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n             let args = make::arg_list(iter::once(expr));\n-            make::expr_call(make::expr_path(make_path_from_text(\"Err\")), args)\n+            make::expr_call(make::expr_path(make::ext::ident_path(\"Err\")), args)\n         }\n     };\n     Some(make::expr_return(Some(value)).clone_for_update())"}, {"sha": "bc9fc524b90e075c15480e8f0872fc995f935f77", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -175,7 +175,7 @@ impl FunctionBuilder {\n     }\n \n     fn render(self) -> FunctionTemplate {\n-        let placeholder_expr = make::expr_todo();\n+        let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n         let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n         let mut fn_def = make::fn_("}, {"sha": "fa3f766093444b4bac6e4d598b5d6298822cf91e", "filename": "crates/ide_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -63,11 +63,7 @@ pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {\n-    let path = {\n-        let name_ref = make::name_ref(&param.name()?.syntax().to_string());\n-        let segment = make::path_segment(name_ref);\n-        make::path_unqualified(segment)\n-    };\n+    let path = make::ext::ident_path(&param.name()?.syntax().to_string());\n     let predicate = make::where_pred(path, param.type_bound_list()?.bounds());\n     Some(predicate.clone_for_update())\n }"}, {"sha": "10d9cec3136bbe7c376f284633be1a9d740eba36", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -84,7 +84,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n         add_assist(acc, ctx, &attr, &args, &trait_path, Some(trait_), &adt)?;\n     }\n     if no_traits_found {\n-        let trait_path = make::path_unqualified(make::path_segment(make::name_ref(trait_name)));\n+        let trait_path = make::ext::ident_path(trait_name);\n         add_assist(acc, ctx, &attr, &args, &trait_path, None, &adt)?;\n     }\n     Some(())\n@@ -159,10 +159,8 @@ fn impl_def_from_trait(\n     if trait_items.is_empty() {\n         return None;\n     }\n-    let impl_def = make::impl_trait(\n-        trait_path.clone(),\n-        make::path_unqualified(make::path_segment(make::name_ref(&annotated_name.text()))),\n-    );\n+    let impl_def =\n+        make::impl_trait(trait_path.clone(), make::ext::ident_path(&annotated_name.text()));\n     let (impl_def, first_assoc_item) =\n         add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n     Some((impl_def, first_assoc_item))"}, {"sha": "f811234c07fcb08d04f0597fdc4b3b7719907a8c", "filename": "crates/ide_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n             let with_placeholder: ast::Pat = match happy_variant {\n                 None => make::wildcard_pat().into(),\n                 Some(var_name) => make::tuple_struct_pat(\n-                    make::path_unqualified(make::path_segment(make::name_ref(var_name))),\n+                    make::ext::ident_path(var_name),\n                     once(make::wildcard_pat().into()),\n                 )\n                 .into(),"}, {"sha": "0fec961b437476410413912b1edbdf96c4c0c43f", "filename": "crates/ide_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -32,7 +32,7 @@ use ide_db::ty_filter::TryEnum;\n // fn main() {\n //     let x: Result<i32, i32> = Result::Ok(92);\n //     let y = match x {\n-//         Ok(a) => a,\n+//         Ok(it) => it,\n //         $0_ => unreachable!(),\n //     };\n // }\n@@ -52,16 +52,17 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n         \"Replace unwrap with match\",\n         target,\n         |builder| {\n-            let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-            let it = make::ident_pat(make::name(\"a\")).into();\n+            let ok_path = make::ext::ident_path(happy_variant);\n+            let it = make::ident_pat(make::name(\"it\")).into();\n             let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-            let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+            let bind_path = make::ext::ident_path(\"it\");\n             let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-            let unreachable_call = make::expr_unreachable();\n-            let err_arm =\n-                make::match_arm(iter::once(make::wildcard_pat().into()), unreachable_call);\n+            let err_arm = make::match_arm(\n+                iter::once(make::wildcard_pat().into()),\n+                make::ext::expr_unreachable(),\n+            );\n \n             let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n             let match_expr = make::expr_match(caller.clone(), match_arm_list)\n@@ -110,7 +111,7 @@ fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match i(x) {\n-        Ok(a) => a,\n+        Ok(it) => it,\n         $0_ => unreachable!(),\n     };\n }\n@@ -136,7 +137,7 @@ fn i<T>(a: T) -> T { a }\n fn main() {\n     let x = Option::Some(92);\n     let y = match i(x) {\n-        Some(a) => a,\n+        Some(it) => it,\n         $0_ => unreachable!(),\n     };\n }\n@@ -162,7 +163,7 @@ fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match i(x) {\n-        Ok(a) => a,\n+        Ok(it) => it,\n         $0_ => unreachable!(),\n     }.count_zeroes();\n }"}, {"sha": "2f1da82c7dc1f120fe65d24169736ce72ed444d5", "filename": "crates/ide_assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -54,9 +54,7 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n \n             for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n                 let ok_wrapped = make::expr_call(\n-                    make::expr_path(make::path_unqualified(make::path_segment(make::name_ref(\n-                        \"Ok\",\n-                    )))),\n+                    make::expr_path(make::ext::ident_path(\"Ok\")),\n                     make::arg_list(iter::once(ret_expr_arg.clone())),\n                 );\n                 builder.replace_ast(ret_expr_arg, ok_wrapped);"}, {"sha": "49c1a9776020875f42fd37bd9ceb3fc5110940aa", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -1531,7 +1531,7 @@ enum Result<T, E> { Ok(T), Err(E) }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match x {\n-        Ok(a) => a,\n+        Ok(it) => it,\n         $0_ => unreachable!(),\n     };\n }"}, {"sha": "0dcf20c618c4de6c860c2799fd6c2d4ecd90b9b5", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -159,8 +159,8 @@ pub fn add_trait_assoc_items_to_impl(\n         match fn_def.body() {\n             Some(_) => fn_def,\n             None => {\n-                let body =\n-                    make::block_expr(None, Some(make::expr_todo())).indent(edit::IndentLevel(1));\n+                let body = make::block_expr(None, Some(make::ext::expr_todo()))\n+                    .indent(edit::IndentLevel(1));\n                 fn_def.with_body(body)\n             }\n         }"}, {"sha": "148297279287afd0e1fc8478ecafff7ee5c2130c", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -137,7 +137,7 @@ fn recursive_merge(\n                             None,\n                             false,\n                         );\n-                        use_trees.insert(idx, make::glob_use_tree());\n+                        use_trees.insert(idx, make::use_tree_glob());\n                         continue;\n                     }\n "}, {"sha": "00678bf3e9bb6fd3d520eac6b63cb270fa9fc436", "filename": "crates/ide_db/src/ty_filter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fty_filter.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -43,7 +43,7 @@ impl TryEnum {\n     pub fn sad_pattern(self) -> ast::Pat {\n         match self {\n             TryEnum::Result => make::tuple_struct_pat(\n-                make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n+                make::ext::ident_path(\"Err\"),\n                 iter::once(make::wildcard_pat().into()),\n             )\n             .into(),\n@@ -54,12 +54,12 @@ impl TryEnum {\n     pub fn happy_pattern(self) -> ast::Pat {\n         match self {\n             TryEnum::Result => make::tuple_struct_pat(\n-                make::path_unqualified(make::path_segment(make::name_ref(\"Ok\"))),\n+                make::ext::ident_path(\"Ok\"),\n                 iter::once(make::wildcard_pat().into()),\n             )\n             .into(),\n             TryEnum::Option => make::tuple_struct_pat(\n-                make::path_unqualified(make::path_segment(make::name_ref(\"Some\"))),\n+                make::ext::ident_path(\"Some\"),\n                 iter::once(make::wildcard_pat().into()),\n             )\n             .into(),"}, {"sha": "a378b1d375ea5f80836bd33c1c2c0bf009ffb451", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c0adc5aafea465c71c85f36484da970df1ba2/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=4f3c0adc5aafea465c71c85f36484da970df1ba2", "patch": "@@ -3,7 +3,7 @@\n //!\n //! Note that all functions here intended to be stupid constructors, which just\n //! assemble a finish node from immediate children. If you want to do something\n-//! smarter than that, it probably doesn't belong in this module.\n+//! smarter than that, it belongs to the `ext` submodule.\n //!\n //! Keep in mind that `from_text` functions should be kept private. The public\n //! API should require to assemble every node piecewise. The trick of\n@@ -14,13 +14,49 @@ use stdx::{format_to, never};\n \n use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, SyntaxToken};\n \n+/// While the parent module defines basic atomic \"constructors\", the `ext`\n+/// module defines shortcuts for common things.\n+///\n+/// It's named `ext` rather than `shortcuts` just to keep it short.\n+pub mod ext {\n+    use super::*;\n+\n+    pub fn ident_path(ident: &str) -> ast::Path {\n+        path_unqualified(path_segment(name_ref(ident)))\n+    }\n+\n+    pub fn expr_unreachable() -> ast::Expr {\n+        expr_from_text(\"unreachable!()\")\n+    }\n+    pub fn expr_todo() -> ast::Expr {\n+        expr_from_text(\"todo!()\")\n+    }\n+\n+    pub fn ty_bool() -> ast::Type {\n+        ty_path(ident_path(\"bool\"))\n+    }\n+    pub fn ty_option(t: ast::Type) -> ast::Type {\n+        ty_from_text(&format!(\"Option<{}>\", t))\n+    }\n+    pub fn ty_result(t: ast::Type, e: ast::Type) -> ast::Type {\n+        ty_from_text(&format!(\"Result<{}, {}>\", t, e))\n+    }\n+}\n+\n pub fn name(text: &str) -> ast::Name {\n     ast_from_text(&format!(\"mod {}{};\", raw_ident_esc(text), text))\n }\n-\n pub fn name_ref(text: &str) -> ast::NameRef {\n     ast_from_text(&format!(\"fn f() {{ {}{}; }}\", raw_ident_esc(text), text))\n }\n+fn raw_ident_esc(ident: &str) -> &'static str {\n+    let is_keyword = parser::SyntaxKind::from_keyword(ident).is_some();\n+    if is_keyword && !matches!(ident, \"self\" | \"crate\" | \"super\" | \"Self\") {\n+        \"r#\"\n+    } else {\n+        \"\"\n+    }\n+}\n \n pub fn lifetime(text: &str) -> ast::Lifetime {\n     let mut text = text;\n@@ -32,15 +68,6 @@ pub fn lifetime(text: &str) -> ast::Lifetime {\n     ast_from_text(&format!(\"fn f<{}>() {{ }}\", text))\n }\n \n-fn raw_ident_esc(ident: &str) -> &'static str {\n-    let is_keyword = parser::SyntaxKind::from_keyword(ident).is_some();\n-    if is_keyword && !matches!(ident, \"self\" | \"crate\" | \"super\" | \"Self\") {\n-        \"r#\"\n-    } else {\n-        \"\"\n-    }\n-}\n-\n // FIXME: replace stringly-typed constructor with a family of typed ctors, a-la\n // `expr_xxx`.\n pub fn ty(text: &str) -> ast::Type {\n@@ -49,9 +76,6 @@ pub fn ty(text: &str) -> ast::Type {\n pub fn ty_unit() -> ast::Type {\n     ty_from_text(\"()\")\n }\n-pub fn ty_bool() -> ast::Type {\n-    ty_path(path_unqualified(path_segment(name_ref(\"bool\"))))\n-}\n pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n     let mut count: usize = 0;\n     let mut contents = types.into_iter().inspect(|_| count += 1).join(\", \");\n@@ -61,11 +85,6 @@ pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n \n     ty_from_text(&format!(\"({})\", contents))\n }\n-// FIXME: handle path to type\n-pub fn ty_generic(name: ast::NameRef, types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n-    let contents = types.into_iter().join(\", \");\n-    ty_from_text(&format!(\"{}<{}>\", name, contents))\n-}\n pub fn ty_ref(target: ast::Type, exclusive: bool) -> ast::Type {\n     ty_from_text(&if exclusive { format!(\"&mut {}\", target) } else { format!(\"&{}\", target) })\n }\n@@ -107,7 +126,7 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     ast_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-\n+// FIXME: path concatenation operation doesn't make sense as AST op.\n pub fn path_concat(first: ast::Path, second: ast::Path) -> ast::Path {\n     ast_from_text(&format!(\"{}::{}\", first, second))\n }\n@@ -123,15 +142,14 @@ pub fn path_from_segments(\n         format!(\"use {};\", segments)\n     })\n }\n-\n+// FIXME: should not be pub\n pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(&format!(\"fn main() {{ let test = {}; }}\", text))\n }\n \n-pub fn glob_use_tree() -> ast::UseTree {\n+pub fn use_tree_glob() -> ast::UseTree {\n     ast_from_text(\"use *;\")\n }\n-\n pub fn use_tree(\n     path: ast::Path,\n     use_tree_list: Option<ast::UseTreeList>,\n@@ -226,15 +244,6 @@ pub fn expr_literal(text: &str) -> ast::Literal {\n pub fn expr_empty_block() -> ast::Expr {\n     expr_from_text(\"{}\")\n }\n-pub fn expr_unimplemented() -> ast::Expr {\n-    expr_from_text(\"unimplemented!()\")\n-}\n-pub fn expr_unreachable() -> ast::Expr {\n-    expr_from_text(\"unreachable!()\")\n-}\n-pub fn expr_todo() -> ast::Expr {\n-    expr_from_text(\"todo!()\")\n-}\n pub fn expr_path(path: ast::Path) -> ast::Expr {\n     expr_from_text(&path.to_string())\n }\n@@ -463,17 +472,6 @@ pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n     ast_from_text(&format!(\"fn f() {{ {}{} (); }}\", expr, semi))\n }\n \n-pub fn token(kind: SyntaxKind) -> SyntaxToken {\n-    tokens::SOURCE_FILE\n-        .tree()\n-        .syntax()\n-        .clone_for_update()\n-        .descendants_with_tokens()\n-        .filter_map(|it| it.into_token())\n-        .find(|it| it.kind() == kind)\n-        .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n-}\n-\n pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n }\n@@ -611,6 +609,17 @@ fn unroot(n: SyntaxNode) -> SyntaxNode {\n     SyntaxNode::new_root(n.green().into())\n }\n \n+pub fn token(kind: SyntaxKind) -> SyntaxToken {\n+    tokens::SOURCE_FILE\n+        .tree()\n+        .syntax()\n+        .clone_for_update()\n+        .descendants_with_tokens()\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == kind)\n+        .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n+}\n+\n pub mod tokens {\n     use once_cell::sync::Lazy;\n "}]}