{"sha": "e72dc794883d81e08d11d88795dbd12479b98137", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MmRjNzk0ODgzZDgxZTA4ZDExZDg4Nzk1ZGJkMTI0NzliOTgxMzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T13:43:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:24Z"}, "message": "make `convert` so it can apply to a single constraint", "tree": {"sha": "6eb2eba07f28d7e01ab2a5cb0d321ff54f12a042", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb2eba07f28d7e01ab2a5cb0d321ff54f12a042"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72dc794883d81e08d11d88795dbd12479b98137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72dc794883d81e08d11d88795dbd12479b98137", "html_url": "https://github.com/rust-lang/rust/commit/e72dc794883d81e08d11d88795dbd12479b98137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72dc794883d81e08d11d88795dbd12479b98137/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f1961d62e166cfe71273175296d9d59222ca81c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1961d62e166cfe71273175296d9d59222ca81c", "html_url": "https://github.com/rust-lang/rust/commit/3f1961d62e166cfe71273175296d9d59222ca81c"}], "stats": {"total": 104, "additions": 54, "deletions": 50}, "files": [{"sha": "900899b9cdebe7a3907a6a48cf3825b30bc3a169", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e72dc794883d81e08d11d88795dbd12479b98137/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72dc794883d81e08d11d88795dbd12479b98137/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=e72dc794883d81e08d11d88795dbd12479b98137", "patch": "@@ -18,8 +18,8 @@ use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, SubregionOrigin};\n use rustc::mir::{Location, Mir};\n-use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::{self, TyCtxt};\n use syntax::codemap::Span;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -65,7 +65,13 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n+    pub(super) fn convert_all(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n+        for query_constraint in query_constraints {\n+            self.convert(query_constraint);\n+        }\n+    }\n+\n+    pub(super) fn convert(&mut self, query_constraint: &QueryRegionConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -77,57 +83,55 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             ..\n         } = *self;\n \n-        for query_constraint in query_constraints {\n-            // At the moment, we never generate any \"higher-ranked\"\n-            // region constraints like `for<'a> 'a: 'b`. At some point\n-            // when we move to universes, we will, and this assertion\n-            // will start to fail.\n-            let ty::OutlivesPredicate(k1, r2) =\n-                query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                    span_bug!(\n-                        self.span(),\n-                        \"query_constraint {:?} contained bound regions\",\n-                        query_constraint,\n-                    );\n-                });\n-\n-            match k1.unpack() {\n-                UnpackedKind::Lifetime(r1) => {\n-                    let r1_vid = self.to_region_vid(r1);\n-                    let r2_vid = self.to_region_vid(r2);\n-                    self.add_outlives(r1_vid, r2_vid);\n-\n-                    // In the new analysis, all outlives relations etc\n-                    // \"take effect\" at the mid point of the statement\n-                    // that requires them, so ignore the `at_location`.\n-                    if let Some(all_facts) = &mut self.all_facts {\n-                        if let Some(from_location) = self.locations.from_location() {\n-                            all_facts.outlives.push((\n-                                r1_vid,\n-                                r2_vid,\n-                                self.location_table.mid_index(from_location),\n-                            ));\n-                        } else {\n-                            for location in self.location_table.all_points() {\n-                                all_facts.outlives.push((r1_vid, r2_vid, location));\n-                            }\n+        // At the moment, we never generate any \"higher-ranked\"\n+        // region constraints like `for<'a> 'a: 'b`. At some point\n+        // when we move to universes, we will, and this assertion\n+        // will start to fail.\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n+                span_bug!(\n+                    self.span(),\n+                    \"query_constraint {:?} contained bound regions\",\n+                    query_constraint,\n+                );\n+            });\n+\n+        match k1.unpack() {\n+            UnpackedKind::Lifetime(r1) => {\n+                let r1_vid = self.to_region_vid(r1);\n+                let r2_vid = self.to_region_vid(r2);\n+                self.add_outlives(r1_vid, r2_vid);\n+\n+                // In the new analysis, all outlives relations etc\n+                // \"take effect\" at the mid point of the statement\n+                // that requires them, so ignore the `at_location`.\n+                if let Some(all_facts) = &mut self.all_facts {\n+                    if let Some(from_location) = self.locations.from_location() {\n+                        all_facts.outlives.push((\n+                            r1_vid,\n+                            r2_vid,\n+                            self.location_table.mid_index(from_location),\n+                        ));\n+                    } else {\n+                        for location in self.location_table.all_points() {\n+                            all_facts.outlives.push((r1_vid, r2_vid, location));\n                         }\n                     }\n                 }\n+            }\n \n-                UnpackedKind::Type(t1) => {\n-                    // we don't actually use this for anything, but\n-                    // the `TypeOutlives` code needs an origin.\n-                    let origin = infer::RelateParamBound(self.span(), t1);\n-\n-                    TypeOutlives::new(\n-                        &mut *self,\n-                        tcx,\n-                        region_bound_pairs,\n-                        implicit_region_bound,\n-                        param_env,\n-                    ).type_must_outlive(origin, t1, r2);\n-                }\n+            UnpackedKind::Type(t1) => {\n+                // we don't actually use this for anything, but\n+                // the `TypeOutlives` code needs an origin.\n+                let origin = infer::RelateParamBound(self.span(), t1);\n+\n+                TypeOutlives::new(\n+                    &mut *self,\n+                    tcx,\n+                    region_bound_pairs,\n+                    implicit_region_bound,\n+                    param_env,\n+                ).type_must_outlive(origin, t1, r2);\n             }\n         }\n     }"}, {"sha": "4a507300f7c9e70ef9236e04d84053ae6ecdf447", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72dc794883d81e08d11d88795dbd12479b98137/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72dc794883d81e08d11d88795dbd12479b98137/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e72dc794883d81e08d11d88795dbd12479b98137", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n-            ).convert(&data);\n+            ).convert_all(&data);\n         }\n     }\n "}]}