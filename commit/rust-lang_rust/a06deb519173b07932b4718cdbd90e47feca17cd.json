{"sha": "a06deb519173b07932b4718cdbd90e47feca17cd", "node_id": "C_kwDOAAsO6NoAKGEwNmRlYjUxOTE3M2IwNzkzMmI0NzE4Y2RiZDkwZTQ3ZmVjYTE3Y2Q", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-13T13:17:07Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-15T11:49:25Z"}, "message": "Compute pre_compiled_cgus more eagerly\n\nThis reduces the complexity of this code a lot", "tree": {"sha": "d8bc77e69cacff12c48a43bf0c13ec17d6804e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8bc77e69cacff12c48a43bf0c13ec17d6804e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a06deb519173b07932b4718cdbd90e47feca17cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a06deb519173b07932b4718cdbd90e47feca17cd", "html_url": "https://github.com/rust-lang/rust/commit/a06deb519173b07932b4718cdbd90e47feca17cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a06deb519173b07932b4718cdbd90e47feca17cd/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c1f16c3e3222d9e8d0b17285244e6155fc69db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1f16c3e3222d9e8d0b17285244e6155fc69db3", "html_url": "https://github.com/rust-lang/rust/commit/1c1f16c3e3222d9e8d0b17285244e6155fc69db3"}], "stats": {"total": 47, "additions": 19, "deletions": 28}, "files": [{"sha": "d11f1534153ad49761e7e07e5f63c72254139993", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a06deb519173b07932b4718cdbd90e47feca17cd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06deb519173b07932b4718cdbd90e47feca17cd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=a06deb519173b07932b4718cdbd90e47feca17cd", "patch": "@@ -15,8 +15,9 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n \n+use rustc_data_structures::sync::par_iter;\n #[cfg(parallel_compiler)]\n-use rustc_data_structures::sync::{par_iter, ParallelIterator};\n+use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n@@ -612,6 +613,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect::<Vec<_>>()\n     });\n \n+    let mut total_codegen_time = Duration::new(0, 0);\n+    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n+\n     // The non-parallel compiler can only translate codegen units to LLVM IR\n     // on a single thread, leading to a staircase effect where the N LLVM\n     // threads have to wait on the single codegen threads to generate work\n@@ -622,8 +626,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // This likely is a temporary measure. Once we don't have to support the\n     // non-parallel compiler anymore, we can compile CGUs end-to-end in\n     // parallel and get rid of the complicated scheduling logic.\n-    #[cfg(parallel_compiler)]\n-    let pre_compile_cgus = || {\n+    let mut pre_compiled_cgus = if cfg!(parallel_compiler) {\n         tcx.sess.time(\"compile_first_CGU_batch\", || {\n             // Try to find one CGU to compile per thread.\n             let cgus: Vec<_> = cgu_reuse\n@@ -643,43 +646,31 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 })\n                 .collect();\n \n-            (pre_compiled_cgus, start_time.elapsed())\n+            total_codegen_time += start_time.elapsed();\n+\n+            pre_compiled_cgus\n         })\n+    } else {\n+        FxHashMap::default()\n     };\n \n-    #[cfg(not(parallel_compiler))]\n-    let pre_compile_cgus = || (FxHashMap::default(), Duration::new(0, 0));\n-\n-    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n-    let mut total_codegen_time = Duration::new(0, 0);\n-    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n-\n     for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        // Do some setup work in the first iteration\n-        if pre_compiled_cgus.is_none() {\n-            // Pre compile some CGUs\n-            let (compiled_cgus, codegen_time) = pre_compile_cgus();\n-            pre_compiled_cgus = Some(compiled_cgus);\n-            total_codegen_time += codegen_time;\n-        }\n-\n         let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let (module, cost) =\n-                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n-                        cgu\n-                    } else {\n-                        let start_time = Instant::now();\n-                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n-                        total_codegen_time += start_time.elapsed();\n-                        module\n-                    };\n+                let (module, cost) = if let Some(cgu) = pre_compiled_cgus.remove(&i) {\n+                    cgu\n+                } else {\n+                    let start_time = Instant::now();\n+                    let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                    total_codegen_time += start_time.elapsed();\n+                    module\n+                };\n                 // This will unwind if there are errors, which triggers our `AbortCodegenOnDrop`\n                 // guard. Unfortunately, just skipping the `submit_codegened_module_to_llvm` makes\n                 // compilation hang on post-monomorphization errors."}]}