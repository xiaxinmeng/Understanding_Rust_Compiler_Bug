{"sha": "9bddd2af551702e472fb1a678466bc620b8973fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZGRkMmFmNTUxNzAyZTQ3MmZiMWE2Nzg0NjZiYzYyMGI4OTczZmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-15T20:14:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-15T20:14:36Z"}, "message": "Merge #9294\n\n9294: internal: introduce minicore -- a subset of libcore for testing r=matklad a=matklad\n\nClearly, we need one more fixed point iteration loop!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "54c0b67022c05c8fb5f57184bef6272af8ec1218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c0b67022c05c8fb5f57184bef6272af8ec1218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bddd2af551702e472fb1a678466bc620b8973fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyQosCRBK7hj4Ov3rIwAAtKMIAENuhMs29//9FYJ27KHZk4XF\nw+aQbC0eea6vqYDV3xz5MovQ+iNx2gW6vZqZIqUT/DwcjRfzTzxmxwPD7yiGhfb8\negY60Wl+ZoUCqNhH9hz0VCT54kaN9rCwLZ6yZqMmt95tjABXX4Bp5/V5vwwGh9yG\nZXMSubYmGRQTG7ARKhLkkktnMlU+xUibhVlA8AhDABI0+KIuYWs6PX+Y4Aej5gaV\n8fKL6lXJd9DPPqSbCUsCWOr4U9s1XtHgpmuJUmaKdN2dzf0vx1+HJn7baO2gmAWZ\n7PKbY5K0r1fJN8NY3zm7OU8krTanRYWWCDNj/6TEtqpfJkbs0xD1x2KucpRtmVM=\n=tf+Z\n-----END PGP SIGNATURE-----\n", "payload": "tree 54c0b67022c05c8fb5f57184bef6272af8ec1218\nparent d0f2bc3b878d1c1d8eaf081e6f670ebb928b7a5f\nparent 7cbcbccc7888b9a515cbebe2cd20fd3eebec463b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623788076 +0000\ncommitter GitHub <noreply@github.com> 1623788076 +0000\n\nMerge #9294\n\n9294: internal: introduce minicore -- a subset of libcore for testing r=matklad a=matklad\n\nClearly, we need one more fixed point iteration loop!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bddd2af551702e472fb1a678466bc620b8973fa", "html_url": "https://github.com/rust-lang/rust/commit/9bddd2af551702e472fb1a678466bc620b8973fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bddd2af551702e472fb1a678466bc620b8973fa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f2bc3b878d1c1d8eaf081e6f670ebb928b7a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f2bc3b878d1c1d8eaf081e6f670ebb928b7a5f", "html_url": "https://github.com/rust-lang/rust/commit/d0f2bc3b878d1c1d8eaf081e6f670ebb928b7a5f"}, {"sha": "7cbcbccc7888b9a515cbebe2cd20fd3eebec463b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cbcbccc7888b9a515cbebe2cd20fd3eebec463b", "html_url": "https://github.com/rust-lang/rust/commit/7cbcbccc7888b9a515cbebe2cd20fd3eebec463b"}], "stats": {"total": 2176, "additions": 1149, "deletions": 1027}, "files": [{"sha": "d56b20b83d9d5bfd3a63d223b6e822e2142e9439", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -9,8 +9,8 @@ use test_utils::{\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n-    input::CrateName, Change, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, FileRange,\n-    SourceDatabaseExt, SourceRoot, SourceRootId,\n+    input::CrateName, Change, CrateDisplayName, CrateGraph, CrateId, Edition, Env, FileId,\n+    FilePosition, FileRange, SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n@@ -81,7 +81,7 @@ pub struct ChangeFixture {\n \n impl ChangeFixture {\n     pub fn parse(ra_fixture: &str) -> ChangeFixture {\n-        let fixture = Fixture::parse(ra_fixture);\n+        let (mini_core, fixture) = Fixture::parse(ra_fixture);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -166,6 +166,31 @@ impl ChangeFixture {\n             }\n         }\n \n+        if let Some(mini_core) = mini_core {\n+            let core_file = file_id;\n+            file_id.0 += 1;\n+\n+            let mut fs = FileSet::default();\n+            fs.insert(core_file, VfsPath::new_virtual_path(\"/sysroot/core/lib.rs\".to_string()));\n+            roots.push(SourceRoot::new_library(fs));\n+\n+            change.change_file(core_file, Some(Arc::new(mini_core.source_code())));\n+\n+            let all_crates = crate_graph.crates_in_topological_order();\n+\n+            let core_crate = crate_graph.add_crate_root(\n+                core_file,\n+                Edition::Edition2021,\n+                Some(CrateDisplayName::from_canonical_name(\"core\".to_string())),\n+                CfgOptions::default(),\n+                Env::default(),\n+                Vec::new(),\n+            );\n+\n+            for krate in all_crates {\n+                crate_graph.add_dep(krate, CrateName::new(\"core\").unwrap(), core_crate).unwrap();\n+            }\n+        }\n         roots.push(SourceRoot::new_local(mem::take(&mut file_set)));\n         change.set_roots(roots);\n         change.set_crate_graph(crate_graph);"}, {"sha": "713b74165c1517a5186c5dfdec300d64e9b151fb", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 266, "deletions": 363, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -23,38 +23,29 @@ fn infer_block_expr_type_mismatch() {\n fn coerce_places() {\n     check_infer(\n         r#\"\n-        struct S<T> { a: T }\n+//- minicore: coerce_unsized\n+struct S<T> { a: T }\n \n-        fn f<T>(_: &[T]) -> T { loop {} }\n-        fn g<T>(_: S<&[T]>) -> T { loop {} }\n+fn f<T>(_: &[T]) -> T { loop {} }\n+fn g<T>(_: S<&[T]>) -> T { loop {} }\n \n-        fn gen<T>() -> *mut [T; 2] { loop {} }\n-        fn test1<U>() -> *mut [U] {\n-            gen()\n-        }\n-\n-        fn test2() {\n-            let arr: &[u8; 1] = &[1];\n-\n-            let a: &[_] = arr;\n-            let b = f(arr);\n-            let c: &[_] = { arr };\n-            let d = g(S { a: arr });\n-            let e: [&[_]; 1] = [arr];\n-            let f: [&[_]; 2] = [arr; 2];\n-            let g: (&[_], &[_]) = (arr, arr);\n-        }\n+fn gen<T>() -> *mut [T; 2] { loop {} }\n+fn test1<U>() -> *mut [U] {\n+    gen()\n+}\n \n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n+fn test2() {\n+    let arr: &[u8; 1] = &[1];\n \n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+    let a: &[_] = arr;\n+    let b = f(arr);\n+    let c: &[_] = { arr };\n+    let d = g(S { a: arr });\n+    let e: [&[_]; 1] = [arr];\n+    let f: [&[_]; 2] = [arr; 2];\n+    let g: (&[_], &[_]) = (arr, arr);\n+}\n+\"#,\n         expect![[r#\"\n             30..31 '_': &[T]\n             44..55 '{ loop {} }': T\n@@ -131,60 +122,52 @@ fn infer_let_stmt_coerce() {\n fn infer_custom_coerce_unsized() {\n     check_infer(\n         r#\"\n-        struct A<T: ?Sized>(*const T);\n-        struct B<T: ?Sized>(*const T);\n-        struct C<T: ?Sized> { inner: *const T }\n+//- minicore: coerce_unsized\n+use core::{marker::Unsize, ops::CoerceUnsized};\n \n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n+struct A<T: ?Sized>(*const T);\n+struct B<T: ?Sized>(*const T);\n+struct C<T: ?Sized> { inner: *const T }\n \n-        fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n-        fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n-        fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n \n-        fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n-            let d = foo1(a);\n-            let e = foo2(b);\n-            let f = foo3(c);\n-        }\n-\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n+fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n+fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n+fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n \n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n+    let d = foo1(a);\n+    let e = foo2(b);\n+    let f = foo3(c);\n+}\n+\"#,\n         expect![[r#\"\n-            257..258 'x': A<[T]>\n-            278..283 '{ x }': A<[T]>\n-            280..281 'x': A<[T]>\n-            295..296 'x': B<[T]>\n-            316..321 '{ x }': B<[T]>\n-            318..319 'x': B<[T]>\n-            333..334 'x': C<[T]>\n-            354..359 '{ x }': C<[T]>\n-            356..357 'x': C<[T]>\n-            369..370 'a': A<[u8; 2]>\n-            384..385 'b': B<[u8; 2]>\n-            399..400 'c': C<[u8; 2]>\n-            414..480 '{     ...(c); }': ()\n-            424..425 'd': A<[{unknown}]>\n-            428..432 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n-            428..435 'foo1(a)': A<[{unknown}]>\n-            433..434 'a': A<[u8; 2]>\n-            445..446 'e': B<[u8]>\n-            449..453 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n-            449..456 'foo2(b)': B<[u8]>\n-            454..455 'b': B<[u8; 2]>\n-            466..467 'f': C<[u8]>\n-            470..474 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n-            470..477 'foo3(c)': C<[u8]>\n-            475..476 'c': C<[u8; 2]>\n+            306..307 'x': A<[T]>\n+            327..332 '{ x }': A<[T]>\n+            329..330 'x': A<[T]>\n+            344..345 'x': B<[T]>\n+            365..370 '{ x }': B<[T]>\n+            367..368 'x': B<[T]>\n+            382..383 'x': C<[T]>\n+            403..408 '{ x }': C<[T]>\n+            405..406 'x': C<[T]>\n+            418..419 'a': A<[u8; 2]>\n+            433..434 'b': B<[u8; 2]>\n+            448..449 'c': C<[u8; 2]>\n+            463..529 '{     ...(c); }': ()\n+            473..474 'd': A<[{unknown}]>\n+            477..481 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n+            477..484 'foo1(a)': A<[{unknown}]>\n+            482..483 'a': A<[u8; 2]>\n+            494..495 'e': B<[u8]>\n+            498..502 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n+            498..505 'foo2(b)': B<[u8]>\n+            503..504 'b': B<[u8; 2]>\n+            515..516 'f': C<[u8]>\n+            519..523 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n+            519..526 'foo3(c)': C<[u8]>\n+            524..525 'c': C<[u8; 2]>\n         \"#]],\n     );\n }\n@@ -193,21 +176,16 @@ fn infer_custom_coerce_unsized() {\n fn infer_if_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test() {\n-            let x = if true {\n-                foo(&[1])\n-            } else {\n-                &[1]\n-            };\n-        }\n-\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        \"#,\n+//- minicore: unsize\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        foo(&[1])\n+    } else {\n+        &[1]\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -235,25 +213,16 @@ fn infer_if_coerce() {\n fn infer_if_else_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test() {\n-            let x = if true {\n-                &[1]\n-            } else {\n-                foo(&[1])\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        &[1]\n+    } else {\n+        foo(&[1])\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -281,20 +250,16 @@ fn infer_if_else_coerce() {\n fn infer_match_first_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test(i: i32) {\n-            let x = match i {\n-                2 => foo(&[2]),\n-                1 => &[1],\n-                _ => &[3],\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        \"#,\n+//- minicore: unsize\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        2 => foo(&[2]),\n+        1 => &[1],\n+        _ => &[3],\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -329,25 +294,16 @@ fn infer_match_first_coerce() {\n fn infer_match_second_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test(i: i32) {\n-            let x = match i {\n-                1 => &[1],\n-                2 => foo(&[2]),\n-                _ => &[3],\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        1 => &[1],\n+        2 => foo(&[2]),\n+        _ => &[3],\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -470,15 +426,15 @@ fn coerce_autoderef() {\n #[test]\n fn coerce_autoderef_generic() {\n     check_infer_with_mismatches(\n-        r\"\n-        struct Foo;\n-        fn takes_ref<T>(x: &T) -> T { *x }\n-        fn test() {\n-            takes_ref(&Foo);\n-            takes_ref(&&Foo);\n-            takes_ref(&&&Foo);\n-        }\n-        \",\n+        r#\"\n+struct Foo;\n+fn takes_ref<T>(x: &T) -> T { *x }\n+fn test() {\n+    takes_ref(&Foo);\n+    takes_ref(&&Foo);\n+    takes_ref(&&&Foo);\n+}\n+\"#,\n         expect![[r\"\n             28..29 'x': &T\n             40..46 '{ *x }': T\n@@ -508,30 +464,29 @@ fn coerce_autoderef_generic() {\n fn coerce_autoderef_block() {\n     check_infer_with_mismatches(\n         r#\"\n-        struct String {}\n-        #[lang = \"deref\"]\n-        trait Deref { type Target; }\n-        impl Deref for String { type Target = str; }\n-        fn takes_ref_str(x: &str) {}\n-        fn returns_string() -> String { loop {} }\n-        fn test() {\n-            takes_ref_str(&{ returns_string() });\n-        }\n-        \"#,\n-        expect![[r\"\n-            126..127 'x': &str\n-            135..137 '{}': ()\n-            168..179 '{ loop {} }': String\n-            170..177 'loop {}': !\n-            175..177 '{}': ()\n-            190..235 '{     ... }); }': ()\n-            196..209 'takes_ref_str': fn takes_ref_str(&str)\n-            196..232 'takes_...g() })': ()\n-            210..231 '&{ ret...ng() }': &String\n-            211..231 '{ retu...ng() }': String\n-            213..227 'returns_string': fn returns_string() -> String\n-            213..229 'return...ring()': String\n-        \"]],\n+//- minicore: deref\n+struct String {}\n+impl core::ops::Deref for String { type Target = str; }\n+fn takes_ref_str(x: &str) {}\n+fn returns_string() -> String { loop {} }\n+fn test() {\n+    takes_ref_str(&{ returns_string() });\n+}\n+\"#,\n+        expect![[r#\"\n+            90..91 'x': &str\n+            99..101 '{}': ()\n+            132..143 '{ loop {} }': String\n+            134..141 'loop {}': !\n+            139..141 '{}': ()\n+            154..199 '{     ... }); }': ()\n+            160..173 'takes_ref_str': fn takes_ref_str(&str)\n+            160..196 'takes_...g() })': ()\n+            174..195 '&{ ret...ng() }': &String\n+            175..195 '{ retu...ng() }': String\n+            177..191 'returns_string': fn returns_string() -> String\n+            177..193 'return...ring()': String\n+        \"#]],\n     );\n }\n \n@@ -674,25 +629,19 @@ fn coerce_placeholder_ref() {\n fn coerce_unsize_array() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        fn test() {\n-            let f: &[usize] = &[1, 2, 3];\n-        }\n+//- minicore: coerce_unsized\n+fn test() {\n+    let f: &[usize] = &[1, 2, 3];\n+}\n         \"#,\n         expect![[r#\"\n-            161..198 '{     ... 3]; }': ()\n-            171..172 'f': &[usize]\n-            185..195 '&[1, 2, 3]': &[usize; 3]\n-            186..195 '[1, 2, 3]': [usize; 3]\n-            187..188 '1': usize\n-            190..191 '2': usize\n-            193..194 '3': usize\n+            10..47 '{     ... 3]; }': ()\n+            20..21 'f': &[usize]\n+            34..44 '&[1, 2, 3]': &[usize; 3]\n+            35..44 '[1, 2, 3]': [usize; 3]\n+            36..37 '1': usize\n+            39..40 '2': usize\n+            42..43 '3': usize\n         \"#]],\n     );\n }\n@@ -701,42 +650,34 @@ fn coerce_unsize_array() {\n fn coerce_unsize_trait_object_simple() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait Foo<T, U> {}\n-        trait Bar<U, T, X>: Foo<T, U> {}\n-        trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-        struct S<T, X>;\n-        impl<T, X> Foo<T, usize> for S<T, X> {}\n-        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-        impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-        fn test() {\n-            let obj: &dyn Baz<i8, i16> = &S;\n-            let obj: &dyn Bar<_, i8, i16> = &S;\n-            let obj: &dyn Foo<i8, _> = &S;\n-        }\n-        \"#,\n-        expect![[r\"\n-            424..539 '{     ... &S; }': ()\n-            434..437 'obj': &dyn Baz<i8, i16>\n-            459..461 '&S': &S<i8, i16>\n-            460..461 'S': S<i8, i16>\n-            471..474 'obj': &dyn Bar<usize, i8, i16>\n-            499..501 '&S': &S<i8, i16>\n-            500..501 'S': S<i8, i16>\n-            511..514 'obj': &dyn Foo<i8, usize>\n-            534..536 '&S': &S<i8, {unknown}>\n-            535..536 'S': S<i8, {unknown}>\n-        \"]],\n+//- minicore: coerce_unsized\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, i8, i16> = &S;\n+    let obj: &dyn Foo<i8, _> = &S;\n+}\n+\"#,\n+        expect![[r#\"\n+            236..351 '{     ... &S; }': ()\n+            246..249 'obj': &dyn Baz<i8, i16>\n+            271..273 '&S': &S<i8, i16>\n+            272..273 'S': S<i8, i16>\n+            283..286 'obj': &dyn Bar<usize, i8, i16>\n+            311..313 '&S': &S<i8, i16>\n+            312..313 'S': S<i8, i16>\n+            323..326 'obj': &dyn Foo<i8, usize>\n+            346..348 '&S': &S<i8, {unknown}>\n+            347..348 'S': S<i8, {unknown}>\n+        \"#]],\n     );\n }\n \n@@ -761,49 +702,41 @@ fn coerce_unsize_trait_object_to_trait_object() {\n     //     602..606 'obj2': &dyn Baz<i8, i16>\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait Foo<T, U> {}\n-        trait Bar<U, T, X>: Foo<T, U> {}\n-        trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-        struct S<T, X>;\n-        impl<T, X> Foo<T, usize> for S<T, X> {}\n-        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-        impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-        fn test() {\n-            let obj: &dyn Baz<i8, i16> = &S;\n-            let obj: &dyn Bar<_, _, _> = obj;\n-            let obj: &dyn Foo<_, _> = obj;\n-            let obj2: &dyn Baz<i8, i16> = &S;\n-            let _: &dyn Foo<_, _> = obj2;\n-        }\n-        \"#,\n+//- minicore: coerce_unsized\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, _, _> = obj;\n+    let obj: &dyn Foo<_, _> = obj;\n+    let obj2: &dyn Baz<i8, i16> = &S;\n+    let _: &dyn Foo<_, _> = obj2;\n+}\n+\"#,\n         expect![[r#\"\n-            424..609 '{     ...bj2; }': ()\n-            434..437 'obj': &dyn Baz<i8, i16>\n-            459..461 '&S': &S<i8, i16>\n-            460..461 'S': S<i8, i16>\n-            471..474 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            496..499 'obj': &dyn Baz<i8, i16>\n-            509..512 'obj': &dyn Foo<{unknown}, {unknown}>\n-            531..534 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            544..548 'obj2': &dyn Baz<i8, i16>\n-            570..572 '&S': &S<i8, i16>\n-            571..572 'S': S<i8, i16>\n-            582..583 '_': &dyn Foo<{unknown}, {unknown}>\n-            602..606 'obj2': &dyn Baz<i8, i16>\n-            496..499: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-            531..534: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            602..606: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n+            236..421 '{     ...bj2; }': ()\n+            246..249 'obj': &dyn Baz<i8, i16>\n+            271..273 '&S': &S<i8, i16>\n+            272..273 'S': S<i8, i16>\n+            283..286 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            308..311 'obj': &dyn Baz<i8, i16>\n+            321..324 'obj': &dyn Foo<{unknown}, {unknown}>\n+            343..346 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            356..360 'obj2': &dyn Baz<i8, i16>\n+            382..384 '&S': &S<i8, i16>\n+            383..384 'S': S<i8, i16>\n+            394..395 '_': &dyn Foo<{unknown}, {unknown}>\n+            414..418 'obj2': &dyn Baz<i8, i16>\n+            308..311: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n+            343..346: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            414..418: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n         \"#]],\n     );\n }\n@@ -812,40 +745,32 @@ fn coerce_unsize_trait_object_to_trait_object() {\n fn coerce_unsize_super_trait_cycle() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait A {}\n-        trait B: C + A {}\n-        trait C: B {}\n-        trait D: C\n-\n-        struct S;\n-        impl A for S {}\n-        impl B for S {}\n-        impl C for S {}\n-        impl D for S {}\n-\n-        fn test() {\n-            let obj: &dyn D = &S;\n-            let obj: &dyn A = &S;\n-        }\n-        \"#,\n-        expect![[r\"\n-            328..383 '{     ... &S; }': ()\n-            338..341 'obj': &dyn D\n-            352..354 '&S': &S\n-            353..354 'S': S\n-            364..367 'obj': &dyn A\n-            378..380 '&S': &S\n-            379..380 'S': S\n-        \"]],\n+//- minicore: coerce_unsized\n+trait A {}\n+trait B: C + A {}\n+trait C: B {}\n+trait D: C\n+\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+\n+fn test() {\n+    let obj: &dyn D = &S;\n+    let obj: &dyn A = &S;\n+}\n+\"#,\n+        expect![[r#\"\n+            140..195 '{     ... &S; }': ()\n+            150..153 'obj': &dyn D\n+            164..166 '&S': &S\n+            165..166 'S': S\n+            176..179 'obj': &dyn A\n+            190..192 '&S': &S\n+            191..192 'S': S\n+        \"#]],\n     );\n }\n \n@@ -854,41 +779,35 @@ fn coerce_unsize_generic() {\n     // FIXME: fix the type mismatches here\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+//- minicore: coerce_unsized\n+struct Foo<T> { t: T };\n+struct Bar<T>(Foo<T>);\n \n-        struct Foo<T> { t: T };\n-        struct Bar<T>(Foo<T>);\n-\n-        fn test() {\n-            let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n-            let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n-        }\n-        \"#,\n+fn test() {\n+    let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+    let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+}\n+\"#,\n         expect![[r#\"\n-            209..317 '{     ... }); }': ()\n-            219..220 '_': &Foo<[usize]>\n-            238..259 '&Foo {..., 3] }': &Foo<[usize]>\n-            239..259 'Foo { ..., 3] }': Foo<[usize]>\n-            248..257 '[1, 2, 3]': [usize; 3]\n-            249..250 '1': usize\n-            252..253 '2': usize\n-            255..256 '3': usize\n-            269..270 '_': &Bar<[usize]>\n-            288..314 '&Bar(F... 3] })': &Bar<[i32; 3]>\n-            289..292 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n-            289..314 'Bar(Fo... 3] })': Bar<[i32; 3]>\n-            293..313 'Foo { ..., 3] }': Foo<[i32; 3]>\n-            302..311 '[1, 2, 3]': [i32; 3]\n-            303..304 '1': i32\n-            306..307 '2': i32\n-            309..310 '3': i32\n-            248..257: expected [usize], got [usize; 3]\n-            288..314: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n+            58..166 '{     ... }); }': ()\n+            68..69 '_': &Foo<[usize]>\n+            87..108 '&Foo {..., 3] }': &Foo<[usize]>\n+            88..108 'Foo { ..., 3] }': Foo<[usize]>\n+            97..106 '[1, 2, 3]': [usize; 3]\n+            98..99 '1': usize\n+            101..102 '2': usize\n+            104..105 '3': usize\n+            118..119 '_': &Bar<[usize]>\n+            137..163 '&Bar(F... 3] })': &Bar<[i32; 3]>\n+            138..141 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n+            138..163 'Bar(Fo... 3] })': Bar<[i32; 3]>\n+            142..162 'Foo { ..., 3] }': Foo<[i32; 3]>\n+            151..160 '[1, 2, 3]': [i32; 3]\n+            152..153 '1': i32\n+            155..156 '2': i32\n+            158..159 '3': i32\n+            97..106: expected [usize], got [usize; 3]\n+            137..163: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n         \"#]],\n     );\n }\n@@ -898,28 +817,20 @@ fn coerce_unsize_apit() {\n     // FIXME: #8984\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n+//- minicore: coerce_unsized\n trait Foo {}\n \n fn test(f: impl Foo) {\n     let _: &dyn Foo = &f;\n }\n         \"#,\n         expect![[r#\"\n-            210..211 'f': impl Foo\n-            223..252 '{     ... &f; }': ()\n-            233..234 '_': &dyn Foo\n-            247..249 '&f': &impl Foo\n-            248..249 'f': impl Foo\n-            247..249: expected &dyn Foo, got &impl Foo\n+            22..23 'f': impl Foo\n+            35..64 '{     ... &f; }': ()\n+            45..46 '_': &dyn Foo\n+            59..61 '&f': &impl Foo\n+            60..61 'f': impl Foo\n+            59..61: expected &dyn Foo, got &impl Foo\n         \"#]],\n     );\n }\n@@ -1015,15 +926,7 @@ fn main() {\n fn coerce_unsize_expected_type() {\n     check_no_mismatches(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n+//- minicore: coerce_unsized\n fn main() {\n     let foo: &[u32] = &[1, 2];\n     let foo: &[u32] = match true {"}, {"sha": "d9b5ee9cf3ef06bf401458173b82796dac06b3ef", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -780,10 +780,7 @@ fn test() { (&S).foo(); }\n fn method_resolution_unsize_array() {\n     check_types(\n         r#\"\n-#[lang = \"slice\"]\n-impl<T> [T] {\n-    fn len(&self) -> usize { loop {} }\n-}\n+//- minicore: slice\n fn test() {\n     let a = [1, 2, 3];\n     a.len();\n@@ -1178,11 +1175,7 @@ fn main() {\n fn autoderef_visibility_field() {\n     check_infer(\n         r#\"\n-#[lang = \"deref\"]\n-pub trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n+//- minicore: deref\n mod a {\n     pub struct Foo(pub char);\n     pub struct Bar(i32);\n@@ -1191,7 +1184,7 @@ mod a {\n             Self(0)\n         }\n     }\n-    impl super::Deref for Bar {\n+    impl core::ops::Deref for Bar {\n         type Target = Foo;\n         fn deref(&self) -> &Foo {\n             &Foo('z')\n@@ -1205,22 +1198,21 @@ mod b {\n }\n         \"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            200..231 '{     ...     }': Bar\n-            214..218 'Self': Bar(i32) -> Bar\n-            214..221 'Self(0)': Bar\n-            219..220 '0': i32\n-            315..319 'self': &Bar\n-            329..362 '{     ...     }': &Foo\n-            343..352 '&Foo('z')': &Foo\n-            344..347 'Foo': Foo(char) -> Foo\n-            344..352 'Foo('z')': Foo\n-            348..351 ''z'': char\n-            392..439 '{     ...     }': ()\n-            406..407 'x': char\n-            410..428 'super:...r::new': fn new() -> Bar\n-            410..430 'super:...:new()': Bar\n-            410..432 'super:...ew().0': char\n+            107..138 '{     ...     }': Bar\n+            121..125 'Self': Bar(i32) -> Bar\n+            121..128 'Self(0)': Bar\n+            126..127 '0': i32\n+            226..230 'self': &Bar\n+            240..273 '{     ...     }': &Foo\n+            254..263 '&Foo('z')': &Foo\n+            255..258 'Foo': Foo(char) -> Foo\n+            255..263 'Foo('z')': Foo\n+            259..262 ''z'': char\n+            303..350 '{     ...     }': ()\n+            317..318 'x': char\n+            321..339 'super:...r::new': fn new() -> Bar\n+            321..341 'super:...:new()': Bar\n+            321..343 'super:...ew().0': char\n         \"#]],\n     )\n }\n@@ -1230,11 +1222,7 @@ fn autoderef_visibility_method() {\n     cov_mark::check!(autoderef_candidate_not_visible);\n     check_infer(\n         r#\"\n-#[lang = \"deref\"]\n-pub trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n+//- minicore: deref\n mod a {\n     pub struct Foo(pub char);\n     impl Foo {\n@@ -1251,7 +1239,7 @@ mod a {\n             self.0\n         }\n     }\n-    impl super::Deref for Bar {\n+    impl core::ops::Deref for Bar {\n         type Target = Foo;\n         fn deref(&self) -> &Foo {\n             &Foo('z')\n@@ -1265,30 +1253,29 @@ mod b {\n }\n         \"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            168..172 'self': &Foo\n-            182..212 '{     ...     }': char\n-            196..200 'self': &Foo\n-            196..202 'self.0': char\n-            288..319 '{     ...     }': Bar\n-            302..306 'Self': Bar(i32) -> Bar\n-            302..309 'Self(0)': Bar\n-            307..308 '0': i32\n-            338..342 'self': &Bar\n-            351..381 '{     ...     }': i32\n-            365..369 'self': &Bar\n-            365..371 'self.0': i32\n-            465..469 'self': &Bar\n-            479..512 '{     ...     }': &Foo\n-            493..502 '&Foo('z')': &Foo\n-            494..497 'Foo': Foo(char) -> Foo\n-            494..502 'Foo('z')': Foo\n-            498..501 ''z'': char\n-            542..595 '{     ...     }': ()\n-            556..557 'x': char\n-            560..578 'super:...r::new': fn new() -> Bar\n-            560..580 'super:...:new()': Bar\n-            560..588 'super:...ango()': char\n+            75..79 'self': &Foo\n+            89..119 '{     ...     }': char\n+            103..107 'self': &Foo\n+            103..109 'self.0': char\n+            195..226 '{     ...     }': Bar\n+            209..213 'Self': Bar(i32) -> Bar\n+            209..216 'Self(0)': Bar\n+            214..215 '0': i32\n+            245..249 'self': &Bar\n+            258..288 '{     ...     }': i32\n+            272..276 'self': &Bar\n+            272..278 'self.0': i32\n+            376..380 'self': &Bar\n+            390..423 '{     ...     }': &Foo\n+            404..413 '&Foo('z')': &Foo\n+            405..408 'Foo': Foo(char) -> Foo\n+            405..413 'Foo('z')': Foo\n+            409..412 ''z'': char\n+            453..506 '{     ...     }': ()\n+            467..468 'x': char\n+            471..489 'super:...r::new': fn new() -> Bar\n+            471..491 'super:...:new()': Bar\n+            471..499 'super:...ango()': char\n         \"#]],\n     )\n }"}, {"sha": "abd9c385aee8990d2d2cd98239dbcf3146134451", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -927,35 +927,33 @@ fn issue_6628() {\n fn issue_6852() {\n     check_infer(\n         r#\"\n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target;\n-        }\n+//- minicore: deref\n+use core::ops::Deref;\n \n-        struct BufWriter {}\n+struct BufWriter {}\n \n-        struct Mutex<T> {}\n-        struct MutexGuard<'a, T> {}\n-        impl<T> Mutex<T> {\n-            fn lock(&self) -> MutexGuard<'_, T> {}\n-        }\n-        impl<'a, T: 'a> Deref for MutexGuard<'a, T> {\n-            type Target = T;\n-        }\n-        fn flush(&self) {\n-            let w: &Mutex<BufWriter>;\n-            *(w.lock());\n-        }\n-        \"#,\n+struct Mutex<T> {}\n+struct MutexGuard<'a, T> {}\n+impl<T> Mutex<T> {\n+    fn lock(&self) -> MutexGuard<'_, T> {}\n+}\n+impl<'a, T: 'a> Deref for MutexGuard<'a, T> {\n+    type Target = T;\n+}\n+fn flush(&self) {\n+    let w: &Mutex<BufWriter>;\n+    *(w.lock());\n+}\n+\"#,\n         expect![[r#\"\n-            156..160 'self': &Mutex<T>\n-            183..185 '{}': ()\n-            267..271 'self': &{unknown}\n-            273..323 '{     ...()); }': ()\n-            283..284 'w': &Mutex<BufWriter>\n-            309..320 '*(w.lock())': BufWriter\n-            311..312 'w': &Mutex<BufWriter>\n-            311..319 'w.lock()': MutexGuard<BufWriter>\n+            123..127 'self': &Mutex<T>\n+            150..152 '{}': ()\n+            234..238 'self': &{unknown}\n+            240..290 '{     ...()); }': ()\n+            250..251 'w': &Mutex<BufWriter>\n+            276..287 '*(w.lock())': BufWriter\n+            278..279 'w': &Mutex<BufWriter>\n+            278..286 'w.lock()': MutexGuard<BufWriter>\n         \"#]],\n     );\n }\n@@ -977,37 +975,33 @@ fn param_overrides_fn() {\n fn lifetime_from_chalk_during_deref() {\n     check_types(\n         r#\"\n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target;\n-        }\n-\n-        struct Box<T: ?Sized> {}\n-        impl<T> Deref for Box<T> {\n-            type Target = T;\n+//- minicore: deref\n+struct Box<T: ?Sized> {}\n+impl<T> core::ops::Deref for Box<T> {\n+    type Target = T;\n \n-            fn deref(&self) -> &Self::Target {\n-                loop {}\n-            }\n-        }\n+    fn deref(&self) -> &Self::Target {\n+        loop {}\n+    }\n+}\n \n-        trait Iterator {\n-            type Item;\n-        }\n+trait Iterator {\n+    type Item;\n+}\n \n-        pub struct Iter<'a, T: 'a> {\n-            inner: Box<dyn IterTrait<'a, T, Item = &'a T> + 'a>,\n-        }\n+pub struct Iter<'a, T: 'a> {\n+    inner: Box<dyn IterTrait<'a, T, Item = &'a T> + 'a>,\n+}\n \n-        trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> {\n-            fn clone_box(&self);\n-        }\n+trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> {\n+    fn clone_box(&self);\n+}\n \n-        fn clone_iter<T>(s: Iter<T>) {\n-            s.inner.clone_box();\n-          //^^^^^^^^^^^^^^^^^^^ ()\n-        }\n-        \"#,\n+fn clone_iter<T>(s: Iter<T>) {\n+    s.inner.clone_box();\n+    //^^^^^^^^^^^^^^^^^^^ ()\n+}\n+\"#,\n     )\n }\n "}, {"sha": "68776f3c0b56b7301b1991c770f4781b98b4bd44", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 365, "deletions": 402, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -113,7 +113,7 @@ fn type_alias_in_struct_lit() {\n fn infer_ranges() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: range\n fn test() {\n     let a = ..;\n     let b = 1..;\n@@ -125,32 +125,6 @@ fn test() {\n     let t = (a, b, c, d, e, f);\n     t;\n } //^ (RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\n-\n-//- /core.rs crate:core\n-#[prelude_import] use prelude::*;\n-mod prelude {}\n-\n-pub mod ops {\n-    pub struct Range<Idx> {\n-        pub start: Idx,\n-        pub end: Idx,\n-    }\n-    pub struct RangeFrom<Idx> {\n-        pub start: Idx,\n-    }\n-    struct RangeFull;\n-    pub struct RangeInclusive<Idx> {\n-        start: Idx,\n-        end: Idx,\n-        is_empty: u8,\n-    }\n-    pub struct RangeTo<Idx> {\n-        pub end: Idx,\n-    }\n-    pub struct RangeToInclusive<Idx> {\n-        pub end: Idx,\n-    }\n-}\n \"#,\n     );\n }\n@@ -175,16 +149,17 @@ fn test() {\n fn infer_basics() {\n     check_infer(\n         r#\"\n-        fn test(a: u32, b: isize, c: !, d: &str) {\n-            a;\n-            b;\n-            c;\n-            d;\n-            1usize;\n-            1isize;\n-            \"test\";\n-            1.0f32;\n-        }\"#,\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}\n+\"#,\n         expect![[r#\"\n             8..9 'a': u32\n             16..17 'b': isize\n@@ -207,15 +182,15 @@ fn infer_basics() {\n fn infer_let() {\n     check_infer(\n         r#\"\n-        fn test() {\n-            let a = 1isize;\n-            let b: usize = 1;\n-            let c = b;\n-            let d: u32;\n-            let e;\n-            let f: i32 = e;\n-        }\n-        \"#,\n+fn test() {\n+    let a = 1isize;\n+    let b: usize = 1;\n+    let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n+}\n+\"#,\n         expect![[r#\"\n             10..117 '{     ...= e; }': ()\n             20..21 'a': isize\n@@ -236,17 +211,17 @@ fn infer_let() {\n fn infer_paths() {\n     check_infer(\n         r#\"\n-        fn a() -> u32 { 1 }\n+fn a() -> u32 { 1 }\n \n-        mod b {\n-            fn c() -> u32 { 1 }\n-        }\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n \n-        fn test() {\n-            a();\n-            b::c();\n-        }\n-        \"#,\n+fn test() {\n+    a();\n+    b::c();\n+}\n+\"#,\n         expect![[r#\"\n             14..19 '{ 1 }': u32\n             16..17 '1': u32\n@@ -265,17 +240,17 @@ fn infer_paths() {\n fn infer_path_type() {\n     check_infer(\n         r#\"\n-        struct S;\n+struct S;\n \n-        impl S {\n-            fn foo() -> i32 { 1 }\n-        }\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n \n-        fn test() {\n-            S::foo();\n-            <S>::foo();\n-        }\n-        \"#,\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#,\n         expect![[r#\"\n             40..45 '{ 1 }': i32\n             42..43 '1': i32\n@@ -292,21 +267,21 @@ fn infer_path_type() {\n fn infer_struct() {\n     check_infer(\n         r#\"\n-        struct A {\n-            b: B,\n-            c: C,\n-        }\n-        struct B;\n-        struct C(usize);\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n \n-        fn test() {\n-            let c = C(1);\n-            B;\n-            let a: A = A { b: B, c: C(1) };\n-            a.b;\n-            a.c;\n-        }\n-        \"#,\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C(1) };\n+    a.b;\n+    a.c;\n+}\n+\"#,\n         expect![[r#\"\n             71..153 '{     ...a.c; }': ()\n             81..82 'c': C\n@@ -332,14 +307,15 @@ fn infer_struct() {\n fn infer_enum() {\n     check_infer(\n         r#\"\n-        enum E {\n-            V1 { field: u32 },\n-            V2\n-        }\n-        fn test() {\n-            E::V1 { field: 1 };\n-            E::V2;\n-        }\"#,\n+enum E {\n+    V1 { field: u32 },\n+    V2\n+}\n+fn test() {\n+    E::V1 { field: 1 };\n+    E::V2;\n+}\n+\"#,\n         expect![[r#\"\n             51..89 '{     ...:V2; }': ()\n             57..75 'E::V1 ...d: 1 }': E\n@@ -353,23 +329,23 @@ fn infer_enum() {\n fn infer_union() {\n     check_infer(\n         r#\"\n-        union MyUnion {\n-            foo: u32,\n-            bar: f32,\n-        }\n+union MyUnion {\n+    foo: u32,\n+    bar: f32,\n+}\n \n-        fn test() {\n-            let u = MyUnion { foo: 0 };\n-            unsafe { baz(u); }\n-            let u = MyUnion { bar: 0.0 };\n-            unsafe { baz(u); }\n-        }\n+fn test() {\n+    let u = MyUnion { foo: 0 };\n+    unsafe { baz(u); }\n+    let u = MyUnion { bar: 0.0 };\n+    unsafe { baz(u); }\n+}\n \n-        unsafe fn baz(u: MyUnion) {\n-            let inner = u.foo;\n-            let inner = u.bar;\n-        }\n-        \"#,\n+unsafe fn baz(u: MyUnion) {\n+    let inner = u.foo;\n+    let inner = u.bar;\n+}\n+\"#,\n         expect![[r#\"\n             57..172 '{     ...); } }': ()\n             67..68 'u': MyUnion\n@@ -404,19 +380,19 @@ fn infer_union() {\n fn infer_refs() {\n     check_infer(\n         r#\"\n-        fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n-            a;\n-            *a;\n-            &a;\n-            &mut a;\n-            b;\n-            *b;\n-            &b;\n-            c;\n-            *c;\n-            d;\n-            *d;\n-        }\n+fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n+    a;\n+    *a;\n+    &a;\n+    &mut a;\n+    b;\n+    *b;\n+    &b;\n+    c;\n+    *c;\n+    d;\n+    *d;\n+}\n         \"#,\n         expect![[r#\"\n             8..9 'a': &u32\n@@ -450,11 +426,11 @@ fn infer_refs() {\n fn infer_raw_ref() {\n     check_infer(\n         r#\"\n-        fn test(a: i32) {\n-            &raw mut a;\n-            &raw const a;\n-        }\n-        \"#,\n+fn test(a: i32) {\n+    &raw mut a;\n+    &raw const a;\n+}\n+\"#,\n         expect![[r#\"\n             8..9 'a': i32\n             16..53 '{     ...t a; }': ()\n@@ -524,26 +500,26 @@ h\";\n fn infer_unary_op() {\n     check_infer(\n         r#\"\n-        enum SomeType {}\n-\n-        fn test(x: SomeType) {\n-            let b = false;\n-            let c = !b;\n-            let a = 100;\n-            let d: i128 = -a;\n-            let e = -100;\n-            let f = !!!true;\n-            let g = !42;\n-            let h = !10u32;\n-            let j = !a;\n-            -3.14;\n-            !3;\n-            -x;\n-            !x;\n-            -\"hello\";\n-            !\"hello\";\n-        }\n-        \"#,\n+enum SomeType {}\n+\n+fn test(x: SomeType) {\n+    let b = false;\n+    let c = !b;\n+    let a = 100;\n+    let d: i128 = -a;\n+    let e = -100;\n+    let f = !!!true;\n+    let g = !42;\n+    let h = !10u32;\n+    let j = !a;\n+    -3.14;\n+    !3;\n+    -x;\n+    !x;\n+    -\"hello\";\n+    !\"hello\";\n+}\n+\"#,\n         expect![[r#\"\n             26..27 'x': SomeType\n             39..271 '{     ...lo\"; }': ()\n@@ -594,19 +570,19 @@ fn infer_unary_op() {\n fn infer_backwards() {\n     check_infer(\n         r#\"\n-        fn takes_u32(x: u32) {}\n+fn takes_u32(x: u32) {}\n \n-        struct S { i32_field: i32 }\n+struct S { i32_field: i32 }\n \n-        fn test() -> &mut &f64 {\n-            let a = unknown_function();\n-            takes_u32(a);\n-            let b = unknown_function();\n-            S { i32_field: b };\n-            let c = unknown_function();\n-            &mut &c\n-        }\n-        \"#,\n+fn test() -> &mut &f64 {\n+    let a = unknown_function();\n+    takes_u32(a);\n+    let b = unknown_function();\n+    S { i32_field: b };\n+    let c = unknown_function();\n+    &mut &c\n+}\n+\"#,\n         expect![[r#\"\n             13..14 'x': u32\n             21..23 '{}': ()\n@@ -636,23 +612,23 @@ fn infer_backwards() {\n fn infer_self() {\n     check_infer(\n         r#\"\n-        struct S;\n+struct S;\n \n-        impl S {\n-            fn test(&self) {\n-                self;\n-            }\n-            fn test2(self: &Self) {\n-                self;\n-            }\n-            fn test3() -> Self {\n-                S {}\n-            }\n-            fn test4() -> Self {\n-                Self {}\n-            }\n-        }\n-        \"#,\n+impl S {\n+    fn test(&self) {\n+        self;\n+    }\n+    fn test2(self: &Self) {\n+        self;\n+    }\n+    fn test3() -> Self {\n+        S {}\n+    }\n+    fn test4() -> Self {\n+        Self {}\n+    }\n+}\n+\"#,\n         expect![[r#\"\n             33..37 'self': &S\n             39..60 '{     ...     }': ()\n@@ -672,30 +648,30 @@ fn infer_self() {\n fn infer_self_as_path() {\n     check_infer(\n         r#\"\n-        struct S1;\n-        struct S2(isize);\n-        enum E {\n-            V1,\n-            V2(u32),\n-        }\n+struct S1;\n+struct S2(isize);\n+enum E {\n+    V1,\n+    V2(u32),\n+}\n \n-        impl S1 {\n-            fn test() {\n-                Self;\n-            }\n-        }\n-        impl S2 {\n-            fn test() {\n-                Self(1);\n-            }\n-        }\n-        impl E {\n-            fn test() {\n-                Self::V1;\n-                Self::V2(1);\n-            }\n-        }\n-        \"#,\n+impl S1 {\n+    fn test() {\n+        Self;\n+    }\n+}\n+impl S2 {\n+    fn test() {\n+        Self(1);\n+    }\n+}\n+impl E {\n+    fn test() {\n+        Self::V1;\n+        Self::V2(1);\n+    }\n+}\n+\"#,\n         expect![[r#\"\n             86..107 '{     ...     }': ()\n             96..100 'Self': S1\n@@ -716,26 +692,26 @@ fn infer_self_as_path() {\n fn infer_binary_op() {\n     check_infer(\n         r#\"\n-        fn f(x: bool) -> i32 {\n-            0i32\n-        }\n+fn f(x: bool) -> i32 {\n+    0i32\n+}\n \n-        fn test() -> bool {\n-            let x = a && b;\n-            let y = true || false;\n-            let z = x == y;\n-            let t = x != y;\n-            let minus_forty: isize = -40isize;\n-            let h = minus_forty <= CONST_2;\n-            let c = f(z || y) + 5;\n-            let d = b;\n-            let g = minus_forty ^= i;\n-            let ten: usize = 10;\n-            let ten_is_eleven = ten == some_num;\n-\n-            ten < 3\n-        }\n-        \"#,\n+fn test() -> bool {\n+    let x = a && b;\n+    let y = true || false;\n+    let z = x == y;\n+    let t = x != y;\n+    let minus_forty: isize = -40isize;\n+    let h = minus_forty <= CONST_2;\n+    let c = f(z || y) + 5;\n+    let d = b;\n+    let g = minus_forty ^= i;\n+    let ten: usize = 10;\n+    let ten_is_eleven = ten == some_num;\n+\n+    ten < 3\n+}\n+\"#,\n         expect![[r#\"\n             5..6 'x': bool\n             21..33 '{     0i32 }': i32\n@@ -795,11 +771,11 @@ fn infer_binary_op() {\n fn infer_shift_op() {\n     check_infer(\n         r#\"\n-        fn test() {\n-            1u32 << 5u8;\n-            1u32 >> 5u8;\n-        }\n-        \"#,\n+fn test() {\n+    1u32 << 5u8;\n+    1u32 >> 5u8;\n+}\n+\"#,\n         expect![[r#\"\n             10..47 '{     ...5u8; }': ()\n             16..20 '1u32': u32\n@@ -816,29 +792,29 @@ fn infer_shift_op() {\n fn infer_field_autoderef() {\n     check_infer(\n         r#\"\n-        struct A {\n-            b: B,\n-        }\n-        struct B;\n-\n-        fn test1(a: A) {\n-            let a1 = a;\n-            a1.b;\n-            let a2 = &a;\n-            a2.b;\n-            let a3 = &mut a;\n-            a3.b;\n-            let a4 = &&&&&&&a;\n-            a4.b;\n-            let a5 = &mut &&mut &&mut a;\n-            a5.b;\n-        }\n+struct A {\n+    b: B,\n+}\n+struct B;\n \n-        fn test2(a1: *const A, a2: *mut A) {\n-            a1.b;\n-            a2.b;\n-        }\n-        \"#,\n+fn test1(a: A) {\n+    let a1 = a;\n+    a1.b;\n+    let a2 = &a;\n+    a2.b;\n+    let a3 = &mut a;\n+    a3.b;\n+    let a4 = &&&&&&&a;\n+    a4.b;\n+    let a5 = &mut &&mut &&mut a;\n+    a5.b;\n+}\n+\n+fn test2(a1: *const A, a2: *mut A) {\n+    a1.b;\n+    a2.b;\n+}\n+\"#,\n         expect![[r#\"\n             43..44 'a': A\n             49..212 '{     ...5.b; }': ()\n@@ -891,58 +867,53 @@ fn infer_field_autoderef() {\n fn infer_argument_autoderef() {\n     check_infer(\n         r#\"\n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target;\n-            fn deref(&self) -> &Self::Target;\n-        }\n-\n-        struct A<T>(T);\n+//- minicore: deref\n+use core::ops::Deref;\n+struct A<T>(T);\n \n-        impl<T> A<T> {\n-            fn foo(&self) -> &T {\n-                &self.0\n-            }\n-        }\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n+        &self.0\n+    }\n+}\n \n-        struct B<T>(T);\n+struct B<T>(T);\n \n-        impl<T> Deref for B<T> {\n-            type Target = T;\n-            fn deref(&self) -> &Self::Target {\n-                &self.0\n-            }\n-        }\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n \n-        fn test() {\n-            let t = A::foo(&&B(B(A(42))));\n-        }\n-        \"#,\n+fn test() {\n+    let t = A::foo(&&B(B(A(42))));\n+}\n+\"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            138..142 'self': &A<T>\n-            150..173 '{     ...     }': &T\n-            160..167 '&self.0': &T\n-            161..165 'self': &A<T>\n-            161..167 'self.0': T\n-            254..258 'self': &B<T>\n-            277..300 '{     ...     }': &T\n-            287..294 '&self.0': &T\n-            288..292 'self': &B<T>\n-            288..294 'self.0': T\n-            314..352 '{     ...))); }': ()\n-            324..325 't': &i32\n-            328..334 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n-            328..349 'A::foo...42))))': &i32\n-            335..348 '&&B(B(A(42)))': &&B<B<A<i32>>>\n-            336..348 '&B(B(A(42)))': &B<B<A<i32>>>\n-            337..338 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n-            337..348 'B(B(A(42)))': B<B<A<i32>>>\n-            339..340 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n-            339..347 'B(A(42))': B<A<i32>>\n-            341..342 'A': A<i32>(i32) -> A<i32>\n-            341..346 'A(42)': A<i32>\n-            343..345 '42': i32\n+            66..70 'self': &A<T>\n+            78..101 '{     ...     }': &T\n+            88..95 '&self.0': &T\n+            89..93 'self': &A<T>\n+            89..95 'self.0': T\n+            182..186 'self': &B<T>\n+            205..228 '{     ...     }': &T\n+            215..222 '&self.0': &T\n+            216..220 'self': &B<T>\n+            216..222 'self.0': T\n+            242..280 '{     ...))); }': ()\n+            252..253 't': &i32\n+            256..262 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n+            256..277 'A::foo...42))))': &i32\n+            263..276 '&&B(B(A(42)))': &&B<B<A<i32>>>\n+            264..276 '&B(B(A(42)))': &B<B<A<i32>>>\n+            265..266 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n+            265..276 'B(B(A(42)))': B<B<A<i32>>>\n+            267..268 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n+            267..275 'B(A(42))': B<A<i32>>\n+            269..270 'A': A<i32>(i32) -> A<i32>\n+            269..274 'A(42)': A<i32>\n+            271..273 '42': i32\n         \"#]],\n     );\n }\n@@ -951,62 +922,57 @@ fn infer_argument_autoderef() {\n fn infer_method_argument_autoderef() {\n     check_infer(\n         r#\"\n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target;\n-            fn deref(&self) -> &Self::Target;\n-        }\n+//- minicore: deref\n+use core::ops::Deref;\n+struct A<T>(*mut T);\n \n-        struct A<T>(*mut T);\n-\n-        impl<T> A<T> {\n-            fn foo(&self, x: &A<T>) -> &T {\n-                &*x.0\n-            }\n-        }\n+impl<T> A<T> {\n+    fn foo(&self, x: &A<T>) -> &T {\n+        &*x.0\n+    }\n+}\n \n-        struct B<T>(T);\n+struct B<T>(T);\n \n-        impl<T> Deref for B<T> {\n-            type Target = T;\n-            fn deref(&self) -> &Self::Target {\n-                &self.0\n-            }\n-        }\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n \n-        fn test(a: A<i32>) {\n-            let t = A(0 as *mut _).foo(&&B(B(a)));\n-        }\n-        \"#,\n+fn test(a: A<i32>) {\n+    let t = A(0 as *mut _).foo(&&B(B(a)));\n+}\n+\"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            143..147 'self': &A<T>\n-            149..150 'x': &A<T>\n-            165..186 '{     ...     }': &T\n-            175..180 '&*x.0': &T\n-            176..180 '*x.0': T\n-            177..178 'x': &A<T>\n-            177..180 'x.0': *mut T\n-            267..271 'self': &B<T>\n-            290..313 '{     ...     }': &T\n-            300..307 '&self.0': &T\n-            301..305 'self': &B<T>\n-            301..307 'self.0': T\n-            325..326 'a': A<i32>\n-            336..382 '{     ...))); }': ()\n-            346..347 't': &i32\n-            350..351 'A': A<i32>(*mut i32) -> A<i32>\n-            350..364 'A(0 as *mut _)': A<i32>\n-            350..379 'A(0 as...B(a)))': &i32\n-            352..353 '0': i32\n-            352..363 '0 as *mut _': *mut i32\n-            369..378 '&&B(B(a))': &&B<B<A<i32>>>\n-            370..378 '&B(B(a))': &B<B<A<i32>>>\n-            371..372 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n-            371..378 'B(B(a))': B<B<A<i32>>>\n-            373..374 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n-            373..377 'B(a)': B<A<i32>>\n-            375..376 'a': A<i32>\n+            71..75 'self': &A<T>\n+            77..78 'x': &A<T>\n+            93..114 '{     ...     }': &T\n+            103..108 '&*x.0': &T\n+            104..108 '*x.0': T\n+            105..106 'x': &A<T>\n+            105..108 'x.0': *mut T\n+            195..199 'self': &B<T>\n+            218..241 '{     ...     }': &T\n+            228..235 '&self.0': &T\n+            229..233 'self': &B<T>\n+            229..235 'self.0': T\n+            253..254 'a': A<i32>\n+            264..310 '{     ...))); }': ()\n+            274..275 't': &i32\n+            278..279 'A': A<i32>(*mut i32) -> A<i32>\n+            278..292 'A(0 as *mut _)': A<i32>\n+            278..307 'A(0 as...B(a)))': &i32\n+            280..281 '0': i32\n+            280..291 '0 as *mut _': *mut i32\n+            297..306 '&&B(B(a))': &&B<B<A<i32>>>\n+            298..306 '&B(B(a))': &B<B<A<i32>>>\n+            299..300 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n+            299..306 'B(B(a))': B<B<A<i32>>>\n+            301..302 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n+            301..305 'B(a)': B<A<i32>>\n+            303..304 'a': A<i32>\n         \"#]],\n     );\n }\n@@ -1015,15 +981,15 @@ fn infer_method_argument_autoderef() {\n fn infer_in_elseif() {\n     check_infer(\n         r#\"\n-        struct Foo { field: i32 }\n-        fn main(foo: Foo) {\n-            if true {\n+struct Foo { field: i32 }\n+fn main(foo: Foo) {\n+    if true {\n \n-            } else if false {\n-                foo.field\n-            }\n-        }\n-        \"#,\n+    } else if false {\n+        foo.field\n+    }\n+}\n+\"#,\n         expect![[r#\"\n             34..37 'foo': Foo\n             44..108 '{     ...   } }': ()\n@@ -1043,28 +1009,29 @@ fn infer_in_elseif() {\n fn infer_if_match_with_return() {\n     check_infer(\n         r#\"\n-        fn foo() {\n-            let _x1 = if true {\n-                1\n-            } else {\n-                return;\n-            };\n-            let _x2 = if true {\n-                2\n-            } else {\n-                return\n-            };\n-            let _x3 = match true {\n-                true => 3,\n-                _ => {\n-                    return;\n-                }\n-            };\n-            let _x4 = match true {\n-                true => 4,\n-                _ => return\n-            };\n-        }\"#,\n+fn foo() {\n+    let _x1 = if true {\n+        1\n+    } else {\n+        return;\n+    };\n+    let _x2 = if true {\n+        2\n+    } else {\n+        return\n+    };\n+    let _x3 = match true {\n+        true => 3,\n+        _ => {\n+            return;\n+        }\n+    };\n+    let _x4 = match true {\n+        true => 4,\n+        _ => return\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             9..322 '{     ...  }; }': ()\n             19..22 '_x1': i32\n@@ -2639,11 +2606,8 @@ fn f() {\n fn infer_boxed_self_receiver() {\n     check_infer(\n         r#\"\n-#[lang = \"deref\"]\n-pub trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n+//- minicore: deref\n+use core::ops::Deref;\n \n struct Box<T>(T);\n \n@@ -2675,40 +2639,39 @@ fn main() {\n }\n         \"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            175..179 'self': &Box<T>\n-            259..263 'self': &Box<Foo<T>>\n-            289..291 '{}': ()\n-            313..317 'self': &Box<Foo<T>>\n-            346..348 '{}': ()\n-            368..372 'self': Box<Foo<T>>\n-            393..395 '{}': ()\n-            409..630 '{     ...r(); }': ()\n-            419..424 'boxed': Box<Foo<i32>>\n-            427..430 'Box': Box<Foo<i32>>(Foo<i32>) -> Box<Foo<i32>>\n-            427..442 'Box(Foo(0_i32))': Box<Foo<i32>>\n-            431..434 'Foo': Foo<i32>(i32) -> Foo<i32>\n-            431..441 'Foo(0_i32)': Foo<i32>\n-            435..440 '0_i32': i32\n-            453..457 'bad1': &i32\n-            460..465 'boxed': Box<Foo<i32>>\n-            460..477 'boxed....nner()': &i32\n-            487..492 'good1': &i32\n-            495..509 'Foo::get_inner': fn get_inner<i32>(&Box<Foo<i32>>) -> &i32\n-            495..517 'Foo::g...boxed)': &i32\n-            510..516 '&boxed': &Box<Foo<i32>>\n-            511..516 'boxed': Box<Foo<i32>>\n-            528..532 'bad2': &Foo<i32>\n-            535..540 'boxed': Box<Foo<i32>>\n-            535..551 'boxed....self()': &Foo<i32>\n-            561..566 'good2': &Foo<i32>\n-            569..582 'Foo::get_self': fn get_self<i32>(&Box<Foo<i32>>) -> &Foo<i32>\n-            569..590 'Foo::g...boxed)': &Foo<i32>\n-            583..589 '&boxed': &Box<Foo<i32>>\n-            584..589 'boxed': Box<Foo<i32>>\n-            601..606 'inner': Foo<i32>\n-            609..614 'boxed': Box<Foo<i32>>\n-            609..627 'boxed....nner()': Foo<i32>\n+            104..108 'self': &Box<T>\n+            188..192 'self': &Box<Foo<T>>\n+            218..220 '{}': ()\n+            242..246 'self': &Box<Foo<T>>\n+            275..277 '{}': ()\n+            297..301 'self': Box<Foo<T>>\n+            322..324 '{}': ()\n+            338..559 '{     ...r(); }': ()\n+            348..353 'boxed': Box<Foo<i32>>\n+            356..359 'Box': Box<Foo<i32>>(Foo<i32>) -> Box<Foo<i32>>\n+            356..371 'Box(Foo(0_i32))': Box<Foo<i32>>\n+            360..363 'Foo': Foo<i32>(i32) -> Foo<i32>\n+            360..370 'Foo(0_i32)': Foo<i32>\n+            364..369 '0_i32': i32\n+            382..386 'bad1': &i32\n+            389..394 'boxed': Box<Foo<i32>>\n+            389..406 'boxed....nner()': &i32\n+            416..421 'good1': &i32\n+            424..438 'Foo::get_inner': fn get_inner<i32>(&Box<Foo<i32>>) -> &i32\n+            424..446 'Foo::g...boxed)': &i32\n+            439..445 '&boxed': &Box<Foo<i32>>\n+            440..445 'boxed': Box<Foo<i32>>\n+            457..461 'bad2': &Foo<i32>\n+            464..469 'boxed': Box<Foo<i32>>\n+            464..480 'boxed....self()': &Foo<i32>\n+            490..495 'good2': &Foo<i32>\n+            498..511 'Foo::get_self': fn get_self<i32>(&Box<Foo<i32>>) -> &Foo<i32>\n+            498..519 'Foo::g...boxed)': &Foo<i32>\n+            512..518 '&boxed': &Box<Foo<i32>>\n+            513..518 'boxed': Box<Foo<i32>>\n+            530..535 'inner': Foo<i32>\n+            538..543 'boxed': Box<Foo<i32>>\n+            538..556 'boxed....nner()': Foo<i32>\n         \"#]],\n     );\n }"}, {"sha": "65fed02d24f1f7dfd0e73922c6338f6ead3298a7", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 19, "deletions": 105, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -6,10 +6,10 @@ use super::{check_infer, check_infer_with_mismatches, check_types};\n fn infer_await() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: future\n struct IntFuture;\n \n-impl Future for IntFuture {\n+impl core::future::Future for IntFuture {\n     type Output = u64;\n }\n \n@@ -18,16 +18,6 @@ fn test() {\n     let v = r.await;\n     v;\n } //^ u64\n-\n-//- /core.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[lang = \"future_trait\"]\n-        pub trait Future {\n-            type Output;\n-        }\n-    }\n-}\n \"#,\n     );\n }\n@@ -36,25 +26,14 @@ pub mod prelude {\n fn infer_async() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n-async fn foo() -> u64 {\n-            128\n-}\n+//- minicore: future\n+async fn foo() -> u64 { 128 }\n \n fn test() {\n     let r = foo();\n     let v = r.await;\n     v;\n } //^ u64\n-\n-//- /core.rs crate:core\n-#[prelude_import] use future::*;\n-mod future {\n-    #[lang = \"future_trait\"]\n-    trait Future {\n-        type Output;\n-    }\n-}\n \"#,\n     );\n }\n@@ -63,24 +42,13 @@ mod future {\n fn infer_desugar_async() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n-async fn foo() -> u64 {\n-            128\n-}\n+//- minicore: future\n+async fn foo() -> u64 { 128 }\n \n fn test() {\n     let r = foo();\n     r;\n } //^ impl Future<Output = u64>\n-\n-//- /core.rs crate:core\n-#[prelude_import] use future::*;\n-mod future {\n-    trait Future {\n-        type Output;\n-    }\n-}\n-\n \"#,\n     );\n }\n@@ -89,7 +57,7 @@ mod future {\n fn infer_async_block() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: future, option\n async fn test() {\n     let a = async { 42 };\n     a;\n@@ -101,26 +69,14 @@ async fn test() {\n     b;\n //  ^ ()\n     let c = async {\n-        let y = Option::None;\n+        let y = None;\n         y\n     //  ^ Option<u64>\n     };\n     let _: Option<u64> = c.await;\n     c;\n //  ^ impl Future<Output = Option<u64>>\n }\n-\n-enum Option<T> { None, Some(T) }\n-\n-//- /core.rs crate:core\n-#[prelude_import] use future::*;\n-mod future {\n-    #[lang = \"future_trait\"]\n-    trait Future {\n-        type Output;\n-    }\n-}\n-\n \"#,\n     );\n }\n@@ -704,14 +660,9 @@ mod ops {\n fn deref_trait() {\n     check_types(\n         r#\"\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n+//- minicore: deref\n struct Arc<T>;\n-impl<T> Deref for Arc<T> {\n+impl<T> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -731,16 +682,10 @@ fn test(s: Arc<S>) {\n fn deref_trait_with_inference_var() {\n     check_types(\n         r#\"\n-//- /main.rs\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n+//- minicore: deref\n struct Arc<T>;\n fn new_arc<T>() -> Arc<T> {}\n-impl<T> Deref for Arc<T> {\n+impl<T> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -761,15 +706,10 @@ fn test() {\n fn deref_trait_infinite_recursion() {\n     check_types(\n         r#\"\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n+//- minicore: deref\n struct S;\n \n-impl Deref for S {\n+impl core::ops::Deref for S {\n     type Target = S;\n }\n \n@@ -784,14 +724,9 @@ fn test(s: S) {\n fn deref_trait_with_question_mark_size() {\n     check_types(\n         r#\"\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n+//- minicore: deref\n struct Arc<T>;\n-impl<T> Deref for Arc<T> {\n+impl<T: ?Sized> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -2625,12 +2560,9 @@ fn test<T: Trait>() {\n fn dyn_trait_through_chalk() {\n     check_types(\n         r#\"\n+//- minicore: deref\n struct Box<T> {}\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-}\n-impl<T> Deref for Box<T> {\n+impl<T> core::ops::Deref for Box<T> {\n     type Target = T;\n }\n trait Trait {\n@@ -3695,16 +3627,7 @@ impl foo::Foo for u32 {\n fn infer_async_ret_type() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n-\n-enum Result<T, E> {\n-    Ok(T),\n-    Err(E),\n-}\n-\n-use Result::*;\n-\n-\n+//- minicore: future, result\n struct Fooey;\n \n impl Fooey {\n@@ -3727,15 +3650,6 @@ async fn get_accounts() -> Result<u32, ()> {\n     //                      ^ u32\n     Ok(ret)\n }\n-\n-//- /core.rs crate:core\n-#[prelude_import] use future::*;\n-mod future {\n-    #[lang = \"future_trait\"]\n-    trait Future {\n-        type Output;\n-    }\n-}\n \"#,\n     );\n }"}, {"sha": "14cf94d607763de31f3762773b7ce0c80d7d6964", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -3000,29 +3000,24 @@ fn foo(ar$0g: &impl Foo + Bar<S>) {}\n     fn test_hover_async_block_impl_trait_has_goto_type_action() {\n         check_actions(\n             r#\"\n+//- minicore: future\n struct S;\n fn foo() {\n     let fo$0o = async { S };\n }\n-\n-#[prelude_import] use future::*;\n-mod future {\n-    #[lang = \"future_trait\"]\n-    pub trait Future { type Output; }\n-}\n \"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n                         [\n                             HoverGotoTypeData {\n-                                mod_path: \"test::future::Future\",\n+                                mod_path: \"core::future::Future\",\n                                 nav: NavigationTarget {\n                                     file_id: FileId(\n-                                        0,\n+                                        1,\n                                     ),\n-                                    full_range: 101..163,\n-                                    focus_range: 140..146,\n+                                    full_range: 244..426,\n+                                    focus_range: 283..289,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "0fccbeccfd728d65d03603c8fee22912245d1d84", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -536,17 +536,11 @@ Some multi-line comment$0\n     fn test_completion_await_impls_future() {\n         check(\n             r#\"\n-//- /main.rs crate:main deps:std\n-use std::future::*;\n+//- minicore: future\n+use core::future::*;\n struct A {}\n impl Future for A {}\n fn foo(a: A) { a.$0 }\n-\n-//- /std/lib.rs crate:std\n-pub mod future {\n-    #[lang = \"future_trait\"]\n-    pub trait Future {}\n-}\n \"#,\n             expect![[r#\"\n                 kw await expr.await\n@@ -555,20 +549,12 @@ pub mod future {\n \n         check(\n             r#\"\n-//- /main.rs crate:main deps:std\n+//- minicore: future\n use std::future::*;\n fn foo() {\n     let a = async {};\n     a.$0\n }\n-\n-//- /std/lib.rs crate:std\n-pub mod future {\n-    #[lang = \"future_trait\"]\n-    pub trait Future {\n-        type Output;\n-    }\n-}\n \"#,\n             expect![[r#\"\n                 kw await expr.await"}, {"sha": "3eb51e80b3f94dfb528e01ba472363c37bbc3a38", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -1152,16 +1152,11 @@ fn main() {\n     fn suggest_deref() {\n         check_relevance(\n             r#\"\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n+//- minicore: deref\n struct S;\n struct T(S);\n \n-impl Deref for T {\n+impl core::ops::Deref for T {\n     type Target = S;\n \n     fn deref(&self) -> &Self::Target {\n@@ -1185,8 +1180,9 @@ fn main() {\n                 st T []\n                 st S []\n                 fn main() []\n-                tt Deref []\n                 fn foo(\u2026) []\n+                md core []\n+                tt Sized []\n             \"#]],\n         )\n     }"}, {"sha": "260a504e7674cbffae1f2194661bdd74a25e13b7", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -75,7 +75,9 @@ impl<'a> Project<'a> {\n             profile::init_from(crate::PROFILE);\n         });\n \n-        for entry in Fixture::parse(self.fixture) {\n+        let (mini_core, fixtures) = Fixture::parse(self.fixture);\n+        assert!(mini_core.is_none());\n+        for entry in fixtures {\n             let path = tmp_dir.path().join(&entry.path['/'.len_utf8()..]);\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();"}, {"sha": "6ba112de8df265e9321f64cd79fd968725cbdf2a", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 159, "deletions": 9, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -77,6 +77,11 @@ pub struct Fixture {\n     pub introduce_new_source_root: bool,\n }\n \n+pub struct MiniCore {\n+    activated_flags: Vec<String>,\n+    valid_flags: Vec<String>,\n+}\n+\n impl Fixture {\n     /// Parses text which looks like this:\n     ///\n@@ -86,12 +91,28 @@ impl Fixture {\n     ///  line 2\n     ///  //- other meta\n     ///  ```\n-    pub fn parse(ra_fixture: &str) -> Vec<Fixture> {\n+    ///\n+    /// Fixture can also start with a minicore declaration:\n+    ///\n+    /// ```\n+    /// //- minicore: sized\n+    /// ```\n+    ///\n+    /// That will include a subset of `libcore` into the fixture, see\n+    /// `minicore.rs` for what's available.\n+    pub fn parse(ra_fixture: &str) -> (Option<MiniCore>, Vec<Fixture>) {\n         let fixture = trim_indent(ra_fixture);\n-\n+        let mut fixture = fixture.as_str();\n+        let mut mini_core = None;\n         let mut res: Vec<Fixture> = Vec::new();\n \n-        let default = if ra_fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n+        if fixture.starts_with(\"//- minicore:\") {\n+            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n+            mini_core = Some(MiniCore::parse(first_line));\n+            fixture = &fixture[first_line.len()..];\n+        }\n+\n+        let default = if fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n \n         for (ix, line) in default.into_iter().chain(fixture.split_inclusive('\\n')).enumerate() {\n             if line.contains(\"//-\") {\n@@ -113,7 +134,7 @@ impl Fixture {\n             }\n         }\n \n-        res\n+        (mini_core, res)\n     }\n \n     //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n@@ -172,6 +193,133 @@ impl Fixture {\n     }\n }\n \n+impl MiniCore {\n+    fn has_flag(&self, flag: &str) -> bool {\n+        self.activated_flags.iter().any(|it| it == flag)\n+    }\n+\n+    #[track_caller]\n+    fn assert_valid_flag(&self, flag: &str) {\n+        if !self.valid_flags.iter().any(|it| it == flag) {\n+            panic!(\"invalid flag: {:?}, valid flags: {:?}\", flag, self.valid_flags);\n+        }\n+    }\n+\n+    fn parse(line: &str) -> MiniCore {\n+        let mut res = MiniCore { activated_flags: Vec::new(), valid_flags: Vec::new() };\n+\n+        let line = line.strip_prefix(\"//- minicore:\").unwrap().trim();\n+        for entry in line.split(\", \") {\n+            if res.has_flag(entry) {\n+                panic!(\"duplicate minicore flag: {:?}\", entry)\n+            }\n+            res.activated_flags.push(entry.to_string())\n+        }\n+\n+        res\n+    }\n+\n+    /// Strips parts of minicore.rs which are flagged by inactive flags.\n+    ///\n+    /// This is probably over-engineered to support flags dependencies.\n+    pub fn source_code(mut self) -> String {\n+        let mut buf = String::new();\n+        let raw_mini_core = include_str!(\"./minicore.rs\");\n+        let mut lines = raw_mini_core.split_inclusive('\\n');\n+\n+        let mut parsing_flags = false;\n+        let mut implications = Vec::new();\n+\n+        // Parse `//!` preamble and extract flags and dependencies.\n+        for line in lines.by_ref() {\n+            let line = match line.strip_prefix(\"//!\") {\n+                Some(it) => it,\n+                None => {\n+                    assert!(line.trim().is_empty());\n+                    break;\n+                }\n+            };\n+\n+            if parsing_flags {\n+                let (flag, deps) = line.split_once(':').unwrap();\n+                let flag = flag.trim();\n+                self.valid_flags.push(flag.to_string());\n+                for dep in deps.split(\", \") {\n+                    let dep = dep.trim();\n+                    if !dep.is_empty() {\n+                        self.assert_valid_flag(dep);\n+                        implications.push((flag, dep));\n+                    }\n+                }\n+            }\n+\n+            if line.contains(\"Available flags:\") {\n+                parsing_flags = true;\n+            }\n+        }\n+\n+        for flag in &self.activated_flags {\n+            self.assert_valid_flag(flag);\n+        }\n+\n+        // Fixed point loop to compute transitive closure of flags.\n+        loop {\n+            let mut changed = false;\n+            for &(u, v) in implications.iter() {\n+                if self.has_flag(u) && !self.has_flag(v) {\n+                    self.activated_flags.push(v.to_string());\n+                    changed = true;\n+                }\n+            }\n+            if !changed {\n+                break;\n+            }\n+        }\n+\n+        let mut curr_region = \"\";\n+        let mut seen_regions = Vec::new();\n+        for line in lines {\n+            let trimmed = line.trim();\n+            if let Some(region) = trimmed.strip_prefix(\"// region:\") {\n+                assert_eq!(curr_region, \"\");\n+                curr_region = region;\n+                continue;\n+            }\n+            if let Some(region) = trimmed.strip_prefix(\"// endregion:\") {\n+                assert_eq!(curr_region, region);\n+                curr_region = \"\";\n+                continue;\n+            }\n+            seen_regions.push(curr_region);\n+\n+            let mut flag = curr_region;\n+            if let Some(idx) = trimmed.find(\"// :\") {\n+                flag = &trimmed[idx + \"// :\".len()..];\n+            }\n+\n+            let skip = if flag == \"\" {\n+                false\n+            } else {\n+                assert!(!flag.starts_with(' '), \"region marker starts with a space: {:?}\", flag);\n+                self.assert_valid_flag(flag);\n+                !self.has_flag(flag)\n+            };\n+\n+            if !skip {\n+                buf.push_str(line)\n+            }\n+        }\n+\n+        for flag in &self.valid_flags {\n+            if !seen_regions.iter().any(|it| it == flag) {\n+                panic!(\"unused minicore flag: {:?}\", flag);\n+            }\n+        }\n+\n+        buf\n+    }\n+}\n+\n #[test]\n #[should_panic]\n fn parse_fixture_checks_further_indented_metadata() {\n@@ -189,12 +337,14 @@ fn parse_fixture_checks_further_indented_metadata() {\n \n #[test]\n fn parse_fixture_gets_full_meta() {\n-    let parsed = Fixture::parse(\n-        r\"\n-    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n-    mod m;\n-    \",\n+    let (mini_core, parsed) = Fixture::parse(\n+        r#\"\n+//- minicore: coerce_unsized\n+//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n+mod m;\n+\"#,\n     );\n+    assert_eq!(mini_core.unwrap().activated_flags, vec![\"coerce_unsized\".to_string()]);\n     assert_eq!(1, parsed.len());\n \n     let meta = &parsed[0];"}, {"sha": "d55bae62a1771dcd433f4012e3e78c9fcc28bb87", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -23,7 +23,10 @@ use text_size::{TextRange, TextSize};\n pub use dissimilar::diff as __diff;\n pub use rustc_hash::FxHashMap;\n \n-pub use crate::{assert_linear::AssertLinear, fixture::Fixture};\n+pub use crate::{\n+    assert_linear::AssertLinear,\n+    fixture::{Fixture, MiniCore},\n+};\n \n pub const CURSOR_MARKER: &str = \"$0\";\n pub const ESCAPED_CURSOR_MARKER: &str = \"\\\\$0\";"}, {"sha": "5ff60178ce651e087616c9c2fd0307f7f4852a59", "filename": "crates/test_utils/src/minicore.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bddd2af551702e472fb1a678466bc620b8973fa/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=9bddd2af551702e472fb1a678466bc620b8973fa", "patch": "@@ -0,0 +1,204 @@\n+//! This is a fixture we use for tests that need lang items.\n+//!\n+//! We want to include the minimal subset of core for each test, so this file\n+//! supports \"conditional compilation\". Tests use the following syntax to include minicore:\n+//!\n+//!  //- minicore: flag1, flag2\n+//!\n+//! We then strip all the code marked with other flags.\n+//!\n+//! Available flags:\n+//!     sized:\n+//!     slice:\n+//!     range:\n+//!     unsize: sized\n+//!     deref: sized\n+//!     coerce_unsized: unsize\n+//!     pin:\n+//!     future: pin\n+//!     option:\n+//!     result:\n+\n+pub mod marker {\n+    // region:sized\n+    #[lang = \"sized\"]\n+    #[fundamental]\n+    #[rustc_specialization_trait]\n+    pub trait Sized {}\n+    // endregion:sized\n+\n+    // region:unsize\n+    #[lang = \"unsize\"]\n+    pub trait Unsize<T: ?Sized> {}\n+    // endregion:unsize\n+}\n+\n+pub mod ops {\n+    // region:coerce_unsized\n+    mod unsize {\n+        use crate::marker::Unsize;\n+\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T: ?Sized> {}\n+\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+    }\n+    pub use self::unsize::CoerceUnsized;\n+    // endregion:coerce_unsized\n+\n+    // region:deref\n+    mod deref {\n+        #[lang = \"deref\"]\n+        pub trait Deref {\n+            #[lang = \"deref_target\"]\n+            type Target: ?Sized;\n+            fn deref(&self) -> &Self::Target;\n+        }\n+    }\n+    pub use self::deref::Deref;\n+    // endregion:deref\n+\n+    // region:range\n+    mod range {\n+        #[lang = \"RangeFull\"]\n+        pub struct RangeFull;\n+\n+        #[lang = \"Range\"]\n+        pub struct Range<Idx> {\n+            pub start: Idx,\n+            pub end: Idx,\n+        }\n+\n+        #[lang = \"RangeFrom\"]\n+        pub struct RangeFrom<Idx> {\n+            pub start: Idx,\n+        }\n+\n+        #[lang = \"RangeTo\"]\n+        pub struct RangeTo<Idx> {\n+            pub end: Idx,\n+        }\n+\n+        #[lang = \"RangeInclusive\"]\n+        pub struct RangeInclusive<Idx> {\n+            pub(crate) start: Idx,\n+            pub(crate) end: Idx,\n+            pub(crate) exhausted: bool,\n+        }\n+\n+        #[lang = \"RangeToInclusive\"]\n+        pub struct RangeToInclusive<Idx> {\n+            pub end: Idx,\n+        }\n+    }\n+    pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n+    pub use self::range::{RangeInclusive, RangeToInclusive};\n+    // endregion:range\n+}\n+\n+// region:slice\n+pub mod slice {\n+    #[lang = \"slice\"]\n+    impl<T> [T] {\n+        pub fn len(&self) -> usize {\n+            loop {}\n+        }\n+    }\n+}\n+// endregion:slice\n+\n+// region:option\n+pub mod option {\n+    pub enum Option<T> {\n+        #[lang = \"None\"]\n+        None,\n+        #[lang = \"Some\"]\n+        Some(T),\n+    }\n+}\n+// endregion:option\n+\n+// region:result\n+pub mod result {\n+    pub enum Result<T, E> {\n+        #[lang = \"Ok\"]\n+        Ok(T),\n+        #[lang = \"Err\"]\n+        Err(E),\n+    }\n+}\n+// endregion:result\n+\n+// region:pin\n+pub mod pin {\n+    #[lang = \"pin\"]\n+    #[fundamental]\n+    pub struct Pin<P> {\n+        pointer: P,\n+    }\n+}\n+// endregion:pin\n+\n+// region:future\n+pub mod future {\n+    use crate::{\n+        pin::Pin,\n+        task::{Context, Poll},\n+    };\n+\n+    #[lang = \"future_trait\"]\n+    pub trait Future {\n+        type Output;\n+        #[lang = \"poll\"]\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n+    }\n+}\n+pub mod task {\n+    pub enum Poll<T> {\n+        #[lang = \"Ready\"]\n+        Ready(T),\n+        #[lang = \"Pending\"]\n+        Pending,\n+    }\n+\n+    pub struct Context<'a> {\n+        waker: &'a (),\n+    }\n+}\n+// endregion:future\n+\n+pub mod prelude {\n+    pub mod v1 {\n+        pub use crate::{\n+            marker::Sized,                      // :sized\n+            option::Option::{self, None, Some}, // :option\n+            result::Result::{self, Err, Ok},    // :result\n+        };\n+    }\n+\n+    pub mod rust_2015 {\n+        pub use super::v1::*;\n+    }\n+\n+    pub mod rust_2018 {\n+        pub use super::v1::*;\n+    }\n+\n+    pub mod rust_2021 {\n+        pub use super::v1::*;\n+    }\n+}\n+\n+#[prelude_import]\n+#[allow(unused)]\n+use prelude::v1::*;"}]}