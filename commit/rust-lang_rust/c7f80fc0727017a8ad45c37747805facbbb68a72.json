{"sha": "c7f80fc0727017a8ad45c37747805facbbb68a72", "node_id": "C_kwDOAAsO6NoAKGM3ZjgwZmMwNzI3MDE3YThhZDQ1YzM3NzQ3ODA1ZmFjYmJiNjhhNzI", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-12-08T22:25:52Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-12-08T22:40:05Z"}, "message": "add tests", "tree": {"sha": "80a2c3ddead37ef878ac6bf3060fa9fbd6139a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80a2c3ddead37ef878ac6bf3060fa9fbd6139a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7f80fc0727017a8ad45c37747805facbbb68a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7f80fc0727017a8ad45c37747805facbbb68a72", "html_url": "https://github.com/rust-lang/rust/commit/c7f80fc0727017a8ad45c37747805facbbb68a72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7f80fc0727017a8ad45c37747805facbbb68a72/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e77f2b460492013cea459221194318b7fd8204", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e77f2b460492013cea459221194318b7fd8204", "html_url": "https://github.com/rust-lang/rust/commit/f9e77f2b460492013cea459221194318b7fd8204"}], "stats": {"total": 387, "additions": 387, "deletions": 0}, "files": [{"sha": "2f196533dd88c931c131d9696c149a68ec14363b", "filename": "src/test/ui/const-generics/issues/issue-79674.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,28 @@\n+#![feature(const_fn_trait_bound, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait MiniTypeId {\n+    const TYPE_ID: u64;\n+}\n+\n+impl<T> MiniTypeId for T {\n+    const TYPE_ID: u64 = 0;\n+}\n+\n+enum Lift<const V: bool> {}\n+\n+trait IsFalse {}\n+impl IsFalse for Lift<false> {}\n+\n+const fn is_same_type<T: MiniTypeId, U: MiniTypeId>() -> bool {\n+    T::TYPE_ID == U::TYPE_ID\n+}\n+\n+fn requires_distinct<A, B>(_a: A, _b: B) where\n+    A: MiniTypeId, B: MiniTypeId,\n+    Lift<{is_same_type::<A, B>()}>: IsFalse {}\n+\n+fn main() {\n+    requires_distinct(\"str\", 12);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "8c029289cbb0d78e57c2903d03d81ed5146508d0", "filename": "src/test/ui/const-generics/issues/issue-79674.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-79674.rs:26:5\n+   |\n+LL |     requires_distinct(\"str\", 12);\n+   |     ^^^^^^^^^^^^^^^^^ expected `true`, found `false`\n+   |\n+   = note: expected type `true`\n+              found type `false`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "68536348d3884584af1ae07d1dd71fc2774e6a3b", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,115 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait TensorDimension {\n+    const DIM : usize;\n+    const ISSCALAR : bool = Self::DIM == 0;\n+    fn is_scalar(&self) -> bool {Self::ISSCALAR}\n+}\n+\n+trait TensorSize : TensorDimension {\n+    fn size(&self) -> [usize;Self::DIM];\n+    fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n+        index.iter().zip(self.size().iter()).all(|(i,s)| i < s)\n+    }\n+}\n+\n+\n+trait Broadcastable: TensorSize + Sized {\n+    type Element;\n+    fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n+    fn lazy_updim<const NEWDIM : usize>(&self, size : [usize;NEWDIM] ) ->\n+       LazyUpdim<Self,{Self::DIM},NEWDIM>\n+    {\n+        assert!(NEWDIM >= Self::DIM,\n+            \"Updimmed tensor cannot have fewer indices than the initial one.\");\n+        LazyUpdim {size,reference:&self}\n+    }\n+    fn bmap<T,F :Fn(Self::Element) -> T>(&self,foo : F) -> BMap<T,Self,F,{Self::DIM}>{\n+        BMap {reference:self,closure : foo}\n+    }\n+}\n+\n+\n+struct LazyUpdim<'a,T : Broadcastable,const OLDDIM : usize, const DIM : usize> {\n+    size : [usize;DIM],\n+    reference : &'a T\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize> TensorDimension for LazyUpdim<'a,T,{T::DIM},DIM> {\n+    const DIM : usize = DIM;\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize> TensorSize for LazyUpdim<'a,T,{T::DIM},DIM> {\n+    fn size(&self) -> [usize;DIM] {self.size}\n+    //~^ ERROR method not compatible with trait\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM>\n+{\n+    type Element = T::Element;\n+    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+      //~^ ERROR method not compatible with trait\n+        assert!(DIM >= T::DIM);\n+        if !self.inbounds(index) {return None}\n+        //~^ ERROR unconstrained generic constant\n+        //~| ERROR mismatched types\n+        let size = self.size();\n+        //~^ ERROR unconstrained generic constant\n+        let newindex : [usize;T::DIM] = Default::default();\n+        //~^ ERROR the trait bound `[usize; _]: Default` is not satisfied\n+        self.reference.bget(newindex)\n+    }\n+}\n+\n+struct BMap<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  , const DIM: usize> {\n+    reference : &'a T,\n+    closure : F\n+}\n+\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R,\n+     const DIM: usize> TensorDimension for BMap<'a,R,T,F,DIM> {\n+\n+    const DIM : usize = DIM;\n+}\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n+      const DIM: usize> TensorSize for BMap<'a,R,T,F,DIM> {\n+\n+    fn size(&self) -> [usize;DIM] {self.reference.size()}\n+    //~^ ERROR unconstrained generic constant\n+    //~| ERROR mismatched types\n+    //~| ERROR method not compatible with trait\n+}\n+\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n+  const DIM: usize> Broadcastable for BMap<'a,R,T,F,DIM> {\n+\n+    type Element = R;\n+    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+      //~^ ERROR method not compatible with trait\n+        self.reference.bget(index).map(&self.closure)\n+        //~^ ERROR unconstrained generic constant\n+        //~| ERROR mismatched types\n+    }\n+}\n+\n+impl<T> TensorDimension for Vec<T> {\n+    const DIM : usize = 1;\n+}\n+impl<T> TensorSize for Vec<T> {\n+    fn size(&self) -> [usize;1] {[self.len()]}\n+}\n+impl<T: Clone> Broadcastable for Vec<T> {\n+    type Element = T;\n+    fn bget(& self,index : [usize;1]) -> Option<T> {\n+        self.get(index[0]).cloned()\n+    }\n+}\n+\n+fn main() {\n+    let v = vec![1,2,3];\n+    let bv = v.lazy_updim([3,4]);\n+    let bbv = bv.bmap(|x| x*x);\n+\n+    println!(\"The size of v is {:?}\",bbv.bget([0,2]).expect(\"Out of bounds.\"));\n+}"}, {"sha": "a49f850717f8a6afa51b0b4fb42ff62b42d95cd0", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,130 @@\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:44:5\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.size}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:51:5\n+   |\n+LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:78:5\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:88:5\n+   |\n+LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:54:18\n+   |\n+LL |         if !self.inbounds(index) {return None}\n+   |                  ^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::inbounds`\n+  --> $DIR/issue-83765.rs:12:38\n+   |\n+LL |     fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n+   |                                      ^^^^^^^^^ required by this bound in `TensorSize::inbounds`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:54:27\n+   |\n+LL |         if !self.inbounds(index) {return None}\n+   |                           ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:57:25\n+   |\n+LL |         let size = self.size();\n+   |                         ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::size`\n+  --> $DIR/issue-83765.rs:11:30\n+   |\n+LL |     fn size(&self) -> [usize;Self::DIM];\n+   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n+\n+error[E0277]: the trait bound `[usize; _]: Default` is not satisfied\n+  --> $DIR/issue-83765.rs:59:41\n+   |\n+LL |         let newindex : [usize;T::DIM] = Default::default();\n+   |                                         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `[usize; _]`\n+   |\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM> where [usize; _]: Default\n+   |                                                                                              +++++++++++++++++++++++++\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:78:51\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |                                                   ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::size`\n+  --> $DIR/issue-83765.rs:11:30\n+   |\n+LL |     fn size(&self) -> [usize;Self::DIM];\n+   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:78:36\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n+   |\n+   = note: expected type `DIM`\n+              found type `Self::DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:90:24\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                        ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `Broadcastable::bget`\n+  --> $DIR/issue-83765.rs:20:33\n+   |\n+LL |     fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n+   |                                 ^^^^^^^^^ required by this bound in `Broadcastable::bget`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:90:29\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                             ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "cf08f722fbb8092d26868b37ca3acf324a78b118", "filename": "src/test/ui/const-generics/issues/issue-86033.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+pub trait IsTrue<const T: bool> {}\n+impl IsTrue<true> for () {}\n+\n+pub trait IsZST {}\n+\n+impl<T> IsZST for T\n+where\n+    (): IsTrue<{ std::mem::size_of::<T>() == 0 }>\n+{}\n+\n+fn _func() -> impl IsZST {\n+    || {}\n+}\n+\n+fn main() {}"}, {"sha": "914047236ab5d3d7a7c70dec1e1e450451a1419d", "filename": "src/test/ui/const-generics/issues/issue-88468.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(generic_const_exprs)]\n+\n+pub struct Assert<const COND: bool>();\n+pub trait IsTrue {}\n+impl IsTrue for Assert<true> {}\n+\n+pub trait IsNotZST {}\n+impl<T> IsNotZST for T where Assert<{ std::mem::size_of::<T>() > 0 }>: IsTrue {}\n+\n+fn main() {}"}, {"sha": "0c640a5ef7136c12f79c593b38e586f565df9b10", "filename": "src/test/ui/const-generics/issues/issue-90318.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_type_id)]\n+#![feature(generic_const_exprs)]\n+#![feature(core_intrinsics)]\n+#![allow(incomplete_features)]\n+\n+use std::any::TypeId;\n+\n+struct If<const B: bool>;\n+pub trait True {}\n+impl True for If<true> {}\n+\n+fn consume<T: 'static>(_val: T)\n+where\n+    If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+    //~^ ERROR: overly complex generic constant\n+    //~| ERROR: calls in constants are limited to constant functions\n+{\n+}\n+\n+fn test<T: 'static>()\n+where\n+    If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+    //~^ ERROR: overly complex generic constant\n+    //~| ERROR: calls in constants are limited to constant functions\n+{\n+}\n+\n+fn main() {\n+    let a = ();\n+    consume(0i32);\n+    consume(a);\n+}"}, {"sha": "2b8afe2ef09ed77040bf834394fce922a2008c60", "filename": "src/test/ui/const-generics/issues/issue-90318.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f80fc0727017a8ad45c37747805facbbb68a72/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr?ref=c7f80fc0727017a8ad45c37747805facbbb68a72", "patch": "@@ -0,0 +1,37 @@\n+error: overly complex generic constant\n+  --> $DIR/issue-90318.rs:14:8\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |        ^^-----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          borrowing is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n+\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-90318.rs:14:10\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: overly complex generic constant\n+  --> $DIR/issue-90318.rs:22:8\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |        ^^-----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          borrowing is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n+\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-90318.rs:22:10\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}]}