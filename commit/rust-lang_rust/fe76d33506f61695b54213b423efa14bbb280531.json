{"sha": "fe76d33506f61695b54213b423efa14bbb280531", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNzZkMzM1MDZmNjE2OTViNTQyMTNiNDIzZWZhMTRiYmIyODA1MzE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-28T22:42:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-29T08:23:29Z"}, "message": "Add and use helper function for calling a machine function and passing it some arguments", "tree": {"sha": "8ce2324579813997ef7ab2a8803aa79cc4990828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce2324579813997ef7ab2a8803aa79cc4990828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe76d33506f61695b54213b423efa14bbb280531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe76d33506f61695b54213b423efa14bbb280531", "html_url": "https://github.com/rust-lang/rust/commit/fe76d33506f61695b54213b423efa14bbb280531", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe76d33506f61695b54213b423efa14bbb280531/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf51f591f7ffdd45f51cd1d42a4002482af2bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf51f591f7ffdd45f51cd1d42a4002482af2bd5", "html_url": "https://github.com/rust-lang/rust/commit/3bf51f591f7ffdd45f51cd1d42a4002482af2bd5"}], "stats": {"total": 282, "additions": 131, "deletions": 151}, "files": [{"sha": "488fdc3b37b1802a13cece11938fd9b322fb994f", "filename": "src/eval.rs", "status": "modified", "additions": 81, "deletions": 100, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/fe76d33506f61695b54213b423efa14bbb280531/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe76d33506f61695b54213b423efa14bbb280531/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=fe76d33506f61695b54213b423efa14bbb280531", "patch": "@@ -6,13 +6,8 @@ use rand::SeedableRng;\n use rustc::hir::def_id::DefId;\n use rustc::ty::layout::{LayoutOf, Size};\n use rustc::ty::{self, TyCtxt};\n-use syntax::source_map::DUMMY_SP;\n \n-use crate::{\n-    EnvVars, Evaluator, FnVal, HelpersEvalContextExt, InterpCx, InterpError,\n-    InterpResult, MemoryExtra, MiriMemoryKind, Pointer, Scalar, StackPopCleanup, Tag,\n-    TlsEvalContextExt, MPlaceTy\n-};\n+use crate::*;\n \n /// Configuration needed to spawn a Miri instance.\n #[derive(Clone)]\n@@ -65,122 +60,108 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(main_ret_ty))),\n     )\n     .unwrap();\n-    let start_mir = ecx.load_mir(start_instance.def, None)?;\n-\n-    if start_mir.arg_count != 3 {\n-        bug!(\n-            \"'start' lang item should have three arguments, but has {}\",\n-            start_mir.arg_count\n-        );\n-    }\n-\n-    // Return value (in static memory so that it does not count as leak).\n-    let ret = ecx.layout_of(start_mir.return_ty())?;\n-    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n-\n-    // Push our stack frame.\n-    ecx.push_stack_frame(\n-        start_instance,\n-        // There is no call site.\n-        DUMMY_SP,\n-        start_mir,\n-        Some(ret_ptr.into()),\n-        StackPopCleanup::None { cleanup: true },\n-    )?;\n-\n-    let mut args = ecx.frame().body.args_iter();\n \n     // First argument: pointer to `main()`.\n     let main_ptr = ecx\n         .memory\n         .create_fn_alloc(FnVal::Instance(main_instance));\n-    let dest = ecx.local_place(args.next().unwrap())?;\n-    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n-\n     // Second argument (argc): `1`.\n-    let dest = ecx.local_place(args.next().unwrap())?;\n-    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n-    ecx.write_scalar(argc, dest)?;\n-    // Store argc for macOS's `_NSGetArgc`.\n-    {\n-        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argc, argc_place.into())?;\n-        ecx.machine.argc = Some(argc_place.ptr);\n-    }\n-\n+    let argc = Scalar::from_uint(config.args.len() as u128, ecx.pointer_size());\n     // Third argument (`argv`): created from `config.args`.\n-    let dest = ecx.local_place(args.next().unwrap())?;\n-    // For Windows, construct a command string with all the aguments.\n-    let mut cmd = String::new();\n-    for arg in config.args.iter() {\n-        if !cmd.is_empty() {\n-            cmd.push(' ');\n+    let argv = {\n+        // For Windows, construct a command string with all the aguments (before we take apart `config.args`).\n+        let mut cmd = String::new();\n+        for arg in config.args.iter() {\n+            if !cmd.is_empty() {\n+                cmd.push(' ');\n+            }\n+            cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n         }\n-        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n-    }\n-    // Don't forget `0` terminator.\n-    cmd.push(std::char::from_u32(0).unwrap());\n-    // Collect the pointers to the individual strings.\n-    let mut argvs = Vec::<Pointer<Tag>>::new();\n-    for arg in config.args {\n-        // Add `0` terminator.\n-        let mut arg = arg.into_bytes();\n-        arg.push(0);\n-        argvs.push(\n-            ecx.memory\n-                .allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()),\n-        );\n-    }\n-    // Make an array with all these pointers, in the Miri memory.\n-    let argvs_layout = ecx.layout_of(\n-        tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), argvs.len() as u64),\n-    )?;\n-    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n-    for (idx, arg) in argvs.into_iter().enumerate() {\n-        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n-        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n-    }\n-    ecx.memory\n-        .mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n-    // Write a pointer to that place as the argument.\n-    let argv = argvs_place.ptr;\n-    ecx.write_scalar(argv, dest)?;\n-    // Store `argv` for macOS `_NSGetArgv`.\n-    {\n-        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argv, argv_place.into())?;\n-        ecx.machine.argv = Some(argv_place.ptr);\n-    }\n-    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n-    {\n-        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n-        let cmd_type = tcx.mk_array(tcx.types.u16, cmd_utf16.len() as u64);\n-        let cmd_place = ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Env.into());\n-        ecx.machine.cmd_line = Some(cmd_place.ptr);\n-        // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n-        let char_size = Size::from_bytes(2);\n-        for (idx, &c) in cmd_utf16.iter().enumerate() {\n-            let place = ecx.mplace_field(cmd_place, idx as u64)?;\n-            ecx.write_scalar(Scalar::from_uint(c, char_size), place.into())?;\n+        // Don't forget `0` terminator.\n+        cmd.push(std::char::from_u32(0).unwrap());\n+        // Collect the pointers to the individual strings.\n+        let mut argvs = Vec::<Pointer<Tag>>::new();\n+        for arg in config.args {\n+            // Add `0` terminator.\n+            let mut arg = arg.into_bytes();\n+            arg.push(0);\n+            argvs.push(\n+                ecx.memory\n+                    .allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()),\n+            );\n         }\n-    }\n+        // Make an array with all these pointers, in the Miri memory.\n+        let argvs_layout = ecx.layout_of(\n+            tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), argvs.len() as u64),\n+        )?;\n+        let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n+        for (idx, arg) in argvs.into_iter().enumerate() {\n+            let place = ecx.mplace_field(argvs_place, idx as u64)?;\n+            ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n+        }\n+        ecx.memory\n+            .mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n+        // A pointer to that place is the argument.\n+        let argv = argvs_place.ptr;\n+        // Store `argc` and `argv` for macOS `_NSGetArg{c,v}`.\n+        {\n+            let argc_place = ecx.allocate(\n+                ecx.layout_of(tcx.types.isize)?,\n+                MiriMemoryKind::Env.into(),\n+            );\n+            ecx.write_scalar(argc, argc_place.into())?;\n+            ecx.machine.argc = Some(argc_place.ptr);\n+\n+            let argv_place = ecx.allocate(\n+                ecx.layout_of(tcx.mk_imm_ptr(tcx.types.unit))?,\n+                MiriMemoryKind::Env.into(),\n+            );\n+            ecx.write_scalar(argv, argv_place.into())?;\n+            ecx.machine.argv = Some(argv_place.ptr);\n+        }\n+        // Store command line as UTF-16 for Windows `GetCommandLineW`.\n+        {\n+            let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n+            let cmd_type = tcx.mk_array(tcx.types.u16, cmd_utf16.len() as u64);\n+            let cmd_place = ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Env.into());\n+            ecx.machine.cmd_line = Some(cmd_place.ptr);\n+            // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n+            let char_size = Size::from_bytes(2);\n+            for (idx, &c) in cmd_utf16.iter().enumerate() {\n+                let place = ecx.mplace_field(cmd_place, idx as u64)?;\n+                ecx.write_scalar(Scalar::from_uint(c, char_size), place.into())?;\n+            }\n+        }\n+        argv\n+    };\n \n-    args.next().expect_none(\"start lang item has more arguments than expected\");\n+    // Return place (in static memory so that it does not count as leak).\n+    let ret_place = ecx.allocate(\n+        ecx.layout_of(tcx.types.isize)?,\n+        MiriMemoryKind::Static.into(),\n+    );\n+    // Call start function.\n+    ecx.call_function(\n+        start_instance,\n+        &[main_ptr.into(), argc, argv],\n+        Some(ret_place.into()),\n+        StackPopCleanup::None { cleanup: true },\n+    )?;\n \n     // Set the last_error to 0\n     let errno_layout = ecx.layout_of(tcx.types.u32)?;\n     let errno_place = ecx.allocate(errno_layout, MiriMemoryKind::Static.into());\n     ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n     ecx.machine.last_error = Some(errno_place);\n \n-    Ok((ecx, ret_ptr))\n+    Ok((ecx, ret_place))\n }\n \n /// Evaluates the main function specified by `main_id`.\n /// Returns `Some(return_code)` if program executed completed.\n /// Returns `None` if an evaluation error occured.\n pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) -> Option<i64> {\n-    let (mut ecx, ret_ptr) = match create_ecx(tcx, main_id, config) {\n+    let (mut ecx, ret_place) = match create_ecx(tcx, main_id, config) {\n         Ok(v) => v,\n         Err(mut err) => {\n             err.print_backtrace();\n@@ -193,7 +174,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n         ecx.run()?;\n         // Read the return code pointer *before* we run TLS destructors, to assert\n         // that it was written to by the time that `start` lang item returned.\n-        let return_code = ecx.read_scalar(ret_ptr.into())?.not_undef()?.to_machine_isize(&ecx)?;\n+        let return_code = ecx.read_scalar(ret_place.into())?.not_undef()?.to_machine_isize(&ecx)?;\n         ecx.run_tls_dtors()?;\n         Ok(return_code)\n     })();"}, {"sha": "28c31a07ef5796d49705ce7091892dfe6b2cc27f", "filename": "src/helpers.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe76d33506f61695b54213b423efa14bbb280531/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe76d33506f61695b54213b423efa14bbb280531/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=fe76d33506f61695b54213b423efa14bbb280531", "patch": "@@ -1,6 +1,7 @@\n use std::{mem, iter};\n use std::ffi::{OsStr, OsString};\n \n+use syntax::source_map::DUMMY_SP;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc::ty::{\n@@ -118,6 +119,40 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.memory.write_bytes(ptr, data.iter().copied())\n     }\n \n+    /// Call a function: Push the stack frame and pass the arguments.\n+    /// For now, arguments must be scalars (so that the caller does not have to know the layout).\n+    fn call_function(\n+        &mut self,\n+        f: ty::Instance<'tcx>,\n+        args: &[Scalar<Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        stack_pop: StackPopCleanup,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // Push frame.\n+        let mir = this.load_mir(f.def, None)?;\n+        this.push_stack_frame(\n+            f,\n+            DUMMY_SP, // There is no call site.\n+            mir,\n+            dest,\n+            stack_pop,\n+        )?;\n+\n+        // Initialize arguments.\n+        let mut callee_args = this.frame().body.args_iter();\n+        for arg in args {\n+            let callee_arg = this.local_place(\n+                callee_args.next().expect(\"callee has fewer arguments than expected\")\n+            )?;\n+            this.write_scalar(*arg, callee_arg)?;\n+        }\n+        callee_args.next().expect_none(\"callee has more arguments than expected\");\n+\n+        Ok(())\n+    }\n+\n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive("}, {"sha": "94ddee6fc0924823106a6b0e18c10b04a94e6939", "filename": "src/machine.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe76d33506f61695b54213b423efa14bbb280531/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe76d33506f61695b54213b423efa14bbb280531/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=fe76d33506f61695b54213b423efa14bbb280531", "patch": "@@ -230,37 +230,26 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n+        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n+        // First argument: `size`.\n+        // (`0` is allowed here -- this is expected to be handled by the lang item).\n+        let size = Scalar::from_uint(layout.size.bytes(), ecx.pointer_size());\n+\n+        // Second argument: `align`.\n+        let align = Scalar::from_uint(layout.align.abi.bytes(), ecx.pointer_size());\n+\n         // Call the `exchange_malloc` lang item.\n         let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n         let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n-        let malloc_mir = ecx.load_mir(malloc.def, None)?;\n-        ecx.push_stack_frame(\n+        ecx.call_function(\n             malloc,\n-            malloc_mir.span,\n-            malloc_mir,\n+            &[size, align],\n             Some(dest),\n             // Don't do anything when we are done. The `statement()` function will increment\n             // the old stack frame's stmt counter to the next statement, which means that when\n             // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n             StackPopCleanup::None { cleanup: true },\n         )?;\n-\n-        let mut args = ecx.frame().body.args_iter();\n-        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n-\n-        // First argument: `size`.\n-        // (`0` is allowed here -- this is expected to be handled by the lang item).\n-        let arg = ecx.local_place(args.next().unwrap())?;\n-        let size = layout.size.bytes();\n-        ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n-\n-        // Second argument: `align`.\n-        let arg = ecx.local_place(args.next().unwrap())?;\n-        let align = layout.align.abi.bytes();\n-        ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n-\n-        // No more arguments.\n-        args.next().expect_none(\"`exchange_malloc` lang item has more arguments than expected\");\n         Ok(())\n     }\n "}, {"sha": "6cc9f176c8fa8bc681cd8b1701bdf8bd363214b5", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe76d33506f61695b54213b423efa14bbb280531/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe76d33506f61695b54213b423efa14bbb280531/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=fe76d33506f61695b54213b423efa14bbb280531", "patch": "@@ -37,7 +37,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Handles the special \"miri_start_panic\" intrinsic, which is called\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n-    #[inline(always)]\n     fn handle_miri_start_panic(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n@@ -57,7 +56,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         return Ok(())\n     }\n \n-    #[inline(always)]\n     fn handle_catch_panic(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n@@ -83,30 +81,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Now we make a function call, and pass `f_arg` as first and only argument.\n         let f_instance = this.memory.get_fn(f)?.as_instance()?;\n         trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-        // TODO: consider making this reusable? `InterpCx::step` does something similar\n-        // for the TLS destructors, and of course `eval_main`.\n-        let mir = this.load_mir(f_instance.def, None)?;\n         let ret_place =\n             MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n-        this.push_stack_frame(\n+        this.call_function(\n             f_instance,\n-            mir.span,\n-            mir,\n+            &[f_arg],\n             Some(ret_place),\n             // Directly return to caller.\n             StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n         )?;\n \n-        let mut args = this.frame().body.args_iter();\n-        // First argument.\n-        let arg_local = args\n-            .next()\n-            .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n-        let arg_dest = this.local_place(arg_local)?;\n-        this.write_scalar(f_arg, arg_dest)?;\n-        // No more arguments.\n-        args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n-\n         // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n         this.write_null(dest)?;\n \n@@ -124,7 +108,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         return Ok(());\n     }\n \n-    #[inline(always)]\n     fn handle_stack_pop(\n         &mut self,\n         mut extra: FrameData<'tcx>,"}, {"sha": "ea8b0df230f2041d90c5cad55e99675d226d97c7", "filename": "src/shims/tls.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe76d33506f61695b54213b423efa14bbb280531/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe76d33506f61695b54213b423efa14bbb280531/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=fe76d33506f61695b54213b423efa14bbb280531", "patch": "@@ -146,22 +146,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n             assert!(!this.is_null(ptr).unwrap(), \"Data can't be NULL when dtor is called!\");\n-            // TODO: Potentially, this has to support all the other possible instances?\n-            // See eval_fn_call in interpret/terminator/mod.rs\n-            let mir = this.load_mir(instance.def, None)?;\n+\n             let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n-            this.push_stack_frame(\n+            this.call_function(\n                 instance,\n-                mir.span,\n-                mir,\n+                &[ptr],\n                 Some(ret_place),\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n-            let arg_local = this.frame().body.args_iter().next().ok_or_else(\n-                || err_ub_format!(\"TLS dtor does not take enough arguments.\"),\n-            )?;\n-            let dest = this.local_place(arg_local)?;\n-            this.write_scalar(ptr, dest)?;\n \n             // step until out of stackframes\n             this.run()?;"}]}