{"sha": "bb260e8950293b84d1da4724cc72027328b74a74", "node_id": "C_kwDOAAsO6NoAKGJiMjYwZTg5NTAyOTNiODRkMWRhNDcyNGNjNzIwMjczMjhiNzRhNzQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-23T19:13:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-23T19:13:02Z"}, "message": "Rollup merge of #92555 - m-ou-se:scoped-threads, r=Amanieu\n\nImplement RFC 3151: Scoped threads.\n\nThis implements https://github.com/rust-lang/rfcs/pull/3151\n\nr? `@Amanieu`", "tree": {"sha": "bfa650c030ddb720c644240d2d61e41a3380265b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfa650c030ddb720c644240d2d61e41a3380265b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb260e8950293b84d1da4724cc72027328b74a74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh7ai+CRBK7hj4Ov3rIwAAKL8IAKFN3tHBQnrZaIHogWmoJHST\ngfbkHJgkpOW+ZId11rtqZQp6adKndt5yV7wUhWVC1vv8bsxsLr8R+jfPfTe7TNRv\nq1t0wYHKfu+RG4dLBxWoe8Q3/v+rhX0HAo87Z/tE71q/hN5Hjt2htCbWhuJzjcNk\nWMgygD6R4nAAqnjK5UKw5fFWX+/hXGaMt0ysEiwDmZTnOvJWmvcv9rhSFRHdmRgi\nIIozeTqjWLaW/1QGG3uKq6udccLCiMlkWQVMA6LxEyDtc9gfi9LE0NtCVnu8QHfn\nYbT4OugHAKAKQ2AR4B5P03MoPAda8GUmYS8T+4NjAd5Yiz7df6MCRcw7+QXmjLM=\n=fIDd\n-----END PGP SIGNATURE-----\n", "payload": "tree bfa650c030ddb720c644240d2d61e41a3380265b\nparent 89baf0f162826983a07be78e102fad0a8a46f3c4\nparent 465c405418409cdd1d4c1537c44849effd01501d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642965182 +0100\ncommitter GitHub <noreply@github.com> 1642965182 +0100\n\nRollup merge of #92555 - m-ou-se:scoped-threads, r=Amanieu\n\nImplement RFC 3151: Scoped threads.\n\nThis implements https://github.com/rust-lang/rfcs/pull/3151\n\nr? `@Amanieu`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb260e8950293b84d1da4724cc72027328b74a74", "html_url": "https://github.com/rust-lang/rust/commit/bb260e8950293b84d1da4724cc72027328b74a74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb260e8950293b84d1da4724cc72027328b74a74/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89baf0f162826983a07be78e102fad0a8a46f3c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/89baf0f162826983a07be78e102fad0a8a46f3c4", "html_url": "https://github.com/rust-lang/rust/commit/89baf0f162826983a07be78e102fad0a8a46f3c4"}, {"sha": "465c405418409cdd1d4c1537c44849effd01501d", "url": "https://api.github.com/repos/rust-lang/rust/commits/465c405418409cdd1d4c1537c44849effd01501d", "html_url": "https://github.com/rust-lang/rust/commit/465c405418409cdd1d4c1537c44849effd01501d"}], "stats": {"total": 409, "additions": 382, "deletions": 27}, "files": [{"sha": "f8d790c37852c3b792847cabcda6b6f26ec1841b", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bb260e8950293b84d1da4724cc72027328b74a74/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb260e8950293b84d1da4724cc72027328b74a74/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=bb260e8950293b84d1da4724cc72027328b74a74", "patch": "@@ -180,6 +180,12 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n+#[unstable(feature = \"scoped_threads\", issue = \"93203\")]\n+mod scoped;\n+\n+#[unstable(feature = \"scoped_threads\", issue = \"93203\")]\n+pub use scoped::{scope, Scope, ScopedJoinHandle};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n@@ -446,6 +452,20 @@ impl Builder {\n         F: FnOnce() -> T,\n         F: Send + 'a,\n         T: Send + 'a,\n+    {\n+        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))\n+    }\n+\n+    unsafe fn spawn_unchecked_<'a, 'scope, F, T>(\n+        self,\n+        f: F,\n+        scope_data: Option<&'scope scoped::ScopeData>,\n+    ) -> io::Result<JoinInner<'scope, T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'a,\n+        T: Send + 'a,\n+        'scope: 'a,\n     {\n         let Builder { name, stack_size } = self;\n \n@@ -456,7 +476,8 @@ impl Builder {\n         }));\n         let their_thread = my_thread.clone();\n \n-        let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n+        let my_packet: Arc<Packet<'scope, T>> =\n+            Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None) });\n         let their_packet = my_packet.clone();\n \n         let output_capture = crate::io::set_output_capture(None);\n@@ -480,10 +501,14 @@ impl Builder {\n             // closure (it is an Arc<...>) and `my_packet` will be stored in the\n             // same `JoinInner` as this closure meaning the mutation will be\n             // safe (not modify it and affect a value far away).\n-            unsafe { *their_packet.get() = Some(try_result) };\n+            unsafe { *their_packet.result.get() = Some(try_result) };\n         };\n \n-        Ok(JoinHandle(JoinInner {\n+        if let Some(scope_data) = scope_data {\n+            scope_data.increment_num_running_threads();\n+        }\n+\n+        Ok(JoinInner {\n             // SAFETY:\n             //\n             // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n@@ -506,8 +531,8 @@ impl Builder {\n                 )?\n             },\n             thread: my_thread,\n-            packet: Packet(my_packet),\n-        }))\n+            packet: my_packet,\n+        })\n     }\n }\n \n@@ -1242,34 +1267,48 @@ impl fmt::Debug for Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n \n-// This packet is used to communicate the return value between the spawned thread\n-// and the rest of the program. Memory is shared through the `Arc` within and there's\n-// no need for a mutex here because synchronization happens with `join()` (the\n-// caller will never read this packet until the thread has exited).\n+// This packet is used to communicate the return value between the spawned\n+// thread and the rest of the program. It is shared through an `Arc` and\n+// there's no need for a mutex here because synchronization happens with `join()`\n+// (the caller will never read this packet until the thread has exited).\n //\n-// This packet itself is then stored into a `JoinInner` which in turns is placed\n-// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n-// manually worry about impls like Send and Sync. The type `T` should\n-// already always be Send (otherwise the thread could not have been created) and\n-// this type is inherently Sync because no methods take &self. Regardless,\n-// however, we add inheriting impls for Send/Sync to this type to ensure it's\n-// Send/Sync and that future modifications will still appropriately classify it.\n-struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n-\n-unsafe impl<T: Send> Send for Packet<T> {}\n-unsafe impl<T: Sync> Sync for Packet<T> {}\n+// An Arc to the packet is stored into a `JoinInner` which in turns is placed\n+// in `JoinHandle`.\n+struct Packet<'scope, T> {\n+    scope: Option<&'scope scoped::ScopeData>,\n+    result: UnsafeCell<Option<Result<T>>>,\n+}\n+\n+// Due to the usage of `UnsafeCell` we need to manually implement Sync.\n+// The type `T` should already always be Send (otherwise the thread could not\n+// have been created) and the Packet is Sync because all access to the\n+// `UnsafeCell` synchronized (by the `join()` boundary), and `ScopeData` is Sync.\n+unsafe impl<'scope, T: Sync> Sync for Packet<'scope, T> {}\n+\n+impl<'scope, T> Drop for Packet<'scope, T> {\n+    fn drop(&mut self) {\n+        // Book-keeping so the scope knows when it's done.\n+        if let Some(scope) = self.scope {\n+            // If this packet was for a thread that ran in a scope, the thread\n+            // panicked, and nobody consumed the panic payload, we make sure\n+            // the scope function will panic.\n+            let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));\n+            scope.decrement_num_running_threads(unhandled_panic);\n+        }\n+    }\n+}\n \n /// Inner representation for JoinHandle\n-struct JoinInner<T> {\n+struct JoinInner<'scope, T> {\n     native: imp::Thread,\n     thread: Thread,\n-    packet: Packet<T>,\n+    packet: Arc<Packet<'scope, T>>,\n }\n \n-impl<T> JoinInner<T> {\n+impl<'scope, T> JoinInner<'scope, T> {\n     fn join(mut self) -> Result<T> {\n         self.native.join();\n-        Arc::get_mut(&mut self.packet.0).unwrap().get_mut().take().unwrap()\n+        Arc::get_mut(&mut self.packet).unwrap().result.get_mut().take().unwrap()\n     }\n }\n \n@@ -1336,7 +1375,7 @@ impl<T> JoinInner<T> {\n /// [`thread::Builder::spawn`]: Builder::spawn\n /// [`thread::spawn`]: spawn\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinHandle<T>(JoinInner<T>);\n+pub struct JoinHandle<T>(JoinInner<'static, T>);\n \n #[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\n unsafe impl<T> Send for JoinHandle<T> {}\n@@ -1404,13 +1443,13 @@ impl<T> JoinHandle<T> {\n         self.0.join()\n     }\n \n-    /// Checks if the the associated thread is still running its main function.\n+    /// Checks if the associated thread is still running its main function.\n     ///\n     /// This might return `false` for a brief moment after the thread's main\n     /// function has returned, but before the thread itself has stopped running.\n     #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n     pub fn is_running(&self) -> bool {\n-        Arc::strong_count(&self.0.packet.0) > 1\n+        Arc::strong_count(&self.0.packet) > 1\n     }\n }\n "}, {"sha": "9dd7c15fc592236e1c66337ba2223d757ad56dac", "filename": "library/std/src/thread/scoped.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/bb260e8950293b84d1da4724cc72027328b74a74/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb260e8950293b84d1da4724cc72027328b74a74/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=bb260e8950293b84d1da4724cc72027328b74a74", "patch": "@@ -0,0 +1,316 @@\n+use super::{current, park, Builder, JoinInner, Result, Thread};\n+use crate::fmt;\n+use crate::io;\n+use crate::marker::PhantomData;\n+use crate::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n+\n+/// A scope to spawn scoped threads in.\n+///\n+/// See [`scope`] for details.\n+pub struct Scope<'env> {\n+    data: ScopeData,\n+    /// Invariance over 'env, to make sure 'env cannot shrink,\n+    /// which is necessary for soundness.\n+    ///\n+    /// Without invariance, this would compile fine but be unsound:\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(scoped_threads)]\n+    ///\n+    /// std::thread::scope(|s| {\n+    ///     s.spawn(|s| {\n+    ///         let a = String::from(\"abcd\");\n+    ///         s.spawn(|_| println!(\"{:?}\", a)); // might run after `a` is dropped\n+    ///     });\n+    /// });\n+    /// ```\n+    env: PhantomData<&'env mut &'env ()>,\n+}\n+\n+/// An owned permission to join on a scoped thread (block on its termination).\n+///\n+/// See [`Scope::spawn`] for details.\n+pub struct ScopedJoinHandle<'scope, T>(JoinInner<'scope, T>);\n+\n+pub(super) struct ScopeData {\n+    num_running_threads: AtomicUsize,\n+    a_thread_panicked: AtomicBool,\n+    main_thread: Thread,\n+}\n+\n+impl ScopeData {\n+    pub(super) fn increment_num_running_threads(&self) {\n+        // We check for 'overflow' with usize::MAX / 2, to make sure there's no\n+        // chance it overflows to 0, which would result in unsoundness.\n+        if self.num_running_threads.fetch_add(1, Ordering::Relaxed) > usize::MAX / 2 {\n+            // This can only reasonably happen by mem::forget()'ing many many ScopedJoinHandles.\n+            self.decrement_num_running_threads(false);\n+            panic!(\"too many running threads in thread scope\");\n+        }\n+    }\n+    pub(super) fn decrement_num_running_threads(&self, panic: bool) {\n+        if panic {\n+            self.a_thread_panicked.store(true, Ordering::Relaxed);\n+        }\n+        if self.num_running_threads.fetch_sub(1, Ordering::Release) == 1 {\n+            self.main_thread.unpark();\n+        }\n+    }\n+}\n+\n+/// Create a scope for spawning scoped threads.\n+///\n+/// The function passed to `scope` will be provided a [`Scope`] object,\n+/// through which scoped threads can be [spawned][`Scope::spawn`].\n+///\n+/// Unlike non-scoped threads, scoped threads can borrow non-`'static` data,\n+/// as the scope guarantees all threads will be joined at the end of the scope.\n+///\n+/// All threads spawned within the scope that haven't been manually joined\n+/// will be automatically joined before this function returns.\n+///\n+/// # Panics\n+///\n+/// If any of the automatically joined threads panicked, this function will panic.\n+///\n+/// If you want to handle panics from spawned threads,\n+/// [`join`][ScopedJoinHandle::join] them before the end of the scope.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(scoped_threads)]\n+/// use std::thread;\n+///\n+/// let mut a = vec![1, 2, 3];\n+/// let mut x = 0;\n+///\n+/// thread::scope(|s| {\n+///     s.spawn(|_| {\n+///         println!(\"hello from the first scoped thread\");\n+///         // We can borrow `a` here.\n+///         dbg!(&a);\n+///     });\n+///     s.spawn(|_| {\n+///         println!(\"hello from the second scoped thread\");\n+///         // We can even mutably borrow `x` here,\n+///         // because no other threads are using it.\n+///         x += a[0] + a[2];\n+///     });\n+///     println!(\"hello from the main thread\");\n+/// });\n+///\n+/// // After the scope, we can modify and access our variables again:\n+/// a.push(4);\n+/// assert_eq!(x, a.len());\n+/// ```\n+#[track_caller]\n+pub fn scope<'env, F, T>(f: F) -> T\n+where\n+    F: FnOnce(&Scope<'env>) -> T,\n+{\n+    let scope = Scope {\n+        data: ScopeData {\n+            num_running_threads: AtomicUsize::new(0),\n+            main_thread: current(),\n+            a_thread_panicked: AtomicBool::new(false),\n+        },\n+        env: PhantomData,\n+    };\n+\n+    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n+    let result = catch_unwind(AssertUnwindSafe(|| f(&scope)));\n+\n+    // Wait until all the threads are finished.\n+    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {\n+        park();\n+    }\n+\n+    // Throw any panic from `f`, or the return value of `f` if no thread panicked.\n+    match result {\n+        Err(e) => resume_unwind(e),\n+        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) => {\n+            panic!(\"a scoped thread panicked\")\n+        }\n+        Ok(result) => result,\n+    }\n+}\n+\n+impl<'env> Scope<'env> {\n+    /// Spawns a new thread within a scope, returning a [`ScopedJoinHandle`] for it.\n+    ///\n+    /// Unlike non-scoped threads, threads spawned with this function may\n+    /// borrow non-`'static` data from the outside the scope. See [`scope`] for\n+    /// details.\n+    ///\n+    /// The join handle provides a [`join`] method that can be used to join the spawned\n+    /// thread. If the spawned thread panics, [`join`] will return an [`Err`] containing\n+    /// the panic payload.\n+    ///\n+    /// If the join handle is dropped, the spawned thread will implicitly joined at the\n+    /// end of the scope. In that case, if the spawned thread panics, [`scope`] will\n+    /// panic after all threads are joined.\n+    ///\n+    /// This call will create a thread using default parameters of [`Builder`].\n+    /// If you want to specify the stack size or the name of the thread, use\n+    /// [`Builder::spawn_scoped`] instead.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the OS fails to create a thread; use [`Builder::spawn_scoped`]\n+    /// to recover from such errors.\n+    ///\n+    /// [`join`]: ScopedJoinHandle::join\n+    pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Builder::new().spawn_scoped(self, f).expect(\"failed to spawn thread\")\n+    }\n+}\n+\n+impl Builder {\n+    /// Spawns a new scoped thread using the settings set through this `Builder`.\n+    ///\n+    /// Unlike [`Scope::spawn`], this method yields an [`io::Result`] to\n+    /// capture any failure to create the thread at the OS level.\n+    ///\n+    /// [`io::Result`]: crate::io::Result\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if a thread name was set and it contained null bytes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// use std::thread;\n+    ///\n+    /// let mut a = vec![1, 2, 3];\n+    /// let mut x = 0;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     thread::Builder::new()\n+    ///         .name(\"first\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can borrow `a` here.\n+    ///         dbg!(&a);\n+    ///     })\n+    ///     .unwrap();\n+    ///     thread::Builder::new()\n+    ///         .name(\"second\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can even mutably borrow `x` here,\n+    ///         // because no other threads are using it.\n+    ///         x += a[0] + a[2];\n+    ///     })\n+    ///     .unwrap();\n+    ///     println!(\"hello from the main thread\");\n+    /// });\n+    ///\n+    /// // After the scope, we can modify and access our variables again:\n+    /// a.push(4);\n+    /// assert_eq!(x, a.len());\n+    /// ```\n+    pub fn spawn_scoped<'scope, 'env, F, T>(\n+        self,\n+        scope: &'scope Scope<'env>,\n+        f: F,\n+    ) -> io::Result<ScopedJoinHandle<'scope, T>>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(|| f(scope), Some(&scope.data)) }?))\n+    }\n+}\n+\n+impl<'scope, T> ScopedJoinHandle<'scope, T> {\n+    /// Extracts a handle to the underlying thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         println!(\"hello\");\n+    ///     });\n+    ///     println!(\"thread id: {:?}\", t.thread().id());\n+    /// });\n+    /// ```\n+    #[must_use]\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+\n+    /// Waits for the associated thread to finish.\n+    ///\n+    /// This function will return immediately if the associated thread has already finished.\n+    ///\n+    /// In terms of [atomic memory orderings], the completion of the associated\n+    /// thread synchronizes with this function returning.\n+    /// In other words, all operations performed by that thread\n+    /// [happen before](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses)\n+    /// all operations that happen after `join` returns.\n+    ///\n+    /// If the associated thread panics, [`Err`] is returned with the panic payload.\n+    ///\n+    /// [atomic memory orderings]: crate::sync::atomic\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         panic!(\"oh no\");\n+    ///     });\n+    ///     assert!(t.join().is_err());\n+    /// });\n+    /// ```\n+    pub fn join(self) -> Result<T> {\n+        self.0.join()\n+    }\n+\n+    /// Checks if the associated thread is still running its main function.\n+    ///\n+    /// This might return `false` for a brief moment after the thread's main\n+    /// function has returned, but before the thread itself has stopped running.\n+    #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n+    pub fn is_running(&self) -> bool {\n+        Arc::strong_count(&self.0.packet) > 1\n+    }\n+}\n+\n+impl<'env> fmt::Debug for Scope<'env> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scope\")\n+            .field(\"num_running_threads\", &self.data.num_running_threads.load(Ordering::Relaxed))\n+            .field(\"a_thread_panicked\", &self.data.a_thread_panicked.load(Ordering::Relaxed))\n+            .field(\"main_thread\", &self.data.main_thread)\n+            .finish_non_exhaustive()\n+    }\n+}\n+\n+impl<'scope, T> fmt::Debug for ScopedJoinHandle<'scope, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ScopedJoinHandle\").finish_non_exhaustive()\n+    }\n+}"}]}