{"sha": "44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MDI5YTViYmM0ODEyZjcxNDRlZThkMGQ0ZWU5NWQ1MmFlY2E2Y2Y=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-03T12:45:14Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-03T14:30:18Z"}, "message": "hashmap: rm linear namespace", "tree": {"sha": "4da0a6304fffc702120960fe36564246de6a16a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4da0a6304fffc702120960fe36564246de6a16a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "html_url": "https://github.com/rust-lang/rust/commit/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cc903015b395c0d9eada3fe3376f2447cc835b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc903015b395c0d9eada3fe3376f2447cc835b6", "html_url": "https://github.com/rust-lang/rust/commit/0cc903015b395c0d9eada3fe3376f2447cc835b6"}], "stats": {"total": 1854, "additions": 925, "deletions": 929}, "files": [{"sha": "64f0dc93e7867a5975f8d9368302cde050177b87", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -441,7 +441,7 @@ expression context, the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ~~~~\n-# use core::hashmap::linear::LinearMap;\n+# use core::hashmap::LinearMap;\n # fn f() {\n # fn id<T:Copy>(t: T) -> T { t }\n type t = LinearMap<int,~str>;  // Type arguments used in a type expression"}, {"sha": "8c5294767c26a291b0a593a2824f40d442618468", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -1888,7 +1888,7 @@ illegal to copy and pass by value.\n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n-# use core::hashmap::linear::LinearMap;\n+# use core::hashmap::LinearMap;\n type Set<T> = LinearMap<T, ()>;\n \n struct Stack<T> {"}, {"sha": "46f2ad76d0792dce0cd89603308f20af07d6c81d", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -43,7 +43,7 @@ use io;\n use libc::{size_t, uintptr_t};\n use option::{None, Option, Some};\n use ptr;\n-use hashmap::linear::LinearSet;\n+use hashmap::LinearSet;\n use stackwalk;\n use sys;\n "}, {"sha": "67942abba46339c27b8f5b68b529817c65a5027e", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 848, "deletions": 852, "changes": 1700, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -13,1013 +13,1009 @@\n //! The tables use a keyed hash with new random keys generated for each container, so the ordering\n //! of a set of keys in a hash table is randomized.\n \n-/// Open addressing with linear probing.\n-pub mod linear {\n-    use container::{Container, Mutable, Map, Set};\n-    use cmp::{Eq, Equiv};\n-    use hash::Hash;\n-    use to_bytes::IterBytes;\n-    use iter::BaseIter;\n-    use hash::Hash;\n-    use iter;\n-    use option::{None, Option, Some};\n-    use rand::RngUtil;\n-    use rand;\n-    use uint;\n-    use vec;\n-    use util::unreachable;\n+use container::{Container, Mutable, Map, Set};\n+use cmp::{Eq, Equiv};\n+use hash::Hash;\n+use to_bytes::IterBytes;\n+use iter::BaseIter;\n+use hash::Hash;\n+use iter;\n+use option::{None, Option, Some};\n+use rand::RngUtil;\n+use rand;\n+use uint;\n+use vec;\n+use util::unreachable;\n+\n+static INITIAL_CAPACITY: uint = 32u; // 2^5\n+\n+struct Bucket<K,V> {\n+    hash: uint,\n+    key: K,\n+    value: V,\n+}\n \n-    static INITIAL_CAPACITY: uint = 32u; // 2^5\n+pub struct LinearMap<K,V> {\n+    priv k0: u64,\n+    priv k1: u64,\n+    priv resize_at: uint,\n+    priv size: uint,\n+    priv buckets: ~[Option<Bucket<K, V>>],\n+}\n \n-    struct Bucket<K,V> {\n-        hash: uint,\n-        key: K,\n-        value: V,\n-    }\n+// We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n+// which would be nifty\n+enum SearchResult {\n+    FoundEntry(uint), FoundHole(uint), TableFull\n+}\n \n-    pub struct LinearMap<K,V> {\n-        priv k0: u64,\n-        priv k1: u64,\n-        priv resize_at: uint,\n-        priv size: uint,\n-        priv buckets: ~[Option<Bucket<K, V>>],\n-    }\n+#[inline(always)]\n+fn resize_at(capacity: uint) -> uint {\n+    ((capacity as float) * 3. / 4.) as uint\n+}\n \n-    // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n-    // which would be nifty\n-    enum SearchResult {\n-        FoundEntry(uint), FoundHole(uint), TableFull\n+pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n+    initial_capacity: uint) -> LinearMap<K, V> {\n+    let r = rand::task_rng();\n+    linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n+                                      initial_capacity)\n+}\n+\n+fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n+    k0: u64, k1: u64,\n+    initial_capacity: uint) -> LinearMap<K, V> {\n+    LinearMap {\n+        k0: k0, k1: k1,\n+        resize_at: resize_at(initial_capacity),\n+        size: 0,\n+        buckets: vec::from_fn(initial_capacity, |_| None)\n     }\n+}\n \n+priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n     #[inline(always)]\n-    fn resize_at(capacity: uint) -> uint {\n-        ((capacity as float) * 3. / 4.) as uint\n+    fn to_bucket(&self, h: uint) -> uint {\n+        // A good hash function with entropy spread over all of the\n+        // bits is assumed. SipHash is more than good enough.\n+        h % self.buckets.len()\n     }\n \n-    pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n-        initial_capacity: uint) -> LinearMap<K, V> {\n-        let r = rand::task_rng();\n-        linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n-                                          initial_capacity)\n+    #[inline(always)]\n+    fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n+        let n = (idx + 1) % len_buckets;\n+        debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n+        n\n     }\n \n-    fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n-        k0: u64, k1: u64,\n-        initial_capacity: uint) -> LinearMap<K, V> {\n-        LinearMap {\n-            k0: k0, k1: k1,\n-            resize_at: resize_at(initial_capacity),\n-            size: 0,\n-            buckets: vec::from_fn(initial_capacity, |_| None)\n+    #[inline(always)]\n+    fn bucket_sequence(&self, hash: uint,\n+                            op: &fn(uint) -> bool) -> uint {\n+        let start_idx = self.to_bucket(hash);\n+        let len_buckets = self.buckets.len();\n+        let mut idx = start_idx;\n+        loop {\n+            if !op(idx) {\n+                return idx;\n+            }\n+            idx = self.next_bucket(idx, len_buckets);\n+            if idx == start_idx {\n+                return start_idx;\n+            }\n         }\n     }\n \n-    priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n-        #[inline(always)]\n-        fn to_bucket(&self, h: uint) -> uint {\n-            // A good hash function with entropy spread over all of the\n-            // bits is assumed. SipHash is more than good enough.\n-            h % self.buckets.len()\n-        }\n+    #[inline(always)]\n+    fn bucket_for_key(&self, k: &K) -> SearchResult {\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        self.bucket_for_key_with_hash(hash, k)\n+    }\n \n-        #[inline(always)]\n-        fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n-            let n = (idx + 1) % len_buckets;\n-            debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n-            n\n-        }\n+    #[inline(always)]\n+    fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n+                                                           k: &Q)\n+                                                        -> SearchResult {\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        self.bucket_for_key_with_hash_equiv(hash, k)\n+    }\n \n-        #[inline(always)]\n-        fn bucket_sequence(&self, hash: uint,\n-                                op: &fn(uint) -> bool) -> uint {\n-            let start_idx = self.to_bucket(hash);\n-            let len_buckets = self.buckets.len();\n-            let mut idx = start_idx;\n-            loop {\n-                if !op(idx) {\n-                    return idx;\n-                }\n-                idx = self.next_bucket(idx, len_buckets);\n-                if idx == start_idx {\n-                    return start_idx;\n-                }\n+    #[inline(always)]\n+    fn bucket_for_key_with_hash(&self,\n+                                hash: uint,\n+                                k: &K)\n+                             -> SearchResult {\n+        let _ = for self.bucket_sequence(hash) |i| {\n+            match self.buckets[i] {\n+                Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n+                    return FoundEntry(i);\n+                },\n+                None => return FoundHole(i)\n             }\n-        }\n-\n-        #[inline(always)]\n-        fn bucket_for_key(&self, k: &K) -> SearchResult {\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.bucket_for_key_with_hash(hash, k)\n-        }\n-\n-        #[inline(always)]\n-        fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n-                                                               k: &Q)\n-                                                            -> SearchResult {\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.bucket_for_key_with_hash_equiv(hash, k)\n-        }\n+        };\n+        TableFull\n+    }\n \n-        #[inline(always)]\n-        fn bucket_for_key_with_hash(&self,\n-                                    hash: uint,\n-                                    k: &K)\n-                                 -> SearchResult {\n-            let _ = for self.bucket_sequence(hash) |i| {\n-                match self.buckets[i] {\n-                    Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n+    #[inline(always)]\n+    fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n+                                                  hash: uint,\n+                                                  k: &Q)\n+                                               -> SearchResult {\n+        let _ = for self.bucket_sequence(hash) |i| {\n+            match self.buckets[i] {\n+                Some(ref bkt) => {\n+                    if bkt.hash == hash && k.equiv(&bkt.key) {\n                         return FoundEntry(i);\n-                    },\n-                    None => return FoundHole(i)\n-                }\n-            };\n-            TableFull\n-        }\n-\n-        #[inline(always)]\n-        fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n-                                                      hash: uint,\n-                                                      k: &Q)\n-                                                   -> SearchResult {\n-            let _ = for self.bucket_sequence(hash) |i| {\n-                match self.buckets[i] {\n-                    Some(ref bkt) => {\n-                        if bkt.hash == hash && k.equiv(&bkt.key) {\n-                            return FoundEntry(i);\n-                        }\n-                    },\n-                    None => return FoundHole(i)\n-                }\n-            };\n-            TableFull\n-        }\n+                    }\n+                },\n+                None => return FoundHole(i)\n+            }\n+        };\n+        TableFull\n+    }\n \n-        /// Expand the capacity of the array to the next power of two\n-        /// and re-insert each of the existing buckets.\n-        #[inline(always)]\n-        fn expand(&mut self) {\n-            let new_capacity = self.buckets.len() * 2;\n-            self.resize(new_capacity);\n-        }\n+    /// Expand the capacity of the array to the next power of two\n+    /// and re-insert each of the existing buckets.\n+    #[inline(always)]\n+    fn expand(&mut self) {\n+        let new_capacity = self.buckets.len() * 2;\n+        self.resize(new_capacity);\n+    }\n \n-        /// Expands the capacity of the array and re-insert each of the\n-        /// existing buckets.\n-        fn resize(&mut self, new_capacity: uint) {\n-            let old_capacity = self.buckets.len();\n-            self.resize_at = resize_at(new_capacity);\n+    /// Expands the capacity of the array and re-insert each of the\n+    /// existing buckets.\n+    fn resize(&mut self, new_capacity: uint) {\n+        let old_capacity = self.buckets.len();\n+        self.resize_at = resize_at(new_capacity);\n \n-            let mut old_buckets = vec::from_fn(new_capacity, |_| None);\n-            self.buckets <-> old_buckets;\n+        let mut old_buckets = vec::from_fn(new_capacity, |_| None);\n+        self.buckets <-> old_buckets;\n \n-            self.size = 0;\n-            for uint::range(0, old_capacity) |i| {\n-                let mut bucket = None;\n-                bucket <-> old_buckets[i];\n-                self.insert_opt_bucket(bucket);\n-            }\n+        self.size = 0;\n+        for uint::range(0, old_capacity) |i| {\n+            let mut bucket = None;\n+            bucket <-> old_buckets[i];\n+            self.insert_opt_bucket(bucket);\n         }\n+    }\n \n-        fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K, V>>) {\n-            match bucket {\n-                Some(Bucket{hash: hash, key: key, value: value}) => {\n-                    self.insert_internal(hash, key, value);\n-                }\n-                None => {}\n+    fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K, V>>) {\n+        match bucket {\n+            Some(Bucket{hash: hash, key: key, value: value}) => {\n+                self.insert_internal(hash, key, value);\n             }\n+            None => {}\n         }\n+    }\n \n-        #[inline(always)]\n-        fn value_for_bucket(&self, idx: uint) -> &'self V {\n-            match self.buckets[idx] {\n-                Some(ref bkt) => &bkt.value,\n-                None => fail!(~\"LinearMap::find: internal logic error\"),\n-            }\n+    #[inline(always)]\n+    fn value_for_bucket(&self, idx: uint) -> &'self V {\n+        match self.buckets[idx] {\n+            Some(ref bkt) => &bkt.value,\n+            None => fail!(~\"LinearMap::find: internal logic error\"),\n         }\n+    }\n \n-        #[inline(always)]\n-        fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n-            match self.buckets[idx] {\n-                Some(ref mut bkt) => &mut bkt.value,\n-                None => unreachable()\n-            }\n+    #[inline(always)]\n+    fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n+        match self.buckets[idx] {\n+            Some(ref mut bkt) => &mut bkt.value,\n+            None => unreachable()\n         }\n+    }\n \n-        /// Inserts the key value pair into the buckets.\n-        /// Assumes that there will be a bucket.\n-        /// True if there was no previous entry with that key\n-        fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n-            match self.bucket_for_key_with_hash(hash, &k) {\n-                TableFull => { fail!(~\"Internal logic error\"); }\n-                FoundHole(idx) => {\n-                    debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n-                           k, v, idx, hash);\n-                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                    value: v});\n-                    self.size += 1;\n-                    true\n-                }\n-                FoundEntry(idx) => {\n-                    debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n-                           k, v, idx, hash);\n-                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                    value: v});\n-                    false\n-                }\n+    /// Inserts the key value pair into the buckets.\n+    /// Assumes that there will be a bucket.\n+    /// True if there was no previous entry with that key\n+    fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n+        match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => { fail!(~\"Internal logic error\"); }\n+            FoundHole(idx) => {\n+                debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                                value: v});\n+                self.size += 1;\n+                true\n+            }\n+            FoundEntry(idx) => {\n+                debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                                value: v});\n+                false\n             }\n         }\n+    }\n \n-        fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n-            // Removing from an open-addressed hashtable\n-            // is, well, painful.  The problem is that\n-            // the entry may lie on the probe path for other\n-            // entries, so removing it would make you think that\n-            // those probe paths are empty.\n-            //\n-            // To address this we basically have to keep walking,\n-            // re-inserting entries we find until we reach an empty\n-            // bucket.  We know we will eventually reach one because\n-            // we insert one ourselves at the beginning (the removed\n-            // entry).\n-            //\n-            // I found this explanation elucidating:\n-            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n-            let mut idx = match self.bucket_for_key_with_hash(hash, k) {\n-                TableFull | FoundHole(_) => return None,\n-                FoundEntry(idx) => idx\n-            };\n-\n-            let len_buckets = self.buckets.len();\n+    fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n+        // Removing from an open-addressed hashtable\n+        // is, well, painful.  The problem is that\n+        // the entry may lie on the probe path for other\n+        // entries, so removing it would make you think that\n+        // those probe paths are empty.\n+        //\n+        // To address this we basically have to keep walking,\n+        // re-inserting entries we find until we reach an empty\n+        // bucket.  We know we will eventually reach one because\n+        // we insert one ourselves at the beginning (the removed\n+        // entry).\n+        //\n+        // I found this explanation elucidating:\n+        // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+        let mut idx = match self.bucket_for_key_with_hash(hash, k) {\n+            TableFull | FoundHole(_) => return None,\n+            FoundEntry(idx) => idx\n+        };\n+\n+        let len_buckets = self.buckets.len();\n+        let mut bucket = None;\n+        self.buckets[idx] <-> bucket;\n+\n+        let value = match bucket {\n+            None => None,\n+            Some(bucket) => {\n+                let Bucket{value: value, _} = bucket;\n+                Some(value)\n+            },\n+        };\n+\n+        /* re-inserting buckets may cause changes in size, so remember\n+        what our new size is ahead of time before we start insertions */\n+        let size = self.size - 1;\n+        idx = self.next_bucket(idx, len_buckets);\n+        while self.buckets[idx].is_some() {\n             let mut bucket = None;\n-            self.buckets[idx] <-> bucket;\n-\n-            let value = match bucket {\n-                None => None,\n-                Some(bucket) => {\n-                    let Bucket{value: value, _} = bucket;\n-                    Some(value)\n-                },\n-            };\n-\n-            /* re-inserting buckets may cause changes in size, so remember\n-            what our new size is ahead of time before we start insertions */\n-            let size = self.size - 1;\n+            bucket <-> self.buckets[idx];\n+            self.insert_opt_bucket(bucket);\n             idx = self.next_bucket(idx, len_buckets);\n-            while self.buckets[idx].is_some() {\n-                let mut bucket = None;\n-                bucket <-> self.buckets[idx];\n-                self.insert_opt_bucket(bucket);\n-                idx = self.next_bucket(idx, len_buckets);\n-            }\n-            self.size = size;\n-\n-            value\n         }\n+        self.size = size;\n \n-        fn search(&self, hash: uint,\n-                  op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n-            let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n-        }\n+        value\n     }\n \n-    impl<'self,K:Hash + IterBytes + Eq,V>\n-            BaseIter<(&'self K, &'self V)> for LinearMap<K, V> {\n-        /// Visit all key-value pairs\n-        fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n-            for uint::range(0, self.buckets.len()) |i| {\n-                let mut broke = false;\n-                do self.buckets[i].map |bucket| {\n-                    if !blk(&(&bucket.key, &bucket.value)) {\n-                        broke = true; // FIXME(#3064) just write \"break;\"\n-                    }\n-                };\n-                if broke { break; }\n-            }\n+    fn search(&self, hash: uint,\n+              op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n+        let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n+    }\n+}\n+\n+impl<'self,K:Hash + IterBytes + Eq,V>\n+        BaseIter<(&'self K, &'self V)> for LinearMap<K, V> {\n+    /// Visit all key-value pairs\n+    fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            let mut broke = false;\n+            do self.buckets[i].map |bucket| {\n+                if !blk(&(&bucket.key, &bucket.value)) {\n+                    broke = true; // FIXME(#3064) just write \"break;\"\n+                }\n+            };\n+            if broke { break; }\n         }\n-        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n \n \n-    impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n-        /// Return the number of elements in the map\n-        fn len(&const self) -> uint { self.size }\n+impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n+    /// Return the number of elements in the map\n+    fn len(&const self) -> uint { self.size }\n \n-        /// Return true if the map contains no elements\n-        fn is_empty(&const self) -> bool { self.len() == 0 }\n-    }\n+    /// Return true if the map contains no elements\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n+}\n \n-    impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n-        /// Clear the map, removing all key-value pairs.\n-        fn clear(&mut self) {\n-            for uint::range(0, self.buckets.len()) |idx| {\n-                self.buckets[idx] = None;\n-            }\n-            self.size = 0;\n+impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) {\n+        for uint::range(0, self.buckets.len()) |idx| {\n+            self.buckets[idx] = None;\n         }\n+        self.size = 0;\n     }\n+}\n \n-    impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n-        /// Return true if the map contains a value for the specified key\n-        fn contains_key(&self, k: &K) -> bool {\n-            match self.bucket_for_key(k) {\n-                FoundEntry(_) => {true}\n-                TableFull | FoundHole(_) => {false}\n-            }\n-        }\n-\n-        /// Visit all keys\n-        fn each_key(&self, blk: &fn(k: &K) -> bool) {\n-            self.each(|&(k, _)| blk(k))\n+impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n+    /// Return true if the map contains a value for the specified key\n+    fn contains_key(&self, k: &K) -> bool {\n+        match self.bucket_for_key(k) {\n+            FoundEntry(_) => {true}\n+            TableFull | FoundHole(_) => {false}\n         }\n+    }\n \n-        /// Visit all values\n-        fn each_value(&self, blk: &fn(v: &V) -> bool) {\n-            self.each(|&(_, v)| blk(v))\n-        }\n+    /// Visit all keys\n+    fn each_key(&self, blk: &fn(k: &K) -> bool) {\n+        self.each(|&(k, _)| blk(k))\n+    }\n \n-        /// Iterate over the map and mutate the contained values\n-        fn mutate_values(&mut self, blk: &fn(&'self K,\n-                              &'self mut V) -> bool) {\n-            for uint::range(0, self.buckets.len()) |i| {\n-                match self.buckets[i] {\n-                  Some(Bucket{key: ref key, value: ref mut value, _}) => {\n-                    if !blk(key, value) { return }\n-                  }\n-                  None => ()\n-                }\n-            }\n-        }\n+    /// Visit all values\n+    fn each_value(&self, blk: &fn(v: &V) -> bool) {\n+        self.each(|&(_, v)| blk(v))\n+    }\n \n-        /// Return a reference to the value corresponding to the key\n-        fn find(&self, k: &K) -> Option<&'self V> {\n-            match self.bucket_for_key(k) {\n-                FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-                TableFull | FoundHole(_) => None,\n+    /// Iterate over the map and mutate the contained values\n+    fn mutate_values(&mut self, blk: &fn(&'self K,\n+                          &'self mut V) -> bool) {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            match self.buckets[i] {\n+              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n+                if !blk(key, value) { return }\n+              }\n+              None => ()\n             }\n         }\n+    }\n \n-        /// Return a mutable reference to the value corresponding to the key\n-        fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n-            let idx = match self.bucket_for_key(k) {\n-                FoundEntry(idx) => idx,\n-                TableFull | FoundHole(_) => return None\n-            };\n-            unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n-                Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n-            }\n+    /// Return a reference to the value corresponding to the key\n+    fn find(&self, k: &K) -> Option<&'self V> {\n+        match self.bucket_for_key(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n         }\n+    }\n \n-        /// Insert a key-value pair into the map. An existing value for a\n-        /// key is replaced by the new value. Return true if the key did\n-        /// not already exist in the map.\n-        fn insert(&mut self, k: K, v: V) -> bool {\n-            if self.size >= self.resize_at {\n-                // n.b.: We could also do this after searching, so\n-                // that we do not resize if this call to insert is\n-                // simply going to update a key in place.  My sense\n-                // though is that it's worse to have to search through\n-                // buckets to find the right spot twice than to just\n-                // resize in this corner case.\n-                self.expand();\n-            }\n-\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.insert_internal(hash, k, v)\n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n+        let idx = match self.bucket_for_key(k) {\n+            FoundEntry(idx) => idx,\n+            TableFull | FoundHole(_) => return None\n+        };\n+        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n         }\n+    }\n \n-        /// Remove a key-value pair from the map. Return true if the key\n-        /// was present in the map, otherwise false.\n-        fn remove(&mut self, k: &K) -> bool {\n-            self.pop(k).is_some()\n-        }\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, k: K, v: V) -> bool {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        self.insert_internal(hash, k, v)\n     }\n \n-    pub impl<K: Hash + IterBytes + Eq, V> LinearMap<K, V> {\n-        /// Create an empty LinearMap\n-        fn new() -> LinearMap<K, V> {\n-            LinearMap::with_capacity(INITIAL_CAPACITY)\n-        }\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, k: &K) -> bool {\n+        self.pop(k).is_some()\n+    }\n+}\n \n-        /// Create an empty LinearMap with space for at least `n` elements in\n-        /// the hash table.\n-        fn with_capacity(capacity: uint) -> LinearMap<K, V> {\n-            linear_map_with_capacity(capacity)\n-        }\n+pub impl<K: Hash + IterBytes + Eq, V> LinearMap<K, V> {\n+    /// Create an empty LinearMap\n+    fn new() -> LinearMap<K, V> {\n+        LinearMap::with_capacity(INITIAL_CAPACITY)\n+    }\n \n-        /// Reserve space for at least `n` elements in the hash table.\n-        fn reserve_at_least(&mut self, n: uint) {\n-            if n > self.buckets.len() {\n-                let buckets = n * 4 / 3 + 1;\n-                self.resize(uint::next_power_of_two(buckets));\n-            }\n-        }\n+    /// Create an empty LinearMap with space for at least `n` elements in\n+    /// the hash table.\n+    fn with_capacity(capacity: uint) -> LinearMap<K, V> {\n+        linear_map_with_capacity(capacity)\n+    }\n \n-        fn pop(&mut self, k: &K) -> Option<V> {\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.pop_internal(hash, k)\n+    /// Reserve space for at least `n` elements in the hash table.\n+    fn reserve_at_least(&mut self, n: uint) {\n+        if n > self.buckets.len() {\n+            let buckets = n * 4 / 3 + 1;\n+            self.resize(uint::next_power_of_two(buckets));\n         }\n+    }\n \n-        fn swap(&mut self, k: K, v: V) -> Option<V> {\n-            // this could be faster.\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            let old_value = self.pop_internal(hash, &k);\n-\n-            if self.size >= self.resize_at {\n-                // n.b.: We could also do this after searching, so\n-                // that we do not resize if this call to insert is\n-                // simply going to update a key in place.  My sense\n-                // though is that it's worse to have to search through\n-                // buckets to find the right spot twice than to just\n-                // resize in this corner case.\n-                self.expand();\n-            }\n+    fn pop(&mut self, k: &K) -> Option<V> {\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        self.pop_internal(hash, k)\n+    }\n \n-            self.insert_internal(hash, k, v);\n+    fn swap(&mut self, k: K, v: V) -> Option<V> {\n+        // this could be faster.\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let old_value = self.pop_internal(hash, &k);\n \n-            old_value\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n         }\n \n-        /// Return the value corresponding to the key in the map, or insert\n-        /// and return the value if it doesn't exist.\n-        fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n-            if self.size >= self.resize_at {\n-                // n.b.: We could also do this after searching, so\n-                // that we do not resize if this call to insert is\n-                // simply going to update a key in place.  My sense\n-                // though is that it's worse to have to search through\n-                // buckets to find the right spot twice than to just\n-                // resize in this corner case.\n-                self.expand();\n-            }\n+        self.insert_internal(hash, k, v);\n \n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-                TableFull => fail!(~\"Internal logic error\"),\n-                FoundEntry(idx) => idx,\n-                FoundHole(idx) => {\n-                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                         value: v});\n-                    self.size += 1;\n-                    idx\n-                },\n-            };\n+        old_value\n+    }\n \n-            unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-                ::cast::transmute_region(self.value_for_bucket(idx))\n-            }\n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n+    }\n \n-        /// Return the value corresponding to the key in the map, or create,\n-        /// insert, and return a new value if it doesn't exist.\n-        fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n-            if self.size >= self.resize_at {\n-                // n.b.: We could also do this after searching, so\n-                // that we do not resize if this call to insert is\n-                // simply going to update a key in place.  My sense\n-                // though is that it's worse to have to search through\n-                // buckets to find the right spot twice than to just\n-                // resize in this corner case.\n-                self.expand();\n-            }\n-\n-            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-                TableFull => fail!(~\"Internal logic error\"),\n-                FoundEntry(idx) => idx,\n-                FoundHole(idx) => {\n-                    let v = f(&k);\n-                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                         value: v});\n-                    self.size += 1;\n-                    idx\n-                },\n-            };\n-\n-            unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-                ::cast::transmute_region(self.value_for_bucket(idx))\n-            }\n+    /// Return the value corresponding to the key in the map, or create,\n+    /// insert, and return a new value if it doesn't exist.\n+    fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                let v = f(&k);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n+    }\n \n-        fn consume(&mut self, f: &fn(K, V)) {\n-            let mut buckets = ~[];\n-            self.buckets <-> buckets;\n-            self.size = 0;\n-\n-            do vec::consume(buckets) |_, bucket| {\n-                match bucket {\n-                    None => {},\n-                    Some(bucket) => {\n-                        let Bucket{key: key, value: value, _} = bucket;\n-                        f(key, value)\n-                    }\n+    fn consume(&mut self, f: &fn(K, V)) {\n+        let mut buckets = ~[];\n+        self.buckets <-> buckets;\n+        self.size = 0;\n+\n+        do vec::consume(buckets) |_, bucket| {\n+            match bucket {\n+                None => {},\n+                Some(bucket) => {\n+                    let Bucket{key: key, value: value, _} = bucket;\n+                    f(key, value)\n                 }\n             }\n         }\n+    }\n \n-        fn get(&self, k: &K) -> &'self V {\n-            match self.find(k) {\n-                Some(v) => v,\n-                None => fail!(fmt!(\"No entry found for key: %?\", k)),\n-            }\n+    fn get(&self, k: &K) -> &'self V {\n+        match self.find(k) {\n+            Some(v) => v,\n+            None => fail!(fmt!(\"No entry found for key: %?\", k)),\n         }\n+    }\n \n-        /// Return true if the map contains a value for the specified key,\n-        /// using equivalence\n-        fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n-                                                          -> bool {\n-            match self.bucket_for_key_equiv(key) {\n-                FoundEntry(_) => {true}\n-                TableFull | FoundHole(_) => {false}\n-            }\n+    /// Return true if the map contains a value for the specified key,\n+    /// using equivalence\n+    fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n+                                                      -> bool {\n+        match self.bucket_for_key_equiv(key) {\n+            FoundEntry(_) => {true}\n+            TableFull | FoundHole(_) => {false}\n         }\n+    }\n \n-        /// Return the value corresponding to the key in the map, using\n-        /// equivalence\n-        fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                                  -> Option<&'self V> {\n-            match self.bucket_for_key_equiv(k) {\n-                FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-                TableFull | FoundHole(_) => None,\n-            }\n+    /// Return the value corresponding to the key in the map, using\n+    /// equivalence\n+    fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n+                                              -> Option<&'self V> {\n+        match self.bucket_for_key_equiv(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n         }\n     }\n+}\n \n-    impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n-        fn eq(&self, other: &LinearMap<K, V>) -> bool {\n-            if self.len() != other.len() { return false; }\n+impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n+    fn eq(&self, other: &LinearMap<K, V>) -> bool {\n+        if self.len() != other.len() { return false; }\n \n-            for self.each |&(key, value)| {\n-                match other.find(key) {\n-                    None => return false,\n-                    Some(v) => if value != v { return false },\n-                }\n+        for self.each |&(key, value)| {\n+            match other.find(key) {\n+                None => return false,\n+                Some(v) => if value != v { return false },\n             }\n-\n-            true\n         }\n \n-        fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n+        true\n     }\n \n-    pub struct LinearSet<T> {\n-        priv map: LinearMap<T, ()>\n-    }\n+    fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n+}\n \n-    impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n-        /// Visit all values in order\n-        fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n-        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-    }\n+pub struct LinearSet<T> {\n+    priv map: LinearMap<T, ()>\n+}\n \n-    impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n-        fn eq(&self, other: &LinearSet<T>) -> bool { self.map == other.map }\n-        fn ne(&self, other: &LinearSet<T>) -> bool { self.map != other.map }\n-    }\n+impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n+    /// Visit all values in order\n+    fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n \n-    impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n-        /// Return the number of elements in the set\n-        fn len(&const self) -> uint { self.map.len() }\n+impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n+    fn eq(&self, other: &LinearSet<T>) -> bool { self.map == other.map }\n+    fn ne(&self, other: &LinearSet<T>) -> bool { self.map != other.map }\n+}\n \n-        /// Return true if the set contains no elements\n-        fn is_empty(&const self) -> bool { self.map.is_empty() }\n-    }\n+impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n+    /// Return the number of elements in the set\n+    fn len(&const self) -> uint { self.map.len() }\n \n-    impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n-        /// Clear the set, removing all values.\n-        fn clear(&mut self) { self.map.clear() }\n-    }\n+    /// Return true if the set contains no elements\n+    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+}\n \n-    impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n-        /// Return true if the set contains a value\n-        fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n+    /// Clear the set, removing all values.\n+    fn clear(&mut self) { self.map.clear() }\n+}\n \n-        /// Add a value to the set. Return true if the value was not already\n-        /// present in the set.\n-        fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n+    /// Return true if the set contains a value\n+    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n-        /// Remove a value from the set. Return true if the value was\n-        /// present in the set.\n-        fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n-        /// Return true if the set has no elements in common with `other`.\n-        /// This is equivalent to checking for an empty intersection.\n-        fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n-            iter::all(self, |v| !other.contains(v))\n-        }\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n-        /// Return true if the set is a subset of another\n-        fn is_subset(&self, other: &LinearSet<T>) -> bool {\n-            iter::all(self, |v| other.contains(v))\n-        }\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+        iter::all(self, |v| !other.contains(v))\n+    }\n \n-        /// Return true if the set is a superset of another\n-        fn is_superset(&self, other: &LinearSet<T>) -> bool {\n-            other.is_subset(self)\n-        }\n+    /// Return true if the set is a subset of another\n+    fn is_subset(&self, other: &LinearSet<T>) -> bool {\n+        iter::all(self, |v| other.contains(v))\n+    }\n \n-        /// Visit the values representing the difference\n-        fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n-            for self.each |v| {\n-                if !other.contains(v) {\n-                    if !f(v) { return }\n-                }\n+    /// Return true if the set is a superset of another\n+    fn is_superset(&self, other: &LinearSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Visit the values representing the difference\n+    fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        for self.each |v| {\n+            if !other.contains(v) {\n+                if !f(v) { return }\n             }\n         }\n+    }\n \n-        /// Visit the values representing the symmetric difference\n-        fn symmetric_difference(&self,\n-                                other: &LinearSet<T>,\n-                                f: &fn(&T) -> bool) {\n-            self.difference(other, f);\n-            other.difference(self, f);\n-        }\n+    /// Visit the values representing the symmetric difference\n+    fn symmetric_difference(&self,\n+                            other: &LinearSet<T>,\n+                            f: &fn(&T) -> bool) {\n+        self.difference(other, f);\n+        other.difference(self, f);\n+    }\n \n-        /// Visit the values representing the intersection\n-        fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n-            for self.each |v| {\n-                if other.contains(v) {\n-                    if !f(v) { return }\n-                }\n+    /// Visit the values representing the intersection\n+    fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        for self.each |v| {\n+            if other.contains(v) {\n+                if !f(v) { return }\n             }\n         }\n+    }\n \n-        /// Visit the values representing the union\n-        fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n-            for self.each |v| {\n-                if !f(v) { return }\n-            }\n+    /// Visit the values representing the union\n+    fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        for self.each |v| {\n+            if !f(v) { return }\n+        }\n \n-            for other.each |v| {\n-                if !self.contains(v) {\n-                    if !f(v) { return }\n-                }\n+        for other.each |v| {\n+            if !self.contains(v) {\n+                if !f(v) { return }\n             }\n         }\n     }\n+}\n \n-    pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n-        /// Create an empty LinearSet\n-        fn new() -> LinearSet<T> {\n-            LinearSet::with_capacity(INITIAL_CAPACITY)\n-        }\n+pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n+    /// Create an empty LinearSet\n+    fn new() -> LinearSet<T> {\n+        LinearSet::with_capacity(INITIAL_CAPACITY)\n+    }\n \n-        /// Create an empty LinearSet with space for at least `n` elements in\n-        /// the hash table.\n-        fn with_capacity(capacity: uint) -> LinearSet<T> {\n-            LinearSet { map: LinearMap::with_capacity(capacity) }\n-        }\n+    /// Create an empty LinearSet with space for at least `n` elements in\n+    /// the hash table.\n+    fn with_capacity(capacity: uint) -> LinearSet<T> {\n+        LinearSet { map: LinearMap::with_capacity(capacity) }\n+    }\n \n-        /// Reserve space for at least `n` elements in the hash table.\n-        fn reserve_at_least(&mut self, n: uint) {\n-            self.map.reserve_at_least(n)\n-        }\n+    /// Reserve space for at least `n` elements in the hash table.\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.map.reserve_at_least(n)\n+    }\n \n-        /// Consumes all of the elements in the set, emptying it out\n-        fn consume(&mut self, f: &fn(T)) {\n-            self.map.consume(|k, _| f(k))\n-        }\n+    /// Consumes all of the elements in the set, emptying it out\n+    fn consume(&mut self, f: &fn(T)) {\n+        self.map.consume(|k, _| f(k))\n     }\n+}\n+\n+#[test]\n+mod test_map {\n+    use container::{Container, Map, Set};\n+    use option::{None, Some};\n+    use super::*;\n+    use uint;\n \n     #[test]\n-    mod test_map {\n-        use container::{Container, Map, Set};\n-        use option::{None, Some};\n-        use hashmap::linear::LinearMap;\n-        use hashmap::linear;\n-        use uint;\n-\n-        #[test]\n-        pub fn test_insert() {\n-            let mut m = LinearMap::new();\n-            assert!(m.insert(1, 2));\n-            assert!(m.insert(2, 4));\n-            assert!(*m.get(&1) == 2);\n-            assert!(*m.get(&2) == 4);\n-        }\n+    pub fn test_insert() {\n+        let mut m = LinearMap::new();\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(2, 4));\n+        assert!(*m.get(&1) == 2);\n+        assert!(*m.get(&2) == 4);\n+    }\n \n-        #[test]\n-        fn test_find_mut() {\n-            let mut m = LinearMap::new();\n-            assert!(m.insert(1, 12));\n-            assert!(m.insert(2, 8));\n-            assert!(m.insert(5, 14));\n-            let new = 100;\n-            match m.find_mut(&5) {\n-                None => fail!(), Some(x) => *x = new\n-            }\n-            assert_eq!(m.find(&5), Some(&new));\n-        }\n+    #[test]\n+    fn test_find_mut() {\n+        let mut m = LinearMap::new();\n+        assert!(m.insert(1, 12));\n+        assert!(m.insert(2, 8));\n+        assert!(m.insert(5, 14));\n+        let new = 100;\n+        match m.find_mut(&5) {\n+            None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find(&5), Some(&new));\n+    }\n \n-        #[test]\n-        pub fn test_insert_overwrite() {\n-            let mut m = LinearMap::new();\n-            assert!(m.insert(1, 2));\n-            assert!(*m.get(&1) == 2);\n-            assert!(!m.insert(1, 3));\n-            assert!(*m.get(&1) == 3);\n-        }\n+    #[test]\n+    pub fn test_insert_overwrite() {\n+        let mut m = LinearMap::new();\n+        assert!(m.insert(1, 2));\n+        assert!(*m.get(&1) == 2);\n+        assert!(!m.insert(1, 3));\n+        assert!(*m.get(&1) == 3);\n+    }\n \n-        #[test]\n-        pub fn test_insert_conflicts() {\n-            let mut m = linear::linear_map_with_capacity(4);\n-            assert!(m.insert(1, 2));\n-            assert!(m.insert(5, 3));\n-            assert!(m.insert(9, 4));\n-            assert!(*m.get(&9) == 4);\n-            assert!(*m.get(&5) == 3);\n-            assert!(*m.get(&1) == 2);\n-        }\n+    #[test]\n+    pub fn test_insert_conflicts() {\n+        let mut m = linear_map_with_capacity(4);\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(5, 3));\n+        assert!(m.insert(9, 4));\n+        assert!(*m.get(&9) == 4);\n+        assert!(*m.get(&5) == 3);\n+        assert!(*m.get(&1) == 2);\n+    }\n \n-        #[test]\n-        pub fn test_conflict_remove() {\n-            let mut m = linear::linear_map_with_capacity(4);\n-            assert!(m.insert(1, 2));\n-            assert!(m.insert(5, 3));\n-            assert!(m.insert(9, 4));\n-            assert!(m.remove(&1));\n-            assert!(*m.get(&9) == 4);\n-            assert!(*m.get(&5) == 3);\n-        }\n+    #[test]\n+    pub fn test_conflict_remove() {\n+        let mut m = linear_map_with_capacity(4);\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(5, 3));\n+        assert!(m.insert(9, 4));\n+        assert!(m.remove(&1));\n+        assert!(*m.get(&9) == 4);\n+        assert!(*m.get(&5) == 3);\n+    }\n \n-        #[test]\n-        pub fn test_is_empty() {\n-            let mut m = linear::linear_map_with_capacity(4);\n-            assert!(m.insert(1, 2));\n-            assert!(!m.is_empty());\n-            assert!(m.remove(&1));\n-            assert!(m.is_empty());\n-        }\n+    #[test]\n+    pub fn test_is_empty() {\n+        let mut m = linear_map_with_capacity(4);\n+        assert!(m.insert(1, 2));\n+        assert!(!m.is_empty());\n+        assert!(m.remove(&1));\n+        assert!(m.is_empty());\n+    }\n \n-        #[test]\n-        pub fn test_pop() {\n-            let mut m = LinearMap::new();\n-            m.insert(1, 2);\n-            assert!(m.pop(&1) == Some(2));\n-            assert!(m.pop(&1) == None);\n-        }\n+    #[test]\n+    pub fn test_pop() {\n+        let mut m = LinearMap::new();\n+        m.insert(1, 2);\n+        assert!(m.pop(&1) == Some(2));\n+        assert!(m.pop(&1) == None);\n+    }\n \n-        #[test]\n-        pub fn test_swap() {\n-            let mut m = LinearMap::new();\n-            assert!(m.swap(1, 2) == None);\n-            assert!(m.swap(1, 3) == Some(2));\n-            assert!(m.swap(1, 4) == Some(3));\n-        }\n+    #[test]\n+    pub fn test_swap() {\n+        let mut m = LinearMap::new();\n+        assert!(m.swap(1, 2) == None);\n+        assert!(m.swap(1, 3) == Some(2));\n+        assert!(m.swap(1, 4) == Some(3));\n+    }\n \n-        #[test]\n-        pub fn test_find_or_insert() {\n-            let mut m = LinearMap::new::<int, int>();\n-            assert!(m.find_or_insert(1, 2) == &2);\n-            assert!(m.find_or_insert(1, 3) == &2);\n-        }\n+    #[test]\n+    pub fn test_find_or_insert() {\n+        let mut m = LinearMap::new::<int, int>();\n+        assert!(m.find_or_insert(1, 2) == &2);\n+        assert!(m.find_or_insert(1, 3) == &2);\n+    }\n \n-        #[test]\n-        pub fn test_find_or_insert_with() {\n-            let mut m = LinearMap::new::<int, int>();\n-            assert!(m.find_or_insert_with(1, |_| 2) == &2);\n-            assert!(m.find_or_insert_with(1, |_| 3) == &2);\n-        }\n+    #[test]\n+    pub fn test_find_or_insert_with() {\n+        let mut m = LinearMap::new::<int, int>();\n+        assert!(m.find_or_insert_with(1, |_| 2) == &2);\n+        assert!(m.find_or_insert_with(1, |_| 3) == &2);\n+    }\n \n-        #[test]\n-        pub fn test_consume() {\n-            let mut m = LinearMap::new();\n-            assert!(m.insert(1, 2));\n-            assert!(m.insert(2, 3));\n-            let mut m2 = LinearMap::new();\n-            do m.consume |k, v| {\n-                m2.insert(k, v);\n-            }\n-            assert!(m.len() == 0);\n-            assert!(m2.len() == 2);\n-            assert!(m2.get(&1) == &2);\n-            assert!(m2.get(&2) == &3);\n-        }\n+    #[test]\n+    pub fn test_consume() {\n+        let mut m = LinearMap::new();\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(2, 3));\n+        let mut m2 = LinearMap::new();\n+        do m.consume |k, v| {\n+            m2.insert(k, v);\n+        }\n+        assert!(m.len() == 0);\n+        assert!(m2.len() == 2);\n+        assert!(m2.get(&1) == &2);\n+        assert!(m2.get(&2) == &3);\n+    }\n \n-        #[test]\n-        pub fn test_iterate() {\n-            let mut m = linear::linear_map_with_capacity(4);\n-            for uint::range(0, 32) |i| {\n-                assert!(m.insert(i, i*2));\n-            }\n-            let mut observed = 0;\n-            for m.each |&(k, v)| {\n-                assert!(*v == *k * 2);\n-                observed |= (1 << *k);\n-            }\n-            assert!(observed == 0xFFFF_FFFF);\n+    #[test]\n+    pub fn test_iterate() {\n+        let mut m = linear_map_with_capacity(4);\n+        for uint::range(0, 32) |i| {\n+            assert!(m.insert(i, i*2));\n         }\n-\n-        #[test]\n-        pub fn test_find() {\n-            let mut m = LinearMap::new();\n-            assert!(m.find(&1).is_none());\n-            m.insert(1, 2);\n-            match m.find(&1) {\n-                None => fail!(),\n-                Some(v) => assert!(*v == 2)\n-            }\n+        let mut observed = 0;\n+        for m.each |&(k, v)| {\n+            assert!(*v == *k * 2);\n+            observed |= (1 << *k);\n         }\n+        assert!(observed == 0xFFFF_FFFF);\n+    }\n \n-        #[test]\n-        pub fn test_eq() {\n-            let mut m1 = LinearMap::new();\n-            m1.insert(1, 2);\n-            m1.insert(2, 3);\n-            m1.insert(3, 4);\n+    #[test]\n+    pub fn test_find() {\n+        let mut m = LinearMap::new();\n+        assert!(m.find(&1).is_none());\n+        m.insert(1, 2);\n+        match m.find(&1) {\n+            None => fail!(),\n+            Some(v) => assert!(*v == 2)\n+        }\n+    }\n \n-            let mut m2 = LinearMap::new();\n-            m2.insert(1, 2);\n-            m2.insert(2, 3);\n+    #[test]\n+    pub fn test_eq() {\n+        let mut m1 = LinearMap::new();\n+        m1.insert(1, 2);\n+        m1.insert(2, 3);\n+        m1.insert(3, 4);\n \n-            assert!(m1 != m2);\n+        let mut m2 = LinearMap::new();\n+        m2.insert(1, 2);\n+        m2.insert(2, 3);\n \n-            m2.insert(3, 4);\n+        assert!(m1 != m2);\n \n-            assert!(m1 == m2);\n-        }\n+        m2.insert(3, 4);\n \n-        #[test]\n-        pub fn test_expand() {\n-            let mut m = LinearMap::new();\n+        assert!(m1 == m2);\n+    }\n \n-            assert!(m.len() == 0);\n-            assert!(m.is_empty());\n+    #[test]\n+    pub fn test_expand() {\n+        let mut m = LinearMap::new();\n \n-            let mut i = 0u;\n-            let old_resize_at = m.resize_at;\n-            while old_resize_at == m.resize_at {\n-                m.insert(i, i);\n-                i += 1;\n-            }\n+        assert!(m.len() == 0);\n+        assert!(m.is_empty());\n \n-            assert!(m.len() == i);\n-            assert!(!m.is_empty());\n+        let mut i = 0u;\n+        let old_resize_at = m.resize_at;\n+        while old_resize_at == m.resize_at {\n+            m.insert(i, i);\n+            i += 1;\n         }\n+\n+        assert!(m.len() == i);\n+        assert!(!m.is_empty());\n     }\n+}\n \n #[test]\n-    mod test_set {\n-        use hashmap::linear;\n-        use container::{Container, Map, Set};\n-        use vec;\n-\n-        #[test]\n-        fn test_disjoint() {\n-            let mut xs = linear::LinearSet::new();\n-            let mut ys = linear::LinearSet::new();\n-            assert!(xs.is_disjoint(&ys));\n-            assert!(ys.is_disjoint(&xs));\n-            assert!(xs.insert(5));\n-            assert!(ys.insert(11));\n-            assert!(xs.is_disjoint(&ys));\n-            assert!(ys.is_disjoint(&xs));\n-            assert!(xs.insert(7));\n-            assert!(xs.insert(19));\n-            assert!(xs.insert(4));\n-            assert!(ys.insert(2));\n-            assert!(ys.insert(-11));\n-            assert!(xs.is_disjoint(&ys));\n-            assert!(ys.is_disjoint(&xs));\n-            assert!(ys.insert(7));\n-            assert!(!xs.is_disjoint(&ys));\n-            assert!(!ys.is_disjoint(&xs));\n-        }\n+mod test_set {\n+    use super::*;\n+    use container::{Container, Map, Set};\n+    use vec;\n \n-        #[test]\n-        fn test_subset_and_superset() {\n-            let mut a = linear::LinearSet::new();\n-            assert!(a.insert(0));\n-            assert!(a.insert(5));\n-            assert!(a.insert(11));\n-            assert!(a.insert(7));\n-\n-            let mut b = linear::LinearSet::new();\n-            assert!(b.insert(0));\n-            assert!(b.insert(7));\n-            assert!(b.insert(19));\n-            assert!(b.insert(250));\n-            assert!(b.insert(11));\n-            assert!(b.insert(200));\n-\n-            assert!(!a.is_subset(&b));\n-            assert!(!a.is_superset(&b));\n-            assert!(!b.is_subset(&a));\n-            assert!(!b.is_superset(&a));\n-\n-            assert!(b.insert(5));\n-\n-            assert!(a.is_subset(&b));\n-            assert!(!a.is_superset(&b));\n-            assert!(!b.is_subset(&a));\n-            assert!(b.is_superset(&a));\n-        }\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = LinearSet::new();\n+        let mut ys = LinearSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5));\n+        assert!(ys.insert(11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n \n-        #[test]\n-        fn test_intersection() {\n-            let mut a = linear::LinearSet::new();\n-            let mut b = linear::LinearSet::new();\n-\n-            assert!(a.insert(11));\n-            assert!(a.insert(1));\n-            assert!(a.insert(3));\n-            assert!(a.insert(77));\n-            assert!(a.insert(103));\n-            assert!(a.insert(5));\n-            assert!(a.insert(-5));\n-\n-            assert!(b.insert(2));\n-            assert!(b.insert(11));\n-            assert!(b.insert(77));\n-            assert!(b.insert(-9));\n-            assert!(b.insert(-42));\n-            assert!(b.insert(5));\n-            assert!(b.insert(3));\n-\n-            let mut i = 0;\n-            let expected = [3, 5, 11, 77];\n-            for a.intersection(&b) |x| {\n-                assert!(vec::contains(expected, x));\n-                i += 1\n-            }\n-            assert!(i == expected.len());\n-        }\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = LinearSet::new();\n+        assert!(a.insert(0));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = LinearSet::new();\n+        assert!(b.insert(0));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n \n-        #[test]\n-        fn test_difference() {\n-            let mut a = linear::LinearSet::new();\n-            let mut b = linear::LinearSet::new();\n-\n-            assert!(a.insert(1));\n-            assert!(a.insert(3));\n-            assert!(a.insert(5));\n-            assert!(a.insert(9));\n-            assert!(a.insert(11));\n-\n-            assert!(b.insert(3));\n-            assert!(b.insert(9));\n-\n-            let mut i = 0;\n-            let expected = [1, 5, 11];\n-            for a.difference(&b) |x| {\n-                assert!(vec::contains(expected, x));\n-                i += 1\n-            }\n-            assert!(i == expected.len());\n-        }\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = LinearSet::new();\n+        let mut b = LinearSet::new();\n+\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n+        assert!(a.insert(-5));\n+\n+        assert!(b.insert(2));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(-9));\n+        assert!(b.insert(-42));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert!(i == expected.len());\n+    }\n \n-        #[test]\n-        fn test_symmetric_difference() {\n-            let mut a = linear::LinearSet::new();\n-            let mut b = linear::LinearSet::new();\n-\n-            assert!(a.insert(1));\n-            assert!(a.insert(3));\n-            assert!(a.insert(5));\n-            assert!(a.insert(9));\n-            assert!(a.insert(11));\n-\n-            assert!(b.insert(-2));\n-            assert!(b.insert(3));\n-            assert!(b.insert(9));\n-            assert!(b.insert(14));\n-            assert!(b.insert(22));\n-\n-            let mut i = 0;\n-            let expected = [-2, 1, 5, 11, 14, 22];\n-            for a.symmetric_difference(&b) |x| {\n-                assert!(vec::contains(expected, x));\n-                i += 1\n-            }\n-            assert!(i == expected.len());\n-        }\n+    #[test]\n+    fn test_difference() {\n+        let mut a = LinearSet::new();\n+        let mut b = LinearSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11];\n+        for a.difference(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert!(i == expected.len());\n+    }\n \n-        #[test]\n-        fn test_union() {\n-            let mut a = linear::LinearSet::new();\n-            let mut b = linear::LinearSet::new();\n-\n-            assert!(a.insert(1));\n-            assert!(a.insert(3));\n-            assert!(a.insert(5));\n-            assert!(a.insert(9));\n-            assert!(a.insert(11));\n-            assert!(a.insert(16));\n-            assert!(a.insert(19));\n-            assert!(a.insert(24));\n-\n-            assert!(b.insert(-2));\n-            assert!(b.insert(1));\n-            assert!(b.insert(5));\n-            assert!(b.insert(9));\n-            assert!(b.insert(13));\n-            assert!(b.insert(19));\n-\n-            let mut i = 0;\n-            let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-            for a.union(&b) |x| {\n-                assert!(vec::contains(expected, x));\n-                i += 1\n-            }\n-            assert!(i == expected.len());\n-        }\n+    #[test]\n+    fn test_symmetric_difference() {\n+        let mut a = LinearSet::new();\n+        let mut b = LinearSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(-2));\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+        assert!(b.insert(14));\n+        assert!(b.insert(22));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 5, 11, 14, 22];\n+        for a.symmetric_difference(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert!(i == expected.len());\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        let mut a = LinearSet::new();\n+        let mut b = LinearSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+        assert!(a.insert(16));\n+        assert!(a.insert(19));\n+        assert!(a.insert(24));\n+\n+        assert!(b.insert(-2));\n+        assert!(b.insert(1));\n+        assert!(b.insert(5));\n+        assert!(b.insert(9));\n+        assert!(b.insert(13));\n+        assert!(b.insert(19));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+        for a.union(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert!(i == expected.len());\n     }\n }"}, {"sha": "ac6775eb81fecb63d1960e7ecb9ec5710daa9b34", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -79,7 +79,7 @@ use comm::{Chan, GenericChan};\n use prelude::*;\n use unstable;\n use ptr;\n-use hashmap::linear::LinearSet;\n+use hashmap::LinearSet;\n use task::local_data_priv::{local_get, local_set};\n use task::rt::rust_task;\n use task::rt;"}, {"sha": "3187012e2a983ce3a1c9be956968217f26ea3ec0", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -34,7 +34,7 @@ use ops::Drop;\n use unstable::{Exclusive, exclusive};\n use unstable::at_exit::at_exit;\n use unstable::intrinsics::atomic_cxchg;\n-use hashmap::linear::LinearMap;\n+use hashmap::LinearMap;\n use sys::Closure;\n \n #[cfg(test)] use unstable::{SharedMutableState, shared_mutable_state};"}, {"sha": "5556792c2254370ba115ba1bee4bf73716a36495", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -21,7 +21,7 @@ is trying to shut down.\n use cell::Cell;\n use comm::{GenericSmartChan, stream};\n use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n-use hashmap::linear::LinearMap;\n+use hashmap::LinearMap;\n use option::{Some, None};\n use unstable::at_exit::at_exit;\n use unstable::finally::Finally;"}, {"sha": "89d1eb53c82016f078775946829ac5ea76f8f1bc", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use core::os;\n use core::uint;\n use core::util;\n use core::vec;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n \n fn not_win32(os: session::os) -> bool {\n   match os {"}, {"sha": "c50eecd448976b3a833c94f1e2a1241646d33446", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::libc::c_uint;\n use core::option;\n use core::ptr;"}, {"sha": "eb01964f6d692fb7080702cc718a62b946dd9c0e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};"}, {"sha": "13447d09736e4882c3da4ce239591ea4aca1ce72", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use metadata::cstore;\n use metadata::decoder;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::vec;\n use std;\n use syntax::ast;"}, {"sha": "b7ad62ee4ed2ca137643653a061df5413aea57ac", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -25,7 +25,7 @@ use util::ppaux::ty_to_str;\n \n use core::flate;\n use core::hash::HashUtil;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::int;\n use core::io::{Writer, WriterUtil};\n use core::io;"}, {"sha": "05f5f302f53798bbf9e70bd6040cbbcfeecac13a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -16,7 +16,7 @@ use core::prelude::*;\n use middle::ty::param_ty;\n use middle::ty;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::io::WriterUtil;\n use core::io;\n use core::uint;"}, {"sha": "2bf89903e1c8b824cf51c73238d31bae36d8acc2", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -31,7 +31,7 @@ use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use core::uint;\n use syntax::ast::m_mutbl;\n use syntax::ast;"}, {"sha": "2965921b05a81fa58a5f512c57a814bfa73c2830", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -31,7 +31,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n-use core::hashmap::linear::{LinearSet, LinearMap};\n+use core::hashmap::{LinearSet, LinearMap};\n use core::vec;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;"}, {"sha": "ca3365bbcabc4d6f3afcd4c4ca9d398095705ff3", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -234,7 +234,7 @@ use middle::moves;\n use util::common::stmt_set;\n use util::ppaux::note_and_explain_region;\n \n-use core::hashmap::linear::{LinearSet, LinearMap};\n+use core::hashmap::{LinearSet, LinearMap};\n use core::io;\n use core::result::{Result, Ok, Err};\n use core::to_bytes;"}, {"sha": "788d8f6de89cde589f1b0281847c424635cd6ae6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -20,7 +20,7 @@ use core::vec;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "d680d1547351a65eb5efd1a10ff93e2dfe87bc67", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use middle::resolve;\n use middle::ty;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use syntax::codemap::span;\n use syntax::{ast, ast_util, visit};\n "}, {"sha": "7c399bf2ece687854561fb79eb0483b034cb0c73", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -31,7 +31,7 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::ptr;\n \n pub enum LangItem {"}, {"sha": "d4cd500f04c48fd3efecfc9936c1b942188582ff", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -15,7 +15,7 @@ use driver::session;\n use middle::ty;\n use util::ppaux::{ty_to_str};\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::char;\n use core::cmp;\n use core::i8;"}, {"sha": "a91404fb47a2a533fae6c49d97751b16695179be", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -111,7 +111,7 @@ use middle::typeck;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::io::WriterUtil;\n use core::io;\n use core::ptr;"}, {"sha": "de52d3e6878e902478388f6645fd13eb710c0b29", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -215,7 +215,7 @@ use middle::typeck::method_map;\n use util::ppaux;\n use util::common::indenter;\n \n-use core::hashmap::linear::{LinearSet, LinearMap};\n+use core::hashmap::{LinearSet, LinearMap};\n use core::vec;\n use syntax::ast::*;\n use syntax::ast_util;"}, {"sha": "db3f5acf9d590d4bb3b6935688b6c0ad294b04aa", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use middle::resolve;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::span;"}, {"sha": "e6e1990717254c88411c6c198c08cc8e33afd1c1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -26,7 +26,7 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant};\n use middle::ty;\n \n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::vec;\n use syntax::ast_map;\n use syntax::codemap::span;"}, {"sha": "c4a6584dd66a366d6657a954f43a2b6ad35c9c8a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -77,7 +77,7 @@ use syntax::opt_vec::OptVec;\n \n use core::option::Some;\n use core::str::each_split_str;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n \n // Definition mapping\n pub type DefMap = @mut LinearMap<node_id,def>;"}, {"sha": "1b5273dd3d7d3a153c58438a2bd4b08168871f60", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -167,7 +167,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;"}, {"sha": "588690b055444e378f1e55f23313067dc800b160", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -67,7 +67,7 @@ use util::ppaux::ty_to_str;\n use util::ppaux;\n \n use core::hash;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};"}, {"sha": "234812e66d9db1cd68d22a6dd92fd6393a23a87a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::span;\n \n use core::prelude::*;\n use core::cast;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::libc::{c_uint, c_ulonglong, c_char};\n use core::libc;\n use core::option::Some;"}, {"sha": "04aca7b9dcdc43d65da91bd1b03bc4a754502130", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -45,7 +45,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;"}, {"sha": "69a70c5a2fd51cabd7699b6e923f2e0f6772925e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -20,7 +20,7 @@ use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::libc;\n use core::option;\n use core::sys;"}, {"sha": "616a25d3c164f11a3382256749f98887b2002ef2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -153,7 +153,7 @@ use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use core::cast::transmute;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n use syntax::codemap;"}, {"sha": "fd0eb9667098bad047be5351a30dbb5c526e6d83", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use middle::typeck;\n \n use core::prelude::*;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::def_id_of_def;"}, {"sha": "2b00bd0c71246d0be5cca69c04481d1c1aacdc8c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -36,7 +36,7 @@ use core::result;\n use core::to_bytes;\n use core::uint;\n use core::vec;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use std::smallintmap::SmallIntMap;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};"}, {"sha": "dd1dcbe67b94a892249095e9891d0ca808dbb2b2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n \n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::vec;\n use syntax::ast;\n use syntax::ast_util;"}, {"sha": "8f7e8478f8adb03d90c87e4862798429a44b30b6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -95,7 +95,7 @@ use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use core::result;\n use core::uint;\n use core::vec;"}, {"sha": "1c144b294d219d1f9da92dc6145f2df3d2aecb48", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -110,7 +110,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{bound_region_to_str, expr_repr, pat_repr};\n use util::ppaux;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::ptr;\n use core::result::{Result, Ok, Err};\n use core::result;"}, {"sha": "ddce274c5420758c5734d4620cd549de19c3f052", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -28,7 +28,7 @@ use core::result::{Ok, Err};\n use core::result;\n use core::uint;\n use core::vec;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;"}, {"sha": "9f4984e02a603c28e80c51f65b8c63e6cd72ed45", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -53,7 +53,7 @@ use syntax::visit::{visit_mod};\n use util::ppaux::ty_to_str;\n \n use core::result::Ok;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::uint;\n \n pub struct UniversalQuantificationResult {"}, {"sha": "b190a98f8cd0833e644f1b8afc8b65ec3fb8a04a", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -548,7 +548,7 @@ use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::result::{Err, Ok};\n use core::to_bytes;\n use core::uint;"}, {"sha": "1a0a1fceb52a87bda6c421f3d3b32182c6a28bc7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -55,7 +55,7 @@ use middle::ty;\n use util::common::time;\n use util::ppaux;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::result;\n use core::vec;\n use std::list::List;"}, {"sha": "98eff8b50d14d3ce61648c60ca4b695670b286d0", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::codemap::{span};\n use syntax::visit;\n \n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use core::str;\n use std;\n "}, {"sha": "2f1d25425ec2b7fcd791361fce23d6e7d8f47f6a", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -28,7 +28,7 @@ extern mod syntax(vers = \"0.6\");\n \n use core::*;\n use core::container::Map;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::io::WriterUtil;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;"}, {"sha": "15546e96653d84742ecb977c5fce949b1b6e9b92", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -10,7 +10,7 @@\n \n use core::*;\n use core::hash::Streaming;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;"}, {"sha": "1b79708e5901790a5033d127fd31530f7f41f08d", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -16,7 +16,7 @@\n \n use core::prelude::*;\n use core::io::{WriterUtil, ReaderUtil};\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n use serialize::Encodable;\n use serialize;\n@@ -1161,7 +1161,7 @@ mod tests {\n     use super::*;\n \n     use core::prelude::*;\n-    use core::hashmap::linear::LinearMap;\n+    use core::hashmap::LinearMap;\n \n     use std::serialize::Decodable;\n "}, {"sha": "b32a9841ac6c14581f607005a29e25e5545215eb", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -17,7 +17,7 @@ use core::from_str::FromStr;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::str;\n use core::to_bytes::IterBytes;\n use core::to_bytes;\n@@ -818,7 +818,7 @@ mod tests {\n \n     use net_url::*;\n \n-    use core::hashmap::linear::LinearMap;\n+    use core::hashmap::LinearMap;\n \n     #[test]\n     pub fn test_url_parse() {"}, {"sha": "88ae58ee01b4c6393b6b0d4fdec5dd6b5874ac3c", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -17,7 +17,7 @@ Core encoding and decoding interfaces.\n #[forbid(non_camel_case_types)];\n \n use core::prelude::*;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::trie::{TrieMap, TrieSet};\n use deque::Deque;\n use dlist::DList;"}, {"sha": "6886d5d630e19a241698209cdc9ab0f90c147c93", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -24,7 +24,7 @@ use core::pipes::recv;\n use core::prelude::*;\n use core::result;\n use core::run;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::task;\n use core::to_bytes;\n "}, {"sha": "04d7cbdca0c3d2695bd2a269a405b4f4b7664ccd", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -23,7 +23,7 @@ use print::pprust;\n use visit;\n \n use core::cmp;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::str;\n use core::vec;\n "}, {"sha": "71e2faa93f569c8a322f780f980dd5c320ee4004", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -20,7 +20,7 @@ use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n use core::vec;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use std;\n \n /* Constructors */"}, {"sha": "cae56267f5eb3400b16b0fae5d47646c86c015ea", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -20,7 +20,7 @@ use parse;\n use parse::token;\n \n use core::vec;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n // new-style macro! tt code:\n //\n@@ -509,7 +509,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n #[cfg(test)]\n mod test {\n     use super::MapChain;\n-    use core::hashmap::linear::LinearMap;\n+    use core::hashmap::LinearMap;\n \n     #[test] fn testenv () {\n         let mut a = LinearMap::new();"}, {"sha": "fcb0c76a2c78a1306cd07bb2fac1a48bfe765846", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -20,7 +20,7 @@ use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::token;\n \n use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n only by calling out to the main rust parser for named nonterminals (which it"}, {"sha": "de0b4c0799fbab22359aafd52c09ee2b960662b6", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n use parse::lexer::TokenAndSpan;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::option;\n use core::vec;\n "}, {"sha": "1b845ad1dd9d4a1c0838404c87e08bac34cd3f1d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -94,7 +94,7 @@ use opt_vec::OptVec;\n \n use core::either::Either;\n use core::either;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use core::vec;\n \n #[deriving(Eq)]"}, {"sha": "ff10b6070e66d35165d1925cb5392e9bb7a42998", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -18,7 +18,7 @@ use util::interner;\n \n use core::cast;\n use core::char;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use core::str;\n use core::task;\n "}, {"sha": "dd4044036ef847647911efdab800371862ff6d1a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -13,7 +13,7 @@\n // type, and vice versa.\n \n use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub struct Interner<T> {\n     priv map: @mut LinearMap<T, uint>,"}, {"sha": "eded285eef11780c61128474261cda25787e086e", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -13,7 +13,7 @@\n \n extern mod std;\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub type header_map = LinearMap<~str, @mut ~[@~str]>;\n "}, {"sha": "c30c38e92f72447a49eea32ea18fce7490ac6a6d", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -13,7 +13,7 @@ extern mod std;\n use core::io;\n use std::time;\n use std::treemap::TreeMap;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::trie::TrieMap;\n \n fn timed(label: &str, f: &fn()) {"}, {"sha": "2fcd82eefe61ba3d3100f7a88bcb626d860b81e4", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern mod std;\n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n use std::bitv::BitvSet;\n use std::treemap::TreeSet;\n use core::io::WriterUtil;"}, {"sha": "397c08228995c20f88f9bfb73b553002ca7b4adb", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -24,7 +24,7 @@ use std::arc;\n use std::time;\n use std::deque::Deque;\n use std::par;\n-use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::hashmap::{LinearMap, LinearSet};\n use core::io::WriterUtil;\n use core::int::abs;\n use core::rand::RngUtil;"}, {"sha": "f608c71000b298d03cc40ae7cf25ed252a1033e8", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -15,7 +15,7 @@\n \n extern mod std;\n use std::sort;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use core::io::ReaderUtil;\n use core::comm::{stream, Port, Chan};\n use core::cmp::Ord;"}, {"sha": "65d99858d1d3648ef66cae18b48eeeeca45b9926", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -25,7 +25,7 @@\n //  writes pbm image to output path\n \n use core::io::WriterUtil;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n struct cmplx {\n     re: f64,"}, {"sha": "b3cf314edd001b807cb604448346b4ca1f396e84", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -10,7 +10,7 @@\n \n //buggy.rs\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n fn main() {\n     let mut buggy_map :LinearMap<uint, &uint> ="}, {"sha": "1420a67556cad807040e606f7d725b3b33cbee98", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::LinearSet;\n \n struct Foo {\n   n: LinearSet<int>,"}, {"sha": "c7c1ea4821307c1c2688a4c78dfa274564f37e56", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -11,7 +11,7 @@\n // error-pattern: mismatched types\n extern mod std;\n use std::bitv;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n struct FnInfo {\n     vars: LinearMap<uint, VarInfo>"}, {"sha": "00efdbbf75acc0a3e93ae7c97267dca1224c1fa8", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::container::Map;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n // Test that trait types printed in error msgs include the type arguments.\n "}, {"sha": "5ec4beb364d89e2b09238f5c30709cc3dd703cef", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -14,7 +14,7 @@\n \n fn main() {\n     let count = @mut 0u;\n-    let mut map = core::hashmap::linear::LinearMap::new();\n+    let mut map = core::hashmap::LinearMap::new();\n     let mut arr = ~[];\n     for uint::range(0u, 10u) |i| {\n         arr += ~[@~\"key stuff\"];"}, {"sha": "415f753a562e2f974e3b3a4f56c3d40f5cd38384", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -19,7 +19,7 @@\n pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n-    use core::hashmap::linear::LinearMap;\n+    use core::hashmap::LinearMap;\n     use core::comm::*;\n \n     pub type putter = @fn(~str, ~str);"}, {"sha": "401920789c0983314354b3ec3573f48f5adfaea7", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -10,7 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub fn main() {\n     let mut m = LinearMap::new();"}, {"sha": "42452d3a2bb0fdcb49aa0be23082148af9782167", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -14,7 +14,7 @@\n extern mod req;\n \n use req::*;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub fn main() {\n   let v = ~[@~\"hi\"];"}, {"sha": "4f0930deaaef13c99e1b8298a205bf12f3f7d933", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -13,7 +13,7 @@\n // Minimized version of issue-2804.rs. Both check that callee IDs don't\n // clobber the previous node ID in a macro expr\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n fn add_interfaces(managed_ip: ~str, device: LinearMap<~str, int>)  {\n      error!(\"%s, %?\", managed_ip, device.get(&~\"interfaces\"));"}, {"sha": "a1c5f4a6757dc3f7a7013de2d3208f6578494bc7", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -11,7 +11,7 @@\n // except according to those terms.\n \n extern mod std;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n use std::json;\n \n enum object {"}, {"sha": "9665113bc0cee5338a78c466d63e5fa767c62d4a", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -10,7 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub fn main() {\n     let mut buggy_map: LinearMap<uint, &uint> = LinearMap::new::<uint, &uint>();"}, {"sha": "a73f130e88981fc2941114626382cd366d7c32c1", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -29,7 +29,7 @@ fn check_strs(actual: &str, expected: &str) -> bool\n #[test]\n fn tester()\n {\n-    let mut table = core::hashmap::linear::LinearMap();\n+    let mut table = core::hashmap::LinearMap();\n     table.insert(@~\"one\", 1);\n     table.insert(@~\"two\", 2);\n     assert!(check_strs(table.to_str(), ~\"xxx\"));   // not sure what expected should be"}, {"sha": "2384b0e8593938d977cab8dfd86cbe4fe55e4def", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n extern mod std;\n \n-use hashmap::linear;\n+use hashmap;\n use std::json;\n use std::serialization::{Deserializable, deserialize};\n "}, {"sha": "8cda78840b341d6c8221ae2f8af6a84dc045e239", "filename": "src/test/run-pass/issue-4092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4092.rs?ref=44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::LinearMap;\n \n pub fn main() {\n     let mut x = LinearMap::new();"}]}