{"sha": "600dc3552ffcdff014cc770e98a67b674496d10a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMGRjMzU1MmZmY2RmZjAxNGNjNzcwZTk4YTY3YjY3NDQ5NmQxMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-04T22:37:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-04T22:37:31Z"}, "message": "Auto merge of #32647 - Amanieu:checked_atomic_intrinsics, r=eddyb\n\nOnly allow using the atomic intrinsics on integer types\n\nUsing these with non-integer types results in LLVM asserts. Atomic operations on non-integer types will require values be transmuted into an integer type of suitable size.\n\nThis doesn't affect the standard library since `AtomicBool` and `AtomicPtr` currently use `usize` for atomic operations.\n\nr? @eddyb", "tree": {"sha": "d59689f8f02781e86102c22521bfb9fcd8950f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d59689f8f02781e86102c22521bfb9fcd8950f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/600dc3552ffcdff014cc770e98a67b674496d10a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/600dc3552ffcdff014cc770e98a67b674496d10a", "html_url": "https://github.com/rust-lang/rust/commit/600dc3552ffcdff014cc770e98a67b674496d10a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/600dc3552ffcdff014cc770e98a67b674496d10a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d5e8457609e0d3520e0586c4633c08280d9b95d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5e8457609e0d3520e0586c4633c08280d9b95d", "html_url": "https://github.com/rust-lang/rust/commit/8d5e8457609e0d3520e0586c4633c08280d9b95d"}, {"sha": "8620bbaafd8bffda3584b4e8534d38dcc09cc6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8620bbaafd8bffda3584b4e8534d38dcc09cc6b1", "html_url": "https://github.com/rust-lang/rust/commit/8620bbaafd8bffda3584b4e8534d38dcc09cc6b1"}], "stats": {"total": 192, "additions": 161, "deletions": 31}, "files": [{"sha": "28d5d9ac176ffc163f5f3f8da82cd3a139c3d3a0", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=600dc3552ffcdff014cc770e98a67b674496d10a", "patch": "@@ -752,33 +752,47 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let cmp = from_immediate(bcx, llargs[1]);\n-                    let src = from_immediate(bcx, llargs[2]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n-                    let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                    let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, weak);\n-                    let result = ExtractValue(bcx, val, 0);\n-                    let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n-                    Store(bcx,\n-                          result,\n-                          PointerCast(bcx, StructGEP(bcx, llresult, 0), val_ty(src).ptr_to()));\n-                    Store(bcx, success, StructGEP(bcx, llresult, 1));\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n+                        let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n+                                                order, failorder, weak);\n+                        let result = ExtractValue(bcx, val, 0);\n+                        let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n+                        Store(bcx, result, StructGEP(bcx, llresult, 0));\n+                        Store(bcx, success, StructGEP(bcx, llresult, 1));\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                    }\n                     C_nil(ccx)\n                 }\n \n                 \"load\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let mut ptr = llargs[0];\n-                    if let Some(ty) = fn_ty.ret.cast {\n-                        ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicLoad(bcx, llargs[0], order)\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                        C_nil(ccx)\n                     }\n-                    to_immediate(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n \n                 \"store\" => {\n-                    let val = from_immediate(bcx, llargs[1]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n-                    AtomicStore(bcx, val, ptr, order);\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicStore(bcx, llargs[1], llargs[0], order);\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                    }\n                     C_nil(ccx)\n                 }\n \n@@ -809,9 +823,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let val = from_immediate(bcx, llargs[1]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n-                    AtomicRMW(bcx, atom_op, ptr, val, order)\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                        C_nil(ccx)\n+                    }\n                 }\n             }\n "}, {"sha": "d2376eecd9b504295aaf90f81fc932187847c3eb", "filename": "src/test/compile-fail/non-interger-atomic.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs?ref=600dc3552ffcdff014cc770e98a67b674496d10a", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_intrinsics, rustc_attrs)]\n+#![allow(warnings)]\n+\n+use std::intrinsics;\n+\n+#[derive(Copy, Clone)]\n+struct Foo(i64);\n+type Bar = &'static Fn();\n+type Quux = [u8; 100];\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_load(p: &mut bool, v: bool) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_store(p: &mut bool, v: bool) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_xchg(p: &mut bool, v: bool) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_cxchg(p: &mut bool, v: bool) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_load(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_store(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_xchg(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_cxchg(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_load(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_store(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_xchg(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_cxchg(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_load(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_store(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_xchg(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_cxchg(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+fn main() {}"}, {"sha": "6e20662b702a94c254547bf231018e1938bae0ea", "filename": "src/test/run-pass/issue-23550.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600dc3552ffcdff014cc770e98a67b674496d10a/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23550.rs?ref=600dc3552ffcdff014cc770e98a67b674496d10a", "patch": "@@ -16,24 +16,16 @@ use std::intrinsics;\n #[derive(Copy, Clone)]\n struct Wrap(i64);\n \n-// These volatile and atomic intrinsics used to cause an ICE\n+// These volatile intrinsics used to cause an ICE\n \n unsafe fn test_bool(p: &mut bool, v: bool) {\n     intrinsics::volatile_load(p);\n     intrinsics::volatile_store(p, v);\n-    intrinsics::atomic_load(p);\n-    intrinsics::atomic_cxchg(p, v, v);\n-    intrinsics::atomic_store(p, v);\n-    intrinsics::atomic_xchg(p, v);\n }\n \n unsafe fn test_immediate_fca(p: &mut Wrap, v: Wrap) {\n     intrinsics::volatile_load(p);\n     intrinsics::volatile_store(p, v);\n-    intrinsics::atomic_load(p);\n-    intrinsics::atomic_cxchg(p, v, v);\n-    intrinsics::atomic_store(p, v);\n-    intrinsics::atomic_xchg(p, v);\n }\n \n fn main() {}"}]}