{"sha": "a86d3a7e45e6c4db749df018678ef587ace21933", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NmQzYTdlNDVlNmM0ZGI3NDlkZjAxODY3OGVmNTg3YWNlMjE5MzM=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-14T10:02:53Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-14T17:59:00Z"}, "message": "Refactor to make interpreter and codegen backend neutral to vtable internal representation.", "tree": {"sha": "6c7cd6bc34a3c66b00cb11a916bacb47bd957016", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c7cd6bc34a3c66b00cb11a916bacb47bd957016"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a86d3a7e45e6c4db749df018678ef587ace21933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a86d3a7e45e6c4db749df018678ef587ace21933", "html_url": "https://github.com/rust-lang/rust/commit/a86d3a7e45e6c4db749df018678ef587ace21933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a86d3a7e45e6c4db749df018678ef587ace21933/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14831568d506b5ee7be3e7d5a2f029ce9048b609", "url": "https://api.github.com/repos/rust-lang/rust/commits/14831568d506b5ee7be3e7d5a2f029ce9048b609", "html_url": "https://github.com/rust-lang/rust/commit/14831568d506b5ee7be3e7d5a2f029ce9048b609"}], "stats": {"total": 427, "additions": 248, "deletions": 179}, "files": [{"sha": "4d1ee47b41e170c910d0f91d80d34c6c12717ad4", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -4,10 +4,7 @@\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n-\n-const DROP_FN_INDEX: usize = 0;\n-const SIZE_INDEX: usize = 1;\n-const ALIGN_INDEX: usize = 2;\n+use ty::VtblEntry;\n \n fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n@@ -21,7 +18,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) ->\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (DROP_FN_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_DROPINPLACE * usize_size) as i32,\n     )\n }\n \n@@ -31,7 +28,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Val\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (SIZE_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32,\n     )\n }\n \n@@ -41,7 +38,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (ALIGN_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32,\n     )\n }\n \n@@ -62,7 +59,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        ((idx + 3) * usize_size as usize) as i32,\n+        (idx * usize_size as usize) as i32,\n     );\n     (ptr, func_ref)\n }\n@@ -98,42 +95,49 @@ fn build_vtable<'tcx>(\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n-    let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n-\n-    let methods_root;\n-    let methods = if let Some(trait_ref) = trait_ref {\n-        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, layout.ty));\n-        methods_root.iter()\n+    let vtable_entries = if let Some(trait_ref) = trait_ref {\n+        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))\n     } else {\n-        (&[]).iter()\n+        ty::COMMON_VTABLE_ENTRIES\n     };\n-    let methods = methods.cloned().map(|opt_mth| {\n-        opt_mth.map(|(def_id, substs)| {\n-            import_function(\n-                tcx,\n-                fx.module,\n-                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n-                    .unwrap()\n-                    .polymorphize(fx.tcx),\n-            )\n-        })\n-    });\n-    components.extend(methods);\n \n     let mut data_ctx = DataContext::new();\n     let mut data = ::std::iter::repeat(0u8)\n-        .take(components.len() * usize_size)\n+        .take(vtable_entries.len() * usize_size)\n         .collect::<Vec<u8>>()\n         .into_boxed_slice();\n \n-    write_usize(fx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n-    write_usize(fx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        match entry {\n+            VtblEntry::MetadataSize => {\n+                write_usize(fx.tcx, &mut data, idx, layout.size.bytes());\n+            }\n+            VtblEntry::MetadataAlign => {\n+                write_usize(fx.tcx, &mut data, idx, layout.align.abi.bytes());\n+            }\n+            VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) => {}\n+        }\n+    }\n     data_ctx.define(data);\n \n-    for (i, component) in components.into_iter().enumerate() {\n-        if let Some(func_id) = component {\n-            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n-            data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        match entry {\n+            VtblEntry::MetadataDropInPlace => {\n+                let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &mut data_ctx);\n+                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n+            }\n+            VtblEntry::Method(def_id, substs) => {\n+                let func_id = import_function(\n+                    tcx,\n+                    fx.module,\n+                    Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)\n+                        .unwrap()\n+                        .polymorphize(fx.tcx),\n+                );\n+                let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n+                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n+            }\n+            VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant => {}\n         }\n     }\n "}, {"sha": "cf217b52c86f483677baeb62ca470db22c61b405", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -23,7 +23,12 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n             let vtable = info.unwrap();\n-            (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n+            (\n+                meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_SIZE)\n+                    .get_usize(bx, vtable),\n+                meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_ALIGN)\n+                    .get_usize(bx, vtable),\n+            )\n         }\n         ty::Slice(_) | ty::Str => {\n             let unit = layout.field(bx, 0);"}, {"sha": "4f0de72970482f08fa0d130bb70074d20882fbfb", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -1,18 +1,14 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::{self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES};\n use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]\n pub struct VirtualIndex(u64);\n \n-pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n-pub const SIZE: VirtualIndex = VirtualIndex(1);\n-pub const ALIGN: VirtualIndex = VirtualIndex(2);\n-\n impl<'a, 'tcx> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n-        VirtualIndex(index as u64 + 3)\n+        VirtualIndex(index as u64)\n     }\n \n     pub fn get_fn<Bx: BuilderMethods<'a, 'tcx>>(\n@@ -77,43 +73,38 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     // Not in the cache; build it.\n     let nullptr = cx.const_null(cx.type_i8p_ext(cx.data_layout().instruction_address_space));\n \n-    let methods_root;\n-    let methods = if let Some(trait_ref) = trait_ref {\n-        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n-        methods_root.iter()\n+    let vtable_entries = if let Some(trait_ref) = trait_ref {\n+        tcx.vtable_entries(trait_ref.with_self_ty(tcx, ty))\n     } else {\n-        (&[]).iter()\n+        COMMON_VTABLE_ENTRIES\n     };\n \n-    let methods = methods.cloned().map(|opt_mth| {\n-        opt_mth.map_or(nullptr, |(def_id, substs)| {\n-            cx.get_fn_addr(\n+    let layout = cx.layout_of(ty);\n+    // /////////////////////////////////////////////////////////////////////////////////////////////\n+    // If you touch this code, be sure to also make the corresponding changes to\n+    // `get_vtable` in `rust_mir/interpret/traits.rs`.\n+    // /////////////////////////////////////////////////////////////////////////////////////////////\n+    let components: Vec<_> = vtable_entries\n+        .iter()\n+        .map(|entry| match entry {\n+            VtblEntry::MetadataDropInPlace => {\n+                cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty))\n+            }\n+            VtblEntry::MetadataSize => cx.const_usize(layout.size.bytes()),\n+            VtblEntry::MetadataAlign => cx.const_usize(layout.align.abi.bytes()),\n+            VtblEntry::Vacant => nullptr,\n+            VtblEntry::Method(def_id, substs) => cx.get_fn_addr(\n                 ty::Instance::resolve_for_vtable(\n                     cx.tcx(),\n                     ty::ParamEnv::reveal_all(),\n-                    def_id,\n+                    *def_id,\n                     substs,\n                 )\n                 .unwrap()\n                 .polymorphize(cx.tcx()),\n-            )\n+            ),\n         })\n-    });\n-\n-    let layout = cx.layout_of(ty);\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    // If you touch this code, be sure to also make the corresponding changes to\n-    // `get_vtable` in `rust_mir/interpret/traits.rs`.\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    let components: Vec<_> = [\n-        cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty)),\n-        cx.const_usize(layout.size.bytes()),\n-        cx.const_usize(layout.align.abi.bytes()),\n-    ]\n-    .iter()\n-    .cloned()\n-    .chain(methods)\n-    .collect();\n+        .collect();\n \n     let vtable_const = cx.const_struct(&components, false);\n     let align = cx.data_layout().pointer_align.abi;"}, {"sha": "2cb28d7361c33b6a56a0280629f0f359954df8c4", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -332,7 +332,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_abi = FnAbi::of_instance(&bx, virtual_drop, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n-                (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_abi), fn_abi)\n+                (\n+                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                        .get_fn(&mut bx, vtable, &fn_abi),\n+                    fn_abi,\n+                )\n             }\n             _ => (bx.get_fn_addr(drop_fn), FnAbi::of_instance(&bx, drop_fn, &[])),\n         };"}, {"sha": "a6f9a7c96f0a5045c81d4bc4c4f8bf61a19d63cd", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -959,9 +959,9 @@ rustc_queries! {\n         desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n     }\n \n-    query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n-                        -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-        desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n+    query vtable_entries(key: ty::PolyTraitRef<'tcx>)\n+                        -> &'tcx [ty::VtblEntry<'tcx>] {\n+        desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n     }\n \n     query codegen_fulfill_obligation("}, {"sha": "a2abbec74927c5706575d92b9ca1cfcdeef400c0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -2009,3 +2009,19 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+pub enum VtblEntry<'tcx> {\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Vacant,\n+    Method(DefId, SubstsRef<'tcx>),\n+}\n+\n+pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n+    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n+\n+pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n+pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n+pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;"}, {"sha": "072c252be2f30ca6d2e5aefcc12e3ebb68aeb53f", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -1,7 +1,10 @@\n use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n-use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::{\n+    self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n+    COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n+};\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n use super::util::ensure_monomorphic_enough;\n@@ -35,13 +38,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(vtable);\n         }\n \n-        let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n+        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n             let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n             let trait_ref = self.tcx.erase_regions(trait_ref);\n \n-            self.tcx.vtable_methods(trait_ref)\n+            self.tcx.vtable_entries(trait_ref)\n         } else {\n-            &[]\n+            COMMON_VTABLE_ENTRIES\n         };\n \n         let layout = self.layout_of(ty)?;\n@@ -56,38 +59,41 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n-        let vtable_size = ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap();\n+        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n         let vtable = self.memory.allocate(vtable_size, ptr_align, MemoryKind::Vtable);\n \n         let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n-        // Prepare the fn ptrs we will write into the vtable later.\n-        let fn_ptrs = methods\n-            .iter()\n-            .enumerate() // remember the original position\n-            .filter_map(|(i, method)| {\n-                if let Some((def_id, substs)) = method { Some((i, def_id, substs)) } else { None }\n-            })\n-            .map(|(i, def_id, substs)| {\n-                let instance =\n-                    ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n-                        .ok_or_else(|| err_inval!(TooGeneric))?;\n-                Ok((i, self.memory.create_fn_alloc(FnVal::Instance(instance))))\n-            })\n-            .collect::<InterpResult<'tcx, Vec<(usize, Pointer<M::PointerTag>)>>>()?;\n-\n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+        let scalars = vtable_entries\n+            .iter()\n+            .map(|entry| -> InterpResult<'tcx, _> {\n+                match entry {\n+                    VtblEntry::MetadataDropInPlace => Ok(Some(drop.into())),\n+                    VtblEntry::MetadataSize => Ok(Some(Scalar::from_uint(size, ptr_size).into())),\n+                    VtblEntry::MetadataAlign => Ok(Some(Scalar::from_uint(align, ptr_size).into())),\n+                    VtblEntry::Vacant => Ok(None),\n+                    VtblEntry::Method(def_id, substs) => {\n+                        // Prepare the fn ptr we write into the vtable.\n+                        let instance =\n+                            ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n+                                .ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        Ok(Some(fn_ptr.into()))\n+                    }\n+                }\n+            })\n+            .collect::<Result<Vec<_>, _>>()?;\n         let mut vtable_alloc =\n             self.memory.get_mut(vtable.into(), vtable_size, ptr_align)?.expect(\"not a ZST\");\n-        vtable_alloc.write_ptr_sized(ptr_size * 0, drop.into())?;\n-        vtable_alloc.write_ptr_sized(ptr_size * 1, Scalar::from_uint(size, ptr_size).into())?;\n-        vtable_alloc.write_ptr_sized(ptr_size * 2, Scalar::from_uint(align, ptr_size).into())?;\n-\n-        for (i, fn_ptr) in fn_ptrs.into_iter() {\n-            vtable_alloc.write_ptr_sized(ptr_size * (3 + i as u64), fn_ptr.into())?;\n+        for (idx, scalar) in scalars.into_iter().enumerate() {\n+            if let Some(scalar) = scalar {\n+                let idx: u64 = u64::try_from(idx).unwrap();\n+                vtable_alloc.write_ptr_sized(ptr_size * idx, scalar)?;\n+            }\n         }\n \n         M::after_static_mem_initialized(self, vtable, vtable_size)?;\n@@ -99,16 +105,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Resolves the function at the specified slot in the provided\n-    /// vtable. An index of '0' corresponds to the first method\n-    /// declared in the trait of the provided vtable.\n+    /// vtable. Currently an index of '3' (`COMMON_VTABLE_ENTRIES.len()`)\n+    /// corresponds to the first method declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n         idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n-        // Skip over the 'drop_ptr', 'size', and 'align' fields.\n-        let vtable_slot = vtable.ptr_offset(ptr_size * idx.checked_add(3).unwrap(), self)?;\n+        let vtable_slot = vtable.ptr_offset(ptr_size * idx, self)?;\n         let vtable_slot = self\n             .memory\n             .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n@@ -122,12 +127,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n+        let pointer_size = self.pointer_size();\n         // We don't care about the pointee type; we just want a pointer.\n         let vtable = self\n             .memory\n-            .get(vtable, self.tcx.data_layout.pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get(\n+                vtable,\n+                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n+                self.tcx.data_layout.pointer_align.abi,\n+            )?\n             .expect(\"cannot be a ZST\");\n-        let drop_fn = vtable.read_ptr_sized(Size::ZERO)?.check_init()?;\n+        let drop_fn = vtable\n+            .read_ptr_sized(\n+                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_DROPINPLACE).unwrap(),\n+            )?\n+            .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n@@ -153,11 +167,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // the size, and the align (which we read below).\n         let vtable = self\n             .memory\n-            .get(vtable, 3 * pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get(\n+                vtable,\n+                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n+                self.tcx.data_layout.pointer_align.abi,\n+            )?\n             .expect(\"cannot be a ZST\");\n-        let size = vtable.read_ptr_sized(pointer_size)?.check_init()?;\n+        let size = vtable\n+            .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap())?\n+            .check_init()?;\n         let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n-        let align = vtable.read_ptr_sized(pointer_size * 2)?.check_init()?;\n+        let align = vtable\n+            .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap())?\n+            .check_init()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n "}, {"sha": "0ab9aa8e1bfd4b63a5ab541d391197847f349975", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -196,7 +196,7 @@ use rustc_middle::mir::{self, Local, Location};\n use rustc_middle::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable, VtblEntry};\n use rustc_middle::{middle::codegen_fn_attrs::CodegenFnAttrFlags, mir::visit::TyContext};\n use rustc_session::config::EntryFnType;\n use rustc_session::lint::builtin::LARGE_ASSIGNMENTS;\n@@ -1091,21 +1091,22 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n             assert!(!poly_trait_ref.has_escaping_bound_vars());\n \n             // Walk all methods of the trait, including those of its supertraits\n-            let methods = tcx.vtable_methods(poly_trait_ref);\n-            let methods = methods\n+            let entries = tcx.vtable_entries(poly_trait_ref);\n+            let methods = entries\n                 .iter()\n-                .cloned()\n-                .filter_map(|method| method)\n-                .map(|(def_id, substs)| {\n-                    ty::Instance::resolve_for_vtable(\n+                .filter_map(|entry| match entry {\n+                    VtblEntry::MetadataDropInPlace\n+                    | VtblEntry::MetadataSize\n+                    | VtblEntry::MetadataAlign\n+                    | VtblEntry::Vacant => None,\n+                    VtblEntry::Method(def_id, substs) => ty::Instance::resolve_for_vtable(\n                         tcx,\n                         ty::ParamEnv::reveal_all(),\n-                        def_id,\n+                        *def_id,\n                         substs,\n                     )\n-                    .unwrap()\n+                    .filter(|instance| should_codegen_locally(tcx, instance)),\n                 })\n-                .filter(|&instance| should_codegen_locally(tcx, &instance))\n                 .map(|item| create_fn_mono_item(tcx, item, source));\n             output.extend(methods);\n         }"}, {"sha": "d65a596a8276f1bca70d7a6ddb22c3f072a4f601", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 82, "deletions": 51, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -31,7 +31,8 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{\n-    self, GenericParamDefKind, ParamEnv, ToPredicate, Ty, TyCtxt, WithConstness,\n+    self, GenericParamDefKind, ParamEnv, ToPredicate, Ty, TyCtxt, VtblEntry, WithConstness,\n+    COMMON_VTABLE_ENTRIES,\n };\n use rustc_span::Span;\n \n@@ -455,59 +456,89 @@ fn subst_and_check_impossible_predicates<'tcx>(\n \n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n-fn vtable_methods<'tcx>(\n+fn vtable_entries<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-    debug!(\"vtable_methods({:?})\", trait_ref);\n-\n-    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx\n-            .associated_items(trait_ref.def_id())\n-            .in_definition_order()\n-            .filter(|item| item.kind == ty::AssocKind::Fn);\n-\n-        // Now list each method's DefId and InternalSubsts (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                debug!(\"vtable_methods: not vtable safe\");\n-                return None;\n-            }\n+) -> &'tcx [VtblEntry<'tcx>] {\n+    debug!(\"vtable_entries({:?})\", trait_ref);\n+\n+    let entries = COMMON_VTABLE_ENTRIES.iter().cloned().chain(\n+        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+            let trait_methods = tcx\n+                .associated_items(trait_ref.def_id())\n+                .in_definition_order()\n+                .filter(|item| item.kind == ty::AssocKind::Fn);\n+\n+            // Now list each method's DefId and InternalSubsts (for within its trait).\n+            // If the method can never be called from this object, produce `Vacant`.\n+            trait_methods.map(move |trait_method| {\n+                debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n+                let def_id = trait_method.def_id;\n+\n+                // Some methods cannot be called on an object; skip those.\n+                if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+                    debug!(\"vtable_entries: not vtable safe\");\n+                    return VtblEntry::Vacant;\n+                }\n \n-            // The method may have some early-bound lifetimes; add regions for those.\n-            let substs = trait_ref.map_bound(|trait_ref| {\n-                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                        trait_ref.substs[param.index as usize]\n-                    }\n-                })\n-            });\n-\n-            // The trait type may have higher-ranked lifetimes in it;\n-            // erase them if they appear, so that we get the type\n-            // at some particular call site.\n-            let substs =\n-                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-            // It's possible that the method relies on where-clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and codegen it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if impossible_predicates(tcx, predicates.predicates) {\n-                debug!(\"vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n+                // The method may have some early-bound lifetimes; add regions for those.\n+                let substs = trait_ref.map_bound(|trait_ref| {\n+                    InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                        GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                            trait_ref.substs[param.index as usize]\n+                        }\n+                    })\n+                });\n+\n+                // The trait type may have higher-ranked lifetimes in it;\n+                // erase them if they appear, so that we get the type\n+                // at some particular call site.\n+                let substs =\n+                    tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                // It's possible that the method relies on where-clauses that\n+                // do not hold for this particular set of type parameters.\n+                // Note that this method could then never be called, so we\n+                // do not want to try and codegen it, in that case (see #23435).\n+                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                if impossible_predicates(tcx, predicates.predicates) {\n+                    debug!(\"vtable_entries: predicates do not hold\");\n+                    return VtblEntry::Vacant;\n+                }\n \n-            Some((def_id, substs))\n-        })\n-    }))\n+                VtblEntry::Method(def_id, substs)\n+            })\n+        }),\n+    );\n+\n+    tcx.arena.alloc_from_iter(entries)\n+}\n+\n+/// Find slot base for trait methods within vtable entries of another trait\n+fn vtable_trait_first_method_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> usize {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    let mut supertraits = util::supertraits(tcx, trait_owning_vtable);\n+\n+    // For each of the non-matching predicates that\n+    // we pass over, we sum up the set of number of vtable\n+    // entries, so that we can compute the offset for the selected\n+    // trait.\n+    let vtable_base = ty::COMMON_VTABLE_ENTRIES.len()\n+        + supertraits\n+            .by_ref()\n+            .take_while(|t| *t != trait_to_be_found)\n+            .map(|t| util::count_own_vtable_entries(tcx, t))\n+            .sum::<usize>();\n+\n+    vtable_base\n }\n \n /// Check whether a `ty` implements given trait(trait_def_id).\n@@ -547,7 +578,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n-        vtable_methods,\n+        vtable_entries,\n         type_implements_trait,\n         subst_and_check_impossible_predicates,\n         mir_abstract_const: |tcx, def_id| {"}, {"sha": "f8297ee3a071865d8e10ca9d2c75005942733a86", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86d3a7e45e6c4db749df018678ef587ace21933/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=a86d3a7e45e6c4db749df018678ef587ace21933", "patch": "@@ -396,19 +396,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut nested = vec![];\n \n         let mut supertraits = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref));\n-\n-        // For each of the non-matching predicates that\n-        // we pass over, we sum up the set of number of vtable\n-        // entries, so that we can compute the offset for the selected\n-        // trait.\n-        let vtable_base = supertraits\n-            .by_ref()\n-            .take(index)\n-            .map(|t| super::util::count_own_vtable_entries(tcx, t))\n-            .sum();\n-\n         let unnormalized_upcast_trait_ref =\n-            supertraits.next().expect(\"supertraits iterator no longer has as many elements\");\n+            supertraits.nth(index).expect(\"supertraits iterator no longer has as many elements\");\n \n         let upcast_trait_ref = normalize_with_depth_to(\n             self,\n@@ -490,6 +479,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         debug!(?nested, \"object nested obligations\");\n+\n+        let vtable_base = super::super::vtable_trait_first_method_offset(\n+            tcx,\n+            (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),\n+        );\n+\n         Ok(ImplSourceObjectData { upcast_trait_ref, vtable_base, nested })\n     }\n "}]}