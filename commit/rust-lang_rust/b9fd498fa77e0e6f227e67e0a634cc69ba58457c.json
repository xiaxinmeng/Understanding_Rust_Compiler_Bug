{"sha": "b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "node_id": "C_kwDOAAsO6NoAKGI5ZmQ0OThmYTc3ZTBlNmYyMjdlNjdlMGE2MzRjYzY5YmE1ODQ1N2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-19T23:39:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-19T23:39:03Z"}, "message": "Auto merge of #110061 - WaffleLapkin:duality_of_myself_and_this, r=cjgillot\n\nAdd suggestion to use closure argument instead of a capture on borrowck error\n\nFixes #109271\nr? `@compiler-errors`\n\nThis should probably be refined a bit, but opening a PR so that I don't forget anything.", "tree": {"sha": "391cb87200751588fc1a27a46f4ff1b9916e7862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/391cb87200751588fc1a27a46f4ff1b9916e7862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "html_url": "https://github.com/rust-lang/rust/commit/b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c6804b92aa202369e402525cee329556bc1db0", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c6804b92aa202369e402525cee329556bc1db0", "html_url": "https://github.com/rust-lang/rust/commit/39c6804b92aa202369e402525cee329556bc1db0"}, {"sha": "cac143f0e3f957c9ace4721eff0b89c95a624288", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac143f0e3f957c9ace4721eff0b89c95a624288", "html_url": "https://github.com/rust-lang/rust/commit/cac143f0e3f957c9ace4721eff0b89c95a624288"}], "stats": {"total": 508, "additions": 425, "deletions": 83}, "files": [{"sha": "acca1a1477f2540d21165f7748d1ee84d482a4e2", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -469,6 +469,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub(crate) fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,"}, {"sha": "49e74a1b000d442d14d5b32db1b52f494050b269", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 160, "deletions": 14, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -1,3 +1,5 @@\n+use std::iter;\n+\n use either::Either;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxIndexSet;\n@@ -10,27 +12,26 @@ use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty, TypeckResults};\n use rustc_middle::util::CallKind;\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n-\n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n-use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n use crate::diagnostics::{find_all_local_uses, CapturedMessageOpt};\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n@@ -959,7 +960,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &msg_borrow,\n                     None,\n                 );\n-                self.suggest_binding_for_closure_capture_self(\n+                self.suggest_binding_for_closure_capture_self(&mut err, &issued_spans);\n+                self.suggest_using_closure_argument_instead_of_capture(\n                     &mut err,\n                     issued_borrow.borrowed_place,\n                     &issued_spans,\n@@ -982,6 +984,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     place,\n                     issued_borrow.borrowed_place,\n                 );\n+                self.suggest_using_closure_argument_instead_of_capture(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n                 err\n             }\n \n@@ -1268,22 +1275,161 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn suggest_binding_for_closure_capture_self(\n+    /// Suggest using closure argument instead of capture.\n+    ///\n+    /// For example:\n+    /// ```ignore (illustrative)\n+    /// struct S;\n+    ///\n+    /// impl S {\n+    ///     fn call(&mut self, f: impl Fn(&mut Self)) { /* ... */ }\n+    ///     fn x(&self) {}\n+    /// }\n+    ///\n+    ///     let mut v = S;\n+    ///     v.call(|this: &mut S| v.x());\n+    /// //  ^\\                    ^-- help: try using the closure argument: `this`\n+    /// //    *-- error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    /// ```\n+    fn suggest_using_closure_argument_instead_of_capture(\n         &self,\n         err: &mut Diagnostic,\n         borrowed_place: Place<'tcx>,\n         issued_spans: &UseSpans<'tcx>,\n     ) {\n-        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n-        let hir = self.infcx.tcx.hir();\n+        let &UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n \n-        // check whether the borrowed place is capturing `self` by mut reference\n+        // Get the type of the local that we are trying to borrow\n         let local = borrowed_place.local;\n-        let Some(_) = self\n-            .body\n-            .local_decls\n-            .get(local)\n-            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+        let local_ty = self.body.local_decls[local].ty;\n+\n+        // Get the body the error happens in\n+        let Some(body_id) = hir.get(self.mir_hir_id()).body_id() else { return };\n+\n+        let body_expr = hir.body(body_id).value;\n+\n+        struct ClosureFinder<'hir> {\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            borrow_span: Span,\n+            res: Option<(&'hir hir::Expr<'hir>, &'hir hir::Closure<'hir>)>,\n+            /// The path expression with the `borrow_span` span\n+            error_path: Option<(&'hir hir::Expr<'hir>, &'hir hir::QPath<'hir>)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ClosureFinder<'hir> {\n+            type NestedFilter = OnlyBodies;\n+\n+            fn nested_visit_map(&mut self) -> Self::Map {\n+                self.hir\n+            }\n+\n+            fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                if let hir::ExprKind::Path(qpath) = &ex.kind\n+                    && ex.span == self.borrow_span\n+                {\n+                    self.error_path = Some((ex, qpath));\n+                }\n+\n+                if let hir::ExprKind::Closure(closure) = ex.kind\n+                    && ex.span.contains(self.borrow_span)\n+                    // To support cases like `|| { v.call(|this| v.get()) }`\n+                    // FIXME: actually support such cases (need to figure out how to move from the capture place to original local)\n+                    && self.res.as_ref().map_or(true, |(prev_res, _)| prev_res.span.contains(ex.span))\n+                {\n+                    self.res = Some((ex, closure));\n+                }\n+\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        // Find the closure that most tightly wraps `capture_kind_span`\n+        let mut finder =\n+            ClosureFinder { hir, borrow_span: capture_kind_span, res: None, error_path: None };\n+        finder.visit_expr(body_expr);\n+        let Some((closure_expr, closure)) = finder.res else { return };\n+\n+        let typeck_results: &TypeckResults<'_> =\n+            tcx.typeck_opt_const_arg(self.body.source.with_opt_param().as_local().unwrap());\n+\n+        // Check that the parent of the closure is a method call,\n+        // with receiver matching with local's type (modulo refs)\n+        let parent = hir.parent_id(closure_expr.hir_id);\n+        if let hir::Node::Expr(parent) = hir.get(parent) {\n+            if let hir::ExprKind::MethodCall(_, recv, ..) = parent.kind {\n+                let recv_ty = typeck_results.expr_ty(recv);\n+\n+                if recv_ty.peel_refs() != local_ty {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // Get closure's arguments\n+        let ty::Closure(_, substs) = typeck_results.expr_ty(closure_expr).kind() else { unreachable!() };\n+        let sig = substs.as_closure().sig();\n+        let tupled_params =\n+            tcx.erase_late_bound_regions(sig.inputs().iter().next().unwrap().map_bound(|&b| b));\n+        let ty::Tuple(params) = tupled_params.kind() else { return };\n+\n+        // Find the first argument with a matching type, get its name\n+        let Some((_, this_name)) = params\n+            .iter()\n+            .zip(hir.body_param_names(closure.body))\n+            .find(|(param_ty, name)|{\n+                // FIXME: also support deref for stuff like `Rc` arguments\n+                param_ty.peel_refs() == local_ty && name != &Ident::empty()\n+            })\n+            else { return };\n+\n+        let spans;\n+        if let Some((_path_expr, qpath)) = finder.error_path\n+            && let hir::QPath::Resolved(_, path) = qpath\n+            && let hir::def::Res::Local(local_id) = path.res\n+        {\n+            // Find all references to the problematic variable in this closure body\n+\n+            struct VariableUseFinder {\n+                local_id: hir::HirId,\n+                spans: Vec<Span>,\n+            }\n+            impl<'hir> Visitor<'hir> for VariableUseFinder {\n+                fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                    if let hir::ExprKind::Path(qpath) = &ex.kind\n+                        && let hir::QPath::Resolved(_, path) = qpath\n+                        && let hir::def::Res::Local(local_id) = path.res\n+                        && local_id == self.local_id\n+                    {\n+                        self.spans.push(ex.span);\n+                    }\n+\n+                    hir::intravisit::walk_expr(self, ex);\n+                }\n+            }\n+\n+            let mut finder = VariableUseFinder { local_id, spans: Vec::new() };\n+            finder.visit_expr(hir.body(closure.body).value);\n+\n+            spans = finder.spans;\n+        } else {\n+            spans = vec![capture_kind_span];\n+        }\n+\n+        err.multipart_suggestion(\n+            \"try using the closure argument\",\n+            iter::zip(spans, iter::repeat(this_name.to_string())).collect(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n \n         struct ExpressionFinder<'hir> {\n             capture_span: Span,"}, {"sha": "54b328e78f8eead0fd69eb1f486593f6f99149ab", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -3529,12 +3529,20 @@ impl<'hir> OwnerNode<'hir> {\n \n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n-            OwnerNode::TraitItem(TraitItem {\n-                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+            OwnerNode::Item(Item {\n+                kind:\n+                    ItemKind::Static(_, _, body) | ItemKind::Const(_, body) | ItemKind::Fn(_, _, body),\n                 ..\n             })\n-            | OwnerNode::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n-            | OwnerNode::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            | OwnerNode::TraitItem(TraitItem {\n+                kind:\n+                    TraitItemKind::Fn(_, TraitFn::Provided(body)) | TraitItemKind::Const(_, Some(body)),\n+                ..\n+            })\n+            | OwnerNode::ImplItem(ImplItem {\n+                kind: ImplItemKind::Fn(_, body) | ImplItemKind::Const(_, body),\n+                ..\n+            }) => Some(*body),\n             _ => None,\n         }\n     }\n@@ -3729,12 +3737,27 @@ impl<'hir> Node<'hir> {\n \n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n-            Node::TraitItem(TraitItem {\n-                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+            Node::Item(Item {\n+                kind:\n+                    ItemKind::Static(_, _, body) | ItemKind::Const(_, body) | ItemKind::Fn(_, _, body),\n+                ..\n+            })\n+            | Node::TraitItem(TraitItem {\n+                kind:\n+                    TraitItemKind::Fn(_, TraitFn::Provided(body)) | TraitItemKind::Const(_, Some(body)),\n+                ..\n+            })\n+            | Node::ImplItem(ImplItem {\n+                kind: ImplItemKind::Fn(_, body) | ImplItemKind::Const(_, body),\n                 ..\n             })\n-            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n-            | Node::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            | Node::Expr(Expr {\n+                kind:\n+                    ExprKind::ConstBlock(AnonConst { body, .. })\n+                    | ExprKind::Closure(Closure { body, .. })\n+                    | ExprKind::Repeat(_, ArrayLen::Body(AnonConst { body, .. })),\n+                ..\n+            }) => Some(*body),\n             _ => None,\n         }\n     }"}, {"sha": "747c54b669440e8eb5d9445c6ddbc0cd173e8987", "filename": "tests/ui/async-await/feature-self-return-type.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -4,6 +4,7 @@ error[E0597]: `bar` does not live long enough\n LL |     let x = {\n    |         - borrow later stored here\n LL |         let bar = 22;\n+   |             --- binding `bar` declared here\n LL |         Foo::new(&bar).await\n    |                  ^^^^ borrowed value does not live long enough\n LL |"}, {"sha": "ac85ed2887abc89b33b6ed791e2ae088540d5927", "filename": "tests/ui/async-await/issue-61949-self-return-type.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -13,6 +13,7 @@ error[E0597]: `bar` does not live long enough\n LL |     let x = {\n    |         - borrow later stored here\n LL |         let bar = 22;\n+   |             --- binding `bar` declared here\n LL |         Foo::new(&bar).await\n    |                  ^^^^ borrowed value does not live long enough\n LL |"}, {"sha": "4a8831dab95676dc6dcf708ecfea7857bdc64028", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.fixed", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -0,0 +1,39 @@\n+// run-rustfix\n+#![allow(unused)]\n+struct S;\n+\n+impl S {\n+    fn call(&mut self, f: impl FnOnce((), &mut Self)) {\n+        // change state or something ...\n+        f((), self);\n+        // change state or something ...\n+    }\n+\n+    fn get(&self) {}\n+    fn set(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut v = S;\n+\n+    v.call(|(), this: &mut S| this.get());\n+    //~^ error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.call(|(), this: &mut S| this.set());\n+    //~^ error: cannot borrow `v` as mutable more than once at a time\n+    //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+    v.call(|(), this: &mut S| {\n+        //~^ error: cannot borrow `v` as mutable more than once at a time\n+        //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+        _ = this;\n+        this.set();\n+        this.get();\n+        S::get(&this);\n+\n+        use std::ops::Add;\n+        let v = 0u32;\n+        _ = v + v;\n+        _ = v.add(3);\n+    });\n+}"}, {"sha": "fcd855f862d71cc4834c255b6090853ded8676cb", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -0,0 +1,39 @@\n+// run-rustfix\n+#![allow(unused)]\n+struct S;\n+\n+impl S {\n+    fn call(&mut self, f: impl FnOnce((), &mut Self)) {\n+        // change state or something ...\n+        f((), self);\n+        // change state or something ...\n+    }\n+\n+    fn get(&self) {}\n+    fn set(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut v = S;\n+\n+    v.call(|(), this: &mut S| v.get());\n+    //~^ error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.call(|(), this: &mut S| v.set());\n+    //~^ error: cannot borrow `v` as mutable more than once at a time\n+    //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+    v.call(|(), this: &mut S| {\n+        //~^ error: cannot borrow `v` as mutable more than once at a time\n+        //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+        _ = v;\n+        v.set();\n+        v.get();\n+        S::get(&v);\n+\n+        use std::ops::Add;\n+        let v = 0u32;\n+        _ = v + v;\n+        _ = v.add(3);\n+    });\n+}"}, {"sha": "25974e0d00831d9992a48be2a675fc9c697d7581", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.stderr", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -0,0 +1,85 @@\n+error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:19:5\n+   |\n+LL |     v.call(|(), this: &mut S| v.get());\n+   |     ^^----^------------------^-^^^^^^^\n+   |     | |    |                  |\n+   |     | |    |                  first borrow occurs due to use of `v` in closure\n+   |     | |    |                  help: try using the closure argument: `this`\n+   |     | |    immutable borrow occurs here\n+   |     | immutable borrow later used by call\n+   |     mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:21:5\n+   |\n+LL |     v.call(|(), this: &mut S| v.set());\n+   |     ^^----^------------------^-^^^^^^^\n+   |     | |    |                  |\n+   |     | |    |                  first borrow occurs due to use of `v` in closure\n+   |     | |    |                  help: try using the closure argument: `this`\n+   |     | |    first mutable borrow occurs here\n+   |     | first borrow later used by call\n+   |     second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:21:12\n+   |\n+LL |     v.call(|(), this: &mut S| v.set());\n+   |     -------^^^^^^^^^^^^^^^^^^---------\n+   |     | |    |                  |\n+   |     | |    |                  second borrow occurs due to use of `v` in closure\n+   |     | |    second mutable borrow occurs here\n+   |     | first borrow later used by call\n+   |     first mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:25:5\n+   |\n+LL |       v.call(|(), this: &mut S| {\n+   |       ^ ---- ------------------ first mutable borrow occurs here\n+   |       | |\n+   |  _____| first borrow later used by call\n+   | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         _ = v;\n+LL | |         v.set();\n+   | |         - first borrow occurs due to use of `v` in closure\n+...  |\n+LL | |         _ = v.add(3);\n+LL | |     });\n+   | |______^ second mutable borrow occurs here\n+   |\n+help: try using the closure argument\n+   |\n+LL ~         _ = this;\n+LL ~         this.set();\n+LL ~         this.get();\n+LL ~         S::get(&this);\n+   |\n+\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:25:12\n+   |\n+LL |       v.call(|(), this: &mut S| {\n+   |       - ---- ^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n+   |       | |\n+   |  _____| first borrow later used by call\n+   | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         _ = v;\n+LL | |         v.set();\n+   | |         - second borrow occurs due to use of `v` in closure\n+...  |\n+LL | |         _ = v.add(3);\n+LL | |     });\n+   | |______- first mutable borrow occurs here\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0499, E0502.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "ff1dc29ccfdd0382c965370ec671c489e02473fe", "filename": "tests/ui/consts/const-eval/generic-slice.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -4,6 +4,8 @@ error[E0597]: `x` does not live long enough\n LL | impl<'a, T: 'static> Generic<'a, T> {\n    |      -- lifetime `'a` defined here\n ...\n+LL |         let x: &'static [T] = &[];\n+   |             - binding `x` declared here\n LL |         &x\n    |         ^^\n    |         |\n@@ -16,6 +18,8 @@ LL |     };\n error[E0597]: `x` does not live long enough\n   --> $DIR/generic-slice.rs:27:5\n    |\n+LL |     let x: &[_] = &[];\n+   |         - binding `x` declared here\n LL |     &x\n    |     ^^\n    |     |"}, {"sha": "b2a5b92ed0f97a692f6ad44c4b94c780e816e123", "filename": "tests/ui/generator/auto-trait-regions.drop_tracking.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -9,7 +9,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut binding, &mut true, No);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/auto-trait-regions.rs:48:35\n@@ -22,7 +26,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut true, &mut binding, No);\n+   |\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:34:5"}, {"sha": "b2a5b92ed0f97a692f6ad44c4b94c780e816e123", "filename": "tests/ui/generator/auto-trait-regions.drop_tracking_mir.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking_mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking_mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fauto-trait-regions.drop_tracking_mir.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -9,7 +9,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut binding, &mut true, No);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/auto-trait-regions.rs:48:35\n@@ -22,7 +26,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut true, &mut binding, No);\n+   |\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:34:5"}, {"sha": "b2a5b92ed0f97a692f6ad44c4b94c780e816e123", "filename": "tests/ui/generator/auto-trait-regions.no_drop_tracking.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fgenerator%2Fauto-trait-regions.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fauto-trait-regions.no_drop_tracking.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -9,7 +9,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut binding, &mut true, No);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/auto-trait-regions.rs:48:35\n@@ -22,7 +26,11 @@ LL |         let a = A(&mut true, &mut true, No);\n LL |         assert_foo(a);\n    |                    - borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~         let binding = true;\n+LL ~         let a = A(&mut true, &mut binding, No);\n+   |\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:34:5"}, {"sha": "165748d44305a733353549dbe6ba28d15de56a46", "filename": "tests/ui/generator/auto-trait-regions.stderr", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/39c6804b92aa202369e402525cee329556bc1db0/tests%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39c6804b92aa202369e402525cee329556bc1db0/tests%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=39c6804b92aa202369e402525cee329556bc1db0", "patch": "@@ -1,47 +0,0 @@\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/auto-trait-regions.rs:48:24\n-   |\n-LL |         let a = A(&mut true, &mut true, No);\n-   |                        ^^^^                - temporary value is freed at the end of this statement\n-   |                        |\n-   |                        creates a temporary value which is freed while still in use\n-...\n-LL |         assert_foo(a);\n-   |                    - borrow later used here\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/auto-trait-regions.rs:48:35\n-   |\n-LL |         let a = A(&mut true, &mut true, No);\n-   |                                   ^^^^     - temporary value is freed at the end of this statement\n-   |                                   |\n-   |                                   creates a temporary value which is freed while still in use\n-...\n-LL |         assert_foo(a);\n-   |                    - borrow later used here\n-   |\n-   = note: consider using a `let` binding to create a longer lived value\n-\n-error: implementation of `Foo` is not general enough\n-  --> $DIR/auto-trait-regions.rs:34:5\n-   |\n-LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n-   |\n-   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo`, for any lifetime `'0`...\n-   = note: ...but `Foo` is actually implemented for the type `&'static OnlyFooIfStaticRef`\n-\n-error: implementation of `Foo` is not general enough\n-  --> $DIR/auto-trait-regions.rs:54:5\n-   |\n-LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n-   |\n-   = note: `Foo` would have to be implemented for the type `A<'0, '1>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Foo` is actually implemented for the type `A<'_, '2>`, for some specific lifetime `'2`\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0716`."}, {"sha": "3879f35505c2e5b2da08314fc78a6ff23e361b14", "filename": "tests/ui/lifetimes/issue-69314.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Flifetimes%2Fissue-69314.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Flifetimes%2Fissue-69314.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-69314.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -12,6 +12,8 @@ LL |     async fn f2(m: Msg<'_>) {}\n error[E0597]: `buf` does not live long enough\n   --> $DIR/issue-69314.rs:14:19\n    |\n+LL |         let mut buf = [0; 512];\n+   |             ------- binding `buf` declared here\n LL |         let m2 = &buf[..];\n    |                   ^^^ borrowed value does not live long enough\n LL |         let m = Self::g(m2).await;"}, {"sha": "900e7e2539089ed34f80c148a47dbc2a5f7a83f0", "filename": "tests/ui/nll/user-annotations/adt-brace-enums.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -31,7 +31,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         SomeEnum::SomeVariant::<&'a u32> { t: &c };\n    |                                               ^^\n    |                                               |"}, {"sha": "d61643dc6ed8ccda6a135855d0f7450bfc0db049", "filename": "tests/ui/nll/user-annotations/adt-brace-structs.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -31,7 +31,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         SomeStruct::<&'a u32> { t: &c };\n    |                                    ^^\n    |                                    |"}, {"sha": "5b385feeedc728a7ac77c3aa8ec030223f6d8727", "filename": "tests/ui/nll/user-annotations/adt-nullary-enums.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -34,7 +34,10 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n+LL |         combine(\n LL |             SomeEnum::SomeVariant(Cell::new(&c)),\n    |                                   ----------^^-\n    |                                   |         |"}, {"sha": "766da9ec00c332b01efbc07e7d97ec8aac3fbdd1", "filename": "tests/ui/nll/user-annotations/adt-tuple-enums.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -31,7 +31,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         SomeEnum::SomeVariant::<&'a u32>(&c);\n    |                                          ^^\n    |                                          |"}, {"sha": "2084697e7e26d8ffc8b7ea060675e6bc08e62ed1", "filename": "tests/ui/nll/user-annotations/adt-tuple-struct-calls.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -33,7 +33,10 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n+LL |         let f = SomeStruct::<&'a u32>;\n LL |         f(&c);\n    |         --^^-\n    |         | |\n@@ -47,7 +50,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL |     let f = SomeStruct::<&'a u32>;\n    |         - lifetime `'1` appears in the type of `f`\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         f(&c);\n    |         --^^-\n    |         | |"}, {"sha": "c7480f52963116c32127a795da816594cfd88031", "filename": "tests/ui/nll/user-annotations/adt-tuple-struct.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -31,7 +31,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         SomeStruct::<&'a u32>(&c);\n    |                               ^^\n    |                               |"}, {"sha": "abaa35e9516ec682723acecec09d0a40513e8cd0", "filename": "tests/ui/nll/user-annotations/fns.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -31,7 +31,9 @@ error[E0597]: `c` does not live long enough\n    |\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n-...\n+LL |     let _closure = || {\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         some_fn::<&'a u32>(&c);\n    |         -------------------^^-\n    |         |                  |"}, {"sha": "b4d1ac042a2326952245a5a6516f859dc39e1a11", "filename": "tests/ui/nll/user-annotations/method-call.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -33,6 +33,8 @@ error[E0597]: `c` does not live long enough\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n ...\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         a.method::<&'a u32>(b,  &c);\n    |         ------------------------^^-\n    |         |                       |"}, {"sha": "4dd39e108277ed4f6740a79148bb847d19d13b11", "filename": "tests/ui/nll/user-annotations/method-ufcs-3.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -33,6 +33,8 @@ error[E0597]: `c` does not live long enough\n LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n    |                                              -- lifetime `'a` defined here\n ...\n+LL |         let c = 66;\n+   |             - binding `c` declared here\n LL |         <_ as Bazoom<_>>::method::<&'a u32>(&a, b, &c);\n    |         -------------------------------------------^^-\n    |         |                                          |"}, {"sha": "035be2b1202fded586d12b74ec1326f631b303ed", "filename": "tests/ui/static/issue-18118.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fstatic%2Fissue-18118.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9fd498fa77e0e6f227e67e0a634cc69ba58457c/tests%2Fui%2Fstatic%2Fissue-18118.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatic%2Fissue-18118.stderr?ref=b9fd498fa77e0e6f227e67e0a634cc69ba58457c", "patch": "@@ -1,6 +1,8 @@\n error[E0597]: `p` does not live long enough\n   --> $DIR/issue-18118.rs:4:9\n    |\n+LL |         let p = 3;\n+   |             - binding `p` declared here\n LL |         &p\n    |         ^^\n    |         |"}]}