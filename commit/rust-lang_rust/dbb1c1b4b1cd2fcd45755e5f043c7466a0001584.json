{"sha": "dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "node_id": "C_kwDOAAsO6NoAKGRiYjFjMWI0YjFjZDJmY2Q0NTc1NWU1ZjA0M2M3NDY2YTAwMDE1ODQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-04T10:19:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T10:19:37Z"}, "message": "Merge #11184\n\n11184: Correctly pass through mutable parameter references when extracting a function r=Veykril a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10277\r\n\r\nI have based this investigation based on my understanding of [the Borrowing chapter](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html) but I wasn't able to debug the test runs or see it in action in an IDE. I'll try to figure out how to do that for future PRs but for now, the tests seem to confirm my understanding. I'll lay out my hypothesis below.\r\n\r\nHere we define the parameters for the to-be-generated function: \r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L882\r\n\r\nThree values in particular are important here: `requires_mut`, `is_copy` and `move_local`. These will in turn be used here to determine the kind of parameter:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L374-L381\r\n\r\nand then here to determine what transformation is needed for the calling argument:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L383-L390\r\n\r\nwhich then gets transformed here:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/syntax/src/ast/make.rs#L381-L383\r\n\r\nWhat I believe is happening is that \r\n* `requires_mut` is `false` (it already is marked as mutable), \r\n* `is_copy` is `false` (`Foo` does not implement `Copy`), and \r\n* `move_local` is `false` (it has further usages)\r\n\r\nAccording to the pattern matching in `fn kind()`, that would lead to `ParamKind::SharedRef` which in turn applies a transformation that prepends `&`.\r\n\r\nHowever if I look at the chapter on borrowing then we only need to mark an argument as a reference if we actually own it. In this case the value is passed through as a reference parameter into the current function which means we never had ownership in the first place. By including the additional check for a reference parameter, `move_local` now becomes `true` and the resulting parameter is now `ParamKind::Value` which will avoid applying any transformations. This was further obscured by the fact that you need further usages of the variable or `move_local` would be considered `true` after all.\r\n\r\nI didn't follow it in depth but it appears this idea applies for both the generated argument and the generated parameter.\r\nThere are existing tests that account for `&mut` values but they refer to local variables for which we do have ownership and as such they didn't expose this issue.\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>", "tree": {"sha": "6aa3a1eb84f3ae7e25b9b6f4f7a7c23b37682e5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aa3a1eb84f3ae7e25b9b6f4f7a7c23b37682e5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1B85CRBK7hj4Ov3rIwAAKfUIAJjmOvhnM/OtaiZGjhOgH20y\nVGddalItvEa64yT+Hijdb5JortbW479liLsxLVQWTgdimJ4X3/oRD2iwrHavU9oX\nyhm4JbwOCkcofon2gyt55czwDfRfbGk71+UhwSc+w12+4P4M5DcmIeWyIQ76kG/9\nStstCztATOUK2oYfULx1re3Oz7iQO8OMfiW2FAW7Ha8Fhm7jl3wCALHxUcoLk51K\nCzYJ8dFHQJ1vQFXMJd252Owm/PCus5XAZbGdWFWoGqA4HfVRQdmAp+c4Z23JmdH6\nuvqmChw39kUY8BDgB2ICIW8dxC2vPybJaWP45RSkSFpTqrMsteJb9qOPiAbAWng=\n=qRlX\n-----END PGP SIGNATURE-----\n", "payload": "tree 6aa3a1eb84f3ae7e25b9b6f4f7a7c23b37682e5c\nparent 22edf2e8a06222bbcbb2b3bee26a3a6a44d58d14\nparent ec61abbe930ae07b2a89813e37d595de1d47b288\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641291577 +0000\ncommitter GitHub <noreply@github.com> 1641291577 +0000\n\nMerge #11184\n\n11184: Correctly pass through mutable parameter references when extracting a function r=Veykril a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10277\r\n\r\nI have based this investigation based on my understanding of [the Borrowing chapter](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html) but I wasn't able to debug the test runs or see it in action in an IDE. I'll try to figure out how to do that for future PRs but for now, the tests seem to confirm my understanding. I'll lay out my hypothesis below.\r\n\r\nHere we define the parameters for the to-be-generated function: \r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L882\r\n\r\nThree values in particular are important here: `requires_mut`, `is_copy` and `move_local`. These will in turn be used here to determine the kind of parameter:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L374-L381\r\n\r\nand then here to determine what transformation is needed for the calling argument:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/ide_assists/src/handlers/extract_function.rs#L383-L390\r\n\r\nwhich then gets transformed here:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/7409880a07803c34590ad162d7854061145c6eae/crates/syntax/src/ast/make.rs#L381-L383\r\n\r\nWhat I believe is happening is that \r\n* `requires_mut` is `false` (it already is marked as mutable), \r\n* `is_copy` is `false` (`Foo` does not implement `Copy`), and \r\n* `move_local` is `false` (it has further usages)\r\n\r\nAccording to the pattern matching in `fn kind()`, that would lead to `ParamKind::SharedRef` which in turn applies a transformation that prepends `&`.\r\n\r\nHowever if I look at the chapter on borrowing then we only need to mark an argument as a reference if we actually own it. In this case the value is passed through as a reference parameter into the current function which means we never had ownership in the first place. By including the additional check for a reference parameter, `move_local` now becomes `true` and the resulting parameter is now `ParamKind::Value` which will avoid applying any transformations. This was further obscured by the fact that you need further usages of the variable or `move_local` would be considered `true` after all.\r\n\r\nI didn't follow it in depth but it appears this idea applies for both the generated argument and the generated parameter.\r\nThere are existing tests that account for `&mut` values but they refer to local variables for which we do have ownership and as such they didn't expose this issue.\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "html_url": "https://github.com/rust-lang/rust/commit/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22edf2e8a06222bbcbb2b3bee26a3a6a44d58d14", "url": "https://api.github.com/repos/rust-lang/rust/commits/22edf2e8a06222bbcbb2b3bee26a3a6a44d58d14", "html_url": "https://github.com/rust-lang/rust/commit/22edf2e8a06222bbcbb2b3bee26a3a6a44d58d14"}, {"sha": "ec61abbe930ae07b2a89813e37d595de1d47b288", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec61abbe930ae07b2a89813e37d595de1d47b288", "html_url": "https://github.com/rust-lang/rust/commit/ec61abbe930ae07b2a89813e37d595de1d47b288"}], "stats": {"total": 64, "additions": 63, "deletions": 1}, "files": [{"sha": "59c52dcd04a43f4a5743cf337004ef6f2b1f599a", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "patch": "@@ -878,7 +878,7 @@ impl FunctionBody {\n                 // We can move the value into the function call if it's not used after the call,\n                 // if the var is not used but defined outside a loop we are extracting from we can't move it either\n                 // as the function will reuse it in the next iteration.\n-                let move_local = !has_usages && defined_outside_parent_loop;\n+                let move_local = (!has_usages && defined_outside_parent_loop) || ty.is_reference();\n                 Param { var, ty, move_local, requires_mut, is_copy }\n             })\n             .collect()\n@@ -4332,6 +4332,68 @@ fn foo() {\n fn $0fun_name(a: _) -> _ {\n     a\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn reference_mutable_param_with_further_usages() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub struct Foo {\n+    field: u32,\n+}\n+\n+pub fn testfn(arg: &mut Foo) {\n+    $0arg.field = 8;$0\n+    // Simulating access after the extracted portion\n+    arg.field = 16;\n+}\n+\"#,\n+            r#\"\n+pub struct Foo {\n+    field: u32,\n+}\n+\n+pub fn testfn(arg: &mut Foo) {\n+    fun_name(arg);\n+    // Simulating access after the extracted portion\n+    arg.field = 16;\n+}\n+\n+fn $0fun_name(arg: &mut Foo) {\n+    arg.field = 8;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn reference_mutable_param_without_further_usages() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub struct Foo {\n+    field: u32,\n+}\n+\n+pub fn testfn(arg: &mut Foo) {\n+    $0arg.field = 8;$0\n+}\n+\"#,\n+            r#\"\n+pub struct Foo {\n+    field: u32,\n+}\n+\n+pub fn testfn(arg: &mut Foo) {\n+    fun_name(arg);\n+}\n+\n+fn $0fun_name(arg: &mut Foo) {\n+    arg.field = 8;\n+}\n \"#,\n         );\n     }"}]}