{"sha": "3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "node_id": "C_kwDOAAsO6NoAKDNjNmY0YzEyNjAyN2FjYTQxNTNiYTNhNmI0OGM2YWJjMTY0ZWY5NGQ", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-11T21:31:23Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-11T21:31:23Z"}, "message": "Bless tagged pointers (comply to strict provenance)", "tree": {"sha": "9e751800e17f88c7fc9cb4f9eb8a5be07db138c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e751800e17f88c7fc9cb4f9eb8a5be07db138c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "html_url": "https://github.com/rust-lang/rust/commit/3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f028636b1aec09366973468e8c347c1cf8291561", "url": "https://api.github.com/repos/rust-lang/rust/commits/f028636b1aec09366973468e8c347c1cf8291561", "html_url": "https://github.com/rust-lang/rust/commit/f028636b1aec09366973468e8c347c1cf8291561"}], "stats": {"total": 152, "additions": 85, "deletions": 67}, "files": [{"sha": "0a3f5f32d16f73951feb129ed6f1bb29a6e77aa6", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "patch": "@@ -29,6 +29,7 @@\n #![feature(get_mut_unchecked)]\n #![feature(lint_reasons)]\n #![feature(unwrap_infallible)]\n+#![feature(strict_provenance)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "8ad2b2a41fdcd19daae0d5a59f2b419f62c24346", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "patch": "@@ -15,6 +15,7 @@\n \n use std::mem::{self, ManuallyDrop};\n use std::ops::Deref;\n+use std::ptr::NonNull;\n use std::rc::Rc;\n use std::sync::Arc;\n \n@@ -29,21 +30,24 @@ pub use drop::TaggedPtr;\n ///\n /// # Safety\n ///\n-/// The usize returned from `into_usize` must be a valid, dereferenceable,\n-/// pointer to [`<Self as Deref>::Target`]. Note that pointers to\n-/// [`Self::Target`] must be thin, even though [`Self::Target`] may not be\n-/// `Sized`.\n+/// The pointer returned from [`into_ptr`] must be a [valid], pointer to\n+/// [`<Self as Deref>::Target`]. Note that pointers to [`Self::Target`] must be\n+/// thin, even though [`Self::Target`] may not be `Sized`.\n ///\n-/// Note that the returned pointer from `into_usize` should be castable to `&mut\n-/// <Self as Deref>::Target` if `Self: DerefMut`.\n+/// Note that if `Self` implements [`DerefMut`] the pointer returned from\n+/// [`into_ptr`] must be valid for writes (and thus calling [`NonNull::as_mut`]\n+/// on it must be safe).\n ///\n-/// The BITS constant must be correct. At least `BITS` bits, least-significant,\n-/// must be zero on all returned pointers from `into_usize`.\n+/// The `BITS` constant must be correct. At least `BITS` bits, least-significant,\n+/// must be zero on all pointers returned from [`into_ptr`].\n ///\n /// For example, if the alignment of [`Self::Target`] is 2, then `BITS` should be 1.\n ///\n+/// [`into_ptr`]: Pointer::into_ptr\n+/// [valid]: std::ptr#safety\n /// [`<Self as Deref>::Target`]: Deref::Target\n /// [`Self::Target`]: Deref::Target\n+/// [`DerefMut`]: std::ops::DerefMut\n pub unsafe trait Pointer: Deref {\n     /// Number of unused (always zero) **least significant bits** in this\n     /// pointer, usually related to the pointees alignment.\n@@ -63,15 +67,15 @@ pub unsafe trait Pointer: Deref {\n     /// [`Self::Target`]: Deref::Target\n     const BITS: usize;\n \n-    fn into_usize(self) -> usize;\n+    fn into_ptr(self) -> NonNull<Self::Target>;\n \n     /// # Safety\n     ///\n     /// The passed `ptr` must be returned from `into_usize`.\n     ///\n     /// This acts as `ptr::read` semantically, it should not be called more than\n     /// once on non-`Copy` `Pointer`s.\n-    unsafe fn from_usize(ptr: usize) -> Self;\n+    unsafe fn from_ptr(ptr: NonNull<Self::Target>) -> Self;\n \n     /// This provides a reference to the `Pointer` itself, rather than the\n     /// `Deref::Target`. It is used for cases where we want to call methods that\n@@ -81,7 +85,7 @@ pub unsafe trait Pointer: Deref {\n     /// # Safety\n     ///\n     /// The passed `ptr` must be returned from `into_usize`.\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R;\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<Self::Target>, f: F) -> R;\n }\n \n /// This describes tags that the `TaggedPtr` struct can hold.\n@@ -106,17 +110,18 @@ unsafe impl<T> Pointer for Box<T> {\n     const BITS: usize = bits_for::<Self::Target>();\n \n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Box::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Box::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Box::into_raw(self)) }\n     }\n \n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Box::from_raw(ptr as *mut T)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        Box::from_raw(ptr.as_ptr())\n     }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<T>, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_ptr(ptr));\n         f(&raw)\n     }\n }\n@@ -125,17 +130,17 @@ unsafe impl<T> Pointer for Rc<T> {\n     const BITS: usize = bits_for::<Self::Target>();\n \n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Rc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        unsafe { NonNull::new_unchecked(Rc::into_raw(self).cast_mut()) }\n     }\n \n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Rc::from_raw(ptr as *const T)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        Rc::from_raw(ptr.as_ptr())\n     }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<T>, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_ptr(ptr));\n         f(&raw)\n     }\n }\n@@ -144,17 +149,17 @@ unsafe impl<T> Pointer for Arc<T> {\n     const BITS: usize = bits_for::<Self::Target>();\n \n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Arc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        unsafe { NonNull::new_unchecked(Arc::into_raw(self).cast_mut()) }\n     }\n \n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Arc::from_raw(ptr as *const T)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        Arc::from_raw(ptr.as_ptr())\n     }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<T>, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_ptr(ptr));\n         f(&raw)\n     }\n }\n@@ -163,32 +168,35 @@ unsafe impl<'a, T: 'a> Pointer for &'a T {\n     const BITS: usize = bits_for::<Self::Target>();\n \n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const T as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n \n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const T)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        ptr.as_ref()\n     }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<T>, f: F) -> R {\n+        f(&ptr.as_ref())\n     }\n }\n \n unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n     const BITS: usize = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *mut T as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &mut *(ptr as *mut T)\n+    unsafe fn from_ptr(mut ptr: NonNull<T>) -> Self {\n+        ptr.as_mut()\n     }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(mut ptr: NonNull<T>, f: F) -> R {\n+        f(&ptr.as_mut())\n     }\n }\n "}, {"sha": "958656f9a02b8ee6bf1a6ceee71fdd173b9c4010", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "patch": "@@ -4,6 +4,7 @@ use std::fmt;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n use std::ops::{Deref, DerefMut};\n+use std::ptr::NonNull;\n \n /// A `Copy` TaggedPtr.\n ///\n@@ -18,7 +19,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n-    packed: NonZeroUsize,\n+    packed: NonNull<P::Target>,\n     data: PhantomData<(P, T)>,\n }\n \n@@ -53,26 +54,36 @@ where\n     const ASSERTION: () = {\n         assert!(T::BITS <= P::BITS);\n         // Used for the transmute_copy's below\n+        // TODO(waffle): do we need this assert anymore?\n         assert!(std::mem::size_of::<&P::Target>() == std::mem::size_of::<usize>());\n     };\n \n     pub fn new(pointer: P, tag: T) -> Self {\n         // Trigger assert!\n         let () = Self::ASSERTION;\n+\n         let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n \n         Self {\n-            // SAFETY: We know that the pointer is non-null, as it must be\n-            // dereferenceable per `Pointer` safety contract.\n-            packed: unsafe {\n-                NonZeroUsize::new_unchecked((P::into_usize(pointer) >> T::BITS) | packed_tag)\n-            },\n+            packed: P::into_ptr(pointer).map_addr(|addr| {\n+                // SAFETY:\n+                // - The pointer is `NonNull` => it's address is `NonZeroUsize`\n+                // - `P::BITS` least significant bits are always zero (`Pointer` contract)\n+                // - `T::BITS <= P::BITS` (from `Self::ASSERTION`)\n+                //\n+                // Thus `addr >> T::BITS` is guaranteed to be non-zero.\n+                //\n+                // `{non_zero} | packed_tag` can't make the value zero.\n+\n+                let packed = (addr.get() >> T::BITS) | packed_tag;\n+                unsafe { NonZeroUsize::new_unchecked(packed) }\n+            }),\n             data: PhantomData,\n         }\n     }\n \n-    pub(super) fn pointer_raw(&self) -> usize {\n-        self.packed.get() << T::BITS\n+    pub(super) fn pointer_raw(&self) -> NonNull<P::Target> {\n+        self.packed.map_addr(|addr| unsafe { NonZeroUsize::new_unchecked(addr.get() << T::BITS) })\n     }\n \n     pub fn pointer(self) -> P\n@@ -83,35 +94,35 @@ where\n         //\n         // Note that this isn't going to double-drop or anything because we have\n         // P: Copy\n-        unsafe { P::from_usize(self.pointer_raw()) }\n+        unsafe { P::from_ptr(self.pointer_raw()) }\n     }\n \n     pub fn pointer_ref(&self) -> &P::Target {\n         // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+        unsafe { self.pointer_raw().as_ref() }\n     }\n \n     pub fn pointer_mut(&mut self) -> &mut P::Target\n     where\n         P: DerefMut,\n     {\n         // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+        unsafe { self.pointer_raw().as_mut() }\n     }\n \n     #[inline]\n     pub fn tag(&self) -> T {\n-        unsafe { T::from_usize(self.packed.get() >> Self::TAG_BIT_SHIFT) }\n+        unsafe { T::from_usize(self.packed.addr().get() >> Self::TAG_BIT_SHIFT) }\n     }\n \n     #[inline]\n     pub fn set_tag(&mut self, tag: T) {\n-        let mut packed = self.packed.get();\n+        // TODO: refactor packing into a function and reuse it here\n         let new_tag = T::into_usize(tag) << Self::TAG_BIT_SHIFT;\n         let tag_mask = (1 << T::BITS) - 1;\n-        packed &= !(tag_mask << Self::TAG_BIT_SHIFT);\n-        packed |= new_tag;\n-        self.packed = unsafe { NonZeroUsize::new_unchecked(packed) };\n+        self.packed = self.packed.map_addr(|addr| unsafe {\n+            NonZeroUsize::new_unchecked(addr.get() & !(tag_mask << Self::TAG_BIT_SHIFT) | new_tag)\n+        });\n     }\n }\n "}, {"sha": "c734dadefe9be81a76a67c78db684987c903c6f9", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "patch": "@@ -76,7 +76,7 @@ where\n     fn drop(&mut self) {\n         // No need to drop the tag, as it's Copy\n         unsafe {\n-            drop(P::from_usize(self.raw.pointer_raw()));\n+            drop(P::from_ptr(self.raw.pointer_raw()));\n         }\n     }\n }"}, {"sha": "01b5e82cd22666d81ce2953d6ab2ee2b830c53d9", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f4c126027aca4153ba3a6b48c6abc164ef94d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=3c6f4c126027aca4153ba3a6b48c6abc164ef94d", "patch": "@@ -8,7 +8,7 @@ use std::hash::{Hash, Hasher};\n use std::iter;\n use std::mem;\n use std::ops::Deref;\n-use std::ptr;\n+use std::ptr::{self, NonNull};\n use std::slice;\n \n /// `List<T>` is a bit like `&[T]`, but with some critical differences.\n@@ -203,18 +203,16 @@ unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T\n     const BITS: usize = bits_for::<usize>();\n \n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const List<T> as usize\n+    fn into_ptr(self) -> NonNull<List<T>> {\n+        NonNull::from(self)\n     }\n \n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> &'a List<T> {\n-        &*(ptr as *const List<T>)\n+    unsafe fn from_ptr(ptr: NonNull<List<T>>) -> &'a List<T> {\n+        ptr.as_ref()\n     }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        // `Self` is `&'a List<T>` which impls `Copy`, so this is fine.\n-        let ptr = Self::from_usize(ptr);\n-        f(&ptr)\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: NonNull<List<T>>, f: F) -> R {\n+        f(&ptr.as_ref())\n     }\n }"}]}