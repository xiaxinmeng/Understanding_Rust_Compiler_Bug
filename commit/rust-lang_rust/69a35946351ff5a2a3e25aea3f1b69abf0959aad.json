{"sha": "69a35946351ff5a2a3e25aea3f1b69abf0959aad", "node_id": "C_kwDOAAsO6NoAKDY5YTM1OTQ2MzUxZmY1YTJhM2UyNWFlYTNmMWI2OWFiZjA5NTlhYWQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-07T17:20:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T16:37:11Z"}, "message": "Store node_intern_event_id in CurrentDepGraph.", "tree": {"sha": "e2862af8813bddc64334ea37ea2bc28726175348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2862af8813bddc64334ea37ea2bc28726175348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a35946351ff5a2a3e25aea3f1b69abf0959aad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a35946351ff5a2a3e25aea3f1b69abf0959aad", "html_url": "https://github.com/rust-lang/rust/commit/69a35946351ff5a2a3e25aea3f1b69abf0959aad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a35946351ff5a2a3e25aea3f1b69abf0959aad/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd5c10767246dc00b2350b1005ee4b857ce2fe22", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5c10767246dc00b2350b1005ee4b857ce2fe22", "html_url": "https://github.com/rust-lang/rust/commit/bd5c10767246dc00b2350b1005ee4b857ce2fe22"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "a8be1ca34c04f0f0e8cd59a8777d90e15a6eae13", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/69a35946351ff5a2a3e25aea3f1b69abf0959aad/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a35946351ff5a2a3e25aea3f1b69abf0959aad/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=69a35946351ff5a2a3e25aea3f1b69abf0959aad", "patch": "@@ -33,12 +33,6 @@ pub struct DepGraph<K: DepKind> {\n     /// each task has a `DepNodeIndex` that uniquely identifies it. This unique\n     /// ID is used for self-profiling.\n     virtual_dep_node_index: Lrc<AtomicU32>,\n-\n-    /// The cached event id for profiling node interning. This saves us\n-    /// from having to look up the event id every time we intern a node\n-    /// which may incur too much overhead.\n-    /// This will be None if self-profiling is disabled.\n-    node_intern_event_id: Option<EventId>,\n }\n \n rustc_index::newtype_index! {\n@@ -116,8 +110,13 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n-        let current =\n-            CurrentDepGraph::new(prev_graph_node_count, encoder, record_graph, record_stats);\n+        let current = CurrentDepGraph::new(\n+            profiler,\n+            prev_graph_node_count,\n+            encoder,\n+            record_graph,\n+            record_stats,\n+        );\n \n         // Instantiate a dependy-less node only once for anonymous queries.\n         let _green_node_index = current.intern_new_node(\n@@ -128,10 +127,6 @@ impl<K: DepKind> DepGraph<K> {\n         );\n         debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n \n-        let node_intern_event_id = profiler\n-            .get_or_alloc_cached_string(\"incr_comp_intern_dep_graph_node\")\n-            .map(EventId::from_label);\n-\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n@@ -142,16 +137,11 @@ impl<K: DepKind> DepGraph<K> {\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n             })),\n             virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n-            node_intern_event_id,\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph<K> {\n-        DepGraph {\n-            data: None,\n-            virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n-            node_intern_event_id: None,\n-        }\n+        DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n@@ -275,9 +265,6 @@ impl<K: DepKind> DepGraph<K> {\n \n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n-        // Get timer for profiling `DepNode` interning\n-        let node_intern_timer =\n-            self.node_intern_event_id.map(|eid| dcx.profiler().generic_activity_with_event_id(eid));\n         // Intern the new `DepNode`.\n         let (dep_node_index, prev_and_color) = data.current.intern_node(\n             dcx.profiler(),\n@@ -287,7 +274,6 @@ impl<K: DepKind> DepGraph<K> {\n             current_fingerprint,\n             print_status,\n         );\n-        drop(node_intern_timer);\n \n         hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -876,10 +862,17 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     /// debugging and only active with `debug_assertions`.\n     total_read_count: AtomicU64,\n     total_duplicate_read_count: AtomicU64,\n+\n+    /// The cached event id for profiling node interning. This saves us\n+    /// from having to look up the event id every time we intern a node\n+    /// which may incur too much overhead.\n+    /// This will be None if self-profiling is disabled.\n+    node_intern_event_id: Option<EventId>,\n }\n \n impl<K: DepKind> CurrentDepGraph<K> {\n     fn new(\n+        profiler: &SelfProfilerRef,\n         prev_graph_node_count: usize,\n         encoder: FileEncoder,\n         record_graph: bool,\n@@ -908,6 +901,10 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n         let new_node_count_estimate = 102 * prev_graph_node_count / 100 + 200;\n \n+        let node_intern_event_id = profiler\n+            .get_or_alloc_cached_string(\"incr_comp_intern_dep_graph_node\")\n+            .map(EventId::from_label);\n+\n         CurrentDepGraph {\n             encoder: Steal::new(GraphEncoder::new(\n                 encoder,\n@@ -927,6 +924,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n+            node_intern_event_id,\n         }\n     }\n \n@@ -970,6 +968,10 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n         let print_status = cfg!(debug_assertions) && print_status;\n \n+        // Get timer for profiling `DepNode` interning\n+        let _node_intern_timer =\n+            self.node_intern_event_id.map(|eid| profiler.generic_activity_with_event_id(eid));\n+\n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n             // Determine the color and index of the new `DepNode`.\n             if let Some(fingerprint) = fingerprint {"}]}