{"sha": "7e114b200abccb7dcbc03c47585828716dfc0f4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMTE0YjIwMGFiY2NiN2RjYmMwM2M0NzU4NTgyODcxNmRmYzBmNGE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-01T23:42:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:16Z"}, "message": "std: impl of net::tcp::write and make net::tcp::tcp_socket a resource", "tree": {"sha": "15bae3f73b0f4dff76bbe80929399d4795e861f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15bae3f73b0f4dff76bbe80929399d4795e861f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e114b200abccb7dcbc03c47585828716dfc0f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e114b200abccb7dcbc03c47585828716dfc0f4a", "html_url": "https://github.com/rust-lang/rust/commit/7e114b200abccb7dcbc03c47585828716dfc0f4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e114b200abccb7dcbc03c47585828716dfc0f4a/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5590dfc85775259a3ba313c75d88db0b7e2bd708", "url": "https://api.github.com/repos/rust-lang/rust/commits/5590dfc85775259a3ba313c75d88db0b7e2bd708", "html_url": "https://github.com/rust-lang/rust/commit/5590dfc85775259a3ba313c75d88db0b7e2bd708"}], "stats": {"total": 144, "additions": 126, "deletions": 18}, "files": [{"sha": "7f20af65366a6ac9f93b3eb8f615713114bd5af9", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 126, "deletions": 18, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7e114b200abccb7dcbc03c47585828716dfc0f4a/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e114b200abccb7dcbc03c47585828716dfc0f4a/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=7e114b200abccb7dcbc03c47585828716dfc0f4a", "patch": "@@ -4,18 +4,38 @@ High-level interface to libuv's TCP functionality\n \n import ip = net_ip;\n \n-export tcp_connect_result;\n-export connect;\n+export tcp_connect_result, tcp_write_result;\n+export connect, write;\n \n-enum tcp_socket {\n-    valid_tcp_socket(@tcp_socket_data)\n+resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n+    let closed_po = comm::port::<()>();\n+    let closed_ch = comm::chan(closed_po);\n+    let close_data = {\n+        closed_ch: closed_ch\n+    };\n+    let close_data_ptr = ptr::addr_of(close_data);\n+    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n+    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n+            stream_handle_ptr, loop_ptr));\n+        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                       close_data_ptr);\n+        uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n+    };\n+    comm::recv(closed_po);\n+    log(debug, \"exiting dtor for tcp_socket\");\n }\n \n enum tcp_connect_result {\n     tcp_connected(tcp_socket),\n     tcp_connect_error(uv::ll::uv_err_data)\n }\n \n+enum tcp_write_result {\n+    tcp_write_success,\n+    tcp_write_error(uv::ll::uv_err_data)\n+}\n+\n #[doc=\"\n Initiate a client connection over TCP/IP\n \n@@ -37,19 +57,19 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n         closed_signal_ch: comm::chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n+    let hl_loop = uv::global_loop::get();\n     let socket_data = @{\n         reader_port: comm::port::<[u8]>(),\n         stream_handle : uv::ll::tcp_t(),\n         connect_req : uv::ll::connect_t(),\n-        write_req : uv::ll::write_t()\n+        write_req : uv::ll::write_t(),\n+        hl_loop: hl_loop\n     };\n     log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n     let socket_data_ptr: *tcp_socket_data =\n         ptr::addr_of(*socket_data);\n-    // in we go!\n-    let hl_loop = uv::global_loop::get();\n     log(debug, #fmt(\"stream_handl_ptr outside interact %?\",\n         ptr::addr_of((*socket_data_ptr).stream_handle)));\n     uv::hl::interact(hl_loop) {|loop_ptr|\n@@ -113,7 +133,7 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n     alt comm::recv(result_po) {\n       conn_success {\n         log(debug, \"tcp::connect - received success on result_po\");\n-        tcp_connected(valid_tcp_socket(socket_data))\n+        tcp_connected(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n@@ -122,7 +142,87 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n       }\n     }\n }\n+\n+#[doc=\"\n+Write binary data to a tcp stream\n+\"]\n+fn write(sock: tcp_socket, raw_write_data: [[u8]]) -> tcp_write_result\n+    unsafe {\n+    let socket_data_ptr = ptr::addr_of(**sock);\n+    let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n+    let stream_handle_ptr =\n+        ptr::addr_of((*socket_data_ptr).stream_handle);\n+    let write_buf_vec = iter::map_to_vec(raw_write_data) {|raw_bytes|\n+        uv::ll::buf_init(vec::unsafe::to_ptr(raw_bytes),\n+                         vec::len(raw_bytes))\n+    };\n+    let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n+    let result_po = comm::port::<tcp_write_result>();\n+    let write_data = {\n+        result_ch: comm::chan(result_po)\n+    };\n+    let write_data_ptr = ptr::addr_of(write_data);\n+    uv::hl::interact((*socket_data_ptr).hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n+        alt uv::ll::write(write_req_ptr,\n+                          stream_handle_ptr,\n+                          write_buf_vec_ptr,\n+                          tcp_write_complete_cb) {\n+          0i32 {\n+            log(debug, \"uv_write() invoked successfully\");\n+            uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n+          }\n+          _ {\n+            log(debug, \"error invoking uv_write()\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send((*write_data_ptr).result_ch,\n+                       tcp_write_error(err_data));\n+          }\n+        }\n+    };\n+    comm::recv(result_po)\n+}\n+\n+\n+\n // INTERNAL API\n+\n+type tcp_socket_close_data = {\n+    closed_ch: comm::chan<()>\n+};\n+\n+crust fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+    let data = uv::ll::get_data_for_uv_handle(handle)\n+        as *tcp_socket_close_data;\n+    let closed_ch = (*data).closed_ch;\n+    comm::send(closed_ch, ());\n+    log(debug, \"tcp_socket_dtor_close_cb exiting..\");\n+}\n+\n+crust fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n+                              status: libc::c_int) unsafe {\n+    let write_data_ptr = uv::ll::get_data_for_req(write_req)\n+        as *write_req_data;\n+    alt status {\n+      0i32 {\n+        log(debug, \"successful write complete\");\n+        comm::send((*write_data_ptr).result_ch, tcp_write_success);\n+      }\n+      _ {\n+        let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n+            write_req);\n+        let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n+        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+        log(debug, \"failure to write\");\n+        comm::send((*write_data_ptr).result_ch, tcp_write_error(err_data));\n+      }\n+    }\n+}\n+\n+type write_req_data = {\n+    result_ch: comm::chan<tcp_write_result>\n+};\n+\n type connect_req_data = {\n     result_ch: comm::chan<conn_attempt>,\n     closed_signal_ch: comm::chan<()>\n@@ -177,7 +277,8 @@ type tcp_socket_data = {\n     reader_port: comm::port<[u8]>,\n     stream_handle: uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n-    write_req: uv::ll::uv_write_t\n+    write_req: uv::ll::uv_write_t,\n+    hl_loop: uv::hl::high_level_loop\n };\n \n // convert rust ip_addr to libuv's native representation\n@@ -190,10 +291,10 @@ fn ipv4_ip_addr_to_sockaddr_in(input: ip::ip_addr,\n mod test {\n     #[test]\n     fn test_gl_tcp_ipv4_request() {\n-        let ip_str = \"127.0.0.1\";\n+        let ip_str = \"173.194.79.99\";\n         let port = 80u;\n         let expected_read_msg = \"foo\";\n-        let actual_write_msg = \"bar\";\n+        let actual_write_msg = \"GET / HTTP/1.1\\r\\n\\r\\n\";\n         let host_ip = ip::v4::parse_addr(ip_str);\n \n         let data_po = comm::port::<[u8]>();\n@@ -202,12 +303,16 @@ mod test {\n         alt connect(host_ip, port) {\n           tcp_connected(sock) {\n             log(debug, \"successful tcp connect\");\n-            /*\n-            let write_data = str::as_buf(actual_write_msg);\n-            alt write(sock, [write_data]) {\n+            let mut write_data: [[u8]] = [];\n+            let write_data = [str::as_bytes(actual_write_msg) {|str_bytes|\n+                str_bytes\n+            }];\n+            alt write(sock, write_data) {\n               tcp_write_success {\n+                log(debug, \"tcp::write successful\");\n+                /*\n                 let mut total_read_data: [u8] = [];\n-                let reader_po = read_start(sock);nyw\n+                let reader_po = read_start(sock);\n                 loop {\n                     alt comm::recv(reader_po) {\n                       new_read_data(data) {\n@@ -228,12 +333,15 @@ mod test {\n                     }\n                 }\n                 comm::send(data_ch, total_read_data);\n+                */\n               }\n-              tcp_write_error {\n-                fail \"error during write attempt.. FIXME need err info\";\n+              tcp_write_error(err_data) {\n+                log(debug, \"tcp_write_error received..\");\n+                log(debug, #fmt(\"tcp write error: %? %?\", err_data.err_name,\n+                               err_data.err_msg));\n+                assert false;\n               }\n             }\n-            */\n           }\n           tcp_connect_error(err_data) {\n             log(debug, \"tcp_connect_error received..\");"}]}