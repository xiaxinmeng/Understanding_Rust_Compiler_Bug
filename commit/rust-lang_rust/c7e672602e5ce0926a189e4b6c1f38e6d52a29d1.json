{"sha": "c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZTY3MjYwMmU1Y2UwOTI2YTE4OWU0YjZjMWYzOGU2ZDUyYTI5ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-24T09:26:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-24T09:26:06Z"}, "message": "auto merge of #9453 : pnkfelix/rust/fsk-further-syntax-visit-refactors, r=alexcrichton\n\nr? anyone.\r\n\r\nPart of #7081.\r\n\r\nMore refactorings of the syntax::visit::Visitor implementations, folding so-called \"environments\" into the visitor impl when the latter was previously a trivial unit struct.\r\n\r\nAs usual, this refactoring only applies when the environments are not actually carrying state that is meant to be pushed and popped as we traverse the expression.  (For an example where the environment *isn't* just passed through, see the `visit_fn` in `liveness.rs`.)\r\n\r\nGot rid of a bit of @-allocation in borrowck.\r\n\r\nBoth cases should be pure-refactorings.", "tree": {"sha": "51d10cd3e439d18a758e9ddf2c3555e227a72143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51d10cd3e439d18a758e9ddf2c3555e227a72143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "html_url": "https://github.com/rust-lang/rust/commit/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0275b1c4047c9213a3f55b36ab690ebedff3a4d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0275b1c4047c9213a3f55b36ab690ebedff3a4d5", "html_url": "https://github.com/rust-lang/rust/commit/0275b1c4047c9213a3f55b36ab690ebedff3a4d5"}, {"sha": "4f691cd5bc83311da1b91b6e5da54e5514440749", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f691cd5bc83311da1b91b6e5da54e5514440749", "html_url": "https://github.com/rust-lang/rust/commit/4f691cd5bc83311da1b91b6e5da54e5514440749"}], "stats": {"total": 267, "additions": 123, "deletions": 144}, "files": [{"sha": "e8e658abc3745404e6112472a249c9fc89f5d0e8", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -33,7 +33,7 @@ use util::ppaux::Repr;\n \n #[deriving(Clone)]\n struct CheckLoanCtxt<'self> {\n-    bccx: @BorrowckCtxt,\n+    bccx: &'self BorrowckCtxt,\n     dfcx_loans: &'self LoanDataFlow,\n     move_data: @move_data::FlowedMoveData,\n     all_loans: &'self [Loan],\n@@ -60,7 +60,7 @@ impl<'self> Visitor<()> for CheckLoanCtxt<'self> {\n     }\n }\n \n-pub fn check_loans(bccx: @BorrowckCtxt,\n+pub fn check_loans(bccx: &BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],"}, {"sha": "549a7fe195c8861c5a5bfdf6a8d9cdb9d7423b2a", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -22,7 +22,7 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use util::ppaux::{UserString};\n \n-pub fn gather_decl(bccx: @BorrowckCtxt,\n+pub fn gather_decl(bccx: &BorrowckCtxt,\n                    move_data: &mut MoveData,\n                    decl_id: ast::NodeId,\n                    _decl_span: Span,\n@@ -31,23 +31,23 @@ pub fn gather_decl(bccx: @BorrowckCtxt,\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n-pub fn gather_move_from_expr(bccx: @BorrowckCtxt,\n+pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &mut MoveData,\n                              move_expr: @ast::Expr,\n                              cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n                                  MoveExpr(move_expr), cmt);\n }\n \n-pub fn gather_move_from_pat(bccx: @BorrowckCtxt,\n+pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_data: &mut MoveData,\n                             move_pat: @ast::Pat,\n                             cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n                                  MovePat(move_pat), cmt);\n }\n \n-fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n+fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n                                 move_data: &mut MoveData,\n                                 move_id: ast::NodeId,\n                                 move_kind: MoveKind,\n@@ -66,7 +66,7 @@ fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n     }\n }\n \n-pub fn gather_captures(bccx: @BorrowckCtxt,\n+pub fn gather_captures(bccx: &BorrowckCtxt,\n                        move_data: &mut MoveData,\n                        closure_expr: @ast::Expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n@@ -83,7 +83,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n     }\n }\n \n-pub fn gather_assignment(bccx: @BorrowckCtxt,\n+pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          move_data: &mut MoveData,\n                          assignment_id: ast::NodeId,\n                          assignment_span: Span,\n@@ -96,7 +96,7 @@ pub fn gather_assignment(bccx: @BorrowckCtxt,\n                              assignee_id);\n }\n \n-fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n+fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {"}, {"sha": "2d71eef4de9c11f6b8ff490cbdc88220d879604d", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -20,7 +20,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{note_and_explain_region};\n \n-pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n+pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n                           span: Span,\n@@ -42,8 +42,8 @@ pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct GuaranteeLifetimeContext {\n-    bccx: @BorrowckCtxt,\n+struct GuaranteeLifetimeContext<'self> {\n+    bccx: &'self BorrowckCtxt,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -58,7 +58,7 @@ struct GuaranteeLifetimeContext {\n     cmt_original: mc::cmt\n }\n \n-impl GuaranteeLifetimeContext {\n+impl<'self> GuaranteeLifetimeContext<'self> {\n     fn tcx(&self) -> ty::ctxt {\n         self.bccx.tcx\n     }"}, {"sha": "4c52634144688cd3ae431470e8f20e9e8a3279ad", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -64,16 +64,16 @@ mod gather_moves;\n /// No good.  Instead what will happen is that `root_ub` will be set to the\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n-struct GatherLoanCtxt {\n-    bccx: @BorrowckCtxt,\n+struct GatherLoanCtxt<'self> {\n+    bccx: &'self BorrowckCtxt,\n     id_range: id_range,\n     move_data: @mut move_data::MoveData,\n     all_loans: @mut ~[Loan],\n     item_ub: ast::NodeId,\n     repeating_ids: ~[ast::NodeId]\n }\n \n-impl visit::Visitor<()> for GatherLoanCtxt {\n+impl<'self> visit::Visitor<()> for GatherLoanCtxt<'self> {\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n         gather_loans_in_expr(self, ex);\n     }\n@@ -100,7 +100,7 @@ impl visit::Visitor<()> for GatherLoanCtxt {\n     fn visit_item(&mut self, _:@ast::item, _:()) { }\n }\n \n-pub fn gather_loans(bccx: @BorrowckCtxt,\n+pub fn gather_loans(bccx: &BorrowckCtxt,\n                     decl: &ast::fn_decl,\n                     body: &ast::Block)\n                     -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n@@ -315,7 +315,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n }\n \n-impl GatherLoanCtxt {\n+impl<'self> GatherLoanCtxt<'self> {\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn push_repeating_id(&mut self, id: ast::NodeId) {\n@@ -532,7 +532,7 @@ impl GatherLoanCtxt {\n             //    }\n         // }\n \n-        fn check_mutability(bccx: @BorrowckCtxt,\n+        fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n                             cmt: mc::cmt,\n                             req_mutbl: LoanMutability) {"}, {"sha": "7dbcb90327fca881703c963fdee3e672b5e64862", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -23,7 +23,7 @@ pub enum RestrictionResult {\n     SafeIf(@LoanPath, ~[Restriction])\n }\n \n-pub fn compute_restrictions(bccx: @BorrowckCtxt,\n+pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n                             cmt: mc::cmt,\n                             restr: RestrictionSet) -> RestrictionResult {\n@@ -39,13 +39,13 @@ pub fn compute_restrictions(bccx: @BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct RestrictionsContext {\n-    bccx: @BorrowckCtxt,\n+struct RestrictionsContext<'self> {\n+    bccx: &'self BorrowckCtxt,\n     span: Span,\n     cmt_original: mc::cmt\n }\n \n-impl RestrictionsContext {\n+impl<'self> RestrictionsContext<'self> {\n     fn tcx(&self) -> ty::ctxt {\n         self.bccx.tcx\n     }"}, {"sha": "852f1a53303f860634d7a8f7a61db3899ca60a8e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -61,12 +61,10 @@ impl Clone for LoanDataFlowOperator {\n \n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n-struct BorrowckVisitor;\n-\n-impl Visitor<@BorrowckCtxt> for BorrowckVisitor {\n+impl Visitor<()> for BorrowckCtxt {\n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, e:@BorrowckCtxt) {\n-        borrowck_fn(self, fk, fd, b, s, n, e);\n+                b:&Block, s:Span, n:NodeId, _:()) {\n+        borrowck_fn(self, fk, fd, b, s, n);\n     }\n }\n \n@@ -78,7 +76,7 @@ pub fn check_crate(\n     capture_map: moves::CaptureMap,\n     crate: &ast::Crate) -> (root_map, write_guard_map)\n {\n-    let bccx = @BorrowckCtxt {\n+    let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         method_map: method_map,\n         moves_map: moves_map,\n@@ -96,9 +94,9 @@ pub fn check_crate(\n             guaranteed_paths: 0,\n         }\n     };\n+    let bccx = &mut bccx;\n \n-    let mut v = BorrowckVisitor;\n-    visit::walk_crate(&mut v, crate, bccx);\n+    visit::walk_crate(bccx, crate, ());\n \n     if tcx.sess.borrowck_stats() {\n         io::println(\"--- borrowck stats ---\");\n@@ -116,20 +114,19 @@ pub fn check_crate(\n \n     return (bccx.root_map, bccx.write_guard_map);\n \n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n+    fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.stats.guaranteed_paths as float;\n         fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n     }\n }\n \n-fn borrowck_fn(v: &mut BorrowckVisitor,\n+fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: &visit::fn_kind,\n                decl: &ast::fn_decl,\n                body: &ast::Block,\n                sp: Span,\n-               id: ast::NodeId,\n-               this: @BorrowckCtxt) {\n+               id: ast::NodeId) {\n     match fk {\n         &visit::fk_anon(*) |\n         &visit::fk_fn_block(*) => {\n@@ -166,7 +163,7 @@ fn borrowck_fn(v: &mut BorrowckVisitor,\n         }\n     }\n \n-    visit::walk_fn(v, fk, decl, body, sp, id, this);\n+    visit::walk_fn(this, fk, decl, body, sp, id, ());\n }\n \n // ----------------------------------------------------------------------"}, {"sha": "331bd25e359ed0a6cb5fd8111e7d7d1c8b060682", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -375,8 +375,6 @@ enum AnyVisitor {\n     NewVisitor(@mut visit::Visitor<()>),\n }\n \n-type VCObj = @mut Visitor<@mut Context>;\n-\n struct Context {\n     // All known lint modes (string versions)\n     dict: @LintDict,"}, {"sha": "b7bdb9a1e5d66a6e9fecf4a07c7358278fa1119b", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 90, "deletions": 106, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e672602e5ce0926a189e4b6c1f38e6d52a29d1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=c7e672602e5ce0926a189e4b6c1f38e6d52a29d1", "patch": "@@ -191,27 +191,24 @@ enum UseMode {\n     Read         // Read no matter what the type.\n }\n \n-struct ComputeModesVisitor;\n-\n-impl visit::Visitor<VisitContext> for ComputeModesVisitor {\n+impl visit::Visitor<()> for VisitContext {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, e:VisitContext) {\n-        compute_modes_for_fn(*self, fk, fd, b, s, n, e);\n+                b:&Block, s:Span, n:NodeId, _:()) {\n+        compute_modes_for_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, e:VisitContext) {\n-        compute_modes_for_expr(*self, ex, e);\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+        compute_modes_for_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l:@Local, e:VisitContext) {\n-        compute_modes_for_local(*self, l, e);\n+    fn visit_local(&mut self, l:@Local, _:()) {\n+        compute_modes_for_local(self, l);\n     }\n }\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n                      crate: &Crate) -> MoveMaps\n {\n-    let mut visitor = ComputeModesVisitor;\n-    let visit_cx = VisitContext {\n+    let mut visit_cx = VisitContext {\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n@@ -220,7 +217,8 @@ pub fn compute_moves(tcx: ty::ctxt,\n             moved_variables_set: @mut HashSet::new()\n         }\n     };\n-    visit::walk_crate(&mut visitor, crate, visit_cx);\n+    let visit_cx = &mut visit_cx;\n+    visit::walk_crate(visit_cx, crate, ());\n     return visit_cx.move_maps;\n }\n \n@@ -238,44 +236,40 @@ pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n ///////////////////////////////////////////////////////////////////////////\n // Expressions\n \n-fn compute_modes_for_local<'a>(v: ComputeModesVisitor,\n-                               local: @Local,\n-                               cx: VisitContext) {\n+fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n+                               local: @Local) {\n     cx.use_pat(local.pat);\n     for &init in local.init.iter() {\n-        cx.use_expr(init, Read, v);\n+        cx.use_expr(init, Read);\n     }\n }\n \n-fn compute_modes_for_fn(v: ComputeModesVisitor,\n+fn compute_modes_for_fn(cx: &mut VisitContext,\n                         fk: &visit::fn_kind,\n                         decl: &fn_decl,\n                         body: &Block,\n                         span: Span,\n-                        id: NodeId,\n-                        cx: VisitContext) {\n-    let mut v = v;\n+                        id: NodeId) {\n     for a in decl.inputs.iter() {\n         cx.use_pat(a.pat);\n     }\n-    visit::walk_fn(&mut v, fk, decl, body, span, id, cx);\n+    visit::walk_fn(cx, fk, decl, body, span, id, ());\n }\n \n-fn compute_modes_for_expr(v: ComputeModesVisitor,\n-                          expr: @Expr,\n-                          cx: VisitContext)\n+fn compute_modes_for_expr(cx: &mut VisitContext,\n+                          expr: @Expr)\n {\n-    cx.consume_expr(expr, v);\n+    cx.consume_expr(expr);\n }\n \n impl VisitContext {\n-    pub fn consume_exprs(&self, exprs: &[@Expr], visitor: ComputeModesVisitor) {\n+    pub fn consume_exprs(&mut self, exprs: &[@Expr]) {\n         for expr in exprs.iter() {\n-            self.consume_expr(*expr, visitor);\n+            self.consume_expr(*expr);\n         }\n     }\n \n-    pub fn consume_expr(&self, expr: @Expr, visitor: ComputeModesVisitor) {\n+    pub fn consume_expr(&mut self, expr: @Expr) {\n         /*!\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -287,13 +281,13 @@ impl VisitContext {\n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n             self.move_maps.moves_map.insert(expr.id);\n-            self.use_expr(expr, Move, visitor);\n+            self.use_expr(expr, Move);\n         } else {\n-            self.use_expr(expr, Read, visitor);\n+            self.use_expr(expr, Read);\n         };\n     }\n \n-    pub fn consume_block(&self, blk: &Block, visitor: ComputeModesVisitor) {\n+    pub fn consume_block(&mut self, blk: &Block) {\n         /*!\n          * Indicates that the value of `blk` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -302,19 +296,17 @@ impl VisitContext {\n         debug!(\"consume_block(blk.id=%?)\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n-            let mut v = visitor;\n-            v.visit_stmt(*stmt, *self);\n+            self.visit_stmt(*stmt, ());\n         }\n \n         for tail_expr in blk.expr.iter() {\n-            self.consume_expr(*tail_expr, visitor);\n+            self.consume_expr(*tail_expr);\n         }\n     }\n \n-    pub fn use_expr(&self,\n+    pub fn use_expr(&mut self,\n                     expr: @Expr,\n-                    expr_mode: UseMode,\n-                    visitor: ComputeModesVisitor) {\n+                    expr_mode: UseMode) {\n         /*!\n          * Indicates that `expr` is used with a given mode.  This will\n          * in turn trigger calls to the subcomponents of `expr`.\n@@ -351,25 +343,23 @@ impl VisitContext {\n             }\n \n             ExprUnary(_, UnDeref, base) => {       // *base\n-                if !self.use_overloaded_operator(\n-                    expr, base, [], visitor)\n+                if !self.use_overloaded_operator(expr, base, [])\n                 {\n                     // Moving out of *base moves out of base.\n-                    self.use_expr(base, comp_mode, visitor);\n+                    self.use_expr(base, comp_mode);\n                 }\n             }\n \n             ExprField(base, _, _) => {        // base.f\n                 // Moving out of base.f moves out of base.\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprIndex(_, lhs, rhs) => {          // lhs[rhs]\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [rhs], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n-                    self.use_expr(lhs, comp_mode, visitor);\n-                    self.consume_expr(rhs, visitor);\n+                    self.use_expr(lhs, comp_mode);\n+                    self.consume_expr(rhs);\n                 }\n             }\n \n@@ -394,20 +384,20 @@ impl VisitContext {\n                 if mode == Move {\n                     self.move_maps.moves_map.insert(callee.id);\n                 }\n-                self.use_expr(callee, mode, visitor);\n-                self.use_fn_args(callee.id, *args, visitor);\n+                self.use_expr(callee, mode);\n+                self.use_fn_args(callee.id, *args);\n             }\n \n             ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n-                self.use_receiver(rcvr, visitor);\n-                self.use_fn_args(callee_id, *args, visitor);\n+                self.use_receiver(rcvr);\n+                self.use_fn_args(callee_id, *args);\n             }\n \n             ExprStruct(_, ref fields, opt_with) => {\n                 for field in fields.iter() {\n-                    self.consume_expr(field.expr, visitor);\n+                    self.consume_expr(field.expr);\n                 }\n \n                 for with_expr in opt_with.iter() {\n@@ -449,50 +439,50 @@ impl VisitContext {\n                                                          which defines the `Drop` trait\",\n                                                         with_ty.user_string(self.tcx)));\n                         }\n-                        self.consume_expr(*with_expr, visitor);\n+                        self.consume_expr(*with_expr);\n                     } else {\n-                        self.use_expr(*with_expr, Read, visitor);\n+                        self.use_expr(*with_expr, Read);\n                     }\n                 }\n             }\n \n             ExprTup(ref exprs) => {\n-                self.consume_exprs(*exprs, visitor);\n+                self.consume_exprs(*exprs);\n             }\n \n             ExprIf(cond_expr, ref then_blk, opt_else_expr) => {\n-                self.consume_expr(cond_expr, visitor);\n-                self.consume_block(then_blk, visitor);\n+                self.consume_expr(cond_expr);\n+                self.consume_block(then_blk);\n                 for else_expr in opt_else_expr.iter() {\n-                    self.consume_expr(*else_expr, visitor);\n+                    self.consume_expr(*else_expr);\n                 }\n             }\n \n             ExprMatch(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n                 for arm in arms.iter() {\n-                    self.consume_arm(arm, visitor);\n+                    self.consume_arm(arm);\n                 }\n \n                 // The discriminant may, in fact, be partially moved\n                 // if there are by-move bindings, but borrowck deals\n                 // with that itself.\n-                self.use_expr(discr, Read, visitor);\n+                self.use_expr(discr, Read);\n             }\n \n             ExprParen(base) => {\n                 // Note: base is not considered a *component* here, so\n                 // use `expr_mode` not `comp_mode`.\n-                self.use_expr(base, expr_mode, visitor);\n+                self.use_expr(base, expr_mode);\n             }\n \n             ExprVec(ref exprs, _) => {\n-                self.consume_exprs(*exprs, visitor);\n+                self.consume_exprs(*exprs);\n             }\n \n             ExprAddrOf(_, base) => {   // &base\n-                self.use_expr(base, Read, visitor);\n+                self.use_expr(base, Read);\n             }\n \n             ExprLogLevel |\n@@ -502,70 +492,67 @@ impl VisitContext {\n             ExprLit(*) => {}\n \n             ExprLoop(ref blk, _) => {\n-                self.consume_block(blk, visitor);\n+                self.consume_block(blk);\n             }\n \n             ExprWhile(cond_expr, ref blk) => {\n-                self.consume_expr(cond_expr, visitor);\n-                self.consume_block(blk, visitor);\n+                self.consume_expr(cond_expr);\n+                self.consume_block(blk);\n             }\n \n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [])\n                 {\n-                    self.consume_expr(lhs, visitor);\n+                    self.consume_expr(lhs);\n                 }\n             }\n \n             ExprBinary(_, _, lhs, rhs) => {\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [rhs], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n-                    self.consume_expr(lhs, visitor);\n-                    self.consume_expr(rhs, visitor);\n+                    self.consume_expr(lhs);\n+                    self.consume_expr(rhs);\n                 }\n             }\n \n             ExprBlock(ref blk) => {\n-                self.consume_block(blk, visitor);\n+                self.consume_block(blk);\n             }\n \n             ExprRet(ref opt_expr) => {\n                 for expr in opt_expr.iter() {\n-                    self.consume_expr(*expr, visitor);\n+                    self.consume_expr(*expr);\n                 }\n             }\n \n             ExprAssign(lhs, rhs) => {\n-                self.use_expr(lhs, Read, visitor);\n-                self.consume_expr(rhs, visitor);\n+                self.use_expr(lhs, Read);\n+                self.consume_expr(rhs);\n             }\n \n             ExprCast(base, _) => {\n-                self.consume_expr(base, visitor);\n+                self.consume_expr(base);\n             }\n \n             ExprAssignOp(_, _, lhs, rhs) => {\n                 // FIXME(#4712) --- Overloaded operators?\n                 //\n-                // if !self.use_overloaded_operator(\n-                //     expr, DoDerefArgs, lhs, [rhs], visitor)\n+                // if !self.use_overloaded_operator(expr, DoDerefArgs, lhs, [rhs])\n                 // {\n-                self.consume_expr(lhs, visitor);\n-                self.consume_expr(rhs, visitor);\n+                self.consume_expr(lhs);\n+                self.consume_expr(rhs);\n                 // }\n             }\n \n             ExprRepeat(base, count, _) => {\n-                self.consume_expr(base, visitor);\n-                self.consume_expr(count, visitor);\n+                self.consume_expr(base);\n+                self.consume_expr(count);\n             }\n \n             ExprDoBody(base) => {\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprFnBlock(ref decl, ref body) => {\n@@ -574,11 +561,11 @@ impl VisitContext {\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n                 self.move_maps.capture_map.insert(expr.id, cap_vars);\n-                self.consume_block(body, visitor);\n+                self.consume_block(body);\n             }\n \n             ExprVstore(base, _) => {\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprMac(*) => {\n@@ -589,40 +576,39 @@ impl VisitContext {\n         }\n     }\n \n-    pub fn use_overloaded_operator(&self,\n+    pub fn use_overloaded_operator(&mut self,\n                                    expr: &Expr,\n                                    receiver_expr: @Expr,\n-                                   arg_exprs: &[@Expr],\n-                                   visitor: ComputeModesVisitor)\n+                                   arg_exprs: &[@Expr])\n                                    -> bool {\n         if !self.method_map.contains_key(&expr.id) {\n             return false;\n         }\n \n-        self.use_receiver(receiver_expr, visitor);\n+        self.use_receiver(receiver_expr);\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n         for arg_expr in arg_exprs.iter() {\n-            self.use_expr(*arg_expr, Read, visitor);\n+            self.use_expr(*arg_expr, Read);\n         }\n \n         return true;\n     }\n \n-    pub fn consume_arm(&self, arm: &Arm, visitor: ComputeModesVisitor) {\n+    pub fn consume_arm(&mut self, arm: &Arm) {\n         for pat in arm.pats.iter() {\n             self.use_pat(*pat);\n         }\n \n         for guard in arm.guard.iter() {\n-            self.consume_expr(*guard, visitor);\n+            self.consume_expr(*guard);\n         }\n \n-        self.consume_block(&arm.body, visitor);\n+        self.consume_block(&arm.body);\n     }\n \n-    pub fn use_pat(&self, pat: @Pat) {\n+    pub fn use_pat(&mut self, pat: @Pat) {\n         /*!\n          *\n          * Decides whether each binding in a pattern moves the value\n@@ -651,28 +637,26 @@ impl VisitContext {\n         }\n     }\n \n-    pub fn use_receiver(&self,\n-                        receiver_expr: @Expr,\n-                        visitor: ComputeModesVisitor) {\n-        self.use_fn_arg(receiver_expr, visitor);\n+    pub fn use_receiver(&mut self,\n+                        receiver_expr: @Expr) {\n+        self.use_fn_arg(receiver_expr);\n     }\n \n-    pub fn use_fn_args(&self,\n+    pub fn use_fn_args(&mut self,\n                        _: NodeId,\n-                       arg_exprs: &[@Expr],\n-                       visitor: ComputeModesVisitor) {\n+                       arg_exprs: &[@Expr]) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {\n-            self.use_fn_arg(*arg_expr, visitor);\n+            self.use_fn_arg(*arg_expr);\n         }\n     }\n \n-    pub fn use_fn_arg(&self, arg_expr: @Expr, visitor: ComputeModesVisitor) {\n+    pub fn use_fn_arg(&mut self, arg_expr: @Expr) {\n         //! Uses the argument.\n-        self.consume_expr(arg_expr, visitor)\n+        self.consume_expr(arg_expr)\n     }\n \n-    pub fn arms_have_by_move_bindings(&self,\n+    pub fn arms_have_by_move_bindings(&mut self,\n                                       moves_map: MovesMap,\n                                       arms: &[Arm])\n                                       -> Option<@Pat> {\n@@ -693,7 +677,7 @@ impl VisitContext {\n         ret\n     }\n \n-    pub fn compute_captures(&self, fn_expr_id: NodeId) -> @[CaptureVar] {\n+    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n         debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n         let _indenter = indenter();\n "}]}