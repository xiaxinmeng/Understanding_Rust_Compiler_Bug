{"sha": "5a2a97c7e8cfac690a00505d8644be30f7ee863a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMmE5N2M3ZThjZmFjNjkwYTAwNTA1ZDg2NDRiZTMwZjdlZTg2M2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-17T15:57:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T15:57:02Z"}, "message": "Merge #1694\n\n1694: Implement initial type-inference support for Index r=flodiebold a=matklad\n\nThis doesn't actually infer indexing types, but at least it walks sub-expressions!\r\n\r\nInitially, I wanted to make `Index` just a new kind of `BinOp` (b/c indexing is kind of a binary op), so I've refactoring binop handing a bit.\r\n\r\nHowever, in the end I've decided to add a separate expr kind for Index, because `foo[0]`, `&foo[1]` and `&mut foo[1]` all seem to need slightly different handing, which is not binop-like\r\n\r\nr? @flodiebold \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "eba980071d5c8941fdd3adc11fc5525d243ba2b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eba980071d5c8941fdd3adc11fc5525d243ba2b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a2a97c7e8cfac690a00505d8644be30f7ee863a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWCPOCRBK7hj4Ov3rIwAAdHIIACK5h+hvCaUAOZKI4wMOsJ5+\nxv0TheWl4CcdLLCJ8/g2D1oQ8hIK+ecBhoIjeKN+PmbejakltBcHdu4Pej3fPFA6\nM4gyieRfjji5uYhGrGN5L5L5rj75f8cKpXawgjFZXiyEwHdGjM3C58q9dSyi8Ixy\nEl8Hki5y+k6cdJ065rKiGUpyRL8RM9LW8179cJ8/YCpHENuF+8bF/R74+BkS9+Ob\nrQmtnEzRupHeqfAnKQyR/6i5Q5tPH8s3H+3v75Dgr1R33Fll5c4LinEr+3JJfuMa\n+2Wd9kh2bgIE8YFwVb2SijlrNWYHttIS1Xfs/EaSj8ZC+BEizAUkxyrhGBQFszQ=\n=1JK2\n-----END PGP SIGNATURE-----\n", "payload": "tree eba980071d5c8941fdd3adc11fc5525d243ba2b3\nparent d15cf2c9600e0464b9bcd0273e7845efbf7bdeb5\nparent 189d879659f4e44c3343023d6455bed7cdf0e7c9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1566057422 +0000\ncommitter GitHub <noreply@github.com> 1566057422 +0000\n\nMerge #1694\n\n1694: Implement initial type-inference support for Index r=flodiebold a=matklad\n\nThis doesn't actually infer indexing types, but at least it walks sub-expressions!\r\n\r\nInitially, I wanted to make `Index` just a new kind of `BinOp` (b/c indexing is kind of a binary op), so I've refactoring binop handing a bit.\r\n\r\nHowever, in the end I've decided to add a separate expr kind for Index, because `foo[0]`, `&foo[1]` and `&mut foo[1]` all seem to need slightly different handing, which is not binop-like\r\n\r\nr? @flodiebold \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2a97c7e8cfac690a00505d8644be30f7ee863a", "html_url": "https://github.com/rust-lang/rust/commit/5a2a97c7e8cfac690a00505d8644be30f7ee863a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a2a97c7e8cfac690a00505d8644be30f7ee863a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d15cf2c9600e0464b9bcd0273e7845efbf7bdeb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d15cf2c9600e0464b9bcd0273e7845efbf7bdeb5", "html_url": "https://github.com/rust-lang/rust/commit/d15cf2c9600e0464b9bcd0273e7845efbf7bdeb5"}, {"sha": "189d879659f4e44c3343023d6455bed7cdf0e7c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/189d879659f4e44c3343023d6455bed7cdf0e7c9", "html_url": "https://github.com/rust-lang/rust/commit/189d879659f4e44c3343023d6455bed7cdf0e7c9"}], "stats": {"total": 299, "additions": 186, "deletions": 113}, "files": [{"sha": "a16561d1143467a12147680a0478477390e760ed", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=5a2a97c7e8cfac690a00505d8644be30f7ee863a", "patch": "@@ -245,6 +245,10 @@ pub enum Expr {\n         rhs: ExprId,\n         op: Option<BinaryOp>,\n     },\n+    Index {\n+        base: ExprId,\n+        index: ExprId,\n+    },\n     Lambda {\n         args: Vec<PatId>,\n         arg_types: Vec<Option<TypeRef>>,\n@@ -257,7 +261,46 @@ pub enum Expr {\n     Literal(Literal),\n }\n \n-pub use ra_syntax::ast::BinOp as BinaryOp;\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinaryOp {\n+    LogicOp(LogicOp),\n+    ArithOp(ArithOp),\n+    CmpOp(CmpOp),\n+    Assignment { op: Option<ArithOp> },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LogicOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CmpOp {\n+    Eq { negated: bool },\n+    Ord { ordering: Ordering, strict: bool },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum Ordering {\n+    Less,\n+    Greater,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ArithOp {\n+    Add,\n+    Mul,\n+    Sub,\n+    Div,\n+    Rem,\n+    Shl,\n+    Shr,\n+    BitXor,\n+    BitOr,\n+    BitAnd,\n+}\n+\n pub use ra_syntax::ast::PrefixOp as UnaryOp;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n@@ -360,6 +403,10 @@ impl Expr {\n                 f(*lhs);\n                 f(*rhs);\n             }\n+            Expr::Index { base, index } => {\n+                f(*base);\n+                f(*index);\n+            }\n             Expr::Field { expr, .. }\n             | Expr::Await { expr }\n             | Expr::Try { expr }\n@@ -791,7 +838,7 @@ where\n             ast::ExprKind::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind();\n+                let op = e.op_kind().map(BinaryOp::from);\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::ExprKind::TupleExpr(e) => {\n@@ -848,10 +895,14 @@ where\n                 };\n                 self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }\n+            ast::ExprKind::IndexExpr(e) => {\n+                let base = self.collect_expr_opt(e.base());\n+                let index = self.collect_expr_opt(e.index());\n+                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n+            }\n \n             // FIXME implement HIR for these:\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::MacroCall(e) => {\n                 let ast_id = self\n@@ -1038,6 +1089,50 @@ where\n     }\n }\n \n+impl From<ast::BinOp> for BinaryOp {\n+    fn from(ast_op: ast::BinOp) -> Self {\n+        match ast_op {\n+            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n+            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n+            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n+            ast::BinOp::LesserEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n+            }\n+            ast::BinOp::GreaterEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n+            }\n+            ast::BinOp::LesserTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n+            }\n+            ast::BinOp::GreaterTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n+            }\n+            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n+            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n+            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n+            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n+            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n+            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n+            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n+            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n+            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n+            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n+            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n+            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n+            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n+            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n+            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n+            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n+            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n+            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n+            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n+            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n+            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n+        }\n+    }\n+}\n+\n pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,"}, {"sha": "cca59538ac626fc459530ffa3055f6235458dd3d", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=5a2a97c7e8cfac690a00505d8644be30f7ee863a", "patch": "@@ -1265,9 +1265,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n-                        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n-                            Expectation::has_type(Ty::simple(TypeCtor::Bool))\n-                        }\n+                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n@@ -1281,6 +1279,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 _ => Ty::Unknown,\n             },\n+            Expr::Index { base, index } => {\n+                let _base_ty = self.infer_expr(*base, &Expectation::none());\n+                let _index_ty = self.infer_expr(*index, &Expectation::none());\n+                // FIXME: use `std::ops::Index::Output` to figure out the real return type\n+                Ty::Unknown\n+            }\n             Expr::Tuple { exprs } => {\n                 let mut ty_vec = Vec::with_capacity(exprs.len());\n                 for arg in exprs.iter() {"}, {"sha": "1b30a5b9b759f29082bb8b621284041c96101977", "filename": "crates/ra_hir/src/ty/op.rs", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs?ref=5a2a97c7e8cfac690a00505d8644be30f7ee863a", "patch": "@@ -1,94 +1,50 @@\n use super::{InferTy, Ty, TypeCtor};\n-use crate::{expr::BinaryOp, ty::ApplicationTy};\n+use crate::{\n+    expr::{BinaryOp, CmpOp},\n+    ty::ApplicationTy,\n+};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::BooleanOr\n-        | BinaryOp::BooleanAnd\n-        | BinaryOp::EqualityTest\n-        | BinaryOp::NegatedEqualityTest\n-        | BinaryOp::LesserEqualTest\n-        | BinaryOp::GreaterEqualTest\n-        | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest => Ty::simple(TypeCtor::Bool),\n-        BinaryOp::Assignment\n-        | BinaryOp::AddAssign\n-        | BinaryOp::SubAssign\n-        | BinaryOp::DivAssign\n-        | BinaryOp::MulAssign\n-        | BinaryOp::RemAssign\n-        | BinaryOp::ShrAssign\n-        | BinaryOp::ShlAssign\n-        | BinaryOp::BitAndAssign\n-        | BinaryOp::BitOrAssign\n-        | BinaryOp::BitXorAssign => Ty::unit(),\n-        BinaryOp::Addition\n-        | BinaryOp::Subtraction\n-        | BinaryOp::Multiplication\n-        | BinaryOp::Division\n-        | BinaryOp::Remainder\n-        | BinaryOp::LeftShift\n-        | BinaryOp::RightShift\n-        | BinaryOp::BitwiseAnd\n-        | BinaryOp::BitwiseOr\n-        | BinaryOp::BitwiseXor => match rhs_ty {\n+        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::Assignment { .. } => Ty::unit(),\n+        BinaryOp::ArithOp(_) => match rhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n                 TypeCtor::Int(..) | TypeCtor::Float(..) => rhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n-        BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n     }\n }\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::simple(TypeCtor::Bool),\n-        BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n-            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..)\n-                | TypeCtor::Float(..)\n-                | TypeCtor::Str\n-                | TypeCtor::Char\n-                | TypeCtor::Bool => lhs_ty,\n+        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::Assignment { op: None } | BinaryOp::CmpOp(CmpOp::Eq { negated: _ }) => {\n+            match lhs_ty {\n+                Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n+                    TypeCtor::Int(..)\n+                    | TypeCtor::Float(..)\n+                    | TypeCtor::Str\n+                    | TypeCtor::Char\n+                    | TypeCtor::Bool => lhs_ty,\n+                    _ => Ty::Unknown,\n+                },\n+                Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n                 _ => Ty::Unknown,\n-            },\n-            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n-            _ => Ty::Unknown,\n-        },\n-        BinaryOp::LesserEqualTest\n-        | BinaryOp::GreaterEqualTest\n-        | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest\n-        | BinaryOp::AddAssign\n-        | BinaryOp::SubAssign\n-        | BinaryOp::DivAssign\n-        | BinaryOp::MulAssign\n-        | BinaryOp::RemAssign\n-        | BinaryOp::ShrAssign\n-        | BinaryOp::ShlAssign\n-        | BinaryOp::BitAndAssign\n-        | BinaryOp::BitOrAssign\n-        | BinaryOp::BitXorAssign\n-        | BinaryOp::Addition\n-        | BinaryOp::Subtraction\n-        | BinaryOp::Multiplication\n-        | BinaryOp::Division\n-        | BinaryOp::Remainder\n-        | BinaryOp::LeftShift\n-        | BinaryOp::RightShift\n-        | BinaryOp::BitwiseAnd\n-        | BinaryOp::BitwiseOr\n-        | BinaryOp::BitwiseXor => match lhs_ty {\n+            }\n+        }\n+        BinaryOp::CmpOp(CmpOp::Ord { .. })\n+        | BinaryOp::Assignment { op: Some(_) }\n+        | BinaryOp::ArithOp(_) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n                 TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n-        _ => Ty::Unknown,\n     }\n }"}, {"sha": "6c2d857bca171b57713a5f6bef4b1d5cc453a577", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=5a2a97c7e8cfac690a00505d8644be30f7ee863a", "patch": "@@ -2655,6 +2655,20 @@ fn test() -> u64 {\n     );\n }\n \n+#[test]\n+fn indexing_arrays() {\n+    assert_snapshot_matches!(\n+        infer(\"fn main() { &mut [9][2]; }\"),\n+        @r###\"\n+[10; 26) '{ &mut...[2]; }': ()\n+[12; 23) '&mut [9][2]': &mut {unknown}\n+[17; 20) '[9]': [i32;_]\n+[17; 23) '[9][2]': {unknown}\n+[18; 19) '9': i32\n+[21; 22) '2': i32\"###\n+    )\n+}\n+\n #[test]\n fn infer_macros_expanded() {\n     assert_snapshot_matches!("}, {"sha": "cf5b6f2510e05f230604e43a1dba834e9043acd4", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2a97c7e8cfac690a00505d8644be30f7ee863a/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=5a2a97c7e8cfac690a00505d8644be30f7ee863a", "patch": "@@ -102,10 +102,6 @@ pub enum BinOp {\n     BitwiseOr,\n     /// The `&` operator for bitwise AND\n     BitwiseAnd,\n-    /// The `..` operator for right-open ranges\n-    RangeRightOpen,\n-    /// The `..=` operator for right-closed ranges\n-    RangeRightClosed,\n     /// The `=` operator for assignment\n     Assignment,\n     /// The `+=` operator for assignment after addition\n@@ -132,41 +128,40 @@ pub enum BinOp {\n \n impl ast::BinExpr {\n     fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n-        self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|c| match c\n-            .kind()\n-        {\n-            T![||] => Some((c, BinOp::BooleanOr)),\n-            T![&&] => Some((c, BinOp::BooleanAnd)),\n-            T![==] => Some((c, BinOp::EqualityTest)),\n-            T![!=] => Some((c, BinOp::NegatedEqualityTest)),\n-            T![<=] => Some((c, BinOp::LesserEqualTest)),\n-            T![>=] => Some((c, BinOp::GreaterEqualTest)),\n-            T![<] => Some((c, BinOp::LesserTest)),\n-            T![>] => Some((c, BinOp::GreaterTest)),\n-            T![+] => Some((c, BinOp::Addition)),\n-            T![*] => Some((c, BinOp::Multiplication)),\n-            T![-] => Some((c, BinOp::Subtraction)),\n-            T![/] => Some((c, BinOp::Division)),\n-            T![%] => Some((c, BinOp::Remainder)),\n-            T![<<] => Some((c, BinOp::LeftShift)),\n-            T![>>] => Some((c, BinOp::RightShift)),\n-            T![^] => Some((c, BinOp::BitwiseXor)),\n-            T![|] => Some((c, BinOp::BitwiseOr)),\n-            T![&] => Some((c, BinOp::BitwiseAnd)),\n-            T![..] => Some((c, BinOp::RangeRightOpen)),\n-            T![..=] => Some((c, BinOp::RangeRightClosed)),\n-            T![=] => Some((c, BinOp::Assignment)),\n-            T![+=] => Some((c, BinOp::AddAssign)),\n-            T![/=] => Some((c, BinOp::DivAssign)),\n-            T![*=] => Some((c, BinOp::MulAssign)),\n-            T![%=] => Some((c, BinOp::RemAssign)),\n-            T![>>=] => Some((c, BinOp::ShrAssign)),\n-            T![<<=] => Some((c, BinOp::ShlAssign)),\n-            T![-=] => Some((c, BinOp::SubAssign)),\n-            T![|=] => Some((c, BinOp::BitOrAssign)),\n-            T![&=] => Some((c, BinOp::BitAndAssign)),\n-            T![^=] => Some((c, BinOp::BitXorAssign)),\n-            _ => None,\n+        self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|c| {\n+            let bin_op = match c.kind() {\n+                T![||] => BinOp::BooleanOr,\n+                T![&&] => BinOp::BooleanAnd,\n+                T![==] => BinOp::EqualityTest,\n+                T![!=] => BinOp::NegatedEqualityTest,\n+                T![<=] => BinOp::LesserEqualTest,\n+                T![>=] => BinOp::GreaterEqualTest,\n+                T![<] => BinOp::LesserTest,\n+                T![>] => BinOp::GreaterTest,\n+                T![+] => BinOp::Addition,\n+                T![*] => BinOp::Multiplication,\n+                T![-] => BinOp::Subtraction,\n+                T![/] => BinOp::Division,\n+                T![%] => BinOp::Remainder,\n+                T![<<] => BinOp::LeftShift,\n+                T![>>] => BinOp::RightShift,\n+                T![^] => BinOp::BitwiseXor,\n+                T![|] => BinOp::BitwiseOr,\n+                T![&] => BinOp::BitwiseAnd,\n+                T![=] => BinOp::Assignment,\n+                T![+=] => BinOp::AddAssign,\n+                T![/=] => BinOp::DivAssign,\n+                T![*=] => BinOp::MulAssign,\n+                T![%=] => BinOp::RemAssign,\n+                T![>>=] => BinOp::ShrAssign,\n+                T![<<=] => BinOp::ShlAssign,\n+                T![-=] => BinOp::SubAssign,\n+                T![|=] => BinOp::BitOrAssign,\n+                T![&=] => BinOp::BitAndAssign,\n+                T![^=] => BinOp::BitXorAssign,\n+                _ => return None,\n+            };\n+            Some((c, bin_op))\n         })\n     }\n \n@@ -194,6 +189,15 @@ impl ast::BinExpr {\n     }\n }\n \n+impl ast::IndexExpr {\n+    pub fn base(&self) -> Option<ast::Expr> {\n+        children(self).nth(0)\n+    }\n+    pub fn index(&self) -> Option<ast::Expr> {\n+        children(self).nth(1)\n+    }\n+}\n+\n pub enum ArrayExprKind {\n     Repeat { initializer: Option<ast::Expr>, repeat: Option<ast::Expr> },\n     ElementList(AstChildren<ast::Expr>),"}]}