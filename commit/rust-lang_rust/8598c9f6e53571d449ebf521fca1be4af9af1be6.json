{"sha": "8598c9f6e53571d449ebf521fca1be4af9af1be6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OThjOWY2ZTUzNTcxZDQ0OWViZjUyMWZjYTFiZTRhZjlhZjFiZTY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-03T00:25:04Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-12T19:59:11Z"}, "message": "Turn type inhabitedness into a query", "tree": {"sha": "2d4f7b9a21129557fa94cb6b6425c8ffdac19ac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4f7b9a21129557fa94cb6b6425c8ffdac19ac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8598c9f6e53571d449ebf521fca1be4af9af1be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8598c9f6e53571d449ebf521fca1be4af9af1be6", "html_url": "https://github.com/rust-lang/rust/commit/8598c9f6e53571d449ebf521fca1be4af9af1be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8598c9f6e53571d449ebf521fca1be4af9af1be6/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b82f149d08a0afcc17afa54f5bb3c7031babd44a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b82f149d08a0afcc17afa54f5bb3c7031babd44a", "html_url": "https://github.com/rust-lang/rust/commit/b82f149d08a0afcc17afa54f5bb3c7031babd44a"}], "stats": {"total": 87, "additions": 60, "deletions": 27}, "files": [{"sha": "418ae2ddfc736e45c7436dc5a73478de3d871e32", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=8598c9f6e53571d449ebf521fca1be4af9af1be6", "patch": "@@ -1308,6 +1308,15 @@ rustc_queries! {\n             eval_always\n             desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         }\n+\n+        /// Computes the set of modules from which this type is visibly uninhabited.\n+        /// To check whether a type is uninhabited at all (not just from a given module), you could\n+        /// check whether the forest is empty.\n+        query type_uninhabited_from(\n+            key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Arc<ty::inhabitedness::DefIdForest> {\n+            desc { \"computing the inhabitedness of `{:?}`\", key }\n+        }\n     }\n \n     Other {"}, {"sha": "50fcd51b78cf75112ddf502877715edffce1ea54", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=8598c9f6e53571d449ebf521fca1be4af9af1be6", "patch": "@@ -11,7 +11,7 @@ use std::mem;\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct DefIdForest {\n     /// The minimal set of `DefId`s required to represent the whole set.\n     /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n@@ -72,6 +72,9 @@ impl<'tcx> DefIdForest {\n                 break;\n             }\n \n+            // `next_ret` and `old_ret` are empty here.\n+            // We keep the elements in `ret` that are also in `next_forest`. Those that aren't are\n+            // put back in `ret` via `old_ret`.\n             for id in ret.root_ids.drain(..) {\n                 if next_forest.contains(tcx, id) {\n                     next_ret.push(id);\n@@ -81,7 +84,13 @@ impl<'tcx> DefIdForest {\n             }\n             ret.root_ids.extend(old_ret.drain(..));\n \n+            // We keep the elements in `next_forest` that are also in `ret`.\n+            // You'd think this is not needed because `next_ret` already contains `ret \\inter\n+            // next_forest`. But those aren't just sets of things. If `ret = [a]`, `next_forest =\n+            // [b]` and `b` is a submodule of `a`, then `b` belongs in the intersection but we\n+            // didn't catch it in the loop above.\n             next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n+            // `next_ret` now contains the intersection of the original `ret` and `next_forest`.\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain(..);"}, {"sha": "9dc309e2ab5595050e87e1b7a8301003ad56a8ca", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=8598c9f6e53571d449ebf521fca1be4af9af1be6", "patch": "@@ -6,7 +6,8 @@ use crate::ty::TyKind::*;\n use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n-use rustc_data_structures::stack::ensure_sufficient_stack;\n+\n+use std::sync::Arc;\n \n mod def_id_forest;\n \n@@ -187,34 +188,47 @@ impl<'tcx> FieldDef {\n \n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n-        match *self.kind() {\n-            Adt(def, substs) => {\n-                ensure_sufficient_stack(|| def.uninhabited_from(tcx, substs, param_env))\n-            }\n+    fn uninhabited_from(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> DefIdForest {\n+        tcx.type_uninhabited_from(param_env.and(self)).as_ref().clone()\n+    }\n+}\n \n-            Never => DefIdForest::full(tcx),\n+// Query provider for `type_uninhabited_from`.\n+pub(crate) fn type_uninhabited_from<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Arc<DefIdForest> {\n+    let ty = key.value;\n+    let param_env = key.param_env;\n+    let forest = match *ty.kind() {\n+        Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n-            Tuple(ref tys) => DefIdForest::union(\n-                tcx,\n-                tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n-            ),\n+        Never => DefIdForest::full(tcx),\n \n-            Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n-                Some(0) | None => DefIdForest::empty(),\n-                // If the array is definitely non-empty, it's uninhabited if\n-                // the type of its elements is uninhabited.\n-                Some(1..) => ty.uninhabited_from(tcx, param_env),\n-            },\n+        Tuple(ref tys) => DefIdForest::union(\n+            tcx,\n+            tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n+        ),\n \n-            // References to uninitialised memory are valid for any type, including\n-            // uninhabited types, in unsafe code, so we treat all references as\n-            // inhabited.\n-            // The precise semantics of inhabitedness with respect to references is currently\n-            // undecided.\n-            Ref(..) => DefIdForest::empty(),\n+        Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n+            Some(0) | None => DefIdForest::empty(),\n+            // If the array is definitely non-empty, it's uninhabited if\n+            // the type of its elements is uninhabited.\n+            Some(1..) => ty.uninhabited_from(tcx, param_env),\n+        },\n \n-            _ => DefIdForest::empty(),\n-        }\n-    }\n+        // References to uninitialised memory are valid for any type, including\n+        // uninhabited types, in unsafe code, so we treat all references as\n+        // inhabited.\n+        // The precise semantics of inhabitedness with respect to references is currently\n+        // undecided.\n+        Ref(..) => DefIdForest::empty(),\n+\n+        _ => DefIdForest::empty(),\n+    };\n+    Arc::new(forest)\n }"}, {"sha": "b2448571b31ee729481a5657e4d6ab52c203c95a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8598c9f6e53571d449ebf521fca1be4af9af1be6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8598c9f6e53571d449ebf521fca1be4af9af1be6", "patch": "@@ -3146,6 +3146,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         all_local_trait_impls: trait_def::all_local_trait_impls,\n+        type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         ..*providers\n     };\n }"}]}