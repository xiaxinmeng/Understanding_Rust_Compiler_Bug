{"sha": "bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYzFlZTQ5NjhmZjU3NzhjZDgwZTEyMTUwZjM3OWRkZmU2YzI3Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T09:19:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T09:19:21Z"}, "message": "Auto merge of #51762 - petrochenkov:oh-hi-mark, r=oli-obk\n\nhygiene: Implement transparent marks and use them for call-site hygiene in proc-macros\n\nFixes https://github.com/rust-lang/rust/issues/50050", "tree": {"sha": "1e61b5ce7879de8613a142ffd6c029f8866bf70a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e61b5ce7879de8613a142ffd6c029f8866bf70a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "html_url": "https://github.com/rust-lang/rust/commit/bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acf50b79beb5909c16861cc7c91e8226b7f78272", "url": "https://api.github.com/repos/rust-lang/rust/commits/acf50b79beb5909c16861cc7c91e8226b7f78272", "html_url": "https://github.com/rust-lang/rust/commit/acf50b79beb5909c16861cc7c91e8226b7f78272"}, {"sha": "84f1bc8b662da4ceb0e448bf0d24ce627e6a462b", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f1bc8b662da4ceb0e448bf0d24ce627e6a462b", "html_url": "https://github.com/rust-lang/rust/commit/84f1bc8b662da4ceb0e448bf0d24ce627e6a462b"}], "stats": {"total": 718, "additions": 549, "deletions": 169}, "files": [{"sha": "a82e3dcb0600cbf8b78d51f28196e2903e3f11c6", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -97,7 +97,7 @@ impl Diagnostic {\n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn emit(self) {\n-        ::__internal::with_sess(move |(sess, _)| {\n+        ::__internal::with_sess(move |sess, _| {\n             let handler = &sess.span_diagnostic;\n             let level = __internal::level_to_internal_level(self.level);\n             let mut diag = rustc::DiagnosticBuilder::new(handler, level, &*self.message);"}, {"sha": "fb5cbf473a387e782f593d4b20dc4e305db1b370", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -58,8 +58,7 @@ use syntax::parse::{self, token};\n use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream;\n use syntax::parse::lexer::{self, comments};\n-use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n-use syntax_pos::hygiene::Mark;\n+use syntax_pos::{FileMap, Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -109,6 +108,7 @@ impl TokenStream {\n /// Attempts to break the string into tokens and parse those tokens into a token stream.\n /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n /// or characters not existing in the language.\n+/// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n /// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n@@ -117,17 +117,10 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        __internal::with_sess(|(sess, mark)| {\n-            let src = src.to_string();\n-            let name = FileName::ProcMacroSourceCode;\n-            let expn_info = mark.expn_info().unwrap();\n-            let call_site = expn_info.call_site;\n-            // notify the expansion info that it is unhygienic\n-            let mark = Mark::fresh(mark);\n-            mark.set_expn_info(expn_info);\n-            let span = call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-            let stream = parse::parse_stream_from_source_str(name, src, sess, Some(span));\n-            Ok(__internal::token_stream_wrap(stream))\n+        __internal::with_sess(|sess, data| {\n+            Ok(__internal::token_stream_wrap(parse::parse_stream_from_source_str(\n+                FileName::ProcMacroSourceCode, src.to_string(), sess, Some(data.call_site.0)\n+            )))\n         })\n     }\n }\n@@ -184,8 +177,6 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub mod token_stream {\n     use syntax::tokenstream;\n-    use syntax_pos::DUMMY_SP;\n-\n     use {TokenTree, TokenStream, Delimiter};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n@@ -214,7 +205,7 @@ pub mod token_stream {\n                 // need to flattened during iteration over stream's token trees.\n                 // Eventually this needs to be removed in favor of keeping original token trees\n                 // and not doing the roundtrip through AST.\n-                if tree.span().0 == DUMMY_SP {\n+                if tree.span().0.is_dummy() {\n                     if let TokenTree::Group(ref group) = tree {\n                         if group.delimiter() == Delimiter::None {\n                             self.cursor.insert(group.stream.clone().0);\n@@ -284,10 +275,7 @@ impl Span {\n     /// A span that resolves at the macro definition site.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn def_site() -> Span {\n-        ::__internal::with_sess(|(_, mark)| {\n-            let call_site = mark.expn_info().unwrap().call_site;\n-            Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n-        })\n+        ::__internal::with_sess(|_, data| data.def_site)\n     }\n \n     /// The span of the invocation of the current procedural macro.\n@@ -296,7 +284,7 @@ impl Span {\n     /// at the macro call site will be able to refer to them as well.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n-        ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n+        ::__internal::with_sess(|_, data| data.call_site)\n     }\n \n     /// The original source file into which this span points.\n@@ -1243,7 +1231,7 @@ impl TokenTree {\n             }\n \n             Interpolated(_) => {\n-                __internal::with_sess(|(sess, _)| {\n+                __internal::with_sess(|sess, _| {\n                     let tts = token.interpolated_to_tokenstream(sess, span);\n                     tt!(Group::new(Delimiter::None, TokenStream(tts)))\n                 })\n@@ -1354,20 +1342,21 @@ pub mod __internal {\n     pub use quote::{LiteralKind, SpannedSymbol, Quoter, unquote};\n \n     use std::cell::Cell;\n+    use std::ptr;\n \n     use syntax::ast;\n     use syntax::ext::base::ExtCtxt;\n-    use syntax::ext::hygiene::Mark;\n     use syntax::ptr::P;\n     use syntax::parse::{self, ParseSess};\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n     use syntax_pos::{BytePos, Loc, DUMMY_SP};\n+    use syntax_pos::hygiene::{Mark, SyntaxContext, Transparency};\n \n-    use super::{TokenStream, LexError};\n+    use super::{TokenStream, LexError, Span};\n \n     pub fn lookup_char_pos(pos: BytePos) -> Loc {\n-        with_sess(|(sess, _)| sess.codemap().lookup_char_pos(pos))\n+        with_sess(|sess, _| sess.codemap().lookup_char_pos(pos))\n     }\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n@@ -1380,7 +1369,7 @@ pub mod __internal {\n     }\n \n     pub fn token_stream_parse_items(stream: TokenStream) -> Result<Vec<P<ast::Item>>, LexError> {\n-        with_sess(move |(sess, _)| {\n+        with_sess(move |sess, _| {\n             let mut parser = parse::stream_to_parser(sess, stream.0);\n             let mut items = Vec::new();\n \n@@ -1411,16 +1400,30 @@ pub mod __internal {\n                                     expand: fn(TokenStream) -> TokenStream);\n     }\n \n+    #[derive(Clone, Copy)]\n+    pub struct ProcMacroData {\n+        pub def_site: Span,\n+        pub call_site: Span,\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct ProcMacroSess {\n+        parse_sess: *const ParseSess,\n+        data: ProcMacroData,\n+    }\n+\n     // Emulate scoped_thread_local!() here essentially\n     thread_local! {\n-        static CURRENT_SESS: Cell<(*const ParseSess, Mark)> =\n-            Cell::new((0 as *const _, Mark::root()));\n+        static CURRENT_SESS: Cell<ProcMacroSess> = Cell::new(ProcMacroSess {\n+            parse_sess: ptr::null(),\n+            data: ProcMacroData { def_site: Span(DUMMY_SP), call_site: Span(DUMMY_SP) },\n+        });\n     }\n \n     pub fn set_sess<F, R>(cx: &ExtCtxt, f: F) -> R\n         where F: FnOnce() -> R\n     {\n-        struct Reset { prev: (*const ParseSess, Mark) }\n+        struct Reset { prev: ProcMacroSess }\n \n         impl Drop for Reset {\n             fn drop(&mut self) {\n@@ -1430,24 +1433,42 @@ pub mod __internal {\n \n         CURRENT_SESS.with(|p| {\n             let _reset = Reset { prev: p.get() };\n-            p.set((cx.parse_sess, cx.current_expansion.mark));\n+\n+            // No way to determine def location for a proc macro right now, so use call location.\n+            let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n+            // Opaque mark was already created by expansion, now create its transparent twin.\n+            // We can't use the call-site span literally here, even if it appears to provide\n+            // correct name resolution, because it has all the `ExpnInfo` wrong, so the edition\n+            // checks, lint macro checks, macro backtraces will all break.\n+            let opaque_mark = cx.current_expansion.mark;\n+            let transparent_mark = Mark::fresh_cloned(opaque_mark);\n+            transparent_mark.set_transparency(Transparency::Transparent);\n+\n+            let to_span = |mark| Span(location.with_ctxt(SyntaxContext::empty().apply_mark(mark)));\n+            p.set(ProcMacroSess {\n+                parse_sess: cx.parse_sess,\n+                data: ProcMacroData {\n+                    def_site: to_span(opaque_mark),\n+                    call_site: to_span(transparent_mark),\n+                },\n+            });\n             f()\n         })\n     }\n \n     pub fn in_sess() -> bool\n     {\n-        let p = CURRENT_SESS.with(|p| p.get());\n-        !p.0.is_null()\n+        !CURRENT_SESS.with(|sess| sess.get()).parse_sess.is_null()\n     }\n \n     pub fn with_sess<F, R>(f: F) -> R\n-        where F: FnOnce((&ParseSess, Mark)) -> R\n+        where F: FnOnce(&ParseSess, &ProcMacroData) -> R\n     {\n-        let p = CURRENT_SESS.with(|p| p.get());\n-        assert!(!p.0.is_null(), \"proc_macro::__internal::with_sess() called \\\n-                                 before set_parse_sess()!\");\n-        f(unsafe { (&*p.0, p.1) })\n+        let sess = CURRENT_SESS.with(|sess| sess.get());\n+        if sess.parse_sess.is_null() {\n+            panic!(\"procedural macro API is used outside of a procedural macro\");\n+        }\n+        f(unsafe { &*sess.parse_sess }, &sess.data)\n     }\n }\n "}, {"sha": "fa01a1ccca59baf0998c4bc8840e780251440839", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -484,12 +484,7 @@ impl Definitions {\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n-            let span = self.def_index_to_span.get(&def_id.index).cloned().unwrap_or(DUMMY_SP);\n-            if span != DUMMY_SP {\n-                Some(span)\n-            } else {\n-                None\n-            }\n+            self.def_index_to_span.get(&def_id.index).cloned()\n         } else {\n             None\n         }\n@@ -586,8 +581,8 @@ impl Definitions {\n             self.opaque_expansions_that_defined.insert(index, expansion);\n         }\n \n-        // The span is added if it isn't DUMMY_SP\n-        if span != DUMMY_SP {\n+        // The span is added if it isn't dummy\n+        if !span.is_dummy() {\n             self.def_index_to_span.insert(index, span);\n         }\n "}, {"sha": "9bf5c4d72b70cb05f8b6977c78291029e0f0961a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -20,7 +20,7 @@ use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n use session::DiagnosticMessageId;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n@@ -687,7 +687,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let msp: MultiSpan = span.into();\n                 let cm = &self.sess.parse_sess.codemap();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n-                    if sp != DUMMY_SP {\n+                    if !sp.is_dummy() {\n                         let file = cm.lookup_char_pos(sp.lo()).file;\n                         if file.name.is_macros() {\n                             None\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match item.node {\n             hir::ItemExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n-                if item.span == DUMMY_SP { return }\n+                if item.span.is_dummy() { return }\n \n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {"}, {"sha": "d783b9574efb2fdbe21bcbd1d22d23fbf369a286", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -708,7 +708,7 @@ macro_rules! define_queries {\n \n             // FIXME(eddyb) Get more valid Span's on queries.\n             pub fn default_span(&self, tcx: TyCtxt<'_, $tcx, '_>, span: Span) -> Span {\n-                if span != DUMMY_SP {\n+                if !span.is_dummy() {\n                     return span;\n                 }\n                 // The def_span query is used to calculate default_span,"}, {"sha": "6d727f7b048c6541276c85ac3129c3793dd6faaa", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -1662,7 +1662,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n     let var_scope = get_namespace_for_item(cx, def_id);\n     let span = tcx.def_span(def_id);\n \n-    let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n+    let (file_metadata, line_number) = if !span.is_dummy() {\n         let loc = span_start(cx, span);\n         (file_metadata(cx, &loc.file.name, LOCAL_CRATE), loc.line as c_uint)\n     } else {"}, {"sha": "068dd9821ac97029dad1295b389a0555d5057bc9", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -219,7 +219,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let span = mir.span;\n \n     // This can be the case for functions inlined from another crate\n-    if span == syntax_pos::DUMMY_SP {\n+    if span.is_dummy() {\n         // FIXME(simulacrum): Probably can't happen; remove.\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }"}, {"sha": "e79a3a87738ec407903ecb1690f515d797659442", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{DUMMY_SP, FileMap, Span, MultiSpan};\n+use syntax_pos::{FileMap, Span, MultiSpan};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n@@ -216,7 +216,7 @@ impl EmitterWriter {\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n-                if span_label.span == DUMMY_SP {\n+                if span_label.span.is_dummy() {\n                     continue;\n                 }\n \n@@ -730,7 +730,7 @@ impl EmitterWriter {\n         let mut max = 0;\n         if let Some(ref cm) = self.cm {\n             for primary_span in msp.primary_spans() {\n-                if primary_span != &DUMMY_SP {\n+                if !primary_span.is_dummy() {\n                     let hi = cm.lookup_char_pos(primary_span.hi());\n                     if hi.line > max {\n                         max = hi.line;\n@@ -739,7 +739,7 @@ impl EmitterWriter {\n             }\n             if !self.short_message {\n                 for span_label in msp.span_labels() {\n-                    if span_label.span != DUMMY_SP {\n+                    if !span_label.span.is_dummy() {\n                         let hi = cm.lookup_char_pos(span_label.span.hi());\n                         if hi.line > max {\n                             max = hi.line;\n@@ -778,7 +778,7 @@ impl EmitterWriter {\n \n             // First, find all the spans in <*macros> and point instead at their use site\n             for sp in span.primary_spans() {\n-                if *sp == DUMMY_SP {\n+                if sp.is_dummy() {\n                     continue;\n                 }\n                 let call_sp = cm.call_span_if_macro(*sp);\n@@ -790,7 +790,7 @@ impl EmitterWriter {\n                     // Only show macro locations that are local\n                     // and display them like a span_note\n                     if let Some(def_site) = trace.def_site_span {\n-                        if def_site == DUMMY_SP {\n+                        if def_site.is_dummy() {\n                             continue;\n                         }\n                         if always_backtrace {\n@@ -830,7 +830,7 @@ impl EmitterWriter {\n                 span.push_span_label(label_span, label_text);\n             }\n             for sp_label in span.span_labels() {\n-                if sp_label.span == DUMMY_SP {\n+                if sp_label.span.is_dummy() {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp_label.span.clone()).is_macros() &&\n@@ -1003,7 +1003,7 @@ impl EmitterWriter {\n         // Make sure our primary file comes first\n         let (primary_lo, cm) = if let (Some(cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n-            if primary_span != &&DUMMY_SP {\n+            if !primary_span.is_dummy() {\n                 (cm.lookup_char_pos(primary_span.lo()), cm)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;"}, {"sha": "cdeee92cb073fc4914539e6ce61af79bc02144ce", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -569,9 +569,11 @@ impl<'a> CrateLoader<'a> {\n             fn register_bang_proc_macro(&mut self,\n                                         name: &str,\n                                         expand: fn(TokenStream) -> TokenStream) {\n-                let expand = SyntaxExtension::ProcMacro(\n-                    Box::new(BangProcMacro { inner: expand }), false, self.edition\n-                );\n+                let expand = SyntaxExtension::ProcMacro {\n+                    expander: Box::new(BangProcMacro { inner: expand }),\n+                    allow_internal_unstable: false,\n+                    edition: self.edition,\n+                };\n                 self.extensions.push((Symbol::intern(name), Lrc::new(expand)));\n             }\n         }"}, {"sha": "23da82f5a4514241ca5fc56fed10f80fef37bd6d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -518,8 +518,11 @@ impl CrateStore for cstore::CStore {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n-            let ext = SyntaxExtension::ProcMacro(Box::new(::proc_macro::__internal::Quoter),\n-                                                 true, data.root.edition);\n+            let ext = SyntaxExtension::ProcMacro {\n+                expander: Box::new(::proc_macro::__internal::Quoter),\n+                allow_internal_unstable: true,\n+                edition: data.root.edition,\n+            };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }\n "}, {"sha": "93294075272584cdc4de217562d9c797f577b3bd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -41,7 +41,7 @@ use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n use syntax::symbol::keywords;\n-use syntax_pos::{self, hygiene, FileName, FileMap, Span, DUMMY_SP};\n+use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if *span == DUMMY_SP {\n+        if span.is_dummy() {\n             return TAG_INVALID_SPAN.encode(self)\n         }\n "}, {"sha": "9b6e3e0cab6baa5c8ba650f585fc54c80e7db08b", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -190,7 +190,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n \n impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n-        if *span != DUMMY_SP {\n+        if !span.is_dummy() {\n             self.last_span = *span;\n         }\n     }\n@@ -1601,7 +1601,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 statement_index: 0,\n             };\n             for stmt in &block_data.statements {\n-                if stmt.source_info.span != DUMMY_SP {\n+                if !stmt.source_info.span.is_dummy() {\n                     self.last_span = stmt.source_info.span;\n                 }\n                 self.check_stmt(mir, stmt, location);"}, {"sha": "a770f078404702c10508367dd858d5ec26829e1b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -156,7 +156,7 @@ impl<'a> Resolver<'a> {\n \n                     // Disallow `use $crate;`\n                     if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n-                        let crate_root = self.resolve_crate_root(source.span.ctxt(), true);\n+                        let crate_root = self.resolve_crate_root(source);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),"}, {"sha": "0c4b9a546cbd18617a52bdb3d9f670d08638f985", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if let ast::ItemKind::Use(..) = item.node {\n-            if item.vis.node == ast::VisibilityKind::Public || item.span.source_equal(&DUMMY_SP) {\n+            if item.vis.node == ast::VisibilityKind::Public || item.span.is_dummy() {\n                 return;\n             }\n         }\n@@ -129,7 +129,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         match directive.subclass {\n             _ if directive.used.get() ||\n                  directive.vis.get() == ty::Visibility::Public ||\n-                 directive.span.source_equal(&DUMMY_SP) => {}\n+                 directive.span.is_dummy() => {}\n             ImportDirectiveSubclass::ExternCrate(_) => {\n                 resolver.maybe_unused_extern_crates.push((directive.id, directive.span));\n             }"}, {"sha": "9f36f888b581b97ddb5ee8bdde90a9fb5dcdf836", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -1850,6 +1850,8 @@ impl<'a> Resolver<'a> {\n             } else {\n                 ident.span.modern()\n             }\n+        } else {\n+            ident = ident.modern_and_legacy();\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1981,12 +1983,36 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext, legacy: bool) -> Module<'a> {\n-        let mark = if legacy {\n+    fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {\n+        let mut ctxt = ident.span.ctxt();\n+        let mark = if ident.name == keywords::DollarCrate.name() {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n             // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n-            ctxt.marks().into_iter().find(|&mark| mark.transparency() != Transparency::Opaque)\n+            // FIXME: This is only a guess and it doesn't work correctly for `macro_rules!`\n+            // definitions actually produced by `macro` and `macro` definitions produced by\n+            // `macro_rules!`, but at least such configurations are not stable yet.\n+            ctxt = ctxt.modern_and_legacy();\n+            let mut iter = ctxt.marks().into_iter().rev().peekable();\n+            let mut result = None;\n+            // Find the last modern mark from the end if it exists.\n+            while let Some(&mark) = iter.peek() {\n+                if mark.transparency() == Transparency::Opaque {\n+                    result = Some(mark);\n+                    iter.next();\n+                } else {\n+                    break;\n+                }\n+            }\n+            // Then find the last legacy mark from the end if it exists.\n+            for mark in iter {\n+                if mark.transparency() == Transparency::SemiTransparent {\n+                    result = Some(mark);\n+                } else {\n+                    break;\n+                }\n+            }\n+            result\n         } else {\n             ctxt = ctxt.modern();\n             ctxt.adjust(Mark::root())\n@@ -2627,6 +2653,7 @@ impl<'a> Resolver<'a> {\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n         let mut def = Def::Local(pat_id);\n         match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n@@ -2857,7 +2884,7 @@ impl<'a> Resolver<'a> {\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n                 for (sp, variant_path, enum_path) in enum_candidates {\n-                    if sp == DUMMY_SP {\n+                    if sp.is_dummy() {\n                         let msg = format!(\"there is an enum variant `{}`, \\\n                                         try using `{}`?\",\n                                         variant_path,\n@@ -3345,14 +3372,11 @@ impl<'a> Resolver<'a> {\n             if ns == TypeNS {\n                 if (i == 0 && name == keywords::CrateRoot.name()) ||\n                    (i == 0 && name == keywords::Crate.name()) ||\n+                   (i == 0 && name == keywords::DollarCrate.name()) ||\n                    (i == 1 && name == keywords::Crate.name() &&\n                               path[0].name == keywords::CrateRoot.name()) {\n-                    // `::a::b` or `::crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.span.ctxt(), false));\n-                    continue\n-                } else if i == 0 && name == keywords::DollarCrate.name() {\n-                    // `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.span.ctxt(), true));\n+                    // `::a::b`, `crate::a::b`, `::crate::a::b` or `$crate::a::b`\n+                    module = Some(self.resolve_crate_root(ident));\n                     continue\n                 } else if i == 1 && !ident.is_path_segment_keyword() {\n                     let prev_name = path[0].name;\n@@ -3784,7 +3808,8 @@ impl<'a> Resolver<'a> {\n             self.unused_labels.insert(id, label.ident.span);\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n-                this.label_ribs.last_mut().unwrap().bindings.insert(label.ident, def);\n+                let ident = label.ident.modern_and_legacy();\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, def);\n                 f(this);\n             });\n         } else {\n@@ -3815,7 +3840,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.ident, |rib, id| rib.bindings.get(&id).cloned()) {\n+                let def = self.search_label(label.ident, |rib, ident| {\n+                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                });\n+                match def {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n@@ -4281,7 +4309,7 @@ impl<'a> Resolver<'a> {\n             let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n             err.span_note(b1.span, &msg1);\n             match b2.def() {\n-                Def::Macro(..) if b2.span == DUMMY_SP =>\n+                Def::Macro(..) if b2.span.is_dummy() =>\n                     err.note(&format!(\"`{}` is also a builtin macro\", name)),\n                 _ => err.span_note(b2.span, &msg2),\n             };\n@@ -4394,14 +4422,14 @@ impl<'a> Resolver<'a> {\n                           container));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        if old_binding.span != DUMMY_SP {\n+        if !old_binding.span.is_dummy() {\n             err.span_label(self.session.codemap().def_span(old_binding.span),\n                            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name));\n         }\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         if old_binding.is_import() || new_binding.is_import() {\n-            let binding = if new_binding.is_import() && new_binding.span != DUMMY_SP {\n+            let binding = if new_binding.is_import() && !new_binding.span.is_dummy() {\n                 new_binding\n             } else {\n                 old_binding"}, {"sha": "0523765ea189750cb879d61588967d3511855fa1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -155,10 +155,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     }\n                 });\n \n-                let ident = path.segments[0].ident;\n-                if ident.name == keywords::DollarCrate.name() {\n+                if path.segments[0].ident.name == keywords::DollarCrate.name() {\n+                    let module = self.0.resolve_crate_root(path.segments[0].ident);\n                     path.segments[0].ident.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_root(ident.span.ctxt(), true);\n                     if !module.is_local() {\n                         let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n@@ -333,7 +332,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n         if ext.is_modern() {\n-            invoc.expansion_data.mark.set_transparency(Transparency::Opaque);\n+            let transparency =\n+                if ext.is_transparent() { Transparency::Transparent } else { Transparency::Opaque };\n+            invoc.expansion_data.mark.set_transparency(transparency);\n         } else if def_id.krate == BUILTIN_MACROS_CRATE {\n             invoc.expansion_data.mark.set_is_builtin(true);\n         }\n@@ -351,8 +352,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n             let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::NormalTT { def_info, .. } => def_info,\n-                SyntaxExtension::DeclMacro(.., osp, _) => osp,\n+                SyntaxExtension::NormalTT { def_info, .. } |\n+                SyntaxExtension::DeclMacro { def_info, .. } => def_info,\n                 _ => None,\n             };\n             if let Some((id, span)) = id_span {\n@@ -849,8 +850,6 @@ impl<'a> Resolver<'a> {\n     /// Error if `ext` is a Macros 1.1 procedural macro being imported by `#[macro_use]`\n     fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,\n                                    binding: &NameBinding<'a>) {\n-        use self::SyntaxExtension::*;\n-\n         let krate = binding.def().def_id().krate;\n \n         // Plugin-based syntax extensions are exempt from this check\n@@ -860,15 +859,16 @@ impl<'a> Resolver<'a> {\n \n         match *ext {\n             // If `ext` is a procedural macro, check if we've already warned about it\n-            AttrProcMacro(..) | ProcMacro(..) =>\n+            SyntaxExtension::AttrProcMacro(..) | SyntaxExtension::ProcMacro { .. } =>\n                 if !self.warned_proc_macros.insert(name) { return; },\n             _ => return,\n         }\n \n         let warn_msg = match *ext {\n-            AttrProcMacro(..) => \"attribute procedural macros cannot be \\\n-                                  imported with `#[macro_use]`\",\n-            ProcMacro(..) => \"procedural macros cannot be imported with `#[macro_use]`\",\n+            SyntaxExtension::AttrProcMacro(..) =>\n+                \"attribute procedural macros cannot be imported with `#[macro_use]`\",\n+            SyntaxExtension::ProcMacro { .. } =>\n+                \"procedural macros cannot be imported with `#[macro_use]`\",\n             _ => return,\n         };\n "}, {"sha": "0ee17ebc4870423b29068b2823be42d5668f630a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -698,7 +698,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                          \"crate root imports need to be explicitly named: \\\n                                           `use crate as name;`\".to_string()));\n                         } else {\n-                            Some(self.resolve_crate_root(source.span.ctxt().modern(), false))\n+                            Some(self.resolve_crate_root(source))\n                         }\n                     } else if is_extern && !source.is_path_segment_keyword() {\n                         let crate_id ="}, {"sha": "c07db44b36ccfd9e0001225890a8244bdddc7be6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -1157,7 +1157,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt() != NO_EXPANSION || span == DUMMY_SP\n+    span.ctxt() != NO_EXPANSION || span.is_dummy()\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "ae5ca5441adf67675d3d3df6d23edc592d04f518", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -12,7 +12,7 @@ use lint;\n use rustc::ty::TyCtxt;\n \n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -39,7 +39,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if item.vis == hir::Public || item.span == DUMMY_SP {\n+        if item.vis == hir::Public || item.span.is_dummy() {\n             return;\n         }\n         if let hir::ItemUse(ref path, _) = item.node {"}, {"sha": "65babbffffef11e93d0c83e3cf234a5602d4a222", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -1219,7 +1219,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     let res = resolver\n         .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n     if let Ok(def) = res {\n-        if let SyntaxExtension::DeclMacro(..) = *resolver.get_macro(def) {\n+        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n             Some(def)\n         } else {\n             None\n@@ -3464,7 +3464,7 @@ impl Span {\n \n impl Clean<Span> for syntax_pos::Span {\n     fn clean(&self, cx: &DocContext) -> Span {\n-        if *self == DUMMY_SP {\n+        if self.is_dummy() {\n             return Span::empty();\n         }\n "}, {"sha": "ea6b39504e81d72463c90b4fd32d1fce8490c6dc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -443,7 +443,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().file_maps.is_empty() && sp.source_equal(&DUMMY_SP) {\n+        if self.files.borrow().file_maps.is_empty() && sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n "}, {"sha": "e2424de4d1449a25a81d4bcac7618cb5e8bf4fa9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -597,11 +597,11 @@ pub enum SyntaxExtension {\n     MultiModifier(Box<MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A function-like procedural macro. TokenStream -> TokenStream.\n-    ProcMacro(\n-        /* expander: */ Box<ProcMacro + sync::Sync + sync::Send>,\n-        /* allow_internal_unstable: */ bool,\n-        /* edition: */ Edition,\n-    ),\n+    ProcMacro {\n+        expander: Box<ProcMacro + sync::Sync + sync::Send>,\n+        allow_internal_unstable: bool,\n+        edition: Edition,\n+    },\n \n     /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n     /// The first TokenSteam is the attribute, the second is the annotated item.\n@@ -646,19 +646,22 @@ pub enum SyntaxExtension {\n     BuiltinDerive(BuiltinDeriveFn),\n \n     /// A declarative macro, e.g. `macro m() {}`.\n-    ///\n-    /// The second element is the definition site span.\n-    DeclMacro(Box<TTMacroExpander + sync::Sync + sync::Send>, Option<(ast::NodeId, Span)>, Edition),\n+    DeclMacro {\n+        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n+        def_info: Option<(ast::NodeId, Span)>,\n+        is_transparent: bool,\n+        edition: Edition,\n+    }\n }\n \n impl SyntaxExtension {\n     /// Return which kind of macro calls this syntax extension.\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n-            SyntaxExtension::DeclMacro(..) |\n+            SyntaxExtension::DeclMacro { .. } |\n             SyntaxExtension::NormalTT { .. } |\n             SyntaxExtension::IdentTT(..) |\n-            SyntaxExtension::ProcMacro(..) =>\n+            SyntaxExtension::ProcMacro { .. } =>\n                 MacroKind::Bang,\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n@@ -672,19 +675,26 @@ impl SyntaxExtension {\n \n     pub fn is_modern(&self) -> bool {\n         match *self {\n-            SyntaxExtension::DeclMacro(..) |\n-            SyntaxExtension::ProcMacro(..) |\n+            SyntaxExtension::DeclMacro { .. } |\n+            SyntaxExtension::ProcMacro { .. } |\n             SyntaxExtension::AttrProcMacro(..) |\n             SyntaxExtension::ProcMacroDerive(..) => true,\n             _ => false,\n         }\n     }\n \n+    pub fn is_transparent(&self) -> bool {\n+        match *self {\n+            SyntaxExtension::DeclMacro { is_transparent, .. } => is_transparent,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn edition(&self) -> Edition {\n         match *self {\n             SyntaxExtension::NormalTT { edition, .. } |\n-            SyntaxExtension::DeclMacro(.., edition) |\n-            SyntaxExtension::ProcMacro(.., edition) |\n+            SyntaxExtension::DeclMacro { edition, .. } |\n+            SyntaxExtension::ProcMacro { edition, .. } |\n             SyntaxExtension::AttrProcMacro(.., edition) |\n             SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n             // Unstable legacy stuff"}, {"sha": "f29bff20f3dd6a4d671c81a472375d1210786ef5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -738,13 +738,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let opt_expanded = match *ext {\n-            DeclMacro(ref expand, def_span, edition) => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_span.map(|(_, s)| s),\n+            DeclMacro { ref expander, def_info, edition, .. } => {\n+                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n                                                                     false, false, false, None,\n                                                                     edition) {\n                     dummy_span\n                 } else {\n-                    kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n+                    kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n                 }\n             }\n \n@@ -804,7 +804,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.dummy(span)\n             }\n \n-            ProcMacro(ref expandfun, allow_internal_unstable, edition) => {\n+            SyntaxExtension::ProcMacro { ref expander, allow_internal_unstable, edition } => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -826,7 +826,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         edition,\n                     });\n \n-                    let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n                     result\n@@ -1297,7 +1297,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner == DUMMY_SP;\n+                let inline_module = item.span.contains(inner) || inner.is_dummy();\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {"}, {"sha": "70fc9dada428ea7f8c60f17720fec27a010cb49f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -312,7 +312,14 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             edition,\n         }\n     } else {\n-        SyntaxExtension::DeclMacro(expander, Some((def.id, def.span)), edition)\n+        let is_transparent = attr::contains_name(&def.attrs, \"rustc_transparent_macro\");\n+\n+        SyntaxExtension::DeclMacro {\n+            expander,\n+            def_info: Some((def.id, def.span)),\n+            is_transparent,\n+            edition,\n+        }\n     }\n }\n "}, {"sha": "82b0fae3e9c68e7ce93e82ca7d0d8926d56799b1", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -14,7 +14,7 @@ use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n-use syntax_pos::{BytePos, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span};\n use tokenstream;\n \n use std::iter::Peekable;\n@@ -41,8 +41,8 @@ impl Delimited {\n \n     /// Return a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let open_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.lo() + BytePos(self.delim.len() as u32))\n         };\n@@ -51,8 +51,8 @@ impl Delimited {\n \n     /// Return a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let close_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };"}, {"sha": "c443f240780317ef2671b3c1ecfdd4fbf22b1e2a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -13,7 +13,7 @@\n use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig};\n use codemap::{CodeMap, FilePathMapping};\n-use syntax_pos::{self, Span, FileMap, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileMap, FileName};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -188,8 +188,8 @@ fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<FileMap>) -> Parser {\n     let end_pos = filemap.end_pos;\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n \n-    if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n-        parser.span = Span::new(end_pos, end_pos, NO_EXPANSION);\n+    if parser.token == token::Eof && parser.span.is_dummy() {\n+        parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n     }\n \n     parser"}, {"sha": "673157d0ffa0db871c61f7730fc79d91af923086", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP, edition::Edition};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -567,7 +567,7 @@ impl<'a> Parser<'a> {\n \n         if let Some(directory) = directory {\n             parser.directory = directory;\n-        } else if !parser.span.source_equal(&DUMMY_SP) {\n+        } else if !parser.span.is_dummy() {\n             if let FileName::Real(mut path) = sess.codemap().span_to_unmapped_path(parser.span) {\n                 path.pop();\n                 parser.directory.path = Cow::from(path);\n@@ -584,7 +584,7 @@ impl<'a> Parser<'a> {\n         } else {\n             self.token_cursor.next()\n         };\n-        if next.sp == syntax_pos::DUMMY_SP {\n+        if next.sp.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n             next.sp = self.prev_span.with_ctxt(next.sp.ctxt());\n         }\n@@ -6138,7 +6138,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         }\n \n-        let hi = if self.span == syntax_pos::DUMMY_SP {\n+        let hi = if self.span.is_dummy() {\n             inner_lo\n         } else {\n             self.prev_span\n@@ -6369,7 +6369,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let mut err = self.diagnostic().struct_span_err(id_sp,\n                     \"cannot declare a new module at this location\");\n-                if id_sp != syntax_pos::DUMMY_SP {\n+                if !id_sp.is_dummy() {\n                     let src_path = self.sess.codemap().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n                         if let Some(stem) = src_path.file_stem() {"}, {"sha": "8736fcf9729a634d2f78a2f601abba147c938282", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -57,8 +57,8 @@ impl Delimited {\n \n     /// Returns the opening delimiter as a token tree.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let open_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n         };\n@@ -67,8 +67,8 @@ impl Delimited {\n \n     /// Returns the closing delimiter as a token tree.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let close_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };"}, {"sha": "33d02d0b10a7bd5283558892069b7d78f65cb1cf", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -33,14 +33,17 @@ pub struct SyntaxContext(pub(super) u32);\n pub struct SyntaxContextData {\n     pub outer_mark: Mark,\n     pub prev_ctxt: SyntaxContext,\n-    pub modern: SyntaxContext,\n+    // This context, but with all transparent and semi-transparent marks filtered away.\n+    pub opaque: SyntaxContext,\n+    // This context, but with all transparent marks filtered away.\n+    pub opaque_and_semitransparent: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n     transparency: Transparency,\n@@ -50,11 +53,10 @@ struct MarkData {\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n-    /// (Not used yet.)\n     Transparent,\n     /// Identifier produced by a semi-transparent expansion may be resolved\n     /// either at call-site or at definition-site.\n@@ -69,16 +71,26 @@ pub enum Transparency {\n }\n \n impl Mark {\n+    fn fresh_with_data(mark_data: MarkData, data: &mut HygieneData) -> Self {\n+        data.marks.push(mark_data);\n+        Mark(data.marks.len() as u32 - 1)\n+    }\n+\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n+            Mark::fresh_with_data(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n                 transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n-            });\n-            Mark(data.marks.len() as u32 - 1)\n+            }, data)\n+        })\n+    }\n+\n+    pub fn fresh_cloned(clone_from: Mark) -> Self {\n+        HygieneData::with(|data| {\n+            Mark::fresh_with_data(data.marks[clone_from.0 as usize].clone(), data)\n         })\n     }\n \n@@ -207,7 +219,8 @@ impl HygieneData {\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n                 prev_ctxt: SyntaxContext(0),\n-                modern: SyntaxContext(0),\n+                opaque: SyntaxContext(0),\n+                opaque_and_semitransparent: SyntaxContext(0),\n             }],\n             markings: HashMap::new(),\n             default_edition: Edition::Edition2015,\n@@ -239,7 +252,7 @@ impl SyntaxContext {\n     // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n     // deserializing Spans from the incr. comp. cache.\n     // FIXME(mw): This method does not restore MarkData::parent or\n-    // SyntaxContextData::prev_ctxt or SyntaxContextData::modern. These things\n+    // SyntaxContextData::prev_ctxt or SyntaxContextData::opaque. These things\n     // don't seem to be used after HIR lowering, so everything should be fine\n     // as long as incremental compilation does not kick in before that.\n     pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n@@ -256,7 +269,8 @@ impl SyntaxContext {\n             data.syntax_contexts.push(SyntaxContextData {\n                 outer_mark: mark,\n                 prev_ctxt: SyntaxContext::empty(),\n-                modern: SyntaxContext::empty(),\n+                opaque: SyntaxContext::empty(),\n+                opaque_and_semitransparent: SyntaxContext::empty(),\n             });\n             SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n         })\n@@ -269,7 +283,13 @@ impl SyntaxContext {\n         }\n \n         let call_site_ctxt =\n-            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt()).modern();\n+            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+        let call_site_ctxt = if mark.transparency() == Transparency::SemiTransparent {\n+            call_site_ctxt.modern()\n+        } else {\n+            call_site_ctxt.modern_and_legacy()\n+        };\n+\n         if call_site_ctxt == SyntaxContext::empty() {\n             return self.apply_mark_internal(mark);\n         }\n@@ -293,26 +313,53 @@ impl SyntaxContext {\n     fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n-            let mut modern = syntax_contexts[self.0 as usize].modern;\n-            if data.marks[mark.0 as usize].transparency == Transparency::Opaque {\n-                modern = *data.markings.entry((modern, mark)).or_insert_with(|| {\n-                    let len = syntax_contexts.len() as u32;\n+            let transparency = data.marks[mark.0 as usize].transparency;\n+\n+            let mut opaque = syntax_contexts[self.0 as usize].opaque;\n+            let mut opaque_and_semitransparent =\n+                syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n+\n+            if transparency >= Transparency::Opaque {\n+                let prev_ctxt = opaque;\n+                opaque = *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                    let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n+                    syntax_contexts.push(SyntaxContextData {\n+                        outer_mark: mark,\n+                        prev_ctxt,\n+                        opaque: new_opaque,\n+                        opaque_and_semitransparent: new_opaque,\n+                    });\n+                    new_opaque\n+                });\n+            }\n+\n+            if transparency >= Transparency::SemiTransparent {\n+                let prev_ctxt = opaque_and_semitransparent;\n+                opaque_and_semitransparent =\n+                        *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                    let new_opaque_and_semitransparent =\n+                        SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n-                        prev_ctxt: modern,\n-                        modern: SyntaxContext(len),\n+                        prev_ctxt,\n+                        opaque,\n+                        opaque_and_semitransparent: new_opaque_and_semitransparent,\n                     });\n-                    SyntaxContext(len)\n+                    new_opaque_and_semitransparent\n                 });\n             }\n \n-            *data.markings.entry((self, mark)).or_insert_with(|| {\n+            let prev_ctxt = self;\n+            *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                let new_opaque_and_semitransparent_and_transparent =\n+                    SyntaxContext(syntax_contexts.len() as u32);\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n-                    prev_ctxt: self,\n-                    modern,\n+                    prev_ctxt,\n+                    opaque,\n+                    opaque_and_semitransparent,\n                 });\n-                SyntaxContext(syntax_contexts.len() as u32 - 1)\n+                new_opaque_and_semitransparent_and_transparent\n             })\n         })\n     }\n@@ -452,7 +499,12 @@ impl SyntaxContext {\n \n     #[inline]\n     pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].modern)\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque)\n+    }\n+\n+    #[inline]\n+    pub fn modern_and_legacy(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque_and_semitransparent)\n     }\n \n     #[inline]"}, {"sha": "491ce720f36c5f0eacd0408dd07a6c99f5e1a65e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -248,6 +248,13 @@ impl Span {\n         self.data().with_ctxt(ctxt)\n     }\n \n+    /// Returns `true` if this is a dummy span with any hygienic context.\n+    #[inline]\n+    pub fn is_dummy(self) -> bool {\n+        let span = self.data();\n+        span.lo.0 == 0 && span.hi.0 == 0\n+    }\n+\n     /// Returns a new span representing an empty span at the beginning of this span\n     #[inline]\n     pub fn shrink_to_lo(self) -> Span {\n@@ -263,7 +270,7 @@ impl Span {\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n-        if self.source_equal(&DUMMY_SP) { other } else { self }\n+        if self.is_dummy() { other } else { self }\n     }\n \n     /// Return true if `self` fully encloses `other`.\n@@ -491,6 +498,12 @@ impl Span {\n         let span = self.data();\n         span.with_ctxt(span.ctxt.modern())\n     }\n+\n+    #[inline]\n+    pub fn modern_and_legacy(self) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.modern_and_legacy())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "9a0c92f679366929916399b3aa08c655fe863dbb", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -68,6 +68,15 @@ impl Ident {\n         Ident::new(self.name, self.span.modern())\n     }\n \n+    /// \"Normalize\" ident for use in comparisons using \"local variable hygiene\".\n+    /// Identifiers with same string value become same if they came from the same non-transparent\n+    /// macro (e.g. `macro` or `macro_rules!` items) and stay different if they came from different\n+    /// non-transparent macros.\n+    /// Technically, this operation strips all transparent marks from ident's syntactic context.\n+    pub fn modern_and_legacy(self) -> Ident {\n+        Ident::new(self.name, self.span.modern_and_legacy())\n+    }\n+\n     pub fn gensym(self) -> Ident {\n         Ident::new(self.name.gensymed(), self.span)\n     }"}, {"sha": "6473b69b4591d3169163caed83305dbe33d85dfd", "filename": "src/test/compile-fail-fulldeps/proc-macro/lints_in_proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -23,5 +23,5 @@ fn main() {\n     bang_proc_macro2!();\n     //~^ ERROR cannot find value `foobar2` in this scope\n     //~^^ did you mean `foobar`?\n-    println!(\"{}\", x); //~ ERROR cannot find value `x` in this scope\n+    println!(\"{}\", x);\n }"}, {"sha": "ab4e082ed74fcb856cd5890796e36e21701dedfc", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/call-site.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn check(input: TokenStream) -> TokenStream {\n+    // Parsed `x2` can refer to `x2` from `input`\n+    let parsed1: TokenStream = \"let x3 = x2;\".parse().unwrap();\n+    // `x3` parsed from one string can refer to `x3` parsed from another string.\n+    let parsed2: TokenStream = \"let x4 = x3;\".parse().unwrap();\n+    // Manually assembled `x4` can refer to parsed `x4`.\n+    let manual: Vec<TokenTree> = vec![\n+        Ident::new(\"let\", Span::call_site()).into(),\n+        Ident::new(\"x5\", Span::call_site()).into(),\n+        Punct::new('=', Spacing::Alone).into(),\n+        Ident::new(\"x4\", Span::call_site()).into(),\n+        Punct::new(';', Spacing::Alone).into(),\n+    ];\n+    input.into_iter().chain(parsed1.into_iter())\n+                     .chain(parsed2.into_iter())\n+                     .chain(manual.into_iter())\n+                     .collect()\n+}"}, {"sha": "f0d48972894ae31ecbfaeb60fbbc7f585edd31fa", "filename": "src/test/run-pass-fulldeps/proc-macro/call-site.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:call-site.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro, proc_macro_non_items)]\n+\n+extern crate call_site;\n+use call_site::*;\n+\n+fn main() {\n+    let x1 = 10;\n+    call_site::check!(let x2 = x1;);\n+    let x6 = x5;\n+}"}, {"sha": "f917fabbe0c589180a5fc5bddea68df675ce2d93", "filename": "src/test/ui/hygiene/auxiliary/intercrate.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -19,3 +19,38 @@ pub mod foo {\n         }\n     }\n }\n+\n+pub struct SomeType;\n+\n+// `$crate`\n+pub macro uses_dollar_crate_modern() {\n+    type Alias = $crate::SomeType;\n+}\n+\n+pub macro define_uses_dollar_crate_modern_nested($uses_dollar_crate_modern_nested: ident) {\n+    macro $uses_dollar_crate_modern_nested() {\n+        type AliasCrateModernNested = $crate::SomeType;\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! define_uses_dollar_crate_legacy_nested {\n+    () => {\n+        macro_rules! uses_dollar_crate_legacy_nested {\n+            () => {\n+                type AliasLegacyNested = $crate::SomeType;\n+            }\n+        }\n+    }\n+}\n+\n+// `crate`\n+pub macro uses_crate_modern() {\n+    type AliasCrate = crate::SomeType;\n+}\n+\n+pub macro define_uses_crate_modern_nested($uses_crate_modern_nested: ident) {\n+    macro $uses_crate_modern_nested() {\n+        type AliasCrateModernNested = crate::SomeType;\n+    }\n+}"}, {"sha": "ba65c5f4da80c4eeac98852f8a2899616b42b32d", "filename": "src/test/ui/hygiene/auxiliary/transparent-basic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_transparent_macro]\n+pub macro dollar_crate() {\n+    let s = $crate::S;\n+}"}, {"sha": "6e536ab14221557f7b32affb643488a6ac7b97c1", "filename": "src/test/ui/hygiene/dollar-crate-modern.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure `$crate` and `crate` work in for basic cases of nested macros.\n+\n+// compile-pass\n+// aux-build:intercrate.rs\n+\n+#![feature(decl_macro, crate_in_paths)]\n+\n+extern crate intercrate;\n+\n+// `$crate`\n+intercrate::uses_dollar_crate_modern!();\n+\n+intercrate::define_uses_dollar_crate_modern_nested!(uses_dollar_crate_modern_nested);\n+uses_dollar_crate_modern_nested!();\n+\n+intercrate::define_uses_dollar_crate_legacy_nested!();\n+uses_dollar_crate_legacy_nested!();\n+\n+// `crate`\n+intercrate::uses_crate_modern!();\n+\n+intercrate::define_uses_crate_modern_nested!(uses_crate_modern_nested);\n+uses_crate_modern_nested!();\n+\n+fn main() {}"}, {"sha": "90409857deadcff726cf6d448c785344db44355e", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is an equivalent of issue #50504, but for declarative macros.\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_transparent_macro]\n+macro genmod() {\n+    mod m {\n+        type A = S; //~ ERROR cannot find type `S` in this scope\n+    }\n+}\n+\n+struct S;\n+\n+genmod!();"}, {"sha": "e79f8528c2cd7a42de0ca5064ab731190832cb70", "filename": "src/test/ui/hygiene/generate-mod.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,17 @@\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/generate-mod.rs:18:18\n+   |\n+LL |         type A = S; //~ ERROR cannot find type `S` in this scope\n+   |                  ^ did you mean `A`?\n+...\n+LL | genmod!();\n+   | ---------- in this macro invocation\n+\n+error[E0601]: `main` function not found in crate `generate_mod`\n+   |\n+   = note: consider adding a `main` function to `$DIR/generate-mod.rs`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0412, E0601.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "81ece1f11bc6aa90e5a832276ccbea3f4d36dd5c", "filename": "src/test/ui/hygiene/transparent-basic.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc1ee4968ff5778cd80e12150f379ddfe6c2767/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs?ref=bfc1ee4968ff5778cd80e12150f379ddfe6c2767", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// aux-build:transparent-basic.rs\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+extern crate transparent_basic;\n+\n+#[rustc_transparent_macro]\n+macro binding() {\n+    let x = 10;\n+}\n+\n+#[rustc_transparent_macro]\n+macro label() {\n+    break 'label\n+}\n+\n+macro_rules! legacy {\n+    () => {\n+        binding!();\n+        let y = x;\n+    }\n+}\n+\n+fn legacy_interaction1() {\n+    legacy!();\n+}\n+\n+struct S;\n+\n+fn check_dollar_crate() {\n+    // `$crate::S` inside the macro resolves to `S` from this crate.\n+    transparent_basic::dollar_crate!();\n+}\n+\n+fn main() {\n+    binding!();\n+    let y = x;\n+\n+    'label: loop {\n+        label!();\n+    }\n+}"}]}