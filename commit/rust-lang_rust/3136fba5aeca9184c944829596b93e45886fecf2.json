{"sha": "3136fba5aeca9184c944829596b93e45886fecf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMzZmYmE1YWVjYTkxODRjOTQ0ODI5NTk2YjkzZTQ1ODg2ZmVjZjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-24T16:41:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-08T21:50:14Z"}, "message": "Removing some mutable fields in libstd", "tree": {"sha": "d8613aa519f2b5de0fa8d5a8bcb9841e6f0709f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8613aa519f2b5de0fa8d5a8bcb9841e6f0709f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3136fba5aeca9184c944829596b93e45886fecf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3136fba5aeca9184c944829596b93e45886fecf2", "html_url": "https://github.com/rust-lang/rust/commit/3136fba5aeca9184c944829596b93e45886fecf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3136fba5aeca9184c944829596b93e45886fecf2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5641777318239926363207f690bf265f7514a63c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5641777318239926363207f690bf265f7514a63c", "html_url": "https://github.com/rust-lang/rust/commit/5641777318239926363207f690bf265f7514a63c"}], "stats": {"total": 183, "additions": 91, "deletions": 92}, "files": [{"sha": "585ce2dc8150047a487b5b904ed5ef777e050471", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -259,7 +259,7 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n  */\n struct RWARC<T> {\n     x: SharedMutableState<RWARCInner<T>>,\n-    mut cant_nest: ()\n+    cant_nest: ()\n }\n \n /// Create a reader/writer ARC with the supplied data."}, {"sha": "5a2bfd2113b90bf4aa8cfb5a65de15c58492570b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -360,9 +360,9 @@ pub fn to_pretty_str(json: &Json) -> ~str {\n \n pub struct Parser {\n     priv rdr: @io::Reader,\n-    priv mut ch: char,\n-    priv mut line: uint,\n-    priv mut col: uint,\n+    priv ch: char,\n+    priv line: uint,\n+    priv col: uint,\n }\n \n /// Decode a json value from an io::reader\n@@ -376,7 +376,7 @@ pub fn Parser(rdr: @io::Reader) -> Parser {\n }\n \n pub impl Parser {\n-    fn parse(&self) -> Result<Json, Error> {\n+    fn parse(&mut self) -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -396,7 +396,7 @@ pub impl Parser {\n priv impl Parser {\n     fn eof(&self) -> bool { self.ch == -1 as char }\n \n-    fn bump(&self) {\n+    fn bump(&mut self) {\n         self.ch = self.rdr.read_char();\n \n         if self.ch == '\\n' {\n@@ -407,7 +407,7 @@ priv impl Parser {\n         }\n     }\n \n-    fn next_char(&self) -> char {\n+    fn next_char(&mut self) -> char {\n         self.bump();\n         self.ch\n     }\n@@ -416,7 +416,7 @@ priv impl Parser {\n         Err(Error { line: self.line, col: self.col, msg: @msg })\n     }\n \n-    fn parse_value(&self) -> Result<Json, Error> {\n+    fn parse_value(&mut self) -> Result<Json, Error> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n@@ -437,11 +437,11 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_whitespace(&self) {\n+    fn parse_whitespace(&mut self) {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(&self, ident: &str, value: Json) -> Result<Json, Error> {\n+    fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n@@ -450,7 +450,7 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_number(&self) -> Result<Json, Error> {\n+    fn parse_number(&mut self) -> Result<Json, Error> {\n         let mut neg = 1f;\n \n         if self.ch == '-' {\n@@ -480,7 +480,7 @@ priv impl Parser {\n         Ok(Number(neg * res))\n     }\n \n-    fn parse_integer(&self) -> Result<float, Error> {\n+    fn parse_integer(&mut self) -> Result<float, Error> {\n         let mut res = 0f;\n \n         match self.ch {\n@@ -512,7 +512,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&self, res: float) -> Result<float, Error> {\n+    fn parse_decimal(&mut self, res: float) -> Result<float, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -538,10 +538,9 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_exponent(&self, res: float) -> Result<float, Error> {\n+    fn parse_exponent(&mut self, mut res: float) -> Result<float, Error> {\n         self.bump();\n \n-        let mut res = res;\n         let mut exp = 0u;\n         let mut neg_exp = false;\n \n@@ -579,7 +578,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_str(&self) -> Result<~str, Error> {\n+    fn parse_str(&mut self) -> Result<~str, Error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -643,7 +642,7 @@ priv impl Parser {\n         self.error(~\"EOF while parsing string\")\n     }\n \n-    fn parse_list(&self) -> Result<Json, Error> {\n+    fn parse_list(&mut self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -673,7 +672,7 @@ priv impl Parser {\n         };\n     }\n \n-    fn parse_object(&self) -> Result<Json, Error> {\n+    fn parse_object(&mut self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -726,7 +725,8 @@ priv impl Parser {\n \n /// Decodes a json value from an @io::Reader\n pub fn from_reader(rdr: @io::Reader) -> Result<Json, Error> {\n-    Parser(rdr).parse()\n+    let mut parser = Parser(rdr);\n+    parser.parse()\n }\n \n /// Decodes a json value from a string"}, {"sha": "949850f3ca6771d8c96c8545dbe56fe139932a2d", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -239,7 +239,6 @@ mod test {\n \n     mod arith {\n         use super::*;\n-        use super::super::*;\n         use core::num::Zero;\n \n         #[test]"}, {"sha": "232f46b6676df6fc4a8af620445bb106a416247a", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -455,7 +455,7 @@ pub mod iterator {\n               node::Content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n-        pub fn next(it: &node::leaf_iterator::T) -> Option<node::Leaf> {\n+        pub fn next(it: &mut node::leaf_iterator::T) -> Option<node::Leaf> {\n             return node::leaf_iterator::next(it);\n         }\n     }\n@@ -470,7 +470,7 @@ pub mod iterator {\n               node::Content(x) => return node::char_iterator::start(x)\n             }\n         }\n-        pub fn next(it: &node::char_iterator::T) -> Option<char> {\n+        pub fn next(it: &mut node::char_iterator::T) -> Option<char> {\n             return node::char_iterator::next(it)\n         }\n     }\n@@ -832,9 +832,9 @@ pub mod node {\n         unsafe {\n             let mut buf = vec::from_elem(byte_len(node), 0);\n             let mut offset = 0u;//Current position in the buffer\n-            let it = leaf_iterator::start(node);\n+            let mut it = leaf_iterator::start(node);\n             loop {\n-                match (leaf_iterator::next(&it)) {\n+                match leaf_iterator::next(&mut it) {\n                   option::None => break,\n                   option::Some(x) => {\n                     //FIXME (#2744): Replace with memcpy or something similar\n@@ -896,9 +896,9 @@ pub mod node {\n         if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[];\n-        let it = leaf_iterator::start(node);\n+        let mut it = leaf_iterator::start(node);\n         loop {\n-            match (leaf_iterator::next(&it)) {\n+            match leaf_iterator::next(&mut it) {\n               option::None    => break,\n               option::Some(x) => forest.push(@Leaf(x))\n             }\n@@ -1058,11 +1058,12 @@ pub mod node {\n     }\n \n     pub fn cmp(a: @Node, b: @Node) -> int {\n-        let ita = char_iterator::start(a);\n-        let itb = char_iterator::start(b);\n+        let mut ita = char_iterator::start(a);\n+        let mut itb = char_iterator::start(b);\n         let mut result = 0;\n         while result == 0 {\n-            match ((char_iterator::next(&ita), char_iterator::next(&itb))) {\n+            match (char_iterator::next(&mut ita), char_iterator::next(&mut itb))\n+            {\n               (option::None, option::None) => break,\n               (option::Some(chara), option::Some(charb)) => {\n                 result = char::cmp(chara, charb);\n@@ -1131,9 +1132,7 @@ pub mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    pub fn char_at(node: @Node, pos: uint) -> char {\n-        let mut node    = node;\n-        let mut pos     = pos;\n+    pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n         loop {\n             match *node {\n               Leaf(x) => return str::char_at(*x.content, pos),\n@@ -1154,8 +1153,8 @@ pub mod node {\n         use core::vec;\n \n         pub struct T {\n-            mut stack: ~[@Node],\n-            mut stackpos: int,\n+            stack: ~[@Node],\n+            stackpos: int,\n         }\n \n         pub fn empty() -> T {\n@@ -1171,7 +1170,7 @@ pub mod node {\n             }\n         }\n \n-        pub fn next(it: &T) -> Option<Leaf> {\n+        pub fn next(it: &mut T) -> Option<Leaf> {\n             if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n@@ -1199,8 +1198,8 @@ pub mod node {\n \n         pub struct T {\n             leaf_iterator: leaf_iterator::T,\n-            mut leaf:  Option<Leaf>,\n-            mut leaf_byte_pos: uint,\n+            leaf:  Option<Leaf>,\n+            leaf_byte_pos: uint,\n         }\n \n         pub fn start(node: @Node) -> T {\n@@ -1219,13 +1218,13 @@ pub mod node {\n             }\n         }\n \n-        pub fn next(it: &T) -> Option<char> {\n+        pub fn next(it: &mut T) -> Option<char> {\n             loop {\n-                match (get_current_or_next_leaf(it)) {\n+                match get_current_or_next_leaf(it) {\n                   option::None => return option::None,\n                   option::Some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n-                    match (next_char) {\n+                    match next_char {\n                       option::None => loop,\n                       option::Some(_) => return next_char\n                     }\n@@ -1234,30 +1233,30 @@ pub mod node {\n             };\n         }\n \n-        pub fn get_current_or_next_leaf(it: &T) -> Option<Leaf> {\n-            match ((*it).leaf) {\n-              option::Some(_) => return (*it).leaf,\n+        pub fn get_current_or_next_leaf(it: &mut T) -> Option<Leaf> {\n+            match it.leaf {\n+              option::Some(_) => return it.leaf,\n               option::None => {\n-                let next = leaf_iterator::next(&((*it).leaf_iterator));\n-                match (next) {\n+                let next = leaf_iterator::next(&mut it.leaf_iterator);\n+                match next {\n                   option::None => return option::None,\n                   option::Some(_) => {\n-                    (*it).leaf          = next;\n-                    (*it).leaf_byte_pos = 0u;\n+                    it.leaf          = next;\n+                    it.leaf_byte_pos = 0u;\n                     return next;\n                   }\n                 }\n               }\n             }\n         }\n \n-        pub fn get_next_char_in_leaf(it: &T) -> Option<char> {\n-            match copy (*it).leaf {\n+        pub fn get_next_char_in_leaf(it: &mut T) -> Option<char> {\n+            match copy it.leaf {\n               option::None => return option::None,\n               option::Some(aleaf) => {\n-                if (*it).leaf_byte_pos >= aleaf.byte_len {\n+                if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n-                    (*it).leaf = option::None;\n+                    it.leaf = option::None;\n                     return option::None\n                 } else {\n                     let range =\n@@ -1342,11 +1341,11 @@ mod tests {\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n-        let string_len  = str::len(*sample);\n-        let rope_iter   = iterator::char::start(r);\n-        let mut equal   = true;\n+        let string_len = str::len(*sample);\n+        let mut rope_iter = iterator::char::start(r);\n+        let mut equal = true;\n         while equal {\n-            match (node::char_iterator::next(&rope_iter)) {\n+            match (node::char_iterator::next(&mut rope_iter)) {\n               option::None => {\n                 if string_iter < string_len {\n                     equal = false;\n@@ -1376,9 +1375,9 @@ mod tests {\n         let r      = of_str(sample);\n \n         let mut len = 0u;\n-        let it  = iterator::char::start(r);\n+        let mut it  = iterator::char::start(r);\n         loop {\n-            match (node::char_iterator::next(&it)) {\n+            match (node::char_iterator::next(&mut it)) {\n               option::None => break,\n               option::Some(_) => len += 1u\n             }"}, {"sha": "1bfdd7f99d501c0ceafaf9a8f2fdc0e24d02455b", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -72,7 +72,7 @@ fn broadcast_waitqueue(q: &Waitqueue) -> uint {\n // The building-block used to make semaphores, mutexes, and rwlocks.\n #[doc(hidden)]\n struct SemInner<Q> {\n-    mut count: int,\n+    count: int,\n     waiters:   Waitqueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n@@ -729,7 +729,6 @@ mod tests {\n \n     use core::cast;\n     use core::cell::Cell;\n-    use core::option;\n     use core::ptr;\n     use core::result;\n     use core::task;"}, {"sha": "3f2772942a5cb60187f18fbda6f91949ab5b5a6a", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -26,8 +26,7 @@ enum Msg<T> {\n \n pub struct TaskPool<T> {\n     channels: ~[Chan<Msg<T>>],\n-    mut next_index: uint,\n-\n+    next_index: uint,\n }\n \n #[unsafe_destructor]\n@@ -84,7 +83,7 @@ pub impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    fn execute(&self, f: ~fn(&T)) {\n+    fn execute(&mut self, f: ~fn(&T)) {\n         self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -97,7 +96,7 @@ fn test_task_pool() {\n         let g: ~fn(uint) -> uint = |i| i;\n         g\n     };\n-    let pool = TaskPool::new(4, Some(SingleThreaded), f);\n+    let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n     for 8.times {\n         pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n     }"}, {"sha": "04fa319b25530f2dc4ba5be6394c24ab9397d7ba", "filename": "src/libstd/test.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3136fba5aeca9184c944829596b93e45886fecf2/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=3136fba5aeca9184c944829596b93e45886fecf2", "patch": "@@ -201,19 +201,19 @@ struct ConsoleTestState {\n     out: @io::Writer,\n     log_out: Option<@io::Writer>,\n     use_color: bool,\n-    mut total: uint,\n-    mut passed: uint,\n-    mut failed: uint,\n-    mut ignored: uint,\n-    mut benchmarked: uint,\n-    mut failures: ~[TestDesc]\n+    total: uint,\n+    passed: uint,\n+    failed: uint,\n+    ignored: uint,\n+    benchmarked: uint,\n+    failures: ~[TestDesc]\n }\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n \n-    fn callback(event: &TestEvent, st: @ConsoleTestState) {\n+    fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match *event {\n           TeFiltered(ref filtered_tests) => {\n@@ -268,16 +268,16 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => None\n     };\n \n-    let st = @ConsoleTestState {\n+    let st = @mut ConsoleTestState {\n         out: io::stdout(),\n         log_out: log_out,\n         use_color: use_color(),\n-        mut total: 0u,\n-        mut passed: 0u,\n-        mut failed: 0u,\n-        mut ignored: 0u,\n-        mut benchmarked: 0u,\n-        mut failures: ~[]\n+        total: 0u,\n+        passed: 0u,\n+        failed: 0u,\n+        ignored: 0u,\n+        benchmarked: 0u,\n+        failures: ~[]\n     };\n \n     run_tests(opts, tests, |x| callback(&x, st));\n@@ -290,15 +290,18 @@ pub fn run_tests_console(opts: &TestOpts,\n         print_failures(st);\n     }\n \n-    st.out.write_str(fmt!(\"\\nresult: \"));\n-    if success {\n-        // There's no parallelism at this point so it's safe to use color\n-        write_ok(st.out, true);\n-    } else {\n-        write_failed(st.out, true);\n+    {\n+      let st: &mut ConsoleTestState = st;\n+      st.out.write_str(fmt!(\"\\nresult: \"));\n+      if success {\n+          // There's no parallelism at this point so it's safe to use color\n+          write_ok(st.out, true);\n+      } else {\n+          write_failed(st.out, true);\n+      }\n+      st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n+                            st.passed, st.failed, st.ignored));\n     }\n-    st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n-                          st.passed, st.failed, st.ignored));\n \n     return success;\n \n@@ -356,7 +359,7 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n }\n \n-fn print_failures(st: @ConsoleTestState) {\n+fn print_failures(st: &ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let mut failures = ~[];\n     for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n@@ -390,12 +393,12 @@ fn should_sort_failures_before_printing_them() {\n             out: wr,\n             log_out: option::None,\n             use_color: false,\n-            mut total: 0u,\n-            mut passed: 0u,\n-            mut failed: 0u,\n-            mut ignored: 0u,\n-            mut benchmarked: 0u,\n-            mut failures: ~[test_b, test_a]\n+            total: 0u,\n+            passed: 0u,\n+            failed: 0u,\n+            ignored: 0u,\n+            benchmarked: 0u,\n+            failures: ~[test_b, test_a]\n         };\n \n         print_failures(st);"}]}