{"sha": "060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MGUwZTlmOTM4MmNiNzk3NTE2NWNlZGU4ZDA0YjdiYmUyNmJjYjI=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-14T15:17:07Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection lint: Basic applicability collection", "tree": {"sha": "bcdfde66c42033ff3b7bfab2ad15e2c4c217a279", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcdfde66c42033ff3b7bfab2ad15e2c4c217a279"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "html_url": "https://github.com/rust-lang/rust/commit/060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060e0e9f9382cb7975165cede8d04b7bbe26bcb2/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "637751ff62662247480ae1641042a019d8e6609a", "url": "https://api.github.com/repos/rust-lang/rust/commits/637751ff62662247480ae1641042a019d8e6609a", "html_url": "https://github.com/rust-lang/rust/commit/637751ff62662247480ae1641042a019d8e6609a"}], "stats": {"total": 180, "additions": 147, "deletions": 33}, "files": [{"sha": "677f9fcc83f2d709ebd0900c1b3f7f57f0950707", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 145, "deletions": 33, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/060e0e9f9382cb7975165cede8d04b7bbe26bcb2/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060e0e9f9382cb7975165cede8d04b7bbe26bcb2/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "patch": "@@ -2,10 +2,14 @@\n //! file and then used to generate the [clippy lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n //!\n //! This module and therefor the entire lint is guarded by a feature flag called\n-//! `internal_metadata_lint`\n+//! `metadata-collector-lint`\n+//!\n+//! The module transforms all lint names to ascii lowercase to ensure that we don't have mismatches\n+//! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n+//! a simple mistake)\n //!\n //! The metadata currently contains:\n-//! - [ ] TODO The lint declaration line for [#1303](https://github.com/rust-lang/rust-clippy/issues/1303)\n+//! - [x] TODO The lint declaration line for [#1303](https://github.com/rust-lang/rust-clippy/issues/1303)\n //!   and [#6492](https://github.com/rust-lang/rust-clippy/issues/6492)\n //! - [ ] TODO The Applicability for each lint for [#4310](https://github.com/rust-lang/rust-clippy/issues/4310)\n \n@@ -17,20 +21,34 @@\n // - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n \n use if_chain::if_chain;\n-use rustc_hir::{ExprKind, Item, ItemKind, Mutability};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::{self as hir, ExprKind, Item, ItemKind, Mutability};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, Loc, Span};\n+use rustc_span::{sym, Loc, Span, Symbol};\n use serde::Serialize;\n use std::fs::OpenOptions;\n use std::io::prelude::*;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n-use crate::utils::span_lint;\n+use crate::utils::{last_path_segment, match_function_call, match_type, paths, span_lint, walk_ptrs_ty_depth};\n \n+/// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"metadata_collection.json\";\n+/// These lints are excluded from the export.\n const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n \n+// TODO xFrednet 2021-02-15: `span_lint_and_then` & `span_lint_hir_and_then` requires special\n+// handling\n+#[rustfmt::skip]\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n+    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint\"],\n+    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_help\"],\n+    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_note\"],\n+    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_hir\"],\n+    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n+];\n+\n declare_clippy_lint! {\n     /// **What it does:** Collects metadata about clippy lints for the website.\n     ///\n@@ -66,12 +84,21 @@ impl_lint_pass!(MetadataCollector => [INTERNAL_METADATA_COLLECTOR]);\n #[derive(Debug, Clone, Default)]\n pub struct MetadataCollector {\n     lints: Vec<LintMetadata>,\n+    applicability_into: FxHashMap<String, ApplicabilityInfo>,\n }\n \n impl Drop for MetadataCollector {\n+    /// You might ask: How hacky is this?\n+    /// My answer:     YES\n     fn drop(&mut self) {\n-        // You might ask: How hacky is this?\n-        // My answer:     YES\n+        let mut applicability_info = std::mem::take(&mut self.applicability_into);\n+\n+        // Mapping the final data\n+        self.lints\n+            .iter_mut()\n+            .for_each(|x| x.applicability = applicability_info.remove(&x.id));\n+\n+        // Outputting\n         let mut file = OpenOptions::new().write(true).create(true).open(OUTPUT_FILE).unwrap();\n         writeln!(file, \"{}\", serde_json::to_string_pretty(&self.lints).unwrap()).unwrap();\n     }\n@@ -83,6 +110,21 @@ struct LintMetadata {\n     id_span: SerializableSpan,\n     group: String,\n     docs: String,\n+    /// This field is only used in the output and will only be\n+    /// mapped shortly before the actual output.\n+    applicability: Option<ApplicabilityInfo>,\n+}\n+\n+impl LintMetadata {\n+    fn new(id: String, id_span: SerializableSpan, group: String, docs: String) -> Self {\n+        Self {\n+            id,\n+            id_span,\n+            group,\n+            docs,\n+            applicability: None,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Serialize)]\n@@ -101,12 +143,31 @@ impl SerializableSpan {\n \n         Self {\n             path: format!(\"{}\", loc.file.name),\n-            line: 1,\n+            line: loc.line,\n         }\n     }\n }\n \n+#[derive(Debug, Clone, Default, Serialize)]\n+struct ApplicabilityInfo {\n+    /// Indicates if any of the lint emissions uses multiple spans. This is related to\n+    /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n+    /// currently not be applied automatically.\n+    has_multi_suggestion: bool,\n+    /// These are all the available applicability values for the lint suggestions\n+    applicabilities: FxHashSet<String>,\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n+    /// Collecting lint declarations like:\n+    /// ```rust, ignore\n+    /// declare_clippy_lint! {\n+    ///     /// **What it does:** Something IDK.\n+    ///     pub SOME_LINT,\n+    ///     internal,\n+    ///     \"Who am I?\"\n+    /// }\n+    /// ```\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Static(ref ty, Mutability::Not, body_id) = item.kind;\n@@ -115,7 +176,7 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n             if let ExprKind::AddrOf(_, _, ref inner_exp) = expr.kind;\n             if let ExprKind::Struct(_, _, _) = inner_exp.kind;\n             then {\n-                let lint_name = item.ident.name.as_str().to_string().to_ascii_lowercase();\n+                let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n                 if BLACK_LISTED_LINTS.contains(&lint_name.as_str()) {\n                     return;\n                 }\n@@ -126,33 +187,50 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n                     if let Some(group_some) = get_lint_group(cx, lint_lst[0]) {\n                         group = group_some;\n                     } else {\n-                        lint_collection_error(cx, item, \"Unable to determine lint group\");\n+                        lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n                         return;\n                     }\n                 } else {\n-                    lint_collection_error(cx, item, \"Unable to find lint in lint_store\");\n+                    lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n                     return;\n                 }\n \n                 let docs: String;\n                 if let Some(docs_some) = extract_attr_docs(item) {\n                     docs = docs_some;\n                 } else {\n-                    lint_collection_error(cx, item, \"could not collect the lint documentation\");\n+                    lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n                     return;\n                 };\n \n-                self.lints.push(LintMetadata {\n-                    id: lint_name,\n-                    id_span: SerializableSpan::from_item(cx, item),\n+                self.lints.push(LintMetadata::new(\n+                    lint_name,\n+                    SerializableSpan::from_item(cx, item),\n                     group,\n                     docs,\n+                ));\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if let Some(args) = match_simple_lint_emission(cx, expr) {\n+            if let Some((lint_name, mut applicability)) = extract_emission_info(cx, args) {\n+                let app_info = self.applicability_into.entry(lint_name).or_default();\n+                applicability.drain(..).for_each(|x| {\n+                    app_info.applicabilities.insert(x);\n                 });\n+            } else {\n+                lint_collection_error_span(cx, expr.span, \"I found this but I can't get the lint or applicability\");\n             }\n         }\n     }\n }\n \n+fn sym_to_string(sym: Symbol) -> String {\n+    sym.as_str().to_string()\n+}\n+\n /// This function collects all documentation that has been added to an item using\n /// `#[doc = r\"\"]` attributes. Several attributes are aggravated using line breaks\n ///\n@@ -166,23 +244,11 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n fn extract_attr_docs(item: &Item<'_>) -> Option<String> {\n     item.attrs\n         .iter()\n-        .filter_map(|ref x| x.doc_str())\n-        .fold(None, |acc, sym| {\n-            let mut doc_str = sym.as_str().to_string();\n-            doc_str.push('\\n');\n-\n-            #[allow(clippy::option_if_let_else)] // See clippy#6737\n-            if let Some(mut x) = acc {\n-                x.push_str(&doc_str);\n-                Some(x)\n-            } else {\n-                Some(doc_str)\n-            }\n-\n-            // acc.map_or(Some(doc_str), |mut x| {\n-            //     x.push_str(&doc_str);\n-            //     Some(x)\n-            // })\n+        .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n+        .reduce(|mut acc, sym| {\n+            acc.push_str(&sym);\n+            acc.push('\\n');\n+            acc\n         })\n }\n \n@@ -196,11 +262,57 @@ fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n     None\n }\n \n-fn lint_collection_error(cx: &LateContext<'_>, item: &Item<'_>, message: &str) {\n+fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &str) {\n     span_lint(\n         cx,\n         INTERNAL_METADATA_COLLECTOR,\n         item.ident.span,\n         &format!(\"Metadata collection error for `{}`: {}\", item.ident.name, message),\n     );\n }\n+\n+fn lint_collection_error_span(cx: &LateContext<'_>, span: Span, message: &str) {\n+    span_lint(\n+        cx,\n+        INTERNAL_METADATA_COLLECTOR,\n+        span,\n+        &format!(\"Metadata collection error: {}\", message),\n+    );\n+}\n+\n+fn match_simple_lint_emission<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+) -> Option<&'tcx [hir::Expr<'tcx>]> {\n+    LINT_EMISSION_FUNCTIONS\n+        .iter()\n+        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn).map(|args| args))\n+}\n+\n+/// This returns the lint name and the possible applicability of this emission\n+fn extract_emission_info<'tcx>(cx: &LateContext<'tcx>, args: &[hir::Expr<'_>]) -> Option<(String, Vec<String>)> {\n+    let mut lint_name = None;\n+    let mut applicability = None;\n+\n+    for arg in args {\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+\n+        if match_type(cx, arg_ty, &paths::LINT) {\n+            // If we found the lint arg, extract the lint name\n+            if let ExprKind::Path(ref lint_path) = arg.kind {\n+                lint_name = Some(last_path_segment(lint_path).ident.name)\n+            }\n+        } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n+            if let ExprKind::Path(ref path) = arg.kind {\n+                applicability = Some(last_path_segment(path).ident.name)\n+            }\n+        }\n+    }\n+\n+    lint_name.map(|lint_name| {\n+        (\n+            sym_to_string(lint_name).to_ascii_lowercase(),\n+            applicability.map(sym_to_string).map_or_else(Vec::new, |x| vec![x]),\n+        )\n+    })\n+}"}, {"sha": "91e5cd6c0465e99acc92ca884f133258ffe302d6", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/060e0e9f9382cb7975165cede8d04b7bbe26bcb2/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060e0e9f9382cb7975165cede8d04b7bbe26bcb2/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "patch": "@@ -5,6 +5,8 @@\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];"}]}