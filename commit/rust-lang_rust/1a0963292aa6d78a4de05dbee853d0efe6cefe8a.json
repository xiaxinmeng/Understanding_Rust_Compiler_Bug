{"sha": "1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMDk2MzI5MmFhNmQ3OGE0ZGUwNWRiZWU4NTNkMGVmZTZjZWZlOGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-11-04T23:49:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-04T23:49:28Z"}, "message": "Rollup merge of #37408 - eddyb:lazy-5, r=nikomatsakis\n\n[5/n] rustc: record the target type of every adjustment.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/37404) | [next](https://github.com/rust-lang/rust/pull/37412)) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nThe first commit rearranges `tcx.tables` so that all users go through `tcx.tables()`. This in preparation for per-body `Tables` where they will be requested for a specific `DefId`. Included to minimize churn.\n\nThe rest of the changes focus on adjustments, there are some renamings, but the main addition is the target type, always available in all cases (as opposed to just for unsizing where it was previously needed).\n\nPossibly the most significant effect of this change is that figuring out the final type of an expression is now _always_ just one successful `HashMap` lookup (either the adjustment or, if that doesn't exist, the node type).", "tree": {"sha": "d26617dc78f4b280ab0198147a92d114f80877f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d26617dc78f4b280ab0198147a92d114f80877f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "html_url": "https://github.com/rust-lang/rust/commit/1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f6a71e3e030bbf59819faf9457e3e71361fbc94", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6a71e3e030bbf59819faf9457e3e71361fbc94", "html_url": "https://github.com/rust-lang/rust/commit/0f6a71e3e030bbf59819faf9457e3e71361fbc94"}, {"sha": "0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "html_url": "https://github.com/rust-lang/rust/commit/0d7201ef46b9bdf8474b07b839d029e56d4f29b7"}], "stats": {"total": 1433, "additions": 631, "deletions": 802}, "files": [{"sha": "a2fc6e044e74c53753b3a2819a49cfad66a8c1ab", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -311,11 +311,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -372,9 +372,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n+        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "bbcd87d9cabfc2ff7a9e1bc91889f3bb5742196d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1266,26 +1266,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.expr_ty(expr);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx,\n-                      expr.span,\n-                      expr.id,\n-                      adjustment,\n-                      |method_call| self.tables\n-                                        .borrow()\n-                                        .method_map\n-                                        .get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty)))\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n@@ -1622,7 +1602,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n@@ -1666,9 +1646,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n             &tables.adjustments\n         }\n "}, {"sha": "4212b1fb05ee3a6eeffc5ff277ac84a964f0cf36", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n-                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                if let Some(substs) = self.tcx.tables().item_substs.get(&id) {\n                     if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n                         self.check_def_id(tyid.did);\n                     }\n@@ -123,12 +123,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        let method = self.tcx.tables().method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.node_id_to_type(field.id);\n+        let field_type = self.tcx.tables().node_id_to_type(field.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false"}, {"sha": "8ca3c75eaa4b1fbe3ad90774651e43d940cf113f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n+                let base_type = self.tcx.tables().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -168,15 +168,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }\n@@ -214,7 +214,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");"}, {"sha": "0543d1303a5f10fe9f1137d11c61cbec6e0769fb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -720,20 +720,33 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n-            match adjustment {\n-                adjustment::AdjustNeverToAny(..) |\n-                adjustment::AdjustReifyFnPointer |\n-                adjustment::AdjustUnsafeFnPointer |\n-                adjustment::AdjustMutToConstPointer => {\n+            match adjustment.kind {\n+                adjustment::Adjust::NeverToAny |\n+                adjustment::Adjust::ReifyFnPointer |\n+                adjustment::Adjust::UnsafeFnPointer |\n+                adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment: trivial adjustment\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                adjustment::AdjustDerefRef(ref adj) => {\n-                    self.walk_autoderefref(expr, adj);\n+                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n+\n+                    self.walk_autoderefs(expr, autoderefs);\n+\n+                    let cmt_derefd =\n+                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n+\n+                    let cmt_refd =\n+                        self.walk_autoref(expr, cmt_derefd, autoref);\n+\n+                    if unsize {\n+                        // Unsizing consumes the thin pointer and produces a fat one.\n+                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n+                    }\n                 }\n             }\n         }\n@@ -770,28 +783,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn walk_autoderefref(&mut self,\n-                         expr: &hir::Expr,\n-                         adj: &adjustment::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n-               expr,\n-               adj);\n-\n-        self.walk_autoderefs(expr, adj.autoderefs);\n-\n-        let cmt_derefd =\n-            return_if_err!(self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-\n-        let cmt_refd =\n-            self.walk_autoref(expr, cmt_derefd, adj.autoref);\n-\n-        if adj.unsize.is_some() {\n-            // Unsizing consumes the thin pointer and produces a fat one.\n-            self.delegate_consume(expr.id, expr.span, cmt_refd);\n-        }\n-    }\n-\n-\n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n     /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred. Because AutoRefs\n@@ -803,7 +794,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -822,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         };\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -831,7 +822,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoRef);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "57503398cfe577acd6aa87f5e37af21cb734e5c9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             let from = bare_fn_ty.sig.0.inputs[0];"}, {"sha": "46bea00cca3cbf8399319f2c5723ca75c3357d20", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1081,7 +1081,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.is_method_call(expr.id) {\n+            if self.ir.tcx.tables().is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1113,8 +1113,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n+            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n+                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n+            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1409,7 +1409,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.is_method_call(expr.id) {\n+        if !this.ir.tcx.tables().is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1459,7 +1459,7 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.node_id_to_type(id);\n+        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     None if !body.stmts.is_empty() =>\n                         match body.stmts.last().unwrap().node {\n                             hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.expr_ty(&e) == fn_ret\n+                                self.ir.tcx.tables().expr_ty(&e) == fn_ret\n                             },\n                             _ => false\n                         },"}, {"sha": "e3ed13e1e40173501cab2d79040731b8d07b67e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -354,11 +354,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = self.expr_ty(expr)?;\n-        Ok(unadjusted_ty.adjust(\n-            self.tcx(), expr.span, expr.id,\n-            self.infcx.adjustments().get(&expr.id),\n-            |method_call| self.infcx.node_method_ty(method_call)))\n+        self.infcx.expr_ty_adjusted(expr)\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -396,19 +392,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                match *adjustment {\n-                    adjustment::AdjustDerefRef(\n-                        adjustment::AutoDerefRef {\n-                            autoref: None, unsize: None, autoderefs, ..}) => {\n+                match adjustment.kind {\n+                    adjustment::Adjust::DerefRef {\n+                        autoderefs,\n+                        autoref: None,\n+                        unsize: false\n+                    } => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    adjustment::AdjustNeverToAny(..) |\n-                    adjustment::AdjustReifyFnPointer |\n-                    adjustment::AdjustUnsafeFnPointer |\n-                    adjustment::AdjustMutToConstPointer |\n-                    adjustment::AdjustDerefRef(_) => {\n+                    adjustment::Adjust::NeverToAny |\n+                    adjustment::Adjust::ReifyFnPointer |\n+                    adjustment::Adjust::UnsafeFnPointer |\n+                    adjustment::Adjust::MutToConstPointer |\n+                    adjustment::Adjust::DerefRef {..} => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "1a50d7aa0adc7f34107bf6f5d05ee20541c4f624", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n \n                 // Mark the trait item (and, possibly, its default impl) as reachable\n                 // Or mark inherent impl item as reachable"}, {"sha": "fd17e378787a59008fd9415c5c93cf783f26e269", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -555,11 +555,11 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprMethodCall(i, ..) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables.borrow().method_map[&method_call].def_id\n+            tcx.tables().method_map[&method_call].def_id\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().field_named(field.node).did\n                 }\n@@ -569,7 +569,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().fields[field.node].did\n                 }\n@@ -580,7 +580,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.expr_ty(e).sty {\n+            match tcx.tables().expr_ty(e).sty {\n                 ty::TyAdt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n                         // check the stability of each field that appears\n@@ -637,7 +637,7 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n         Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n         _ => return,\n     };"}, {"sha": "333a5c74cb45cb309c73e62317493ffed343530c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 107, "deletions": 182, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AutoAdjustment::*;\n-pub use self::AutoRef::*;\n-\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut};\n use ty::LvaluePreference::{NoPreference};\n \n use syntax::ast;\n@@ -20,116 +17,122 @@ use syntax_pos::Span;\n use hir;\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AutoAdjustment<'tcx> {\n-    AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n-    AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,      // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustMutToConstPointer,    // go from a mut raw pointer to a const raw pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>),\n+pub struct Adjustment<'tcx> {\n+    pub kind: Adjust<'tcx>,\n+    pub target: Ty<'tcx>\n }\n \n-/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-///\n-/// We transform pointers by following the following steps in order:\n-/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n-///\n-/// To make that more concrete, here are some common scenarios:\n-///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The number of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// None.\n-///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-/// }\n-/// ```\n-///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n-///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 0,\n-///     autoref: None,\n-///     unsize: Some(Box<[i32]>),\n-/// }\n-/// ```\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct AutoDerefRef<'tcx> {\n-    /// Step 1. Apply a number of dereferences, producing an lvalue.\n-    pub autoderefs: usize,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoRef<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. The stored type is the target pointer type. Note that\n-    /// the source could be a thin or fat pointer.\n-    pub unsize: Option<Ty<'tcx>>,\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum Adjust<'tcx> {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+    ///\n+    /// We transform pointers by following the following steps in order:\n+    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+    ///    `&` or `*` pointer.\n+    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+    ///    which will do things like convert thin pointers to fat\n+    ///    pointers, or convert structs containing thin pointers to\n+    ///    structs containing fat pointers, or convert between fat\n+    ///    pointers.  We don't store the details of how the transform is\n+    ///    done (in fact, we don't know that, because it might depend on\n+    ///    the precise type parameters). We just store the target\n+    ///    type. Trans figures out what has to be done at monomorphization\n+    ///    time based on the precise source/target type at hand.\n+    ///\n+    /// To make that more concrete, here are some common scenarios:\n+    ///\n+    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+    /// Here the pointer will be dereferenced N times (where a dereference can\n+    /// happen to raw or borrowed pointers or any smart pointer which implements\n+    /// Deref, including Box<_>). The number of dereferences is given by\n+    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+    /// None.\n+    ///\n+    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+    /// with a thin pointer, deref a number of times, unsize the underlying data,\n+    /// then autoref. The 'unsize' phase may change a fixed length array to a\n+    /// dynamically sized one, a concrete object to a trait object, or statically\n+    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+    /// represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n+    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+    /// The autoderef and -ref are the same as in the above example, but the type\n+    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n+    ///\n+    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+    /// that case, we have the pointer we need coming in, so there are no\n+    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+    /// At some point, of course, `Box` should move out of the compiler, in which\n+    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+    /// Box<[i32]> is represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 0,\n+    ///     autoref: None,\n+    ///     unsize: Some(Box<[i32]>),\n+    /// }\n+    /// ```\n+    DerefRef {\n+        /// Step 1. Apply a number of dereferences, producing an lvalue.\n+        autoderefs: usize,\n+\n+        /// Step 2. Optionally produce a pointer/reference from the value.\n+        autoref: Option<AutoBorrow<'tcx>>,\n+\n+        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+        /// `&[T]`. Note that the source could be a thin or fat pointer.\n+        unsize: bool,\n+    }\n }\n \n-impl<'tcx> AutoAdjustment<'tcx> {\n+impl<'tcx> Adjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n-        match *self {\n-            AdjustNeverToAny(ty) => ty.is_never(),\n-            AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer |\n-            AdjustMutToConstPointer => false,\n-            AdjustDerefRef(ref r) => r.is_identity(),\n+        match self.kind {\n+            Adjust::NeverToAny => self.target.is_never(),\n+\n+            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::DerefRef {..} => false,\n         }\n     }\n }\n-impl<'tcx> AutoDerefRef<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AutoRef<'tcx> {\n+pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+    Ref(&'tcx ty::Region, hir::Mutability),\n \n     /// Convert from T to *T.\n-    /// Value to thin pointer.\n-    AutoUnsafe(hir::Mutability),\n+    RawPtr(hir::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n@@ -139,84 +142,6 @@ pub enum CustomCoerceUnsized {\n }\n \n impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     adjustment: Option<&AutoAdjustment<'tcx>>,\n-                     mut method_type: F)\n-                     -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        if let ty::TyError = self.sty {\n-            return self;\n-        }\n-\n-        return match adjustment {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    AdjustNeverToAny(ref ty) => ty,\n-\n-                    AdjustReifyFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnDef(.., f) => tcx.mk_fn_ptr(f),\n-                            _ => {\n-                                bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n-                                     self);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustUnsafeFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n-                            ref b => {\n-                                bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustMutToConstPointer => {\n-                        match self.sty {\n-                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n-                                ty: mt.ty,\n-                                mutbl: hir::MutImmutable\n-                            }),\n-                            ref b => {\n-                                bug!(\"AdjustMutToConstPointer on non-raw-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustDerefRef(ref adj) => {\n-                        let mut adjusted_ty = self;\n-\n-                        if !adjusted_ty.references_error() {\n-                            for i in 0..adj.autoderefs {\n-                                adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(tcx,\n-                                                                     expr_id,\n-                                                                     span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                            }\n-                        }\n-\n-                        if let Some(target) = adj.unsize {\n-                            target\n-                        } else {\n-                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n-                        }\n-                    }\n-                }\n-            }\n-            None => self\n-        };\n-    }\n-\n     pub fn adjust_for_autoderef<F>(&'tcx self,\n                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n@@ -247,14 +172,14 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoRef<'tcx>>)\n+                              autoref: Option<AutoBorrow<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n-            Some(AutoPtr(r, m)) => {\n+            Some(AutoBorrow::Ref(r, m)) => {\n                 tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n-            Some(AutoUnsafe(m)) => {\n+            Some(AutoBorrow::RawPtr(m)) => {\n                 tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }"}, {"sha": "7e5e10435d51683d520fc299a801a67b082eeb58", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n use std::borrow::Borrow;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -212,7 +212,7 @@ pub struct Tables<'tcx> {\n     /// other items.\n     pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n+    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n     pub method_map: ty::MethodMap<'tcx>,\n \n@@ -255,6 +255,76 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             fru_field_types: NodeMap()\n         }\n     }\n+\n+    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+        match self.node_id_to_type_opt(id) {\n+            Some(ty) => ty,\n+            None => {\n+                bug!(\"node_id_to_type: no type for node `{}`\",\n+                     tls::with(|tcx| tcx.map.node_to_string(id)))\n+            }\n+        }\n+    }\n+\n+    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+        self.node_types.get(&id).cloned()\n+    }\n+\n+    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n+        self.item_substs.get(&id).map(|ts| ts.substs)\n+    }\n+\n+    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n+    // doesn't provide type parameter substitutions.\n+    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+        self.node_id_to_type(pat.id)\n+    }\n+\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(pat.id)\n+    }\n+\n+    // Returns the type of an expression as a monotype.\n+    //\n+    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    // some cases, we insert `Adjustment` annotations such as auto-deref or\n+    // auto-ref.  The type returned by this function does not consider such\n+    // adjustments.  See `expr_ty_adjusted()` instead.\n+    //\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+    // instead of \"fn(ty) -> T with T = isize\".\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.node_id_to_type(expr.id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(expr.id)\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.adjustments.get(&expr.id)\n+            .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.adjustments.get(&expr.id)\n+            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n+    }\n+\n+    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n+        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -599,14 +669,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n-        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n-            &tables.node_types\n-        }\n-\n-        Ref::map(self.tables.borrow(), projection)\n-    }\n-\n     pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }"}, {"sha": "b79ebdb14f552ba0977135013ba10f6782a9b0b3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -176,8 +176,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n-                    -> adjustment::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoBorrow<'tcx>)\n+                    -> adjustment::AutoBorrow<'tcx> {\n         ar.super_fold_with(self)\n     }\n }"}, {"sha": "2c15f08e89822667ad9fd9cdab7cce33fb9ca20d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 87, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -2120,80 +2120,8 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n-        match self.node_id_to_type_opt(id) {\n-           Some(ty) => ty,\n-           None => bug!(\"node_id_to_type: no type for node `{}`\",\n-                        self.map.node_to_string(id))\n-        }\n-    }\n-\n-    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n-        self.tables.borrow().node_types.get(&id).cloned()\n-    }\n-\n-    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts {\n-                substs: self.global_tcx().intern_substs(&[])\n-            },\n-            Some(ts) => ts.clone(),\n-        }\n-    }\n-\n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n-        self.node_id_to_type(pat.id)\n-    }\n-    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(pat.id)\n-    }\n-\n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.node_id_to_type(expr.id)\n-    }\n-\n-    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(expr.id)\n-    }\n-\n-    /// Returns the type of `expr`, considering any `AutoAdjustment`\n-    /// entry recorded for that expression.\n-    ///\n-    /// It would almost certainly be better to store the adjusted ty in with\n-    /// the `AutoAdjustment`, but I opted not to do this because it would\n-    /// require serializing and deserializing the type and, although that's not\n-    /// hard to do, I just hate that code so much I didn't want to touch it\n-    /// unless it was to fix it properly, which seemed a distraction from the\n-    /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.expr_ty(expr)\n-            .adjust(self.global_tcx(), expr.span, expr.id,\n-                    self.tables.borrow().adjustments.get(&expr.id),\n-                    |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        })\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n-                                                expr.span,\n-                                                expr.id,\n-                                                self.tables.borrow().adjustments.get(&expr.id),\n-                                                |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        }))\n+    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n+        self.tables.borrow()\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2908,19 +2836,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n-    }\n-\n-    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n-                                                                            autoderefs))\n-    }\n-\n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n-    }\n-\n     pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)"}, {"sha": "9ca911837b517855e3dcbce3e0aa5c69b22a4bfd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -218,15 +218,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n-    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n+    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            ty::adjustment::AutoBorrow::Ref(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n-            ty::adjustment::AutoUnsafe(m) => {\n-                Some(ty::adjustment::AutoUnsafe(m))\n+            ty::adjustment::AutoBorrow::RawPtr(m) => {\n+                Some(ty::adjustment::AutoBorrow::RawPtr(m))\n             }\n         }\n     }\n@@ -676,13 +676,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(ref r, m) => {\n-                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n+            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n+                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n             }\n-            ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n+            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n         }\n     }\n \n@@ -692,8 +692,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ty::adjustment::AutoPtr(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoUnsafe(_m) => false,\n+            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n+            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n         }\n     }\n }"}, {"sha": "31304fb7b4993eeb4e8c24a21cc0687c10d7d7a6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -447,32 +447,9 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::adjustment::AdjustNeverToAny(ref target) => {\n-                write!(f, \"AdjustNeverToAny({:?})\", target)\n-            }\n-            ty::adjustment::AdjustReifyFnPointer => {\n-                write!(f, \"AdjustReifyFnPointer\")\n-            }\n-            ty::adjustment::AdjustUnsafeFnPointer => {\n-                write!(f, \"AdjustUnsafeFnPointer\")\n-            }\n-            ty::adjustment::AdjustMutToConstPointer => {\n-                write!(f, \"AdjustMutToConstPointer\")\n-            }\n-            ty::adjustment::AdjustDerefRef(ref data) => {\n-                write!(f, \"{:?}\", data)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n-               self.autoderefs, self.unsize, self.autoref)\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n     }\n }\n "}, {"sha": "51574868f9bfb5b72a2f8483f4356bef9539311b", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -37,7 +37,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = bccx.tcx.node_id_to_type(var_id);\n+    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }"}, {"sha": "615aca90db8bfd86497836f4c94938f8243407f9", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n-            let pat_ty = cx.tcx.pat_ty(p);\n+            let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n@@ -486,7 +486,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.node_id_to_type(p.id);\n+                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }"}, {"sha": "1f66d7140682681173c01f4b90c2c9192f5e59ed", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -246,7 +246,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    pat_id: ast::NodeId,\n                                    span: Span)\n                                    -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.expr_ty(expr);\n+    let pat_ty = tcx.tables().expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n         ty::TyFloat(_) => {\n@@ -329,7 +329,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Def::StructCtor(_, CtorKind::Const) |\n                 Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n@@ -606,7 +607,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.expr_ty(e))\n+            Some(tcx.tables().expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -617,7 +618,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.expr_ty_opt(e)\n+            tcx.tables().expr_ty_opt(e)\n         }\n     };\n     let result = match e.node {\n@@ -759,7 +760,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.expr_ty_opt(&base) {\n+            match tcx.tables().expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n@@ -798,7 +799,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.node_id_item_substs(e.id).substs)\n+                      Some(tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };"}, {"sha": "10b2a7625cacfefa1140ec965188e48d1cb7d516", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.node_id_to_type(pat.id);\n+        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -167,8 +167,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                        let substs = tcx.tables().node_id_item_substs(pat.id)\n+                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n                             Some((const_expr, _const_ty)) => {\n                                 match eval::const_expr_to_pat(\n                                     tcx, const_expr, pat.id, pat.span)\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.node_id_to_type(pat.id);\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -222,7 +223,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.tcx.node_id_to_type(pat.id).sty {\n+                match self.tcx.tables().node_id_to_type(pat.id).sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n@@ -243,7 +244,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             PatKind::Binding(bm, ref ident, ref sub) => {\n                 let def_id = self.tcx.expect_def(pat.id).def_id();\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.node_id_to_type(pat.id);\n+                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -280,7 +281,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -299,7 +300,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {"}, {"sha": "b4ab9da92e9d0af08a6495b4d7aca42b647dff9b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),"}, {"sha": "28dc71fd59bae021941cf78f5a7e27287ef5b9c9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -34,7 +34,6 @@ use middle::stability;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n@@ -118,7 +117,9 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            hir::ItemUnion(..) => {\n+                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+            }\n             _ => (),\n         }\n \n@@ -129,15 +130,15 @@ impl LateLintPass for BoxPointers {\n                 for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx,\n                                          struct_field.span,\n-                                         cx.tcx.node_id_to_type(struct_field.id));\n+                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n                 }\n             }\n             _ => (),\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.node_id_to_type(e.id);\n+        let ty = cx.tcx.tables().node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -585,7 +586,7 @@ impl LateLintPass for MissingDebugImplementations {\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n                         if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n                             impls.insert(node_id);\n                         }\n@@ -939,24 +940,23 @@ impl LateLintPass for UnconditionalRecursion {\n                                                 method: &ty::Method,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n+            use rustc::ty::adjustment::*;\n+\n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n-            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n-                for i in 0..adj.autoderefs {\n+            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n+            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n+                for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables\n-                        .borrow()\n-                        .method_map\n-                        .get(&method_call)\n-                        .cloned() {\n+                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n+                                                            .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -971,12 +971,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     // it doesn't necessarily have a definition.\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(tcx,\n-                                                         method,\n-                                                         def_id,\n-                                                         &item_substs.substs,\n-                                                         id)\n+                            let substs = tcx.tables().node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -1213,7 +1211,7 @@ impl LateLintPass for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.node_id_to_type(expr.id);\n+                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.0.inputs[0];\n@@ -1284,7 +1282,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "b04759955a956b8d3a43153d9b98b4b89a7da7a5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -113,14 +113,14 @@ impl LateLintPass for TypeLimits {\n                             forbid_unsigned_negation(cx, e.span);\n                         }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                            if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                            if let ty::TyUint(_) = cx.tcx.tables().node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n                         }\n                         _ => (),\n                     }\n                 } else {\n-                    let t = cx.tcx.node_id_to_type(expr.id);\n+                    let t = cx.tcx.tables().node_id_to_type(expr.id);\n                     if let ty::TyUint(_) = t.sty {\n                         forbid_unsigned_negation(cx, e.span);\n                     }\n@@ -138,7 +138,7 @@ impl LateLintPass for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -171,7 +171,7 @@ impl LateLintPass for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.node_id_to_type(e.id).sty {\n+                match cx.tcx.tables().node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -324,7 +324,7 @@ impl LateLintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.node_id_to_type(expr.id).sty {\n+            match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -740,7 +740,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.node_id_to_type(it.id);\n+                let t = cx.tcx.tables().node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx)"}, {"sha": "15430a5c9f99d96ca583ae3c2767bb8d51dfd374", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -140,7 +140,7 @@ impl LateLintPass for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.expr_ty(&expr);\n+        let t = cx.tcx.tables().expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -441,16 +441,15 @@ impl LateLintPass for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n-                *adjustment {\n+        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n+            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use &mut instead\");"}, {"sha": "e009955b92ee4a67cc7f13f05bf4f3e93189ddcf", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -38,7 +38,7 @@ enum TableEntry<'tcx> {\n     Def(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    Adjustment(ty::adjustment::Adjustment<'tcx>),\n     ConstQualif(ConstQualif),\n }\n \n@@ -94,9 +94,9 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n         };\n \n         encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n-        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n         encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }"}, {"sha": "fdb117ef81b13e731b638ad70e795466cdcdb0f6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n         };\n \n         Entry {"}, {"sha": "b37dd8dd0a90716d11c584cde4bff6e33c7f4db2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -191,7 +191,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.node_id_to_type(fn_id).sty {\n+    match tcx.tables().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n             spread_arg = Some(Local::new(arguments.len()));\n@@ -203,7 +203,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n@@ -233,7 +233,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        ast_expr: &'tcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n-    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);\n "}, {"sha": "cb69de2cb3cace0923c907f0218e471cc3010649", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -77,7 +77,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.node_id_to_type(block.id);\n+    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "ba0d3b49a6c1ae28315fd51bd8085db29f982470", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -35,62 +35,61 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n+        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n+               expr, adj);\n \n         // Now apply adjustments, if any.\n-        match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n+        match adj.map(|adj| (adj.kind, adj.target)) {\n             None => {}\n-            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustNeverToAny(adjusted_ty)) => {\n+            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::NeverToAny { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustMutToConstPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n-                for i in 0..adj.autoderefs {\n+            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n+                  adjusted_ty)) => {\n+                for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(\n                             cx.tcx,\n                             self.id,\n                             self.span,\n                             i,\n-                            |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n+                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n                     let meth_ty =\n-                        cx.tcx.tables.borrow().method_map.get(&method_key).map(|m| m.ty);\n+                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -128,10 +127,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     };\n                 }\n \n-                if let Some(autoref) = adj.autoref {\n+                if let Some(autoref) = autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::adjustment::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -143,7 +142,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 },\n                             };\n                         }\n-                        ty::adjustment::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression.\n@@ -169,10 +168,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                 }\n \n-                if let Some(target) = adj.unsize {\n+                if unsize {\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n-                        ty: target,\n+                        ty: adjusted_ty,\n                         span: self.span,\n                         kind: ExprKind::Unsize { source: expr.to_ref() },\n                     };\n@@ -212,7 +211,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.expr_ty(expr);\n+    let expr_ty = cx.tcx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -231,7 +230,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -282,7 +281,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n+                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -296,7 +296,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.node_id_to_type(fun.id),\n+                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -328,7 +328,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -350,7 +350,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -406,7 +406,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, lhs.to_ref(), vec![index])\n             } else {\n@@ -418,7 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -427,7 +427,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -439,7 +439,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -470,10 +470,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             base: base.as_ref().map(|base| {\n                                 FruInfo {\n                                     base: base.to_ref(),\n-                                    field_types: cx.tcx.tables\n-                                        .borrow()\n-                                        .fru_field_types[&expr.id]\n-                                        .clone()\n+                                    field_types:\n+                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n                                 }\n                             })\n                         }\n@@ -512,7 +510,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.expr_ty(expr);\n+            let closure_ty = cx.tcx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -551,7 +549,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n             value: v.to_ref(),\n             count: TypedConstVal {\n-                ty: cx.tcx.expr_ty(c),\n+                ty: cx.tcx.tables().expr_ty(c),\n                 span: c.span,\n                 value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n@@ -579,7 +577,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n@@ -631,8 +629,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n+    let callee = cx.tcx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -666,8 +663,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n-    // Otherwise there may be def_map borrow conflicts\n+    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -677,18 +674,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit struct/variant which is used as a value.\n-            // We return a completely different ExprKind here to account for this special case.\n-            ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                adt_def: adt_def,\n-                variant_index: adt_def.variant_index_with_id(def_id),\n-                substs: substs,\n-                fields: vec![],\n-                base: None,\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n+        Def::VariantCtor(def_id, CtorKind::Const) => {\n+            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+                // A unit struct/variant which is used as a value.\n+                // We return a completely different ExprKind here to account for this special case.\n+                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: adt_def.variant_index_with_id(def_id),\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None,\n+                },\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+            }\n+        }\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,\n@@ -720,7 +719,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n-            let var_ty = cx.tcx.node_id_to_type(id_var);\n+            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -737,7 +736,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -809,7 +808,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(\n@@ -893,7 +892,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             argrefs.extend(\n                 args.iter()\n                     .map(|arg| {\n-                        let arg_ty = cx.tcx.expr_ty_adjusted(arg);\n+                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n                         let adjusted_ty =\n                             cx.tcx.mk_ref(region,\n                                        ty::TypeAndMut { ty: arg_ty,\n@@ -931,9 +930,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n-    let ref_ty = callee.ty.fn_ret();\n+    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -962,9 +959,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.node_id_to_type(id_var);\n+    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "0ffc59fe6bf45da6140208019e0e8419845ba63b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n         // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n             Some(f) => f.clone(),\n             None => {\n                 span_bug!(span, \"no liberated fn sig for {:?}\", id);\n@@ -248,7 +248,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with"}, {"sha": "f23539e88f78d175f3b9dfc36e4dd70a019dbdae", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = self.tcx.node_id_to_type(ex.id);\n+        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -449,14 +449,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.node_id_to_type(inner.id).sty {\n+            match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -466,7 +466,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.node_id_to_type(lhs.id).sty {\n+            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -503,7 +503,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     }\n                 }\n                 Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n@@ -555,7 +556,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables.borrow().method_map[&method_call];\n+            let method = v.tcx.tables().method_map[&method_call];\n             let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n@@ -565,7 +566,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.add_qualif(ConstQualif::MUTABLE_MEM);\n@@ -624,16 +625,18 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n-    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+    use rustc::ty::adjustment::*;\n+\n+    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n-        Some(&ty::adjustment::AdjustNeverToAny(..)) |\n-        Some(&ty::adjustment::AdjustReifyFnPointer) |\n-        Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n-        Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n+        Some(Adjust::NeverToAny) |\n+        Some(Adjust::ReifyFnPointer) |\n+        Some(Adjust::UnsafeFnPointer) |\n+        Some(Adjust::MutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+        Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }"}, {"sha": "8fdfecd4a586519f3fac992ea2e9445adf324206", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -430,11 +430,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables.borrow().method_map[&method_call];\n+                let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(_, ref expr_fields, _) => {\n-                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -495,14 +495,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n-                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.pat_ty(pattern).sty {\n+                match self.tcx.tables().pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();"}, {"sha": "db4788c3ceadb70964703f37c071161b23f13e17", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -356,7 +356,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n+                let typ = self.tcx.tables().node_types.get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n@@ -988,7 +988,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n-                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().node_id_to_type(p.id).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n@@ -1023,8 +1023,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let types = self.tcx.node_types();\n-            let typ = match types.get(&id) {\n+            let typ = match self.tcx.tables().node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1355,7 +1354,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n@@ -1381,7 +1380,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n+                let ty = &self.tcx.tables().expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n@@ -1468,7 +1467,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.node_types()\n+                    let typ = self.tcx.tables().node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "7e008f741624b117187e54a756b1ed73dbcc8133", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -286,7 +286,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.node_types().get(&field.id).unwrap().to_string();\n+            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n@@ -418,7 +418,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -432,7 +432,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -451,7 +451,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n@@ -472,7 +472,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "ffb13a833a582543e615fe7dba8e971f289e3590", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n                              method_call: ty::MethodCall)\n                              -> Callee<'tcx> {\n-        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        let method = bcx.tcx().tables().method_map[&method_call];\n         Callee::method(bcx, method)\n     }\n "}, {"sha": "a439d415ede151f16e2f7e1418498e89b4f5a69f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1082,10 +1082,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = {\n-                        let tables = self.scx.tcx().tables.borrow();\n-                        tables.node_types[&item.id]\n-                    };\n+                    let ty = self.scx.tcx().tables().node_types[&item.id];\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\","}, {"sha": "4bb34850e0870c0cce998ceb9a57acb54ac81dbf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "c93f1c6c8e6102523bdb7a9fea545239b91112cd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -1549,7 +1549,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 tcx.prohibit_type_params(base_segments);\n                 let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.node_id_to_type(impl_id);\n+                let ty = tcx.tables().node_id_to_type(impl_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "3cf64fa439d7d0afe868f3ab2554079661dac4c1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n                 return Some(CallStep::Builtin);\n             }\n "}, {"sha": "16493412d690b41e042afbb1e2c9b99b2fc8fe06", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -65,10 +65,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n-use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n-use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::adjustment::AdjustNeverToAny;\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -93,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -144,12 +141,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     /// Synthesize an identity adjustment.\n     fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: 0,\n-                autoref: None,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: false,\n+        }))\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -166,7 +162,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         if a.is_never() {\n-            return Ok((b, AdjustNeverToAny(b)));\n+            return Ok((b, Adjust::NeverToAny));\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -396,17 +392,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n-        let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: autoderefs,\n-                autoref: autoref,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: autoderefs,\n+            autoref: autoref,\n+            unsize: false,\n+        }))\n     }\n \n \n@@ -437,11 +432,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.next_region_var(coercion);\n-                (mt_a.ty, Some(AutoPtr(r_borrow, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n-                (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::RawPtr(mt_b.mutbl)))\n             }\n             _ => (source, None),\n         };\n@@ -497,13 +492,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n \n-        let adjustment = AutoDerefRef {\n+        let adjustment = Adjust::DerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n-            unsize: Some(target),\n+            unsize: true,\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, AdjustDerefRef(adjustment)))\n+        Ok((target, adjustment))\n     }\n \n     fn coerce_from_safe_fn(&self,\n@@ -516,7 +511,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n                     return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n+                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n                 }\n                 _ => {}\n             }\n@@ -555,7 +550,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, AdjustReifyFnPointer))\n+                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n             }\n             _ => self.unify_and_identity(a, b),\n         }\n@@ -585,17 +580,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Although references and unsafe ptrs have the same\n-        // representation, we still register an AutoDerefRef so that\n+        // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n         Ok((ty,\n             if is_ref {\n-                AdjustDerefRef(AutoDerefRef {\n+                Adjust::DerefRef {\n                     autoderefs: 1,\n-                    autoref: Some(AutoUnsafe(mutbl_b)),\n-                    unsize: None,\n-                })\n+                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                    unsize: false,\n+                }\n             } else if mt_a.mutbl != mutbl_b {\n-                AdjustMutToConstPointer\n+                Adjust::MutToConstPointer\n             } else {\n                 noop\n             }))\n@@ -606,24 +601,25 @@ fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n                                    exprs: &E,\n                                    a: Ty<'tcx>,\n                                    b: Ty<'tcx>)\n-                                   -> CoerceResult<'tcx>\n+                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n     where E: Fn() -> I,\n           I: IntoIterator<Item = &'b hir::Expr>\n {\n \n-    let (ty, adjustment) = indent(|| coerce.coerce(exprs, a, b))?;\n+    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n \n     let fcx = coerce.fcx;\n-    if let AdjustDerefRef(auto) = adjustment {\n-        if auto.unsize.is_some() {\n-            let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-            for obligation in obligations.drain(..) {\n-                fcx.register_predicate(obligation);\n-            }\n+    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n+        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n+        for obligation in obligations.drain(..) {\n+            fcx.register_predicate(obligation);\n         }\n     }\n \n-    Ok((ty, adjustment))\n+    Ok(Adjustment {\n+        kind: adjust,\n+        target: ty\n+    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -641,17 +637,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n         self.commit_if_ok(|_| {\n-            let (ty, adjustment) = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n                     None |\n-                    Some(&AdjustNeverToAny(..)) => (),\n+                    Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => (),\n                     _ => bug!(\"expr already has an adjustment on it!\"),\n                 };\n                 self.write_adjustment(expr.id, adjustment);\n             }\n-            Ok(ty)\n+            Ok(adjustment.target)\n         })\n     }\n \n@@ -705,12 +701,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // Reify both sides and return the reified fn pointer type.\n+                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n                 for expr in exprs().into_iter().chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                    self.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                    self.write_adjustment(expr.id, Adjustment {\n+                        kind: Adjust::ReifyFnPointer,\n+                        target: fn_ptr\n+                    });\n                 }\n-                return Ok(self.tcx.mk_fn_ptr(fty));\n+                return Ok(fn_ptr);\n             }\n             _ => {}\n         }\n@@ -724,11 +724,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n             let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok((ty, adjustment)) => {\n+                Ok(adjustment) => {\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n-                    return Ok(ty);\n+                    return Ok(adjustment.target);\n                 }\n                 Err(e) => first_error = Some(e),\n             }\n@@ -738,10 +738,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs() {\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&AdjustDerefRef(AutoDerefRef { autoderefs: 1,\n-                                                    autoref: Some(AutoPtr(_, mutbl_adj)),\n-                                                    unsize: None })) => {\n+            let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n+                Some(Adjust::DerefRef {\n+                    autoderefs: 1,\n+                    autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n+                    unsize: false\n+                }) => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore.\n@@ -750,7 +752,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => false,\n                     }\n                 }\n-                Some(&AdjustNeverToAny(_)) => true,\n+                Some(Adjust::NeverToAny) => true,\n                 Some(_) => false,\n                 None => true,\n             };\n@@ -783,18 +785,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok((ty, adjustment)) => {\n+            Ok(adjustment) => {\n                 if !adjustment.is_identity() {\n+                    let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {\n-                        let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n-                        if let Some(AdjustNeverToAny(_)) = previous {\n-                            self.write_adjustment(expr.id, AdjustNeverToAny(ty));\n-                        } else {\n-                            self.write_adjustment(expr.id, adjustment);\n+                        if let Some(&mut Adjustment {\n+                            kind: Adjust::NeverToAny,\n+                            ref mut target\n+                        }) = tables.adjustments.get_mut(&expr.id) {\n+                            *target = adjustment.target;\n+                            continue;\n                         }\n+                        tables.adjustments.insert(expr.id, adjustment);\n                     }\n                 }\n-                Ok(ty)\n+                Ok(adjustment.target)\n             }\n         }\n     }"}, {"sha": "f88bb355d1270a63ddeaa536a2ec5ca64e2c962d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use syntax_pos::Span;\n@@ -140,20 +140,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx> {\n-        let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n+        let autoref = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(region, mutbl);\n-            (Some(autoref),\n-             pick.unsize.map(|target| target.adjust_for_autoref(self.tcx, Some(autoref))))\n+            Some(AutoBorrow::Ref(region, mutbl))\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n             // currently only unsize `[T;N]` to `[T]`, and naturally\n             // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n-            (None, None)\n+            None\n         };\n \n+\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n@@ -163,19 +162,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         autoderef.unambiguous_final_ty();\n         autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n+        let target = pick.unsize.unwrap_or(autoderefd_ty);\n+        let target = target.adjust_for_autoref(self.tcx, autoref);\n+\n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id,\n-                              AdjustDerefRef(AutoDerefRef {\n-                                  autoderefs: pick.autoderefs,\n-                                  autoref: autoref,\n-                                  unsize: unsize,\n-                              }));\n-\n-        if let Some(target) = unsize {\n-            target\n-        } else {\n-            autoderefd_ty.adjust_for_autoref(self.tcx, autoref)\n-        }\n+        self.write_adjustment(self.self_expr.id, Adjustment {\n+            kind: Adjust::DerefRef {\n+                autoderefs: pick.autoderefs,\n+                autoref: autoref,\n+                unsize: pick.unsize.is_some(),\n+            },\n+            target: target\n+        });\n+\n+        target\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -463,29 +463,23 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n             // Count autoderefs.\n-            let autoderef_count = match self.tables\n-                .borrow()\n-                .adjustments\n-                .get(&expr.id) {\n-                Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n-                Some(_) | None => 0,\n-            };\n-\n-            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n-                                                      autoderef_count={}\",\n-                   i,\n-                   expr,\n-                   autoderef_count);\n-\n-            if autoderef_count > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                autoderef.nth(autoderef_count).unwrap_or_else(|| {\n-                    span_bug!(expr.span,\n-                              \"expr was deref-able {} times but now isn't?\",\n-                              autoderef_count);\n-                });\n-                autoderef.finalize(PreferMutLvalue, Some(expr));\n+            let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n+            match adjustment {\n+                Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n+                    if autoderefs > 0 {\n+                        let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n+                        autoderef.nth(autoderefs).unwrap_or_else(|| {\n+                            span_bug!(expr.span,\n+                                      \"expr was deref-able {} times but now isn't?\",\n+                                      autoderefs);\n+                        });\n+                        autoderef.finalize(PreferMutLvalue, Some(expr));\n+                    }\n+                }\n+                Some(_) | None => {}\n             }\n \n             // Don't retry the first one or we might infinite loop!\n@@ -503,45 +497,55 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n                     let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n-                    let (autoderefs, unsize) = match adj {\n-                        Some(AdjustDerefRef(adr)) => {\n-                            match adr.autoref {\n+                    let (autoderefs, unsize, adjusted_base_ty) = match adj {\n+                        Some(Adjustment {\n+                            kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n+                            target\n+                        }) => {\n+                            match autoref {\n                                 None => {\n-                                    assert!(adr.unsize.is_none());\n-                                    (adr.autoderefs, None)\n-                                }\n-                                Some(AutoPtr(..)) => {\n-                                    (adr.autoderefs,\n-                                     adr.unsize.map(|target| {\n-                                         target.builtin_deref(false, NoPreference)\n-                                             .expect(\"fixup: AutoPtr is not &T\")\n-                                             .ty\n-                                     }))\n+                                    assert!(!unsize);\n                                 }\n+                                Some(AutoBorrow::Ref(..)) => {}\n                                 Some(_) => {\n                                     span_bug!(base_expr.span,\n                                               \"unexpected adjustment autoref {:?}\",\n-                                              adr);\n+                                              adj);\n                                 }\n                             }\n+\n+                            (autoderefs, unsize, if unsize {\n+                                target.builtin_deref(false, NoPreference)\n+                                      .expect(\"fixup: AutoBorrow::Ref is not &T\")\n+                                      .ty\n+                            } else {\n+                                let ty = self.node_ty(base_expr.id);\n+                                let mut ty = self.shallow_resolve(ty);\n+                                let mut method_type = |method_call: ty::MethodCall| {\n+                                    self.tables.borrow().method_map.get(&method_call).map(|m| {\n+                                        self.resolve_type_vars_if_possible(&m.ty)\n+                                    })\n+                                };\n+\n+                                if !ty.references_error() {\n+                                    for i in 0..autoderefs {\n+                                        ty = ty.adjust_for_autoderef(self.tcx,\n+                                                                     base_expr.id,\n+                                                                     base_expr.span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n+                                    }\n+                                }\n+\n+                                ty\n+                            })\n                         }\n-                        None => (0, None),\n+                        None => (0, false, self.node_ty(base_expr.id)),\n                         Some(_) => {\n                             span_bug!(base_expr.span, \"unexpected adjustment type\");\n                         }\n                     };\n \n-                    let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n-                        (target, true)\n-                    } else {\n-                        (self.adjust_expr_ty(base_expr,\n-                                             Some(&AdjustDerefRef(AutoDerefRef {\n-                                                 autoderefs: autoderefs,\n-                                                 autoref: None,\n-                                                 unsize: None,\n-                                             }))),\n-                         false)\n-                    };\n                     let index_expr_ty = self.node_ty(index_expr.id);\n \n                     let result = self.try_index_step(ty::MethodCall::expr(expr.id),"}, {"sha": "2df562f9ade46032613c5c6ea92799d74e2e79e9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer;\n \n use syntax::ast;\n@@ -294,28 +294,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        unsize,\n                        method_ty.explicit_self);\n \n-                match method_ty.explicit_self {\n+                let autoref = match method_ty.explicit_self {\n                     ty::ExplicitSelfCategory::ByValue => {\n                         // Trait method is fn(self), no transformation needed.\n                         assert!(!unsize);\n-                        self.write_autoderef_adjustment(self_expr.id, autoderefs);\n+                        None\n                     }\n \n                     ty::ExplicitSelfCategory::ByReference(..) => {\n                         // Trait method is fn(&self) or fn(&mut self), need an\n                         // autoref. Pull the region etc out of the type of first argument.\n                         match transformed_self_ty.sty {\n                             ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                                self.write_adjustment(self_expr.id,\n-                                                      AdjustDerefRef(AutoDerefRef {\n-                                                          autoderefs: autoderefs,\n-                                                          autoref: Some(AutoPtr(region, mutbl)),\n-                                                          unsize: if unsize {\n-                                                              Some(transformed_self_ty)\n-                                                          } else {\n-                                                              None\n-                                                          },\n-                                                      }));\n+                                Some(AutoBorrow::Ref(region, mutbl))\n                             }\n \n                             _ => {\n@@ -331,7 +322,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   \"unexpected explicit self type in operator method: {:?}\",\n                                   method_ty.explicit_self);\n                     }\n-                }\n+                };\n+\n+                self.write_adjustment(self_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs: autoderefs,\n+                        autoref: autoref,\n+                        unsize: unsize\n+                    },\n+                    target: transformed_self_ty\n+                });\n             }\n         }\n "}, {"sha": "60e7858467b98e456637d79d82526dd295fe824f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -777,7 +777,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.node_id_to_type(it.id);\n+        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -1205,7 +1205,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n                                  item_id: ast::NodeId)\n                                  -> bool {\n-    let rty = tcx.node_id_to_type(item_id);\n+    let rty = tcx.tables().node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1224,7 +1224,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.node_id_to_type(id);\n+    let t = tcx.tables().node_id_to_type(id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1581,20 +1581,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      derefs: usize) {\n-        self.write_adjustment(\n-            node_id,\n-            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                                      derefs: usize,\n+                                      adjusted_ty: Ty<'tcx>) {\n+        self.write_adjustment(node_id, adjustment::Adjustment {\n+            kind: adjustment::Adjust::DerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n-                unsize: None\n-            })\n-        );\n+                unsize: false\n+            },\n+            target: adjusted_ty\n+        });\n     }\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: adjustment::AutoAdjustment<'tcx>) {\n+                            adj: adjustment::Adjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1760,21 +1761,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.node_ty(expr.id);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n-            self.tables.borrow().method_map.get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty))\n-        })\n-    }\n-\n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n@@ -2311,7 +2297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n                 assert!(!unsize);\n-                self.write_autoderef_adjustment(base_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n@@ -2867,9 +2853,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n-                let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n-                if res.is_ok() && adj.is_some() {\n-                    self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n+                if res.is_ok() {\n+                    let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n+                    if let Some(adj) = adj {\n+                        self.write_ty(then_blk.id, adj.target);\n+                    }\n                 }\n \n                 res\n@@ -2930,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n-                            self.write_autoderef_adjustment(base.id, autoderefs);\n+                            self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3048,7 +3036,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_autoderef_adjustment(base.id, autoderefs);\n+                self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n         }\n@@ -3358,8 +3346,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if ty.is_never() {\n             if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n                 let adj_ty = self.next_diverging_ty_var();\n-                let adj = adjustment::AdjustNeverToAny(adj_ty);\n-                self.write_adjustment(expr.id, adj);\n+                self.write_adjustment(expr.id, adjustment::Adjustment {\n+                    kind: adjustment::Adjust::NeverToAny,\n+                    target: adj_ty\n+                });\n                 return adj_ty;\n             }\n         }"}, {"sha": "6f6538254c46bae735d2f9884ef27083b94d85ae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -259,23 +259,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.tables.borrow().method_map\n-                            .get(&method_call).map(|method| method.ty);\n-        method_ty.map(|method_ty| self.resolve_type(method_ty))\n-    }\n-\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> {\n-        let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty_unadjusted.references_error() {\n-            ty_unadjusted\n-        } else {\n-            ty_unadjusted.adjust(\n-                self.tcx, expr.span, expr.id,\n-                self.tables.borrow().adjustments.get(&expr.id),\n-                |method_call| self.resolve_method_type(method_call))\n-        }\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n+        self.resolve_type(ty)\n     }\n \n     fn visit_fn_body(&mut self,\n@@ -553,10 +540,8 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n         if let Some(adjustment) = adjustment {\n             debug!(\"adjustment={:?}\", adjustment);\n-            match adjustment {\n-                adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                    autoderefs, ref autoref, ..\n-                }) => {\n+            match adjustment.kind {\n+                adjustment::Adjust::DerefRef { autoderefs, ref autoref, .. } => {\n                     let expr_ty = self.resolve_node_type(expr.id);\n                     self.constrain_autoderefs(expr, autoderefs, expr_ty);\n                     if let Some(ref autoref) = *autoref {\n@@ -946,7 +931,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let origin = infer::ParameterOrigin::OverloadedDeref;\n                     self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n \n-                    // Treat overloaded autoderefs as if an AutoRef adjustment\n+                    // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                     // was applied on the base type, as that is always the case.\n                     let fn_sig = method.ty.fn_sig();\n                     let fn_sig = // late-bound regions should have been instantiated\n@@ -1060,15 +1045,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         id: ast::NodeId,\n         minimum_lifetime: &'tcx ty::Region)\n     {\n-        let tcx = self.tcx;\n-\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(id);\n-        let ty = ty0.adjust(tcx, origin.span(), id,\n-                            self.tables.borrow().adjustments.get(&id),\n-                            |method_call| self.resolve_method_type(method_call));\n+        let ty = self.tables.borrow().adjustments.get(&id).map_or(ty0, |adj| adj.target);\n+        let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n@@ -1165,20 +1147,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n                     autoderefs: usize,\n-                    autoref: &adjustment::AutoRef<'tcx>)\n+                    autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?})\", autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.link_region(expr.span, r,\n                                  ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.node_scope_region(expr.id);\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }"}, {"sha": "be1f2e35679d71e7ab191c5130a8fff33b87678a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -416,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -519,7 +519,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().node_id_to_type(item.id);\n+        let ty = self.tcx().tables().node_id_to_type(item.id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n@@ -649,7 +649,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.node_id_to_type(field.id);\n+                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,"}, {"sha": "5ef3e8699602b5437d93a813b7a04ce2addc8586", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -229,7 +229,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               self.tcx().node_id_to_type(p.id));\n+               self.tcx().tables().node_id_to_type(p.id));\n \n         intravisit::walk_pat(self, p);\n     }\n@@ -381,36 +381,40 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = match adjustment {\n-                    adjustment::AdjustNeverToAny(ty) => {\n-                        adjustment::AdjustNeverToAny(self.resolve(&ty, reason))\n+                let resolved_adjustment = match adjustment.kind {\n+                    adjustment::Adjust::NeverToAny => {\n+                        adjustment::Adjust::NeverToAny\n                     }\n \n-                    adjustment::AdjustReifyFnPointer => {\n-                        adjustment::AdjustReifyFnPointer\n+                    adjustment::Adjust::ReifyFnPointer => {\n+                        adjustment::Adjust::ReifyFnPointer\n                     }\n \n-                    adjustment::AdjustMutToConstPointer => {\n-                        adjustment::AdjustMutToConstPointer\n+                    adjustment::Adjust::MutToConstPointer => {\n+                        adjustment::Adjust::MutToConstPointer\n                     }\n \n-                    adjustment::AdjustUnsafeFnPointer => {\n-                        adjustment::AdjustUnsafeFnPointer\n+                    adjustment::Adjust::UnsafeFnPointer => {\n+                        adjustment::Adjust::UnsafeFnPointer\n                     }\n \n-                    adjustment::AdjustDerefRef(adj) => {\n-                        for autoderef in 0..adj.autoderefs {\n+                    adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                        for autoderef in 0..autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                            autoderefs: adj.autoderefs,\n-                            autoref: self.resolve(&adj.autoref, reason),\n-                            unsize: self.resolve(&adj.unsize, reason),\n-                        })\n+                        adjustment::Adjust::DerefRef {\n+                            autoderefs: autoderefs,\n+                            autoref: self.resolve(&autoref, reason),\n+                            unsize: unsize,\n+                        }\n                     }\n                 };\n+                let resolved_adjustment = adjustment::Adjustment {\n+                    kind: resolved_adjustment,\n+                    target: self.resolve(&adjustment.target, reason)\n+                };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().tables.borrow_mut().adjustments.insert(\n                     id, resolved_adjustment);"}, {"sha": "671274a4057c0190fa2a2e6c3c0124bb6fa3c72f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0963292aa6d78a4de05dbee853d0efe6cefe8a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1a0963292aa6d78a4de05dbee853d0efe6cefe8a", "patch": "@@ -211,7 +211,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = tcx.node_id_to_type(main_id);\n+    let main_t = tcx.tables().node_id_to_type(main_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n@@ -263,7 +263,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = tcx.node_id_to_type(start_id);\n+    let start_t = tcx.tables().node_id_to_type(start_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {"}]}