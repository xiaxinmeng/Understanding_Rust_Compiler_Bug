{"sha": "52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "node_id": "C_kwDOAAsO6NoAKDUyZmVmYjA0NTQ0MDU3NjNkYzBiOGViZTlmMWZiOTI3ZGYzY2EyZDM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-04-26T11:22:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-26T11:22:28Z"}, "message": "Rollup merge of #96361 - GuillaumeGomez:es6, r=notriddle\n\nSwitch JS code to ES6\n\nConsidering it's already quite big, I'll do the remaining files in another PR.\n\nPart of #93058.\n\nr? ``@notriddle``", "tree": {"sha": "6d3471f707074ff91b7eab410919e0000c8ca92c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d3471f707074ff91b7eab410919e0000c8ca92c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZ9X0CRBK7hj4Ov3rIwAADDIIADCOnuXwuBSzmCwhlqm/qKfq\nwixnpZ9xQlF+Aq8O1Xh7N2/bctr7AWvMkQoetnMeminm8p9Ln952rzdoU+xfsUbh\n/Ihiq6jGmqGTuAdFzd2zDykTUr6HbA+p0BZKY6jBHTgLPPAFWMqIqfWTj0NoFE6K\ntRCIHZYHuoIcHeVO9tlwhG9W16whrr4bLg/zbaduIo+AO27sU63kvGIIc55CF3W9\nNHzAgmXbzO+xopDUAx3R4k4DVvMHmYObmjDB1vS7bTGseRkXWaT+b7Qk2Ltnf9Q/\nw7UA8YPpteCGauOIZ2XKOYDpAS6LKBv6PtTvk6vZ24KzHBcpYC1rZWjQ7iC7OwE=\n=LaPT\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d3471f707074ff91b7eab410919e0000c8ca92c\nparent 2b8bf0d530f8be971264b2430f40217433568968\nparent 0233abebc85d336e92849ae7bca1fd8c1ef4f097\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1650972148 +0200\ncommitter GitHub <noreply@github.com> 1650972148 +0200\n\nRollup merge of #96361 - GuillaumeGomez:es6, r=notriddle\n\nSwitch JS code to ES6\n\nConsidering it's already quite big, I'll do the remaining files in another PR.\n\nPart of #93058.\n\nr? ``@notriddle``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "html_url": "https://github.com/rust-lang/rust/commit/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8bf0d530f8be971264b2430f40217433568968", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8bf0d530f8be971264b2430f40217433568968", "html_url": "https://github.com/rust-lang/rust/commit/2b8bf0d530f8be971264b2430f40217433568968"}, {"sha": "0233abebc85d336e92849ae7bca1fd8c1ef4f097", "url": "https://api.github.com/repos/rust-lang/rust/commits/0233abebc85d336e92849ae7bca1fd8c1ef4f097", "html_url": "https://github.com/rust-lang/rust/commit/0233abebc85d336e92849ae7bca1fd8c1ef4f097"}], "stats": {"total": 460, "additions": 232, "deletions": 228}, "files": [{"sha": "c4e74ea06578db01d49cd7049d29f022a2132f18", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 207, "deletions": 218, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "patch": "@@ -1,10 +1,13 @@\n+/* eslint-env es6 */\n+/* eslint no-var: \"error\" */\n+/* eslint prefer-const: \"error\" */\n /* global addClass, getNakedUrl, getSettingValue, hasOwnPropertyRustdoc, initSearch, onEach */\n /* global onEachLazy, removeClass, searchState, hasClass */\n \n (function() {\n // This mapping table should match the discriminants of\n // `rustdoc::formats::item_type::ItemType` type in Rust.\n-var itemTypes = [\n+const itemTypes = [\n     \"mod\",\n     \"externcrate\",\n     \"import\",\n@@ -34,15 +37,15 @@ var itemTypes = [\n ];\n \n // used for special search precedence\n-var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n-var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n+const TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n+const TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n \n // In the search display, allows to switch between tabs.\n function printTab(nb) {\n     if (nb === 0 || nb === 1 || nb === 2) {\n         searchState.currentTab = nb;\n     }\n-    var nb_copy = nb;\n+    let nb_copy = nb;\n     onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n         if (nb_copy === 0) {\n             addClass(elem, \"selected\");\n@@ -68,14 +71,15 @@ function printTab(nb) {\n  * This code is an unmodified version of the code written by Marco de Wit\n  * and was found at https://stackoverflow.com/a/18514751/745719\n  */\n-var levenshtein_row2 = [];\n+const levenshtein_row2 = [];\n function levenshtein(s1, s2) {\n     if (s1 === s2) {\n         return 0;\n     }\n-    var s1_len = s1.length, s2_len = s2.length;\n+    const s1_len = s1.length, s2_len = s2.length;\n     if (s1_len && s2_len) {\n-        var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n+        let i1 = 0, i2 = 0, a, b, c, c2;\n+        const row = levenshtein_row2;\n         while (i1 < s1_len) {\n             row[i1] = ++i1;\n         }\n@@ -97,24 +101,24 @@ function levenshtein(s1, s2) {\n }\n \n window.initSearch = function(rawSearchIndex) {\n-    var MAX_LEV_DISTANCE = 3;\n-    var MAX_RESULTS = 200;\n-    var GENERICS_DATA = 2;\n-    var NAME = 0;\n-    var INPUTS_DATA = 0;\n-    var OUTPUT_DATA = 1;\n-    var NO_TYPE_FILTER = -1;\n+    const MAX_LEV_DISTANCE = 3;\n+    const MAX_RESULTS = 200;\n+    const GENERICS_DATA = 2;\n+    const NAME = 0;\n+    const INPUTS_DATA = 0;\n+    const OUTPUT_DATA = 1;\n+    const NO_TYPE_FILTER = -1;\n     /**\n      *  @type {Array<Row>}\n      */\n-    var searchIndex;\n+    let searchIndex;\n     /**\n      *  @type {Array<string>}\n      */\n-    var searchWords;\n-    var currentResults;\n-    var ALIASES = {};\n-    var params = searchState.getQueryStringParams();\n+    let searchWords = [];\n+    let currentResults;\n+    const ALIASES = {};\n+    const params = searchState.getQueryStringParams();\n \n     // Populate search bar with query string search term when provided,\n     // but only if the input bar is empty. This avoid the obnoxious issue\n@@ -145,7 +149,7 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function itemTypeFromName(typename) {\n-        for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+        for (let i = 0, len = itemTypes.length; i < len; ++i) {\n             if (itemTypes[i] === typename) {\n                 return i;\n             }\n@@ -176,8 +180,8 @@ window.initSearch = function(rawSearchIndex) {\n             throw new Error(\"Cannot use literal search when there is more than one element\");\n         }\n         parserState.pos += 1;\n-        var start = parserState.pos;\n-        var end = getIdentEndPosition(parserState);\n+        const start = parserState.pos;\n+        const end = getIdentEndPosition(parserState);\n         if (parserState.pos >= parserState.length) {\n             throw new Error(\"Unclosed `\\\"`\");\n         } else if (parserState.userQuery[end] !== \"\\\"\") {\n@@ -264,10 +268,10 @@ window.initSearch = function(rawSearchIndex) {\n         if (query.literalSearch && parserState.totalElems - parserState.genericsElems > 0) {\n             throw new Error(\"You cannot have more than one element if you use quotes\");\n         }\n-        var pathSegments = name.split(\"::\");\n+        const pathSegments = name.split(\"::\");\n         if (pathSegments.length > 1) {\n-            for (var i = 0, len = pathSegments.length; i < len; ++i) {\n-                var pathSegment = pathSegments[i];\n+            for (let i = 0, len = pathSegments.length; i < len; ++i) {\n+                const pathSegment = pathSegments[i];\n \n                 if (pathSegment.length === 0) {\n                     if (i === 0) {\n@@ -305,9 +309,9 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {integer}\n      */\n     function getIdentEndPosition(parserState) {\n-        var end = parserState.pos;\n+        let end = parserState.pos;\n         while (parserState.pos < parserState.length) {\n-            var c = parserState.userQuery[parserState.pos];\n+            const c = parserState.userQuery[parserState.pos];\n             if (!isIdentCharacter(c)) {\n                 if (isErrorCharacter(c)) {\n                     throw new Error(`Unexpected \\`${c}\\``);\n@@ -342,10 +346,10 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean} isInGenerics\n      */\n     function getNextElem(query, parserState, elems, isInGenerics) {\n-        var generics = [];\n+        const generics = [];\n \n-        var start = parserState.pos;\n-        var end;\n+        let start = parserState.pos;\n+        let end;\n         // We handle the strings on their own mostly to make code easier to follow.\n         if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n             start += 1;\n@@ -393,10 +397,10 @@ window.initSearch = function(rawSearchIndex) {\n      *                                      character.\n      */\n     function getItemsBefore(query, parserState, elems, endChar) {\n-        var foundStopChar = true;\n+        let foundStopChar = true;\n \n         while (parserState.pos < parserState.length) {\n-            var c = parserState.userQuery[parserState.pos];\n+            const c = parserState.userQuery[parserState.pos];\n             if (c === endChar) {\n                 break;\n             } else if (isSeparatorCharacter(c)) {\n@@ -406,7 +410,7 @@ window.initSearch = function(rawSearchIndex) {\n             } else if (c === \":\" && isPathStart(parserState)) {\n                 throw new Error(\"Unexpected `::`: paths cannot start with `::`\");\n             } else if (c === \":\" || isEndCharacter(c)) {\n-                var extra = \"\";\n+                let extra = \"\";\n                 if (endChar === \">\") {\n                     extra = \"`<`\";\n                 } else if (endChar === \"\") {\n@@ -420,7 +424,7 @@ window.initSearch = function(rawSearchIndex) {\n                 }\n                 throw new Error(`Expected \\`,\\` or \\` \\`, found \\`${c}\\``);\n             }\n-            var posBefore = parserState.pos;\n+            const posBefore = parserState.pos;\n             getNextElem(query, parserState, elems, endChar === \">\");\n             // This case can be encountered if `getNextElem` encounted a \"stop character\" right from\n             // the start. For example if you have `,,` or `<>`. In this case, we simply move up the\n@@ -442,9 +446,9 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {ParserState} parserState\n      */\n     function checkExtraTypeFilterCharacters(parserState) {\n-        var query = parserState.userQuery;\n+        const query = parserState.userQuery;\n \n-        for (var pos = 0; pos < parserState.pos; ++pos) {\n+        for (let pos = 0; pos < parserState.pos; ++pos) {\n             if (!isIdentCharacter(query[pos]) && !isWhitespaceCharacter(query[pos])) {\n                 throw new Error(`Unexpected \\`${query[pos]}\\` in type filter`);\n             }\n@@ -459,8 +463,8 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {ParserState} parserState\n      */\n     function parseInput(query, parserState) {\n-        var c, before;\n-        var foundStopChar = true;\n+        let c, before;\n+        let foundStopChar = true;\n \n         while (parserState.pos < parserState.length) {\n             c = parserState.userQuery[parserState.pos];\n@@ -557,7 +561,7 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {string}\n      */\n     function buildUrl(search, filterCrates) {\n-        var extra = \"?search=\" + encodeURIComponent(search);\n+        let extra = \"?search=\" + encodeURIComponent(search);\n \n         if (filterCrates !== null) {\n             extra += \"&filter-crate=\" + encodeURIComponent(filterCrates);\n@@ -571,7 +575,7 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {string|null}\n      */\n     function getFilterCrates() {\n-        var elem = document.getElementById(\"crate-search\");\n+        const elem = document.getElementById(\"crate-search\");\n \n         if (elem &&\n             elem.value !== \"All crates\" &&\n@@ -650,7 +654,7 @@ window.initSearch = function(rawSearchIndex) {\n      */\n     function parseQuery(userQuery) {\n         userQuery = userQuery.trim();\n-        var parserState = {\n+        const parserState = {\n             length: userQuery.length,\n             pos: 0,\n             // Total number of elements (includes generics).\n@@ -659,12 +663,12 @@ window.initSearch = function(rawSearchIndex) {\n             typeFilter: null,\n             userQuery: userQuery.toLowerCase(),\n         };\n-        var query = newParsedQuery(userQuery);\n+        let query = newParsedQuery(userQuery);\n \n         try {\n             parseInput(query, parserState);\n             if (parserState.typeFilter !== null) {\n-                var typeFilter = parserState.typeFilter;\n+                let typeFilter = parserState.typeFilter;\n                 if (typeFilter === \"const\") {\n                     typeFilter = \"constant\";\n                 }\n@@ -715,19 +719,17 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {ResultsTable}\n      */\n     function execQuery(parsedQuery, searchWords, filterCrates) {\n-        var results_others = {}, results_in_args = {}, results_returned = {};\n+        const results_others = {}, results_in_args = {}, results_returned = {};\n \n         function transformResults(results) {\n-            var duplicates = {};\n-            var out = [];\n-\n-            for (var i = 0, len = results.length; i < len; ++i) {\n-                var result = results[i];\n+            const duplicates = {};\n+            const out = [];\n \n+            for (const result of results) {\n                 if (result.id > -1) {\n-                    var obj = searchIndex[result.id];\n+                    const obj = searchIndex[result.id];\n                     obj.lev = result.lev;\n-                    var res = buildHrefAndPath(obj);\n+                    const res = buildHrefAndPath(obj);\n                     obj.displayPath = pathSplitter(res[0]);\n                     obj.fullPath = obj.displayPath + obj.name;\n                     // To be sure than it some items aren't considered as duplicate.\n@@ -749,11 +751,11 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function sortResults(results, isType) {\n-            var userQuery = parsedQuery.userQuery;\n-            var ar = [];\n-            for (var entry in results) {\n+            const userQuery = parsedQuery.userQuery;\n+            const ar = [];\n+            for (const entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n-                    var result = results[entry];\n+                    const result = results[entry];\n                     result.word = searchWords[result.id];\n                     result.item = searchIndex[result.id] || {};\n                     ar.push(result);\n@@ -766,7 +768,7 @@ window.initSearch = function(rawSearchIndex) {\n             }\n \n             results.sort(function(aaa, bbb) {\n-                var a, b;\n+                let a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n                 a = (aaa.word !== userQuery);\n@@ -832,20 +834,18 @@ window.initSearch = function(rawSearchIndex) {\n                 return 0;\n             });\n \n-            var nameSplit = null;\n+            let nameSplit = null;\n             if (parsedQuery.elems.length === 1) {\n-                var hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n+                const hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n                 nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n             }\n \n-            for (var i = 0, len = results.length; i < len; ++i) {\n-                result = results[i];\n-\n+            for (const result of results) {\n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n                 }\n-                var name = result.item.name.toLowerCase(),\n+                const name = result.item.name.toLowerCase(),\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n@@ -877,15 +877,14 @@ window.initSearch = function(rawSearchIndex) {\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n-            var elem_name;\n+            let elem_name;\n             if (elem.generics.length > 0 && row[GENERICS_DATA].length >= elem.generics.length) {\n-                var elems = Object.create(null);\n-                for (var x = 0, length = row[GENERICS_DATA].length; x < length; ++x) {\n-                    elem_name = row[GENERICS_DATA][x][NAME];\n+                const elems = Object.create(null);\n+                for (const entry of row[GENERICS_DATA]) {\n+                    elem_name = entry[NAME];\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(\n-                                row[GENERICS_DATA][x], elem, MAX_LEV_DISTANCE + 1) !== 0) {\n+                        if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n                             return MAX_LEV_DISTANCE + 1;\n                         }\n                         continue;\n@@ -897,9 +896,8 @@ window.initSearch = function(rawSearchIndex) {\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n-                for (x = 0, length = elem.generics.length; x < length; ++x) {\n-                    var generic = elem.generics[x];\n-                    var match = null;\n+                for (const generic of elem.generics) {\n+                    let match = null;\n                     if (elems[generic.name]) {\n                         match = generic.name;\n                     } else {\n@@ -936,12 +934,12 @@ window.initSearch = function(rawSearchIndex) {\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n         function checkIfInGenerics(row, elem) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n-            for (var x = 0, length = row[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n-                lev = Math.min(\n-                    checkType(row[GENERICS_DATA][x], elem, true),\n-                    lev\n-                );\n+            let lev = MAX_LEV_DISTANCE + 1;\n+            for (const entry of row[GENERICS_DATA]) {\n+                lev = Math.min(checkType(entry, elem, true), lev);\n+                if (lev === 0) {\n+                    break;\n+                }\n             }\n             return lev;\n         }\n@@ -966,12 +964,12 @@ window.initSearch = function(rawSearchIndex) {\n                 return MAX_LEV_DISTANCE + 1;\n             }\n \n-            var lev = levenshtein(row[NAME], elem.name);\n+            let lev = levenshtein(row[NAME], elem.name);\n             if (literalSearch) {\n                 if (lev !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n                     if (elem.generics.length === 0) {\n-                        var checkGeneric = (row.length > GENERICS_DATA &&\n+                        const checkGeneric = (row.length > GENERICS_DATA &&\n                             row[GENERICS_DATA].length > 0);\n                         if (checkGeneric && row[GENERICS_DATA].findIndex(function(tmp_elem) {\n                             return tmp_elem[NAME] === elem.name;\n@@ -1004,7 +1002,7 @@ window.initSearch = function(rawSearchIndex) {\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    var tmp_lev = checkGenerics(row, elem, lev);\n+                    const tmp_lev = checkGenerics(row, elem, lev);\n                     if (tmp_lev > MAX_LEV_DISTANCE) {\n                         return MAX_LEV_DISTANCE + 1;\n                     }\n@@ -1032,16 +1030,14 @@ window.initSearch = function(rawSearchIndex) {\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n         function findArg(row, elem, typeFilter) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n+            let lev = MAX_LEV_DISTANCE + 1;\n \n             if (row && row.type && row.type[INPUTS_DATA] && row.type[INPUTS_DATA].length > 0) {\n-                var length = row.type[INPUTS_DATA].length;\n-                for (var i = 0; i < length; i++) {\n-                    var tmp = row.type[INPUTS_DATA][i];\n-                    if (!typePassesFilter(typeFilter, tmp[1])) {\n+                for (const input of row.type[INPUTS_DATA]) {\n+                    if (!typePassesFilter(typeFilter, input[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n@@ -1061,19 +1057,18 @@ window.initSearch = function(rawSearchIndex) {\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n         function checkReturned(row, elem, typeFilter) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n+            let lev = MAX_LEV_DISTANCE + 1;\n \n             if (row && row.type && row.type.length > OUTPUT_DATA) {\n-                var ret = row.type[OUTPUT_DATA];\n+                let ret = row.type[OUTPUT_DATA];\n                 if (typeof ret[0] === \"string\") {\n                     ret = [ret];\n                 }\n-                for (var x = 0, len = ret.length; x < len; ++x) {\n-                    var tmp = ret[x];\n-                    if (!typePassesFilter(typeFilter, tmp[1])) {\n+                for (const ret_ty of ret) {\n+                    if (!typePassesFilter(typeFilter, ret_ty[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n@@ -1086,26 +1081,26 @@ window.initSearch = function(rawSearchIndex) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            var ret_lev = MAX_LEV_DISTANCE + 1;\n-            var path = ty.path.split(\"::\");\n+            let ret_lev = MAX_LEV_DISTANCE + 1;\n+            const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n                 path.push(ty.parent.name.toLowerCase());\n             }\n \n-            var length = path.length;\n-            var clength = contains.length;\n+            const length = path.length;\n+            const clength = contains.length;\n             if (clength > length) {\n                 return MAX_LEV_DISTANCE + 1;\n             }\n-            for (var i = 0; i < length; ++i) {\n+            for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n                     break;\n                 }\n-                var lev_total = 0;\n-                var aborted = false;\n-                for (var x = 0; x < clength; ++x) {\n-                    var lev = levenshtein(path[i + x], contains[x]);\n+                let lev_total = 0;\n+                let aborted = false;\n+                for (let x = 0; x < clength; ++x) {\n+                    const lev = levenshtein(path[i + x], contains[x]);\n                     if (lev > MAX_LEV_DISTANCE) {\n                         aborted = true;\n                         break;\n@@ -1124,7 +1119,7 @@ window.initSearch = function(rawSearchIndex) {\n             if (filter <= NO_TYPE_FILTER || filter === type) return true;\n \n             // Match related items\n-            var name = itemTypes[type];\n+            const name = itemTypes[type];\n             switch (itemTypes[filter]) {\n                 case \"constant\":\n                     return name === \"associatedconstant\";\n@@ -1154,33 +1149,31 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function handleAliases(ret, query, filterCrates) {\n-            var lowerQuery = query.toLowerCase();\n+            const lowerQuery = query.toLowerCase();\n             // We separate aliases and crate aliases because we want to have current crate\n             // aliases to be before the others in the displayed results.\n-            var aliases = [];\n-            var crateAliases = [];\n+            const aliases = [];\n+            const crateAliases = [];\n             if (filterCrates !== null) {\n                 if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n-                    var query_aliases = ALIASES[filterCrates][lowerQuery];\n-                    var len = query_aliases.length;\n-                    for (var i = 0; i < len; ++i) {\n-                        aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                    const query_aliases = ALIASES[filterCrates][lowerQuery];\n+                    for (const alias of query_aliases) {\n+                        aliases.push(createAliasFromItem(searchIndex[alias]));\n                     }\n                 }\n             } else {\n                 Object.keys(ALIASES).forEach(function(crate) {\n                     if (ALIASES[crate][lowerQuery]) {\n-                        var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                        var query_aliases = ALIASES[crate][lowerQuery];\n-                        var len = query_aliases.length;\n-                        for (var i = 0; i < len; ++i) {\n-                            pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                        const pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                        const query_aliases = ALIASES[crate][lowerQuery];\n+                        for (const alias of query_aliases) {\n+                            pushTo.push(createAliasFromItem(searchIndex[alias]));\n                         }\n                     }\n                 });\n             }\n \n-            var sortFunc = function(aaa, bbb) {\n+            const sortFunc = function(aaa, bbb) {\n                 if (aaa.path < bbb.path) {\n                     return 1;\n                 } else if (aaa.path === bbb.path) {\n@@ -1191,9 +1184,9 @@ window.initSearch = function(rawSearchIndex) {\n             crateAliases.sort(sortFunc);\n             aliases.sort(sortFunc);\n \n-            var pushFunc = function(alias) {\n+            const pushFunc = function(alias) {\n                 alias.alias = query;\n-                var res = buildHrefAndPath(alias);\n+                const res = buildHrefAndPath(alias);\n                 alias.displayPath = pathSplitter(res[0]);\n                 alias.fullPath = alias.displayPath + alias.name;\n                 alias.href = res[1];\n@@ -1230,7 +1223,7 @@ window.initSearch = function(rawSearchIndex) {\n         function addIntoResults(results, fullId, id, index, lev) {\n             if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n                 if (results[fullId] !== undefined) {\n-                    var result = results[fullId];\n+                    const result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n                         return;\n                     }\n@@ -1270,19 +1263,19 @@ window.initSearch = function(rawSearchIndex) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            var lev, lev_add = 0, index = -1;\n-            var fullId = row.id;\n+            let lev, lev_add = 0, index = -1;\n+            const fullId = row.id;\n \n-            var in_args = findArg(row, elem, parsedQuery.typeFilter);\n-            var returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n \n             addIntoResults(results_in_args, fullId, pos, index, in_args);\n             addIntoResults(results_returned, fullId, pos, index, returned);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n             }\n-            var searchWord = searchWords[pos];\n+            const searchWord = searchWords[pos];\n \n             if (parsedQuery.literalSearch) {\n                 if (searchWord === elem.name) {\n@@ -1352,16 +1345,14 @@ window.initSearch = function(rawSearchIndex) {\n                 return;\n             }\n \n-            var totalLev = 0;\n-            var nbLev = 0;\n-            var lev;\n+            let totalLev = 0;\n+            let nbLev = 0;\n \n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n-                for (var i = 0, len = elems.length; i < len; ++i) {\n-                    var elem = elems[i];\n+                for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    lev = callback(row, elem, NO_TYPE_FILTER);\n+                    const lev = callback(row, elem, NO_TYPE_FILTER);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1381,12 +1372,12 @@ window.initSearch = function(rawSearchIndex) {\n             if (nbLev === 0) {\n                 return;\n             }\n-            lev = Math.round(totalLev / nbLev);\n+            const lev = Math.round(totalLev / nbLev);\n             addIntoResults(results, row.id, pos, 0, lev);\n         }\n \n         function innerRunQuery() {\n-            var elem, i, nSearchWords, in_returned, row;\n+            let elem, i, nSearchWords, in_returned, row;\n \n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n@@ -1413,7 +1404,7 @@ window.initSearch = function(rawSearchIndex) {\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n-                var container = results_others;\n+                let container = results_others;\n                 // In the special case where only a \"returned\" information is available, we want to\n                 // put the information into the \"results_returned\" dict.\n                 if (parsedQuery.returned.length !== 0 && parsedQuery.elems.length === 0) {\n@@ -1429,7 +1420,7 @@ window.initSearch = function(rawSearchIndex) {\n             innerRunQuery();\n         }\n \n-        var ret = createQueryResults(\n+        const ret = createQueryResults(\n             sortResults(results_in_args, true),\n             sortResults(results_returned, true),\n             sortResults(results_others, false),\n@@ -1462,26 +1453,26 @@ window.initSearch = function(rawSearchIndex) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n-        for (var i = 0, len = keys.length; i < len; ++i) {\n+        for (const key of keys) {\n             // each check is for validation so we negate the conditions and invalidate\n             if (!(\n                 // check for an exact name match\n-                name.indexOf(keys[i]) > -1 ||\n+                name.indexOf(key) > -1 ||\n                 // then an exact path match\n-                path.indexOf(keys[i]) > -1 ||\n+                path.indexOf(key) > -1 ||\n                 // next if there is a parent, check for exact parent match\n                 (parent !== undefined && parent.name !== undefined &&\n-                    parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                    parent.name.toLowerCase().indexOf(key) > -1) ||\n                 // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n+                levenshtein(name, key) <= MAX_LEV_DISTANCE)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n     function nextTab(direction) {\n-        var next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n+        const next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n         searchState.focusedByTab[searchState.currentTab] = document.activeElement;\n         printTab(next);\n         focusSearchResult();\n@@ -1490,7 +1481,7 @@ window.initSearch = function(rawSearchIndex) {\n     // Focus the first search result on the active tab, or the result that\n     // was focused last time this tab was active.\n     function focusSearchResult() {\n-        var target = searchState.focusedByTab[searchState.currentTab] ||\n+        const target = searchState.focusedByTab[searchState.currentTab] ||\n             document.querySelectorAll(\".search-results.active a\").item(0) ||\n             document.querySelectorAll(\"#titles > button\").item(searchState.currentTab);\n         if (target) {\n@@ -1499,11 +1490,11 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function buildHrefAndPath(item) {\n-        var displayPath;\n-        var href;\n-        var type = itemTypes[item.ty];\n-        var name = item.name;\n-        var path = item.path;\n+        let displayPath;\n+        let href;\n+        const type = itemTypes[item.ty];\n+        const name = item.name;\n+        let path = item.path;\n \n         if (type === \"mod\") {\n             displayPath = path + \"::\";\n@@ -1517,19 +1508,19 @@ window.initSearch = function(rawSearchIndex) {\n             displayPath = \"\";\n             href = window.rootPath + name + \"/index.html\";\n         } else if (item.parent !== undefined) {\n-            var myparent = item.parent;\n-            var anchor = \"#\" + type + \".\" + name;\n-            var parentType = itemTypes[myparent.ty];\n-            var pageType = parentType;\n-            var pageName = myparent.name;\n+            const myparent = item.parent;\n+            let anchor = \"#\" + type + \".\" + name;\n+            const parentType = itemTypes[myparent.ty];\n+            let pageType = parentType;\n+            let pageName = myparent.name;\n \n             if (parentType === \"primitive\") {\n                 displayPath = myparent.name + \"::\";\n             } else if (type === \"structfield\" && parentType === \"variant\") {\n                 // Structfields belonging to variants are special: the\n                 // final path element is the enum name.\n-                var enumNameIdx = item.path.lastIndexOf(\"::\");\n-                var enumName = item.path.substr(enumNameIdx + 2);\n+                const enumNameIdx = item.path.lastIndexOf(\"::\");\n+                const enumName = item.path.substr(enumNameIdx + 2);\n                 path = item.path.substr(0, enumNameIdx);\n                 displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n                 anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n@@ -1551,13 +1542,13 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function escape(content) {\n-        var h1 = document.createElement(\"h1\");\n+        const h1 = document.createElement(\"h1\");\n         h1.textContent = content;\n         return h1.innerHTML;\n     }\n \n     function pathSplitter(path) {\n-        var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n+        const tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n         if (tmp.endsWith(\"<span>\")) {\n             return tmp.slice(0, tmp.length - 6);\n         }\n@@ -1571,42 +1562,42 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean}     display - True if this is the active tab\n      */\n     function addTab(array, query, display) {\n-        var extraClass = \"\";\n+        let extraClass = \"\";\n         if (display === true) {\n             extraClass = \" active\";\n         }\n \n-        var output = document.createElement(\"div\");\n-        var length = 0;\n+        const output = document.createElement(\"div\");\n+        let length = 0;\n         if (array.length > 0) {\n             output.className = \"search-results \" + extraClass;\n \n             array.forEach(function(item) {\n-                var name = item.name;\n-                var type = itemTypes[item.ty];\n+                const name = item.name;\n+                const type = itemTypes[item.ty];\n \n                 length += 1;\n \n-                var extra = \"\";\n+                let extra = \"\";\n                 if (type === \"primitive\") {\n                     extra = \" <i>(primitive type)</i>\";\n                 } else if (type === \"keyword\") {\n                     extra = \" <i>(keyword)</i>\";\n                 }\n \n-                var link = document.createElement(\"a\");\n+                const link = document.createElement(\"a\");\n                 link.className = \"result-\" + type;\n                 link.href = item.href;\n \n-                var wrapper = document.createElement(\"div\");\n-                var resultName = document.createElement(\"div\");\n+                const wrapper = document.createElement(\"div\");\n+                const resultName = document.createElement(\"div\");\n                 resultName.className = \"result-name\";\n \n                 if (item.is_alias) {\n-                    var alias = document.createElement(\"span\");\n+                    const alias = document.createElement(\"span\");\n                     alias.className = \"alias\";\n \n-                    var bold = document.createElement(\"b\");\n+                    const bold = document.createElement(\"b\");\n                     bold.innerText = item.alias;\n                     alias.appendChild(bold);\n \n@@ -1621,9 +1612,9 @@ window.initSearch = function(rawSearchIndex) {\n                     item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" + name + extra + \"</span>\");\n                 wrapper.appendChild(resultName);\n \n-                var description = document.createElement(\"div\");\n+                const description = document.createElement(\"div\");\n                 description.className = \"desc\";\n-                var spanDesc = document.createElement(\"span\");\n+                const spanDesc = document.createElement(\"span\");\n                 spanDesc.insertAdjacentHTML(\"beforeend\", item.desc);\n \n                 description.appendChild(spanDesc);\n@@ -1664,15 +1655,15 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {string} filterCrates\n      */\n     function showResults(results, go_to_first, filterCrates) {\n-        var search = searchState.outputElement();\n+        const search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n             && getSettingValue(\"go-to-only-result\") === \"true\"\n             // By default, the search DOM element is \"empty\" (meaning it has no children not\n             // text content). Once a search has been run, it won't be empty, even if you press\n             // ESC or empty the search input (which also \"cancels\" the search).\n             && (!search.firstChild || search.firstChild.innerText !== searchState.loadingText)))\n         {\n-            var elem = document.createElement(\"a\");\n+            const elem = document.createElement(\"a\");\n             elem.href = results.others[0].href;\n             removeClass(elem, \"active\");\n             // For firefox, we need the element to be in the DOM so it can be clicked.\n@@ -1686,14 +1677,14 @@ window.initSearch = function(rawSearchIndex) {\n \n         currentResults = results.query.userQuery;\n \n-        var ret_others = addTab(results.others, results.query, true);\n-        var ret_in_args = addTab(results.in_args, results.query, false);\n-        var ret_returned = addTab(results.returned, results.query, false);\n+        const ret_others = addTab(results.others, results.query, true);\n+        const ret_in_args = addTab(results.in_args, results.query, false);\n+        const ret_returned = addTab(results.returned, results.query, false);\n \n         // Navigate to the relevant tab if the current tab is empty, like in case users search\n         // for \"-> String\". If they had selected another tab previously, they have to click on\n         // it again.\n-        var currentTab = searchState.currentTab;\n+        let currentTab = searchState.currentTab;\n         if ((currentTab === 0 && ret_others[1] === 0) ||\n                 (currentTab === 1 && ret_in_args[1] === 0) ||\n                 (currentTab === 2 && ret_returned[1] === 0)) {\n@@ -1709,18 +1700,18 @@ window.initSearch = function(rawSearchIndex) {\n         let crates = \"\";\n         if (window.ALL_CRATES.length > 1) {\n             crates = ` in <select id=\"crate-search\"><option value=\"All crates\">All crates</option>`;\n-            for (let c of window.ALL_CRATES) {\n+            for (const c of window.ALL_CRATES) {\n                 crates += `<option value=\"${c}\" ${c == filterCrates && \"selected\"}>${c}</option>`;\n             }\n             crates += `</select>`;\n         }\n \n-        var typeFilter = \"\";\n+        let typeFilter = \"\";\n         if (results.query.typeFilter !== NO_TYPE_FILTER) {\n             typeFilter = \" (type: \" + escape(itemTypes[results.query.typeFilter]) + \")\";\n         }\n \n-        var output = `<div id=\"search-settings\">` +\n+        let output = `<div id=\"search-settings\">` +\n             `<h1 class=\"search-results-title\">Results for ${escape(results.query.userQuery)}` +\n             `${typeFilter}</h1> in ${crates} </div>`;\n         if (results.query.error !== null) {\n@@ -1732,22 +1723,22 @@ window.initSearch = function(rawSearchIndex) {\n             makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n             \"</div>\";\n \n-        var resultsElem = document.createElement(\"div\");\n+        const resultsElem = document.createElement(\"div\");\n         resultsElem.id = \"results\";\n         resultsElem.appendChild(ret_others[0]);\n         resultsElem.appendChild(ret_in_args[0]);\n         resultsElem.appendChild(ret_returned[0]);\n \n         search.innerHTML = output;\n-        let crateSearch = document.getElementById(\"crate-search\");\n+        const crateSearch = document.getElementById(\"crate-search\");\n         if (crateSearch) {\n             crateSearch.addEventListener(\"input\", updateCrate);\n         }\n         search.appendChild(resultsElem);\n         // Reset focused elements.\n         searchState.focusedByTab = [null, null, null];\n         searchState.showResults(search);\n-        var elems = document.getElementById(\"titles\").childNodes;\n+        const elems = document.getElementById(\"titles\").childNodes;\n         elems[0].onclick = function() { printTab(0); };\n         elems[1].onclick = function() { printTab(1); };\n         elems[2].onclick = function() { printTab(2); };\n@@ -1761,8 +1752,8 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean} [forced]\n      */\n     function search(e, forced) {\n-        var params = searchState.getQueryStringParams();\n-        var query = parseQuery(searchState.input.value.trim());\n+        const params = searchState.getQueryStringParams();\n+        const query = parseQuery(searchState.input.value.trim());\n \n         if (e) {\n             e.preventDefault();\n@@ -1775,7 +1766,7 @@ window.initSearch = function(rawSearchIndex) {\n             return;\n         }\n \n-        var filterCrates = getFilterCrates();\n+        let filterCrates = getFilterCrates();\n \n         // In case we have no information about the saved crate and there is a URL query parameter,\n         // we override it with the URL query parameter.\n@@ -1789,7 +1780,7 @@ window.initSearch = function(rawSearchIndex) {\n         // Because searching is incremental by character, only the most\n         // recent search query is added to the browser history.\n         if (searchState.browserSupportsHistoryApi()) {\n-            var newURL = buildUrl(query.original, filterCrates);\n+            const newURL = buildUrl(query.original, filterCrates);\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", newURL);\n             } else {\n@@ -1808,17 +1799,17 @@ window.initSearch = function(rawSearchIndex) {\n         /**\n          * @type {Array<string>}\n          */\n-        var searchWords = [];\n-        var i, word;\n-        var currentIndex = 0;\n-        var id = 0;\n+        const searchWords = [];\n+        let i, word;\n+        let currentIndex = 0;\n+        let id = 0;\n \n-        for (var crate in rawSearchIndex) {\n+        for (const crate in rawSearchIndex) {\n             if (!hasOwnPropertyRustdoc(rawSearchIndex, crate)) {\n                 continue;\n             }\n \n-            var crateSize = 0;\n+            let crateSize = 0;\n \n             /**\n              * The raw search data for a given crate. `n`, `t`, `d`, and `q`, `i`, and `f`\n@@ -1850,13 +1841,13 @@ window.initSearch = function(rawSearchIndex) {\n              *   p: Array<Object>,\n              * }}\n              */\n-            var crateCorpus = rawSearchIndex[crate];\n+            const crateCorpus = rawSearchIndex[crate];\n \n             searchWords.push(crate);\n             // This object should have exactly the same set of fields as the \"row\"\n             // object defined below. Your JavaScript runtime will thank you.\n             // https://mathiasbynens.be/notes/shapes-ics\n-            var crateRow = {\n+            const crateRow = {\n                 crate: crate,\n                 ty: 1, // == ExternCrate\n                 name: crate,\n@@ -1872,26 +1863,26 @@ window.initSearch = function(rawSearchIndex) {\n             currentIndex += 1;\n \n             // an array of (Number) item types\n-            var itemTypes = crateCorpus.t;\n+            const itemTypes = crateCorpus.t;\n             // an array of (String) item names\n-            var itemNames = crateCorpus.n;\n+            const itemNames = crateCorpus.n;\n             // an array of (String) full paths (or empty string for previous path)\n-            var itemPaths = crateCorpus.q;\n+            const itemPaths = crateCorpus.q;\n             // an array of (String) descriptions\n-            var itemDescs = crateCorpus.d;\n+            const itemDescs = crateCorpus.d;\n             // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n-            var itemParentIdxs = crateCorpus.i;\n+            const itemParentIdxs = crateCorpus.i;\n             // an array of (Object | null) the type of the function, if any\n-            var itemFunctionSearchTypes = crateCorpus.f;\n+            const itemFunctionSearchTypes = crateCorpus.f;\n             // an array of [(Number) item type,\n             //              (String) name]\n-            var paths = crateCorpus.p;\n+            const paths = crateCorpus.p;\n             // an array of [(String) alias name\n             //             [Number] index to items]\n-            var aliases = crateCorpus.a;\n+            const aliases = crateCorpus.a;\n \n             // convert `rawPaths` entries into object form\n-            var len = paths.length;\n+            let len = paths.length;\n             for (i = 0; i < len; ++i) {\n                 paths[i] = {ty: paths[i][0], name: paths[i][1]};\n             }\n@@ -1904,7 +1895,7 @@ window.initSearch = function(rawSearchIndex) {\n             // all other search operations have access to this cached data for\n             // faster analysis operations\n             len = itemTypes.length;\n-            var lastPath = \"\";\n+            let lastPath = \"\";\n             for (i = 0; i < len; ++i) {\n                 // This object should have exactly the same set of fields as the \"crateRow\"\n                 // object defined above.\n@@ -1915,7 +1906,7 @@ window.initSearch = function(rawSearchIndex) {\n                     word = \"\";\n                     searchWords.push(\"\");\n                 }\n-                var row = {\n+                const row = {\n                     crate: crate,\n                     ty: itemTypes[i],\n                     name: itemNames[i],\n@@ -1934,18 +1925,16 @@ window.initSearch = function(rawSearchIndex) {\n \n             if (aliases) {\n                 ALIASES[crate] = {};\n-                var j, local_aliases;\n-                for (var alias_name in aliases) {\n+                for (const alias_name in aliases) {\n                     if (!hasOwnPropertyRustdoc(aliases, alias_name)) {\n                         continue;\n                     }\n \n                     if (!hasOwnPropertyRustdoc(ALIASES[crate], alias_name)) {\n                         ALIASES[crate][alias_name] = [];\n                     }\n-                    local_aliases = aliases[alias_name];\n-                    for (j = 0, len = local_aliases.length; j < len; ++j) {\n-                        ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                    for (const local_alias of aliases[alias_name]) {\n+                        ALIASES[crate][alias_name].push(local_alias + currentIndex);\n                     }\n                 }\n             }\n@@ -1965,11 +1954,11 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function putBackSearch() {\n-        var search_input = searchState.input;\n+        const search_input = searchState.input;\n         if (!searchState.input) {\n             return;\n         }\n-        var search = searchState.outputElement();\n+        const search = searchState.outputElement();\n         if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n             searchState.showResults(search);\n             if (searchState.browserSupportsHistoryApi()) {\n@@ -1981,7 +1970,7 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function registerSearchEvents() {\n-        var searchAfter500ms = function() {\n+        const searchAfter500ms = function() {\n             searchState.clearInputTimeout();\n             if (searchState.input.value.length === 0) {\n                 if (searchState.browserSupportsHistoryApi()) {\n@@ -2019,19 +2008,19 @@ window.initSearch = function(rawSearchIndex) {\n             // up and down arrow select next/previous search result, or the\n             // search box if we're already at the top.\n             if (e.which === 38) { // up\n-                var previous = document.activeElement.previousElementSibling;\n+                const previous = document.activeElement.previousElementSibling;\n                 if (previous) {\n                     previous.focus();\n                 } else {\n                     searchState.focus();\n                 }\n                 e.preventDefault();\n             } else if (e.which === 40) { // down\n-                var next = document.activeElement.nextElementSibling;\n+                const next = document.activeElement.nextElementSibling;\n                 if (next) {\n                     next.focus();\n                 }\n-                var rect = document.activeElement.getBoundingClientRect();\n+                const rect = document.activeElement.getBoundingClientRect();\n                 if (window.innerHeight - rect.bottom < rect.height) {\n                     window.scrollBy(0, rect.height);\n                 }\n@@ -2064,10 +2053,10 @@ window.initSearch = function(rawSearchIndex) {\n         // history.\n         if (searchState.browserSupportsHistoryApi()) {\n             // Store the previous <title> so we can revert back to it later.\n-            var previousTitle = document.title;\n+            const previousTitle = document.title;\n \n             window.addEventListener(\"popstate\", function(e) {\n-                var params = searchState.getQueryStringParams();\n+                const params = searchState.getQueryStringParams();\n                 // Revert to the previous title manually since the History\n                 // API ignores the title parameter.\n                 document.title = previousTitle;\n@@ -2103,7 +2092,7 @@ window.initSearch = function(rawSearchIndex) {\n         // that try to sync state between the URL and the search input. To work around it,\n         // do a small amount of re-init on page show.\n         window.onpageshow = function(){\n-            var qSearch = searchState.getQueryStringParams().search;\n+            const qSearch = searchState.getQueryStringParams().search;\n             if (searchState.input.value === \"\" && qSearch) {\n                 searchState.input.value = qSearch;\n             }\n@@ -2114,8 +2103,8 @@ window.initSearch = function(rawSearchIndex) {\n     function updateCrate(ev) {\n         if (ev.target.value === \"All crates\") {\n             // If we don't remove it from the URL, it'll be picked up again by the search.\n-            var params = searchState.getQueryStringParams();\n-            var query = searchState.input.value.trim();\n+            const params = searchState.getQueryStringParams();\n+            const query = searchState.input.value.trim();\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", buildUrl(query, null));\n             } else {"}, {"sha": "549d56450d8032698a50b582bc0373c3047494c0", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "patch": "@@ -1,4 +1,7 @@\n // Local js definitions:\n+/* eslint-env es6 */\n+/* eslint no-var: \"error\" */\n+/* eslint prefer-const: \"error\" */\n /* global getSettingValue, getVirtualKey, onEachLazy, updateLocalStorage, updateSystemTheme */\n /* global addClass, removeClass */\n \n@@ -55,9 +58,9 @@\n     function setEvents() {\n         updateLightAndDark();\n         onEachLazy(document.getElementsByClassName(\"slider\"), function(elem) {\n-            var toggle = elem.previousElementSibling;\n-            var settingId = toggle.id;\n-            var settingValue = getSettingValue(settingId);\n+            const toggle = elem.previousElementSibling;\n+            const settingId = toggle.id;\n+            const settingValue = getSettingValue(settingId);\n             if (settingValue !== null) {\n                 toggle.checked = settingValue === \"true\";\n             }\n@@ -68,9 +71,9 @@\n             toggle.onkeyrelease = handleKey;\n         });\n         onEachLazy(document.getElementsByClassName(\"select-wrapper\"), function(elem) {\n-            var select = elem.getElementsByTagName(\"select\")[0];\n-            var settingId = select.id;\n-            var settingValue = getSettingValue(settingId);\n+            const select = elem.getElementsByTagName(\"select\")[0];\n+            const settingId = select.id;\n+            const settingValue = getSettingValue(settingId);\n             if (settingValue !== null) {\n                 select.value = settingValue;\n             }"}, {"sha": "98d0f5dc656c17ac0cd4359630e5aba742d9b121", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/52fefb0454405763dc0b8ebe9f1fb927df3ca2d3/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=52fefb0454405763dc0b8ebe9f1fb927df3ca2d3", "patch": "@@ -85,8 +85,11 @@ function extractFunction(content, functionName) {\n }\n \n // Stupid function extractor for array.\n-function extractArrayVariable(content, arrayName) {\n-    var splitter = \"var \" + arrayName;\n+function extractArrayVariable(content, arrayName, kind) {\n+    if (typeof kind === \"undefined\") {\n+        kind = \"let \";\n+    }\n+    var splitter = kind + arrayName;\n     while (true) {\n         var start = content.indexOf(splitter);\n         if (start === -1) {\n@@ -126,12 +129,18 @@ function extractArrayVariable(content, arrayName) {\n         }\n         content = content.slice(start + 1);\n     }\n+    if (kind === \"let \") {\n+        return extractArrayVariable(content, arrayName, \"const \");\n+    }\n     return null;\n }\n \n // Stupid function extractor for variable.\n-function extractVariable(content, varName) {\n-    var splitter = \"var \" + varName;\n+function extractVariable(content, varName, kind) {\n+    if (typeof kind === \"undefined\") {\n+        kind = \"let \";\n+    }\n+    var splitter = kind + varName;\n     while (true) {\n         var start = content.indexOf(splitter);\n         if (start === -1) {\n@@ -162,6 +171,9 @@ function extractVariable(content, varName) {\n         }\n         content = content.slice(start + 1);\n     }\n+    if (kind === \"let \") {\n+        return extractVariable(content, varName, \"const \");\n+    }\n     return null;\n }\n "}]}