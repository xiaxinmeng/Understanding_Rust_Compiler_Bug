{"sha": "9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjRlMDBmNmZlMGY3MjBkOWJjNzExNmJmODljMjBhY2QzNWYwMGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-04T11:13:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-06T08:24:26Z"}, "message": "refactor ptr_offset_inbounds: it can be reduced to check_ptr_access, after all!", "tree": {"sha": "ef2d5c5a52a3c1c992544e77701209e0dcf68182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2d5c5a52a3c1c992544e77701209e0dcf68182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b", "html_url": "https://github.com/rust-lang/rust/commit/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4f1d3f4886d1bcb144aa5b929ca76e5d2804435", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f1d3f4886d1bcb144aa5b929ca76e5d2804435", "html_url": "https://github.com/rust-lang/rust/commit/c4f1d3f4886d1bcb144aa5b929ca76e5d2804435"}], "stats": {"total": 50, "additions": 14, "deletions": 36}, "files": [{"sha": "0c83b5bed93b731fc0098d7708c5f65d0b2b87c3", "filename": "src/operator.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=9eb4e00f6fe0f720d9bc7116bf89c20acd35f00b", "patch": "@@ -1,16 +1,11 @@\n use std::convert::TryFrom;\n \n-use rustc::ty::{Ty, layout::LayoutOf};\n+use rustc::ty::{Ty, layout::{Size, Align, LayoutOf}};\n use rustc::mir;\n \n use crate::*;\n \n pub trait EvalContextExt<'tcx> {\n-    fn pointer_inbounds(\n-        &self,\n-        ptr: Pointer<Tag>\n-    ) -> InterpResult<'tcx>;\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -33,13 +28,6 @@ pub trait EvalContextExt<'tcx> {\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n-    /// Test if the pointer is in-bounds of a live allocation.\n-    #[inline]\n-    fn pointer_inbounds(&self, ptr: Pointer<Tag>) -> InterpResult<'tcx> {\n-        let (size, _align) = self.memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n-        ptr.check_inbounds_alloc(size, CheckInAllocMsg::InboundsTest)\n-    }\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -110,9 +98,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     }\n \n     /// Raises an error if the offset moves the pointer outside of its allocation.\n-    /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n-    /// moves in there because the size is 0). We also consider the NULL pointer its own separate\n-    /// allocation, and all the remaining integers pointers their own allocation.\n+    /// For integers, we consider each of them their own tiny allocation of size 0,\n+    /// so offset-by-0 is okay for them -- except for NULL, which we rule out entirely.\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar<Tag>,\n@@ -123,25 +110,16 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         let offset = offset\n             .checked_mul(pointee_size)\n             .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n-        // Now let's see what kind of pointer this is.\n-        let ptr = if offset == 0 {\n-            match ptr {\n-                Scalar::Ptr(ptr) => ptr,\n-                Scalar::Raw { .. } => {\n-                    // Offset 0 on an integer. We accept that, pretending there is\n-                    // a little zero-sized allocation here.\n-                    return Ok(ptr);\n-                }\n-            }\n-        } else {\n-            // Offset > 0. We *require* a pointer.\n-            self.force_ptr(ptr)?\n-        };\n-        // Both old and new pointer must be in-bounds of a *live* allocation.\n-        // (Of the same allocation, but that part is trivial with our representation.)\n-        self.pointer_inbounds(ptr)?;\n-        let ptr = ptr.signed_offset(offset, self)?;\n-        self.pointer_inbounds(ptr)?;\n-        Ok(Scalar::Ptr(ptr))\n+        // We do this forst, to rule out overflows.\n+        let offset_ptr = ptr.ptr_signed_offset(offset, self)?;\n+        // What we need to check is that starting at `ptr`,\n+        // we could do an access of size `offset`. Alignment does not matter.\n+        self.memory.check_ptr_access(\n+            ptr,\n+            Size::from_bytes(u64::try_from(offset).unwrap()),\n+            Align::from_bytes(1).unwrap(),\n+        )?;\n+        // That's it!\n+        Ok(offset_ptr)\n     }\n }"}]}