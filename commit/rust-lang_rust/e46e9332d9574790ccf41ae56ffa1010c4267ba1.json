{"sha": "e46e9332d9574790ccf41ae56ffa1010c4267ba1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NmU5MzMyZDk1NzQ3OTBjY2Y0MWFlNTZmZmExMDEwYzQyNjdiYTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T04:58:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T17:10:13Z"}, "message": "serialize: Read/emit tuples with {read,emit}_tuple\n\nThis commit moves from {read,emit}_seq for tuples to {read,emit}_tuple, as well\nas providing a generalized macro for generating these implementations from one\ninvocation.\n\nCloses #13086", "tree": {"sha": "6f09b1def93596d44f46df8aed2cbde6936926b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f09b1def93596d44f46df8aed2cbde6936926b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e46e9332d9574790ccf41ae56ffa1010c4267ba1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e46e9332d9574790ccf41ae56ffa1010c4267ba1", "html_url": "https://github.com/rust-lang/rust/commit/e46e9332d9574790ccf41ae56ffa1010c4267ba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e46e9332d9574790ccf41ae56ffa1010c4267ba1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e233a43f5a0e14ceb322b955b16c8967adb2f4a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e233a43f5a0e14ceb322b955b16c8967adb2f4a8", "html_url": "https://github.com/rust-lang/rust/commit/e233a43f5a0e14ceb322b955b16c8967adb2f4a8"}], "stats": {"total": 170, "additions": 30, "deletions": 140}, "files": [{"sha": "036b580cc5f3692217ca2f70490881767ff1467d", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 30, "deletions": 140, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/e46e9332d9574790ccf41ae56ffa1010c4267ba1/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e46e9332d9574790ccf41ae56ffa1010c4267ba1/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=e46e9332d9574790ccf41ae56ffa1010c4267ba1", "patch": "@@ -477,153 +477,43 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     }\n }\n \n-impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                s.emit_seq(2, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    fn decode(d: &mut D) -> (T0, T1) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 2);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>\n-> Encodable<S> for (T0, T1, T2) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                s.emit_seq(3, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>\n-> Decodable<D> for (T0, T1, T2) {\n-    fn decode(d: &mut D) -> (T0, T1, T2) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 3);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                s.emit_seq(4, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n+macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+\n+macro_rules! tuple (\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<D:Decoder,$($name:Decodable<D>),*> Decodable<D> for ($($name,)*) {\n+            #[allow(uppercase_variables)]\n+            fn decode(d: &mut D) -> ($($name,)*) {\n+                d.read_tuple(|d, amt| {\n+                    let mut i = 0;\n+                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> $name {\n+                        Decodable::decode(d)\n+                    }),)*);\n+                    assert!(amt == i,\n+                            \"expected tuple of length `{}`, found tuple \\\n+                             of length `{}`\", i, amt);\n+                    return ret;\n                 })\n             }\n         }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 4);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>,\n-    T4: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3, T4) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                s.emit_seq(5, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n-                    s.emit_seq_elt(4, |s| t4.encode(s));\n+        impl<S:Encoder,$($name:Encodable<S>),*> Encodable<S> for ($($name,)*) {\n+            #[allow(uppercase_variables)]\n+            fn encode(&self, s: &mut S) {\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(let $name = $name; n += 1;)*\n+                s.emit_tuple(n, |s| {\n+                    let mut i = 0;\n+                    $(s.emit_seq_elt({ i+=1; i-1 }, |s| $name.encode(s));)*\n                 })\n             }\n         }\n-    }\n-}\n+        peel!($($name,)*)\n+    )\n+)\n \n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>,\n-    T4: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 5);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d)),\n-                d.read_seq_elt(4, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n impl<E: Encoder> Encodable<E> for path::posix::Path {\n     fn encode(&self, e: &mut E) {"}]}