{"sha": "0957ede5027c0bffe208904998675a17bfd4cd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NTdlZGU1MDI3YzBiZmZlMjA4OTA0OTk4Njc1YTE3YmZkNGNkNTk=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-07-01T22:43:01Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-07-01T23:46:07Z"}, "message": "Make causal tracking lazy", "tree": {"sha": "c453480ba2599e5f99cd5e4c099d4bedc112ed74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c453480ba2599e5f99cd5e4c099d4bedc112ed74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0957ede5027c0bffe208904998675a17bfd4cd59", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAls5Z78ACgkQiMlBzaHU\nZDJ2pw//Y+VQvzUnHmlc2/Axte6ju133ATzv1jJdcmtgkulKSaAsBnSdU0n+i3/n\njZZKlTi5cwd8TGpaeVwvcVyTuNQKGy6xeXuS43TgFO8gZP1J1A3FCHq25suoPrHW\n+YH/hzJAiziqpLbhdl1ruo1kcXJXF9wFE7wwayx6gcyLbnNP5rnI8WOkdA5rpqho\nBPYmRmhIIYxJcmPXBOHrl/QseavSM6EbGGO24FbD30KkMN4fR+77EtxDumdZ78Y5\nq3toU98zPw7WT2cJEgSKANXDSdpTXtHJXRcMXEFRPPgMNW46zO+jdFd8GxVapDHI\nhNTfTho2GG0YtD+zNlTqWIrl5VOqljbLre2txreIlyTvsUIZimSGoxr+QbxNoLEF\nQelOZrcPajBgUUSVhf7B9V+tMHB3KydNGpFM4PIT0WVhCCOgmKn+VOeTVhaMqhu4\nL0HcuRDwvRG9yIVRFUZUhnOgtvGQ3lXRrksTmansBV2W5pMYuLINJisfFoMrwHVp\nZH2PMVwZTawGTvi4ns2ICeg7MwUsMQdOOKUeS5AzVIQX0rzAyusvq6qej1E3vLvx\nPVY1SY1G3QYrXRzMb77Xk8e5KJOJbqK6JXsRTrt4ywJniurLU1GaFgsfFA3SakhJ\nkhpi87oCvXrp9AXb1AE99GeaQv68CH1dmf3NRy/a6v12dobEXnM=\n=Mi+U\n-----END PGP SIGNATURE-----", "payload": "tree c453480ba2599e5f99cd5e4c099d4bedc112ed74\nparent 24f91e878244990595649120f402cc13263ae54f\nauthor Santiago Pastorino <spastorino@gmail.com> 1530484981 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1530488767 -0300\n\nMake causal tracking lazy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0957ede5027c0bffe208904998675a17bfd4cd59", "html_url": "https://github.com/rust-lang/rust/commit/0957ede5027c0bffe208904998675a17bfd4cd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0957ede5027c0bffe208904998675a17bfd4cd59/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24f91e878244990595649120f402cc13263ae54f", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f91e878244990595649120f402cc13263ae54f", "html_url": "https://github.com/rust-lang/rust/commit/24f91e878244990595649120f402cc13263ae54f"}], "stats": {"total": 544, "additions": 225, "deletions": 319}, "files": [{"sha": "dca0d4f442a4cbf0971e759cc30fdddfdc7c69a7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -1000,6 +1000,10 @@ impl<'tcx> Terminator<'tcx> {\n         self.kind.successors_mut()\n     }\n \n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        self.kind.unwind()\n+    }\n+\n     pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n         self.kind.unwind_mut()\n     }\n@@ -1195,6 +1199,31 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdges { .. } => None,\n+            TerminatorKind::Call {\n+                cleanup: ref unwind,\n+                ..\n+            }\n+            | TerminatorKind::Assert {\n+                cleanup: ref unwind,\n+                ..\n+            }\n+            | TerminatorKind::DropAndReplace { ref unwind, .. }\n+            | TerminatorKind::Drop { ref unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n+        }\n+    }\n+\n     pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n         match *self {\n             TerminatorKind::Goto { .. }"}, {"sha": "25a0123755f2c586e540d18fd7bbecf34f1f388d", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::type_check::AtLocation;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n@@ -33,7 +33,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location, Cause)],\n+    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location)],\n ) {\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n@@ -69,14 +69,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_substs(substs);\n     }\n \n     /// We sometimes have `region` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*region, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*region, location);\n         self.super_region(region);\n     }\n \n@@ -94,7 +94,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                 );\n             }\n             TyContext::Location(location) => {\n-                self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n+                self.add_regular_live_constraint(*ty, location);\n             }\n         }\n \n@@ -104,14 +104,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `generator_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_generator_substs(&mut self, substs: &GeneratorSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_generator_substs(substs);\n     }\n \n     /// We sometimes have `closure_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_closure_substs(substs);\n     }\n \n@@ -233,7 +233,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// that we also have to respect.\n     fn add_region_liveness_constraints_from_type_check(\n         &mut self,\n-        liveness_set: &[(ty::Region<'tcx>, Location, Cause)],\n+        liveness_set: &[(ty::Region<'tcx>, Location)],\n     ) {\n         debug!(\n             \"add_region_liveness_constraints_from_type_check(liveness_set={} items)\",\n@@ -247,16 +247,16 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             ..\n         } = self;\n \n-        for (region, location, cause) in liveness_set {\n+        for (region, location) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = regioncx.to_region_vid(region);\n-            regioncx.add_live_point(region_vid, *location, &cause);\n+            regioncx.add_live_point(region_vid, *location);\n         }\n \n         if let Some(all_facts) = all_facts {\n             all_facts\n                 .region_live_at\n-                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                .extend(liveness_set.into_iter().flat_map(|(region, location)| {\n                     let r = regioncx.to_region_vid(region);\n                     let p1 = location_table.start_index(*location);\n                     let p2 = location_table.mid_index(*location);\n@@ -269,7 +269,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location, cause: Cause)\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -282,7 +282,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location, &cause);\n+                self.regioncx.add_live_point(vid, location);\n             });\n     }\n "}, {"sha": "a65019690e3077488bf9c341721fafac2d0c943b", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 100, "deletions": 74, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -8,74 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::borrow_set::BorrowData;\n-use borrow_check::nll::region_infer::RegionInferenceContext;\n+use std::collections::VecDeque;\n+use std::rc::Rc;\n+\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::ToRegionVid;\n use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use util::liveness::{self, DefUse, LivenessMode};\n \n-crate fn regular_use<'gcx, 'tcx>(\n-    mir: &'gcx Mir,\n-    regioncx: &'tcx RegionInferenceContext,\n-    borrow: &'tcx BorrowData,\n+crate fn find<'cx, 'gcx: 'tcx, 'tcx: 'cx>(\n+    mir: &'cx Mir<'tcx>,\n+    regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n     start_point: Location,\n-    local: Local,\n-) -> Option<Location> {\n+) -> Option<Cause> {\n     let mut uf = UseFinder {\n         mir,\n         regioncx,\n-        borrow,\n+        tcx,\n+        region_vid,\n         start_point,\n-        local,\n         liveness_mode: LivenessMode {\n             include_regular_use: true,\n-            include_drops: false,\n-        },\n-    };\n-\n-    uf.find()\n-}\n-\n-crate fn drop_use<'gcx, 'tcx>(\n-    mir: &'gcx Mir,\n-    regioncx: &'tcx RegionInferenceContext,\n-    borrow: &'tcx BorrowData,\n-    start_point: Location,\n-    local: Local,\n-) -> Option<Location> {\n-    let mut uf = UseFinder {\n-        mir,\n-        regioncx,\n-        borrow,\n-        start_point,\n-        local,\n-        liveness_mode: LivenessMode {\n-            include_regular_use: false,\n             include_drops: true,\n         },\n     };\n \n     uf.find()\n }\n \n-struct UseFinder<'gcx, 'tcx> {\n-    mir: &'gcx Mir<'gcx>,\n-    regioncx: &'tcx RegionInferenceContext<'tcx>,\n-    borrow: &'tcx BorrowData<'tcx>,\n+struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n     start_point: Location,\n-    local: Local,\n     liveness_mode: LivenessMode,\n }\n \n-impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n-    fn find(&mut self) -> Option<Location> {\n-        let mut stack = vec![];\n+impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n+    fn find(&mut self) -> Option<Cause> {\n+        let mut queue = VecDeque::new();\n         let mut visited = FxHashSet();\n \n-        stack.push(self.start_point);\n-        while let Some(p) = stack.pop() {\n-            if !self.regioncx.region_contains_point(self.borrow.region, p) {\n+        queue.push_back(self.start_point);\n+        while let Some(p) = queue.pop_front() {\n+            if !self.regioncx.region_contains_point(self.region_vid, p) {\n                 continue;\n             }\n \n@@ -84,58 +66,102 @@ impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n             }\n \n             let block_data = &self.mir[p.block];\n-            let (defined, used) = self.def_use(p, block_data.visitable(p.statement_index));\n-\n-            if used {\n-                return Some(p);\n-            } else if !defined {\n-                if p.statement_index < block_data.statements.len() {\n-                    stack.push(Location {\n-                        statement_index: p.statement_index + 1,\n-                        ..p\n-                    });\n-                } else {\n-                    stack.extend(block_data.terminator().successors().map(|&basic_block| {\n-                        Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }\n-                    }));\n+\n+            match self.def_use(p, block_data.visitable(p.statement_index)) {\n+                Some(DefUseResult::Def) => {}\n+\n+                Some(DefUseResult::UseLive { local }) => {\n+                    return Some(Cause::LiveVar(local, p));\n+                }\n+\n+                Some(DefUseResult::UseDrop { local }) => {\n+                    return Some(Cause::DropVar(local, p));\n+                }\n+\n+                None => {\n+                    if p.statement_index < block_data.statements.len() {\n+                        queue.push_back(Location {\n+                            statement_index: p.statement_index + 1,\n+                            ..p\n+                        });\n+                    } else {\n+                        queue.extend(\n+                            block_data\n+                                .terminator()\n+                                .successors()\n+                                .filter(|&bb| Some(&Some(*bb)) != block_data.terminator().unwind())\n+                                .map(|&bb| Location {\n+                                    statement_index: 0,\n+                                    block: bb,\n+                                }),\n+                        );\n+                    }\n                 }\n             }\n         }\n \n         None\n     }\n \n-    fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> (bool, bool) {\n+    fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> Option<DefUseResult> {\n         let mut visitor = DefUseVisitor {\n-            defined: false,\n-            used: false,\n-            local: self.local,\n+            mir: self.mir,\n+            tcx: self.tcx,\n+            region_vid: self.region_vid,\n             liveness_mode: self.liveness_mode,\n+            def_use_result: None,\n         };\n \n         thing.apply(location, &mut visitor);\n \n-        (visitor.defined, visitor.used)\n+        visitor.def_use_result\n     }\n }\n \n-struct DefUseVisitor {\n-    defined: bool,\n-    used: bool,\n-    local: Local,\n+struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n     liveness_mode: LivenessMode,\n+    def_use_result: Option<DefUseResult>,\n+}\n+\n+enum DefUseResult {\n+    Def,\n+\n+    UseLive { local: Local },\n+\n+    UseDrop { local: Local },\n }\n \n-impl<'tcx> Visitor<'tcx> for DefUseVisitor {\n+impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'gcx, 'tcx> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        if local == self.local {\n+        let local_ty = self.mir.local_decls[local].ty;\n+\n+        let mut found_it = false;\n+        self.tcx.for_each_free_region(&local_ty, |r| {\n+            if r.to_region_vid() == self.region_vid {\n+                found_it = true;\n+            }\n+        });\n+\n+        if found_it {\n             match liveness::categorize(context, self.liveness_mode) {\n-                Some(DefUse::Def) => self.defined = true,\n-                Some(DefUse::Use) => self.used = true,\n-                None => (),\n+                Some(DefUse::Def) => {\n+                    self.def_use_result = Some(DefUseResult::Def);\n+                }\n+\n+                Some(DefUse::Use) => {\n+                    self.def_use_result = if context.is_drop() {\n+                        Some(DefUseResult::UseDrop { local })\n+                    } else {\n+                        Some(DefUseResult::UseLive { local })\n+                    };\n+                }\n+\n+                None => {\n+                    self.def_use_result = None;\n+                }\n             }\n         }\n     }"}, {"sha": "bc4646b7c789a1724cdc51d0e89589a9cf2c8d0c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 53, "deletions": 68, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -38,87 +38,72 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let regioncx = &&self.nonlexical_regioncx;\n+        debug!(\n+            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n+            context, borrow, kind_place,\n+        );\n+\n+        let regioncx = &self.nonlexical_regioncx;\n         let mir = self.mir;\n+        let tcx = self.tcx;\n \n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n-        if let Some(cause) = regioncx.why_region_contains_point(borrow_region_vid, context.loc) {\n-            match cause {\n-                Cause::LiveVar(local, location) => match find_use::regular_use(\n-                    mir, regioncx, borrow, location, local,\n-                ) {\n-                    Some(p) => {\n-                        err.span_label(mir.source_info(p).span, format!(\"borrow later used here\"));\n-                    }\n \n-                    None => {\n-                        span_bug!(\n-                            mir.source_info(context.loc).span,\n-                            \"Cause should end in a LiveVar\"\n-                        );\n-                    }\n-                },\n+        debug!(\n+            \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n+            borrow_region_vid\n+        );\n \n-                Cause::DropVar(local, location) => match find_use::drop_use(\n-                    mir, regioncx, borrow, location, local,\n-                ) {\n-                    Some(p) => match &mir.local_decls[local].name {\n-                        Some(local_name) => {\n-                            err.span_label(\n-                                mir.source_info(p).span,\n-                                format!(\"borrow later used here, when `{}` is dropped\", local_name),\n-                            );\n+        let region_sub = regioncx.find_constraint(borrow_region_vid, context.loc);\n \n-                            if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                                if let Place::Local(borrowed_local) = place {\n-                                    let dropped_local_scope =\n-                                        mir.local_decls[local].visibility_scope;\n-                                    let borrowed_local_scope =\n-                                        mir.local_decls[*borrowed_local].visibility_scope;\n+        debug!(\n+            \"explain_why_borrow_contains_point: region_sub={:?}\",\n+            region_sub\n+        );\n \n-                                    if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n-                                        err.note(\n-                                            \"values in a scope are dropped \\\n-                                             in the opposite order they are defined\",\n-                                        );\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        None => {\n-                            err.span_label(\n-                                mir.local_decls[local].source_info.span,\n-                                \"borrow may end up in a temporary, created here\",\n-                            );\n+        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+            Some(Cause::LiveVar(_local, location)) => {\n+                err.span_label(\n+                    mir.source_info(location).span,\n+                    format!(\"borrow later used here\"),\n+                );\n+            }\n \n-                            err.span_label(\n-                                mir.source_info(p).span,\n-                                \"temporary later dropped here, \\\n-                                 potentially using the reference\",\n-                            );\n-                        }\n-                    },\n+            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n+                Some(local_name) => {\n+                    err.span_label(\n+                        mir.source_info(location).span,\n+                        format!(\"borrow later used here, when `{}` is dropped\", local_name),\n+                    );\n \n-                    None => {\n-                        span_bug!(\n-                            mir.source_info(context.loc).span,\n-                            \"Cause should end in a DropVar\"\n-                        );\n-                    }\n-                },\n+                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                        if let Place::Local(borrowed_local) = place {\n+                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n+                            let borrowed_local_scope =\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n \n-                Cause::UniversalRegion(region_vid) => {\n-                    if let Some(region) = regioncx.to_error_region(region_vid) {\n-                        self.tcx.note_and_explain_free_region(\n-                            err,\n-                            \"borrowed value must be valid for \",\n-                            region,\n-                            \"...\",\n-                        );\n+                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n+                                err.note(\n+                                    \"values in a scope are dropped \\\n+                                     in the opposite order they are defined\",\n+                                );\n+                            }\n+                        }\n                     }\n                 }\n \n-                _ => {}\n+                None => {}\n+            },\n+\n+            None => {\n+                if let Some(region) = regioncx.to_error_region(region_sub) {\n+                    self.tcx.note_and_explain_free_region(\n+                        err,\n+                        \"borrowed value must be valid for \",\n+                        region,\n+                        \"...\",\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "6543516b9c2c642e75c7b9e8382eebfd5693470f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::fmt;\n-use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -259,15 +259,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n-        // Find some constraint `X: Y` where:\n-        // - `fr1: X` transitively\n-        // - and `Y` is live at `elem`\n+    // Find some constraint `X: Y` where:\n+    // - `fr1: X` transitively\n+    // - and `Y` is live at `elem`\n+    crate fn find_constraint(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints[index].sub;\n-\n-        // then return why `Y` was live at `elem`\n-        self.liveness_constraints.cause(region_sub, elem)\n+        self.constraints[index].sub\n     }\n \n     /// Tries to finds a good span to blame for the fact that `fr1`"}, {"sha": "fd6d79d160ea625de4427245d8480814192fe65b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -75,8 +75,6 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_regions: UniversalRegions<'tcx>,\n }\n \n-struct TrackCauses(bool);\n-\n struct RegionDefinition<'tcx> {\n     /// Why we created this variable. Mostly these will be\n     /// `RegionVariableOrigin::NLL`, but some variables get created\n@@ -105,13 +103,6 @@ pub(crate) enum Cause {\n \n     /// point inserted because Local was dropped at the given Location\n     DropVar(Local, Location),\n-\n-    /// point inserted because the type was live at the given Location,\n-    /// but not as part of some local variable\n-    LiveOther(Location),\n-\n-    /// part of the initial set of values for a universally quantified region\n-    UniversalRegion(RegionVid),\n }\n \n /// A \"type test\" corresponds to an outlives constraint between a type\n@@ -283,15 +274,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 self.liveness_constraints.add_element(\n                     variable,\n                     point_index,\n-                    &Cause::UniversalRegion(variable),\n                 );\n             }\n \n             // Add `end(X)` into the set for X.\n             self.liveness_constraints.add_element(\n                 variable,\n                 variable,\n-                &Cause::UniversalRegion(variable),\n             );\n         }\n     }\n@@ -337,13 +326,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location, cause: &Cause) -> bool {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        debug!(\"add_live_point: @{:?} Adding cause {:?}\", point, cause);\n \n         let element = self.elements.index(point);\n-        self.liveness_constraints.add_element(v, element, &cause)\n+        self.liveness_constraints.add_element(v, element)\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n@@ -436,7 +424,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.duplicate(TrackCauses(false));\n+        let mut inferred_values = self.liveness_constraints.clone();\n \n         let dependency_map = self.dependency_map.as_ref().unwrap();\n "}, {"sha": "5be4297f660dd99ddb395e44a200dc20cb415845", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 3, "deletions": 81, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -8,18 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::TrackCauses;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n use rustc_data_structures::bitvec::SparseBitMatrix;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n use std::rc::Rc;\n \n-use super::Cause;\n-\n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n pub(super) struct RegionValueElements {\n@@ -180,19 +176,12 @@ impl ToElementIndex for RegionElementIndex {\n /// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n+#[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n-\n-    /// If cause tracking is enabled, maps from a pair (r, e)\n-    /// consisting of a region `r` that contains some element `e` to\n-    /// the reason that the element is contained. There should be an\n-    /// entry for every bit set to 1 in `SparseBitMatrix`.\n-    causes: Option<CauseMap>,\n }\n \n-type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Cause>;\n-\n impl RegionValues {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n@@ -209,25 +198,6 @@ impl RegionValues {\n                 RegionVid::new(num_region_variables),\n                 RegionElementIndex::new(elements.num_elements()),\n             ),\n-            causes: Some(CauseMap::default()),\n-        }\n-    }\n-\n-    /// Duplicates the region values. If track_causes is false, then the\n-    /// resulting value will not track causal information (and any existing\n-    /// causal information is dropped). Otherwise, the causal information is\n-    /// preserved and maintained. Tracking the causal information makes region\n-    /// propagation significantly slower, so we prefer not to do it until an\n-    /// error is reported.\n-    pub(super) fn duplicate(&self, track_causes: TrackCauses) -> Self {\n-        Self {\n-            elements: self.elements.clone(),\n-            matrix: self.matrix.clone(),\n-            causes: if track_causes.0 {\n-                self.causes.clone()\n-            } else {\n-                None\n-            },\n         }\n     }\n \n@@ -237,10 +207,10 @@ impl RegionValues {\n         &mut self,\n         r: RegionVid,\n         elem: E,\n-        cause: &Cause,\n     ) -> bool {\n         let i = self.elements.index(elem);\n-        self.add_internal(r, i, |_| cause.clone())\n+        debug!(\"add(r={:?}, elem={:?})\", r, elem);\n+        self.matrix.add(r, i)\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n@@ -249,40 +219,6 @@ impl RegionValues {\n         self.matrix.merge(r_from, r_to)\n     }\n \n-    /// Internal method to add an element to a region.\n-    ///\n-    /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n-    /// be invoked if cause tracking is enabled.\n-    fn add_internal<F>(&mut self, r: RegionVid, i: RegionElementIndex, make_cause: F) -> bool\n-    where\n-        F: FnOnce(&CauseMap) -> Cause,\n-    {\n-        if self.matrix.add(r, i) {\n-            debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n-\n-            if let Some(causes) = &mut self.causes {\n-                let cause = make_cause(causes);\n-                causes.insert((r, i), cause);\n-            }\n-\n-            true\n-        } else {\n-            if let Some(causes) = &mut self.causes {\n-                let cause = make_cause(causes);\n-                let old_cause = causes.get_mut(&(r, i)).unwrap();\n-                // #49998: compare using root cause alone to avoid\n-                // useless traffic from similar outlives chains.\n-\n-                if cause < *old_cause {\n-                    *old_cause = cause;\n-                    return true;\n-                }\n-            }\n-\n-            false\n-        }\n-    }\n-\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n@@ -398,18 +334,4 @@ impl RegionValues {\n             ));\n         }\n     }\n-\n-    /// Given a region `r` that contains the element `elem`, returns the `Cause`\n-    /// that tells us *why* `elem` is found in that region.\n-    ///\n-    /// Returns None if cause tracking is disabled or `elem` is not\n-    /// actually found in `r`.\n-    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Cause> {\n-        let index = self.elements.index(elem);\n-        if let Some(causes) = &self.causes {\n-            causes.get(&(r, index)).cloned()\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "dbdfef21970249fbf10fa51bd3a656d70df1ad0d", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n@@ -88,8 +87,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             .simulate_block(self.mir, bb, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    let cause = Cause::LiveVar(live_local, location);\n-                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location, cause);\n+                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n             });\n \n@@ -161,7 +159,6 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n         value: T,\n         location: Location,\n-        cause: Cause,\n     ) where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -173,7 +170,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         cx.tcx().for_each_free_region(&value, |live_region| {\n             cx.constraints\n                 .liveness_set\n-                .push((live_region, location, cause.clone()));\n+                .push((live_region, location));\n         });\n     }\n \n@@ -210,9 +207,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n-        let cause = Cause::DropVar(dropped_local, location);\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::push_type_live_constraint(&mut self.cx, kind, location, cause);\n+            Self::push_type_live_constraint(&mut self.cx, kind, location);\n         }\n     }\n "}, {"sha": "d5cf55c0f773711763f8ae242934fba8b922f161", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -14,7 +14,6 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraint_set::ConstraintSet;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n@@ -615,7 +614,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n+    crate liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n \n     crate outlives_constraints: ConstraintSet,\n \n@@ -986,7 +985,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.constraints.liveness_set.push((\n                         late_bound_region,\n                         term_location,\n-                        Cause::LiveOther(term_location),\n                     ));\n                 }\n "}, {"sha": "015538b16f971e4d94d9dc87df35a81aa7894b46", "filename": "src/test/ui/generator/borrowing.nll.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -2,15 +2,10 @@ error[E0597]: `a` does not live long enough\n   --> $DIR/borrowing.rs:18:18\n    |\n LL |         unsafe { (|| yield &a).resume() }\n-   |                  ^^^^^^^^^^^^^\n-   |                  |\n-   |                  borrowed value does not live long enough\n-   |                  borrow may end up in a temporary, created here\n+   |                  ^^^^^^^^^^^^^ borrowed value does not live long enough\n LL |         //~^ ERROR: `a` does not live long enough\n LL |     };\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error[E0597]: `a` does not live long enough\n   --> $DIR/borrowing.rs:24:9"}, {"sha": "08839c23c37622261aa1cb76e3a157e323af6534", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.nll.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -1,19 +1,11 @@\n error[E0597]: `b` does not live long enough\n   --> $DIR/ref-escapes-but-not-over-yield.rs:24:13\n    |\n-LL |       let mut b = move || {\n-   |  _________________-\n-LL | |         yield();\n-LL | |         let b = 5;\n-LL | |         a = &b;\n-   | |             ^^ borrowed value does not live long enough\n-LL | |         //~^ ERROR `b` does not live long enough\n-LL | |     };\n-   | |     -\n-   | |     |\n-   | |     borrowed value only lives until here\n-   | |_____temporary later dropped here, potentially using the reference\n-   |       borrow may end up in a temporary, created here\n+LL |         a = &b;\n+   |             ^^ borrowed value does not live long enough\n+LL |         //~^ ERROR `b` does not live long enough\n+LL |     };\n+   |     - borrowed value only lives until here\n \n error: aborting due to previous error\n "}, {"sha": "4bdce85d18b5feff02dbd3340dd7a1ef64f9e79b", "filename": "src/test/ui/issue-47646.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fissue-47646.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fissue-47646.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47646.stderr?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -3,15 +3,9 @@ error[E0502]: cannot borrow `heap` as immutable because it is also borrowed as m\n    |\n LL |     let borrow = heap.peek_mut();\n    |                  ---- mutable borrow occurs here\n-LL | \n-LL |     match (borrow, ()) {\n-   |           ------------ borrow may end up in a temporary, created here\n-LL |         (Some(_), ()) => {\n+...\n LL |             println!(\"{:?}\", heap); //~ ERROR cannot borrow `heap` as immutable\n    |                              ^^^^ immutable borrow occurs here\n-...\n-LL |     };\n-   |      - temporary later dropped here, potentially using the reference\n \n error: aborting due to previous error\n "}, {"sha": "8be4cf445da3f77c2261843cd1c3b8a39c445176", "filename": "src/test/ui/span/destructor-restrictions.nll.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -2,14 +2,9 @@ error[E0597]: `*a` does not live long enough\n   --> $DIR/destructor-restrictions.rs:18:10\n    |\n LL |         *a.borrow() + 1\n-   |          ^---------\n-   |          |\n-   |          borrowed value does not live long enough\n-   |          borrow may end up in a temporary, created here\n+   |          ^ borrowed value does not live long enough\n LL |     }; //~^ ERROR `*a` does not live long enough\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error: aborting due to previous error\n "}, {"sha": "ec2f5a25631c4aedb4748dbde77c01a39c9e5190", "filename": "src/test/ui/span/issue-23338-locals-die-before-temps-of-body.nll.stderr", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0957ede5027c0bffe208904998675a17bfd4cd59/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr?ref=0957ede5027c0bffe208904998675a17bfd4cd59", "patch": "@@ -2,28 +2,17 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:20:5\n    |\n LL |     y.borrow().clone()\n-   |     ^---------\n-   |     |\n-   |     borrowed value does not live long enough\n-   |     borrow may end up in a temporary, created here\n+   |     ^ borrowed value does not live long enough\n LL | }\n-   | -\n-   | |\n-   | borrowed value only lives until here\n-   | temporary later dropped here, potentially using the reference\n+   | - borrowed value only lives until here\n \n error[E0597]: `y` does not live long enough\n   --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:27:9\n    |\n LL |         y.borrow().clone()\n-   |         ^---------\n-   |         |\n-   |         borrowed value does not live long enough\n-   |         borrow may end up in a temporary, created here\n+   |         ^ borrowed value does not live long enough\n LL |     };\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error: aborting due to 2 previous errors\n "}]}