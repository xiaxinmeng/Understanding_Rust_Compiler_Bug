{"sha": "3659406c513062c265f8d8631fa8dae2702bbe8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTk0MDZjNTEzMDYyYzI2NWY4ZDg2MzFmYThkYWUyNzAyYmJlOGQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-06-17T22:13:05Z"}, "committer": {"name": "Aman Arora", "email": "aman23091998@gmail.com", "date": "2020-06-18T22:59:38Z"}, "message": "Refactor hir::Place\n\nFor the following code\n```rust\nlet c = || bar(foo.x, foo.x)\n```\n\nWe generate two different `hir::Place`s for both `foo.x`.\nHandling this adds overhead for analysis we need to do for RFC 2229.\n\nWe also want to store type information at each Projection to support\nanalysis as part of the RFC. This resembles what we have for\n`mir::Place`\n\nThis commit modifies the Place as follows:\n- Rename to `PlaceWithHirId`, where there `hir_id` is that of the\nexpressioin.\n- Move any other information that describes the access out to another\nstruct now called `Place`.\n- Removed `Span`, it can be accessed using the [hir\nAPI](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.span)\n- Modify `Projection` to be a strucutre of its own, that currently only\ncontains the `ProjectionKind`.\n\nAdding type information to projections wil be completed as part of https://github.com/rust-lang/project-rfc-2229/issues/5\n\nCloses https://github.com/rust-lang/project-rfc-2229/issues/3\n\nCo-authored-by: Aman Arora <me@aman-arora.com>\nCo-authored-by: Roxane Fruytier <roxane.fruytier@hotmail.com>", "tree": {"sha": "f4be058b6d1f523ab73cc94dc1a080b607a524d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4be058b6d1f523ab73cc94dc1a080b607a524d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3659406c513062c265f8d8631fa8dae2702bbe8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3659406c513062c265f8d8631fa8dae2702bbe8d", "html_url": "https://github.com/rust-lang/rust/commit/3659406c513062c265f8d8631fa8dae2702bbe8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3659406c513062c265f8d8631fa8dae2702bbe8d/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e55d3f9c5213fe1a25366450127bdff67ad1eca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e55d3f9c5213fe1a25366450127bdff67ad1eca2", "html_url": "https://github.com/rust-lang/rust/commit/e55d3f9c5213fe1a25366450127bdff67ad1eca2"}], "stats": {"total": 417, "additions": 222, "deletions": 195}, "files": [{"sha": "d3bccaaa3e4b98e3f8977c6b1964f995140cfd5c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -439,7 +439,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n+    fn constrain_adjustments(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -480,12 +483,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n         &mut self,\n-        place: &mc::Place<'tcx>,\n+        place_with_id: &mc::PlaceWithHirId<'tcx>,\n         span: Span,\n     ) {\n-        if let mc::PlaceBase::Rvalue = place.base {\n-            if place.projections.is_empty() {\n-                let typ = self.resolve_type(place.ty);\n+        if let mc::PlaceBase::Rvalue = place_with_id.place.base {\n+            if place_with_id.place.projections.is_empty() {\n+                let typ = self.resolve_type(place_with_id.place.ty);\n                 let body_id = self.body_id;\n                 let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n             }\n@@ -570,7 +573,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat<'_>) {\n+    fn link_pattern(&self, discr_cmt: mc::PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -591,7 +594,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr<'_>,\n-        expr_cmt: &mc::Place<'tcx>,\n+        expr_cmt: &mc::PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n@@ -612,7 +615,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::Place<'tcx>,\n+        cmt_borrowed: &mc::PlaceWithHirId<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -635,12 +638,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_place: &mc::Place<'tcx>,\n+        borrow_place: &mc::PlaceWithHirId<'tcx>,\n     ) {\n-        let origin = infer::DataBorrowed(borrow_place.ty, span);\n-        self.type_must_outlive(origin, borrow_place.ty, borrow_region);\n+        let origin = infer::DataBorrowed(borrow_place.place.ty, span);\n+        self.type_must_outlive(origin, borrow_place.place.ty, borrow_region);\n \n-        for pointer_ty in borrow_place.deref_tys() {\n+        for pointer_ty in borrow_place.place.deref_tys() {\n             debug!(\n                 \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n                 borrow_region, borrow_kind, borrow_place\n@@ -656,7 +659,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n             }\n         }\n-        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.base {\n+        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n             self.link_upvar_region(span, borrow_region, upvar_id);\n         }\n     }"}, {"sha": "64b4f108f5ec4c216006a71870869f07bd6a6cf8", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -270,10 +270,13 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        place: &mc::Place<'tcx>,\n+        place_with_id: &mc::PlaceWithHirId<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(place={:?}, mode={:?})\", place, mode);\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume(place_with_id={:?}, mode={:?})\",\n+            place_with_id, mode\n+        );\n \n         // we only care about moves\n         match mode {\n@@ -284,7 +287,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n \n         let tcx = self.fcx.tcx;\n-        let upvar_id = if let PlaceBase::Upvar(upvar_id) = place.base {\n+        let upvar_id = if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             upvar_id\n         } else {\n             return;\n@@ -296,22 +299,22 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         self.adjust_closure_kind(\n             upvar_id.closure_expr_id,\n             ty::ClosureKind::FnOnce,\n-            place.span,\n+            tcx.hir().span(place_with_id.hir_id),\n             var_name(tcx, upvar_id.var_path.hir_id),\n         );\n \n         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n     }\n \n-    /// Indicates that `place` is being directly mutated (e.g., assigned\n+    /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, place: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(place={:?})\", place);\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(place_with_id={:?})\", place_with_id);\n \n-        if let PlaceBase::Upvar(upvar_id) = place.base {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             let mut borrow_kind = ty::MutBorrow;\n-            for pointer_ty in place.deref_tys() {\n+            for pointer_ty in place_with_id.place.deref_tys() {\n                 match pointer_ty.kind {\n                     // Raw pointers don't inherit mutability.\n                     ty::RawPtr(_) => return,\n@@ -323,20 +326,28 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     _ => (),\n                 }\n             }\n-            self.adjust_upvar_deref(upvar_id, place.span, borrow_kind);\n+            self.adjust_upvar_deref(\n+                upvar_id,\n+                self.fcx.tcx.hir().span(place_with_id.hir_id),\n+                borrow_kind,\n+            );\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, place: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(place={:?})\", place);\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(place_with_id={:?})\", place_with_id);\n \n-        if let PlaceBase::Upvar(upvar_id) = place.base {\n-            if place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n                 // Raw pointers don't inherit mutability.\n                 return;\n             }\n             // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(upvar_id, place.span, ty::UniqueImmBorrow);\n+            self.adjust_upvar_deref(\n+                upvar_id,\n+                self.fcx.tcx.hir().span(place_with_id.hir_id),\n+                ty::UniqueImmBorrow,\n+            );\n         }\n     }\n \n@@ -453,26 +464,26 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, place: &mc::Place<'tcx>, mode: euv::ConsumeMode) {\n-        debug!(\"consume(place={:?},mode={:?})\", place, mode);\n-        self.adjust_upvar_borrow_kind_for_consume(place, mode);\n+    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n+        debug!(\"consume(place_with_id={:?},mode={:?})\", place_with_id, mode);\n+        self.adjust_upvar_borrow_kind_for_consume(place_with_id, mode);\n     }\n \n-    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind) {\n-        debug!(\"borrow(place={:?}, bk={:?})\", place, bk);\n+    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+        debug!(\"borrow(place_with_id={:?}, bk={:?})\", place_with_id, bk);\n \n         match bk {\n             ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n-                self.adjust_upvar_borrow_kind_for_unique(place);\n+                self.adjust_upvar_borrow_kind_for_unique(place_with_id);\n             }\n             ty::MutBorrow => {\n-                self.adjust_upvar_borrow_kind_for_mut(place);\n+                self.adjust_upvar_borrow_kind_for_mut(place_with_id);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>) {\n+    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>) {\n         debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_place);"}, {"sha": "b72fae96e4ca0ac25d6d047c57c35ff140522ccd", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -5,7 +5,7 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use mc::{Place, PlaceBase, Projection};\n+pub use mc::{PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -25,13 +25,13 @@ use rustc_span::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, place: &mc::Place<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: ConsumeMode);\n \n     // The value found at `place` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n \n-    // The path at `place` is being assigned to.\n-    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>);\n+    // The path at `place_with_id` is being assigned to.\n+    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -113,11 +113,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx()\n     }\n \n-    fn delegate_consume(&mut self, place: &Place<'tcx>) {\n-        debug!(\"delegate_consume(place={:?})\", place);\n+    fn delegate_consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n+        debug!(\"delegate_consume(place_with_id={:?})\", place_with_id);\n \n-        let mode = copy_or_move(&self.mc, place);\n-        self.delegate.consume(place, mode);\n+        let mode = copy_or_move(&self.mc, place_with_id);\n+        self.delegate.consume(place_with_id, mode);\n     }\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr<'_>]) {\n@@ -129,22 +129,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(&place);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate_consume(&place_with_id);\n         self.walk_expr(expr);\n     }\n \n     fn mutate_expr(&mut self, expr: &hir::Expr<'_>) {\n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(&place);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.mutate(&place_with_id);\n         self.walk_expr(expr);\n     }\n \n     fn borrow_expr(&mut self, expr: &hir::Expr<'_>, bk: ty::BorrowKind) {\n         debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(&place, bk);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.borrow(&place_with_id, bk);\n \n         self.walk_expr(expr)\n     }\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        match with_place.ty.kind {\n+        match with_place.place.ty.kind {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n@@ -422,14 +422,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.tables.expr_adjustments(expr);\n-        let mut place = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+        let mut place_with_id = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny | adjustment::Adjust::Pointer(_) => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(&place);\n+                    self.delegate_consume(&place_with_id);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -441,14 +441,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(&place, bk);\n+                    self.delegate.borrow(&place_with_id, bk);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n-                    self.walk_autoref(expr, &place, autoref);\n+                    self.walk_autoref(expr, &place_with_id, autoref);\n                 }\n             }\n-            place = return_if_err!(self.mc.cat_expr_adjusted(expr, place, &adjustment));\n+            place_with_id =\n+                return_if_err!(self.mc.cat_expr_adjusted(expr, place_with_id, &adjustment));\n         }\n     }\n \n@@ -458,7 +459,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_autoref(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-        base_place: &mc::Place<'tcx>,\n+        base_place: &mc::PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -479,7 +480,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm<'_>) {\n+    fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -491,12 +492,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n+    fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         self.walk_pat(discr_place, pat);\n     }\n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n+    fn walk_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n@@ -569,7 +570,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         closure_hir_id: hir::HirId,\n         closure_span: Span,\n         var_id: hir::HirId,\n-    ) -> mc::McResult<mc::Place<'tcx>> {\n+    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n         // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;\n@@ -579,7 +580,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n-    place: &Place<'tcx>,\n+    place_with_id: &PlaceWithHirId<'tcx>,\n ) -> ConsumeMode {\n-    if !mc.type_is_copy_modulo_regions(place.ty, place.span) { Move } else { Copy }\n+    if !mc.type_is_copy_modulo_regions(\n+        place_with_id.place.ty,\n+        mc.tcx().hir().span(place_with_id.hir_id),\n+    ) {\n+        Move\n+    } else {\n+        Copy\n+    }\n }"}, {"sha": "d619d37be2d7b9ef201c9037d63dd7f24de4f149", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 98, "deletions": 95, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -74,22 +74,24 @@ pub enum PlaceBase {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Projection<'tcx> {\n+pub enum ProjectionKind<'tcx> {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref(Ty<'tcx>),\n     /// An index or a field\n     Other,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct Projection<'tcx> {\n+    /// Defines the type of access\n+    kind: ProjectionKind<'tcx>,\n+}\n+\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n #[derive(Clone, Debug)]\n pub struct Place<'tcx> {\n-    /// `HirId` of the expression or pattern producing this value.\n-    pub hir_id: hir::HirId,\n-    /// The `Span` of the expression or pattern producing this value.\n-    pub span: Span,\n     /// The type of the `Place`\n     pub ty: Ty<'tcx>,\n     /// The \"outermost\" place that holds this value.\n@@ -98,6 +100,32 @@ pub struct Place<'tcx> {\n     pub projections: Vec<Projection<'tcx>>,\n }\n \n+/// A `PlaceWithHirId` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug)]\n+pub struct PlaceWithHirId<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: hir::HirId,\n+\n+    /// Information about the `Place`\n+    pub place: Place<'tcx>,\n+}\n+\n+impl<'tcx> PlaceWithHirId<'tcx> {\n+    crate fn new(\n+        hir_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        base: PlaceBase,\n+        projections: Vec<Projection<'tcx>>,\n+    ) -> PlaceWithHirId<'tcx> {\n+        PlaceWithHirId {\n+            hir_id: hir_id,\n+            place: Place { ty: ty, base: base, projections: projections },\n+        }\n+    }\n+}\n+\n impl<'tcx> Place<'tcx> {\n     /// Returns an iterator of the types that have to be dereferenced to access\n     /// the `Place`.\n@@ -107,7 +135,7 @@ impl<'tcx> Place<'tcx> {\n     ///`*const u32` then `&*const u32`.\n     crate fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n         self.projections.iter().rev().filter_map(|proj| {\n-            if let Projection::Deref(deref_ty) = *proj { Some(deref_ty) } else { None }\n+            if let ProjectionKind::Deref(deref_ty) = proj.kind { Some(deref_ty) } else { None }\n         })\n     }\n }\n@@ -280,14 +308,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n             mc: &MemCategorizationContext<'a, 'tcx>,\n             expr: &hir::Expr<'_>,\n             adjustments: &[adjustment::Adjustment<'tcx>],\n-        ) -> McResult<Place<'tcx>> {\n+        ) -> McResult<PlaceWithHirId<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -302,9 +330,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     crate fn cat_expr_adjusted(\n         &self,\n         expr: &hir::Expr<'_>,\n-        previous: Place<'tcx>,\n+        previous: PlaceWithHirId<'tcx>,\n         adjustment: &adjustment::Adjustment<'tcx>,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n@@ -313,9 +341,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         previous: F,\n         adjustment: &adjustment::Adjustment<'tcx>,\n-    ) -> McResult<Place<'tcx>>\n+    ) -> McResult<PlaceWithHirId<'tcx>>\n     where\n-        F: FnOnce() -> McResult<Place<'tcx>>,\n+        F: FnOnce() -> McResult<PlaceWithHirId<'tcx>>,\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_vars_if_possible(&adjustment.target);\n@@ -342,7 +370,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -418,7 +446,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         span: Span,\n         expr_ty: Ty<'tcx>,\n         res: Res,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_res: id={:?} expr={:?} def={:?}\", hir_id, expr_ty, res);\n \n         match res {\n@@ -433,25 +461,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             )\n             | Res::SelfCtor(..) => Ok(self.cat_rvalue(hir_id, span, expr_ty)),\n \n-            Res::Def(DefKind::Static, _) => Ok(Place {\n-                hir_id,\n-                span,\n-                ty: expr_ty,\n-                base: PlaceBase::StaticItem,\n-                projections: Vec::new(),\n-            }),\n+            Res::Def(DefKind::Static, _) => {\n+                Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::StaticItem, Vec::new()))\n+            }\n \n             Res::Local(var_id) => {\n                 if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n-                    self.cat_upvar(hir_id, span, var_id)\n+                    self.cat_upvar(hir_id, var_id)\n                 } else {\n-                    Ok(Place {\n-                        hir_id,\n-                        span,\n-                        ty: expr_ty,\n-                        base: PlaceBase::Local(var_id),\n-                        projections: Vec::new(),\n-                    })\n+                    Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Local(var_id), Vec::new()))\n                 }\n             }\n \n@@ -464,12 +482,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Note: the actual upvar access contains invisible derefs of closure\n     /// environment and upvar reference as appropriate. Only regionck cares\n     /// about these dereferences, so we let it compute them as needed.\n-    fn cat_upvar(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        var_id: hir::HirId,\n-    ) -> McResult<Place<'tcx>> {\n+    fn cat_upvar(&self, hir_id: hir::HirId, var_id: hir::HirId) -> McResult<PlaceWithHirId<'tcx>> {\n         let closure_expr_def_id = self.body_owner;\n \n         let upvar_id = ty::UpvarId {\n@@ -478,41 +491,33 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         };\n         let var_ty = self.node_ty(var_id)?;\n \n-        let ret = Place {\n-            hir_id,\n-            span,\n-            ty: var_ty,\n-            base: PlaceBase::Upvar(upvar_id),\n-            projections: Vec::new(),\n-        };\n+        let ret = PlaceWithHirId::new(hir_id, var_ty, PlaceBase::Upvar(upvar_id), Vec::new());\n \n         debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n \n-    crate fn cat_rvalue(&self, hir_id: hir::HirId, span: Span, expr_ty: Ty<'tcx>) -> Place<'tcx> {\n+    crate fn cat_rvalue(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        expr_ty: Ty<'tcx>,\n+    ) -> PlaceWithHirId<'tcx> {\n         debug!(\"cat_rvalue hir_id={:?}, expr_ty={:?}, span={:?}\", hir_id, expr_ty, span);\n-        let ret =\n-            Place { hir_id, span, base: PlaceBase::Rvalue, projections: Vec::new(), ty: expr_ty };\n+        let ret = PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Rvalue, Vec::new());\n         debug!(\"cat_rvalue ret={:?}\", ret);\n         ret\n     }\n \n     crate fn cat_projection<N: HirNode>(\n         &self,\n         node: &N,\n-        base_place: Place<'tcx>,\n+        base_place: PlaceWithHirId<'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> Place<'tcx> {\n-        let mut projections = base_place.projections;\n-        projections.push(Projection::Other);\n-        let ret = Place {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            ty,\n-            base: base_place.base,\n-            projections,\n-        };\n+    ) -> PlaceWithHirId<'tcx> {\n+        let mut projections = base_place.place.projections;\n+        projections.push(Projection { kind: ProjectionKind::Other });\n+        let ret = PlaceWithHirId::new(node.hir_id(), ty, base_place.place.base, projections);\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n@@ -521,7 +526,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -540,64 +545,62 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.cat_deref(expr, base)\n     }\n \n-    fn cat_deref(&self, node: &impl HirNode, base_place: Place<'tcx>) -> McResult<Place<'tcx>> {\n+    fn cat_deref(\n+        &self,\n+        node: &impl HirNode,\n+        base_place: PlaceWithHirId<'tcx>,\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_deref: base_place={:?}\", base_place);\n \n-        let base_ty = base_place.ty;\n+        let base_ty = base_place.place.ty;\n         let deref_ty = match base_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,\n             None => {\n                 debug!(\"explicit deref of non-derefable type: {:?}\", base_ty);\n                 return Err(());\n             }\n         };\n-        let mut projections = base_place.projections;\n-        projections.push(Projection::Deref(base_ty));\n-\n-        let ret = Place {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            ty: deref_ty,\n-            base: base_place.base,\n-            projections,\n-        };\n+        let mut projections = base_place.place.projections;\n+        projections.push(Projection { kind: ProjectionKind::Deref(base_ty) });\n+\n+        let ret = PlaceWithHirId::new(node.hir_id(), deref_ty, base_place.place.base, projections);\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n     }\n \n     crate fn cat_pattern<F>(\n         &self,\n-        place: Place<'tcx>,\n+        place: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,\n         mut op: F,\n     ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n+        F: FnMut(&PlaceWithHirId<'tcx>, &hir::Pat<'_>),\n     {\n         self.cat_pattern_(place, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(\n         &self,\n-        mut place: Place<'tcx>,\n+        mut place_with_id: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,\n         op: &mut F,\n     ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n+        F: FnMut(&PlaceWithHirId<'tcx>, &hir::Pat<'_>),\n     {\n-        // Here, `place` is the `Place` being matched and pat is the pattern it\n+        // Here, `place` is the `PlaceWithHirId` being matched and pat is the pattern it\n         // is being matched against.\n         //\n         // In general, the way that this works is that we walk down the pattern,\n-        // constructing a `Place` that represents the path that will be taken\n+        // constructing a `PlaceWithHirId` that represents the path that will be taken\n         // to reach the value being matched.\n \n-        debug!(\"cat_pattern(pat={:?}, place={:?})\", pat, place);\n+        debug!(\"cat_pattern(pat={:?}, place_with_id={:?})\", pat, place_with_id);\n \n-        // If (pattern) adjustments are active for this pattern, adjust the `Place` correspondingly.\n-        // `Place`s are constructed differently from patterns. For example, in\n+        // If (pattern) adjustments are active for this pattern, adjust the `PlaceWithHirId` correspondingly.\n+        // `PlaceWithHirId`s are constructed differently from patterns. For example, in\n         //\n         // ```\n         // match foo {\n@@ -607,7 +610,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // ```\n         //\n         // the pattern `&&Some(x,)` is represented as `Ref { Ref { TupleStruct }}`. To build the\n-        // corresponding `Place` we start with the `Place` for `foo`, and then, by traversing the\n+        // corresponding `PlaceWithHirId` we start with the `PlaceWithHirId` for `foo`, and then, by traversing the\n         // pattern, try to answer the question: given the address of `foo`, how is `x` reached?\n         //\n         // `&&Some(x,)` `place_foo`\n@@ -629,29 +632,29 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `deref { deref { place_foo }}` instead of `place_foo` since the pattern is now `Some(x,)`\n         // and not `&&Some(x,)`, even though its assigned type is that of `&&Some(x,)`.\n         for _ in 0..self.tables.pat_adjustments().get(pat.hir_id).map(|v| v.len()).unwrap_or(0) {\n-            debug!(\"cat_pattern: applying adjustment to place={:?}\", place);\n-            place = self.cat_deref(pat, place)?;\n+            debug!(\"cat_pattern: applying adjustment to place_with_id={:?}\", place_with_id);\n+            place_with_id = self.cat_deref(pat, place_with_id)?;\n         }\n-        let place = place; // lose mutability\n-        debug!(\"cat_pattern: applied adjustment derefs to get place={:?}\", place);\n+        let place_with_id = place_with_id; // lose mutability\n+        debug!(\"cat_pattern: applied adjustment derefs to get place_with_id={:?}\", place_with_id);\n \n-        // Invoke the callback, but only now, after the `place` has adjusted.\n+        // Invoke the callback, but only now, after the `place_with_id` has adjusted.\n         //\n         // To see that this makes sense, consider `match &Some(3) { Some(x) => { ... }}`. In that\n-        // case, the initial `place` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n+        // case, the initial `place_with_id` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n         // don't want to call `op` with these incompatible values. As written, what happens instead\n         // is that `op` is called with the adjusted place (that for `*&Some(3)`) and the pattern\n         // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n         // result in the place `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n         // that (where the `ref` on `x` is implied).\n-        op(&place, pat);\n+        op(&place_with_id, pat);\n \n         match pat.kind {\n             PatKind::TupleStruct(_, ref subpats, _) | PatKind::Tuple(ref subpats, _) => {\n                 // S(p1, ..., pN) or (p1, ..., pN)\n                 for subpat in subpats.iter() {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n-                    let sub_place = self.cat_projection(pat, place.clone(), subpat_ty);\n+                    let sub_place = self.cat_projection(pat, place_with_id.clone(), subpat_ty);\n                     self.cat_pattern_(sub_place, &subpat, op)?;\n                 }\n             }\n@@ -660,44 +663,44 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n-                    let field_place = self.cat_projection(pat, place.clone(), field_ty);\n+                    let field_place = self.cat_projection(pat, place_with_id.clone(), field_ty);\n                     self.cat_pattern_(field_place, &fp.pat, op)?;\n                 }\n             }\n \n             PatKind::Or(pats) => {\n                 for pat in pats {\n-                    self.cat_pattern_(place.clone(), &pat, op)?;\n+                    self.cat_pattern_(place_with_id.clone(), &pat, op)?;\n                 }\n             }\n \n             PatKind::Binding(.., Some(ref subpat)) => {\n-                self.cat_pattern_(place, &subpat, op)?;\n+                self.cat_pattern_(place_with_id, &subpat, op)?;\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n                 // box p1, &p1, &mut p1.  we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n-                let subplace = self.cat_deref(pat, place)?;\n+                let subplace = self.cat_deref(pat, place_with_id)?;\n                 self.cat_pattern_(subplace, &subpat, op)?;\n             }\n \n             PatKind::Slice(before, ref slice, after) => {\n-                let element_ty = match place.ty.builtin_index() {\n+                let element_ty = match place_with_id.place.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", place);\n+                        debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n                         return Err(());\n                     }\n                 };\n-                let elt_place = self.cat_projection(pat, place.clone(), element_ty);\n+                let elt_place = self.cat_projection(pat, place_with_id.clone(), element_ty);\n                 for before_pat in before {\n                     self.cat_pattern_(elt_place.clone(), &before_pat, op)?;\n                 }\n                 if let Some(ref slice_pat) = *slice {\n                     let slice_pat_ty = self.pat_ty_adjusted(&slice_pat)?;\n-                    let slice_place = self.cat_projection(pat, place, slice_pat_ty);\n+                    let slice_place = self.cat_projection(pat, place_with_id, slice_pat_ty);\n                     self.cat_pattern_(slice_place, &slice_pat, op)?;\n                 }\n                 for after_pat in after {"}, {"sha": "59af475af175e2c484318fe1cbfb354965d3a9ea", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_target::abi::LayoutOf;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n \n use crate::utils::span_lint;\n \n@@ -112,9 +112,9 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &Place<'tcx>, mode: ConsumeMode) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn consume(&mut self, cmt: &PlaceWithHirId<'tcx>, mode: ConsumeMode) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 if let ConsumeMode::Move = mode {\n                     // moved out or in. clearly can't be localized\n                     self.set.remove(&lid);\n@@ -132,16 +132,16 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, _: ty::BorrowKind) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: ty::BorrowKind) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 self.set.remove(&lid);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if cmt.projections.is_empty() {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if cmt.place.projections.is_empty() {\n             let map = &self.cx.tcx.hir();\n             if is_argument(*map, cmt.hir_id) {\n                 // Skip closure arguments\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     return;\n                 }\n \n-                if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                if is_non_trait_box(cmt.place.ty) && !self.is_large_box(cmt.place.ty) {\n                     self.set.insert(cmt.hir_id);\n                 }\n                 return;"}, {"sha": "83093ec51bd9037dd52569934fcb72bc1576b8f3", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n use std::iter::{once, Iterator};\n use std::mem;\n \n@@ -1489,42 +1489,43 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-struct MutatePairDelegate {\n+struct MutatePairDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     hir_id_low: Option<HirId>,\n     hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n-impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+impl<'a, 'tcx> Delegate<'tcx> for MutatePairDelegate<'a, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            if let PlaceBase::Local(id) = cmt.base {\n+            if let PlaceBase::Local(id) = cmt.place.base {\n                 if Some(id) == self.hir_id_low {\n-                    self.span_low = Some(cmt.span)\n+                    self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n                 if Some(id) == self.hir_id_high {\n-                    self.span_high = Some(cmt.span)\n+                    self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if let PlaceBase::Local(id) = cmt.base {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n             if Some(id) == self.hir_id_low {\n-                self.span_low = Some(cmt.span)\n+                self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n             if Some(id) == self.hir_id_high {\n-                self.span_high = Some(cmt.span)\n+                self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n         }\n     }\n }\n \n-impl<'tcx> MutatePairDelegate {\n+impl<'a, 'tcx> MutatePairDelegate<'a, 'tcx> {\n     fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n         (self.span_low, self.span_high)\n     }\n@@ -1579,12 +1580,13 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<Hi\n     None\n }\n \n-fn check_for_mutation(\n-    cx: &LateContext<'_, '_>,\n+fn check_for_mutation<'a, 'tcx> (\n+    cx: &LateContext<'a, 'tcx>,\n     body: &Expr<'_>,\n     bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n+        cx: cx,\n         hir_id_low: bound_ids[0],\n         hir_id_high: bound_ids[1],\n         span_low: None,"}, {"sha": "ca87deac9891c905913b99430bca8859ae6cfb2a", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -326,21 +326,21 @@ struct MovedVariablesCtxt {\n }\n \n impl MovedVariablesCtxt {\n-    fn move_common(&mut self, cmt: &euv::Place<'_>) {\n-        if let euv::PlaceBase::Local(vid) = cmt.base {\n+    fn move_common(&mut self, cmt: &euv::PlaceWithHirId<'_>) {\n+        if let euv::PlaceBase::Local(vid) = cmt.place.base {\n             self.moved_vars.insert(vid);\n         }\n     }\n }\n \n impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n-    fn consume(&mut self, cmt: &euv::Place<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, cmt: &euv::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move = mode {\n             self.move_common(cmt);\n         }\n     }\n \n-    fn borrow(&mut self, _: &euv::Place<'tcx>, _: ty::BorrowKind) {}\n+    fn borrow(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: ty::BorrowKind) {}\n \n-    fn mutate(&mut self, _: &euv::Place<'tcx>) {}\n+    fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>) {}\n }"}, {"sha": "6a7a1f1ceaaef8fabe9cfa38e331e237b303db8c", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3659406c513062c265f8d8631fa8dae2702bbe8d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=3659406c513062c265f8d8631fa8dae2702bbe8d", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -46,8 +46,8 @@ struct MutVarsDelegate {\n \n impl<'tcx> MutVarsDelegate {\n     #[allow(clippy::similar_names)]\n-    fn update(&mut self, cat: &Place<'tcx>) {\n-        match cat.base {\n+    fn update(&mut self, cat: &PlaceWithHirId<'tcx>) {\n+        match cat.place.base {\n             PlaceBase::Local(id) => {\n                 self.used_mutably.insert(id);\n             },\n@@ -63,15 +63,15 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt)\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n         self.update(&cmt)\n     }\n }"}]}