{"sha": "ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "node_id": "C_kwDOAAsO6NoAKGVjNDY5OTIwMDhjMGZkOTNhYjBmM2FlZjg0MzhkZDI0ZWNhMjhhOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T16:51:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T16:51:01Z"}, "message": "Auto merge of #8720 - asquared31415:ptr-cast-ice-fix, r=Alexendoo,xFrednet\n\nfix ICE in `cast_slice_different_sizes`\n\nfixes #8708\n\nchangelog: fixes an ICE introduced in #8445", "tree": {"sha": "f14f7cb803d3f8c8f68dde009e4a429bf0275921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f14f7cb803d3f8c8f68dde009e4a429bf0275921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "html_url": "https://github.com/rust-lang/rust/commit/ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80cd4da01a2ac10a7972fb58316413f9acd1ab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80cd4da01a2ac10a7972fb58316413f9acd1ab8", "html_url": "https://github.com/rust-lang/rust/commit/c80cd4da01a2ac10a7972fb58316413f9acd1ab8"}, {"sha": "8f8fc9f71752e8df80152a402b992bdd819be7f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8fc9f71752e8df80152a402b992bdd819be7f3", "html_url": "https://github.com/rust-lang/rust/commit/8f8fc9f71752e8df80152a402b992bdd819be7f3"}], "stats": {"total": 224, "additions": 180, "deletions": 44}, "files": [{"sha": "2238668abca71d464e9f8f0be73600d1b95140a2", "filename": "clippy_lints/src/casts/cast_slice_different_sizes.rs", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs?ref=ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source::snippet_opt};\n+use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source};\n use if_chain::if_chain;\n use rustc_ast::Mutability;\n use rustc_hir::{Expr, ExprKind, Node};\n@@ -8,32 +8,7 @@ use rustc_semver::RustcVersion;\n \n use super::CAST_SLICE_DIFFERENT_SIZES;\n \n-fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    if_chain! {\n-        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n-        if let Some(parent) = map.find(parent_id);\n-        then {\n-            let expr = match parent {\n-                Node::Block(block) => {\n-                    if let Some(parent_expr) = block.expr {\n-                        parent_expr\n-                    } else {\n-                        return false;\n-                    }\n-                },\n-                Node::Expr(expr) => expr,\n-                _ => return false,\n-            };\n-\n-            matches!(expr.kind, ExprKind::Cast(..))\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVersion>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, msrv: &Option<RustcVersion>) {\n     // suggestion is invalid if `ptr::slice_from_raw_parts` does not exist\n     if !meets_msrv(msrv.as_ref(), &msrvs::PTR_SLICE_RAW_PARTS) {\n         return;\n@@ -45,8 +20,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n         return;\n     }\n \n-    if let Some((from_slice_ty, to_slice_ty)) = expr_cast_chain_tys(cx, expr) {\n-        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(from_slice_ty.ty), cx.layout_of(to_slice_ty.ty)) {\n+    if let Some(CastChainInfo {\n+        left_cast,\n+        start_ty,\n+        end_ty,\n+    }) = expr_cast_chain_tys(cx, expr)\n+    {\n+        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(start_ty.ty), cx.layout_of(end_ty.ty)) {\n             let from_size = from_layout.size.bytes();\n             let to_size = to_layout.size.bytes();\n             if from_size != to_size && from_size != 0 && to_size != 0 {\n@@ -56,21 +36,20 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n                     expr.span,\n                     &format!(\n                         \"casting between raw pointers to `[{}]` (element size {}) and `[{}]` (element size {}) does not adjust the count\",\n-                        from_slice_ty, from_size, to_slice_ty, to_size,\n+                        start_ty.ty, from_size, end_ty.ty, to_size,\n                     ),\n                     |diag| {\n-                        let cast_expr = match expr.kind {\n-                            ExprKind::Cast(cast_expr, ..) => cast_expr,\n-                            _ => unreachable!(\"expr should be a cast as checked by expr_cast_chain_tys\"),\n-                        };\n-                        let ptr_snippet = snippet_opt(cx, cast_expr.span).unwrap();\n+                        let ptr_snippet = source::snippet(cx, left_cast.span, \"..\");\n \n-                        let (mutbl_fn_str, mutbl_ptr_str) = match to_slice_ty.mutbl {\n+                        let (mutbl_fn_str, mutbl_ptr_str) = match end_ty.mutbl {\n                             Mutability::Mut => (\"_mut\", \"mut\"),\n                             Mutability::Not => (\"\", \"const\"),\n                         };\n                         let sugg = format!(\n-                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {to_slice_ty}, ..)\"\n+                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {}, ..)\",\n+                            // get just the ty from the TypeAndMut so that the printed type isn't something like `mut\n+                            // T`, extract just the `T`\n+                            end_ty.ty\n                         );\n \n                         diag.span_suggestion(\n@@ -86,6 +65,31 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n     }\n }\n \n+fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    if_chain! {\n+        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n+        if let Some(parent) = map.find(parent_id);\n+        then {\n+            let expr = match parent {\n+                Node::Block(block) => {\n+                    if let Some(parent_expr) = block.expr {\n+                        parent_expr\n+                    } else {\n+                        return false;\n+                    }\n+                },\n+                Node::Expr(expr) => expr,\n+                _ => return false,\n+            };\n+\n+            matches!(expr.kind, ExprKind::Cast(..))\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n /// Returns the type T of the pointed to *const [T] or *mut [T] and the mutability of the slice if\n /// the type is one of those slices\n fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n@@ -98,18 +102,40 @@ fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n     }\n }\n \n-/// Returns the pair (original ptr T, final ptr U) if the expression is composed of casts\n+struct CastChainInfo<'tcx> {\n+    /// The left most part of the cast chain, or in other words, the first cast in the chain\n+    /// Used for diagnostics\n+    left_cast: &'tcx Expr<'tcx>,\n+    /// The starting type of the cast chain\n+    start_ty: TypeAndMut<'tcx>,\n+    /// The final type of the cast chain\n+    end_ty: TypeAndMut<'tcx>,\n+}\n+\n+/// Returns a `CastChainInfo` with the left-most cast in the chain and the original ptr T and final\n+/// ptr U if the expression is composed of casts.\n /// Returns None if the expr is not a Cast\n-fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<(TypeAndMut<'tcx>, TypeAndMut<'tcx>)> {\n+fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<CastChainInfo<'tcx>> {\n     if let ExprKind::Cast(cast_expr, _cast_to_hir_ty) = expr.peel_blocks().kind {\n         let cast_to = cx.typeck_results().expr_ty(expr);\n         let to_slice_ty = get_raw_slice_ty_mut(cast_to)?;\n-        if let Some((inner_from_ty, _inner_to_ty)) = expr_cast_chain_tys(cx, cast_expr) {\n-            Some((inner_from_ty, to_slice_ty))\n+\n+        // If the expression that makes up the source of this cast is itself a cast, recursively\n+        // call `expr_cast_chain_tys` and update the end type with the final tartet type.\n+        // Otherwise, this cast is not immediately nested, just construct the info for this cast\n+        if let Some(prev_info) = expr_cast_chain_tys(cx, cast_expr) {\n+            Some(CastChainInfo {\n+                end_ty: to_slice_ty,\n+                ..prev_info\n+            })\n         } else {\n             let cast_from = cx.typeck_results().expr_ty(cast_expr);\n             let from_slice_ty = get_raw_slice_ty_mut(cast_from)?;\n-            Some((from_slice_ty, to_slice_ty))\n+            Some(CastChainInfo {\n+                left_cast: cast_expr,\n+                start_ty: from_slice_ty,\n+                end_ty: to_slice_ty,\n+            })\n         }\n     } else {\n         None"}, {"sha": "24d7eb28a197aa03b75fd663cbeda11339ee8c4a", "filename": "tests/ui/cast_slice_different_sizes.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/tests%2Fui%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/tests%2Fui%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.rs?ref=ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "patch": "@@ -39,3 +39,44 @@ fn main() {\n     let long_chain_restore =\n         r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8] as *const [u32];\n }\n+\n+// foo and foo2 should not fire, they're the same size\n+fn foo(x: *mut [u8]) -> *mut [u8] {\n+    x as *mut [u8]\n+}\n+\n+fn foo2(x: *mut [u8]) -> *mut [u8] {\n+    x as *mut _\n+}\n+\n+// Test that casts as part of function returns work\n+fn bar(x: *mut [u16]) -> *mut [u8] {\n+    x as *mut [u8]\n+}\n+\n+fn uwu(x: *mut [u16]) -> *mut [u8] {\n+    x as *mut _\n+}\n+\n+fn bar2(x: *mut [u16]) -> *mut [u8] {\n+    x as _\n+}\n+\n+// constify\n+fn bar3(x: *mut [u16]) -> *const [u8] {\n+    x as _\n+}\n+\n+// unconstify\n+fn bar4(x: *const [u16]) -> *mut [u8] {\n+    x as _\n+}\n+\n+// function returns plus blocks\n+fn blocks(x: *mut [u16]) -> *mut [u8] {\n+    ({ x }) as _\n+}\n+\n+fn more_blocks(x: *mut [u16]) -> *mut [u8] {\n+    { ({ x }) as _ }\n+}"}, {"sha": "40721dcd05d5dbc909d140a82d70de3bfb28ddc7", "filename": "tests/ui/cast_slice_different_sizes.stderr", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/tests%2Fui%2Fcast_slice_different_sizes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec46992008c0fd93ab0f3aef8438dd24eca28a9d/tests%2Fui%2Fcast_slice_different_sizes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.stderr?ref=ec46992008c0fd93ab0f3aef8438dd24eca28a9d", "patch": "@@ -46,7 +46,76 @@ error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (elem\n   --> $DIR/cast_slice_different_sizes.rs:38:27\n    |\n LL |     let long_chain_loss = r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8];\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const u8, ..)`\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const u8, ..)`\n \n-error: aborting due to 6 previous errors\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:53:36\n+   |\n+LL |   fn bar(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________^\n+LL | |     x as *mut [u8]\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:57:36\n+   |\n+LL |   fn uwu(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________^\n+LL | |     x as *mut _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:61:37\n+   |\n+LL |   fn bar2(x: *mut [u16]) -> *mut [u8] {\n+   |  _____________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:66:39\n+   |\n+LL |   fn bar3(x: *mut [u16]) -> *const [u8] {\n+   |  _______________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(x as *const u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:71:39\n+   |\n+LL |   fn bar4(x: *const [u16]) -> *mut [u8] {\n+   |  _______________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:76:39\n+   |\n+LL |   fn blocks(x: *mut [u16]) -> *mut [u8] {\n+   |  _______________________________________^\n+LL | |     ({ x }) as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:80:44\n+   |\n+LL |   fn more_blocks(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________________^\n+LL | |     { ({ x }) as _ }\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:81:5\n+   |\n+LL |     { ({ x }) as _ }\n+   |     ^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: aborting due to 14 previous errors\n "}]}