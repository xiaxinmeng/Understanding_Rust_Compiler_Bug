{"sha": "31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZGU4ZTE1YzBmOTU3NWMyMzZmYzg3ZmJiZjAyYmQwOGUzYjg4NDI=", "commit": {"author": {"name": "Kelly Wilson", "email": "wilsonk@cpsc.ucalgary.ca", "date": "2011-05-24T17:12:32Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-24T22:38:41Z"}, "message": "Add quick_sort3 function based on 'QuicksortIsOptimal.pdf' (see comments in file). Cleanup the quick_sort function a little, as well. Add test file.", "tree": {"sha": "b50aa76594382b5ae1686a4d6d6cda9b1a821325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b50aa76594382b5ae1686a4d6d6cda9b1a821325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "html_url": "https://github.com/rust-lang/rust/commit/31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31de8e15c0f9575c236fc87fbbf02bd08e3b8842/comments", "author": {"login": "wilsonk", "id": 38802, "node_id": "MDQ6VXNlcjM4ODAy", "avatar_url": "https://avatars.githubusercontent.com/u/38802?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wilsonk", "html_url": "https://github.com/wilsonk", "followers_url": "https://api.github.com/users/wilsonk/followers", "following_url": "https://api.github.com/users/wilsonk/following{/other_user}", "gists_url": "https://api.github.com/users/wilsonk/gists{/gist_id}", "starred_url": "https://api.github.com/users/wilsonk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wilsonk/subscriptions", "organizations_url": "https://api.github.com/users/wilsonk/orgs", "repos_url": "https://api.github.com/users/wilsonk/repos", "events_url": "https://api.github.com/users/wilsonk/events{/privacy}", "received_events_url": "https://api.github.com/users/wilsonk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac836dd79c2d7c631ca601dc468de13cb5c785da", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac836dd79c2d7c631ca601dc468de13cb5c785da", "html_url": "https://github.com/rust-lang/rust/commit/ac836dd79c2d7c631ca601dc468de13cb5c785da"}], "stats": {"total": 155, "additions": 148, "deletions": 7}, "files": [{"sha": "ede8d229fa599220ea3eca1af25e83d1e5e50582", "filename": "src/lib/sort.rs", "status": "modified", "additions": 82, "deletions": 7, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/31de8e15c0f9575c236fc87fbbf02bd08e3b8842/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31de8e15c0f9575c236fc87fbbf02bd08e3b8842/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "patch": "@@ -4,6 +4,7 @@ import vec::slice;\n export lteq;\n export merge_sort;\n export quick_sort;\n+export quick_sort3;\n \n type lteq[T] = fn(&T a, &T b) -> bool;\n \n@@ -52,18 +53,12 @@ fn swap[T](vec[mutable T] arr, uint x, uint y) {\n fn part[T](lteq[T] compare_func, vec[mutable T] arr, uint left,\n         uint right, uint pivot) -> uint {\n \n-    fn compare[T](lteq[T] compare_func, vec[mutable T]arr,\n-           uint arr_idx, &T arr_value) -> bool {\n-\n-        ret compare_func(arr.(arr_idx),arr_value);\n-    }\n-\n     auto pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n     let uint storage_index = left;\n     let uint i = left;\n     while (i<right) {\n-        if (compare[T](compare_func, arr, i, pivot_value)) {\n+        if (compare_func(arr.(i), pivot_value)) {\n            swap[T](arr, i, storage_index);\n            storage_index += 1u;\n         }\n@@ -95,6 +90,86 @@ fn quick_sort[T](lteq[T] compare_func, vec[mutable T] arr) {\n     qsort[T](compare_func, arr, 0u, (len[T](arr)) - 1u);\n }\n \n+\n+// Based on algorithm presented by Sedgewick and Bentley here:\n+// http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n+// According to these slides this is the algorithm of choice for\n+// 'randomly ordered keys, abstract compare' & 'small number of key values'\n+\n+fn qsort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n+        vec[mutable T] arr, int left, int right) {\n+\n+    if (right <= left) {\n+        ret;\n+    }\n+\n+    let T v = arr.(right);\n+    let int i = left - 1;\n+    let int j = right;\n+    let int p = i;\n+    let int q = j;\n+\n+    while (true) {\n+        i += 1;\n+        while (compare_func_lt(arr.(i), v)) {\n+            i += 1;\n+        }\n+        j -= 1;\n+        while (compare_func_lt(v, arr.(j))) {\n+            if (j == left) {\n+                break;\n+            }\n+            j -= 1;\n+        }\n+        if (i >= j) {\n+            break;\n+        }\n+        swap[T](arr, i as uint, j as uint);\n+        if (compare_func_eq(arr.(i), v)) {\n+            p += 1;\n+            swap[T](arr, p as uint, i as uint);\n+        }\n+        if (compare_func_eq(v, arr.(j))) {\n+            q -= 1;\n+            swap[T](arr, j as uint, q as uint);\n+        }\n+   }\n+    swap[T](arr, i as uint, right as uint);\n+    j = i - 1;\n+    i += 1;\n+\n+    let int k = left;\n+    while (k < p) {\n+        swap[T](arr, k as uint, j as uint);\n+        k += 1;\n+        j -= 1;\n+        if (k == vec::len[T](arr) as int) {\n+            break;\n+        }\n+    }\n+    k = right - 1;\n+    while (k > q) {\n+        swap[T](arr, i as uint, k as uint);\n+        k -= 1;\n+        i += 1;\n+        if (k == 0) {\n+            break;\n+        }\n+    }\n+\n+    qsort3[T](compare_func_lt, compare_func_eq, arr, left, j);\n+    qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n+}\n+\n+fn quick_sort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n+        vec[mutable T] arr) {\n+    if (vec::len[T](arr) == 0u) {\n+        ret;\n+    }\n+    qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n+              (vec::len[T](arr) as int) - 1);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "f91a2cb8cadcb6acaeef0caff98301c099d4401d", "filename": "src/test/run-pass/lib-qsort3.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/31de8e15c0f9575c236fc87fbbf02bd08e3b8842/src%2Ftest%2Frun-pass%2Flib-qsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31de8e15c0f9575c236fc87fbbf02bd08e3b8842/src%2Ftest%2Frun-pass%2Flib-qsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort3.rs?ref=31de8e15c0f9575c236fc87fbbf02bd08e3b8842", "patch": "@@ -0,0 +1,66 @@\n+use std;\n+\n+fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n+  auto len = std::vec::len[int](v1);\n+\n+  fn lt(&int a, &int b) -> bool {\n+    ret a < b;\n+  }\n+  fn equal(&int a, &int b) -> bool {\n+    ret a == b;\n+  }\n+  auto f1 = lt;\n+  auto f2 = equal;\n+  std::sort::quick_sort3[int](f1, f2, v1);\n+  auto i = 0u;\n+  while (i < len) {\n+    log v2.(i);\n+    assert (v2.(i) == v1.(i));\n+    i += 1u;\n+  }\n+}\n+\n+\n+fn main() {\n+  {\n+    auto v1 = [mutable 3,7,4,5,2,9,5,8];\n+    auto v2 = [mutable 2,3,4,5,5,7,8,9];\n+    check_sort(v1, v2);\n+  }\n+\n+  {\n+    auto v1 = [mutable 1,1,1];\n+    auto v2 = [mutable 1,1,1];\n+    check_sort(v1, v2);\n+  }\n+\n+  {\n+    let vec[mutable int] v1 = [mutable];\n+    let vec[mutable int] v2 = [mutable];\n+    check_sort(v1, v2);\n+  }\n+\n+  {\n+    auto v1 = [mutable 9];\n+    auto v2 = [mutable 9];\n+    check_sort(v1, v2);\n+  }\n+\n+  {\n+    auto v1 = [mutable 9,3,3,3,9];\n+    auto v2 = [mutable 3,3,3,9,9];\n+    check_sort(v1, v2);\n+  }\n+\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+\n+"}]}