{"sha": "1fbca8824a6b6018191b7ee998d2c97f30c481d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYmNhODgyNGE2YjYwMTgxOTFiN2VlOTk4ZDJjOTdmMzBjNDgxZDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-14T18:34:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-14T19:24:49Z"}, "message": "std: Fully stabilize Option<T>\n\nThis commit takes a second pass through the `std::option` module to fully\nstabilize any lingering methods inside of it.\n\nThese items were made stable as-is\n\n* Some\n* None\n* as_mut\n* expect\n* unwrap\n* unwrap_or\n* unwrap_or_else\n* map\n* map_or\n* map_or_else\n* and_then\n* or_else\n* unwrap_or_default\n* Default implementation\n* FromIterator implementation\n* Copy implementation\n\nThese items were made stable with modifications\n\n* iter - now returns a struct called Iter\n* iter_mut - now returns a struct called IterMut\n* into_iter - now returns a struct called IntoIter, Clone is never implemented\n\nThis is a breaking change due to the modifications to the names of the iterator\ntypes returned. Code referencing the old names should updated to referencing the\nnewer names instead. This is also a breaking change due to the fact that\n`IntoIter` no longer implements the `Clone` trait.\n\nThese items were explicitly not stabilized\n\n* as_slice - waiting on indexing conventions\n* as_mut_slice - waiting on conventions with as_slice as well\n* cloned - the API was still just recently added\n* ok_or - API remains experimental\n* ok_or_else - API remains experimental\n\n[breaking-change]", "tree": {"sha": "50d241ae939dda14ee2a0eaf07c3d6c46b302924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50d241ae939dda14ee2a0eaf07c3d6c46b302924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fbca8824a6b6018191b7ee998d2c97f30c481d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fbca8824a6b6018191b7ee998d2c97f30c481d7", "html_url": "https://github.com/rust-lang/rust/commit/1fbca8824a6b6018191b7ee998d2c97f30c481d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fbca8824a6b6018191b7ee998d2c97f30c481d7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444fa1b7cffcd99ca5b8abb51acf979f06a25899", "url": "https://api.github.com/repos/rust-lang/rust/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "html_url": "https://github.com/rust-lang/rust/commit/444fa1b7cffcd99ca5b8abb51acf979f06a25899"}], "stats": {"total": 125, "additions": 93, "deletions": 32}, "files": [{"sha": "58d71e0ed0889d4681a00918f836eb65ca0dc020", "filename": "src/libcore/option.rs", "status": "modified", "additions": 87, "deletions": 26, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=1fbca8824a6b6018191b7ee998d2c97f30c481d7", "patch": "@@ -168,8 +168,10 @@ use ops::{Deref, FnOnce};\n #[stable]\n pub enum Option<T> {\n     /// No value\n+    #[stable]\n     None,\n     /// Some value `T`\n+    #[stable]\n     Some(T)\n }\n \n@@ -261,7 +263,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42u));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[stable]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -321,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -353,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -370,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -388,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -412,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -432,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -454,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -520,9 +522,9 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n-        Item{opt: self.as_ref()}\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { inner: Item { opt: self.as_ref() } }\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n@@ -542,8 +544,8 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n-        Item{opt: self.as_mut()}\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        IterMut { inner: Item { opt: self.as_mut() } }\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n@@ -560,9 +562,9 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn into_iter(self) -> Item<T> {\n-        Item{opt: self}\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { inner: Item { opt: self } }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -614,7 +616,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -666,7 +668,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -731,7 +733,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -744,6 +746,7 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[unstable = \"waiting on the stability of the trait itself\"]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n@@ -761,20 +764,16 @@ impl<T> AsSlice<T> for Option<T> {\n #[stable]\n impl<T> Default for Option<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> Option<T> { None }\n }\n \n /////////////////////////////////////////////////////////////////////////////\n-// The Option Iterator\n+// The Option Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-/// An `Option` iterator that yields either one or zero elements\n-///\n-/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n-/// methods on `Option`.\n #[deriving(Clone)]\n-#[unstable = \"waiting for iterator conventions\"]\n-pub struct Item<A> {\n+struct Item<A> {\n     opt: Option<A>\n }\n \n@@ -802,6 +801,66 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n \n impl<A> ExactSizeIterator<A> for Item<A> {}\n \n+/// An iterator over a reference of the contained item in an Option.\n+#[stable]\n+pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n+\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n+}\n+\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n+\n+impl<'a, A> Clone for Iter<'a, A> {\n+    fn clone(&self) -> Iter<'a, A> {\n+        Iter { inner: self.inner.clone() }\n+    }\n+}\n+\n+/// An iterator over a mutable reference of the contained item in an Option.\n+#[stable]\n+pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n+\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n+}\n+\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n+\n+/// An iterator over the item contained inside an Option.\n+#[stable]\n+pub struct IntoIter<A> { inner: Item<A> }\n+\n+impl<A> Iterator<A> for IntoIter<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n+}\n+\n+impl<A> ExactSizeIterator<A> for IntoIter<A> {}\n+\n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n@@ -826,6 +885,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n+    #[stable]\n     fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n@@ -860,5 +920,6 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     }\n }\n \n+#[stable]\n impl<T:Copy> Copy for Option<T> {}\n "}, {"sha": "9381c97d49dca757ff0d2858304c9ad55f017a1e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1fbca8824a6b6018191b7ee998d2c97f30c481d7", "patch": "@@ -364,12 +364,12 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n-                                               mut path: PI) {\n+fn encode_path<PI: Iterator<PathElem>>(rbml_w: &mut Encoder, path: PI) {\n+    let path = path.collect::<Vec<_>>();\n     rbml_w.start_tag(tag_path);\n-    rbml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n-    for pe in path {\n-        let tag = match pe {\n+    rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);\n+    for pe in path.iter() {\n+        let tag = match *pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };"}, {"sha": "57004d71c75e46065f7c43769662b3e1909f3817", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbca8824a6b6018191b7ee998d2c97f30c481d7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1fbca8824a6b6018191b7ee998d2c97f30c481d7", "patch": "@@ -325,7 +325,7 @@ impl FromStr for UserIdentifiedItem {\n }\n \n enum NodesMatchingUII<'a, 'ast: 'a> {\n-    NodesMatchingDirect(option::Item<ast::NodeId>),\n+    NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n     NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n }\n "}]}