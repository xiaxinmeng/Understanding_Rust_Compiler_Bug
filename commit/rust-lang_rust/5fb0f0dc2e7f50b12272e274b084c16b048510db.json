{"sha": "5fb0f0dc2e7f50b12272e274b084c16b048510db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYjBmMGRjMmU3ZjUwYjEyMjcyZTI3NGIwODRjMTZiMDQ4NTEwZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-23T08:19:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-01T17:31:09Z"}, "message": "strip param-env from infcx", "tree": {"sha": "8a4a9f892f255cc792274108bea372504a16c2e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a4a9f892f255cc792274108bea372504a16c2e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fb0f0dc2e7f50b12272e274b084c16b048510db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb0f0dc2e7f50b12272e274b084c16b048510db", "html_url": "https://github.com/rust-lang/rust/commit/5fb0f0dc2e7f50b12272e274b084c16b048510db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fb0f0dc2e7f50b12272e274b084c16b048510db/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "541523d10dce98dc266f6d4e6fb6131182c0f791", "url": "https://api.github.com/repos/rust-lang/rust/commits/541523d10dce98dc266f6d4e6fb6131182c0f791", "html_url": "https://github.com/rust-lang/rust/commit/541523d10dce98dc266f6d4e6fb6131182c0f791"}], "stats": {"total": 1077, "additions": 694, "deletions": 383}, "files": [{"sha": "14920b8b668ec56fb0f26141dec9a5c3707e05e4", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -55,6 +55,7 @@ pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n     pub infcx: &'infcx InferCtxt<'infcx, 'gcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n@@ -215,6 +216,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(self.trace.cause.clone(),\n+                                                  self.param_env,\n                                                   ty::Predicate::WellFormed(b_ty)));\n         }\n "}, {"sha": "a16f7fb208175f9b08c4abbe73a6131d2e5a8b3f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 103, "deletions": 83, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -161,8 +161,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n \n-    pub param_env: ty::ParamEnv<'gcx>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -400,55 +398,39 @@ impl fmt::Display for FixupError {\n pub trait InferEnv<'a, 'tcx> {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>);\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for Reveal {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>) {\n-        (None, None, ty::ParamEnv::empty(self))\n-    }\n+                    Option<ty::TypeckTables<'tcx>>);\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParamEnv<'tcx> {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>) {\n-        (None, None, self)\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (None, None)\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for &'a ty::TypeckTables<'tcx> {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>) {\n-        (Some(self.0), None, self.1)\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (Some(self), None)\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::TypeckTables<'tcx> {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>) {\n-        (None, Some(self.0), self.1)\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (None, Some(self))\n     }\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    ty::ParamEnv<'tcx>) {\n+                    Option<ty::TypeckTables<'tcx>>) {\n         let def_id = tcx.hir.body_owner_def_id(self);\n-        (Some(tcx.typeck_tables_of(def_id)),\n-         None,\n-         tcx.param_env(def_id))\n+        (Some(tcx.typeck_tables_of(def_id)), None)\n     }\n }\n \n@@ -460,18 +442,16 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     arena: DroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n     tables: Option<&'a ty::TypeckTables<'gcx>>,\n-    param_env: ty::ParamEnv<'gcx>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self, env: E) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        let (tables, fresh_tables, param_env) = env.to_parts(self);\n+        let (tables, fresh_tables) = env.to_parts(self);\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n             fresh_tables: fresh_tables.map(RefCell::new),\n             tables: tables,\n-            param_env: param_env,\n         }\n     }\n \n@@ -480,15 +460,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     /// If any inference functionality is used, ICEs will occur.\n     pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n                                     -> InferCtxt<'a, 'gcx, 'gcx> {\n-        let (tables, _, param_env) = body.to_parts(self);\n+        let (tables, _) = body.to_parts(self);\n         InferCtxt {\n             tcx: self,\n             tables: InferTables::Interned(tables.unwrap()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(self),\n-            param_env: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n@@ -509,7 +488,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             ref arena,\n             ref fresh_tables,\n             tables,\n-            param_env,\n         } = *self;\n         let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n             fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n@@ -522,7 +500,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n-            param_env: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n@@ -563,17 +540,21 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n /// Helper trait for shortening the lifetimes inside a\n /// value for post-type-checking normalization.\n pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n+    fn trans_normalize<'a, 'tcx>(&self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>)\n+                                 -> Self;\n }\n \n macro_rules! items { ($($item:item)+) => ($($item)+) }\n macro_rules! impl_trans_normalize {\n     ($lt_gcx:tt, $($ty:ty),+) => {\n         items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n             fn trans_normalize<'a, 'tcx>(&self,\n-                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>)\n+                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>)\n                                          -> Self {\n-                infcx.normalize_projections_in(self)\n+                infcx.normalize_projections_in(param_env, self)\n             }\n         })+);\n     }\n@@ -590,13 +571,16 @@ impl_trans_normalize!('gcx,\n );\n \n impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn trans_normalize<'a, 'tcx>(&self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>)\n+                                 -> Self {\n         match *self {\n-            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx) },\n+            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {\n                 LvalueTy::Downcast {\n                     adt_def: adt_def,\n-                    substs: substs.trans_normalize(infcx),\n+                    substs: substs.trans_normalize(infcx, param_env),\n                     variant_index: variant_index\n                 }\n             }\n@@ -618,19 +602,23 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         self.normalize_associated_type(&value)\n     }\n \n+    /// Fully normalizes any associated types in `value`, using an\n+    /// empty environment and `Reveal::All` mode (therefore, suitable\n+    /// only for monomorphized code during trans, basically).\n     pub fn normalize_associated_type<T>(self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n         debug!(\"normalize_associated_type(t={:?})\", value);\n \n+        let param_env = ty::ParamEnv::empty(Reveal::All);\n         let value = self.erase_regions(value);\n \n         if !value.has_projection_types() {\n             return value;\n         }\n \n-        self.infer_ctxt(Reveal::All).enter(|infcx| {\n-            value.trans_normalize(&infcx)\n+        self.infer_ctxt(()).enter(|infcx| {\n+            value.trans_normalize(&infcx, param_env)\n         })\n     }\n \n@@ -651,20 +639,20 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(env.reveal_all()).enter(|infcx| {\n-            value.trans_normalize(&infcx)\n+        self.infer_ctxt(()).enter(|infcx| {\n+            value.trans_normalize(&infcx, env.reveal_all())\n        })\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn normalize_projections_in<T>(&self, value: &T) -> T::Lifted\n+    fn normalize_projections_in<T>(&self, param_env: ty::ParamEnv<'tcx>, value: &T) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = traits::ObligationCause::dummy();\n         let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, param_env, cause, value);\n \n         debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n                 result, obligations);\n@@ -803,48 +791,69 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         return variables;\n     }\n \n-    fn combine_fields(&'a self, trace: TypeTrace<'tcx>)\n+    fn combine_fields(&'a self, trace: TypeTrace<'tcx>, param_env: ty::ParamEnv<'tcx>)\n                       -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace: trace,\n             cause: None,\n+            param_env,\n             obligations: PredicateObligations::new(),\n         }\n     }\n \n-    pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+    pub fn equate<T>(&'a self,\n+                     a_is_expected: bool,\n+                     trace: TypeTrace<'tcx>,\n+                     param_env: ty::ParamEnv<'tcx>,\n+                     a: &T,\n+                     b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut fields = self.combine_fields(trace);\n+        let mut fields = self.combine_fields(trace, param_env);\n         let result = fields.equate(a_is_expected).relate(a, b);\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n-    pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+    pub fn sub<T>(&'a self,\n+                  a_is_expected: bool,\n+                  trace: TypeTrace<'tcx>,\n+                  param_env: ty::ParamEnv<'tcx>,\n+                  a: &T,\n+                  b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut fields = self.combine_fields(trace);\n+        let mut fields = self.combine_fields(trace, param_env);\n         let result = fields.sub(a_is_expected).relate(a, b);\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n-    pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+    pub fn lub<T>(&'a self,\n+                  a_is_expected: bool,\n+                  trace: TypeTrace<'tcx>,\n+                  param_env: ty::ParamEnv<'tcx>,\n+                  a: &T,\n+                  b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut fields = self.combine_fields(trace);\n+        let mut fields = self.combine_fields(trace, param_env);\n         let result = fields.lub(a_is_expected).relate(a, b);\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n-    pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+    pub fn glb<T>(&'a self,\n+                  a_is_expected: bool,\n+                  trace: TypeTrace<'tcx>,\n+                  param_env: ty::ParamEnv<'tcx>,\n+                  a: &T,\n+                  b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut fields = self.combine_fields(trace);\n+        let mut fields = self.combine_fields(trace, param_env);\n         let result = fields.glb(a_is_expected).relate(a, b);\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n@@ -1011,26 +1020,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n                      cause: &ObligationCause<'tcx>,\n+                     param_env: ty::ParamEnv<'tcx>,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-        -> InferResult<'tcx, ()>\n+                     -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n+            self.sub(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n     pub fn can_sub_types(&self,\n+                         param_env: ty::ParamEnv<'tcx>,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n                          -> UnitResult<'tcx>\n     {\n         self.probe(|_| {\n             let origin = &ObligationCause::dummy();\n             let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|InferOk { obligations: _, .. }| {\n+            self.sub(true, trace, param_env, &a, &b).map(|InferOk { obligations: _, .. }| {\n                 // Ignore obligations, since we are unrolling\n                 // everything anyway.\n             })\n@@ -1040,21 +1051,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     cause: &ObligationCause<'tcx>,\n+                    param_env: ty::ParamEnv<'tcx>,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n+            self.equate(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n     pub fn eq_trait_refs(&self,\n-                          a_is_expected: bool,\n-                          cause: &ObligationCause<'tcx>,\n-                          a: ty::TraitRef<'tcx>,\n-                          b: ty::TraitRef<'tcx>)\n+                         a_is_expected: bool,\n+                         cause: &ObligationCause<'tcx>,\n+                         param_env: ty::ParamEnv<'tcx>,\n+                         a: ty::TraitRef<'tcx>,\n+                         b: ty::TraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n@@ -1063,28 +1076,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 cause: cause.clone(),\n                 values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n-            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n+            self.equate(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n     pub fn eq_impl_headers(&self,\n                            a_is_expected: bool,\n                            cause: &ObligationCause<'tcx>,\n+                           param_env: ty::ParamEnv<'tcx>,\n                            a: &ty::ImplHeader<'tcx>,\n                            b: &ty::ImplHeader<'tcx>)\n                            -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n         match (a.trait_ref, b.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, cause, a_ref, b_ref),\n-            (None, None) => self.eq_types(a_is_expected, cause, a.self_ty, b.self_ty),\n+            (Some(a_ref), Some(b_ref)) =>\n+                self.eq_trait_refs(a_is_expected, cause, param_env, a_ref, b_ref),\n+            (None, None) =>\n+                self.eq_types(a_is_expected, cause, param_env, a.self_ty, b.self_ty),\n             _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n         }\n     }\n \n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                cause: ObligationCause<'tcx>,\n+                               param_env: ty::ParamEnv<'tcx>,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n@@ -1095,7 +1112,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 cause: cause,\n                 values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n-            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n+            self.sub(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -1109,14 +1126,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn equality_predicate(&self,\n                               cause: &ObligationCause<'tcx>,\n+                              param_env: ty::ParamEnv<'tcx>,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let cause_span = cause.span;\n-            let eqty_ok = self.eq_types(false, cause, a, b)?;\n+            let eqty_ok = self.eq_types(false, cause, param_env, a, b)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(eqty_ok.unit())\n@@ -1125,6 +1143,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn subtype_predicate(&self,\n                              cause: &ObligationCause<'tcx>,\n+                             param_env: ty::ParamEnv<'tcx>,\n                              predicate: &ty::PolySubtypePredicate<'tcx>)\n         -> Option<InferResult<'tcx, ()>>\n     {\n@@ -1153,7 +1172,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n \n             let cause_span = cause.span;\n-            let ok = self.sub_types(a_is_expected, cause, a, b)?;\n+            let ok = self.sub_types(a_is_expected, cause, param_env, a, b)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(ok.unit())\n@@ -1555,6 +1574,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// details.\n     pub fn match_poly_projection_predicate(&self,\n                                            cause: ObligationCause<'tcx>,\n+                                           param_env: ty::ParamEnv<'tcx>,\n                                            match_a: ty::PolyProjectionPredicate<'tcx>,\n                                            match_b: ty::TraitRef<'tcx>)\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n@@ -1567,7 +1587,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n-        let mut combine = self.combine_fields(trace);\n+        let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n@@ -1586,7 +1606,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn can_equate<T>(&self, a: &T, b: &T) -> UnitResult<'tcx>\n+    pub fn can_equate<T>(&self, param_env: ty::ParamEnv<'tcx>, a: &T, b: &T) -> UnitResult<'tcx>\n         where T: Relate<'tcx> + fmt::Debug\n     {\n         debug!(\"can_equate({:?}, {:?})\", a, b);\n@@ -1596,7 +1616,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // generic so we don't have to do anything quite this\n             // terrible.\n             let trace = TypeTrace::dummy(self.tcx);\n-            self.equate(true, trace, a, b).map(|InferOk { obligations: _, .. }| {\n+            self.equate(true, trace, param_env, a, b).map(|InferOk { obligations: _, .. }| {\n                 // We can intentionally ignore obligations here, since\n                 // this is part of a simple test for general\n                 // \"equatability\". However, it's not entirely clear\n@@ -1617,17 +1637,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n-    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    pub fn type_moves_by_default(&self,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if let Some(ty) = self.tcx.lift_to_global(&ty) {\n+        if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n             // Even if the type may have no inference variables, during\n             // type-checking closure types are in local tables only.\n             let local_closures = match self.tables {\n                 InferTables::InProgress(_) => ty.has_closure_types(),\n                 _ => false\n             };\n             if !local_closures {\n-                return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n+                return ty.moves_by_default(self.tcx.global_tcx(), param_env, span);\n             }\n         }\n \n@@ -1637,17 +1661,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n+        !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n \n-    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n-        self.param_env\n-    }\n-\n     pub fn closure_kind(&self,\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>"}, {"sha": "405699968135243e5cb4ab974837fe07150e817f", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -96,6 +96,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                 self.fields.obligations.push(\n                     Obligation::new(\n                         self.fields.trace.cause.clone(),\n+                        self.fields.param_env,\n                         ty::Predicate::Subtype(\n                             ty::Binder(ty::SubtypePredicate {\n                                 a_is_expected: self.a_is_expected,"}, {"sha": "2216103636fb6c7821bfbb8b0fda714b129d02be", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -47,7 +47,7 @@\n #![cfg_attr(stage0, feature(staged_api))]\n #![cfg_attr(stage0, feature(loop_break_value))]\n \n-#![recursion_limit=\"192\"]\n+#![recursion_limit=\"256\"]\n \n extern crate arena;\n extern crate core;"}, {"sha": "7ab534605c2514193fd884c13c462c2640ee4ca9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -242,6 +242,7 @@ impl OverloadedCallType {\n pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n     delegate: &'a mut Delegate<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n // If the TYPER results in an error, it's because the type check\n@@ -266,24 +267,28 @@ macro_rules! return_if_err {\n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                region_maps: &'a RegionMaps,\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>)\n                -> Self\n     {\n         ExprUseVisitor::with_options(delegate,\n                                      infcx,\n+                                     param_env,\n                                      region_maps,\n                                      mc::MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'tcx>,\n                         region_maps: &'a RegionMaps,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::with_options(infcx, region_maps, options),\n-            delegate: delegate\n+            delegate,\n+            param_env,\n         }\n     }\n \n@@ -318,7 +323,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.mc.infcx, &cmt, DirectRefMove);\n+        let mode = copy_or_move(self.mc.infcx, self.param_env, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -797,7 +802,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n                 PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n+                    match copy_or_move(self.mc.infcx, self.param_env, &cmt_pat, PatBindingMove) {\n                         Copy => mode.lub(CopyingMatch),\n                         Move(..) => mode.lub(MovingMatch),\n                     }\n@@ -813,10 +818,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n-        let tcx = &self.tcx();\n-        let mc = &self.mc;\n+        let tcx = self.tcx();\n         let infcx = self.mc.infcx;\n-        let delegate = &mut self.delegate;\n+        let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n@@ -840,7 +844,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::BindByValue(..) => {\n-                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(infcx, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -899,7 +903,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.mc.infcx, &cmt_var, CaptureMove);\n+                        let mode = copy_or_move(self.mc.infcx,\n+                                                self.param_env,\n+                                                &cmt_var,\n+                                                CaptureMove);\n                         self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n@@ -929,11 +936,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n }\n \n fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                param_env: ty::ParamEnv<'tcx>,\n                                 cmt: &mc::cmt<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {\n-    if infcx.type_moves_by_default(cmt.ty, cmt.span) {\n+    if infcx.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "c7d069053e9d0cec7807c998e091f215fbcaa7c8", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -10,10 +10,11 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::{SelectionContext, Obligation, ObligationCause};\n-\n use hir::def_id::{DefId, LOCAL_CRATE};\n+use syntax_pos::DUMMY_SP;\n+use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n use ty::{self, Ty, TyCtxt};\n+use ty::subst::Subst;\n \n use infer::{InferCtxt, InferOk};\n \n@@ -37,6 +38,28 @@ pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n \n+fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+                                       param_env: ty::ParamEnv<'tcx>,\n+                                       impl_def_id: DefId)\n+                                       -> ty::ImplHeader<'tcx>\n+{\n+    let tcx = selcx.tcx();\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+\n+    let header = ty::ImplHeader {\n+        impl_def_id: impl_def_id,\n+        self_ty: tcx.type_of(impl_def_id),\n+        trait_ref: tcx.impl_trait_ref(impl_def_id),\n+        predicates: tcx.predicates_of(impl_def_id).predicates\n+    }.subst(tcx, impl_substs);\n+\n+    let Normalized { value: mut header, obligations } =\n+        traits::normalize(selcx, param_env, ObligationCause::dummy(), &header);\n+\n+    header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n+    header\n+}\n+\n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n@@ -48,17 +71,24 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n            a_def_id,\n            b_def_id);\n \n-    let a_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, a_def_id);\n-    let b_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, b_def_id);\n+    // For the purposes of this check, we don't bring any skolemized\n+    // types into scope; instead, we replace the generic types with\n+    // fresh type variables, and hence we do our evaluations in an\n+    // empty environment.\n+    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+\n+    let a_impl_header = with_fresh_ty_vars(selcx, param_env, a_def_id);\n+    let b_impl_header = with_fresh_ty_vars(selcx, param_env, b_def_id);\n \n     debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n     let obligations = match selcx.infcx().eq_impl_headers(true,\n-                                        &ObligationCause::dummy(),\n-                                        &a_impl_header,\n-                                        &b_impl_header) {\n+                                                          &ObligationCause::dummy(),\n+                                                          param_env,\n+                                                          &a_impl_header,\n+                                                          &b_impl_header) {\n         Ok(InferOk { obligations, .. }) => {\n             obligations\n         }\n@@ -75,6 +105,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                      .chain(&b_impl_header.predicates)\n                      .map(|p| infcx.resolve_type_vars_if_possible(p))\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n+                                           param_env: param_env,\n                                            recursion_depth: 0,\n                                            predicate: p })\n                      .chain(obligations)"}, {"sha": "6635a1f1f271eb9c3e046ef8d6fa4d69ae198fb0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -179,12 +179,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     data);\n                 let normalized = super::normalize_projection_type(\n                     &mut selcx,\n+                    obligation.param_env,\n                     data.projection_ty,\n                     obligation.cause.clone(),\n                     0\n                 );\n                 if let Err(error) = self.eq_types(\n-                    false, &obligation.cause,\n+                    false, &obligation.cause, obligation.param_env,\n                     data.ty, normalized.value\n                 ) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n@@ -251,7 +252,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        -> Option<DefId>\n     {\n         let tcx = self.tcx;\n-\n+        let param_env = obligation.param_env;\n         let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n@@ -268,7 +269,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                 let impl_self_ty = impl_trait_ref.self_ty();\n \n-                if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n+                if let Ok(..) = self.can_equate(param_env, &trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n                     if trait_ref.substs.types().skip(1)\n@@ -578,7 +579,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n-                            self.predicate_can_apply(trait_ref) {\n+                            self.predicate_can_apply(obligation.param_env, trait_ref) {\n                             // If a where-clause may be useful, remind the\n                             // user that they can add it.\n                             //\n@@ -607,7 +608,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Equate(ref predicate) => {\n                         let predicate = self.resolve_type_vars_if_possible(predicate);\n                         let err = self.equality_predicate(&obligation.cause,\n-                                                            &predicate).err().unwrap();\n+                                                          obligation.param_env,\n+                                                          &predicate).err().unwrap();\n                         struct_span_err!(self.tcx.sess, span, E0278,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate, err)\n@@ -936,7 +938,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns whether the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n-    fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n+    fn predicate_can_apply(&self,\n+                           param_env: ty::ParamEnv<'tcx>,\n+                           pred: ty::PolyTraitRef<'tcx>)\n+                           -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n@@ -967,12 +972,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = super::project::normalize(\n                 &mut selcx,\n+                param_env,\n                 ObligationCause::dummy(),\n                 &cleaned_pred\n             ).value;\n \n             let obligation = Obligation::new(\n                 ObligationCause::dummy(),\n+                param_env,\n                 cleaned_pred.to_predicate()\n             );\n "}, {"sha": "daeb96e188d3774ecc7e219afd29e33339c2e5f6", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -113,6 +113,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type(&mut self,\n                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      projection_ty: ty::ProjectionTy<'tcx>,\n                                      cause: ObligationCause<'tcx>)\n                                      -> Ty<'tcx>\n@@ -125,7 +126,11 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // FIXME(#20304) -- cache\n \n         let mut selcx = SelectionContext::new(infcx);\n-        let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n+        let normalized = project::normalize_projection_type(&mut selcx,\n+                                                            param_env,\n+                                                            projection_ty,\n+                                                            cause,\n+                                                            0);\n \n         for obligation in normalized.obligations {\n             self.register_predicate_obligation(infcx, obligation);\n@@ -136,8 +141,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n     pub fn register_bound(&mut self,\n                           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>,\n                           def_id: DefId,\n                           cause: ObligationCause<'tcx>)\n@@ -149,6 +158,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.register_predicate_obligation(infcx, Obligation {\n             cause: cause,\n             recursion_depth: 0,\n+            param_env,\n             predicate: trait_ref.to_predicate()\n         });\n     }\n@@ -410,7 +420,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(&obligation.cause, binder) {\n+            match selcx.infcx().equality_predicate(&obligation.cause, obligation.param_env, binder) {\n                 Ok(InferOk { obligations, value: () }) => {\n                     Ok(Some(obligations))\n                 },\n@@ -498,7 +508,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+            match ty::wf::obligations(selcx.infcx(), obligation.param_env, obligation.cause.body_id,\n                                       ty, obligation.cause.span) {\n                 None => {\n                     pending_obligation.stalled_on = vec![ty];\n@@ -509,7 +519,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Subtype(ref subtype) => {\n-            match selcx.infcx().subtype_predicate(&obligation.cause, subtype) {\n+            match selcx.infcx().subtype_predicate(&obligation.cause, obligation.param_env, subtype) {\n                 None => {\n                     // none means that both are unresolved\n                     pending_obligation.stalled_on = vec![subtype.skip_binder().a,"}, {"sha": "c51974e6e670021a3f390f3739c1516b4538f148", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -68,6 +68,7 @@ mod util;\n #[derive(Clone, PartialEq, Eq)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub recursion_depth: usize,\n     pub predicate: T,\n }\n@@ -359,10 +360,11 @@ pub struct VtableFnPointerData<'tcx, N> {\n \n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> PredicateObligations<'tcx>\n {\n-    util::predicates_for_generics(cause, 0, generic_bounds)\n+    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n }\n \n /// Determines whether the type `ty` is known to meet `bound` and\n@@ -371,6 +373,7 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>,\n                                                 ty: Ty<'tcx>,\n                                                 def_id: DefId,\n                                                 span: Span)\n@@ -385,6 +388,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         substs: infcx.tcx.mk_substs_trait(ty, &[]),\n     };\n     let obligation = Obligation {\n+        param_env,\n         cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n         recursion_depth: 0,\n         predicate: trait_ref.to_predicate(),\n@@ -408,7 +412,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // anyhow).\n         let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n-        fulfill_cx.register_bound(infcx, ty, def_id, cause);\n+        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n@@ -480,22 +484,24 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n                                            unnormalized_env.reveal);\n \n-    tcx.infer_ctxt(elaborated_env).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let predicates = match fully_normalize(\n-                &infcx, cause,\n-                // You would really want to pass infcx.param_env.caller_bounds here,\n-                // but that is an interned slice, and fully_normalize takes &T and returns T, so\n-                // without further refactoring, a slice can't be used. Luckily, we still have the\n-                // predicate vector from which we created the ParamEnv in infcx, so we\n-                // can pass that instead. It's roundabout and a bit brittle, but this code path\n-                // ought to be refactored anyway, and until then it saves us from having to copy.\n-                &predicates,\n+            &infcx,\n+            cause,\n+            elaborated_env,\n+            // You would really want to pass infcx.param_env.caller_bounds here,\n+            // but that is an interned slice, and fully_normalize takes &T and returns T, so\n+            // without further refactoring, a slice can't be used. Luckily, we still have the\n+            // predicate vector from which we created the ParamEnv in infcx, so we\n+            // can pass that instead. It's roundabout and a bit brittle, but this code path\n+            // ought to be refactored anyway, and until then it saves us from having to copy.\n+            &predicates,\n         ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n                 infcx.report_fulfillment_errors(&errors);\n                 // An unnormalized env is better than nothing.\n-                return infcx.param_env;\n+                return elaborated_env;\n             }\n         };\n \n@@ -517,24 +523,25 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // all things considered.\n                 tcx.sess.span_err(span, &fixup_err.to_string());\n                 // An unnormalized env is better than nothing.\n-                return infcx.param_env;\n+                return elaborated_env;\n             }\n         };\n \n         let predicates = match tcx.lift_to_global(&predicates) {\n             Some(predicates) => predicates,\n-            None => return infcx.param_env\n+            None => return elaborated_env,\n         };\n \n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n-            predicates);\n+               predicates);\n \n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n     })\n }\n \n pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                           cause: ObligationCause<'tcx>,\n+                                          param_env: ty::ParamEnv<'tcx>,\n                                           value: &T)\n                                           -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n@@ -558,7 +565,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let mut fulfill_cx = FulfillmentContext::new();\n \n     let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, cause, value);\n+        project::normalize(selcx, param_env, cause, value);\n     debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\",\n            normalized_value,\n            obligations);\n@@ -580,28 +587,29 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     Ok(resolved_value)\n }\n \n-/// Normalizes the predicates and checks whether they hold.  If this\n-/// returns false, then either normalize encountered an error or one\n-/// of the predicates did not hold. Used when creating vtables to\n-/// check for unsatisfiable methods.\n+/// Normalizes the predicates and checks whether they hold in an empty\n+/// environment. If this returns false, then either normalize\n+/// encountered an error or one of the predicates did not hold. Used\n+/// when creating vtables to check for unsatisfiable methods.\n pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                predicates: Vec<ty::Predicate<'tcx>>)\n                                                -> bool\n {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt(Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::All);\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, cause.clone(), &predicates);\n+            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n         for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n         for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), predicate);\n+            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n \n@@ -663,30 +671,33 @@ pub fn get_vtable_methods<'a, 'tcx>(\n \n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n-               trait_ref: O)\n+               param_env: ty::ParamEnv<'tcx>,\n+               predicate: O)\n                -> Obligation<'tcx, O>\n     {\n-        Obligation { cause: cause,\n-                     recursion_depth: 0,\n-                     predicate: trait_ref }\n+        Obligation { cause, param_env, recursion_depth: 0, predicate }\n     }\n \n     fn with_depth(cause: ObligationCause<'tcx>,\n                   recursion_depth: usize,\n-                  trait_ref: O)\n+                  param_env: ty::ParamEnv<'tcx>,\n+                  predicate: O)\n                   -> Obligation<'tcx, O>\n     {\n-        Obligation { cause: cause,\n-                     recursion_depth: recursion_depth,\n-                     predicate: trait_ref }\n+        Obligation { cause, param_env, recursion_depth, predicate }\n     }\n \n-    pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n-        Obligation::new(ObligationCause::misc(span, body_id), trait_ref)\n+    pub fn misc(span: Span,\n+                body_id: ast::NodeId,\n+                param_env: ty::ParamEnv<'tcx>,\n+                trait_ref: O)\n+                -> Obligation<'tcx, O> {\n+        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n     }\n \n     pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n         Obligation { cause: self.cause.clone(),\n+                     param_env: self.param_env,\n                      recursion_depth: self.recursion_depth,\n                      predicate: value }\n     }"}, {"sha": "c155d1bf241b5f1a529bdf4f6859f1dc0fed838e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -168,7 +168,8 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n \n     let Normalized { value: normalized_ty, mut obligations } =\n         match opt_normalize_projection_type(selcx,\n-                                            obligation.predicate.projection_ty.clone(),\n+                                            obligation.param_env,\n+                                            obligation.predicate.projection_ty,\n                                             obligation.cause.clone(),\n                                             obligation.recursion_depth) {\n             Some(n) => n,\n@@ -180,7 +181,11 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    match infcx.eq_types(true, &obligation.cause, normalized_ty, obligation.predicate.ty) {\n+    match infcx.eq_types(true,\n+                         &obligation.cause,\n+                         obligation.param_env,\n+                         normalized_ty,\n+                         obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n@@ -194,17 +199,19 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n pub fn normalize<'a, 'b, 'gcx, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         cause: ObligationCause<'tcx>,\n                                         value: &T)\n                                         -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n-    normalize_with_depth(selcx, cause, 0, value)\n+    normalize_with_depth(selcx, param_env, cause, 0, value)\n }\n \n /// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     value: &T)\n@@ -213,7 +220,7 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n-    let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n+    let mut normalizer = AssociatedTypeNormalizer::new(selcx, param_env, cause, depth);\n     let result = normalizer.fold(value);\n     debug!(\"normalize_with_depth: depth={} result={:?} with {} obligations\",\n            depth, result, normalizer.obligations.len());\n@@ -227,19 +234,22 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n \n struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     fn new(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>,\n            cause: ObligationCause<'tcx>,\n            depth: usize)\n            -> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx>\n     {\n         AssociatedTypeNormalizer {\n             selcx: selcx,\n+            param_env: param_env,\n             cause: cause,\n             obligations: vec![],\n             depth: depth,\n@@ -305,6 +315,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n                 let Normalized { value: normalized_ty, obligations } =\n                     normalize_projection_type(self.selcx,\n+                                              self.param_env,\n                                               data.clone(),\n                                               self.cause.clone(),\n                                               self.depth);\n@@ -344,12 +355,13 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n     -> NormalizedTy<'tcx>\n {\n-    opt_normalize_projection_type(selcx, projection_ty.clone(), cause.clone(), depth)\n+    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth)\n         .unwrap_or_else(move || {\n             // if we bottom out in ambiguity, create a type variable\n             // and a deferred predicate to resolve this when more type\n@@ -366,7 +378,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 ty: ty_var\n             });\n             let obligation = Obligation::with_depth(\n-                cause, depth + 1, projection.to_predicate());\n+                cause, depth + 1, param_env, projection.to_predicate());\n             Normalized {\n                 value: ty_var,\n                 obligations: vec![obligation]\n@@ -380,6 +392,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -449,6 +462,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n             let obligation = Obligation::with_depth(cause.clone(),\n                                                     recursion_limit,\n+                                                    param_env,\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n@@ -464,11 +478,11 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     found error\");\n-            return Some(normalize_to_error(selcx, projection_ty, cause, depth));\n+            return Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth));\n         }\n     }\n \n-    let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n+    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n         Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n                                             mut obligations,\n@@ -489,7 +503,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                    cacheable);\n \n             let result = if projected_ty.has_projection_types() {\n-                let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth+1);\n+                let mut normalizer = AssociatedTypeNormalizer::new(selcx, param_env, cause, depth+1);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n                 debug!(\"opt_normalize_projection_type: \\\n@@ -540,7 +554,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             infcx.projection_cache.borrow_mut()\n                                   .error(projection_ty);\n-            Some(normalize_to_error(selcx, projection_ty, cause, depth))\n+            Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n         }\n     }\n }\n@@ -565,6 +579,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                      param_env: ty::ParamEnv<'tcx>,\n                                       projection_ty: ty::ProjectionTy<'tcx>,\n                                       cause: ObligationCause<'tcx>,\n                                       depth: usize)\n@@ -573,6 +588,7 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n+                                        param_env,\n                                         predicate: trait_ref.to_predicate() };\n     let tcx = selcx.infcx().tcx;\n     let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n@@ -746,13 +762,12 @@ fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n-    let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n                                         obligation_trait_ref,\n                                         candidate_set,\n                                         ProjectionTyCandidate::ParamEnv,\n-                                        env_predicates);\n+                                        obligation.param_env.caller_bounds.iter().cloned());\n }\n \n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n@@ -807,7 +822,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: I)\n-    where I: Iterator<Item=ty::Predicate<'tcx>>\n+    where I: IntoIterator<Item=ty::Predicate<'tcx>>\n {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n            obligation);\n@@ -827,6 +842,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                         obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n                                               obligation.cause.clone(),\n+                                              obligation.param_env,\n                                               data_poly_trait_ref,\n                                               obligation_poly_trait_ref)\n                         .map(|InferOk { obligations: _, value: () }| {\n@@ -936,7 +952,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // get a result which isn't correct for all monomorphizations.\n                 let new_candidate = if !is_default {\n                     Some(ProjectionTyCandidate::Select)\n-                } else if selcx.projection_mode() == Reveal::All {\n+                } else if obligation.param_env.reveal == Reveal::All {\n                     assert!(!poly_trait_ref.needs_infer());\n                     if !poly_trait_ref.needs_subst() {\n                         Some(ProjectionTyCandidate::Select)\n@@ -1096,6 +1112,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n             selcx.infcx().probe(|_| {\n                 selcx.infcx().sub_poly_trait_refs(false,\n                                                   obligation.cause.clone(),\n+                                                  obligation.param_env,\n                                                   data_poly_trait_ref,\n                                                   obligation_poly_trait_ref).is_ok()\n             })\n@@ -1143,6 +1160,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n         value: closure_type,\n         obligations\n     } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &closure_type);\n@@ -1203,8 +1221,9 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n {\n     let infcx = selcx.infcx();\n     let cause = obligation.cause.clone();\n+    let param_env = obligation.param_env;\n     let trait_ref = obligation.predicate.trait_ref;\n-    match infcx.match_poly_projection_predicate(cause, poly_projection, trait_ref) {\n+    match infcx.match_poly_projection_predicate(cause, param_env, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n             Progress {\n                 ty: ty_match.value,\n@@ -1233,6 +1252,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n     let tcx = selcx.tcx();\n+    let param_env = obligation.param_env;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name(tcx));\n \n     let ty = if !assoc_ty.item.defaultness.has_value() {\n@@ -1247,7 +1267,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)\n     };\n-    let substs = translate_substs(selcx.infcx(), impl_def_id, substs, assoc_ty.node);\n+    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n     Progress {\n         ty: ty.subst(tcx, substs),\n         obligations: nested,"}, {"sha": "21d4df3d0990d67a04c82365c78003892f894347", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -21,7 +21,6 @@ use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n-use super::Reveal;\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n@@ -315,18 +314,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n-        self.infcx.param_env()\n-    }\n-\n     pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn projection_mode(&self) -> Reveal {\n-        self.param_env().reveal\n-    }\n-\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n@@ -540,7 +531,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.equality_predicate(&obligation.cause, p) {\n+                match self.infcx.equality_predicate(&obligation.cause, obligation.param_env, p) {\n                     Ok(InferOk { obligations, .. }) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -551,7 +542,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Subtype(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.subtype_predicate(&obligation.cause, p) {\n+                match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -562,7 +553,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(self.infcx, obligation.cause.body_id,\n+                match ty::wf::obligations(self.infcx, obligation.param_env, obligation.cause.body_id,\n                                           ty, obligation.cause.span) {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n@@ -628,7 +619,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let stack = self.push_stack(previous_stack, obligation);\n         let fresh_trait_ref = stack.fresh_trait_ref;\n-        if let Some(result) = self.check_evaluation_cache(fresh_trait_ref) {\n+        if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n                    fresh_trait_ref,\n                    result);\n@@ -640,7 +631,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n-        self.insert_evaluation_cache(fresh_trait_ref, result);\n+        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, result);\n \n         result\n     }\n@@ -751,10 +742,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n+    fn check_evaluation_cache(&self,\n+                              param_env: ty::ParamEnv<'tcx>,\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let cache = self.tcx().evaluation_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n                 return Some(cached.clone());\n@@ -764,6 +757,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn insert_evaluation_cache(&mut self,\n+                               param_env: ty::ParamEnv<'tcx>,\n                                trait_ref: ty::PolyTraitRef<'tcx>,\n                                result: EvaluationResult)\n     {\n@@ -778,7 +772,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n                 cache.insert(trait_ref, result);\n@@ -819,7 +813,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        if let Some(c) = self.check_candidate_cache(&cache_fresh_trait_pred) {\n+        if let Some(c) = self.check_candidate_cache(stack.obligation.param_env,\n+                                                    &cache_fresh_trait_pred) {\n             debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred,\n                    c);\n@@ -832,7 +827,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n             debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n-            self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+            self.insert_candidate_cache(stack.obligation.param_env,\n+                                        cache_fresh_trait_pred,\n+                                        candidate.clone());\n         }\n \n         candidate\n@@ -995,15 +992,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Returns true if the global caches can be used.\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n-    fn can_use_global_caches(&self) -> bool {\n+    fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n         // switch to a global cache. We used to try and draw\n         // finer-grained distinctions, but that led to a serious of\n         // annoying and weird bugs like #22019 and #18290. This simple\n         // rule seems to be pretty clearly safe and also still retains\n         // a very high hit rate (~95% when compiling rustc).\n-        if !self.param_env().caller_bounds.is_empty() {\n+        if !param_env.caller_bounds.is_empty() {\n             return false;\n         }\n \n@@ -1023,11 +1020,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n+                             param_env: ty::ParamEnv<'tcx>,\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n         let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let cache = self.tcx().selection_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n                 return Some(cached.clone());\n@@ -1037,11 +1035,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn insert_candidate_cache(&mut self,\n+                              param_env: ty::ParamEnv<'tcx>,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n         let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n                 if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n@@ -1099,6 +1098,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         let TraitObligationStack { obligation, .. } = *stack;\n         let ref obligation = Obligation {\n+            param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n             predicate: self.infcx().resolve_type_vars_if_possible(&obligation.predicate)\n@@ -1272,6 +1272,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let cause = obligation.cause.clone();\n         match self.infcx.sub_poly_trait_refs(false,\n                                              cause,\n+                                             obligation.param_env,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n@@ -1296,9 +1297,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack.obligation);\n \n         let all_bounds =\n-            self.param_env().caller_bounds\n-                            .iter()\n-                            .filter_map(|o| o.to_opt_poly_trait_ref());\n+            stack.obligation.param_env.caller_bounds\n+                                      .iter()\n+                                      .filter_map(|o| o.to_opt_poly_trait_ref());\n \n         // micro-optimization: filter out predicates relating to different\n         // traits.\n@@ -1953,6 +1954,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn collect_predicates_for_types(&mut self,\n+                                    param_env: ty::ParamEnv<'tcx>,\n                                     cause: ObligationCause<'tcx>,\n                                     recursion_depth: usize,\n                                     trait_def_id: DefId,\n@@ -1981,16 +1983,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(this,\n+                                                  param_env,\n                                                   cause.clone(),\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    this.tcx().predicate_for_trait_def(\n-                                                  cause.clone(),\n-                                                  trait_def_id,\n-                                                  recursion_depth,\n-                                                  normalized_ty,\n-                                                  &[]);\n+                    this.tcx().predicate_for_trait_def(param_env,\n+                                                       cause.clone(),\n+                                                       trait_def_id,\n+                                                       recursion_depth,\n+                                                       normalized_ty,\n+                                                       &[]);\n                 obligations.push(skol_obligation);\n                 this.infcx().plug_leaks(skol_map, snapshot, obligations)\n             })\n@@ -2131,7 +2134,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            self.collect_predicates_for_types(cause,\n+            self.collect_predicates_for_types(obligation.param_env,\n+                                              cause,\n                                               obligation.recursion_depth+1,\n                                               trait_def,\n                                               nested)\n@@ -2175,6 +2179,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let mut obligations = self.collect_predicates_for_types(\n+            obligation.param_env,\n             cause,\n             obligation.recursion_depth+1,\n             trait_def_id,\n@@ -2187,6 +2192,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n+                                           obligation.param_env,\n                                            trait_def_id,\n                                            &trait_ref.substs,\n                                            skol_map,\n@@ -2220,9 +2226,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.vtable_impl(impl_def_id, substs, cause,\n+            this.vtable_impl(impl_def_id,\n+                             substs,\n+                             cause,\n                              obligation.recursion_depth + 1,\n-                             skol_map, snapshot)\n+                             obligation.param_env,\n+                             skol_map,\n+                             snapshot)\n         })\n     }\n \n@@ -2231,6 +2241,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n+                   param_env: ty::ParamEnv<'tcx>,\n                    skol_map: infer::SkolemizationMap<'tcx>,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n@@ -2244,6 +2255,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut impl_obligations =\n             self.impl_or_trait_obligations(cause,\n                                            recursion_depth,\n+                                           param_env,\n                                            impl_def_id,\n                                            &substs.value,\n                                            skol_map,\n@@ -2345,6 +2357,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n         Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n@@ -2374,12 +2387,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligations);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n \n         obligations.push(Obligation::new(\n-                obligation.cause.clone(),\n-                ty::Predicate::ClosureKind(closure_def_id, kind)));\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            ty::Predicate::ClosureKind(closure_def_id, kind)));\n \n         Ok(VtableClosureData {\n             closure_def_id: closure_def_id,\n@@ -2415,13 +2430,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n                                obligation_cause: ObligationCause<'tcx>,\n+                               obligation_param_env: ty::ParamEnv<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx.sub_poly_trait_refs(false,\n                                        obligation_cause.clone(),\n+                                       obligation_param_env,\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n@@ -2458,7 +2475,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_dynamic(\n                     ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, new_trait, target)\n+                    self.infcx.eq_types(false,\n+                                        &obligation.cause,\n+                                        obligation.param_env,\n+                                        new_trait,\n+                                        target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2469,6 +2490,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n+                                                   obligation.param_env,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n@@ -2488,6 +2510,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let mut push = |predicate| {\n                     nested.push(Obligation::with_depth(cause.clone(),\n                                                        obligation.recursion_depth + 1,\n+                                                       obligation.param_env,\n                                                        predicate));\n                 };\n \n@@ -2517,7 +2540,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, a, b)\n+                    self.infcx.eq_types(false, &obligation.cause, obligation.param_env, a, b)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2580,12 +2603,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, new_struct, target)\n+                    self.infcx.eq_types(false,\n+                                        &obligation.cause,\n+                                        obligation.param_env,\n+                                        new_struct,\n+                                        target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n+                    obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n@@ -2655,6 +2683,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let impl_trait_ref =\n             project::normalize_with_depth(self,\n+                                          obligation.param_env,\n                                           obligation.cause.clone(),\n                                           obligation.recursion_depth + 1,\n                                           &impl_trait_ref);\n@@ -2669,6 +2698,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let InferOk { obligations, .. } =\n             self.infcx.eq_trait_refs(false,\n                                      &obligation.cause,\n+                                     obligation.param_env,\n                                      impl_trait_ref.value.clone(),\n                                      skol_obligation_trait_ref)\n             .map_err(|e| {\n@@ -2742,6 +2772,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         self.infcx.sub_poly_trait_refs(false,\n                                        obligation.cause.clone(),\n+                                       obligation.param_env,\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n@@ -2809,6 +2840,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // A closure signature can contain associated types which\n         // must be normalized.\n         normalize_with_depth(self,\n+                             obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &trait_ref)\n@@ -2821,6 +2853,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn impl_or_trait_obligations(&mut self,\n                                  cause: ObligationCause<'tcx>,\n                                  recursion_depth: usize,\n+                                 param_env: ty::ParamEnv<'tcx>,\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap<'tcx>,\n@@ -2847,12 +2880,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n-            let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,\n+            let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain(\n                 Some(Obligation {\n                     cause: cause.clone(),\n                     recursion_depth: recursion_depth,\n+                    param_env,\n                     predicate: predicate.value\n                 }))\n         }).collect();"}, {"sha": "0e9bf93cbd2d1cca3f7beb6028fbf51938831736", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -41,6 +41,7 @@ pub struct OverlapError {\n /// Given a subst for the requested impl, translate it to a subst\n /// appropriate for the actual item definition (whether it be in that impl,\n /// a parent impl, or the trait).\n+///\n /// When we have selected one impl, but are actually using item definitions from\n /// a parent impl providing a default, we need a way to translate between the\n /// type parameters of the two impls. Here the `source_impl` is the one we've\n@@ -73,6 +74,7 @@ pub struct OverlapError {\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         source_impl: DefId,\n                                         source_substs: &'tcx Substs<'tcx>,\n                                         target_node: specialization_graph::Node)\n@@ -91,10 +93,11 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                 return source_substs;\n             }\n \n-            fulfill_implication(infcx, source_trait_ref, target_impl).unwrap_or_else(|_| {\n-                bug!(\"When translating substitutions for specialization, the expected \\\n-                      specializaiton failed to hold\")\n-            })\n+            fulfill_implication(infcx, param_env, source_trait_ref, target_impl)\n+                .unwrap_or_else(|_| {\n+                    bug!(\"When translating substitutions for specialization, the expected \\\n+                          specializaiton failed to hold\")\n+                })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n@@ -122,9 +125,10 @@ pub fn find_associated_item<'a, 'tcx>(\n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt(Reveal::All).enter(|infcx| {\n+            let substs = tcx.infer_ctxt(()).enter(|infcx| {\n+                let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(&infcx, impl_data.impl_def_id,\n+                let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n                 let substs = infcx.tcx.erase_regions(&substs);\n                 tcx.lift(&substs).unwrap_or_else(|| {\n@@ -184,19 +188,22 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(penv).enter(|infcx| {\n+    let result = tcx.infer_ctxt(()).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref =\n-            match traits::fully_normalize(&infcx, ObligationCause::dummy(), &impl1_trait_ref) {\n+            match traits::fully_normalize(&infcx,\n+                                          ObligationCause::dummy(),\n+                                          penv,\n+                                          &impl1_trait_ref) {\n                 Ok(impl1_trait_ref) => impl1_trait_ref,\n                 Err(err) => {\n                     bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n                 }\n             };\n \n         // Attempt to prove that impl2 applies, given all of the above.\n-        fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+        fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n     });\n \n     tcx.specializes_cache.borrow_mut().insert(impl1_def_id, impl2_def_id, result);\n@@ -209,18 +216,21 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                       param_env: ty::ParamEnv<'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                   target_impl,\n-                                                                   target_substs);\n+                                                                       param_env,\n+                                                                       target_impl,\n+                                                                       target_substs);\n \n     // do the impls unify? If not, no specialization.\n     match infcx.eq_trait_refs(true,\n                               &ObligationCause::dummy(),\n+                              param_env,\n                               source_trait_ref,\n                               target_trait_ref) {\n         Ok(InferOk { obligations: o, .. }) => {\n@@ -250,7 +260,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                        source_trait_ref,\n                        target_trait_ref,\n                        errors,\n-                       infcx.param_env.caller_bounds);\n+                       param_env.caller_bounds);\n                 Err(())\n             }\n "}, {"sha": "702c5035a18b721e9708f6fa1ab81afde4b18f09", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -11,7 +11,7 @@\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n-use traits::{self, Reveal};\n+use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use std::rc::Rc;\n@@ -109,7 +109,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(Reveal::UserFacing).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt(()).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "4abb0cb549db45add7ce5f917660a282bc030f72", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -341,6 +341,7 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n             predicate: self.predicate.fold_with(folder),\n+            param_env: self.param_env.fold_with(folder),\n         }\n     }\n "}, {"sha": "7ad2ef90f0d49fc2eb8f7eb5654695d8d9c821ef", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -46,12 +46,14 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             // Do the initial selection for the obligation. This yields the\n             // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt(Reveal::All).enter(|infcx| {\n+            self.infer_ctxt(()).enter(|infcx| {\n                 let mut selcx = SelectionContext::new(&infcx);\n \n+                let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let obligation_cause = ObligationCause::misc(span,\n                                                              ast::DUMMY_NODE_ID);\n                 let obligation = Obligation::new(obligation_cause,\n+                                                 param_env,\n                                                  trait_ref.to_poly_trait_predicate());\n \n                 let selection = match selcx.select(&obligation) {"}, {"sha": "c385927811cf7532aac7bcad629670ab58c19340", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -358,6 +358,7 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>,\n                                                 impl_def_id: DefId,\n                                                 impl_substs: &Substs<'tcx>)\n                                                 -> (ty::TraitRef<'tcx>,\n@@ -368,14 +369,14 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let impl_trait_ref =\n         impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &impl_trait_ref);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        super::normalize(selcx, ObligationCause::dummy(), &predicates);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n     let impl_obligations =\n-        predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n+        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n \n     let impl_obligations: Vec<_> =\n         impl_obligations.into_iter()\n@@ -389,6 +390,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> Vec<PredicateObligation<'tcx>>\n {\n@@ -398,37 +400,41 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n     generic_bounds.predicates.iter().map(|predicate| {\n         Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n+                     param_env: param_env,\n                      predicate: predicate.clone() }\n     }).collect()\n }\n \n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n     -> PredicateObligation<'tcx>\n {\n     Obligation {\n         cause: cause,\n+        param_env: param_env,\n         recursion_depth: recursion_depth,\n         predicate: trait_ref.to_predicate(),\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn predicate_for_trait_def(self,\n-        cause: ObligationCause<'tcx>,\n-        trait_def_id: DefId,\n-        recursion_depth: usize,\n-        param_ty: Ty<'tcx>,\n-        ty_params: &[Ty<'tcx>])\n+                                   param_env: ty::ParamEnv<'tcx>,\n+                                   cause: ObligationCause<'tcx>,\n+                                   trait_def_id: DefId,\n+                                   recursion_depth: usize,\n+                                   param_ty: Ty<'tcx>,\n+                                   ty_params: &[Ty<'tcx>])\n         -> PredicateObligation<'tcx>\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n             substs: self.mk_substs_trait(param_ty, ty_params)\n         };\n-        predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n+        predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n     }\n \n     /// Cast a trait reference into a reference to one of its super"}, {"sha": "87cee2ddc03f8ea5329caaa21f7526c6a0bbdf8b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -765,6 +765,18 @@ pub trait Lift<'tcx> {\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n+    type Lifted = ty::ParamEnv<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<ty::ParamEnv<'tcx>> {\n+        self.caller_bounds.lift_to_tcx(tcx).and_then(|caller_bounds| {\n+            Some(ty::ParamEnv {\n+                reveal: self.reveal,\n+                caller_bounds,\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n@@ -851,6 +863,25 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n+    type Lifted = &'tcx Slice<Predicate<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+        -> Option<&'tcx Slice<Predicate<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub mod tls {\n     use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n "}, {"sha": "8c991be0d12d4942c309618bdfd41b45a8dacde9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -158,29 +158,6 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'gcx, 'tcx>,\n-                              impl_def_id: DefId)\n-                              -> ImplHeader<'tcx>\n-    {\n-        let tcx = selcx.tcx();\n-        let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-\n-        let header = ImplHeader {\n-            impl_def_id: impl_def_id,\n-            self_ty: tcx.type_of(impl_def_id),\n-            trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.predicates_of(impl_def_id).predicates\n-        }.subst(tcx, impl_substs);\n-\n-        let traits::Normalized { value: mut header, obligations } =\n-            traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n-\n-        header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n-        header\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct AssociatedItem {\n     pub def_id: DefId,"}, {"sha": "1e2689243903e3a7c2f81f186d78ea4b2f09f0d9", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -466,6 +466,20 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ParamEnv {\n+            reveal: self.reveal,\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let &ty::ParamEnv { reveal: _, ref caller_bounds } = self;\n+        caller_bounds.super_visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n@@ -771,6 +785,17 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_predicates(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "8c2577a382431b6f33fe100420ad86cf5a205ce0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -170,20 +170,21 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n         ty::ParamEnv { reveal: Reveal::All, ..self }\n     }\n \n-    pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn can_type_implement_copy<'a>(self,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n-                                       -> Result<(), CopyImplementationError> {\n+                                       -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(self.clone()).enter(|infcx| {\n+        tcx.infer_ctxt(()).enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n \n             let field_implements_copy = |field: &ty::FieldDef| {\n                 let cause = traits::ObligationCause::dummy();\n-                match traits::fully_normalize(&infcx, cause, &field.ty(tcx, substs)) {\n-                    Ok(ty) => !infcx.type_moves_by_default(ty, span),\n+                match traits::fully_normalize(&infcx, cause, self, &field.ty(tcx, substs)) {\n+                    Ok(ty) => !infcx.type_moves_by_default(self, ty, span),\n                     Err(..) => false,\n                 }\n             };\n@@ -963,8 +964,12 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-    tcx.infer_ctxt(param_env)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -973,8 +978,12 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-    tcx.infer_ctxt(param_env)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -983,8 +992,12 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n-    tcx.infer_ctxt(param_env)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "aa2c9802e54737bff9bf52eb372ee1740f704129", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -26,12 +26,14 @@ use middle::lang_items;\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   param_env: ty::ParamEnv<'tcx>,\n                                    body_id: ast::NodeId,\n                                    ty: Ty<'tcx>,\n                                    span: Span)\n                                    -> Option<Vec<traits::PredicateObligation<'tcx>>>\n {\n     let mut wf = WfPredicates { infcx: infcx,\n+                                param_env: param_env,\n                                 body_id: body_id,\n                                 span: span,\n                                 out: vec![] };\n@@ -50,23 +52,25 @@ pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>,\n                                          body_id: ast::NodeId,\n                                          trait_ref: &ty::TraitRef<'tcx>,\n                                          span: Span)\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n     wf.compute_trait_ref(trait_ref);\n     wf.normalize()\n }\n \n pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             param_env: ty::ParamEnv<'tcx>,\n                                              body_id: ast::NodeId,\n                                              predicate: &ty::Predicate<'tcx>,\n                                              span: Span)\n                                              -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n@@ -126,6 +130,7 @@ pub enum ImpliedBound<'tcx> {\n /// the `ImpliedBound` type for more details.\n pub fn implied_bounds<'a, 'gcx, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     span: Span)\n@@ -148,7 +153,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n-        let obligations = obligations(infcx, body_id, ty, span).unwrap_or(vec![]);\n+        let obligations = obligations(infcx, param_env, body_id, ty, span).unwrap_or(vec![]);\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n@@ -231,6 +236,7 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n \n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n@@ -244,11 +250,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n+        let param_env = self.param_env;\n         self.out.iter()\n                 .inspect(|pred| assert!(!pred.has_escaping_regions()))\n                 .flat_map(|pred| {\n                     let mut selcx = traits::SelectionContext::new(infcx);\n-                    let pred = traits::normalize(&mut selcx, cause.clone(), pred);\n+                    let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n                     once(pred.value).chain(pred.obligations)\n                 })\n                 .collect()\n@@ -261,10 +268,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         self.out.extend(obligations);\n \n         let cause = self.cause(traits::MiscObligation);\n+        let param_env = self.param_env;\n         self.out.extend(\n             trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n+                                                              param_env,\n                                                               ty::Predicate::WellFormed(ty))));\n     }\n \n@@ -280,7 +289,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         if !data.has_escaping_regions() {\n             let predicate = data.trait_ref.to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n-            self.out.push(traits::Obligation::new(cause, predicate));\n+            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n     }\n \n@@ -291,7 +300,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n-            self.out.push(traits::Obligation::new(cause, trait_ref.to_predicate()));\n+            self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));\n         }\n     }\n \n@@ -301,6 +310,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n         let mut subtys = ty0.walk();\n+        let param_env = self.param_env;\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n                 ty::TyBool |\n@@ -350,6 +360,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                         self.out.push(\n                             traits::Obligation::new(\n                                 cause,\n+                                param_env,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder(\n                                         ty::OutlivesPredicate(mt.ty, r)))));\n@@ -389,12 +400,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // checking those\n \n                     let cause = self.cause(traits::MiscObligation);\n-\n                     let component_traits =\n                         data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n+                            param_env,\n                             ty::Predicate::ObjectSafe(did)\n                         ))\n                     );\n@@ -422,7 +433,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                         let cause = self.cause(traits::MiscObligation);\n                         self.out.push( // ...not the type we started from, so we made progress.\n-                            traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+                            traits::Obligation::new(cause,\n+                                                    self.param_env,\n+                                                    ty::Predicate::WellFormed(ty)));\n                     } else {\n                         // Yes, resolved, proceed with the\n                         // result. Should never return false because\n@@ -448,7 +461,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates\n                   .into_iter()\n-                  .map(|pred| traits::Obligation::new(cause.clone(), pred))\n+                  .map(|pred| traits::Obligation::new(cause.clone(),\n+                                                      self.param_env,\n+                                                      pred))\n                   .filter(|pred| !pred.has_escaping_regions())\n                   .collect()\n     }\n@@ -497,7 +512,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n-                self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n+                self.out.push(traits::Obligation::new(cause,\n+                                                      self.param_env,\n+                                                      outlives.to_predicate()));\n             }\n         }\n     }"}, {"sha": "122a37ee32aeab1b9c3ed0db03770170ac498a5e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -90,7 +90,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParamEnv<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -191,15 +191,17 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n+    let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n+    let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,\n         move_data: move_data,\n         all_loans: all_loans,\n-        param_env: &infcx.param_env\n+        param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "85a09969ac81c68cd950cd15ac9de31566b3bd11", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -38,9 +38,10 @@ mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n-                                    -> (Vec<Loan<'tcx>>,\n-                                        move_data::MoveData<'tcx>) {\n+                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n+    let def_id = bccx.tcx.hir.body_owner_def_id(body);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n+    let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         infcx: &infcx,\n@@ -51,7 +52,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;"}, {"sha": "539f1ff3730ee3a162281e67fcb467d3e08d1278", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                      lp: &LoanPath<'tcx>,\n                                      the_move: &move_data::Move,\n                                      moved_lp: &LoanPath<'tcx>,\n-                                     _param_env: &ty::ParamEnv<'tcx>) {\n+                                     _param_env: ty::ParamEnv<'tcx>) {\n         let (verb, verb_participle) = match use_kind {\n             MovedInUse => (\"use\", \"used\"),\n             MovedInCapture => (\"capture\", \"captured\"),"}, {"sha": "dd26a3e611f8809545a9b938d061401a0a4a794d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -517,11 +517,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt((cx.tables, cx.param_env)).enter(|infcx| {\n+    cx.tcx.infer_ctxt(cx.tables).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx).walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx, cx.param_env).walk_expr(guard);\n     });\n }\n "}, {"sha": "3d07ffc2bc77aefda074e589a1267e478de2b3c7", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -483,9 +483,11 @@ fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.infer_ctxt(Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                 param_env,\n                                                  trait_ref.to_poly_trait_predicate());\n         let selection = match selcx.select(&obligation) {\n             Ok(Some(vtable)) => vtable,"}, {"sha": "3a4729e64548a732d74aa73f5be1d9c138ea598c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -951,12 +951,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.hir.span(expr_id);\n+                    let param_env = tcx.param_env(method.def_id);\n                     let obligation =\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n+                                                param_env,\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    let param_env = tcx.param_env(method.def_id);\n-                    tcx.infer_ctxt(param_env).enter(|infcx| {\n+                    tcx.infer_ctxt(()).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "08a5cb37e5788a4b545fac5048e77444c0349e7c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -171,8 +171,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = tcx.param_env(tcx.hir.local_def_id(ctor_id));\n-        tcx.infer_ctxt(pe).enter(|infcx| {\n+        tcx.infer_ctxt(()).enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n "}, {"sha": "5b7b52a72b0ab4c625c19b24d863def31b7c2b73", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -35,6 +35,7 @@ use std::rc::Rc;\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub region_maps: Rc<RegionMaps>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n@@ -64,6 +65,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let src_id = src.item_id();\n         let src_def_id = tcx.hir.local_def_id(src_id);\n \n+        let param_env = tcx.param_env(src_def_id);\n         let region_maps = tcx.region_maps(src_def_id);\n \n         let attrs = tcx.hir.attrs(src_id);\n@@ -80,7 +82,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx { tcx, infcx, region_maps, constness, src, check_overflow }\n+        Cx { tcx, infcx, param_env, region_maps, constness, src, check_overflow }\n     }\n }\n \n@@ -169,12 +171,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n-            bug!(\"MIR: Cx::needs_drop({}) got \\\n+        let (ty, param_env) = self.tcx.lift_to_global(&(ty, self.param_env)).unwrap_or_else(|| {\n+            bug!(\"MIR: Cx::needs_drop({:?}, {:?}) got \\\n                   type with inference types/regions\",\n-                 ty);\n+                 ty, self.param_env);\n         });\n-        ty.needs_drop(self.tcx.global_tcx(), self.infcx.param_env)\n+        ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "ef88e813a50c60bf54691ab28010fe720bbb7f20", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -998,10 +998,13 @@ impl MirPass for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt(Reveal::UserFacing).enter(|infcx| {\n+            tcx.infer_ctxt(()).enter(|infcx| {\n+                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_bound(&infcx, ty,\n+                fulfillment_cx.register_bound(&infcx,\n+                                              param_env,\n+                                              ty,\n                                               tcx.require_lang_item(lang_items::SyncTraitLangItem),\n                                               cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {"}, {"sha": "fb162f354e991d11b4a2ce2893bb0257c105846b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -320,19 +320,24 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, body_id: ast::NodeId) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+           body_id: ast::NodeId,\n+           param_env: ty::ParamEnv<'gcx>)\n+           -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP,\n-            body_id: body_id,\n+            body_id,\n+            param_env,\n             reported_errors: FxHashSet(),\n         }\n     }\n@@ -351,14 +356,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn sub_types(&mut self, sup: Ty<'tcx>, sub: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, &self.misc(self.last_span), sup, sub)\n+        self.infcx.sub_types(false, &self.misc(self.last_span), self.param_env, sup, sub)\n             .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.eq_types(false, &self.misc(span), a, b)\n+        self.infcx.eq_types(false, &self.misc(span), self.param_env, a, b)\n             .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n@@ -665,7 +670,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         let span = local_decl.source_info.span;\n         let ty = local_decl.ty;\n-        if !ty.is_sized(self.tcx().global_tcx(), self.infcx.param_env(), span) {\n+        if !ty.is_sized(self.tcx().global_tcx(), self.param_env, span) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough\n@@ -706,7 +711,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let mut selcx = traits::SelectionContext::new(self.infcx);\n         let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n         let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, self.param_env, cause, value);\n \n         debug!(\"normalize: value={:?} obligations={:?}\",\n                value,\n@@ -752,8 +757,8 @@ impl MirPass for TypeckMir {\n             return;\n         }\n         let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt(param_env).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, item_id);\n+        tcx.infer_ctxt(()).enter(|infcx| {\n+            let mut checker = TypeChecker::new(&infcx, item_id, param_env);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "65a9334bbae19512dbf8892ee2df3da9673274a7", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -139,10 +139,10 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let outer_penv = self.tcx.infer_ctxt(body_id).enter(|infcx| {\n-            let param_env = infcx.param_env.clone();\n+            let param_env = self.tcx.param_env(item_def_id);\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             let region_maps = &self.tcx.region_maps(item_def_id);\n-            euv::ExprUseVisitor::new(self, region_maps, &infcx).consume_body(body);\n+            euv::ExprUseVisitor::new(self, region_maps, &infcx, param_env).consume_body(body);\n             outer_penv\n         });\n "}, {"sha": "151de5ac98df9abb2dae6ffeb60a1c8b8b0ea720", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -23,12 +23,12 @@ use monomorphize::Instance;\n use partitioning::CodegenUnit;\n use type_::Type;\n use rustc_data_structures::base_n;\n+use rustc::session::config::{self, NoDebugInfo};\n+use rustc::session::Session;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use session::config::{self, NoDebugInfo};\n-use session::Session;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};"}, {"sha": "6aac9dc42ee02bda67e747fb6738600259fc4116", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -118,13 +118,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n         let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let obligation = traits::Obligation::new(cause.clone(), trait_ref.to_predicate());\n+        let obligation = traits::Obligation::new(cause.clone(),\n+                                                 self.fcx.param_env,\n+                                                 trait_ref.to_predicate());\n         if !selcx.evaluate_obligation(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n         let normalized = traits::normalize_projection_type(&mut selcx,\n+                                                           self.fcx.param_env,\n                                                            ty::ProjectionTy::from_ref_and_name(\n                                                                tcx,\n                                                                trait_ref,"}, {"sha": "91aeade65aa4c2b57a5ffd1f7d263845c769cc69", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -555,6 +555,6 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-        traits::type_known_to_meet_bound(self, ty, lang_item, span)\n+        traits::type_known_to_meet_bound(self, self.param_env, ty, lang_item, span)\n     }\n }"}, {"sha": "f041db43e16d757c1e80bddceea92e1cba623fbb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -81,9 +81,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n-                                                            body.value.id, &fn_sig);\n+                                                            body.value.id,\n+                                                            self.param_env,\n+                                                            &fn_sig);\n \n-        check_fn(self, fn_sig, decl, expr.id, body);\n+        check_fn(self, self.param_env, fn_sig, decl, expr.id, body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "b1b4e099626cfb422967f2b9a32a7c26551c946f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -137,9 +137,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n-                self.lub(false, trace, &a, &b)\n+                self.lub(false, trace, self.fcx.param_env, &a, &b)\n             } else {\n-                self.sub(false, trace, &a, &b)\n+                self.sub(false, trace, self.fcx.param_env, &a, &b)\n             }\n         })\n     }\n@@ -511,9 +511,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.cause.span, self.body_id);\n-        queue.push_back(self.tcx\n-            .predicate_for_trait_def(cause, coerce_unsized_did, 0,\n-                                     coerce_source, &[coerce_target]));\n+        queue.push_back(self.tcx.predicate_for_trait_def(self.fcx.param_env,\n+                                                         cause,\n+                                                         coerce_unsized_did,\n+                                                         0,\n+                                                         coerce_source,\n+                                                         &[coerce_target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -775,13 +778,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match (&prev_ty.sty, &new_ty.sty) {\n             (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n-                let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n+                let fty = self.lub(true, trace.clone(), self.param_env, &a_fty, &b_fty)\n                               .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n                 if a_def_id == b_def_id {\n                     // Same function, maybe the parameters match.\n                     let substs = self.commit_if_ok(|_| {\n-                        self.lub(true, trace.clone(), &a_substs, &b_substs)\n+                        self.lub(true, trace.clone(), self.param_env, &a_substs, &b_substs)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     });\n \n@@ -850,7 +853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if !noop {\n                 return self.commit_if_ok(|_| {\n-                    self.lub(true, trace.clone(), &prev_ty, &new_ty)\n+                    self.lub(true, trace.clone(), self.param_env, &prev_ty, &new_ty)\n                         .map(|ok| self.register_infer_ok_obligations(ok))\n                 });\n             }\n@@ -863,7 +866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Err(e)\n                 } else {\n                     self.commit_if_ok(|_| {\n-                        self.lub(true, trace, &prev_ty, &new_ty)\n+                        self.lub(true, trace, self.param_env, &prev_ty, &new_ty)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     })\n                 }\n@@ -1106,7 +1109,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             // Another example is `break` with no argument expression.\n             assert!(expression_ty.is_nil());\n             assert!(expression_ty.is_nil(), \"if let hack without unit type\");\n-            fcx.eq_types(label_expression_as_expected, cause, expression_ty, self.merged_ty())\n+            fcx.eq_types(label_expression_as_expected, cause, fcx.param_env, expression_ty, self.merged_ty())\n                .map(|infer_ok| {\n                    fcx.register_infer_ok_obligations(infer_ok);\n                    expression_ty"}, {"sha": "50e7e89a5f61a93afa5790fdf03abe5e56cd6079", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -219,12 +219,12 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                          param_env,\n                                                          normalize_cause.clone());\n \n-    tcx.infer_ctxt(param_env).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n-               infcx.param_env.caller_bounds);\n+               param_env.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n@@ -234,10 +234,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n+                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n \n             inh.register_predicates(obligations);\n-            inh.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n+            inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -270,6 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n+                                              param_env,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n@@ -282,12 +283,13 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n+                                              param_env,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.sub_types(false, &cause, impl_fty, trait_fty)\n+        let sub_result = infcx.sub_types(false, &cause, param_env, impl_fty, trait_fty)\n                               .map(|InferOk { obligations, .. }| {\n                                   inh.register_predicates(obligations);\n                               });\n@@ -298,6 +300,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    trait_fty);\n \n             let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(&infcx,\n+                                                                                    param_env,\n                                                                                     &terr,\n                                                                                     &cause,\n                                                                                     impl_m,\n@@ -345,11 +348,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // pass around temporarily.\n             let region_maps = RegionMaps::new();\n             let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(\n-                &infcx.param_env.caller_bounds);\n+            free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n         } else {\n-            let fcx = FnCtxt::new(&inh, impl_m_node_id);\n+            let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n             fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n         }\n \n@@ -400,6 +402,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                                     param_env: ty::ParamEnv<'tcx>,\n                                                      terr: &TypeError,\n                                                      cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n@@ -458,14 +461,21 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n                          .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                             match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n+                             match infcx.sub_types(true,\n+                                                   &cause,\n+                                                   param_env,\n+                                                   trait_arg_ty,\n+                                                   impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false, &cause, impl_sig.output(),\n+                             if infcx.sub_types(false,\n+                                                &cause,\n+                                                param_env,\n+                                                impl_sig.output(),\n                                                 trait_sig.output())\n                                      .is_err() {\n                                          (impl_m_output.span(), Some(trait_m_output.span()))\n@@ -714,7 +724,8 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    tcx.infer_ctxt(Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n \n@@ -737,17 +748,19 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n                                                         impl_c_node_id,\n+                                                        param_env,\n                                                         &impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n         let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n                                                          impl_c_node_id,\n+                                                         param_env,\n                                                          &trait_ty);\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-        let err = infcx.sub_types(false, &cause, impl_ty, trait_ty)\n+        let err = infcx.sub_types(false, &cause, param_env, impl_ty, trait_ty)\n             .map(|ok| inh.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n@@ -795,7 +808,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             return;\n         }\n \n-        let fcx = FnCtxt::new(&inh, impl_c_node_id);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_c_node_id);\n         fcx.regionck_item(impl_c_node_id, impl_c_span, &[]);\n     });\n }"}, {"sha": "9c3dcc3f0e0ebac055984e7e6e251b031aa5b92e", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n         let cause = self.misc(sp);\n-        match self.sub_types(false, &cause, actual, expected) {\n+        match self.sub_types(false, &cause, self.param_env, actual, expected) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             },\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n                                      actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n-        match self.eq_types(false, cause, actual, expected) {\n+        match self.eq_types(false, cause, self.param_env, actual, expected) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "024d1f09f1cf70d70a872a5c899b6841d4800306", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -79,8 +79,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = tcx.param_env(self_type_did);\n-    tcx.infer_ctxt(impl_param_env).enter(|ref infcx| {\n+    tcx.infer_ctxt(()).enter(|ref infcx| {\n+        let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -92,7 +92,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n-        match infcx.eq_types(true, cause, named_type, fresh_impl_self_ty) {\n+        match infcx.eq_types(true, cause, impl_param_env, named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }"}, {"sha": "a5cf4dd2683041de04a091128edae82a1056baa6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.sub_types(false, &self.misc(self.span), self_ty, method_self_ty) {\n+        match self.sub_types(false, &self.misc(self.span), self.param_env, self_ty, method_self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "73c1215f275fbd8612ba0dbdab7ce4b47cc7be49", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -205,7 +205,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Construct an obligation\n         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n         let obligation =\n-            traits::Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n+            traits::Obligation::misc(span,\n+                                     self.body_id,\n+                                     self.param_env,\n+                                     poly_trait_ref.to_predicate());\n \n         // Now we want to know if this can be matched\n         let mut selcx = traits::SelectionContext::new(self);\n@@ -262,14 +265,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!bounds.has_escaping_regions());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n-        obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n+        obligations.extend(traits::predicates_for_generics(cause.clone(),\n+                                                           self.param_env,\n+                                                           &bounds));\n \n         // Also add an obligation for the method type being well-formed.\n         let method_ty = tcx.mk_fn_ptr(ty::Binder(fn_sig));\n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n                obligation);\n-        obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n+        obligations.push(traits::Obligation::new(cause,\n+                                                 self.param_env,\n+                                                 ty::Predicate::WellFormed(method_ty)));\n \n         let callee = MethodCallee {\n             def_id: def_id,"}, {"sha": "449c0f0281044105173a5a10a319a33c68b1839f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, cause, &xform_self_ty);\n+                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n             debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n                    xform_self_ty);\n \n@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     let output = fty.output().subst(self.tcx, substs);\n                     let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &output);\n-                    self.can_sub_types(output, expected).is_ok()\n+                    self.can_sub_types(self.param_env, output, expected).is_ok()\n                 })\n             }\n             _ => false,\n@@ -751,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, cause, &xform_self_ty);\n+                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n \n             debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n@@ -885,7 +885,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        substs,\n                        bound);\n \n-                if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                if self.can_equate(self.param_env, &step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n@@ -1145,6 +1145,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self.sub_types(false,\n                                                        &ObligationCause::dummy(),\n+                                                       self.param_env,\n                                                        self_ty,\n                                                        probe.xform_self_ty) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1182,10 +1183,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_bounds = self.tcx.predicates_of(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                traits::normalize(selcx, cause.clone(), &impl_bounds);\n+                traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n \n             // Convert the bounds into obligations.\n-            let obligations = traits::predicates_for_generics(cause.clone(), &impl_bounds);\n+            let obligations = traits::predicates_for_generics(cause.clone(), self.param_env, &impl_bounds);\n             debug!(\"impl_obligations={:?}\", obligations);\n \n             // Evaluate those obligations to see if they might possibly hold."}, {"sha": "c496053a1543bea4420ed4049d883c55ac93f0b6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -57,7 +57,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation =\n-                            Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n+                            Obligation::misc(span,\n+                                             self.body_id,\n+                                             self.param_env,\n+                                             poly_trait_ref.to_predicate());\n                         SelectionContext::new(self).evaluate_obligation(&obligation)\n                     })\n                 })"}, {"sha": "055ce94d201057a146b97ec3ffed90e4c665283f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -450,6 +450,14 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n+    /// The parameter environment used for proving trait obligations\n+    /// in this function. This can change when we descend into\n+    /// closures (as they bring new things into scope), hence it is\n+    /// not part of `Inherited` (as of the time of this writing,\n+    /// closures do not yet change the environment, but they will\n+    /// eventually).\n+    param_env: ty::ParamEnv<'tcx>,\n+\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -528,9 +536,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = tcx.param_env(def_id);\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt((tables, param_env)),\n+            infcx: tcx.infer_ctxt(tables),\n             def_id,\n         }\n     }\n@@ -590,16 +597,18 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, value);\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n \n     fn normalize_associated_types_in_as_infer_ok<T>(&self,\n                                                     span: Span,\n                                                     body_id: ast::NodeId,\n+                                                    param_env: ty::ParamEnv<'tcx>,\n                                                     value: &T)\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n@@ -608,7 +617,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, param_env, cause, value);\n         debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n             value,\n             obligations);\n@@ -797,6 +806,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let body = tcx.hir.body(body_id);\n \n     Inherited::build(tcx, def_id).enter(|inh| {\n+        let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.type_of(def_id).fn_sig();\n \n@@ -806,11 +816,14 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let fn_sig =\n                 inh.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n+                inh.normalize_associated_types_in(body.value.span,\n+                                                  body_id.node_id,\n+                                                  param_env,\n+                                                  &fn_sig);\n \n-            check_fn(&inh, fn_sig, decl, id, body)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body)\n         } else {\n-            let fcx = FnCtxt::new(&inh, body.value.id);\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n             let expected_type = tcx.type_of(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -919,6 +932,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n+                            param_env: ty::ParamEnv<'tcx>,\n                             fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n@@ -927,11 +941,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n {\n     let mut fn_sig = fn_sig.clone();\n \n-    debug!(\"check_fn(sig={:?}, fn_id={})\", fn_sig, fn_id);\n+    debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, body.value.id);\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     let ret_ty = fn_sig.output();\n@@ -1633,10 +1647,12 @@ enum TupleArgumentsFlag {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             body_id: body_id,\n+            param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n@@ -1870,7 +1886,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Require that the predicate holds for the concrete type.\n                     let cause = traits::ObligationCause::new(span, self.body_id,\n                                                              traits::ReturnType);\n-                    self.register_predicate(traits::Obligation::new(cause, predicate));\n+                    self.register_predicate(traits::Obligation::new(cause,\n+                                                                    self.param_env,\n+                                                                    predicate));\n                 }\n \n                 ty_var\n@@ -1883,15 +1901,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, value);\n-        self.register_infer_ok_obligations(ok)\n+        self.inh.normalize_associated_types_in(span, self.body_id, self.param_env, value)\n     }\n \n     fn normalize_associated_types_in_as_infer_ok<T>(&self, span: Span, value: &T)\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in_as_infer_ok(span, self.body_id, value)\n+        self.inh.normalize_associated_types_in_as_infer_ok(span, self.body_id, self.param_env, value)\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -1929,7 +1946,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           cause: traits::ObligationCause<'tcx>)\n     {\n         self.fulfillment_cx.borrow_mut()\n-            .register_bound(self, ty, def_id, cause);\n+                           .register_bound(self, self.param_env, ty, def_id, cause);\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n@@ -1970,7 +1987,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // WF obligations never themselves fail, so no real need to give a detailed cause:\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_predicate(traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+        self.register_predicate(traits::Obligation::new(cause,\n+                                                        self.param_env,\n+                                                        ty::Predicate::WellFormed(ty)));\n     }\n \n     pub fn register_old_wf_obligation(&self,\n@@ -2023,7 +2042,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"add_obligations_for_parameters(predicates={:?})\",\n                predicates);\n \n-        for obligation in traits::predicates_for_generics(cause, predicates) {\n+        for obligation in traits::predicates_for_generics(cause, self.param_env, predicates) {\n             self.register_predicate(obligation);\n         }\n     }\n@@ -2704,7 +2723,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.sub_types(false, &origin, formal_ret, ret_ty);\n+                let ures = self.sub_types(false, &origin, self.param_env, formal_ret, ret_ty);\n \n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -4199,7 +4218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => return,\n         };\n         let last_expr_ty = self.expr_ty(last_expr);\n-        if self.can_sub_types(last_expr_ty, expected_ty).is_err() {\n+        if self.can_sub_types(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n@@ -4459,7 +4478,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty = self.tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n-            match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {\n+            match self.sub_types(false, &self.misc(span), self.param_env, self_ty, impl_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     span_bug!(span,"}, {"sha": "4d69b37b113cfbf2bfaf36b49e00f583d15d23ea", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -238,9 +238,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             lhs_ty);\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n-                            if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(ty_mut.ty, &[rhs_ty],\n-                                                      Op::Binary(op, is_assign)).is_ok() {\n+                            if {\n+                                !self.infcx.type_moves_by_default(self.param_env,\n+                                                                  ty_mut.ty,\n+                                                                  lhs_expr.span) &&\n+                                    self.lookup_op_method(ty_mut.ty,\n+                                                          &[rhs_ty],\n+                                                          Op::Binary(op, is_assign))\n+                                        .is_ok()\n+                            } {\n                                 err.note(\n                                     &format!(\n                                         \"this is a reference to a type that `{}` can be applied \\"}, {"sha": "db817efe93d4a3279bb25f858e60d2f2c5c9f551", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = ty::wf::implied_bounds(self, body_id, ty, span);\n+            let implied_bounds = ty::wf::implied_bounds(self, self.fcx.param_env, body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n             self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n@@ -1660,7 +1660,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n                     // check whether this predicate applies to our current projection\n                     let cause = self.fcx.misc(span);\n-                    match self.eq_types(false, &cause, ty, outlives.0) {\n+                    match self.eq_types(false, &cause, self.fcx.param_env, ty, outlives.0) {\n                         Ok(ok) => {\n                             self.register_infer_ok_obligations(ok);\n                             Ok(outlives.1)"}, {"sha": "25f5418bea9c5ab8c13e616185625dba0380680a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -166,9 +166,11 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         {\n             let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n             let region_maps = &self.fcx.tcx.region_maps(body_owner_def_id);\n+            let param_env = self.fcx.param_env;\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n+                                                  param_env,\n                                                   region_maps,\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true"}, {"sha": "26f708e934562ba704458f0c361e4dd7d81eda8f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -37,7 +37,8 @@ struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n-    span: Span\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n@@ -48,8 +49,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let code = self.code.clone();\n         let id = self.id;\n         let span = self.span;\n+        let param_env = self.param_env;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, id);\n+            let fcx = FnCtxt::new(&inh, param_env, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n                 tcx: fcx.tcx.global_tcx(),\n                 code: code\n@@ -206,11 +208,13 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n                     -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+        let def_id = self.tcx.hir.local_def_id(id);\n         CheckWfFcxBuilder {\n-            inherited: Inherited::build(self.tcx, self.tcx.hir.local_def_id(id)),\n+            inherited: Inherited::build(self.tcx, def_id),\n             code: self.code.clone(),\n             id: id,\n-            span: span\n+            span: span,\n+            param_env: self.tcx.param_env(def_id),\n         }\n     }\n \n@@ -374,6 +378,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                             ast_trait_ref.path.span, &trait_ref);\n                     let obligations =\n                         ty::wf::trait_obligations(fcx,\n+                                                  fcx.param_env,\n                                                   fcx.body_id,\n                                                   &trait_ref,\n                                                   ast_trait_ref.path.span);\n@@ -405,6 +410,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             predicates.predicates\n                       .iter()\n                       .flat_map(|p| ty::wf::predicate_obligations(fcx,\n+                                                                  fcx.param_env,\n                                                                   fcx.body_id,\n                                                                   p,\n                                                                   span));"}, {"sha": "8c2679f1bbf532b7e72b3823cf92bc6c4312b504", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -208,7 +208,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(param_env).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -308,7 +308,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // we may have to evaluate constraint\n                         // expressions in the course of execution.)\n                         // See e.g. #41936.\n-                        if let Ok(ok) = infcx.eq_types(false, &cause, b, a) {\n+                        if let Ok(ok) = infcx.eq_types(false, &cause, param_env, b, a) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }\n@@ -376,7 +376,12 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);\n-        let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+        let predicate = tcx.predicate_for_trait_def(param_env,\n+                                                    cause,\n+                                                    trait_def_id,\n+                                                    0,\n+                                                    source,\n+                                                    &[target]);\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n         // Check that all transitive obligations are satisfied.\n@@ -387,8 +392,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Finally, resolve all regions.\n         let region_maps = RegionMaps::new();\n         let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(&infcx.param_env\n-            .caller_bounds);\n+        free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n \n         CoerceUnsizedInfo {"}, {"sha": "afeb85a7a065698f68593887929e818a86630413", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n \n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt(Reveal::UserFacing).enter(|infcx| {\n+                self.tcx.infer_ctxt(()).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "ac0e360adb08a853a400a877abe57842e5fdfbd7", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb0f0dc2e7f50b12272e274b084c16b048510db/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5fb0f0dc2e7f50b12272e274b084c16b048510db", "patch": "@@ -155,9 +155,10 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt(Reveal::UserFacing).enter(|ref infcx| {\n+    tcx.infer_ctxt(()).enter(|ref infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut fulfill_cx = FulfillmentContext::new();\n-        match infcx.eq_types(false, &cause, expected, actual) {\n+        match infcx.eq_types(false, &cause, param_env, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);\n             }"}]}