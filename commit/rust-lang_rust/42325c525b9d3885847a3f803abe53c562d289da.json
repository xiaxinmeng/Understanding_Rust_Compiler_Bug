{"sha": "42325c525b9d3885847a3f803abe53c562d289da", "node_id": "C_kwDOAAsO6NoAKDQyMzI1YzUyNWI5ZDM4ODU4NDdhM2Y4MDNhYmU1M2M1NjJkMjg5ZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-11T20:11:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-11T20:11:07Z"}, "message": "Auto merge of #104293 - Manishearth:rollup-xj92d0k, r=Manishearth\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #95292 (Allow specialized const trait impls.)\n - #100386 (Make `Sized` coinductive, again)\n - #102215 (Implement the `+whole-archive` modifier for `wasm-ld`)\n - #103468 (Fix unused lint and parser caring about spaces to won't produce invalid code)\n - #103531 (Suggest calling the instance method of the same name when method not found)\n - #103960 (piece of diagnostic migrate)\n - #104051 (update Miri)\n - #104129 (rustdoc: use javascript to layout notable traits popups)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1dff3f83bd600c5e0be3762b380d28a3d238d320", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dff3f83bd600c5e0be3762b380d28a3d238d320"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42325c525b9d3885847a3f803abe53c562d289da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42325c525b9d3885847a3f803abe53c562d289da", "html_url": "https://github.com/rust-lang/rust/commit/42325c525b9d3885847a3f803abe53c562d289da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42325c525b9d3885847a3f803abe53c562d289da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "html_url": "https://github.com/rust-lang/rust/commit/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf"}, {"sha": "b74d042be2c237fa1a29e87ed7501410974a0dd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b74d042be2c237fa1a29e87ed7501410974a0dd9", "html_url": "https://github.com/rust-lang/rust/commit/b74d042be2c237fa1a29e87ed7501410974a0dd9"}], "stats": {"total": 2712, "additions": 2191, "deletions": 521}, "files": [{"sha": "563ff056ae467245b67f5bacee32f7c2b5817ff0", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;"}, {"sha": "01be379120dc7483c088daa4005b744bb386dfb8", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -8,9 +8,18 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     pub(crate) fn cannot_move_when_borrowed(\n         &self,\n         span: Span,\n-        desc: &str,\n+        borrow_span: Span,\n+        place: &str,\n+        borrow_place: &str,\n+        value_place: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n+        self.infcx.tcx.sess.create_err(crate::session_diagnostics::MoveBorrow {\n+            place,\n+            span,\n+            borrow_place,\n+            value_place,\n+            borrow_span,\n+        })\n     }\n \n     pub(crate) fn cannot_use_when_mutably_borrowed("}, {"sha": "11b31c3f14028e72dbe20df6d6e3db3a6ec21f1a", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::visit::TyContext;\n use rustc_middle::mir::visit::Visitor;"}, {"sha": "84a93e5f72e9dd3b508782306ea15fc46d653995", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;"}, {"sha": "86da767f322738fae52365b52cc0366d1b6fe311", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;"}, {"sha": "8070c0e6710ee0e1288cb9a0284fab5d47f8617f", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, Place};"}, {"sha": "8e62a0198be46987733c4ad7c0608aff65cc84bf", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_middle::mir::visit::{\n     MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext,\n };"}, {"sha": "b99bfda1a51fe661c6366505486bca5d9c8f76b8", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;"}, {"sha": "9e0aa57b2553fba87dfbab9ef2f19689da0a12ce", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -224,10 +224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            use_spans.var_span_label_path_only(\n-                &mut err,\n-                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-            );\n+            use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n             if !is_loop_move {\n                 err.span_label(\n@@ -404,10 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let used = desired_action.as_general_verb_in_past_tense();\n         let mut err =\n             struct_span_err!(self, span, E0381, \"{used} binding {desc}{isnt_initialized}\");\n-        use_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-        );\n+        use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n         if let InitializationRequiringAction::PartialAssignment\n         | InitializationRequiringAction::Assignment = desired_action\n@@ -673,16 +667,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let move_spans = self.move_spans(place.as_ref(), location);\n         let span = move_spans.args_or_use();\n \n-        let mut err =\n-            self.cannot_move_when_borrowed(span, &self.describe_any_place(place.as_ref()));\n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n-        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n-\n-        borrow_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", borrow_spans.describe()),\n+        let mut err = self.cannot_move_when_borrowed(\n+            span,\n+            borrow_span,\n+            &self.describe_any_place(place.as_ref()),\n+            &borrow_msg,\n+            &value_msg,\n         );\n \n+        borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n+\n         move_spans.var_span_label(\n             &mut err,\n             format!(\"move occurs due to use{}\", move_spans.describe()),\n@@ -724,22 +718,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-        borrow_spans.var_subdiag(\n-            &mut err,\n-            |var_span| {\n-                use crate::session_diagnostics::CaptureVarCause::*;\n-                let place = &borrow.borrowed_place;\n-                let desc_place = self.describe_any_place(place.as_ref());\n-                match borrow_spans {\n-                    UseSpans::ClosureUse { generator_kind, .. } => match generator_kind {\n-                        Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n-                        None => BorrowUsePlaceClosure { place: desc_place, var_span },\n-                    },\n-                    _ => BorrowUsePlace { place: desc_place, var_span },\n-                }\n-            },\n-            \"mutable\",\n-        );\n+        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_any_place(place.as_ref());\n+            match kind {\n+                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic("}, {"sha": "498e9834354b7ff851da549230f7b2707ef43c28", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::BTreeSet;\n \n use rustc_middle::mir::visit::{PlaceContext, Visitor};"}, {"sha": "15f42e26cbf4a7aeca1bac947ac0b58b4836c3aa", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::VecDeque;\n use std::rc::Rc;\n "}, {"sha": "7f26af67c71b214485777b90ea0e97029650bafb", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -595,11 +595,34 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the use of the captured variable, if it exists.\n-    // only adds label to the `path_span`\n-    pub(super) fn var_span_label_path_only(self, err: &mut Diagnostic, message: impl Into<String>) {\n-        if let UseSpans::ClosureUse { path_span, .. } = self {\n-            err.span_label(path_span, message);\n+    /// Add a span label to the use of the captured variable, if it exists.\n+    /// only adds label to the `path_span`\n+    pub(super) fn var_path_only_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        action: crate::InitializationRequiringAction,\n+    ) {\n+        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n+        use crate::InitializationRequiringAction::*;\n+        if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n+            match generator_kind {\n+                Some(_) => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInGenerator { path_span },\n+                        MatchOn | Use => UseInGenerator { path_span },\n+                        Assignment => AssignInGenerator { path_span },\n+                        PartialAssignment => AssignPartInGenerator { path_span },\n+                    });\n+                }\n+                None => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInClosure { path_span },\n+                        MatchOn | Use => UseInClosure { path_span },\n+                        Assignment => AssignInClosure { path_span },\n+                        PartialAssignment => AssignPartInClosure { path_span },\n+                    });\n+                }\n+            }\n         }\n     }\n \n@@ -627,19 +650,28 @@ impl UseSpans<'_> {\n     pub(super) fn var_subdiag(\n         self,\n         err: &mut Diagnostic,\n-        f: impl Fn(Span) -> crate::session_diagnostics::CaptureVarCause,\n-        kind_desc: impl Into<String>,\n+        kind: Option<rustc_middle::mir::BorrowKind>,\n+        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n     ) {\n-        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n-            if capture_kind_span == path_span {\n-                err.subdiagnostic(f(capture_kind_span));\n-            } else {\n-                err.subdiagnostic(crate::session_diagnostics::CaptureVarKind {\n-                    kind_desc: kind_desc.into(),\n-                    kind_span: capture_kind_span,\n+        use crate::session_diagnostics::CaptureVarKind::*;\n+        if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n+            if capture_kind_span != path_span {\n+                err.subdiagnostic(match kind {\n+                    Some(kd) => match kd {\n+                        rustc_middle::mir::BorrowKind::Shared\n+                        | rustc_middle::mir::BorrowKind::Shallow\n+                        | rustc_middle::mir::BorrowKind::Unique => {\n+                            Immute { kind_span: capture_kind_span }\n+                        }\n+\n+                        rustc_middle::mir::BorrowKind::Mut { .. } => {\n+                            Mut { kind_span: capture_kind_span }\n+                        }\n+                    },\n+                    None => Move { kind_span: capture_kind_span },\n                 });\n-                err.subdiagnostic(f(path_span));\n-            }\n+            };\n+            err.subdiagnostic(f(generator_kind, path_span));\n         }\n     }\n "}, {"sha": "b385f95b67c6f992a12841c02b77b7bed01b8f35", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use crate::Upvar;\n use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexVec};"}, {"sha": "51ed27c167d3844971e445036bb0a4584524e210", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::location::{LocationIndex, LocationTable};\n use crate::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusFacts;"}, {"sha": "f5317a143aed7157d0801da0e688c7bd7a090246", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, NonDivergingIntrinsic, Place, Rvalue};"}, {"sha": "9fa7e218b1b6f65ceb09a92420043f5f823f41f1", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{BasicBlock, Body, Location};\n "}, {"sha": "b48f9f97daad8d76dc07b541f445206f55fa7e8c", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;"}, {"sha": "f8856b56d140bae139a7d069159b8bb813b28dd6", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n use rustc_data_structures::vec_map::VecMap;"}, {"sha": "f8a99a2699e6ff0cf3c89c3c62ab576f6278e72c", "filename": "compiler/rustc_borrowck/src/path_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::places_conflict;\n use crate::AccessDepth;"}, {"sha": "9f6b1fdfcb54085853bb49c34a070b95c3358ec7", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::LocalsStateAtExit;\n use rustc_hir as hir;\n use rustc_middle::mir::ProjectionElem;"}, {"sha": "8a87d1972ebf35613c8673285a0e43880112a666", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::ArtificialField;\n use crate::Overlap;\n use crate::{AccessDepth, Deep, Shallow};"}, {"sha": "6f281349863763f0cbb578f0a93102ef6ec19b81", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n //! place are formed by stripping away fields and derefs, except that\n //! we stop when we reach the deref of a shared reference. [...] \""}, {"sha": "6524b594e44dc02083d629688966c151ae0965c5", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! As part of generating the regions, if you enable `-Zdump-mir=nll`,\n //! we will generate an annotated copy of the MIR that includes the\n //! state of region inference. This code handles emitting the region"}, {"sha": "2e15586e03b3bb49ec35331d11cdeaa9d9026b25", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This module provides linkage between RegionInferenceContext and\n //! `rustc_graphviz` traits, specialized to attaching borrowck analysis\n //! data to rendered labels."}, {"sha": "167f664609698e8b26011e134c887d85855f7e79", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::constraints::ConstraintSccIndex;\n use crate::RegionInferenceContext;\n use itertools::Itertools;"}, {"sha": "7498ddccf196a1fc136f07cac6e20768c606ce60", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::SparseBitMatrix;\n use rustc_index::interval::IntervalSet;"}, {"sha": "084754830bdbfa8dda894e2f0621e6dd7ebe575d", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};"}, {"sha": "577332c0744b84dd8447af7ab3519a33ef18abe0", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -150,21 +150,70 @@ pub(crate) enum RequireStaticErr {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(borrowck_capture_kind_label)]\n-pub(crate) struct CaptureVarKind {\n-    pub kind_desc: String,\n-    #[primary_span]\n-    pub kind_span: Span,\n+pub(crate) enum CaptureVarPathUseCause {\n+    #[label(borrowck_borrow_due_to_use_generator)]\n+    BorrowInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_generator)]\n+    UseInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_generator)]\n+    AssignInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_generator)]\n+    AssignPartInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_borrow_due_to_use_closure)]\n+    BorrowInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_closure)]\n+    UseInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_closure)]\n+    AssignInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_closure)]\n+    AssignPartInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n }\n \n #[derive(Subdiagnostic)]\n-pub(crate) enum CaptureVarCause {\n-    #[label(borrowck_var_borrow_by_use_place)]\n-    BorrowUsePlace {\n-        place: String,\n+pub(crate) enum CaptureVarKind {\n+    #[label(borrowck_capture_immute)]\n+    Immute {\n         #[primary_span]\n-        var_span: Span,\n+        kind_span: Span,\n+    },\n+    #[label(borrowck_capture_mut)]\n+    Mut {\n+        #[primary_span]\n+        kind_span: Span,\n     },\n+    #[label(borrowck_capture_move)]\n+    Move {\n+        #[primary_span]\n+        kind_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarCause {\n     #[label(borrowck_var_borrow_by_use_place_in_generator)]\n     BorrowUsePlaceGenerator {\n         place: String,\n@@ -178,3 +227,16 @@ pub(crate) enum CaptureVarCause {\n         var_span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck_cannot_move_when_borrowed, code = \"E0505\")]\n+pub(crate) struct MoveBorrow<'a> {\n+    pub place: &'a str,\n+    pub borrow_place: &'a str,\n+    pub value_place: &'a str,\n+    #[primary_span]\n+    #[label(move_label)]\n+    pub span: Span,\n+    #[label]\n+    pub borrow_span: Span,\n+}"}, {"sha": "6ccc29b09c0a5d9646acb03f130f29ec579530a0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This pass type-checks the MIR to ensure it is not broken.\n \n use std::rc::Rc;"}, {"sha": "e297b1230ea0c58b2bf273cc8dbf886c9e495cb4", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{"}, {"sha": "7f0c2861f7e29014de16da9d8817dc50a7c8c6c6", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1260,11 +1260,11 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: &str, _verbatim: bool, _search_path: &[PathBuf]) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(\"-l\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n-        self.cmd.arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn gc_sections(&mut self, _keep_metadata: bool) {"}, {"sha": "de47ada826444e00644e0edfc357973969a21f20", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -70,3 +70,56 @@ borrowck_var_borrow_by_use_place_in_closure =\n \n borrowck_var_borrow_by_use_place =\n     borrow occurs due to use of {$place}\n+\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_assign_due_to_use_generator =\n+    assign occurs due to use in generator\n+\n+borrowck_assign_part_due_to_use_generator =\n+    assign to part occurs due to use in generator\n+\n+borrowck_borrow_due_to_use_closure =\n+    borrow occurs due to use in closure\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_assign_due_to_use_closure =\n+    assign occurs due to use in closure\n+\n+borrowck_assign_part_due_to_use_closure =\n+    assign to part occurs due to use in closure\n+\n+borrowck_capture_immute =\n+    capture is immutable because of use here\n+\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n+\n+borrowck_capture_move =\n+    capture is moved because of use here\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here"}, {"sha": "55cca0cd2d7b540b2a3edad210ada95d39fc6d67", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 98, "deletions": 22, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -69,6 +69,7 @@ use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -80,6 +81,7 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n+use tracing::instrument;\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -103,13 +105,11 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n }\n \n /// Check that `impl1` is a sound specialization\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n     if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n-        debug!(\n-            \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n-            impl1_def_id, impl2_def_id, impl2_substs\n-        );\n+        debug!(?impl2_def_id, ?impl2_substs);\n \n         let parent_substs = if impl2_node.is_from_trait() {\n             impl2_substs.to_vec()\n@@ -118,12 +118,33 @@ fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node\n         };\n \n         let span = tcx.def_span(impl1_def_id);\n+        check_constness(tcx, impl1_def_id, impl2_node, span);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n         check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n+/// Check that the specializing impl `impl1` is at least as const as the base\n+/// impl `impl2`\n+fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n+    if impl2_node.is_from_trait() {\n+        // This isn't a specialization\n+        return;\n+    }\n+\n+    let impl1_constness = tcx.constness(impl1_def_id.to_def_id());\n+    let impl2_constness = tcx.constness(impl2_node.def_id());\n+\n+    if let hir::Constness::Const = impl2_constness {\n+        if let hir::Constness::NotConst = impl1_constness {\n+            tcx.sess\n+                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n+                .emit();\n+        }\n+    }\n+}\n+\n /// Given a specializing impl `impl1`, and the base impl `impl2`, returns two\n /// substitutions `(S1, S2)` that equate their trait references. The returned\n /// types are expressed in terms of the generics of `impl1`.\n@@ -278,15 +299,15 @@ fn check_static_lifetimes<'tcx>(\n \n /// Check whether predicates on the specializing impl (`impl1`) are allowed.\n ///\n-/// Each predicate `P` must be:\n+/// Each predicate `P` must be one of:\n ///\n-/// * global (not reference any parameters)\n-/// * `T: Tr` predicate where `Tr` is an always-applicable trait\n-/// * on the base `impl impl2`\n-///     * Currently this check is done using syntactic equality, which is\n-///       conservative but generally sufficient.\n-/// * a well-formed predicate of a type argument of the trait being implemented,\n+/// * Global (not reference any parameters).\n+/// * A `T: Tr` predicate where `Tr` is an always-applicable trait.\n+/// * Present on the base impl `impl2`.\n+///     * This check is done using the `trait_predicates_eq` function below.\n+/// * A well-formed predicate of a type argument of the trait being implemented,\n ///   including the `Self`-type.\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl1_def_id: LocalDefId,\n@@ -322,10 +343,7 @@ fn check_predicates<'tcx>(\n         .map(|obligation| obligation.predicate)\n         .collect()\n     };\n-    debug!(\n-        \"check_always_applicable(\\nimpl1_predicates={:?},\\nimpl2_predicates={:?}\\n)\",\n-        impl1_predicates, impl2_predicates,\n-    );\n+    debug!(?impl1_predicates, ?impl2_predicates);\n \n     // Since impls of always applicable traits don't get to assume anything, we\n     // can also assume their supertraits apply.\n@@ -373,25 +391,83 @@ fn check_predicates<'tcx>(\n     );\n \n     for (predicate, span) in impl1_predicates {\n-        if !impl2_predicates.contains(&predicate) {\n+        if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {\n             check_specialization_on(tcx, predicate, span)\n         }\n     }\n }\n \n+/// Checks if some predicate on the specializing impl (`predicate1`) is the same\n+/// as some predicate on the base impl (`predicate2`).\n+///\n+/// This basically just checks syntactic equivalence, but is a little more\n+/// forgiving since we want to equate `T: Tr` with `T: ~const Tr` so this can work:\n+///\n+/// ```ignore (illustrative)\n+/// #[rustc_specialization_trait]\n+/// trait Specialize { }\n+///\n+/// impl<T: Bound> Tr for T { }\n+/// impl<T: ~const Bound + Specialize> const Tr for T { }\n+/// ```\n+///\n+/// However, we *don't* want to allow the reverse, i.e., when the bound on the\n+/// specializing impl is not as const as the bound on the base impl:\n+///\n+/// ```ignore (illustrative)\n+/// impl<T: ~const Bound> const Tr for T { }\n+/// impl<T: Bound + Specialize> const Tr for T { } // should be T: ~const Bound\n+/// ```\n+///\n+/// So we make that check in this function and try to raise a helpful error message.\n+fn trait_predicates_eq<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate1: ty::Predicate<'tcx>,\n+    predicate2: ty::Predicate<'tcx>,\n+    span: Span,\n+) -> bool {\n+    let pred1_kind = predicate1.kind().skip_binder();\n+    let pred2_kind = predicate2.kind().skip_binder();\n+    let (trait_pred1, trait_pred2) = match (pred1_kind, pred2_kind) {\n+        (ty::PredicateKind::Trait(pred1), ty::PredicateKind::Trait(pred2)) => (pred1, pred2),\n+        // Just use plain syntactic equivalence if either of the predicates aren't\n+        // trait predicates or have bound vars.\n+        _ => return predicate1 == predicate2,\n+    };\n+\n+    let predicates_equal_modulo_constness = {\n+        let pred1_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred1 };\n+        let pred2_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred2 };\n+        pred1_unconsted == pred2_unconsted\n+    };\n+\n+    if !predicates_equal_modulo_constness {\n+        return false;\n+    }\n+\n+    // Check that the predicate on the specializing impl is at least as const as\n+    // the one on the base.\n+    match (trait_pred2.constness, trait_pred1.constness) {\n+        (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n+            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+        }\n+        _ => {}\n+    }\n+\n+    true\n+}\n+\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n-    debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n     match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(ty::TraitPredicate {\n-            trait_ref,\n-            constness: ty::BoundConstness::NotConst,\n-            polarity: _,\n-        }) => {\n+        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)"}, {"sha": "ff0fb9bae923229ba85cd50d758aafe5eddbab02", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -581,10 +581,24 @@ trait UnusedDelimLint {\n             lint.set_arg(\"delim\", Self::DELIM_STR);\n             lint.set_arg(\"item\", msg);\n             if let Some((lo, hi)) = spans {\n-                let replacement = vec![\n-                    (lo, if keep_space.0 { \" \".into() } else { \"\".into() }),\n-                    (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n-                ];\n+                let sm = cx.sess().source_map();\n+                let lo_replace =\n+                    if keep_space.0 &&\n+                        let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(\" \") {\n+                        \" \".to_string()\n+                        } else {\n+                            \"\".to_string()\n+                        };\n+\n+                let hi_replace =\n+                    if keep_space.1 &&\n+                        let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(\" \") {\n+                        \" \".to_string()\n+                        } else {\n+                            \"\".to_string()\n+                        };\n+\n+                let replacement = vec![(lo, lo_replace), (hi, hi_replace)];\n                 lint.multipart_suggestion(\n                     fluent::suggestion,\n                     replacement,\n@@ -781,6 +795,7 @@ impl UnusedParens {\n         value: &ast::Pat,\n         avoid_or: bool,\n         avoid_mut: bool,\n+        keep_space: (bool, bool),\n     ) {\n         use ast::{BindingAnnotation, PatKind};\n \n@@ -805,7 +820,7 @@ impl UnusedParens {\n             } else {\n                 None\n             };\n-            self.emit_unused_delims(cx, value.span, spans, \"pattern\", (false, false));\n+            self.emit_unused_delims(cx, value.span, spans, \"pattern\", keep_space);\n         }\n     }\n }\n@@ -814,7 +829,7 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         match e.kind {\n             ExprKind::Let(ref pat, _, _) | ExprKind::ForLoop(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n+                self.check_unused_parens_pat(cx, pat, false, false, (true, true));\n             }\n             // We ignore parens in cases like `if (((let Some(0) = Some(1))))` because we already\n             // handle a hard error for them during AST lowering in `lower_expr_mut`, but we still\n@@ -858,40 +873,41 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n         use ast::{Mutability, PatKind::*};\n+        let keep_space = (false, false);\n         match &p.kind {\n             // Do not lint on `(..)` as that will result in the other arms being useless.\n             Paren(_)\n             // The other cases do not contain sub-patterns.\n             | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => {},\n             // These are list-like patterns; parens can always be removed.\n             TupleStruct(_, _, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n-                self.check_unused_parens_pat(cx, p, false, false);\n+                self.check_unused_parens_pat(cx, p, false, false, keep_space);\n             },\n             Struct(_, _, fps, _) => for f in fps {\n-                self.check_unused_parens_pat(cx, &f.pat, false, false);\n+                self.check_unused_parens_pat(cx, &f.pat, false, false, keep_space);\n             },\n             // Avoid linting on `i @ (p0 | .. | pn)` and `box (p0 | .. | pn)`, #64106.\n-            Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false),\n+            Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false, keep_space),\n             // Avoid linting on `&(mut x)` as `&mut x` has a different meaning, #55342.\n             // Also avoid linting on `& mut? (p0 | .. | pn)`, #64106.\n-            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not),\n+            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not, keep_space),\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let StmtKind::Local(ref local) = s.kind {\n-            self.check_unused_parens_pat(cx, &local.pat, true, false);\n+            self.check_unused_parens_pat(cx, &local.pat, true, false, (false, false));\n         }\n \n         <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n-        self.check_unused_parens_pat(cx, &param.pat, true, false);\n+        self.check_unused_parens_pat(cx, &param.pat, true, false, (false, false));\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false, (false, false));\n     }\n \n     fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {"}, {"sha": "a4495d2934df3b58318a4340912357f0a1432446", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1957,6 +1957,7 @@ impl BorrowKind {\n         }\n     }\n \n+    // FIXME: won't be used after diagnostic migration\n     pub fn describe_mutability(&self) -> &str {\n         match *self {\n             BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => \"immutable\","}, {"sha": "18eb06b83c9dfa87f54fbdf56fed2f0e014dd8f5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -2506,6 +2506,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n+        self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n+    }\n+\n     /// Returns layout of a generator. Layout might be unavailable if the\n     /// generator is tainted by errors.\n     pub fn generator_layout(self, def_id: DefId) -> Option<&'tcx GeneratorLayout<'tcx>> {"}, {"sha": "d59982f7063f33e5756cdf62cfb60eecc0b7e576", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1165,10 +1165,12 @@ pub(crate) struct ParenthesesInForHead {\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ParenthesesInForHeadSugg {\n-    #[suggestion_part(code = \"\")]\n+    #[suggestion_part(code = \"{left_snippet}\")]\n     pub left: Span,\n-    #[suggestion_part(code = \"\")]\n+    pub left_snippet: String,\n+    #[suggestion_part(code = \"{right_snippet}\")]\n     pub right: Span,\n+    pub right_snippet: String,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "0bbe073fe2af4621c19f95e570bdd13367249e82", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1653,15 +1653,29 @@ impl<'a> Parser<'a> {\n             (token::CloseDelim(Delimiter::Parenthesis), Some(begin_par_sp)) => {\n                 self.bump();\n \n+                let sm = self.sess.source_map();\n+                let left = begin_par_sp;\n+                let right = self.prev_token.span;\n+                let left_snippet = if let Ok(snip) = sm.span_to_prev_source(left) &&\n+                        !snip.ends_with(\" \") {\n+                                \" \".to_string()\n+                            } else {\n+                                \"\".to_string()\n+                            };\n+\n+                let right_snippet = if let Ok(snip) = sm.span_to_next_source(right) &&\n+                        !snip.starts_with(\" \") {\n+                                \" \".to_string()\n+                            } else {\n+                                \"\".to_string()\n+                        };\n+\n                 self.sess.emit_err(ParenthesesInForHead {\n-                    span: vec![begin_par_sp, self.prev_token.span],\n+                    span: vec![left, right],\n                     // With e.g. `for (x) in y)` this would replace `(x) in y)`\n                     // with `x) in y)` which is syntactically invalid.\n                     // However, this is prevented before we get here.\n-                    sugg: ParenthesesInForHeadSugg {\n-                        left: begin_par_sp,\n-                        right: self.prev_token.span,\n-                    },\n+                    sugg: ParenthesesInForHeadSugg { left, right, left_snippet, right_snippet },\n                 });\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint."}, {"sha": "f2bfec5a2a38aff6f3fde462fb217d331ecc3630", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -219,26 +219,26 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let (mod_prefix, mod_str, suggestion) = if path.len() == 1 {\n                 debug!(?self.diagnostic_metadata.current_impl_items);\n                 debug!(?self.diagnostic_metadata.current_function);\n-                let suggestion = if let Some(items) = self.diagnostic_metadata.current_impl_items\n+                let suggestion = if self.current_trait_ref.is_none()\n                     && let Some((fn_kind, _)) = self.diagnostic_metadata.current_function\n-                    && self.current_trait_ref.is_none()\n                     && let Some(FnCtxt::Assoc(_)) = fn_kind.ctxt()\n+                    && let Some(items) = self.diagnostic_metadata.current_impl_items\n                     && let Some(item) = items.iter().find(|i| {\n-                        if let AssocItemKind::Fn(fn_) = &i.kind\n-                            && !fn_.sig.decl.has_self()\n-                            && i.ident.name == item_str.name\n+                        if let AssocItemKind::Fn(_) = &i.kind && i.ident.name == item_str.name\n                         {\n                             debug!(?item_str.name);\n-                            debug!(?fn_.sig.decl.inputs);\n                             return true\n                         }\n                         false\n                     })\n+                    && let AssocItemKind::Fn(fn_) = &item.kind\n                 {\n+                    debug!(?fn_);\n+                    let self_sugg = if fn_.sig.decl.has_self() { \"self.\" } else { \"Self::\" };\n                     Some((\n-                        item_span,\n+                        item_span.shrink_to_lo(),\n                         \"consider using the associated function\",\n-                        format!(\"Self::{}\", item.ident)\n+                        self_sugg.to_string()\n                     ))\n                 } else {\n                     None\n@@ -396,11 +396,13 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n \n     fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n-        let is_assoc_fn = self.self_type_is_available();\n+        if !self.self_type_is_available() {\n+            return;\n+        }\n         let Some(path_last_segment) = path.last() else { return };\n         let item_str = path_last_segment.ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n+        if [\"this\", \"my\"].contains(&item_str.as_str()) {\n             err.span_suggestion_short(\n                 span,\n                 \"you might have meant to use `self` here instead\",\n@@ -451,7 +453,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n         let path_str = Segment::names_to_string(path);\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-\n         let mut candidates = self\n             .r\n             .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n@@ -1542,7 +1543,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 _ => None,\n             }\n         }\n-\n         // Fields are generally expected in the same contexts as locals.\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) ="}, {"sha": "a12f67125bbc0f2afba2fe9b15af46572743bacf", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -959,7 +959,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_coinductive(data.def_id()),\n             ty::PredicateKind::WellFormed(_) => true,\n             _ => false,\n         };"}, {"sha": "39e2a90222670250fd8c0c81e75fe50901430435", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -107,10 +107,6 @@ impl Buffer {\n         self.buffer\n     }\n \n-    pub(crate) fn insert_str(&mut self, idx: usize, s: &str) {\n-        self.buffer.insert_str(idx, s);\n-    }\n-\n     pub(crate) fn push_str(&mut self, s: &str) {\n         self.buffer.push_str(s);\n     }"}, {"sha": "73690c86f4f72b97070c9c42718fe47022c2b468", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -69,11 +69,13 @@ pub(crate) struct Context<'tcx> {\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n     pub(crate) include_sources: bool,\n+    /// Collection of all types with notable traits referenced in the current module.\n+    pub(crate) types_with_notable_traits: FxHashSet<clean::Type>,\n }\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(not(windows), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Context<'_>, 128);\n+rustc_data_structures::static_assert_size!(Context<'_>, 160);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n pub(crate) struct SharedContext<'tcx> {\n@@ -532,6 +534,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             deref_id_map: FxHashMap::default(),\n             shared: Rc::new(scx),\n             include_sources,\n+            types_with_notable_traits: FxHashSet::default(),\n         };\n \n         if emit_crate {\n@@ -560,6 +563,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             id_map: IdMap::new(),\n             shared: Rc::clone(&self.shared),\n             include_sources: self.include_sources,\n+            types_with_notable_traits: FxHashSet::default(),\n         }\n     }\n \n@@ -803,6 +807,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 }\n             }\n         }\n+\n         Ok(())\n     }\n "}, {"sha": "266ec2ac7ad7394f3706b59b26ce2964f2cad919", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 122, "deletions": 73, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -59,7 +59,7 @@ use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n-use serde::ser::SerializeSeq;\n+use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, ItemId, RenderedLink, SelfTy};\n@@ -803,7 +803,7 @@ fn assoc_method(\n     d: &clean::FnDecl,\n     link: AssocItemLink<'_>,\n     parent: ItemType,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     render_mode: RenderMode,\n ) {\n     let tcx = cx.tcx();\n@@ -836,6 +836,8 @@ fn assoc_method(\n         + name.as_str().len()\n         + generics_len;\n \n+    let notable_traits = d.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+\n     let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n         header_len += 4;\n         let indent_str = \"    \";\n@@ -861,9 +863,9 @@ fn assoc_method(\n         name = name,\n         generics = g.print(cx),\n         decl = d.full_print(header_len, indent, cx),\n-        notable_traits = notable_traits_decl(d, cx),\n+        notable_traits = notable_traits.unwrap_or_default(),\n         where_clause = print_where_clause(g, cx, indent, end_newline),\n-    )\n+    );\n }\n \n /// Writes a span containing the versions at which an item became stable and/or const-stable. For\n@@ -963,7 +965,7 @@ fn render_assoc_item(\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n     parent: ItemType,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     render_mode: RenderMode,\n ) {\n     match &*item.kind {\n@@ -1273,88 +1275,135 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n     }\n }\n \n-fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n-    let mut out = Buffer::html();\n+pub(crate) fn notable_traits_button(ty: &clean::Type, cx: &mut Context<'_>) -> Option<String> {\n+    let mut has_notable_trait = false;\n+\n+    let did = ty.def_id(cx.cache())?;\n \n-    if let Some((did, ty)) = decl.output.as_return().and_then(|t| Some((t.def_id(cx.cache())?, t)))\n+    // Box has pass-through impls for Read, Write, Iterator, and Future when the\n+    // boxed type implements one of those. We don't want to treat every Box return\n+    // as being notably an Iterator (etc), though, so we exempt it. Pin has the same\n+    // issue, with a pass-through impl for Future.\n+    if Some(did) == cx.tcx().lang_items().owned_box()\n+        || Some(did) == cx.tcx().lang_items().pin_type()\n     {\n-        // Box has pass-through impls for Read, Write, Iterator, and Future when the\n-        // boxed type implements one of those. We don't want to treat every Box return\n-        // as being notably an Iterator (etc), though, so we exempt it. Pin has the same\n-        // issue, with a pass-through impl for Future.\n-        if Some(did) == cx.tcx().lang_items().owned_box()\n-            || Some(did) == cx.tcx().lang_items().pin_type()\n-        {\n-            return \"\".to_string();\n-        }\n-        if let Some(impls) = cx.cache().impls.get(&did) {\n-            for i in impls {\n-                let impl_ = i.inner_impl();\n-                if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache())\n+        return None;\n+    }\n+\n+    if let Some(impls) = cx.cache().impls.get(&did) {\n+        for i in impls {\n+            let impl_ = i.inner_impl();\n+            if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+                // Two different types might have the same did,\n+                // without actually being the same.\n+                continue;\n+            }\n+            if let Some(trait_) = &impl_.trait_ {\n+                let trait_did = trait_.def_id();\n+\n+                if cx.cache().traits.get(&trait_did).map_or(false, |t| t.is_notable_trait(cx.tcx()))\n                 {\n-                    // Two different types might have the same did,\n-                    // without actually being the same.\n-                    continue;\n+                    has_notable_trait = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    if has_notable_trait {\n+        cx.types_with_notable_traits.insert(ty.clone());\n+        Some(format!(\n+            \"<span class=\\\"notable-traits\\\" data-ty=\\\"{ty}\\\">\\\n+                <span class=\\\"notable-traits-tooltip\\\">\u24d8</span>\\\n+            </span>\",\n+            ty = Escape(&format!(\"{:#}\", ty.print(cx))),\n+        ))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> (String, String) {\n+    let mut out = Buffer::html();\n+\n+    let did = ty.def_id(cx.cache()).expect(\"notable_traits_button already checked this\");\n+\n+    let impls = cx.cache().impls.get(&did).expect(\"notable_traits_button already checked this\");\n+\n+    for i in impls {\n+        let impl_ = i.inner_impl();\n+        if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+            // Two different types might have the same did,\n+            // without actually being the same.\n+            continue;\n+        }\n+        if let Some(trait_) = &impl_.trait_ {\n+            let trait_did = trait_.def_id();\n+\n+            if cx.cache().traits.get(&trait_did).map_or(false, |t| t.is_notable_trait(cx.tcx())) {\n+                if out.is_empty() {\n+                    write!(\n+                        &mut out,\n+                        \"<h3 class=\\\"notable\\\">Notable traits for <code>{}</code></h3>\\\n+                     <pre class=\\\"content\\\"><code>\",\n+                        impl_.for_.print(cx)\n+                    );\n                 }\n-                if let Some(trait_) = &impl_.trait_ {\n-                    let trait_did = trait_.def_id();\n-\n-                    if cx\n-                        .cache()\n-                        .traits\n-                        .get(&trait_did)\n-                        .map_or(false, |t| t.is_notable_trait(cx.tcx()))\n-                    {\n-                        if out.is_empty() {\n-                            write!(\n-                                &mut out,\n-                                \"<span class=\\\"notable\\\">Notable traits for {}</span>\\\n-                             <code class=\\\"content\\\">\",\n-                                impl_.for_.print(cx)\n-                            );\n-                        }\n \n-                        //use the \"where\" class here to make it small\n-                        write!(\n+                //use the \"where\" class here to make it small\n+                write!(\n+                    &mut out,\n+                    \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n+                    impl_.print(false, cx)\n+                );\n+                for it in &impl_.items {\n+                    if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n+                        out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n+                        let empty_set = FxHashSet::default();\n+                        let src_link = AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n+                        assoc_type(\n                             &mut out,\n-                            \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                            impl_.print(false, cx)\n+                            it,\n+                            &tydef.generics,\n+                            &[], // intentionally leaving out bounds\n+                            Some(&tydef.type_),\n+                            src_link,\n+                            0,\n+                            cx,\n                         );\n-                        for it in &impl_.items {\n-                            if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n-                                out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n-                                let empty_set = FxHashSet::default();\n-                                let src_link =\n-                                    AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n-                                assoc_type(\n-                                    &mut out,\n-                                    it,\n-                                    &tydef.generics,\n-                                    &[], // intentionally leaving out bounds\n-                                    Some(&tydef.type_),\n-                                    src_link,\n-                                    0,\n-                                    cx,\n-                                );\n-                                out.push_str(\";</span>\");\n-                            }\n-                        }\n+                        out.push_str(\";</span>\");\n                     }\n                 }\n             }\n         }\n     }\n-\n-    if !out.is_empty() {\n-        out.insert_str(\n-            0,\n-            \"<span class=\\\"notable-traits\\\"><span class=\\\"notable-traits-tooltip\\\">\u24d8\\\n-            <span class=\\\"notable-traits-tooltiptext\\\"><span class=\\\"docblock\\\">\",\n-        );\n-        out.push_str(\"</code></span></span></span></span>\");\n+    if out.is_empty() {\n+        write!(&mut out, \"</code></pre>\",);\n     }\n \n-    out.into_inner()\n+    (format!(\"{:#}\", ty.print(cx)), out.into_inner())\n+}\n+\n+pub(crate) fn notable_traits_json<'a>(\n+    tys: impl Iterator<Item = &'a clean::Type>,\n+    cx: &Context<'_>,\n+) -> String {\n+    let mut mp: Vec<(String, String)> = tys.map(|ty| notable_traits_decl(ty, cx)).collect();\n+    mp.sort_by(|(name1, _html1), (name2, _html2)| name1.cmp(name2));\n+    struct NotableTraitsMap(Vec<(String, String)>);\n+    impl Serialize for NotableTraitsMap {\n+        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where\n+            S: Serializer,\n+        {\n+            let mut map = serializer.serialize_map(Some(self.0.len()))?;\n+            for item in &self.0 {\n+                map.serialize_entry(&item.0, &item.1)?;\n+            }\n+            map.end()\n+        }\n+    }\n+    serde_json::to_string(&NotableTraitsMap(mp))\n+        .expect(\"serialize (string, string) -> json object cannot fail\")\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "ac11a860a4f0b88af87cc192f97674afe7c3afa0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -17,9 +17,10 @@ use std::rc::Rc;\n \n use super::{\n     collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,\n-    item_ty_to_section, notable_traits_decl, render_all_impls, render_assoc_item,\n-    render_assoc_items, render_attributes_in_code, render_attributes_in_pre, render_impl,\n-    render_rightside, render_stability_since_raw, AssocItemLink, Context, ImplRenderingParameters,\n+    item_ty_to_section, notable_traits_button, notable_traits_json, render_all_impls,\n+    render_assoc_item, render_assoc_items, render_attributes_in_code, render_attributes_in_pre,\n+    render_impl, render_rightside, render_stability_since_raw, AssocItemLink, Context,\n+    ImplRenderingParameters,\n };\n use crate::clean;\n use crate::config::ModuleSorting;\n@@ -183,6 +184,16 @@ pub(super) fn print_item(\n             unreachable!();\n         }\n     }\n+\n+    // Render notable-traits.js used for all methods in this module.\n+    if !cx.types_with_notable_traits.is_empty() {\n+        write!(\n+            buf,\n+            r#\"<script type=\"text/json\" id=\"notable-traits-data\">{}</script>\"#,\n+            notable_traits_json(cx.types_with_notable_traits.iter(), cx)\n+        );\n+        cx.types_with_notable_traits.clear();\n+    }\n }\n \n /// For large structs, enums, unions, etc, determine whether to hide their fields\n@@ -516,6 +527,9 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n         + name.as_str().len()\n         + generics_len;\n \n+    let notable_traits =\n+        f.decl.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+\n     wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"fn\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n@@ -533,11 +547,11 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n                 generics = f.generics.print(cx),\n                 where_clause = print_where_clause(&f.generics, cx, 0, Ending::Newline),\n                 decl = f.decl.full_print(header_len, 0, cx),\n-                notable_traits = notable_traits_decl(&f.decl, cx),\n+                notable_traits = notable_traits.unwrap_or_default(),\n             );\n         });\n     });\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    document(w, cx, it, None, HeadingOffset::H2);\n }\n \n fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {"}, {"sha": "54e8b6561f34f9c3e4cb0b7ba1706e3a3e352b57", "filename": "src/librustdoc/html/static/css/noscript.css", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fnoscript.css", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fnoscript.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fnoscript.css?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -22,3 +22,9 @@ nav.sub {\n .source .sidebar {\n \tdisplay: none;\n }\n+\n+.notable-traits {\n+\t/* layout requires javascript\n+\t    https://github.com/rust-lang/rust/issues/102576 */\n+\tdisplay: none;\n+}"}, {"sha": "6a068a3d243d9c402ae2eceff90c4ece0d1dec57", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -183,6 +183,8 @@ h4.code-header {\n \tfont-weight: 600;\n \tmargin: 0;\n \tpadding: 0;\n+\t/* position notable traits in mobile mode within the header */\n+\tposition: relative;\n }\n \n #crate-search,\n@@ -1278,13 +1280,12 @@ h3.variant {\n \tcursor: pointer;\n }\n \n-.notable-traits:hover .notable-traits-tooltiptext,\n-.notable-traits .notable-traits-tooltiptext.force-tooltip {\n+.notable-traits .notable-traits-tooltiptext {\n \tdisplay: inline-block;\n+\tvisibility: hidden;\n }\n \n-.notable-traits .notable-traits-tooltiptext {\n-\tdisplay: none;\n+.notable-traits-tooltiptext {\n \tpadding: 5px 3px 3px 3px;\n \tborder-radius: 6px;\n \tmargin-left: 5px;\n@@ -1302,22 +1303,26 @@ h3.variant {\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n-.notable-traits .docblock {\n+.notable-traits-tooltiptext .docblock {\n \tmargin: 0;\n }\n \n-.notable-traits .notable {\n-\tmargin: 0;\n-\tmargin-bottom: 13px;\n+.notable-traits-tooltiptext .notable {\n \tfont-size: 1.1875rem;\n \tfont-weight: 600;\n \tdisplay: block;\n }\n \n-.notable-traits .docblock code.content {\n+.notable-traits-tooltiptext pre, .notable-traits-tooltiptext code {\n+\tbackground: transparent;\n+}\n+\n+.notable-traits-tooltiptext .docblock pre.content {\n \tmargin: 0;\n \tpadding: 0;\n \tfont-size: 1.25rem;\n+\twhite-space: pre-wrap;\n+\toverflow: hidden;\n }\n \n .search-failed {"}, {"sha": "0426774e80d46ff974ffd59b890b3301b804a145", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -790,6 +790,19 @@ function loadCss(cssUrl) {\n             // we need to switch away from mobile mode and make the main content area scrollable.\n             hideSidebar();\n         }\n+        if (window.CURRENT_NOTABLE_ELEMENT) {\n+            // As a workaround to the behavior of `contains: layout` used in doc togglers, the\n+            // notable traits popup is positioned using javascript.\n+            //\n+            // This means when the window is resized, we need to redo the layout.\n+            const base = window.CURRENT_NOTABLE_ELEMENT.NOTABLE_BASE;\n+            const force_visible = base.NOTABLE_FORCE_VISIBLE;\n+            hideNotable();\n+            if (force_visible) {\n+                showNotable(base);\n+                base.NOTABLE_FORCE_VISIBLE = true;\n+            }\n+        }\n     });\n \n     function handleClick(id, f) {\n@@ -822,10 +835,80 @@ function loadCss(cssUrl) {\n         });\n     });\n \n+    function showNotable(e) {\n+        if (!window.NOTABLE_TRAITS) {\n+            const data = document.getElementById(\"notable-traits-data\");\n+            if (data) {\n+                window.NOTABLE_TRAITS = JSON.parse(data.innerText);\n+            } else {\n+                throw new Error(\"showNotable() called on page without any notable traits!\");\n+            }\n+        }\n+        if (window.CURRENT_NOTABLE_ELEMENT && window.CURRENT_NOTABLE_ELEMENT.NOTABLE_BASE === e) {\n+            // Make this function idempotent.\n+            return;\n+        }\n+        hideNotable();\n+        const ty = e.getAttribute(\"data-ty\");\n+        const tooltip = e.getElementsByClassName(\"notable-traits-tooltip\")[0];\n+        const wrapper = document.createElement(\"div\");\n+        wrapper.innerHTML = \"<div class=\\\"docblock\\\">\" + window.NOTABLE_TRAITS[ty] + \"</div>\";\n+        wrapper.className = \"notable-traits-tooltiptext\";\n+        tooltip.appendChild(wrapper);\n+        const pos = wrapper.getBoundingClientRect();\n+        tooltip.removeChild(wrapper);\n+        wrapper.style.top = (pos.top + window.scrollY) + \"px\";\n+        wrapper.style.left = (pos.left + window.scrollX) + \"px\";\n+        wrapper.style.width = pos.width + \"px\";\n+        const body = document.getElementsByTagName(\"body\")[0];\n+        body.appendChild(wrapper);\n+        window.CURRENT_NOTABLE_ELEMENT = wrapper;\n+        window.CURRENT_NOTABLE_ELEMENT.NOTABLE_BASE = e;\n+        wrapper.onpointerleave = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            if (!e.NOTABLE_FORCE_VISIBLE && !elemIsInParent(event.relatedTarget, e)) {\n+                hideNotable();\n+            }\n+        };\n+    }\n+\n+    function hideNotable() {\n+        if (window.CURRENT_NOTABLE_ELEMENT) {\n+            window.CURRENT_NOTABLE_ELEMENT.NOTABLE_BASE.NOTABLE_FORCE_VISIBLE = false;\n+            const body = document.getElementsByTagName(\"body\")[0];\n+            body.removeChild(window.CURRENT_NOTABLE_ELEMENT);\n+            window.CURRENT_NOTABLE_ELEMENT = null;\n+        }\n+    }\n+\n     onEachLazy(document.getElementsByClassName(\"notable-traits\"), e => {\n         e.onclick = function() {\n-            this.getElementsByClassName(\"notable-traits-tooltiptext\")[0]\n-                .classList.toggle(\"force-tooltip\");\n+            this.NOTABLE_FORCE_VISIBLE = this.NOTABLE_FORCE_VISIBLE ? false : true;\n+            if (window.CURRENT_NOTABLE_ELEMENT && !this.NOTABLE_FORCE_VISIBLE) {\n+                hideNotable();\n+            } else {\n+                showNotable(this);\n+            }\n+        };\n+        e.onpointerenter = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            showNotable(this);\n+        };\n+        e.onpointerleave = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            if (!this.NOTABLE_FORCE_VISIBLE &&\n+                !elemIsInParent(event.relatedTarget, window.CURRENT_NOTABLE_ELEMENT)) {\n+                hideNotable();\n+            }\n         };\n     });\n "}, {"sha": "d8261d8dc902c624cd58317de81abae163d42d55", "filename": "src/test/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 93, "deletions": 9, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -25,22 +25,28 @@ assert-position: (\n     {\"x\": 951},\n )\n // The tooltip should be beside the `i`\n+// Also, clicking the tooltip should bring its text into the DOM\n+assert-count: (\"//*[@class='notable-traits-tooltiptext']\", 0)\n click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+assert-count: (\"//*[@class='notable-traits-tooltiptext']\", 1)\n compare-elements-position-near: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    \"//*[@class='notable-traits-tooltiptext']\",\n     {\"y\": 2}\n )\n compare-elements-position-false: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    \"//*[@class='notable-traits-tooltiptext']\",\n     (\"x\")\n )\n // The docblock should be flush with the border.\n assert-css: (\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    \"//*[@class='notable-traits-tooltiptext']/*[@class='docblock']\",\n     {\"margin-left\": \"0px\"}\n )\n+click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+move-cursor-to: \"//h1\"\n+assert-count: (\"//*[@class='notable-traits-tooltiptext']\", 0)\n \n // Now only the `i` should be on the next line.\n size: (1055, 600)\n@@ -98,26 +104,31 @@ assert-position: (\n     {\"x\": 289},\n )\n // The tooltip should be below `i`\n+click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+assert-count: (\"//*[@class='notable-traits-tooltiptext']\", 1)\n compare-elements-position-near-false: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    \"//*[@class='notable-traits-tooltiptext']\",\n     {\"y\": 2}\n )\n compare-elements-position-false: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    \"//*[@class='notable-traits-tooltiptext']\",\n     (\"x\")\n )\n compare-elements-position-near: (\n-    \"//*[@id='method.create_an_iterator_from_read']/parent::*\",\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n-    {\"x\": 5}\n+    \"//*[@id='method.create_an_iterator_from_read']\",\n+    \"//*[@class='notable-traits-tooltiptext']\",\n+    {\"x\": 10}\n )\n // The docblock should be flush with the border.\n assert-css: (\n-    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    \"//*[@class='notable-traits-tooltiptext']/*[@class='docblock']\",\n     {\"margin-left\": \"0px\"}\n )\n+click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+move-cursor-to: \"//h1\"\n+assert-count: (\"//*[@class='notable-traits-tooltiptext']\", 0)\n \n // Checking on very small mobile. The `i` should be on its own line.\n size: (365, 600)\n@@ -126,3 +137,76 @@ compare-elements-position-false: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n     (\"y\", \"x\"),\n )\n+\n+// Now check the colors.\n+define-function: (\n+    \"check-colors\",\n+    (theme, header_color, content_color, type_color, trait_color),\n+    [\n+        (\"goto\", \"file://\" + |DOC_PATH| + \"/test_docs/struct.NotableStructWithLongName.html\"),\n+        // This is needed to ensure that the text color is computed.\n+        (\"show-text\", true),\n+\n+        // Setting the theme.\n+        (\"local-storage\", {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}),\n+        // We reload the page so the local storage settings are being used.\n+        (\"reload\"),\n+\n+        (\"move-cursor-to\", \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"),\n+        (\"assert-count\", (\".notable-traits-tooltiptext\", 1)),\n+\n+        (\"assert-css\", (\n+             \".notable-traits-tooltiptext h3.notable\",\n+             {\"color\": |header_color|},\n+             ALL,\n+        )),\n+        (\"assert-css\", (\n+             \".notable-traits-tooltiptext pre.content\",\n+             {\"color\": |content_color|},\n+             ALL,\n+        )),\n+        (\"assert-css\", (\n+             \".notable-traits-tooltiptext pre.content a.struct\",\n+             {\"color\": |type_color|},\n+             ALL,\n+        )),\n+        (\"assert-css\", (\n+             \".notable-traits-tooltiptext pre.content a.trait\",\n+             {\"color\": |trait_color|},\n+             ALL,\n+        )),\n+    ]\n+)\n+\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"ayu\",\n+        \"content_color\": \"rgb(230, 225, 207)\",\n+        \"header_color\": \"rgb(255, 255, 255)\",\n+        \"type_color\": \"rgb(255, 160, 165)\",\n+        \"trait_color\": \"rgb(57, 175, 215)\",\n+    },\n+)\n+\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"dark\",\n+        \"content_color\": \"rgb(221, 221, 221)\",\n+        \"header_color\": \"rgb(221, 221, 221)\",\n+        \"type_color\": \"rgb(45, 191, 184)\",\n+        \"trait_color\": \"rgb(183, 140, 242)\",\n+    },\n+)\n+\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"light\",\n+        \"content_color\": \"rgb(0, 0, 0)\",\n+        \"header_color\": \"rgb(0, 0, 0)\",\n+        \"type_color\": \"rgb(173, 55, 138)\",\n+        \"trait_color\": \"rgb(110, 79, 201)\",\n+    },\n+)"}, {"sha": "6b58be7e6853eef95298a633143f9891710df901", "filename": "src/test/rustdoc/doc-notable_trait-slice.bare_fn_matches.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1 @@\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"&amp;'static [SomeStruct]\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait_slice::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "2411da8cd45493d0aa0813f26076351186ed8bf2", "filename": "src/test/rustdoc/doc-notable_trait-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait-slice.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -8,13 +8,13 @@ pub struct OtherStruct;\n impl SomeTrait for &[SomeStruct] {}\n \n // @has doc_notable_trait_slice/fn.bare_fn_matches.html\n-// @has - '//code[@class=\"content\"]' 'impl SomeTrait for &[SomeStruct]'\n+// @snapshot bare_fn_matches - '//script[@id=\"notable-traits-data\"]'\n pub fn bare_fn_matches() -> &'static [SomeStruct] {\n     &[]\n }\n \n // @has doc_notable_trait_slice/fn.bare_fn_no_matches.html\n-// @!has - '//code[@class=\"content\"]' 'impl SomeTrait for &[SomeStruct]'\n+// @count - '//script[@id=\"notable-traits-data\"]' 0\n pub fn bare_fn_no_matches() -> &'static [OtherStruct] {\n     &[]\n }"}, {"sha": "4e4a3f18f2498b1db69e3f997a7b556b5825a2c4", "filename": "src/test/rustdoc/doc-notable_trait.bare-fn.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.bare-fn.html?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1 @@\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "1f2cd7181c3d4aa5ac45c5172d55ec5de68346db", "filename": "src/test/rustdoc/doc-notable_trait.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -9,7 +9,8 @@ impl<T: SomeTrait> SomeTrait for Wrapper<T> {}\n #[doc(notable_trait)]\n pub trait SomeTrait {\n     // @has doc_notable_trait/trait.SomeTrait.html\n-    // @has - '//code[@class=\"content\"]' 'impl<T: SomeTrait> SomeTrait for Wrapper<T>'\n+    // @has - '//span[@class=\"notable-traits\"]/@data-ty' 'Wrapper<Self>'\n+    // @snapshot wrap-me - '//script[@id=\"notable-traits-data\"]'\n     fn wrap_me(self) -> Wrapper<Self> where Self: Sized {\n         Wrapper {\n             inner: self,\n@@ -22,15 +23,16 @@ impl SomeTrait for SomeStruct {}\n \n impl SomeStruct {\n     // @has doc_notable_trait/struct.SomeStruct.html\n-    // @has - '//code[@class=\"content\"]' 'impl SomeTrait for SomeStruct'\n-    // @has - '//code[@class=\"content\"]' 'impl<T: SomeTrait> SomeTrait for Wrapper<T>'\n+    // @has - '//span[@class=\"notable-traits\"]/@data-ty' 'SomeStruct'\n+    // @snapshot some-struct-new - '//script[@id=\"notable-traits-data\"]'\n     pub fn new() -> SomeStruct {\n         SomeStruct\n     }\n }\n \n // @has doc_notable_trait/fn.bare_fn.html\n-// @has - '//code[@class=\"content\"]' 'impl SomeTrait for SomeStruct'\n+// @has - '//span[@class=\"notable-traits\"]/@data-ty' 'SomeStruct'\n+// @snapshot bare-fn - '//script[@id=\"notable-traits-data\"]'\n pub fn bare_fn() -> SomeStruct {\n     SomeStruct\n }"}, {"sha": "c0fd9748fd37107a850cf9bf361c9f265ba0ad9f", "filename": "src/test/rustdoc/doc-notable_trait.some-struct-new.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1 @@\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\",\"Wrapper&lt;Self&gt;\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "9a59d5edd12a8f14533db611fd8e4d1946c19a69", "filename": "src/test/rustdoc/doc-notable_trait.wrap-me.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait.wrap-me.html?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1 @@\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Wrapper&lt;Self&gt;\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "987a949af44b18a4d9cd1cc9088ba6acefec002b", "filename": "src/test/rustdoc/spotlight-from-dependency.odd.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.odd.html", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.odd.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.odd.html?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1 @@\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Odd\":\"&lt;h3 class=\\\"notable\\\"&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html\\\" title=\\\"trait core::iter::traits::iterator::Iterator\\\"&gt;Iterator&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/span&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;    type &lt;a href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\"&gt;Item&lt;/a&gt; = &lt;a class=\\\"primitive\\\" href=\\\"{{channel}}/std/primitive.usize.html\\\"&gt;usize&lt;/a&gt;;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "156aedca62b4e346455db26191a09749506c6e56", "filename": "src/test/rustdoc/spotlight-from-dependency.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fspotlight-from-dependency.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -3,7 +3,8 @@\n use std::iter::Iterator;\n \n // @has foo/struct.Odd.html\n-// @has - '//*[@id=\"method.new\"]//span[@class=\"notable-traits\"]//code/span' 'impl Iterator for Odd'\n+// @has - '//*[@id=\"method.new\"]//span[@class=\"notable-traits\"]/@data-ty' 'Odd'\n+// @snapshot odd - '//script[@id=\"notable-traits-data\"]'\n pub struct Odd {\n     current: usize,\n }"}, {"sha": "d6e18010f3b271a42810d91a153c53695950cf7c", "filename": "src/test/ui/generic-associated-types/bugs/issue-80626.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,15 +1,12 @@\n-// check-fail\n-// known-bug: #80626\n-\n-// This should pass, but it requires `Sized` to be coinductive.\n+// check-pass\n \n trait Allocator {\n     type Allocated<T>;\n }\n \n enum LinkedList<A: Allocator> {\n     Head,\n-    Next(A::Allocated<Self>)\n+    Next(A::Allocated<Self>),\n }\n \n fn main() {}"}, {"sha": "9a0f332ed47360141760f8f697d340417855dde6", "filename": "src/test/ui/generic-associated-types/bugs/issue-80626.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-80626.stderr?ref=7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "patch": "@@ -1,15 +0,0 @@\n-error[E0275]: overflow evaluating the requirement `LinkedList<A>: Sized`\n-  --> $DIR/issue-80626.rs:12:10\n-   |\n-LL |     Next(A::Allocated<Self>)\n-   |          ^^^^^^^^^^^^^^^^^^\n-   |\n-note: required by a bound in `Allocator::Allocated`\n-  --> $DIR/issue-80626.rs:7:20\n-   |\n-LL |     type Allocated<T>;\n-   |                    ^ required by this bound in `Allocator::Allocated`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0275`."}, {"sha": "b35657989efb96ddda749a38767a8c04edd723ba", "filename": "src/test/ui/generic-associated-types/issue-87750.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n trait PointerFamily {\n     type Pointer<T>;\n }\n@@ -10,11 +12,13 @@ impl PointerFamily for RcFamily {\n }\n \n #[allow(dead_code)]\n-enum Node<T, P: PointerFamily> where P::Pointer<Node<T, P>>: Sized {\n+enum Node<T, P: PointerFamily>\n+where\n+    P::Pointer<Node<T, P>>: Sized,\n+{\n     Cons(P::Pointer<Node<T, P>>),\n }\n \n fn main() {\n     let _list: <RcFamily as PointerFamily>::Pointer<Node<i32, RcFamily>>;\n-    //~^ ERROR overflow evaluating the requirement `Node<i32, RcFamily>: Sized`\n }"}, {"sha": "b358ca273ca79c3854dc92bfbc3d02a22ea4737b", "filename": "src/test/ui/generic-associated-types/issue-87750.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87750.stderr?ref=7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "patch": "@@ -1,9 +0,0 @@\n-error[E0275]: overflow evaluating the requirement `Node<i32, RcFamily>: Sized`\n-  --> $DIR/issue-87750.rs:18:16\n-   |\n-LL |     let _list: <RcFamily as PointerFamily>::Pointer<Node<i32, RcFamily>>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0275`."}, {"sha": "ecf6f69c9fa7ebca2426cf28e384f1790afdcb08", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -21,6 +21,7 @@ impl<T> Foo for Number<T> {\n     // ```\n     // which it is :)\n     type Item = [T] where [T]: Sized;\n+    //~^ ERROR overflow evaluating the requirement `<Number<T> as Foo>::Item == _`\n }\n \n struct OnlySized<T> where T: Sized { f: T }\n@@ -40,7 +41,6 @@ impl<T> Bar for T where T: Foo {\n     // can use the bound on `Foo::Item` for this, but that requires\n     // `wf(<T as Foo>::Item)`, which is an invalid cycle.\n     type Assoc = OnlySized<<T as Foo>::Item>;\n-    //~^ ERROR overflow evaluating the requirement `<T as Foo>::Item: Sized`\n }\n \n fn foo<T: Print>() {"}, {"sha": "aae9a56bb612878da03b2e46c2bdc74c3ff1c175", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle-generic.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,14 +1,8 @@\n-error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n-  --> $DIR/projection-bound-cycle-generic.rs:42:18\n+error[E0275]: overflow evaluating the requirement `<Number<T> as Foo>::Item == _`\n+  --> $DIR/projection-bound-cycle-generic.rs:23:5\n    |\n-LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: required by a bound in `OnlySized`\n-  --> $DIR/projection-bound-cycle-generic.rs:26:18\n-   |\n-LL | struct OnlySized<T> where T: Sized { f: T }\n-   |                  ^ required by this bound in `OnlySized`\n+LL |     type Item = [T] where [T]: Sized;\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b51ae7ef20186dcf07ad3725677657b81296ffaa", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -24,6 +24,7 @@ impl Foo for Number {\n     // ```\n     // which it is :)\n     type Item = str where str: Sized;\n+    //~^ ERROR overflow evaluating the requirement `<Number as Foo>::Item == _`\n }\n \n struct OnlySized<T> where T: Sized { f: T }\n@@ -43,7 +44,6 @@ impl<T> Bar for T where T: Foo {\n     // can use the bound on `Foo::Item` for this, but that requires\n     // `wf(<T as Foo>::Item)`, which is an invalid cycle.\n     type Assoc = OnlySized<<T as Foo>::Item>;\n-    //~^ ERROR overflow evaluating the requirement `<T as Foo>::Item: Sized`\n }\n \n fn foo<T: Print>() {"}, {"sha": "b1b8afeecd02f51c65457461a4e7bd5f38e6abdb", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,14 +1,8 @@\n-error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n-  --> $DIR/projection-bound-cycle.rs:45:18\n+error[E0275]: overflow evaluating the requirement `<Number as Foo>::Item == _`\n+  --> $DIR/projection-bound-cycle.rs:26:5\n    |\n-LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: required by a bound in `OnlySized`\n-  --> $DIR/projection-bound-cycle.rs:29:18\n-   |\n-LL | struct OnlySized<T> where T: Sized { f: T }\n-   |                  ^ required by this bound in `OnlySized`\n+LL |     type Item = str where str: Sized;\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2b01b414baa6ea8f57b33d0c2c858f11de50d838", "filename": "src/test/ui/lint/issue-103435-extra-parentheses.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.fixed?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![deny(unused_parens)]\n+\n+fn main() {\n+    if let Some(_) = Some(1) {}\n+    //~^ ERROR unnecessary parentheses around pattern\n+\n+    for _x in 1..10 {}\n+    //~^ ERROR unnecessary parentheses around pattern\n+\n+    if 2 == 1 {}\n+    //~^ ERROR unnecessary parentheses around `if` condition\n+\n+    // reported by parser\n+    for _x in 1..10 {}\n+    //~^ ERROR expected one of\n+    //~| ERROR unexpected parentheses surrounding\n+}"}, {"sha": "8261610cf5646ee045c4953718d926c30989da46", "filename": "src/test/ui/lint/issue-103435-extra-parentheses.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![deny(unused_parens)]\n+\n+fn main() {\n+    if let(Some(_))= Some(1) {}\n+    //~^ ERROR unnecessary parentheses around pattern\n+\n+    for(_x)in 1..10 {}\n+    //~^ ERROR unnecessary parentheses around pattern\n+\n+    if(2 == 1){}\n+    //~^ ERROR unnecessary parentheses around `if` condition\n+\n+    // reported by parser\n+    for(_x in 1..10){}\n+    //~^ ERROR expected one of\n+    //~| ERROR unexpected parentheses surrounding\n+}"}, {"sha": "29c41c91050b96e2de3bc587b3923f07e320debe", "filename": "src/test/ui/lint/issue-103435-extra-parentheses.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-103435-extra-parentheses.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,61 @@\n+error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n+  --> $DIR/issue-103435-extra-parentheses.rs:15:12\n+   |\n+LL |     for(_x in 1..10){}\n+   |            ^^ expected one of `)`, `,`, `@`, or `|`\n+\n+error: unexpected parentheses surrounding `for` loop head\n+  --> $DIR/issue-103435-extra-parentheses.rs:15:8\n+   |\n+LL |     for(_x in 1..10){}\n+   |        ^           ^\n+   |\n+help: remove parentheses in `for` loop\n+   |\n+LL -     for(_x in 1..10){}\n+LL +     for _x in 1..10 {}\n+   |\n+\n+error: unnecessary parentheses around pattern\n+  --> $DIR/issue-103435-extra-parentheses.rs:5:11\n+   |\n+LL |     if let(Some(_))= Some(1) {}\n+   |           ^       ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-103435-extra-parentheses.rs:2:9\n+   |\n+LL | #![deny(unused_parens)]\n+   |         ^^^^^^^^^^^^^\n+help: remove these parentheses\n+   |\n+LL -     if let(Some(_))= Some(1) {}\n+LL +     if let Some(_) = Some(1) {}\n+   |\n+\n+error: unnecessary parentheses around pattern\n+  --> $DIR/issue-103435-extra-parentheses.rs:8:8\n+   |\n+LL |     for(_x)in 1..10 {}\n+   |        ^  ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     for(_x)in 1..10 {}\n+LL +     for _x in 1..10 {}\n+   |\n+\n+error: unnecessary parentheses around `if` condition\n+  --> $DIR/issue-103435-extra-parentheses.rs:11:7\n+   |\n+LL |     if(2 == 1){}\n+   |       ^      ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     if(2 == 1){}\n+LL +     if 2 == 1 {}\n+   |\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "14f2259e1d4e82894316a70a8fd04ac900b70ac6", "filename": "src/test/ui/resolve/issue-103474.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,28 @@\n+struct S {}\n+impl S {\n+    fn first(&self) {}\n+\n+    fn second(&self) {\n+        first()\n+        //~^ ERROR cannot find function `first` in this scope\n+    }\n+\n+    fn third(&self) {\n+        no_method_err()\n+        //~^ ERROR cannot find function `no_method_err` in this scope\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust/pull/103531#discussion_r1004728080\n+struct Foo {\n+    i: i32,\n+}\n+\n+impl Foo {\n+    fn needs_self() {\n+        this.i\n+        //~^ ERROR cannot find value `this` in this scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "415d231552a0335e56f520e07dbd3a7a32c22d56", "filename": "src/test/ui/resolve/issue-103474.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-103474.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,35 @@\n+error[E0425]: cannot find value `this` in this scope\n+  --> $DIR/issue-103474.rs:23:9\n+   |\n+LL |         this.i\n+   |         ^^^^ not found in this scope\n+   |\n+help: you might have meant to use `self` here instead\n+   |\n+LL |         self.i\n+   |         ~~~~\n+help: if you meant to use `self`, you are also missing a `self` receiver argument\n+   |\n+LL |     fn needs_self(&self) {\n+   |                   +++++\n+\n+error[E0425]: cannot find function `first` in this scope\n+  --> $DIR/issue-103474.rs:6:9\n+   |\n+LL |         first()\n+   |         ^^^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         self.first()\n+   |         +++++\n+\n+error[E0425]: cannot find function `no_method_err` in this scope\n+  --> $DIR/issue-103474.rs:11:9\n+   |\n+LL |         no_method_err()\n+   |         ^^^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "36f3da7c9553794129913273f3194ddfcdb9da84", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -85,7 +85,7 @@ LL |         static_method();\n help: consider using the associated function\n    |\n LL |         Self::static_method();\n-   |         ~~~~~~~~~~~~~~~~~~~\n+   |         ++++++\n \n error[E0425]: cannot find function `purr` in this scope\n   --> $DIR/issue-2356.rs:54:9\n@@ -114,7 +114,7 @@ LL |     grow_older();\n help: consider using the associated function\n    |\n LL |     Self::grow_older();\n-   |     ~~~~~~~~~~~~~~~~\n+   |     ++++++\n \n error[E0425]: cannot find function `shave` in this scope\n   --> $DIR/issue-2356.rs:74:5"}, {"sha": "3ac909924864decc4df351a38999152708498229", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/const-default-bound-non-const-specialized-bound.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,46 @@\n+// Tests that trait bounds on specializing trait impls must be `~const` if the\n+// same bound is present on the default impl and is `~const` there.\n+\n+#![feature(const_trait_impl)]\n+#![feature(rustc_attrs)]\n+#![feature(min_specialization)]\n+\n+#[rustc_specialization_trait]\n+trait Specialize {}\n+\n+#[const_trait]\n+trait Foo {}\n+\n+#[const_trait]\n+trait Bar {}\n+\n+// bgr360: I was only able to exercise the code path that raises the\n+// \"missing ~const qualifier\" error by making this base impl non-const, even\n+// though that doesn't really make sense to do. As seen below, if the base impl\n+// is made const, rustc fails earlier with an overlapping impl failure.\n+impl<T> Bar for T\n+where\n+    T: ~const Foo,\n+{}\n+\n+impl<T> Bar for T\n+where\n+    T: Foo, //~ ERROR missing `~const` qualifier\n+    T: Specialize,\n+{}\n+\n+#[const_trait]\n+trait Baz {}\n+\n+impl<T> const Baz for T\n+where\n+    T: ~const Foo,\n+{}\n+\n+impl<T> const Baz for T //~ ERROR conflicting implementations of trait `Baz`\n+where\n+    T: Foo,\n+    T: Specialize,\n+{}\n+\n+fn main() {}"}, {"sha": "4aea1979421c36d09fcbe236790bd8942cbd4b52", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/const-default-bound-non-const-specialized-bound.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,18 @@\n+error: missing `~const` qualifier for specialization\n+  --> $DIR/const-default-bound-non-const-specialized-bound.rs:28:8\n+   |\n+LL |     T: Foo,\n+   |        ^^^\n+\n+error[E0119]: conflicting implementations of trait `Baz`\n+  --> $DIR/const-default-bound-non-const-specialized-bound.rs:40:1\n+   |\n+LL | impl<T> const Baz for T\n+   | ----------------------- first implementation here\n+...\n+LL | impl<T> const Baz for T\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "9ddea427cfd803c9cd5b6d96e215e3ff2282e21c", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/const-default-const-specialized.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-const-specialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-const-specialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-const-specialized.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,39 @@\n+// Tests that a const default trait impl can be specialized by another const\n+// trait impl and that the specializing impl will be used during const-eval.\n+\n+// run-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(min_specialization)]\n+\n+#[const_trait]\n+trait Value {\n+    fn value() -> u32;\n+}\n+\n+const fn get_value<T: ~const Value>() -> u32 {\n+    T::value()\n+}\n+\n+impl<T> const Value for T {\n+    default fn value() -> u32 {\n+        0\n+    }\n+}\n+\n+struct FortyTwo;\n+\n+impl const Value for FortyTwo {\n+    fn value() -> u32 {\n+        42\n+    }\n+}\n+\n+const ZERO: u32 = get_value::<()>();\n+\n+const FORTY_TWO: u32 = get_value::<FortyTwo>();\n+\n+fn main() {\n+    assert_eq!(ZERO, 0);\n+    assert_eq!(FORTY_TWO, 42);\n+}"}, {"sha": "a3bb9b3f93edaee333821435da563aa43cfba147", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/const-default-impl-non-const-specialized-impl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,26 @@\n+// Tests that specializing trait impls must be at least as const as the default impl.\n+\n+#![feature(const_trait_impl)]\n+#![feature(min_specialization)]\n+\n+#[const_trait]\n+trait Value {\n+    fn value() -> u32;\n+}\n+\n+impl<T> const Value for T {\n+    default fn value() -> u32 {\n+        0\n+    }\n+}\n+\n+struct FortyTwo;\n+\n+impl Value for FortyTwo { //~ ERROR cannot specialize on const impl with non-const impl\n+    fn value() -> u32 {\n+        println!(\"You can't do that (constly)\");\n+        42\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "24766804708a388c5ec7da2a426cbd39295738b5", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/const-default-impl-non-const-specialized-impl.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-impl-non-const-specialized-impl.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,8 @@\n+error: cannot specialize on const impl with non-const impl\n+  --> $DIR/const-default-impl-non-const-specialized-impl.rs:19:1\n+   |\n+LL | impl Value for FortyTwo {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2aac0a2b4d11183d4b6dca6bd9b0df37b4c92204", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/default-keyword.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fdefault-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fdefault-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fdefault-keyword.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(min_specialization)]\n+\n+#[const_trait]\n+trait Foo {\n+    fn foo();\n+}\n+\n+impl const Foo for u32 {\n+    default fn foo() {}\n+}\n+\n+fn main() {}"}, {"sha": "9c2c2cf1610a296465a9c1156b50e282cb871ae7", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/issue-95186-specialize-on-tilde-const.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,37 @@\n+// Tests that `~const` trait bounds can be used to specialize const trait impls.\n+\n+// check-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(rustc_attrs)]\n+#![feature(min_specialization)]\n+\n+#[const_trait]\n+#[rustc_specialization_trait]\n+trait Specialize {}\n+\n+#[const_trait]\n+trait Foo {}\n+\n+impl<T> const Foo for T {}\n+\n+impl<T> const Foo for T\n+where\n+    T: ~const Specialize,\n+{}\n+\n+#[const_trait]\n+trait Bar {}\n+\n+impl<T> const Bar for T\n+where\n+    T: ~const Foo,\n+{}\n+\n+impl<T> const Bar for T\n+where\n+    T: ~const Foo,\n+    T: ~const Specialize,\n+{}\n+\n+fn main() {}"}, {"sha": "1e6b1c6513b39a5699e39e39bd5ea6a6c73a3b89", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/issue-95187-same-trait-bound-different-constness.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,45 @@\n+// Tests that `T: ~const Foo` in a specializing impl is treated as equivalent to\n+// `T: Foo` in the default impl for the purposes of specialization (i.e., it\n+// does not think that the user is attempting to specialize on trait `Foo`).\n+\n+// check-pass\n+\n+#![feature(rustc_attrs)]\n+#![feature(min_specialization)]\n+#![feature(const_trait_impl)]\n+\n+#[rustc_specialization_trait]\n+trait Specialize {}\n+\n+#[const_trait]\n+trait Foo {}\n+\n+#[const_trait]\n+trait Bar {}\n+\n+impl<T> Bar for T\n+where\n+    T: Foo,\n+{}\n+\n+impl<T> const Bar for T\n+where\n+    T: ~const Foo,\n+    T: Specialize,\n+{}\n+\n+#[const_trait]\n+trait Baz {}\n+\n+impl<T> const Baz for T\n+where\n+    T: Foo,\n+{}\n+\n+impl<T> const Baz for T\n+where\n+    T: ~const Foo,\n+    T: Specialize,\n+{}\n+\n+fn main() {}"}, {"sha": "35aa52fbd4ed205519e108db2084f42d1523c7d2", "filename": "src/test/ui/rfc-2632-const-trait-impl/specialization/non-const-default-const-specialized.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fnon-const-default-const-specialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fnon-const-default-const-specialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fnon-const-default-const-specialized.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,39 @@\n+// Tests that a non-const default impl can be specialized by a const trait impl,\n+// but that the default impl cannot be used in a const context.\n+\n+// run-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(min_specialization)]\n+\n+#[const_trait]\n+trait Value {\n+    fn value() -> u32;\n+}\n+\n+const fn get_value<T: ~const Value>() -> u32 {\n+    T::value()\n+}\n+\n+impl<T> Value for T {\n+    default fn value() -> u32 {\n+        println!(\"You can't do that (constly)\");\n+        0\n+    }\n+}\n+\n+struct FortyTwo;\n+\n+impl const Value for FortyTwo {\n+    fn value() -> u32 {\n+        42\n+    }\n+}\n+\n+fn main() {\n+    let zero = get_value::<()>();\n+    assert_eq!(zero, 0);\n+\n+    const FORTY_TWO: u32 = get_value::<FortyTwo>();\n+    assert_eq!(FORTY_TWO, 42);\n+}"}, {"sha": "9ab170f092006a05799cbca6298c1262b7b5ac93", "filename": "src/test/ui/rfc-2632-const-trait-impl/specializing-constness.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -17,7 +17,9 @@ impl<T: ~const Default> const A for T {\n     }\n }\n \n-impl<T: Default + Sup> A for T { //~ ERROR: cannot specialize\n+impl<T: Default + Sup> A for T {\n+//~^ ERROR: cannot specialize\n+//~| ERROR: missing `~const` qualifier\n     fn a() -> u32 {\n         3\n     }"}, {"sha": "843fc6ce84d45aa49c0531192b47877f3803d26f", "filename": "src/test/ui/rfc-2632-const-trait-impl/specializing-constness.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,8 +1,14 @@\n-error: cannot specialize on trait `Default`\n+error: cannot specialize on const impl with non-const impl\n+  --> $DIR/specializing-constness.rs:20:1\n+   |\n+LL | impl<T: Default + Sup> A for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing `~const` qualifier for specialization\n   --> $DIR/specializing-constness.rs:20:9\n    |\n LL | impl<T: Default + Sup> A for T {\n    |         ^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "063c3f013c5390474fc2b54f14ad2fbfe7bdd413", "filename": "src/test/ui/self/class-missing-self.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fself%2Fclass-missing-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fself%2Fclass-missing-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fclass-missing-self.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -10,6 +10,10 @@ error[E0425]: cannot find function `sleep` in this scope\n LL |       sleep();\n    |       ^^^^^ not found in this scope\n    |\n+help: consider using the associated function\n+   |\n+LL |       self.sleep();\n+   |       +++++\n help: consider importing this function\n    |\n LL | use std::thread::sleep;"}, {"sha": "cdf70920f009542e78d7dd2eab9dfd49b13ce063", "filename": "src/test/ui/sized/coinductive-1-gat.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1-gat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1-gat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1-gat.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+struct Node<C: Trait>(C::Assoc::<Self>);\n+\n+trait Trait {\n+    type Assoc<T>;\n+}\n+\n+impl Trait for Vec<()> {\n+    type Assoc<T> = Vec<T>;\n+}\n+\n+fn main() {\n+    let _ = Node::<Vec<()>>(Vec::new());\n+}"}, {"sha": "7bcd0f1fdaf6d55eac6f68382c99f508bf50df4e", "filename": "src/test/ui/sized/coinductive-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Fcoinductive-1.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+struct Node<C: Trait<Self>>(C::Assoc);\n+\n+trait Trait<T> {\n+    type Assoc;\n+}\n+\n+impl<T> Trait<T> for Vec<()> {\n+    type Assoc = Vec<T>;\n+}\n+\n+fn main() {\n+    let _ = Node::<Vec<()>>(Vec::new());\n+}"}, {"sha": "212274d2e4b6c8350c25bc6c9a66037a64d775b3", "filename": "src/test/ui/sized/coinductive-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Fcoinductive-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Fcoinductive-2.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+struct Node<C: CollectionFactory<Self>> {\n+    _children: C::Collection,\n+}\n+\n+trait CollectionFactory<T> {\n+    type Collection;\n+}\n+\n+impl<T> CollectionFactory<T> for Vec<()> {\n+    type Collection = Vec<T>;\n+}\n+\n+trait Collection<T>: Sized {\n+    fn push(&mut self, v: T);\n+}\n+\n+impl<T> Collection<T> for Vec<T> {\n+    fn push(&mut self, v: T) {\n+        self.push(v)\n+    }\n+}\n+\n+fn main() {\n+    let _ = Node::<Vec<()>> {\n+        _children: Vec::new(),\n+    };\n+}"}, {"sha": "cd6805967e524e2d860104818365d90157332431", "filename": "src/test/ui/sized/recursive-type-1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Frecursive-type-1.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+trait A { type Assoc; }\n+\n+impl A for () {\n+    // FIXME: it would be nice for this to at least cause a warning.\n+    type Assoc = Foo<()>;\n+}\n+struct Foo<T: A>(T::Assoc);\n+\n+fn main() {}"}, {"sha": "7d95417a6ffd97ed0deffc8d0788783684e487b6", "filename": "src/test/ui/sized/recursive-type-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,13 @@\n+// build-fail\n+//~^ ERROR cycle detected when computing layout of `Foo<()>`\n+\n+trait A { type Assoc: ?Sized; }\n+\n+impl A for () {\n+    type Assoc = Foo<()>;\n+}\n+struct Foo<T: A>(T::Assoc);\n+\n+fn main() {\n+    let x: Foo<()>;\n+}"}, {"sha": "d0e6e9db07e9bfa6b970c68a35deae6d8ce63671", "filename": "src/test/ui/sized/recursive-type-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized%2Frecursive-type-2.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,13 @@\n+error[E0391]: cycle detected when computing layout of `Foo<()>`\n+   |\n+   = note: ...which requires computing layout of `<() as A>::Assoc`...\n+   = note: ...which again requires computing layout of `Foo<()>`, completing the cycle\n+note: cycle used when elaborating drops for `main`\n+  --> $DIR/recursive-type-2.rs:11:1\n+   |\n+LL | fn main() {\n+   | ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "febdd67338c991263c9f398ad89c7db59b988f4a", "filename": "src/test/ui/suggestions/assoc_fn_without_self.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -7,13 +7,18 @@ LL |         foo();\n help: consider using the associated function\n    |\n LL |         Self::foo();\n-   |         ~~~~~~~~~\n+   |         ++++++\n \n error[E0425]: cannot find function `bar` in this scope\n   --> $DIR/assoc_fn_without_self.rs:17:9\n    |\n LL |         bar();\n    |         ^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         self.bar();\n+   |         +++++\n \n error[E0425]: cannot find function `baz` in this scope\n   --> $DIR/assoc_fn_without_self.rs:18:9\n@@ -24,7 +29,7 @@ LL |         baz(2, 3);\n help: consider using the associated function\n    |\n LL |         Self::baz(2, 3);\n-   |         ~~~~~~~~~\n+   |         ++++++\n \n error[E0425]: cannot find function `foo` in this scope\n   --> $DIR/assoc_fn_without_self.rs:14:13"}, {"sha": "37bae2e90a595a0252eabf1f907ff6b59857ce37", "filename": "src/test/ui/traits/issue-82830.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,10 +1,12 @@\n+// check-pass\n+\n trait A<Y, N> {\n     type B;\n }\n \n type MaybeBox<T> = <T as A<T, Box<T>>>::B;\n struct P {\n-    t: MaybeBox<P>, //~ ERROR: overflow evaluating the requirement `P: Sized`\n+    t: MaybeBox<P>,\n }\n \n impl<Y, N> A<Y, N> for P {"}, {"sha": "6a597a402156f1926912f3ac5bb958a4e53187ec", "filename": "src/test/ui/traits/issue-82830.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-82830.stderr?ref=7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "patch": "@@ -1,15 +0,0 @@\n-error[E0275]: overflow evaluating the requirement `P: Sized`\n-  --> $DIR/issue-82830.rs:7:8\n-   |\n-LL |     t: MaybeBox<P>,\n-   |        ^^^^^^^^^^^\n-   |\n-note: required for `P` to implement `A<P, Box<P>>`\n-  --> $DIR/issue-82830.rs:10:12\n-   |\n-LL | impl<Y, N> A<Y, N> for P {\n-   |            ^^^^^^^     ^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0275`."}, {"sha": "607ffe0cc59feb11d3c735ea3bddd0d7b53aa0c3", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -67,9 +67,9 @@ jobs:\n         shell: bash\n         run: |\n           if [[ ${{ github.event_name }} == 'schedule' ]]; then\n-            ./rustup-toolchain HEAD --host ${{ matrix.host_target }}\n+            ./miri toolchain HEAD --host ${{ matrix.host_target }}\n           else\n-            ./rustup-toolchain \"\" --host ${{ matrix.host_target }}\n+            ./miri toolchain \"\" --host ${{ matrix.host_target }}\n           fi\n \n       - name: Show Rust version\n@@ -118,7 +118,7 @@ jobs:\n       - name: Install \"master\" toolchain\n         shell: bash\n         run: |\n-          ./rustup-toolchain \"\" -c clippy\n+          ./miri toolchain\n \n       - name: Show Rust version\n         run: |"}, {"sha": "724cf26df2b9b3f85a26b45e7ea8144233dfea05", "filename": "src/tools/miri/.gitpod.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2F.gitpod.yml", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2F.gitpod.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.gitpod.yml?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -4,6 +4,6 @@ tasks:\n   - before: echo \"...\"\n     init: |\n       cargo install rustup-toolchain-install-master\n-      ./rustup-toolchain\n+      ./miri toolchain\n       ./miri build\n-    command: echo \"Run tests with ./miri test\"\n\\ No newline at end of file\n+    command: echo \"Run tests with ./miri test\""}, {"sha": "5c41547616ec68d0e9c8d50673cbadf45f2ffef8", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -23,13 +23,13 @@ tested against. Other versions will likely not work. After installing\n [`rustup-toolchain-install-master`], you can run the following command to\n install that exact version of rustc as a toolchain:\n ```\n-./rustup-toolchain\n+./miri toolchain\n ```\n This will set up a rustup toolchain called `miri` and set it as an override for\n the current directory.\n \n You can also create a `.auto-everything` file (contents don't matter, can be empty), which\n-will cause any `./miri` command to automatically call `rustup-toolchain`, `clippy` and `rustfmt`\n+will cause any `./miri` command to automatically call `./miri toolchain`, `clippy` and `rustfmt`\n for you. If you don't want all of these to happen, you can add individual `.auto-toolchain`,\n `.auto-clippy` and `.auto-fmt` files respectively.\n \n@@ -132,12 +132,15 @@ development version of Miri using\n and then you can use it as if it was installed by `rustup`.  Make sure you use\n the same toolchain when calling `cargo miri` that you used when installing Miri!\n Usually this means you have to write `cargo +miri miri ...` to select the `miri`\n-toolchain that was installed by `./rustup-toolchain`.\n+toolchain that was installed by `./miri toolchain`.\n \n There's a test for the cargo wrapper in the `test-cargo-miri` directory; run\n `./run-test.py` in there to execute it. Like `./miri test`, this respects the\n `MIRI_TEST_TARGET` environment variable to execute the test for another target.\n \n+Note that installing Miri like this will \"take away\" Miri management from `rustup`.\n+If you want to later go back to a rustup-installed Miri, run `rustup update`.\n+\n ### Using a modified standard library\n \n Miri re-builds the standard library into a custom sysroot, so it is fairly easy\n@@ -214,7 +217,7 @@ for changes in rustc. In both cases, `rustc-version` needs updating.\n \n To update the `rustc-version` file and install the latest rustc, you can run:\n ```\n-./rustup-toolchain HEAD\n+./miri toolchain HEAD\n ```\n \n Now edit Miri until `./miri test` passes, and submit a PR. Generally, it is\n@@ -290,16 +293,14 @@ cargo run --release -p josh-proxy -- --local=$(pwd)/local --remote=https://githu\n \n ### Importing changes from the rustc repo\n \n+Josh needs to be running, as described above.\n We assume we start on an up-to-date master branch in the Miri repo.\n \n ```sh\n-# Fetch rustc side of the history. Takes ca 5 min the first time.\n-# Do NOT change that commit ID, it needs to be exactly this!\n-git fetch http://localhost:8000/rust-lang/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git master\n-# Include that history into ours.\n-git merge FETCH_HEAD -m \"merge rustc history\"\n+# Fetch and merge rustc side of the history. Takes ca 5 min the first time.\n+./miri rustc-pull\n # Update toolchain reference and apply formatting.\n-./rustup-toolchain HEAD && ./miri fmt\n+./miri toolchain HEAD && ./miri fmt\n git commit -am \"rustup\"\n ```\n \n@@ -310,16 +311,15 @@ needed.\n \n ### Exporting changes to the rustc repo\n \n-We will use the josh proxy to push to your fork of rustc. You need to make sure\n-that the master branch of your fork is up-to-date. Also make sure that there\n-exists no branch called `miri` in your fork. Then run the following in the Miri\n-repo, assuming we are on an up-to-date master branch:\n+Josh needs to be running, as described above. We will use the josh proxy to push\n+to your fork of rustc. Run the following in the Miri repo, assuming we are on an\n+up-to-date master branch:\n \n ```sh\n # Push the Miri changes to your rustc fork (substitute your github handle for YOUR_NAME).\n-# Do NOT change that commit ID, it needs to be exactly this!\n-git push http://localhost:8000/YOUR_NAME/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git -o base=master HEAD:miri\n+./miri rustc-push YOUR_NAME miri\n ```\n \n-This will create a new branch in your fork, and the output should include a link\n-to create a rustc PR that will integrate those changes into the main repository.\n+This will create a new branch called 'miri' in your fork, and the output should\n+include a link to create a rustc PR that will integrate those changes into the\n+main repository."}, {"sha": "1185525f6865c33cd3a3d8a3d2a2731c45209e92", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -374,14 +374,15 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n-* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n+* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into *all* fields.\n   This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n   and in particular, they are protected when passed as function arguments.\n+  (The default is to recurse only in cases where rustc would actually emit a `noalias` attribute.)\n * `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n   fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n-  recurses (the default), `scalar` means it only recurses for types where we would also emit\n+  recurses, `scalar` (the default) means it only recurses for types where we would also emit\n   `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n-  scalars).\n+  scalars). Setting this to `none` is **unsound**.\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to\n   `0` disables the garbage collector, which causes some programs to have explosive memory usage\n@@ -419,9 +420,9 @@ Some native rustc `-Z` flags are also very relevant for Miri:\n \n Moreover, Miri recognizes some environment variables:\n \n-* `MIRI_AUTO_OPS` indicates whether the automatic execution of rustfmt, clippy and rustup-toolchain\n-  should be skipped. If it is set to any value, they are skipped. This is used for avoiding\n-  infinite recursion in `./miri` and to allow automated IDE actions to avoid the auto ops.\n+* `MIRI_AUTO_OPS` indicates whether the automatic execution of rustfmt, clippy and toolchain setup\n+  should be skipped. If it is set to any value, they are skipped. This is used for avoiding infinite\n+  recursion in `./miri` and to allow automated IDE actions to avoid the auto ops.\n * `MIRI_LOG`, `MIRI_BACKTRACE` control logging and backtrace printing during\n   Miri executions, also [see \"Testing the Miri driver\" in `CONTRIBUTING.md`][testing-miri].\n * `MIRIFLAGS` (recognized by `cargo miri` and the test suite) defines extra"}, {"sha": "df36041c75ed32f5af95b6a47907afc38fbfa7d6", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -528,7 +528,7 @@ pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: Runner\n     cmd.args(binary_args);\n \n     // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n-    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n+    // But then we need to switch to the run-time one, which we instruct Miri to do by setting `MIRI_CWD`.\n     cmd.current_dir(info.current_dir);\n     cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n "}, {"sha": "f0986bfb1cdbe847216bff42cd684ee19924c745", "filename": "src/tools/miri/miri", "status": "modified", "additions": 125, "deletions": 31, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -42,6 +42,22 @@ many different seeds.\n Runs the benchmarks from bench-cargo-miri in hyperfine. hyperfine needs to be installed.\n <benches> can explicitly list the benchmarks to run; by default, all of them are run.\n \n+./miri rustc-pull:\n+Pull and merge Miri changes from the rustc repo.\n+\n+./miri rustc-push <github user> <branch>:\n+Push Miri changes back to the rustc repo. This will update the 'master' branch\n+in the Rust fork of the given user to upstream. It will also pull a copy of the\n+rustc history into the Miri repo, unless you set the RUSTC_GIT env var to an\n+existing clone of the rustc repo.\n+\n+./miri toolchain <commit> <flags>:\n+Update and activate the rustup toolchain 'miri'. If no commit is given, updates\n+to the commit given in the `rust-version` file. If the commit is `HEAD`, updates\n+to the latest upstream rustc commit.\n+`rustup-toolchain-install-master` must be installed for this to work. Any extra\n+flags are passed to `rustup-toolchain-install-master`.\n+\n   ENVIRONMENT VARIABLES\n \n MIRI_SYSROOT:\n@@ -52,37 +68,98 @@ Pass extra flags to all cargo invocations. (Ignored by `./miri cargo`.)\n EOF\n )\n \n-## We need to know where we are.\n+## We need to know which command to run and some global constants.\n+COMMAND=\"$1\"\n+if [ -z \"$COMMAND\" ]; then\n+    echo \"$USAGE\"\n+    exit 1\n+fi\n+shift\n # macOS does not have a useful readlink/realpath so we have to use Python instead...\n MIRIDIR=$(python3 -c 'import os, sys; print(os.path.dirname(os.path.realpath(sys.argv[1])))' \"$0\")\n+# Used for rustc syncs.\n+JOSH_FILTER=\":at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri\"\n+# Needed for `./miri bench`.\n+TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n \n-## Run the auto-things.\n-if [ -z \"$MIRI_AUTO_OPS\" ]; then\n-    export MIRI_AUTO_OPS=42\n-\n-    # Run this first, so that the toolchain doesn't change after\n-    # other code has run.\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-toolchain\" ] ; then\n-        (cd \"$MIRIDIR\" && ./rustup-toolchain)\n+## Early commands, that don't do auto-things and don't want the environment-altering things happening below.\n+case \"$COMMAND\" in\n+toolchain)\n+    cd \"$MIRIDIR\"\n+    # Make sure rustup-toolchain-install-master is installed.\n+    if ! which rustup-toolchain-install-master >/dev/null; then\n+        echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n+        exit 1\n     fi\n-\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-fmt\" ] ; then\n-        $0 fmt\n+    # Determine new commit.\n+    if [[ \"$1\" == \"\" ]]; then\n+        NEW_COMMIT=$(cat rust-version)\n+    elif [[ \"$1\" == \"HEAD\" ]]; then\n+        NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n+    else\n+        NEW_COMMIT=\"$1\"\n     fi\n-\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-clippy\" ] ; then\n-        $0 clippy -- -D warnings\n+    echo \"$NEW_COMMIT\" > rust-version\n+    shift || true # don't fail if shifting fails because no commit was given\n+    # Check if we already are at that commit.\n+    CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n+    if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n+        echo \"miri toolchain is already at commit $CUR_COMMIT.\"\n+        rustup override set miri\n+        exit 0\n     fi\n-fi\n-\n-## Determine command and toolchain.\n-COMMAND=\"$1\"\n-[ $# -gt 0 ] && shift\n-# Doing this *after* auto-toolchain logic above, since that might change the toolchain.\n-TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n-\n-## Handle some commands early, since they should *not* alter the environment.\n-case \"$COMMAND\" in\n+    # Install and setup new toolchain.\n+    rustup toolchain uninstall miri\n+    rustup-toolchain-install-master -n miri -c cargo -c rust-src -c rustc-dev -c llvm-tools -c rustfmt -c clippy \"$@\" -- \"$NEW_COMMIT\"\n+    rustup override set miri\n+    # Cleanup.\n+    cargo clean\n+    # Call 'cargo metadata' on the sources in case that changes the lockfile\n+    # (which fails under some setups when it is done from inside vscode).\n+    cargo metadata --format-version 1 --manifest-path \"$(rustc --print sysroot)/lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\" >/dev/null\n+    # Done!\n+    exit 0\n+    ;;\n+rustc-pull)\n+    cd \"$MIRIDIR\"\n+    git fetch http://localhost:8000/rust-lang/rust.git$JOSH_FILTER.git master\n+    git merge FETCH_HEAD --no-ff -m \"Merge from rustc\"\n+    exit 0\n+    ;;\n+rustc-push)\n+    USER=\"$1\"\n+    BRANCH=\"$2\"\n+    if [ -z \"$USER\" ] || [ -z \"$BRANCH\" ]; then\n+        echo \"Usage: $0 rustc-push <github user> <branch>\"\n+        exit 1\n+    fi\n+    if [ -n \"$RUSTC_GIT\" ]; then\n+        # Use an existing fork for the branch updates.\n+        cd \"$RUSTC_GIT\"\n+    else\n+        # Do this in the local Miri repo.\n+        echo \"This will pull a copy of the rust-lang/rust history into this Miri checkout, growing it by about 1GB.\"\n+        read -r -p \"To avoid that, abort now and set the RUSTC_GIT environment variable to an existing rustc checkout. Proceed? [y/N] \"\n+        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n+            exit 1\n+        fi\n+        cd \"$MIRIDIR\"\n+    fi\n+    # Prepare the branches. For reliable pushing we need to push to a non-existent branch\n+    # and set `-o base` to a branch that holds current rustc master.\n+    echo \"Preparing $USER/rust...\"\n+    if git fetch https://github.com/$USER/rust $BRANCH &>/dev/null; then\n+        echo \"The '$BRANCH' seems to already exist in $USER/rust. Please delete it and try again.\"\n+        exit 1\n+    fi\n+    git fetch https://github.com/rust-lang/rust master\n+    git push https://github.com/$USER/rust FETCH_HEAD:master\n+    # Do the actual push.\n+    cd \"$MIRIDIR\"\n+    echo \"Pushing Miri changes...\"\n+    git push http://localhost:8000/$USER/rust.git$JOSH_FILTER.git HEAD:$BRANCH -o base=master\n+    exit 0\n+    ;;\n many-seeds)\n     for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n         echo \"Trying seed: $SEED\"\n@@ -106,9 +183,29 @@ bench)\n     ;;\n esac\n \n+## Run the auto-things.\n+if [ -z \"$MIRI_AUTO_OPS\" ]; then\n+    export MIRI_AUTO_OPS=42\n+\n+    # Run this first, so that the toolchain doesn't change after\n+    # other code has run.\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-toolchain\" ] ; then\n+        $0 toolchain\n+        # Let's make sure to actually use that toolchain, too.\n+        TOOLCHAIN=miri\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-fmt\" ] ; then\n+        $0 fmt\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-clippy\" ] ; then\n+        $0 clippy -- -D warnings\n+    fi\n+fi\n+\n ## Prepare the environment\n # Determine some toolchain properties\n-# export the target so its available in miri\n TARGET=$(rustc +$TOOLCHAIN --version --verbose | grep \"^host:\" | cut -d ' ' -f 2)\n SYSROOT=$(rustc +$TOOLCHAIN --print sysroot)\n LIBDIR=$SYSROOT/lib/rustlib/$TARGET/lib\n@@ -227,10 +324,7 @@ cargo)\n     $CARGO \"$@\"\n     ;;\n *)\n-    if [ -n \"$COMMAND\" ]; then\n-      echo \"Unknown command: $COMMAND\"\n-      echo\n-    fi\n-    echo \"$USAGE\"\n+    echo \"Unknown command: $COMMAND\"\n     exit 1\n+    ;;\n esac"}, {"sha": "13492d183c99996c2a0c100fa8a45d270130c327", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1 +1 @@\n-85d089b41e2a0c0f07ab34f6c5a7c451389f25e6\n+b03502b35d111bef0399a66ab3cc765f0802e8ba"}, {"sha": "d7730f2b06d36a33cceb880461bef5213ff719c3", "filename": "src/tools/miri/rustup-toolchain", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftools%2Fmiri%2Frustup-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf/src%2Ftools%2Fmiri%2Frustup-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frustup-toolchain?ref=7d85104b96fb2ffe7b638ffbfb1794ef5652bdcf", "patch": "@@ -1,53 +0,0 @@\n-#!/bin/bash\n-set -e\n-# Manages a rustup toolchain called \"miri\".\n-#\n-# All commands set \"miri\" as the override toolchain for the current directory,\n-# and make the `rust-version` file match that toolchain.\n-#\n-# USAGE:\n-#\n-# ./rustup-toolchain: Update \"miri\" toolchain to match `rust-version` (the known-good version for this commit).\n-#\n-# ./rustup-toolchain HEAD: Update \"miri\" toolchain and `rust-version` file to latest rustc HEAD.\n-#\n-# ./rustup-toolchain $COMMIT: Update \"miri\" toolchain and `rust-version` file to match that commit.\n-#\n-# Any extra parameters are passed to `rustup-toolchain-install-master`.\n-\n-# Make sure rustup-toolchain-install-master is installed.\n-if ! which rustup-toolchain-install-master >/dev/null; then\n-    echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n-    exit 1\n-fi\n-\n-# Determine new commit.\n-if [[ \"$1\" == \"\" ]]; then\n-    NEW_COMMIT=$(cat rust-version)\n-elif [[ \"$1\" == \"HEAD\" ]]; then\n-    NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n-else\n-    NEW_COMMIT=\"$1\"\n-fi\n-echo \"$NEW_COMMIT\" > rust-version\n-shift || true # don't fail if shifting fails\n-\n-# Check if we already are at that commit.\n-CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n-if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n-    echo \"miri toolchain is already at commit $CUR_COMMIT.\"\n-    rustup override set miri\n-    exit 0\n-fi\n-\n-# Install and setup new toolchain.\n-rustup toolchain uninstall miri\n-rustup-toolchain-install-master -n miri -c cargo -c rust-src -c rustc-dev -c llvm-tools -c rustfmt -c clippy \"$@\" -- \"$NEW_COMMIT\"\n-rustup override set miri\n-\n-# Cleanup.\n-cargo clean\n-\n-# Call 'cargo metadata' on the sources in case that changes the lockfile\n-# (which fails under some setups when it is done from inside vscode).\n-cargo metadata --format-version 1 --manifest-path \"$(rustc --print sysroot)/lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\" >/dev/null"}, {"sha": "eb42cdf80abbeb5de883a9dc009948fc5777f2df", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -3,7 +3,7 @@ use std::num::NonZeroU32;\n \n use rustc_index::vec::Idx;\n \n-use super::sync::EvalContextExtPriv;\n+use super::sync::EvalContextExtPriv as _;\n use super::thread::MachineCallback;\n use super::vector_clock::VClock;\n use crate::*;\n@@ -52,6 +52,43 @@ impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Synchronize with the previous initialization attempt of an InitOnce.\n+    #[inline]\n+    fn init_once_observe_attempt(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(\n+                &this.machine.threads.sync.init_onces[id].data_race,\n+                current_thread,\n+            );\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_wake_waiter(\n+        &mut self,\n+        id: InitOnceId,\n+        waiter: InitOnceWaiter<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        this.unblock_thread(waiter.thread);\n+\n+        // Call callback, with the woken-up thread as `current`.\n+        this.set_active_thread(waiter.thread);\n+        this.init_once_observe_attempt(id);\n+        waiter.callback.call(this)?;\n+        this.set_active_thread(current_thread);\n+\n+        Ok(())\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_get_or_create_id(\n@@ -141,20 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Wake up everyone.\n         // need to take the queue to avoid having `this` be borrowed multiple times\n         for waiter in std::mem::take(&mut init_once.waiters) {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         }\n \n         Ok(())\n@@ -172,33 +196,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         );\n \n         // Each complete happens-before the end of the wait\n-        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n-        // but the docs don't talk about such details.\n         if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this.\n         if let Some(waiter) = init_once.waiters.pop_front() {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         } else {\n             // Nobody there to take this, so go back to 'uninit'\n             init_once.status = InitOnceStatus::Uninitialized;\n         }\n \n         Ok(())\n     }\n+\n+    /// Synchronize with the previous completion of an InitOnce.\n+    /// Must only be called after checking that it is complete.\n+    #[inline]\n+    fn init_once_observe_completed(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+\n+        assert_eq!(\n+            this.init_once_status(id),\n+            InitOnceStatus::Complete,\n+            \"observing the completion of incomplete init once\"\n+        );\n+\n+        this.init_once_observe_attempt(id);\n+    }\n }"}, {"sha": "ba5ae852c5a960663d694ca6eb9ca0020047730c", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -116,13 +116,25 @@ struct RwLock {\n \n declare_id!(CondvarId);\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum RwLockMode {\n+    Read,\n+    Write,\n+}\n+\n+#[derive(Debug)]\n+pub enum CondvarLock {\n+    Mutex(MutexId),\n+    RwLock { id: RwLockId, mode: RwLockMode },\n+}\n+\n /// A thread waiting on a conditional variable.\n #[derive(Debug)]\n struct CondvarWaiter {\n     /// The thread that is waiting on this variable.\n     thread: ThreadId,\n-    /// The mutex on which the thread is waiting.\n-    mutex: MutexId,\n+    /// The mutex or rwlock on which the thread is waiting.\n+    lock: CondvarLock,\n }\n \n /// The conditional variable state.\n@@ -569,16 +581,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark that the thread is waiting on the conditional variable.\n-    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, mutex: MutexId) {\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: CondvarLock) {\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, mutex });\n+        waiters.push_back(CondvarWaiter { thread, lock });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional\n     /// variable.\n-    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, MutexId)> {\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n@@ -592,7 +604,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n-            (waiter.thread, waiter.mutex)\n+            (waiter.thread, waiter.lock)\n         })\n     }\n "}, {"sha": "81132db94cf181ff1583031304e4535d47099dbc", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -163,7 +163,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n-            retag_fields: RetagFields::No,\n+            retag_fields: RetagFields::OnlyScalar,\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,"}, {"sha": "a7275646847e29ed42c09ceede08e0cea1f6ccb7", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -3,6 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n+use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n \n@@ -696,8 +697,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        if let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        if let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -710,8 +715,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        while let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -729,7 +738,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         Ok(0)\n     }\n@@ -768,7 +777,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;"}, {"sha": "e16749c986b168cfb6f77a350e69783271126d12", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -273,6 +273,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.InitOnceComplete(ptr, flags, context)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"SleepConditionVariableSRW\" => {\n+                let [condvar, lock, timeout, flags] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                let result = this.SleepConditionVariableSRW(condvar, lock, timeout, flags, dest)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"WakeConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeConditionVariable(condvar)?;\n+            }\n+            \"WakeAllConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeAllConditionVariable(condvar)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "8f414d98dba5f70a979aa132a0caac8bbdd979c5", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 165, "deletions": 2, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -3,11 +3,45 @@ use std::time::Duration;\n use rustc_target::abi::Size;\n \n use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::sync::{CondvarLock, RwLockMode};\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n+const CONDVAR_ID_OFFSET: u64 = 0;\n+\n+impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Try to reacquire the lock associated with the condition variable after we\n+    /// were signaled.\n+    fn reacquire_cond_lock(\n+        &mut self,\n+        thread: ThreadId,\n+        lock: RwLockId,\n+        mode: RwLockMode,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.unblock_thread(thread);\n+\n+        match mode {\n+            RwLockMode::Read =>\n+                if this.rwlock_is_write_locked(lock) {\n+                    this.rwlock_enqueue_and_block_reader(lock, thread);\n+                } else {\n+                    this.rwlock_reader_lock(lock, thread);\n+                },\n+            RwLockMode::Write =>\n+                if this.rwlock_is_locked(lock) {\n+                    this.rwlock_enqueue_and_block_writer(lock, thread);\n+                } else {\n+                    this.rwlock_writer_lock(lock, thread);\n+                },\n+        }\n+\n+        Ok(())\n+    }\n+}\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n #[allow(non_snake_case)]\n@@ -177,8 +211,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     Box::new(Callback { init_once_id: id, pending_place }),\n                 )\n             }\n-            InitOnceStatus::Complete =>\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+            InitOnceStatus::Complete => {\n+                this.init_once_observe_completed(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+            }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n@@ -325,4 +361,131 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn SleepConditionVariableSRW(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+        let lock_id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(this.machine.clock.now().checked_add(duration).unwrap())\n+        };\n+\n+        let shared_mode = 0x1; // CONDITION_VARIABLE_LOCKMODE_SHARED is not in std\n+        let mode = if flags == 0 {\n+            RwLockMode::Write\n+        } else if flags == shared_mode {\n+            RwLockMode::Read\n+        } else {\n+            throw_unsup_format!(\"unsupported `Flags` {flags} in `SleepConditionVariableSRW`\");\n+        };\n+\n+        let active_thread = this.get_active_thread();\n+\n+        let was_locked = match mode {\n+            RwLockMode::Read => this.rwlock_reader_unlock(lock_id, active_thread),\n+            RwLockMode::Write => this.rwlock_writer_unlock(lock_id, active_thread),\n+        };\n+\n+        if !was_locked {\n+            throw_ub_format!(\n+                \"calling SleepConditionVariableSRW with an SRWLock that is not locked by the current thread\"\n+            );\n+        }\n+\n+        this.block_thread(active_thread);\n+        this.condvar_wait(condvar_id, active_thread, CondvarLock::RwLock { id: lock_id, mode });\n+\n+        if let Some(timeout_time) = timeout_time {\n+            struct Callback<'tcx> {\n+                thread: ThreadId,\n+                condvar_id: CondvarId,\n+                lock_id: RwLockId,\n+                mode: RwLockMode,\n+                dest: PlaceTy<'tcx, Provenance>,\n+            }\n+\n+            impl<'tcx> VisitTags for Callback<'tcx> {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n+                    dest.visit_tags(visit);\n+                }\n+            }\n+\n+            impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                    this.reacquire_cond_lock(self.thread, self.lock_id, self.mode)?;\n+\n+                    this.condvar_remove_waiter(self.condvar_id, self.thread);\n+\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    this.set_last_error(error_timeout)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    Ok(())\n+                }\n+            }\n+\n+            this.register_timeout_callback(\n+                active_thread,\n+                Time::Monotonic(timeout_time),\n+                Box::new(Callback {\n+                    thread: active_thread,\n+                    condvar_id,\n+                    lock_id,\n+                    mode,\n+                    dest: dest.clone(),\n+                }),\n+            );\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        if let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn WakeAllConditionVariable(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        while let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "7f18e5dbae052ebbeb7406964173c08ebf1e33ea", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -252,7 +252,7 @@ pub fn err_sb_ub<'tcx>(\n /// We need to make at least the following things true:\n ///\n /// U1: After creating a `Uniq`, it is at the top.\n-/// U2: If the top is `Uniq`, accesses must be through that `Uniq` or remove it it.\n+/// U2: If the top is `Uniq`, accesses must be through that `Uniq` or remove it.\n /// U3: If an access happens with a `Uniq`, it requires the `Uniq` to be in the stack.\n ///\n /// F1: After creating a `&`, the parts outside `UnsafeCell` have our `SharedReadOnly` on top."}, {"sha": "cc774500a3c69d69351c32d542743fe8f1f81730", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32, i32);\n "}, {"sha": "1aa6e240e30f1699f5122d42d0b7a281092b7354", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n "}, {"sha": "5a9dc6afba8da9e85617915b52a0ecf2729eb232", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,16 +1,15 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 }; // let-bind to avoid 2phase\n     let ret = Some(ret);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "c0ff35ebcde307aa39834ff5a11314ee51345033", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let ret = Some(ret);\n-   |                    ^^^\n+   |               ^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+  --> $DIR/return_invalid_mut_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "8fe7f15cab0c12c2f7b5df8d71fe90e059c6c26b", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "9abf43c29f08fb3e44601d09e248eeff7288fe9c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &mut (*xraw).1 },);\n-   |                         ^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "094ce33b9c1f73c9540a20e66417ed8fcc990f1f", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,15 +1,14 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "6066bf89f5d095806cab091431260eebca461801", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     let ret = Some(unsafe { &(*xraw).1 });\n-   |                             ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+  --> $DIR/return_invalid_shr_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "d0fd53e06aa2624fa88ee8b3f4f85de319e1632c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "52d365246a74441852bee7c4f2912844c3933159", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &(*xraw).1 },);\n-   |                         ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "19ea6c130bdd8ceb980076b42b5d45736a4c4a20", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -230,20 +230,8 @@ fn main() {\n     check_once();\n     park_timeout();\n     park_unpark();\n-\n-    if !cfg!(windows) {\n-        // ignore-target-windows: Condvars on Windows are not supported yet\n-        check_barriers();\n-        check_conditional_variables_notify_one();\n-        check_conditional_variables_timed_wait_timeout();\n-        check_conditional_variables_timed_wait_notimeout();\n-    } else {\n-        // We need to fake the same output...\n-        for _ in 0..10 {\n-            println!(\"before wait\");\n-        }\n-        for _ in 0..10 {\n-            println!(\"after wait\");\n-        }\n-    }\n+    check_barriers();\n+    check_conditional_variables_notify_one();\n+    check_conditional_variables_timed_wait_timeout();\n+    check_conditional_variables_timed_wait_notimeout();\n }"}, {"sha": "c6cff038f81e0eafa5b993d0d0ab84ddc132f9e4", "filename": "src/tools/miri/tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n "}, {"sha": "d89320bfe59718988be92feab3da341baadea0ca", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,227 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn SleepConditionVariableSRW(\n+        condvar: *mut *mut c_void,\n+        lock: *mut *mut c_void,\n+        timeout: u32,\n+        flags: u32,\n+    ) -> i32;\n+    fn WakeAllConditionVariable(condvar: *mut *mut c_void);\n+\n+    fn AcquireSRWLockExclusive(lock: *mut *mut c_void);\n+    fn AcquireSRWLockShared(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockExclusive(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockShared(lock: *mut *mut c_void);\n+}\n+\n+const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;\n+const INFINITE: u32 = u32::MAX;\n+\n+/// threads should be able to reacquire the lock while it is locked by multiple other threads in shared mode\n+fn all_shared() {\n+    println!(\"all_shared\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+\n+    // waiters\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    // readers\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// reacquiring a lock should wait until the lock is not exclusively locked\n+fn shared_sleep_and_exclusive_lock() {\n+    println!(\"shared_sleep_and_exclusive_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut waiters = Vec::with_capacity(5);\n+    for i in 0..5 {\n+        waiters.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"shared waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"shared waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        AcquireSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main locked\");\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    // waiters are now waiting for the lock to be unlocked\n+    thread::yield_now();\n+\n+    unsafe {\n+        ReleaseSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main unlocked\");\n+\n+    for handle in waiters {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// threads reacquiring locks should wait for all locks to be released first\n+fn exclusive_sleep_and_shared_lock() {\n+    println!(\"exclusive_sleep_and_shared_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockExclusive(lock_ptr.0);\n+            }\n+\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe { SleepConditionVariableSRW(condvar_ptr.0, lock_ptr.0, INFINITE, 0) };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // switch to next waiter or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockExclusive(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} unlocked\");\n+        }));\n+    }\n+\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    all_shared();\n+    shared_sleep_and_exclusive_lock();\n+    exclusive_sleep_and_shared_lock();\n+}"}, {"sha": "918b54668f201cfafb6aab0df18cdb9041b8bf9f", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,60 @@\n+all_shared\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 4 reacquired lock\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+shared_sleep_and_exclusive_lock\n+shared waiter 0 locked\n+shared waiter 1 locked\n+shared waiter 2 locked\n+shared waiter 3 locked\n+shared waiter 4 locked\n+main locked\n+main unlocked\n+shared waiter 0 reacquired lock\n+shared waiter 1 reacquired lock\n+shared waiter 2 reacquired lock\n+shared waiter 3 reacquired lock\n+shared waiter 4 reacquired lock\n+exclusive_sleep_and_shared_lock\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 0 unlocked\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 1 unlocked\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 2 unlocked\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 3 unlocked\n+exclusive waiter 4 reacquired lock\n+exclusive waiter 4 unlocked"}, {"sha": "4eb88379620597dd28a36ef8ddfb60571b534a03", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -131,8 +131,46 @@ fn retry_on_fail() {\n     waiter2.join().unwrap();\n }\n \n+fn no_data_race_after_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let mut place = 0;\n+    let place_ptr = SendPtr(&mut place);\n+\n+    let reader = thread::spawn(move || unsafe {\n+        let mut pending = 0;\n+\n+        // this doesn't block because reader only executes after `InitOnceComplete` is called\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+        // this should not data race\n+        place_ptr.0.read()\n+    });\n+\n+    unsafe {\n+        // this should not data race\n+        place_ptr.0.write(1);\n+    }\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+\n+    // run reader (without preemption, it has not taken a step yet)\n+    assert_eq!(reader.join().unwrap(), 1);\n+}\n+\n fn main() {\n     single_thread();\n     block_until_complete();\n     retry_on_fail();\n+    no_data_race_after_complete();\n }"}, {"sha": "776bc2057f3501fd9d1773b717bce1e426b8407b", "filename": "src/tools/miri/tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "48fc8e8668ce041a37a9754ce3d706a04f137674", "filename": "src/tools/miri/tests/pass/stacked-borrows/no_field_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=none\n+\n+struct Newtype<'a>(&'a mut i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we do *not* retag the fields of `Newtype`.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "296339e73845576ccc72d3c8912ac0984f7fc320", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/42325c525b9d3885847a3f803abe53c562d289da/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout?ref=42325c525b9d3885847a3f803abe53c562d289da", "patch": "@@ -1,6 +1,6 @@\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n 0..1: [ unknown-bottom(..<TAG>) ]"}]}