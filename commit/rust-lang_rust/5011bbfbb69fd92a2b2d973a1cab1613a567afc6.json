{"sha": "5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMTFiYmZiYjY5ZmQ5MmEyYjJkOTczYTFjYWIxNjEzYTU2N2FmYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-30T17:41:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-30T17:41:20Z"}, "message": "auto merge of #9630 : blake2-ppc/rust/de-at-smaller, r=huonw\n\nThis is mostly an incremental change, picking off some uses of\r\n@- or @mut-pointers that can be replaced by references.\r\n\r\nAlmost all of the builder functions in trans::build are updated,\r\nmostly using `&Block` arguments instead of `@mut Block`.", "tree": {"sha": "9bf38344d394a1395c508138e8b9bd3fb45111f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf38344d394a1395c508138e8b9bd3fb45111f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "html_url": "https://github.com/rust-lang/rust/commit/5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8174618a05c44a9b90806aa7b848cb9b7ab62d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/8174618a05c44a9b90806aa7b848cb9b7ab62d25", "html_url": "https://github.com/rust-lang/rust/commit/8174618a05c44a9b90806aa7b848cb9b7ab62d25"}, {"sha": "f4d8d8c12299456ded2f6dd367a5764abe93af8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d8d8c12299456ded2f6dd367a5764abe93af8d", "html_url": "https://github.com/rust-lang/rust/commit/f4d8d8c12299456ded2f6dd367a5764abe93af8d"}], "stats": {"total": 369, "additions": 191, "deletions": 178}, "files": [{"sha": "a726644c15a797573d46f9669a287022ceb6ce28", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -121,7 +121,7 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n         for pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n-            let pat_matches_nan: &fn(@Pat) -> bool = |p| {\n+            let pat_matches_nan: &fn(&Pat) -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n                     Some(&DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -893,7 +893,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     }\n \n-    let check_move: &fn(@Pat, Option<@Pat>) = |p, sub| {\n+    let check_move: &fn(&Pat, Option<@Pat>) = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(*) is legal, but x @ Foo(y) isn't."}, {"sha": "0e4d2bcd9103fc62684cc215f6816d3bb0fb0bac", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -422,7 +422,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_expr(&mut self,\n-                 expr: @ast::Expr,\n+                 expr: &ast::Expr,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n@@ -744,7 +744,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn pop_scopes(&mut self,\n-                  from_expr: @ast::Expr,\n+                  from_expr: &ast::Expr,\n                   to_scope: &mut LoopScope,\n                   in_out: &mut [uint]) {\n         //! Whenever you have a `break` or a `loop` statement, flow\n@@ -778,7 +778,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn break_from_to(&mut self,\n-                     from_expr: @ast::Expr,\n+                     from_expr: &ast::Expr,\n                      to_scope: &mut LoopScope,\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n@@ -811,7 +811,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     fn walk_call(&mut self,\n                  _callee_id: ast::NodeId,\n                  call_id: ast::NodeId,\n-                 arg0: @ast::Expr,\n+                 arg0: &ast::Expr,\n                  args: &[@ast::Expr],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n@@ -865,7 +865,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn find_scope<'a>(&self,\n-                      expr: @ast::Expr,\n+                      expr: &ast::Expr,\n                       label: Option<ast::Name>,\n                       loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n         let index = match label {\n@@ -899,7 +899,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         &mut loop_scopes[index]\n     }\n \n-    fn is_method_call(&self, expr: @ast::Expr) -> bool {\n+    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         self.dfcx.method_map.contains_key(&expr.id)\n     }\n "}, {"sha": "f0ce22d5f33ad4ff16f980dd990efd3f4bf0bda8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -5363,7 +5363,7 @@ impl Resolver {\n     }\n \n     pub fn enforce_default_binding_mode(&mut self,\n-                                        pat: @Pat,\n+                                        pat: &Pat,\n                                         pat_binding_mode: BindingMode,\n                                         descr: &str) {\n         match pat_binding_mode {"}, {"sha": "c2dbcfa3b57d69d9b795bd9b68ee2c04036953af", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -1398,7 +1398,7 @@ fn insert_lllocals(bcx: @mut Block,\n }\n \n fn compile_guard(bcx: @mut Block,\n-                     guard_expr: @ast::Expr,\n+                     guard_expr: &ast::Expr,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n@@ -1826,7 +1826,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n pub fn trans_match(bcx: @mut Block,\n                    match_expr: &ast::Expr,\n-                   discr_expr: @ast::Expr,\n+                   discr_expr: &ast::Expr,\n                    arms: &[ast::Arm],\n                    dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n@@ -1876,7 +1876,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n }\n \n fn trans_match_inner(scope_cx: @mut Block,\n-                         discr_expr: @ast::Expr,\n+                         discr_expr: &ast::Expr,\n                          arms: &[ast::Arm],\n                          dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match_inner\");"}, {"sha": "1749f8e3f6f1829c24ccc8decd7985eccc357281", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -1407,7 +1407,10 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     }\n     match leave {\n       Some(target) => Br(bcx, target),\n-      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.unwrap())); }\n+      None => {\n+          let ll_load = Load(bcx, bcx.fcx.personality.unwrap());\n+          Resume(bcx, ll_load);\n+      }\n     }\n }\n \n@@ -2485,7 +2488,7 @@ pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n     ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n \n-fn exported_name(ccx: @mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.to_owned(),\n@@ -2979,7 +2982,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     return map;\n }\n \n-pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n+pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -3030,7 +3033,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         }\n }\n \n-pub fn write_metadata(cx: &mut CrateContext, crate: &ast::Crate) {\n+pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n     if !*cx.sess.building_library { return; }\n \n     let encode_inlined_item: encoder::encode_inlined_item ="}, {"sha": "1cad4f8a93f0022135cbce642f3504ad691239a8", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -23,17 +23,17 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: @mut Block, _: &str) {\n+pub fn terminate(cx: &mut Block, _: &str) {\n     cx.terminated = true;\n }\n \n-pub fn check_not_terminated(cx: @mut Block) {\n+pub fn check_not_terminated(cx: &Block) {\n     if cx.terminated {\n         fail!(\"already terminated!\");\n     }\n }\n \n-pub fn B(cx: @mut Block) -> Builder {\n+pub fn B(cx: &Block) -> Builder {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b\n@@ -47,7 +47,7 @@ pub fn B(cx: @mut Block) -> Builder {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: @mut Block) {\n+pub fn RetVoid(cx: &mut Block) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n@@ -83,7 +83,7 @@ pub fn CondBr(cx: @mut Block, If: ValueRef, Then: BasicBlockRef,\n     B(cx).cond_br(If, Then, Else);\n }\n \n-pub fn Switch(cx: @mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: &mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     check_not_terminated(cx);\n@@ -98,7 +98,7 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: @mut Block, Addr: ValueRef, NumDests: uint) {\n+pub fn IndirectBr(cx: &mut Block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n@@ -123,7 +123,7 @@ pub fn Invoke(cx: @mut Block,\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)\n }\n \n-pub fn Unreachable(cx: @mut Block) {\n+pub fn Unreachable(cx: &mut Block) {\n     if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n@@ -138,177 +138,177 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Add(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).add(LHS, RHS)\n }\n \n-pub fn NSWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswadd(LHS, RHS)\n }\n \n-pub fn NUWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwadd(LHS, RHS)\n }\n \n-pub fn FAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fadd(LHS, RHS)\n }\n \n-pub fn Sub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Sub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sub(LHS, RHS)\n }\n \n-pub fn NSWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswsub(LHS, RHS)\n }\n \n-pub fn NUWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwsub(LHS, RHS)\n }\n \n-pub fn FSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fsub(LHS, RHS)\n }\n \n-pub fn Mul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Mul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).mul(LHS, RHS)\n }\n \n-pub fn NSWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswmul(LHS, RHS)\n }\n \n-pub fn NUWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwmul(LHS, RHS)\n }\n \n-pub fn FMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fmul(LHS, RHS)\n }\n \n-pub fn UDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).udiv(LHS, RHS)\n }\n \n-pub fn SDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sdiv(LHS, RHS)\n }\n \n-pub fn ExactSDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).exactsdiv(LHS, RHS)\n }\n \n-pub fn FDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fdiv(LHS, RHS)\n }\n \n-pub fn URem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn URem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).urem(LHS, RHS)\n }\n \n-pub fn SRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).srem(LHS, RHS)\n }\n \n-pub fn FRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).frem(LHS, RHS)\n }\n \n-pub fn Shl(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Shl(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).shl(LHS, RHS)\n }\n \n-pub fn LShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn LShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).lshr(LHS, RHS)\n }\n \n-pub fn AShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn AShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).ashr(LHS, RHS)\n }\n \n-pub fn And(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn And(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).and(LHS, RHS)\n }\n \n-pub fn Or(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Or(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).or(LHS, RHS)\n }\n \n-pub fn Xor(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Xor(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).xor(LHS, RHS)\n }\n \n-pub fn BinOp(cx: @mut Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n+pub fn BinOp(cx: &Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).binop(Op, LHS, RHS)\n }\n \n-pub fn Neg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn Neg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).neg(V)\n }\n \n-pub fn NSWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nswneg(V)\n }\n \n-pub fn NUWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nuwneg(V)\n }\n-pub fn FNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).fneg(V)\n }\n \n-pub fn Not(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn Not(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).not(V)\n }\n \n /* Memory */\n-pub fn Malloc(cx: @mut Block, Ty: Type) -> ValueRef {\n+pub fn Malloc(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).malloc(Ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).array_malloc(Ty, Val)\n     }\n }\n \n-pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -317,7 +317,7 @@ pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n     }\n }\n \n-pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -326,12 +326,12 @@ pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Free(cx: @mut Block, PointerVal: ValueRef) {\n+pub fn Free(cx: &Block, PointerVal: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).free(PointerVal)\n }\n \n-pub fn Load(cx: @mut Block, PointerVal: ValueRef) -> ValueRef {\n+pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -347,7 +347,7 @@ pub fn Load(cx: @mut Block, PointerVal: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn AtomicLoad(cx: @mut Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -358,7 +358,7 @@ pub fn AtomicLoad(cx: @mut Block, PointerVal: ValueRef, order: AtomicOrdering) -\n }\n \n \n-pub fn LoadRangeAssert(cx: @mut Block, PointerVal: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n     if cx.unreachable {\n         let ccx = cx.fcx.ccx;\n@@ -376,17 +376,17 @@ pub fn LoadRangeAssert(cx: @mut Block, PointerVal: ValueRef, lo: c_ulonglong,\n     }\n }\n \n-pub fn Store(cx: @mut Block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn Store(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).store(Val, Ptr)\n }\n \n-pub fn AtomicStore(cx: @mut Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: &Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable { return; }\n     B(cx).atomic_store(Val, Ptr, order)\n }\n \n-pub fn GEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gep(Pointer, Indices)\n@@ -396,170 +396,170 @@ pub fn GEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: @mut Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n-pub fn InBoundsGEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n-pub fn StructGEP(cx: @mut Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: &Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n-pub fn GlobalString(cx: @mut Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string(_Str)\n     }\n }\n \n-pub fn GlobalStringPtr(cx: @mut Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn Trunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc(Val, DestTy)\n     }\n }\n \n-pub fn ZExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext(Val, DestTy)\n     }\n }\n \n-pub fn SExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext(Val, DestTy)\n     }\n }\n \n-pub fn FPToUI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToUI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptoui(Val, DestTy)\n     }\n }\n \n-pub fn FPToSI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToSI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptosi(Val, DestTy)\n     }\n }\n \n-pub fn UIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn UIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).uitofp(Val, DestTy)\n     }\n }\n \n-pub fn SIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sitofp(Val, DestTy)\n     }\n }\n \n-pub fn FPTrunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPTrunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n-pub fn FPExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpext(Val, DestTy)\n     }\n }\n \n-pub fn PtrToInt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PtrToInt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n-pub fn IntToPtr(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntToPtr(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n-pub fn BitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn BitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).bitcast(Val, DestTy)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn Cast(cx: @mut Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n+pub fn Cast(cx: &Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n-pub fn PointerCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PointerCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).pointercast(Val, DestTy)\n     }\n }\n \n-pub fn IntCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).intcast(Val, DestTy)\n     }\n }\n \n-pub fn FPCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpcast(Val, DestTy)\n@@ -568,15 +568,15 @@ pub fn FPCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: @mut Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn ICmp(cx: &Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n-pub fn FCmp(cx: @mut Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn FCmp(cx: &Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n@@ -585,14 +585,14 @@ pub fn FCmp(cx: @mut Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: @mut Block, Ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).empty_phi(Ty)\n     }\n }\n \n-pub fn Phi(cx: @mut Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: &Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).phi(Ty, vals, bbs)\n@@ -608,7 +608,7 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: &Block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n@@ -622,129 +622,129 @@ pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: @mut Block, sp: Span, text: &str) {\n+pub fn add_span_comment(cx: &Block, sp: Span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(cx: @mut Block, text: &str) {\n+pub fn add_comment(cx: &Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: @mut Block, asm: *c_char, cons: *c_char,\n+pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n+pub fn Call(cx: &Block, Fn: ValueRef, Args: &[ValueRef],\n             attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args, attributes)\n }\n \n-pub fn CallWithConv(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n+pub fn CallWithConv(cx: &Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n                     attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call_with_conv(Fn, Args, Conv, attributes)\n }\n \n-pub fn AtomicFence(cx: @mut Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n     if cx.unreachable { return; }\n     B(cx).atomic_fence(order)\n }\n \n-pub fn Select(cx: @mut Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n+pub fn Select(cx: &Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(Then); }\n     B(cx).select(If, Then, Else)\n }\n \n-pub fn VAArg(cx: @mut Block, list: ValueRef, Ty: Type) -> ValueRef {\n+pub fn VAArg(cx: &Block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).va_arg(list, Ty)\n     }\n }\n \n-pub fn ExtractElement(cx: @mut Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: &Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_element(VecVal, Index)\n     }\n }\n \n-pub fn InsertElement(cx: @mut Block, VecVal: ValueRef, EltVal: ValueRef,\n+pub fn InsertElement(cx: &Block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n-pub fn ShuffleVector(cx: @mut Block, V1: ValueRef, V2: ValueRef,\n+pub fn ShuffleVector(cx: &Block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n-pub fn VectorSplat(cx: @mut Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: &Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n-pub fn ExtractValue(cx: @mut Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: &Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_value(AggVal, Index)\n     }\n }\n \n-pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn InsertValue(cx: &Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_value(AggVal, EltVal, Index)\n     }\n }\n \n-pub fn IsNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_null(Val)\n     }\n }\n \n-pub fn IsNotNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_not_null(Val)\n     }\n }\n \n-pub fn PtrDiff(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n-pub fn Trap(cx: @mut Block) {\n+pub fn Trap(cx: &Block) {\n     if cx.unreachable { return; }\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: @mut Block, Ty: Type, PersFn: ValueRef,\n+pub fn LandingPad(cx: &Block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable);\n     B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n-pub fn SetCleanup(cx: @mut Block, LandingPad: ValueRef) {\n+pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n@@ -755,12 +755,12 @@ pub fn Resume(cx: @mut Block, Exn: ValueRef) -> ValueRef {\n }\n \n // Atomic Operations\n-pub fn AtomicCmpXchg(cx: @mut Block, dst: ValueRef,\n+pub fn AtomicCmpXchg(cx: &Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order)\n }\n-pub fn AtomicRMW(cx: @mut Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: &Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "a3788d7cbdef46add349ca3c87442590f56384ba", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -77,7 +77,7 @@ pub struct Callee {\n     data: CalleeData\n }\n \n-pub fn trans(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n+pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n@@ -92,7 +92,7 @@ pub fn trans(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n+    fn datum_callee(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(*) => {\n@@ -115,7 +115,7 @@ pub fn trans(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: @mut Block, def: ast::Def, ref_expr: @ast::Expr) -> Callee {\n+    fn trans_def(bcx: @mut Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n@@ -447,8 +447,8 @@ pub fn trans_fn_ref_with_vtables(\n // Translating calls\n \n pub fn trans_call(in_cx: @mut Block,\n-                  call_ex: @ast::Expr,\n-                  f: @ast::Expr,\n+                  call_ex: &ast::Expr,\n+                  f: &ast::Expr,\n                   args: CallArgs,\n                   id: ast::NodeId,\n                   dest: expr::Dest)\n@@ -465,9 +465,9 @@ pub fn trans_call(in_cx: @mut Block,\n }\n \n pub fn trans_method_call(in_cx: @mut Block,\n-                         call_ex: @ast::Expr,\n+                         call_ex: &ast::Expr,\n                          callee_id: ast::NodeId,\n-                         rcvr: @ast::Expr,\n+                         rcvr: &ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n                          -> @mut Block {\n@@ -834,7 +834,7 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: @mut Block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n-                      arg_expr: @ast::Expr,\n+                      arg_expr: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = push_ctxt(\"trans_arg_expr\");"}, {"sha": "322050331a266765eb40933dfbacc4a5298b4ecf", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -550,7 +550,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n     }\n }\n \n-pub fn block_cleanups(bcx: @mut Block) -> ~[cleanup] {\n+pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n     match bcx.scope {\n        None  => ~[],\n        Some(inf) => inf.cleanups.clone(),\n@@ -670,7 +670,7 @@ impl Block {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    pub fn expr_to_str(&self, e: @ast::Expr) -> ~str {\n+    pub fn expr_to_str(&self, e: &ast::Expr) -> ~str {\n         e.repr(self.tcx())\n     }\n \n@@ -1061,7 +1061,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     r\n }\n \n-pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -1074,23 +1074,23 @@ pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: @mut Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &mut Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: @mut Block, id: ast::NodeId) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n "}, {"sha": "7d208c896b7cadd1d7f83fd6bac6e9b28f112a46", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -177,7 +177,7 @@ pub fn get_const_val(cx: @mut CrateContext,\n      !cx.non_inlineable_statics.contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> (ValueRef, bool) {\n+pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;"}, {"sha": "73e7a6745fb3c829b081ed328fac3ba50844228f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -45,7 +45,7 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n }\n \n pub fn trans_if(bcx: @mut Block,\n-            cond: @ast::Expr,\n+            cond: &ast::Expr,\n             thn: &ast::Block,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n@@ -158,7 +158,7 @@ pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block\n     return out;\n }\n \n-pub fn trans_while(bcx: @mut Block, cond: @ast::Expr, body: &ast::Block) -> @mut Block {\n+pub fn trans_while(bcx: @mut Block, cond: &ast::Expr, body: &ast::Block) -> @mut Block {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n "}, {"sha": "56677167f0e00ffbba9a06b4a932eeffb1f8fde7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -181,7 +181,7 @@ fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n     return bcx;\n }\n \n-pub fn trans_to_datum(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n@@ -307,7 +307,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n \n     fn auto_borrow_obj(mut bcx: @mut Block,\n                        autoderefs: uint,\n-                       expr: @ast::Expr,\n+                       expr: &ast::Expr,\n                        source_datum: Datum) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n@@ -419,7 +419,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: @mut Block, expr: @ast::Expr, dest: Dest) -> @mut Block {\n+pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     if bcx.tcx().adjustments.contains_key(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n@@ -477,7 +477,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::Expr, dest: Dest) -> @mut Block {\n     };\n }\n \n-fn trans_lvalue(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n+fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -496,7 +496,7 @@ fn trans_lvalue(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     };\n }\n \n-fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -562,7 +562,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -615,7 +615,7 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBloc\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> @mut Block {\n+fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -669,7 +669,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> @mut Block\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::Expr,\n+fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n                                dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n@@ -878,7 +878,7 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -918,7 +918,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     };\n \n     fn trans_rec_field(bcx: @mut Block,\n-                       base: @ast::Expr,\n+                       base: &ast::Expr,\n                        field: ast::Ident) -> DatumBlock {\n         //! Translates `base.field`.\n \n@@ -942,8 +942,8 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n \n     fn trans_index(bcx: @mut Block,\n                    index_expr: &ast::Expr,\n-                   base: @ast::Expr,\n-                   idx: @ast::Expr) -> DatumBlock {\n+                   base: &ast::Expr,\n+                   idx: &ast::Expr) -> DatumBlock {\n         //! Translates `base[idx]`.\n \n         let _icx = push_ctxt(\"trans_index\");\n@@ -1321,7 +1321,7 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n }\n \n \n-fn trans_immediate_lit(bcx: @mut Block, expr: @ast::Expr,\n+fn trans_immediate_lit(bcx: @mut Block, expr: &ast::Expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -1332,7 +1332,7 @@ fn trans_immediate_lit(bcx: @mut Block, expr: @ast::Expr,\n fn trans_unary_datum(bcx: @mut Block,\n                      un_expr: &ast::Expr,\n                      op: ast::UnOp,\n-                     sub_expr: @ast::Expr) -> DatumBlock {\n+                     sub_expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1391,7 +1391,7 @@ fn trans_unary_datum(bcx: @mut Block,\n \n     fn trans_boxed_expr(bcx: @mut Block,\n                         box_ty: ty::t,\n-                        contents: @ast::Expr,\n+                        contents: &ast::Expr,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n@@ -1416,7 +1416,7 @@ fn trans_unary_datum(bcx: @mut Block,\n }\n \n fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n-                 subexpr: @ast::Expr) -> DatumBlock {\n+                 subexpr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n@@ -1532,8 +1532,8 @@ enum lazy_binop_ty { lazy_and, lazy_or }\n fn trans_lazy_binop(bcx: @mut Block,\n                     binop_expr: &ast::Expr,\n                     op: lazy_binop_ty,\n-                    a: @ast::Expr,\n-                    b: @ast::Expr) -> DatumBlock {\n+                    a: &ast::Expr,\n+                    b: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let bcx = bcx;\n@@ -1577,8 +1577,8 @@ fn trans_lazy_binop(bcx: @mut Block,\n fn trans_binary(bcx: @mut Block,\n                 binop_expr: &ast::Expr,\n                 op: ast::BinOp,\n-                lhs: @ast::Expr,\n-                rhs: @ast::Expr) -> DatumBlock\n+                lhs: &ast::Expr,\n+                rhs: &ast::Expr) -> DatumBlock\n {\n     let _icx = push_ctxt(\"trans_binary\");\n \n@@ -1603,7 +1603,7 @@ fn trans_binary(bcx: @mut Block,\n fn trans_overloaded_op(bcx: @mut Block,\n                        expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n-                       rcvr: @ast::Expr,\n+                       rcvr: &ast::Expr,\n                        args: ~[@ast::Expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n@@ -1679,7 +1679,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: @mut Block, expr: @ast::Expr,\n+fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n                   id: ast::NodeId) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n@@ -1748,10 +1748,10 @@ fn trans_imm_cast(bcx: @mut Block, expr: @ast::Expr,\n }\n \n fn trans_assign_op(bcx: @mut Block,\n-                   expr: @ast::Expr,\n+                   expr: &ast::Expr,\n                    callee_id: ast::NodeId,\n                    op: ast::BinOp,\n-                   dst: @ast::Expr,\n+                   dst: &ast::Expr,\n                    src: @ast::Expr) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_assign_op\");"}, {"sha": "a10f53ebcbc846788a540f44783c9eac91e5dacc", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -552,12 +552,14 @@ pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n     let decr_bcx = sub_block(bcx, \"decr\");\n     let free_bcx = sub_block(decr_bcx, \"free\");\n     let next_bcx = sub_block(bcx, \"next\");\n-    CondBr(bcx, IsNotNull(bcx, box_ptr), decr_bcx.llbb, next_bcx.llbb);\n+    let llnotnull = IsNotNull(bcx, box_ptr);\n+    CondBr(bcx, llnotnull, decr_bcx.llbb, next_bcx.llbb);\n \n     let rc_ptr = GEPi(decr_bcx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Sub(decr_bcx, Load(decr_bcx, rc_ptr), C_int(ccx, 1));\n     Store(decr_bcx, rc, rc_ptr);\n-    CondBr(decr_bcx, IsNull(decr_bcx, rc), free_bcx.llbb, next_bcx.llbb);\n+    let llisnull = IsNull(decr_bcx, rc);\n+    CondBr(decr_bcx, llisnull, free_bcx.llbb, next_bcx.llbb);\n \n     let free_bcx = match box_ptr_ptr {\n         Some(p) => free_ty(free_bcx, p, t),"}, {"sha": "04ffb393b5e4ed595f15c69018e135015465f10b", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -49,7 +49,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n         }\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args), []));\n+        let llcall = Call(bcx, llfn, args.slice(0, num_args), []);\n+        Ret(bcx, llcall);\n     }\n \n     fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n@@ -116,7 +117,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, [x, y], []));\n+        let llcall = Call(bcx, llfn, [x, y], []);\n+        Ret(bcx, llcall);\n     }\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n@@ -324,14 +326,19 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                             (Pointer, other) | (other, Pointer) if other != Pointer => {\n                                 let tmp = Alloca(bcx, llouttype, \"\");\n                                 Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n+                                let ll_load = Load(bcx, tmp);\n+                                Ret(bcx, ll_load);\n+                            }\n+                            _ => {\n+                                let llbitcast = BitCast(bcx, llsrcval, llouttype);\n+                                Ret(bcx, llbitcast)\n                             }\n-                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n                         }\n                     }\n                 } else if ty::type_is_immediate(ccx.tcx, out_type) {\n                     let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n-                    Ret(bcx, Load(bcx, llsrcptr));\n+                    let ll_load = Load(bcx, llsrcptr);\n+                    Ret(bcx, ll_load);\n                 } else {\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n@@ -404,7 +411,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"offset\" => {\n             let ptr = get_param(decl, first_real_arg);\n             let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+            let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n+            Ret(bcx, lladdr);\n         }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),"}, {"sha": "19e2e1d00f646413476db4e93ca4fe828299235c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -139,7 +139,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n }\n \n pub fn trans_self_arg(bcx: @mut Block,\n-                      base: @ast::Expr,\n+                      base: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n@@ -156,7 +156,7 @@ pub fn trans_self_arg(bcx: @mut Block,\n \n pub fn trans_method_callee(bcx: @mut Block,\n                            callee_id: ast::NodeId,\n-                           this: @ast::Expr,\n+                           this: &ast::Expr,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n@@ -313,7 +313,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n \n pub fn trans_monomorphized_callee(bcx: @mut Block,\n                                   callee_id: ast::NodeId,\n-                                  base: @ast::Expr,\n+                                  base: &ast::Expr,\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n@@ -420,7 +420,7 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n-                          self_expr: @ast::Expr)\n+                          self_expr: &ast::Expr)\n                           -> Callee {\n     /*!\n      * Create a method callee where the method is coming from a trait\n@@ -630,7 +630,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n }\n \n pub fn trans_trait_cast(bcx: @mut Block,\n-                        val: @ast::Expr,\n+                        val: &ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)"}, {"sha": "6a9b221726603680025797446322218d3572d927", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -158,7 +158,7 @@ impl VecTypes {\n }\n \n pub fn trans_fixed_vstore(bcx: @mut Block,\n-                          vstore_expr: @ast::Expr,\n+                          vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n                        -> @mut Block {\n@@ -187,8 +187,8 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n }\n \n pub fn trans_slice_vstore(bcx: @mut Block,\n-                          vstore_expr: @ast::Expr,\n-                          content_expr: @ast::Expr,\n+                          vstore_expr: &ast::Expr,\n+                          content_expr: &ast::Expr,\n                           dest: expr::Dest)\n                        -> @mut Block {\n     //!\n@@ -246,7 +246,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n }\n \n pub fn trans_lit_str(bcx: @mut Block,\n-                     lit_expr: @ast::Expr,\n+                     lit_expr: &ast::Expr,\n                      str_lit: @str,\n                      dest: Dest)\n                   -> @mut Block {\n@@ -280,7 +280,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @ast::Expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &ast::Expr,\n                                     content_expr: &ast::Expr) -> DatumBlock {\n     //!\n     //\n@@ -343,7 +343,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @a\n \n pub fn write_content(bcx: @mut Block,\n                      vt: &VecTypes,\n-                     vstore_expr: @ast::Expr,\n+                     vstore_expr: &ast::Expr,\n                      content_expr: &ast::Expr,\n                      dest: Dest)\n                   -> @mut Block {"}, {"sha": "7def799742dcd16c5f174578c9e62693dcecc5b4", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011bbfbb69fd92a2b2d973a1cab1613a567afc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=5011bbfbb69fd92a2b2d973a1cab1613a567afc6", "patch": "@@ -49,7 +49,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: @mut Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 do store.get_parent().and_then |store_bb| {"}]}