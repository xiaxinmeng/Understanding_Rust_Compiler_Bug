{"sha": "5ca596f486707ac1362edad717ad0e9f5b71d0a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTU5NmY0ODY3MDdhYzEzNjJlZGFkNzE3YWQwZTlmNWI3MWQwYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-24T01:36:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-24T01:36:09Z"}, "message": "Auto merge of #85556 - FabianWolff:issue-85071, r=estebank,jackh726\n\nWarn about unreachable code following an expression with an uninhabited type\n\nThis pull request fixes #85071. The issue is that liveness analysis currently is \"smarter\" than reachability analysis when it comes to detecting uninhabited types: Unreachable code is detected during type checking, where full type information is not yet available. Therefore, the check for type inhabitedness is quite crude:\nhttps://github.com/rust-lang/rust/blob/fc81ad22c453776de16acf9938976930cf8c9401/compiler/rustc_typeck/src/check/expr.rs#L202-L205\n\ni.e. it only checks for `!`, but not other, non-trivially uninhabited types, such as empty enums, structs containing an uninhabited type, etc. By contrast, liveness analysis, which runs after type checking, can benefit from the more sophisticated `tcx.is_ty_uninhabited_from()`:\nhttps://github.com/rust-lang/rust/blob/fc81ad22c453776de16acf9938976930cf8c9401/compiler/rustc_passes/src/liveness.rs#L981\nhttps://github.com/rust-lang/rust/blob/fc81ad22c453776de16acf9938976930cf8c9401/compiler/rustc_passes/src/liveness.rs#L996\n\nThis can lead to confusing warnings when a variable is reported as unused, but the use of the variable is not reported as unreachable. For instance:\n```rust\nenum Foo {}\nfn f() -> Foo {todo!()}\n\nfn main() {\n    let x = f();\n    let _ = x;\n}\n```\ncurrently leads to\n```\nwarning: unused variable: `x`\n --> t1.rs:5:9\n  |\n5 |     let x = f();\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: 1 warning emitted\n```\nwhich is confusing, because `x` _appears_ to be used in line 6. With my changes, I get:\n```\nwarning: unreachable expression\n --> t1.rs:6:13\n  |\n5 |     let x = f();\n  |             --- any code following this expression is unreachable\n6 |     let _ = x;\n  |             ^ unreachable expression\n  |\n  = note: `#[warn(unreachable_code)]` on by default\nnote: this expression has type `Foo`, which is uninhabited\n --> t1.rs:5:13\n  |\n5 |     let x = f();\n  |             ^^^\n\nwarning: unused variable: `x`\n --> t1.rs:5:9\n  |\n5 |     let x = f();\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: 2 warnings emitted\n```\nMy implementation is slightly inelegant because unreachable code warnings can now be issued in two different places (during type checking and during liveness analysis), but I think it is the solution with the least amount of unnecessary code duplication, given that the new warning integrates nicely with liveness analysis, where unreachable code is already implicitly detected for the purpose of finding unused variables.", "tree": {"sha": "8a3a9230466d1400e0f0d8f37c9b7984bf55bce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a3a9230466d1400e0f0d8f37c9b7984bf55bce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca596f486707ac1362edad717ad0e9f5b71d0a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca596f486707ac1362edad717ad0e9f5b71d0a3", "html_url": "https://github.com/rust-lang/rust/commit/5ca596f486707ac1362edad717ad0e9f5b71d0a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca596f486707ac1362edad717ad0e9f5b71d0a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de42550d0ac525f44ec79300a1cb349ade181c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/de42550d0ac525f44ec79300a1cb349ade181c1a", "html_url": "https://github.com/rust-lang/rust/commit/de42550d0ac525f44ec79300a1cb349ade181c1a"}, {"sha": "7a98fd412425ed39e8737e63a35da96202e43e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a98fd412425ed39e8737e63a35da96202e43e56", "html_url": "https://github.com/rust-lang/rust/commit/7a98fd412425ed39e8737e63a35da96202e43e56"}], "stats": {"total": 212, "additions": 181, "deletions": 31}, "files": [{"sha": "36d1a6c104421c6ca7d5c2ac6d91e55820bdc66d", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5ca596f486707ac1362edad717ad0e9f5b71d0a3/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca596f486707ac1362edad717ad0e9f5b71d0a3/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=5ca596f486707ac1362edad717ad0e9f5b71d0a3", "patch": "@@ -95,7 +95,7 @@ use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -123,8 +123,8 @@ rustc_index::newtype_index! {\n #[derive(Copy, Clone, PartialEq, Debug)]\n enum LiveNodeKind {\n     UpvarNode(Span),\n-    ExprNode(Span),\n-    VarDefNode(Span),\n+    ExprNode(Span, HirId),\n+    VarDefNode(Span, HirId),\n     ClosureNode,\n     ExitNode,\n }\n@@ -133,8 +133,8 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     let sm = tcx.sess.source_map();\n     match lnk {\n         UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_diagnostic_string(s)),\n-        ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_diagnostic_string(s)),\n-        VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_diagnostic_string(s)),\n+        ExprNode(s, _) => format!(\"Expr node [{}]\", sm.span_to_diagnostic_string(s)),\n+        VarDefNode(s, _) => format!(\"Var def node [{}]\", sm.span_to_diagnostic_string(s)),\n         ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n@@ -297,7 +297,7 @@ impl IrMaps<'tcx> {\n         }\n \n         pat.each_binding(|_, hir_id, _, ident| {\n-            self.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n+            self.add_live_node_for_node(hir_id, VarDefNode(ident.span, hir_id));\n             self.add_variable(Local(LocalInfo {\n                 id: hir_id,\n                 name: ident.name,\n@@ -396,14 +396,14 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n                 if let Res::Local(_var_hir_id) = path.res {\n-                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 }\n                 intravisit::walk_expr(self, expr);\n             }\n             hir::ExprKind::Closure(..) => {\n                 // Interesting control flow (for loops can contain labeled\n                 // breaks or continues)\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n \n                 // Make a live_node for each captured variable, with the span\n                 // being the location that the variable is used.  This results\n@@ -436,11 +436,11 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n             // live nodes required for interesting control flow:\n             hir::ExprKind::If(..) | hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 intravisit::walk_expr(self, expr);\n             }\n             hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n-                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -992,32 +992,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n-                    m,\n-                    self.typeck_results.expr_ty(expr),\n-                    self.param_env,\n-                ) {\n-                    self.exit_ln\n-                } else {\n-                    succ\n-                };\n+                let succ = self.check_is_ty_uninhabited(expr, succ);\n                 let succ = self.propagate_through_exprs(args, succ);\n                 self.propagate_through_expr(&f, succ)\n             }\n \n             hir::ExprKind::MethodCall(.., ref args, _) => {\n-                let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n-                    m,\n-                    self.typeck_results.expr_ty(expr),\n-                    self.param_env,\n-                ) {\n-                    self.exit_ln\n-                } else {\n-                    succ\n-                };\n-\n+                let succ = self.check_is_ty_uninhabited(expr, succ);\n                 self.propagate_through_exprs(args, succ)\n             }\n \n@@ -1289,6 +1270,66 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         ln\n     }\n+\n+    fn check_is_ty_uninhabited(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n+        let ty = self.typeck_results.expr_ty(expr);\n+        let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n+        if self.ir.tcx.is_ty_uninhabited_from(m, ty, self.param_env) {\n+            match self.ir.lnks[succ] {\n+                LiveNodeKind::ExprNode(succ_span, succ_id) => {\n+                    self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"expression\");\n+                }\n+                LiveNodeKind::VarDefNode(succ_span, succ_id) => {\n+                    self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"definition\");\n+                }\n+                _ => {}\n+            };\n+            self.exit_ln\n+        } else {\n+            succ\n+        }\n+    }\n+\n+    fn warn_about_unreachable(\n+        &mut self,\n+        orig_span: Span,\n+        orig_ty: Ty<'tcx>,\n+        expr_span: Span,\n+        expr_id: HirId,\n+        descr: &str,\n+    ) {\n+        if !orig_ty.is_never() {\n+            // Unreachable code warnings are already emitted during type checking.\n+            // However, during type checking, full type information is being\n+            // calculated but not yet available, so the check for diverging\n+            // expressions due to uninhabited result types is pretty crude and\n+            // only checks whether ty.is_never(). Here, we have full type\n+            // information available and can issue warnings for less obviously\n+            // uninhabited types (e.g. empty enums). The check above is used so\n+            // that we do not emit the same warning twice if the uninhabited type\n+            // is indeed `!`.\n+\n+            self.ir.tcx.struct_span_lint_hir(\n+                lint::builtin::UNREACHABLE_CODE,\n+                expr_id,\n+                expr_span,\n+                |lint| {\n+                    let msg = format!(\"unreachable {}\", descr);\n+                    lint.build(&msg)\n+                        .span_label(expr_span, &msg)\n+                        .span_label(orig_span, \"any code following this expression is unreachable\")\n+                        .span_note(\n+                            orig_span,\n+                            &format!(\n+                                \"this expression has type `{}`, which is uninhabited\",\n+                                orig_ty\n+                            ),\n+                        )\n+                        .emit();\n+                },\n+            );\n+        }\n+    }\n }\n \n // _______________________________________________________________________"}, {"sha": "f0639931c84f3b5e2aa1f45735766c5c27d464fc", "filename": "src/test/ui/lint/dead-code/issue-85071-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.rs?ref=5ca596f486707ac1362edad717ad0e9f5b71d0a3", "patch": "@@ -0,0 +1,22 @@\n+// A slight variation of issue-85071.rs. Here, a method is called instead\n+// of a function, and the warning is about an unreachable definition\n+// instead of an unreachable expression.\n+\n+// check-pass\n+\n+#![warn(unused_variables,unreachable_code)]\n+\n+enum Foo {}\n+\n+struct S;\n+impl S {\n+    fn f(&self) -> Foo {todo!()}\n+}\n+\n+fn main() {\n+    let s = S;\n+    let x = s.f();\n+    //~^ WARNING: unused variable: `x`\n+    let _y = x;\n+    //~^ WARNING: unreachable definition\n+}"}, {"sha": "86fbd1d75e89ff1a5565cd7c89237302dfce967a", "filename": "src/test/ui/lint/dead-code/issue-85071-2.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071-2.stderr?ref=5ca596f486707ac1362edad717ad0e9f5b71d0a3", "patch": "@@ -0,0 +1,34 @@\n+warning: unreachable definition\n+  --> $DIR/issue-85071-2.rs:20:9\n+   |\n+LL |     let x = s.f();\n+   |             ----- any code following this expression is unreachable\n+LL |\n+LL |     let _y = x;\n+   |         ^^ unreachable definition\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071-2.rs:7:26\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |                          ^^^^^^^^^^^^^^^^\n+note: this expression has type `Foo`, which is uninhabited\n+  --> $DIR/issue-85071-2.rs:18:13\n+   |\n+LL |     let x = s.f();\n+   |             ^^^^^\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-85071-2.rs:18:9\n+   |\n+LL |     let x = s.f();\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071-2.rs:7:9\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "d6969321cad4b5e7a1a37e2ee8dfdd787b4cd48b", "filename": "src/test/ui/lint/dead-code/issue-85071.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.rs?ref=5ca596f486707ac1362edad717ad0e9f5b71d0a3", "patch": "@@ -0,0 +1,19 @@\n+// Checks that an unreachable code warning is emitted when an expression is\n+// preceded by an expression with an uninhabited type. Previously, the\n+// variable liveness analysis was \"smarter\" than the reachability analysis\n+// in this regard, which led to confusing \"unused variable\" warnings\n+// without an accompanying explanatory \"unreachable expression\" warning.\n+\n+// check-pass\n+\n+#![warn(unused_variables,unreachable_code)]\n+\n+enum Foo {}\n+fn f() -> Foo {todo!()}\n+\n+fn main() {\n+    let x = f();\n+    //~^ WARNING: unused variable: `x`\n+    let _ = x;\n+    //~^ WARNING: unreachable expression\n+}"}, {"sha": "49555fdaa3595553297ce2b37dd0f234c05837bd", "filename": "src/test/ui/lint/dead-code/issue-85071.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ca596f486707ac1362edad717ad0e9f5b71d0a3/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85071.stderr?ref=5ca596f486707ac1362edad717ad0e9f5b71d0a3", "patch": "@@ -0,0 +1,34 @@\n+warning: unreachable expression\n+  --> $DIR/issue-85071.rs:17:13\n+   |\n+LL |     let x = f();\n+   |             --- any code following this expression is unreachable\n+LL |\n+LL |     let _ = x;\n+   |             ^ unreachable expression\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071.rs:9:26\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |                          ^^^^^^^^^^^^^^^^\n+note: this expression has type `Foo`, which is uninhabited\n+  --> $DIR/issue-85071.rs:15:13\n+   |\n+LL |     let x = f();\n+   |             ^^^\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-85071.rs:15:9\n+   |\n+LL |     let x = f();\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-85071.rs:9:9\n+   |\n+LL | #![warn(unused_variables,unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}]}