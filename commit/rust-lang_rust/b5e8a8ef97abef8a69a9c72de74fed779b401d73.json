{"sha": "b5e8a8ef97abef8a69a9c72de74fed779b401d73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZThhOGVmOTdhYmVmOGE2OWE5YzcyZGU3NGZlZDc3OWI0MDFkNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-25T23:46:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-25T23:46:14Z"}, "message": "Auto merge of #43046 - milmazz:bootstrap-unittest, r=aidanhs\n\nbootstrap: Add doctests and unitests\n\nThis commit includes the following changes:\n\n* Include more docstrings in classes, methods, and functions\n* Add doctests, which are great for self-documenting our source code\n* Add some unit tests with the `unittest` module\n* Remove `WindowsError` reference on non-windows systems\n* Rename some variables to be more explicit about their meaning\n* Move all the attributes defined outside of `__init__`\n* Add initial support for Python 3\n\nr? @alexcrichton", "tree": {"sha": "38eaa6e06fa1a49a16ac60a5481321995057dac8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38eaa6e06fa1a49a16ac60a5481321995057dac8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5e8a8ef97abef8a69a9c72de74fed779b401d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e8a8ef97abef8a69a9c72de74fed779b401d73", "html_url": "https://github.com/rust-lang/rust/commit/b5e8a8ef97abef8a69a9c72de74fed779b401d73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5e8a8ef97abef8a69a9c72de74fed779b401d73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c417ee9ae8c30ac307c58591da46cf62e91caac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c417ee9ae8c30ac307c58591da46cf62e91caac1", "html_url": "https://github.com/rust-lang/rust/commit/c417ee9ae8c30ac307c58591da46cf62e91caac1"}, {"sha": "f516765b94761838fd15cff283757e74e61cdd41", "url": "https://api.github.com/repos/rust-lang/rust/commits/f516765b94761838fd15cff283757e74e61cdd41", "html_url": "https://github.com/rust-lang/rust/commit/f516765b94761838fd15cff283757e74e61cdd41"}], "stats": {"total": 628, "additions": 427, "deletions": 201}, "files": [{"sha": "9369a55ccb97bc6c82ac05a25c7a461fe71e198e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 305, "deletions": 201, "changes": 506, "blob_url": "https://github.com/rust-lang/rust/blob/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=b5e8a8ef97abef8a69a9c72de74fed779b401d73", "patch": "@@ -37,12 +37,12 @@ def get(url, path, verbose=False):\n         if os.path.exists(path):\n             if verify(path, sha_path, False):\n                 if verbose:\n-                    print(\"using already-download file \" + path)\n+                    print(\"using already-download file\", path)\n                 return\n             else:\n                 if verbose:\n-                    print(\"ignoring already-download file \" +\n-                          path + \" due to failed verification\")\n+                    print(\"ignoring already-download file\",\n+                          path, \"due to failed verification\")\n                 os.unlink(path)\n         download(temp_path, url, True, verbose)\n         if not verify(temp_path, sha_path, verbose):\n@@ -59,12 +59,12 @@ def delete_if_present(path, verbose):\n     \"\"\"Remove the given file if present\"\"\"\n     if os.path.isfile(path):\n         if verbose:\n-            print(\"removing \" + path)\n+            print(\"removing\", path)\n         os.unlink(path)\n \n \n def download(path, url, probably_big, verbose):\n-    for x in range(0, 4):\n+    for _ in range(0, 4):\n         try:\n             _download(path, url, probably_big, verbose, True)\n             return\n@@ -96,7 +96,7 @@ def _download(path, url, probably_big, verbose, exception):\n def verify(path, sha_path, verbose):\n     \"\"\"Check if the sha256 sum of the given path is valid\"\"\"\n     if verbose:\n-        print(\"verifying \" + path)\n+        print(\"verifying\", path)\n     with open(path, \"rb\") as source:\n         found = hashlib.sha256(source.read()).hexdigest()\n     with open(sha_path, \"r\") as sha256sum:\n@@ -111,29 +111,30 @@ def verify(path, sha_path, verbose):\n \n def unpack(tarball, dst, verbose=False, match=None):\n     \"\"\"Unpack the given tarball file\"\"\"\n-    print(\"extracting \" + tarball)\n+    print(\"extracting\", tarball)\n     fname = os.path.basename(tarball).replace(\".tar.gz\", \"\")\n     with contextlib.closing(tarfile.open(tarball)) as tar:\n-        for p in tar.getnames():\n-            if \"/\" not in p:\n+        for member in tar.getnames():\n+            if \"/\" not in member:\n                 continue\n-            name = p.replace(fname + \"/\", \"\", 1)\n+            name = member.replace(fname + \"/\", \"\", 1)\n             if match is not None and not name.startswith(match):\n                 continue\n             name = name[len(match) + 1:]\n \n-            fp = os.path.join(dst, name)\n+            dst_path = os.path.join(dst, name)\n             if verbose:\n-                print(\"  extracting \" + p)\n-            tar.extract(p, dst)\n-            tp = os.path.join(dst, p)\n-            if os.path.isdir(tp) and os.path.exists(fp):\n+                print(\"  extracting\", member)\n+            tar.extract(member, dst)\n+            src_path = os.path.join(dst, member)\n+            if os.path.isdir(src_path) and os.path.exists(dst_path):\n                 continue\n-            shutil.move(tp, fp)\n+            shutil.move(src_path, dst_path)\n     shutil.rmtree(os.path.join(dst, fname))\n \n \n def run(args, verbose=False, exception=False, **kwargs):\n+    \"\"\"Run a child program in a new process\"\"\"\n     if verbose:\n         print(\"running: \" + ' '.join(args))\n     sys.stdout.flush()\n@@ -149,97 +150,118 @@ def run(args, verbose=False, exception=False, **kwargs):\n \n \n def stage0_data(rust_root):\n+    \"\"\"Build a dictionary from stage0.txt\"\"\"\n     nightlies = os.path.join(rust_root, \"src/stage0.txt\")\n-    data = {}\n     with open(nightlies, 'r') as nightlies:\n-        for line in nightlies:\n-            line = line.rstrip()  # Strip newline character, '\\n'\n-            if line.startswith(\"#\") or line == '':\n-                continue\n-            a, b = line.split(\": \", 1)\n-            data[a] = b\n-    return data\n+        lines = [line.rstrip() for line in nightlies\n+                 if not line.startswith(\"#\")]\n+        return dict([line.split(\": \", 1) for line in lines if line])\n \n \n def format_build_time(duration):\n+    \"\"\"Return a nicer format for build time\n+\n+    >>> format_build_time('300')\n+    '0:05:00'\n+    \"\"\"\n     return str(datetime.timedelta(seconds=int(duration)))\n \n \n class RustBuild(object):\n+    \"\"\"Provide all the methods required to build Rust\"\"\"\n+    def __init__(self):\n+        self.cargo_channel = ''\n+        self.date = ''\n+        self._download_url = 'https://static.rust-lang.org'\n+        self.rustc_channel = ''\n+        self.build = ''\n+        self.build_dir = os.path.join(os.getcwd(), \"build\")\n+        self.clean = False\n+        self.config_mk = ''\n+        self.config_toml = ''\n+        self.printed = False\n+        self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+        self.use_locked_deps = ''\n+        self.use_vendored_sources = ''\n+        self.verbose = False\n \n     def download_stage0(self):\n-        cache_dst = os.path.join(self.build_dir, \"cache\")\n-        rustc_cache = os.path.join(cache_dst, self.stage0_date())\n-        if not os.path.exists(rustc_cache):\n-            os.makedirs(rustc_cache)\n+        \"\"\"Fetch the build system for Rust, written in Rust\n+\n+        This method will build a cache directory, then it will fetch the\n+        tarball which has the stage0 compiler used to then bootstrap the Rust\n+        compiler itself.\n \n-        rustc_channel = self.stage0_rustc_channel()\n-        cargo_channel = self.stage0_cargo_channel()\n+        Each downloaded tarball is extracted, after that, the script\n+        will move all the content to the right place.\n+        \"\"\"\n+        rustc_channel = self.rustc_channel\n+        cargo_channel = self.cargo_channel\n \n         if self.rustc().startswith(self.bin_root()) and \\\n-                (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n-            self.print_what_it_means_to_bootstrap()\n+                (not os.path.exists(self.rustc()) or\n+                 self.program_out_of_date(self.rustc_stamp())):\n+            self.print_what_bootstrap_means()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             filename = \"rust-std-{}-{}.tar.gz\".format(\n                 rustc_channel, self.build)\n-            url = self._download_url + \"/dist/\" + self.stage0_date()\n-            tarball = os.path.join(rustc_cache, filename)\n-            if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename),\n-                    tarball, verbose=self.verbose)\n-            unpack(tarball, self.bin_root(),\n-                   match=\"rust-std-\" + self.build,\n-                   verbose=self.verbose)\n+            pattern = \"rust-std-{}\".format(self.build)\n+            self._download_stage0_helper(filename, pattern)\n \n             filename = \"rustc-{}-{}.tar.gz\".format(rustc_channel, self.build)\n-            url = self._download_url + \"/dist/\" + self.stage0_date()\n-            tarball = os.path.join(rustc_cache, filename)\n-            if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename),\n-                    tarball, verbose=self.verbose)\n-            unpack(tarball, self.bin_root(),\n-                   match=\"rustc\", verbose=self.verbose)\n-            self.fix_executable(self.bin_root() + \"/bin/rustc\")\n-            self.fix_executable(self.bin_root() + \"/bin/rustdoc\")\n-            with open(self.rustc_stamp(), 'w') as f:\n-                f.write(self.stage0_date())\n+            self._download_stage0_helper(filename, \"rustc\")\n+            self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n+            self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            with open(self.rustc_stamp(), 'w') as rust_stamp:\n+                rust_stamp.write(self.date)\n \n             if \"pc-windows-gnu\" in self.build:\n                 filename = \"rust-mingw-{}-{}.tar.gz\".format(\n                     rustc_channel, self.build)\n-                url = self._download_url + \"/dist/\" + self.stage0_date()\n-                tarball = os.path.join(rustc_cache, filename)\n-                if not os.path.exists(tarball):\n-                    get(\"{}/{}\".format(url, filename),\n-                        tarball, verbose=self.verbose)\n-                unpack(tarball, self.bin_root(),\n-                       match=\"rust-mingw\", verbose=self.verbose)\n+                self._download_stage0_helper(filename, \"rust-mingw\")\n \n         if self.cargo().startswith(self.bin_root()) and \\\n-                (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n-            self.print_what_it_means_to_bootstrap()\n+                (not os.path.exists(self.cargo()) or\n+                 self.program_out_of_date(self.cargo_stamp())):\n+            self.print_what_bootstrap_means()\n             filename = \"cargo-{}-{}.tar.gz\".format(cargo_channel, self.build)\n-            url = self._download_url + \"/dist/\" + self.stage0_date()\n-            tarball = os.path.join(rustc_cache, filename)\n-            if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename),\n-                    tarball, verbose=self.verbose)\n-            unpack(tarball, self.bin_root(),\n-                   match=\"cargo\", verbose=self.verbose)\n-            self.fix_executable(self.bin_root() + \"/bin/cargo\")\n-            with open(self.cargo_stamp(), 'w') as f:\n-                f.write(self.stage0_date())\n-\n-    def fix_executable(self, fname):\n-        # If we're on NixOS we need to change the path to the dynamic loader\n+            self._download_stage0_helper(filename, \"cargo\")\n+            self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n+            with open(self.cargo_stamp(), 'w') as cargo_stamp:\n+                cargo_stamp.write(self.date)\n+\n+    def _download_stage0_helper(self, filename, pattern):\n+        cache_dst = os.path.join(self.build_dir, \"cache\")\n+        rustc_cache = os.path.join(cache_dst, self.date)\n+        if not os.path.exists(rustc_cache):\n+            os.makedirs(rustc_cache)\n+\n+        url = \"{}/dist/{}\".format(self._download_url, self.date)\n+        tarball = os.path.join(rustc_cache, filename)\n+        if not os.path.exists(tarball):\n+            get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n+        unpack(tarball, self.bin_root(), match=pattern, verbose=self.verbose)\n \n+    @staticmethod\n+    def fix_executable(fname):\n+        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker\n+\n+        This method is only required on NixOS and uses the PatchELF utility to\n+        change the dynamic linker of ELF executables.\n+\n+        Please see https://nixos.org/patchelf.html for more information\n+        \"\"\"\n         default_encoding = sys.getdefaultencoding()\n         try:\n             ostype = subprocess.check_output(\n                 ['uname', '-s']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, WindowsError):\n+        except subprocess.CalledProcessError:\n             return\n+        except OSError as reason:\n+            if getattr(reason, 'winerror', None) is not None:\n+                return\n+            raise reason\n \n         if ostype != \"Linux\":\n             return\n@@ -257,8 +279,8 @@ def fix_executable(self, fname):\n             interpreter = subprocess.check_output(\n                 [\"patchelf\", \"--print-interpreter\", fname])\n             interpreter = interpreter.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as e:\n-            print(\"warning: failed to call patchelf: %s\" % e)\n+        except subprocess.CalledProcessError as reason:\n+            print(\"warning: failed to call patchelf:\", reason)\n             return\n \n         loader = interpreter.split(\"/\")[-1]\n@@ -267,8 +289,8 @@ def fix_executable(self, fname):\n             ldd_output = subprocess.check_output(\n                 ['ldd', '/run/current-system/sw/bin/sh'])\n             ldd_output = ldd_output.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as e:\n-            print(\"warning: unable to call ldd: %s\" % e)\n+        except subprocess.CalledProcessError as reason:\n+            print(\"warning: unable to call ldd:\", reason)\n             return\n \n         for line in ldd_output.splitlines():\n@@ -285,45 +307,66 @@ def fix_executable(self, fname):\n         try:\n             subprocess.check_output(\n                 [\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n-        except subprocess.CalledProcessError as e:\n-            print(\"warning: failed to call patchelf: %s\" % e)\n+        except subprocess.CalledProcessError as reason:\n+            print(\"warning: failed to call patchelf:\", reason)\n             return\n \n-    def stage0_date(self):\n-        return self._date\n-\n-    def stage0_rustc_channel(self):\n-        return self._rustc_channel\n-\n-    def stage0_cargo_channel(self):\n-        return self._cargo_channel\n-\n     def rustc_stamp(self):\n-        \"\"\"Return the path for .rustc-stamp\"\"\"\n+        \"\"\"Return the path for .rustc-stamp\n+\n+        >>> rb = RustBuild()\n+        >>> rb.build_dir = \"build\"\n+        >>> rb.rustc_stamp() == os.path.join(\"build\", \"stage0\", \".rustc-stamp\")\n+        True\n+        \"\"\"\n         return os.path.join(self.bin_root(), '.rustc-stamp')\n \n     def cargo_stamp(self):\n-        \"\"\"Return the path for .cargo-stamp\"\"\"\n-        return os.path.join(self.bin_root(), '.cargo-stamp')\n+        \"\"\"Return the path for .cargo-stamp\n \n-    def rustc_out_of_date(self):\n-        \"\"\"Check if rustc is out of date\"\"\"\n-        if not os.path.exists(self.rustc_stamp()) or self.clean:\n-            return True\n-        with open(self.rustc_stamp(), 'r') as f:\n-            return self.stage0_date() != f.read()\n+        >>> rb = RustBuild()\n+        >>> rb.build_dir = \"build\"\n+        >>> rb.cargo_stamp() == os.path.join(\"build\", \"stage0\", \".cargo-stamp\")\n+        True\n+        \"\"\"\n+        return os.path.join(self.bin_root(), '.cargo-stamp')\n \n-    def cargo_out_of_date(self):\n-        \"\"\"Check if cargo is out of date\"\"\"\n-        if not os.path.exists(self.cargo_stamp()) or self.clean:\n+    def program_out_of_date(self, stamp_path):\n+        \"\"\"Check if the given program stamp is out of date\"\"\"\n+        if not os.path.exists(stamp_path) or self.clean:\n             return True\n-        with open(self.cargo_stamp(), 'r') as f:\n-            return self.stage0_date() != f.read()\n+        with open(stamp_path, 'r') as stamp:\n+            return self.date != stamp.read()\n \n     def bin_root(self):\n+        \"\"\"Return the binary root directory\n+\n+        >>> rb = RustBuild()\n+        >>> rb.build_dir = \"build\"\n+        >>> rb.bin_root() == os.path.join(\"build\", \"stage0\")\n+        True\n+\n+        When the 'build' property is given should be a nested directory:\n+\n+        >>> rb.build = \"devel\"\n+        >>> rb.bin_root() == os.path.join(\"build\", \"devel\", \"stage0\")\n+        True\n+        \"\"\"\n         return os.path.join(self.build_dir, self.build, \"stage0\")\n \n     def get_toml(self, key):\n+        \"\"\"Returns the value of the given key in config.toml, otherwise returns None\n+\n+        >>> rb = RustBuild()\n+        >>> rb.config_toml = 'key1 = \"value1\"\\\\nkey2 = \"value2\"'\n+        >>> rb.get_toml(\"key2\")\n+        'value2'\n+\n+        If the key does not exists, the result is None:\n+\n+        >>> rb.get_toml(\"key3\") == None\n+        True\n+        \"\"\"\n         for line in self.config_toml.splitlines():\n             match = re.match(r'^{}\\s*=(.*)$'.format(key), line)\n             if match is not None:\n@@ -332,6 +375,18 @@ def get_toml(self, key):\n         return None\n \n     def get_mk(self, key):\n+        \"\"\"Returns the value of the given key in config.mk, otherwise returns None\n+\n+        >>> rb = RustBuild()\n+        >>> rb.config_mk = 'key := value\\\\n'\n+        >>> rb.get_mk('key')\n+        'value'\n+\n+        If the key does not exists, the result is None:\n+\n+        >>> rb.get_mk('does_not_exists') == None\n+        True\n+        \"\"\"\n         for line in iter(self.config_mk.splitlines()):\n             if line.startswith(key + ' '):\n                 var = line[line.find(':=') + 2:].strip()\n@@ -340,36 +395,64 @@ def get_mk(self, key):\n         return None\n \n     def cargo(self):\n-        config = self.get_toml('cargo')\n-        if config:\n-            return config\n-        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n-        if config:\n-            return config + '/bin/cargo' + self.exe_suffix()\n-        return os.path.join(self.bin_root(), \"bin/cargo\" + self.exe_suffix())\n+        \"\"\"Return config path for cargo\"\"\"\n+        return self.program_config('cargo')\n \n     def rustc(self):\n-        config = self.get_toml('rustc')\n+        \"\"\"Return config path for rustc\"\"\"\n+        return self.program_config('rustc')\n+\n+    def program_config(self, program):\n+        \"\"\"Return config path for the given program\n+\n+        >>> rb = RustBuild()\n+        >>> rb.config_toml = 'rustc = \"rustc\"\\\\n'\n+        >>> rb.config_mk = 'CFG_LOCAL_RUST_ROOT := /tmp/rust\\\\n'\n+        >>> rb.program_config('rustc')\n+        'rustc'\n+        >>> cargo_path = rb.program_config('cargo')\n+        >>> cargo_path.rstrip(\".exe\") == os.path.join(\"/tmp/rust\",\n+        ... \"bin\", \"cargo\")\n+        True\n+        >>> rb.config_toml = ''\n+        >>> rb.config_mk = ''\n+        >>> cargo_path = rb.program_config('cargo')\n+        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(),\n+        ... \"bin\", \"cargo\")\n+        True\n+        \"\"\"\n+        config = self.get_toml(program)\n         if config:\n             return config\n         config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n         if config:\n-            return config + '/bin/rustc' + self.exe_suffix()\n-        return os.path.join(self.bin_root(), \"bin/rustc\" + self.exe_suffix())\n-\n-    def get_string(self, line):\n+            return os.path.join(config, \"bin\", \"{}{}\".format(\n+                program, self.exe_suffix()))\n+        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n+            program, self.exe_suffix()))\n+\n+    @staticmethod\n+    def get_string(line):\n+        \"\"\"Return the value between double quotes\n+\n+        >>> RustBuild.get_string('    \"devel\"   ')\n+        'devel'\n+        \"\"\"\n         start = line.find('\"')\n         if start == -1:\n             return None\n         end = start + 1 + line[start + 1:].find('\"')\n         return line[start + 1:end]\n \n-    def exe_suffix(self):\n+    @staticmethod\n+    def exe_suffix():\n+        \"\"\"Return a suffix for executables\"\"\"\n         if sys.platform == 'win32':\n             return '.exe'\n         return ''\n \n-    def print_what_it_means_to_bootstrap(self):\n+    def print_what_bootstrap_means(self):\n+        \"\"\"Prints more information about the build system\"\"\"\n         if hasattr(self, 'printed'):\n             return\n         self.printed = True\n@@ -386,10 +469,19 @@ def print_what_it_means_to_bootstrap(self):\n         print('      src/bootstrap/README.md before the download finishes')\n \n     def bootstrap_binary(self):\n-        return os.path.join(self.build_dir, \"bootstrap/debug/bootstrap\")\n+        \"\"\"Return the path of the boostrap binary\n+\n+        >>> rb = RustBuild()\n+        >>> rb.build_dir = \"build\"\n+        >>> rb.bootstrap_binary() == os.path.join(\"build\", \"bootstrap\",\n+        ... \"debug\", \"bootstrap\")\n+        True\n+        \"\"\"\n+        return os.path.join(self.build_dir, \"bootstrap\", \"debug\", \"bootstrap\")\n \n     def build_bootstrap(self):\n-        self.print_what_it_means_to_bootstrap()\n+        \"\"\"Build bootstrap\"\"\"\n+        self.print_what_bootstrap_means()\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n@@ -409,7 +501,8 @@ def build_bootstrap(self):\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n-            raise Exception(\"no cargo executable found at `%s`\" % self.cargo())\n+            raise Exception(\"no cargo executable found at `{}`\".format(\n+                self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n         if self.verbose:\n@@ -423,6 +516,7 @@ def build_bootstrap(self):\n         run(args, env=env, verbose=self.verbose)\n \n     def build_triple(self):\n+        \"\"\"Build triple as in LLVM\"\"\"\n         default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n         if config:\n@@ -445,23 +539,26 @@ def build_triple(self):\n \n         # The goal here is to come up with the same triple as LLVM would,\n         # at least for the subset of platforms we're willing to target.\n-        if ostype == 'Linux':\n+        ostype_mapper = {\n+            'Bitrig': 'unknown-bitrig',\n+            'Darwin': 'apple-darwin',\n+            'DragonFly': 'unknown-dragonfly',\n+            'FreeBSD': 'unknown-freebsd',\n+            'Haiku': 'unknown-haiku',\n+            'NetBSD': 'unknown-netbsd',\n+            'OpenBSD': 'unknown-openbsd'\n+        }\n+\n+        # Consider the direct transformation first and then the special cases\n+        if ostype in ostype_mapper:\n+            ostype = ostype_mapper[ostype]\n+        elif ostype == 'Linux':\n             os_from_sp = subprocess.check_output(\n                 ['uname', '-o']).strip().decode(default_encoding)\n             if os_from_sp == 'Android':\n                 ostype = 'linux-android'\n             else:\n                 ostype = 'unknown-linux-gnu'\n-        elif ostype == 'FreeBSD':\n-            ostype = 'unknown-freebsd'\n-        elif ostype == 'DragonFly':\n-            ostype = 'unknown-dragonfly'\n-        elif ostype == 'Bitrig':\n-            ostype = 'unknown-bitrig'\n-        elif ostype == 'OpenBSD':\n-            ostype = 'unknown-openbsd'\n-        elif ostype == 'NetBSD':\n-            ostype = 'unknown-netbsd'\n         elif ostype == 'SunOS':\n             ostype = 'sun-solaris'\n             # On Solaris, uname -m will return a machine classification instead\n@@ -477,10 +574,6 @@ def build_triple(self):\n                 if self.verbose:\n                     raise Exception(err)\n                 sys.exit(err)\n-        elif ostype == 'Darwin':\n-            ostype = 'apple-darwin'\n-        elif ostype == 'Haiku':\n-            ostype = 'unknown-haiku'\n         elif ostype.startswith('MINGW'):\n             # msys' `uname` does not print gcc configuration, but prints msys\n             # configuration. so we cannot believe `uname -m`:\n@@ -499,13 +592,36 @@ def build_triple(self):\n                 cputype = 'x86_64'\n             ostype = 'pc-windows-gnu'\n         else:\n-            err = \"unknown OS type: \" + ostype\n+            err = \"unknown OS type: {}\".format(ostype)\n             if self.verbose:\n                 raise ValueError(err)\n             sys.exit(err)\n \n-        if cputype in {'i386', 'i486', 'i686', 'i786', 'x86'}:\n-            cputype = 'i686'\n+        cputype_mapper = {\n+            'BePC': 'i686',\n+            'aarch64': 'aarch64',\n+            'amd64': 'x86_64',\n+            'arm64': 'aarch64',\n+            'i386': 'i686',\n+            'i486': 'i686',\n+            'i686': 'i686',\n+            'i786': 'i686',\n+            'powerpc': 'powerpc',\n+            'powerpc64': 'powerpc64',\n+            'powerpc64le': 'powerpc64le',\n+            'ppc': 'powerpc',\n+            'ppc64': 'powerpc64',\n+            'ppc64le': 'powerpc64le',\n+            's390x': 's390x',\n+            'x64': 'x86_64',\n+            'x86': 'i686',\n+            'x86-64': 'x86_64',\n+            'x86_64': 'x86_64'\n+        }\n+\n+        # Consider the direct transformation first and then the special cases\n+        if cputype in cputype_mapper:\n+            cputype = cputype_mapper[cputype]\n         elif cputype in {'xscale', 'arm'}:\n             cputype = 'arm'\n             if ostype == 'linux-android':\n@@ -522,47 +638,34 @@ def build_triple(self):\n                 ostype = 'linux-androideabi'\n             else:\n                 ostype += 'eabihf'\n-        elif cputype in {'aarch64', 'arm64'}:\n-            cputype = 'aarch64'\n         elif cputype == 'mips':\n             if sys.byteorder == 'big':\n                 cputype = 'mips'\n             elif sys.byteorder == 'little':\n                 cputype = 'mipsel'\n             else:\n-                raise ValueError('unknown byteorder: ' + sys.byteorder)\n+                raise ValueError(\"unknown byteorder: {}\".format(sys.byteorder))\n         elif cputype == 'mips64':\n             if sys.byteorder == 'big':\n                 cputype = 'mips64'\n             elif sys.byteorder == 'little':\n                 cputype = 'mips64el'\n             else:\n-                raise ValueError('unknown byteorder: ' + sys.byteorder)\n+                raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n             # only the n64 ABI is supported, indicate it\n             ostype += 'abi64'\n-        elif cputype in {'powerpc', 'ppc'}:\n-            cputype = 'powerpc'\n-        elif cputype in {'powerpc64', 'ppc64'}:\n-            cputype = 'powerpc64'\n-        elif cputype in {'powerpc64le', 'ppc64le'}:\n-            cputype = 'powerpc64le'\n         elif cputype == 'sparcv9':\n             pass\n-        elif cputype in {'amd64', 'x86_64', 'x86-64', 'x64'}:\n-            cputype = 'x86_64'\n-        elif cputype == 's390x':\n-            cputype = 's390x'\n-        elif cputype == 'BePC':\n-            cputype = 'i686'\n         else:\n-            err = \"unknown cpu type: \" + cputype\n+            err = \"unknown cpu type: {}\".format(cputype)\n             if self.verbose:\n                 raise ValueError(err)\n             sys.exit(err)\n \n         return \"{}-{}\".format(cputype, ostype)\n \n     def update_submodules(self):\n+        \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\" or \\\n                 self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n@@ -592,8 +695,13 @@ def update_submodules(self):\n              \"clean\", \"-qdfx\"],\n             cwd=self.rust_root, verbose=self.verbose)\n \n+    def set_dev_environment(self):\n+        \"\"\"Set download URL for development environment\"\"\"\n+        self._download_url = 'https://dev-static.rust-lang.org'\n+\n \n def bootstrap():\n+    \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n@@ -604,107 +712,103 @@ def bootstrap():\n     args, _ = parser.parse_known_args(args)\n \n     # Configure initial bootstrap\n-    rb = RustBuild()\n-    rb.config_toml = ''\n-    rb.config_mk = ''\n-    rb.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n-    rb.build_dir = os.path.join(os.getcwd(), \"build\")\n-    rb.verbose = args.verbose\n-    rb.clean = args.clean\n+    build = RustBuild()\n+    build.verbose = args.verbose\n+    build.clean = args.clean\n \n     try:\n         with open(args.config or 'config.toml') as config:\n-            rb.config_toml = config.read()\n+            build.config_toml = config.read()\n     except:\n         pass\n     try:\n-        rb.config_mk = open('config.mk').read()\n+        build.config_mk = open('config.mk').read()\n     except:\n         pass\n \n-    if '\\nverbose = 2' in rb.config_toml:\n-        rb.verbose = 2\n-    elif '\\nverbose = 1' in rb.config_toml:\n-        rb.verbose = 1\n+    if '\\nverbose = 2' in build.config_toml:\n+        build.verbose = 2\n+    elif '\\nverbose = 1' in build.config_toml:\n+        build.verbose = 1\n \n-    rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n-                              'CFG_ENABLE_VENDOR' in rb.config_mk\n+    build.use_vendored_sources = '\\nvendor = true' in build.config_toml or \\\n+                                 'CFG_ENABLE_VENDOR' in build.config_mk\n \n-    rb.use_locked_deps = '\\nlocked-deps = true' in rb.config_toml or \\\n-                         'CFG_ENABLE_LOCKED_DEPS' in rb.config_mk\n+    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml or \\\n+                            'CFG_ENABLE_LOCKED_DEPS' in build.config_mk\n \n-    if 'SUDO_USER' in os.environ and not rb.use_vendored_sources:\n+    if 'SUDO_USER' in os.environ and not build.use_vendored_sources:\n         if os.environ.get('USER') != os.environ['SUDO_USER']:\n-            rb.use_vendored_sources = True\n+            build.use_vendored_sources = True\n             print('info: looks like you are running this command under `sudo`')\n             print('      and so in order to preserve your $HOME this will now')\n             print('      use vendored sources by default. Note that if this')\n             print('      does not work you should run a normal build first')\n             print('      before running a command like `sudo make install`')\n \n-    if rb.use_vendored_sources:\n+    if build.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        with open('.cargo/config', 'w') as f:\n-            f.write(\"\"\"\n+        with open('.cargo/config', 'w') as cargo_config:\n+            cargo_config.write(\"\"\"\n                 [source.crates-io]\n                 replace-with = 'vendored-sources'\n                 registry = 'https://example.com'\n \n                 [source.vendored-sources]\n                 directory = '{}/src/vendor'\n-            \"\"\".format(rb.rust_root))\n+            \"\"\".format(build.rust_root))\n     else:\n         if os.path.exists('.cargo'):\n             shutil.rmtree('.cargo')\n \n-    data = stage0_data(rb.rust_root)\n-    rb._date = data['date']\n-    rb._rustc_channel = data['rustc']\n-    rb._cargo_channel = data['cargo']\n+    data = stage0_data(build.rust_root)\n+    build.date = data['date']\n+    build.rustc_channel = data['rustc']\n+    build.cargo_channel = data['cargo']\n+\n     if 'dev' in data:\n-        rb._download_url = 'https://dev-static.rust-lang.org'\n-    else:\n-        rb._download_url = 'https://static.rust-lang.org'\n+        build.set_dev_environment()\n \n-    rb.update_submodules()\n+    build.update_submodules()\n \n     # Fetch/build the bootstrap\n-    rb.build = args.build or rb.build_triple()\n-    rb.download_stage0()\n+    build.build = args.build or build.build_triple()\n+    build.download_stage0()\n     sys.stdout.flush()\n-    rb.build_bootstrap()\n+    build.build_bootstrap()\n     sys.stdout.flush()\n \n     # Run the bootstrap\n-    args = [rb.bootstrap_binary()]\n+    args = [build.bootstrap_binary()]\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n-    env[\"BUILD\"] = rb.build\n-    env[\"SRC\"] = rb.rust_root\n+    env[\"BUILD\"] = build.build\n+    env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n-    run(args, env=env, verbose=rb.verbose)\n+    run(args, env=env, verbose=build.verbose)\n \n \n def main():\n+    \"\"\"Entry point for the bootstrap process\"\"\"\n     start_time = time()\n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n         bootstrap()\n         if not help_triggered:\n-            print(\"Build completed successfully in %s\" %\n-                  format_build_time(time() - start_time))\n-    except (SystemExit, KeyboardInterrupt) as e:\n-        if hasattr(e, 'code') and isinstance(e.code, int):\n-            exit_code = e.code\n+            print(\"Build completed successfully in {}\".format(\n+                format_build_time(time() - start_time)))\n+    except (SystemExit, KeyboardInterrupt) as error:\n+        if hasattr(error, 'code') and isinstance(error.code, int):\n+            exit_code = error.code\n         else:\n             exit_code = 1\n-            print(e)\n+            print(error)\n         if not help_triggered:\n-            print(\"Build completed unsuccessfully in %s\" %\n-                  format_build_time(time() - start_time))\n+            print(\"Build completed unsuccessfully in {}\".format(\n+                format_build_time(time() - start_time)))\n         sys.exit(exit_code)\n \n "}, {"sha": "a65a3a4042eca1ecd9b1c3b49a3071b94b67b694", "filename": "src/bootstrap/bootstrap_test.py", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=b5e8a8ef97abef8a69a9c72de74fed779b401d73", "patch": "@@ -0,0 +1,114 @@\n+# Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+\"\"\"Bootstrap tests\"\"\"\n+\n+import os\n+import doctest\n+import unittest\n+import tempfile\n+import hashlib\n+\n+from shutil import rmtree\n+\n+import bootstrap\n+\n+\n+class Stage0DataTestCase(unittest.TestCase):\n+    \"\"\"Test Case for stage0_data\"\"\"\n+    def setUp(self):\n+        self.rust_root = tempfile.mkdtemp()\n+        os.mkdir(os.path.join(self.rust_root, \"src\"))\n+        with open(os.path.join(self.rust_root, \"src\",\n+                               \"stage0.txt\"), \"w\") as stage0:\n+            stage0.write(\"#ignore\\n\\ndate: 2017-06-15\\nrustc: beta\\ncargo: beta\")\n+\n+    def tearDown(self):\n+        rmtree(self.rust_root)\n+\n+    def test_stage0_data(self):\n+        \"\"\"Extract data from stage0.txt\"\"\"\n+        expected = {\"date\": \"2017-06-15\", \"rustc\": \"beta\", \"cargo\": \"beta\"}\n+        data = bootstrap.stage0_data(self.rust_root)\n+        self.assertDictEqual(data, expected)\n+\n+\n+class VerifyTestCase(unittest.TestCase):\n+    \"\"\"Test Case for verify\"\"\"\n+    def setUp(self):\n+        self.container = tempfile.mkdtemp()\n+        self.src = os.path.join(self.container, \"src.txt\")\n+        self.sums = os.path.join(self.container, \"sums\")\n+        self.bad_src = os.path.join(self.container, \"bad.txt\")\n+        content = \"Hello world\"\n+\n+        with open(self.src, \"w\") as src:\n+            src.write(content)\n+        with open(self.sums, \"w\") as sums:\n+            sums.write(hashlib.sha256(content.encode(\"utf-8\")).hexdigest())\n+        with open(self.bad_src, \"w\") as bad:\n+            bad.write(\"Hello!\")\n+\n+    def tearDown(self):\n+        rmtree(self.container)\n+\n+    def test_valid_file(self):\n+        \"\"\"Check if the sha256 sum of the given file is valid\"\"\"\n+        self.assertTrue(bootstrap.verify(self.src, self.sums, False))\n+\n+    def test_invalid_file(self):\n+        \"\"\"Should verify that the file is invalid\"\"\"\n+        self.assertFalse(bootstrap.verify(self.bad_src, self.sums, False))\n+\n+\n+class ProgramOutOfDate(unittest.TestCase):\n+    \"\"\"Test if a program is out of date\"\"\"\n+    def setUp(self):\n+        self.container = tempfile.mkdtemp()\n+        os.mkdir(os.path.join(self.container, \"stage0\"))\n+        self.build = bootstrap.RustBuild()\n+        self.build.date = \"2017-06-15\"\n+        self.build.build_dir = self.container\n+        self.rustc_stamp_path = os.path.join(self.container, \"stage0\",\n+                                             \".rustc-stamp\")\n+\n+    def tearDown(self):\n+        rmtree(self.container)\n+\n+    def test_stamp_path_does_not_exists(self):\n+        \"\"\"Return True when the stamp file does not exists\"\"\"\n+        if os.path.exists(self.rustc_stamp_path):\n+            os.unlink(self.rustc_stamp_path)\n+        self.assertTrue(self.build.program_out_of_date(self.rustc_stamp_path))\n+\n+    def test_dates_are_different(self):\n+        \"\"\"Return True when the dates are different\"\"\"\n+        with open(self.rustc_stamp_path, \"w\") as rustc_stamp:\n+            rustc_stamp.write(\"2017-06-14\")\n+        self.assertTrue(self.build.program_out_of_date(self.rustc_stamp_path))\n+\n+    def test_same_dates(self):\n+        \"\"\"Return False both dates match\"\"\"\n+        with open(self.rustc_stamp_path, \"w\") as rustc_stamp:\n+            rustc_stamp.write(\"2017-06-15\")\n+        self.assertFalse(self.build.program_out_of_date(self.rustc_stamp_path))\n+\n+\n+if __name__ == '__main__':\n+    SUITE = unittest.TestSuite()\n+    TEST_LOADER = unittest.TestLoader()\n+    SUITE.addTest(doctest.DocTestSuite(bootstrap))\n+    SUITE.addTests([\n+        TEST_LOADER.loadTestsFromTestCase(Stage0DataTestCase),\n+        TEST_LOADER.loadTestsFromTestCase(VerifyTestCase),\n+        TEST_LOADER.loadTestsFromTestCase(ProgramOutOfDate)])\n+\n+    RUNNER = unittest.TextTestRunner(verbosity=2)\n+    RUNNER.run(SUITE)"}, {"sha": "9410927824cc131c3c7c1ce233e6b18f5813bd61", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=b5e8a8ef97abef8a69a9c72de74fed779b401d73", "patch": "@@ -64,6 +64,8 @@ check-aux:\n \t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\tsrc/test/run-fail-fulldeps/pretty \\\n \t\t$(BOOTSTRAP_ARGS)\n+check-bootstrap:\n+\t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n distcheck:"}, {"sha": "ccf0bb1ffb707766cc59ba72e30cde3372c64695", "filename": "src/ci/run.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b5e8a8ef97abef8a69a9c72de74fed779b401d73/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=b5e8a8ef97abef8a69a9c72de74fed779b401d73", "patch": "@@ -74,6 +74,12 @@ retry make prepare\n travis_fold end make-prepare\n travis_time_finish\n \n+travis_fold start check-bootstrap\n+travis_time_start\n+make check-bootstrap\n+travis_fold end check-bootstrap\n+travis_time_finish\n+\n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n     ncpus=$(sysctl -n hw.ncpu)\n else"}]}