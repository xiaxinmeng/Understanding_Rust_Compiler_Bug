{"sha": "1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzlkZDZmMmRmMWVlY2RkNDMyY2Y3MmM5MWM0ZWU5ODhiNTRjNzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-07T11:34:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-07T11:34:31Z"}, "message": "Merge #3045\n\n3045: Cleanup early return assist r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b5e467df6bf55bcd6fcdb849e5422f3720ec7006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e467df6bf55bcd6fcdb849e5422f3720ec7006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJePUtHCRBK7hj4Ov3rIwAAdHIIAJZ3CcTKscpgMM7H+stAEsO2\n8qFlmWJJer50D1G7KNG2n14uMUCBzo6uCOOP6SWC+YyhPXdX/99+fcV2Ud00sgSh\nrdHEHHBCEmXucxegukInGVWBBK6e3P+31Z8ejnueLwErjFo5e+fDF5sAqbGfPrpP\nuC1/0NMK53G95g3Y4EKXpLouVc85WDPK9NOYcYgwnsl9ijClKK3EYJ4uCzFJLlWC\n015sWuA5niad64Y6KE7+3DDffgjCMvToSCt4ax2tc1RgCGURXFIHU4I2yKdc0Sf1\npshUu3vmN/eaExg3h+oBi1BoIbiO/e6x6fi+8gAHxnj80N7PTPOKdvlpiLXKOJ0=\n=j/Uh\n-----END PGP SIGNATURE-----\n", "payload": "tree b5e467df6bf55bcd6fcdb849e5422f3720ec7006\nparent 5aba5a756a19a54d5c4edd51d8055db36182688b\nparent 36ee9ecb678d775609bf3825f1c4fd8e0c56bf32\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581075271 +0000\ncommitter GitHub <noreply@github.com> 1581075271 +0000\n\nMerge #3045\n\n3045: Cleanup early return assist r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "html_url": "https://github.com/rust-lang/rust/commit/1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aba5a756a19a54d5c4edd51d8055db36182688b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aba5a756a19a54d5c4edd51d8055db36182688b", "html_url": "https://github.com/rust-lang/rust/commit/5aba5a756a19a54d5c4edd51d8055db36182688b"}, {"sha": "36ee9ecb678d775609bf3825f1c4fd8e0c56bf32", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ee9ecb678d775609bf3825f1c4fd8e0c56bf32", "html_url": "https://github.com/rust-lang/rust/commit/36ee9ecb678d775609bf3825f1c4fd8e0c56bf32"}], "stats": {"total": 93, "additions": 64, "deletions": 29}, "files": [{"sha": "ba08a8223b95ff36cd4da25a5223c7a1a356982c", "filename": "crates/ra_assists/src/assists/apply_demorgan.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs?ref=1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "patch": "@@ -31,12 +31,14 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     if !cursor_in_range {\n         return None;\n     }\n+\n     let lhs = expr.lhs()?;\n     let lhs_range = lhs.syntax().text_range();\n+    let not_lhs = invert_boolean_expression(lhs);\n+\n     let rhs = expr.rhs()?;\n     let rhs_range = rhs.syntax().text_range();\n-    let not_lhs = invert_boolean_expression(&lhs)?;\n-    let not_rhs = invert_boolean_expression(&rhs)?;\n+    let not_rhs = invert_boolean_expression(rhs);\n \n     ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", |edit| {\n         edit.target(op_range);\n@@ -77,12 +79,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn demorgan_doesnt_apply_with_cursor_not_on_op() {\n-        check_assist_not_applicable(apply_demorgan, \"fn f() { <|> !x || !x }\")\n+    fn demorgan_general_case() {\n+        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x &&<|> !x) }\")\n     }\n \n     #[test]\n-    fn demorgan_doesnt_apply_when_operands_arent_negated_already() {\n-        check_assist_not_applicable(apply_demorgan, \"fn f() { x ||<|> x }\")\n+    fn demorgan_doesnt_apply_with_cursor_not_on_op() {\n+        check_assist_not_applicable(apply_demorgan, \"fn f() { <|> !x || !x }\")\n     }\n }"}, {"sha": "8f30dc586088050c555ad66a55dd03f777d6a3e3", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "patch": "@@ -10,6 +10,7 @@ use ra_syntax::{\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n+    assists::invert_if::invert_boolean_expression,\n     AssistId,\n };\n \n@@ -99,9 +100,13 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n         let new_block = match if_let_pat {\n             None => {\n                 // If.\n-                let early_expression = &(early_expression.syntax().to_string() + \";\");\n-                let new_expr = if_indent_level\n-                    .increase_indent(make::if_expression(cond_expr, early_expression));\n+                let new_expr = {\n+                    let then_branch =\n+                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                    let cond = invert_boolean_expression(cond_expr);\n+                    let e = make::expr_if(cond, then_branch);\n+                    if_indent_level.increase_indent(e)\n+                };\n                 replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n             Some((path, bound_ident)) => {"}, {"sha": "983392f21ee3039143894576bc744cee698719eb", "filename": "crates/ra_assists/src/assists/invert_if.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs?ref=1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::ast::{self, make, AstNode};\n use ra_syntax::T;\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -35,8 +35,8 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n     let then_node = expr.then_branch()?.syntax().clone();\n \n     if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let flip_cond = invert_boolean_expression(&cond)?;\n         let cond_range = cond.syntax().text_range();\n+        let flip_cond = invert_boolean_expression(cond);\n         let else_node = else_block.syntax();\n         let else_range = else_node.text_range();\n         let then_range = then_node.text_range();\n@@ -51,16 +51,23 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n     None\n }\n \n-pub(crate) fn invert_boolean_expression(expr: &ast::Expr) -> Option<ast::Expr> {\n+pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n+    if let Some(expr) = invert_special_case(&expr) {\n+        return expr;\n+    }\n+    make::expr_prefix(T![!], expr)\n+}\n+\n+pub(crate) fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n     match expr {\n         ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n             ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n+            ast::BinOp::EqualityTest => bin.replace_op(T![!=]).map(|it| it.into()),\n             _ => None,\n         },\n-        ast::Expr::PrefixExpr(pe) => match pe.op_kind()? {\n-            ast::PrefixOp::Not => pe.expr(),\n-            _ => None,\n-        },\n+        ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::PrefixOp::Not => pe.expr(),\n+        // FIXME:\n+        // ast::Expr::Literal(true | false )\n         _ => None,\n     }\n }\n@@ -90,12 +97,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn invert_if_doesnt_apply_with_cursor_not_on_if() {\n-        check_assist_not_applicable(invert_if, \"fn f() { if !<|>cond { 3 * 2 } else { 1 } }\")\n+    fn invert_if_general_case() {\n+        check_assist(\n+            invert_if,\n+            \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\",\n+            \"fn f() { i<|>f !cond { 1 } else { 3 * 2 } }\",\n+        )\n     }\n \n     #[test]\n-    fn invert_if_doesnt_apply_without_negated() {\n-        check_assist_not_applicable(invert_if, \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\")\n+    fn invert_if_doesnt_apply_with_cursor_not_on_if() {\n+        check_assist_not_applicable(invert_if, \"fn f() { if !<|>cond { 3 * 2 } else { 1 } }\")\n     }\n }"}, {"sha": "862eb11728cd491527f71e2220b8e56e8ec6ac52", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1479dd6f2df1eecdd432cf72c91c4ee988b54c77/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=1479dd6f2df1eecdd432cf72c91c4ee988b54c77", "patch": "@@ -33,6 +33,21 @@ pub fn record_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordF\n     }\n }\n \n+pub fn block_expr(\n+    stmts: impl IntoIterator<Item = ast::Stmt>,\n+    tail_expr: Option<ast::Expr>,\n+) -> ast::BlockExpr {\n+    let mut text = \"{\\n\".to_string();\n+    for stmt in stmts.into_iter() {\n+        text += &format!(\"    {}\\n\", stmt.syntax());\n+    }\n+    if let Some(tail_expr) = tail_expr {\n+        text += &format!(\"    {}\\n\", tail_expr.syntax())\n+    }\n+    text += \"}\";\n+    ast_from_text(&format!(\"fn f() {}\", text))\n+}\n+\n pub fn block_from_expr(e: ast::Expr) -> ast::Block {\n     return from_text(&format!(\"{{ {} }}\", e.syntax()));\n \n@@ -62,6 +77,13 @@ pub fn expr_return() -> ast::Expr {\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr.syntax(), match_arm_list.syntax()))\n }\n+pub fn expr_if(condition: ast::Expr, then_branch: ast::BlockExpr) -> ast::Expr {\n+    expr_from_text(&format!(\"if {} {}\", condition.syntax(), then_branch.syntax()))\n+}\n+pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n+    let token = token(op);\n+    expr_from_text(&format!(\"{}{}\", token, expr.syntax()))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -158,21 +180,16 @@ pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::Whe\n     }\n }\n \n-pub fn if_expression(condition: ast::Expr, statement: &str) -> ast::IfExpr {\n-    ast_from_text(&format!(\n-        \"fn f() {{ if !{} {{\\n    {}\\n}}\\n}}\",\n-        condition.syntax().text(),\n-        statement\n-    ))\n-}\n-\n pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetStmt {\n     let text = match initializer {\n         Some(it) => format!(\"let {} = {};\", pattern.syntax(), it.syntax()),\n         None => format!(\"let {};\", pattern.syntax()),\n     };\n     ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n }\n+pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n+    ast_from_text(&format!(\"fn f() {{ {}; }}\", expr.syntax()))\n+}\n \n pub fn token(kind: SyntaxKind) -> SyntaxToken {\n     tokens::SOURCE_FILE\n@@ -203,7 +220,7 @@ pub mod tokens {\n     use once_cell::sync::Lazy;\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2)\\n;\"));\n+        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\"));\n \n     pub fn comma() -> SyntaxToken {\n         SOURCE_FILE"}]}