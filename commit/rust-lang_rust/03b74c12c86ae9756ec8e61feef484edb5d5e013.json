{"sha": "03b74c12c86ae9756ec8e61feef484edb5d5e013", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjc0YzEyYzg2YWU5NzU2ZWM4ZTYxZmVlZjQ4NGVkYjVkNWUwMTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-03T09:02:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-03T09:02:17Z"}, "message": "Merge branch 'master' into debug", "tree": {"sha": "0b665fbed69b99b9e4d175cca4ffaf65dfcb10f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b665fbed69b99b9e4d175cca4ffaf65dfcb10f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b74c12c86ae9756ec8e61feef484edb5d5e013", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc9OIZCRBK7hj4Ov3rIwAAdHIIADzYV/PhvAtr7xExZ0px/trW\ntKGFUs+SGOTjJlzSg7Jbctr+O2GTyso1mFRSLQRKetwn6Hiuh6M+ggpeLIY9ch6t\nxx1ShB9Y/ovsgjJmj7NIdrhuT3vCZ6tBYkCfmxwMPpxuZI01CE1CO8gM7saEptKd\npaWMvnadyBdLGgof4dHvJGmO7fUMpMAXVL6AYgL4homFn6Pj3A7Gplq8DSrdXOv5\nMmdzJSRi5Xk2Au4ZMi8jSEZCX+6p2MfCy1st/YCrzHYpRKSWPiUZm9LVYjCr6CSm\nLNUFAxDCYCsvMzFqCbVyEwa9TakDLg1S8jKleJqOqU8jhIDXTRIFQM062Ld0UeA=\n=iCv8\n-----END PGP SIGNATURE-----\n", "payload": "tree 0b665fbed69b99b9e4d175cca4ffaf65dfcb10f2\nparent 96444c11eee3a6d29d22056eee7e1d2ea73ebb19\nparent 0c4d68835bee388c271ddbdb7db693f436f7706b\nauthor Ralf Jung <post@ralfj.de> 1559552537 +0200\ncommitter GitHub <noreply@github.com> 1559552537 +0200\n\nMerge branch 'master' into debug"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b74c12c86ae9756ec8e61feef484edb5d5e013", "html_url": "https://github.com/rust-lang/rust/commit/03b74c12c86ae9756ec8e61feef484edb5d5e013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b74c12c86ae9756ec8e61feef484edb5d5e013/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96444c11eee3a6d29d22056eee7e1d2ea73ebb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/96444c11eee3a6d29d22056eee7e1d2ea73ebb19", "html_url": "https://github.com/rust-lang/rust/commit/96444c11eee3a6d29d22056eee7e1d2ea73ebb19"}, {"sha": "0c4d68835bee388c271ddbdb7db693f436f7706b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4d68835bee388c271ddbdb7db693f436f7706b", "html_url": "https://github.com/rust-lang/rust/commit/0c4d68835bee388c271ddbdb7db693f436f7706b"}], "stats": {"total": 170, "additions": 94, "deletions": 76}, "files": [{"sha": "0627c9986fb4a08c74cd10027b169f4c2565a81f", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -34,8 +34,8 @@ required-features = [\"rustc_tests\"]\n \n [dependencies]\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n-cargo_metadata = { version = \"0.7\", optional = true }\n-directories = { version = \"1.0\", optional = true }\n+cargo_metadata = { version = \"0.8\", optional = true }\n+directories = { version = \"2.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n env_logger = \"0.6\"\n log = \"0.4\""}, {"sha": "7604934a98b3390ec8c712941e30c7da7d7b1669", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -1 +1 @@\n-c28084ac16af4ab594b6860958df140e7c876a13\n+627486af15d222bcba336b12ea92a05237cc9ab1"}, {"sha": "d46d185c5f488ffdb67dd57f1efb247bcb879bf2", "filename": "src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n \n use crate::{\n     PlaceTy, OpTy, ImmTy, Immediate, Scalar, ScalarMaybeUndef, Tag,\n-    OperatorEvalContextExt\n+    OperatorEvalContextExt, MiriMemoryKind,\n };\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n@@ -401,7 +401,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n-                let value = this.str_to_immediate(&ty_name)?;\n+                let ptr = this.memory_mut().allocate_static_bytes(ty_name.as_bytes(), MiriMemoryKind::Static.into());\n+                let value = Immediate::new_slice(Scalar::Ptr(ptr), ty_name.len() as u64, this);\n                 this.write_immediate(value, dest)?;\n             }\n "}, {"sha": "bf0c6cd38787e93e7e66175baacaacc1cb01d204", "filename": "src/lib.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -30,7 +30,7 @@ use rand::SeedableRng;\n \n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{LayoutOf, Size, Align};\n-use rustc::hir::{self, def_id::DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::mir;\n pub use rustc_mir::interpret::*;\n // Resolve ambiguity.\n@@ -113,7 +113,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     // Return value (in static memory so that it does not count as leak).\n     let ret = ecx.layout_of(start_mir.return_ty())?;\n-    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into());\n+    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n \n     // Push our stack frame.\n     ecx.push_stack_frame(\n@@ -128,7 +128,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     let mut args = ecx.frame().mir.args_iter();\n \n     // First argument: pointer to `main()`.\n-    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n+    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n     let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n     ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n \n@@ -162,7 +162,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // Add `0` terminator.\n         let mut arg = arg.into_bytes();\n         arg.push(0);\n-        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice()).with_default_tag());\n+        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n     }\n     // Make an array with all these pointers, in the Miri memory.\n     let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n@@ -299,8 +299,8 @@ pub enum MiriMemoryKind {\n     C,\n     /// Part of env var emulation.\n     Env,\n-    /// Mutable statics.\n-    MutStatic,\n+    /// Statics.\n+    Static,\n }\n \n impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n@@ -316,7 +316,7 @@ impl MayLeak for MiriMemoryKind {\n         use self::MiriMemoryKind::*;\n         match self {\n             Rust | C => false,\n-            Env | MutStatic => true,\n+            Env | Static => true,\n         }\n     }\n }\n@@ -392,7 +392,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n \n-    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n+    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n \n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool {\n@@ -476,8 +476,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        memory_extra: &Self::MemoryExtra,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Tag, Self::AllocExtra>>> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n             Some(name) => name.as_str(),\n@@ -489,8 +488,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n                 // This should be all-zero, pointer-sized.\n                 let size = tcx.data_layout.pointer_size;\n                 let data = vec![0; size.bytes() as usize];\n-                let extra = Stacks::new(size, Tag::default(), Rc::clone(memory_extra));\n-                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi, extra)\n+                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n             }\n             _ => return err!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n@@ -506,47 +504,48 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(())\n     }\n \n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n+    fn tag_allocation<'b>(\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKinds>>,\n         memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Tag, Self::AllocExtra>> {\n-        let extra = Stacks::new(\n+    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n+        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n+        let alloc = alloc.into_owned();\n+        let (extra, base_tag) = Stacks::new_allocation(\n+            id,\n             Size::from_bytes(alloc.bytes.len() as u64),\n-            Tag::default(),\n             Rc::clone(memory_extra),\n+            kind,\n         );\n+        if kind != MiriMemoryKind::Static.into() {\n+            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n+            // Now we can rely on the inner pointers being static, too.\n+        }\n+        let mut memory_extra = memory_extra.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n-            bytes: alloc.bytes.clone(),\n+            bytes: alloc.bytes,\n             relocations: Relocations::from_presorted(\n                 alloc.relocations.iter()\n-                    .map(|&(offset, ((), alloc))| (offset, (Tag::default(), alloc)))\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n                     .collect()\n             ),\n-            undef_mask: alloc.undef_mask.clone(),\n+            undef_mask: alloc.undef_mask,\n             align: alloc.align,\n             mutability: alloc.mutability,\n             extra,\n         };\n-        Cow::Owned(alloc)\n-    }\n-\n-    #[inline(always)]\n-    fn new_allocation(\n-        size: Size,\n-        extra: &Self::MemoryExtra,\n-        kind: MemoryKind<MiriMemoryKind>,\n-    ) -> (Self::AllocExtra, Self::PointerTag) {\n-        Stacks::new_allocation(size, extra, kind)\n+        (Cow::Owned(alloc), base_tag)\n     }\n \n     #[inline(always)]\n-    fn tag_dereference(\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Tag>,\n-        _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Tag>> {\n-        // Nothing happens.\n-        Ok(place.ptr)\n+    fn tag_static_base_pointer(\n+        id: AllocId,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Self::PointerTag {\n+        memory_extra.borrow_mut().static_base_ptr(id)\n     }\n \n     #[inline(always)]"}, {"sha": "dee4ca33c25d39aca96e6306ea3495724a233ce5", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -1,5 +1,5 @@\n use std::cell::RefCell;\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n use std::fmt;\n use std::num::NonZeroU64;\n@@ -10,7 +10,7 @@ use rustc::mir::RetagKind;\n \n use crate::{\n     EvalResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, CheckInAllocMsg,\n+    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId, CheckInAllocMsg,\n     Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -92,10 +92,18 @@ pub struct Stacks {\n /// Extra global state, available to the memory access hooks.\n #[derive(Debug)]\n pub struct GlobalState {\n+    /// Next unused pointer ID (tag).\n     next_ptr_id: PtrId,\n+    /// Table storing the \"base\" tag for each allocation.\n+    /// The base tag is the one used for the initial pointer.\n+    /// We need this in a separate table to handle cyclic statics.\n+    base_ptr_ids: HashMap<AllocId, Tag>,\n+    /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n+    /// Those call IDs corresponding to functions that are still running.\n     active_calls: HashSet<CallId>,\n }\n+/// Memory extra state gives us interior mutable access to the global state.\n pub type MemoryState = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n@@ -144,14 +152,15 @@ impl Default for GlobalState {\n     fn default() -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n+            base_ptr_ids: HashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: HashSet::default(),\n         }\n     }\n }\n \n impl GlobalState {\n-    pub fn new_ptr(&mut self) -> PtrId {\n+    fn new_ptr(&mut self) -> PtrId {\n         let id = self.next_ptr_id;\n         self.next_ptr_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n@@ -172,6 +181,15 @@ impl GlobalState {\n     fn is_active(&self, id: CallId) -> bool {\n         self.active_calls.contains(&id)\n     }\n+\n+    pub fn static_base_ptr(&mut self, id: AllocId) -> Tag {\n+        self.base_ptr_ids.get(&id).copied().unwrap_or_else(|| {\n+            let tag = Tag::Tagged(self.new_ptr());\n+            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n+            self.base_ptr_ids.insert(id, tag);\n+            tag\n+        })\n+    }\n }\n \n // # Stacked Borrows Core Begin\n@@ -190,14 +208,6 @@ impl GlobalState {\n /// F3: If an access happens with an `&` outside `UnsafeCell`,\n ///     it requires the `SharedReadOnly` to still be in the stack.\n \n-impl Default for Tag {\n-    #[inline(always)]\n-    fn default() -> Tag {\n-        Tag::Untagged\n-    }\n-}\n-\n-\n /// Core relation on `Permission` to define which accesses are allowed\n impl Permission {\n     /// This defines for a given permission, whether it permits the given kind of access.\n@@ -409,12 +419,13 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    pub(crate) fn new(\n+    fn new(\n         size: Size,\n+        perm: Permission,\n         tag: Tag,\n         extra: MemoryState,\n     ) -> Self {\n-        let item = Item { perm: Permission::Unique, tag, protector: None };\n+        let item = Item { perm, tag, protector: None };\n         let stack = Stack {\n             borrows: vec![item],\n         };\n@@ -443,27 +454,25 @@ impl<'tcx> Stacks {\n /// Glue code to connect with Miri Machine Hooks\n impl Stacks {\n     pub fn new_allocation(\n+        id: AllocId,\n         size: Size,\n-        extra: &MemoryState,\n+        extra: MemoryState,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n-        let tag = match kind {\n-            MemoryKind::Stack => {\n-                // New unique borrow. This `Uniq` is not accessible by the program,\n+        let (tag, perm) = match kind {\n+            MemoryKind::Stack =>\n+                // New unique borrow. This tag is not accessible by the program,\n                 // so it will only ever be used when using the local directly (i.e.,\n-                // not through a pointer). That is, whenever we directly use a local, this will pop\n+                // not through a pointer). That is, whenever we directly write to a local, this will pop\n                 // everything else off the stack, invalidating all previous pointers,\n-                // and in particular, *all* raw pointers. This subsumes the explicit\n-                // `reset` which the blog post [1] says to perform when accessing a local.\n-                //\n-                // [1]: <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>\n-                Tag::Tagged(extra.borrow_mut().new_ptr())\n-            }\n-            _ => {\n-                Tag::Untagged\n-            }\n+                // and in particular, *all* raw pointers.\n+                (Tag::Tagged(extra.borrow_mut().new_ptr()), Permission::Unique),\n+            MemoryKind::Machine(MiriMemoryKind::Static) =>\n+                (extra.borrow_mut().static_base_ptr(id), Permission::SharedReadWrite),\n+            _ =>\n+                (Tag::Untagged, Permission::SharedReadWrite),\n         };\n-        let stack = Stacks::new(size, tag, Rc::clone(extra));\n+        let stack = Stacks::new(size, perm, tag, extra);\n         (stack, tag)\n     }\n }"}, {"sha": "4546e8a4d7c9bd795951f9ac22f43865b024a46d", "filename": "tests/compile-fail/modifying_constants.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -1,3 +1,5 @@\n+// This should fail even without validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee"}, {"sha": "0f0467fc5cb994c672002bc84770bb5de65dc587", "filename": "tests/compile-fail/stacked_borrows/unescaped_static.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_static.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -0,0 +1,7 @@\n+static ARRAY: [u8; 2] = [0, 1];\n+\n+fn main() {\n+    let ptr_to_first = &ARRAY[0] as *const u8;\n+    // Illegally use this to access the 2nd element.\n+    let _val = unsafe { *ptr_to_first.add(1) }; //~ ERROR borrow stack\n+}"}, {"sha": "00ca2aa41dd35448c1675f706f9aa3194b4d0604", "filename": "tests/run-pass/ints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Frun-pass%2Fints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Frun-pass%2Fints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fints.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -34,11 +34,11 @@ fn match_int() -> i16 {\n fn match_int_range() -> i64 {\n     let n = 42;\n     match n {\n-        0...9 => 0,\n-        10...19 => 1,\n-        20...29 => 2,\n-        30...39 => 3,\n-        40...49 => 4,\n+        0..=9 => 0,\n+        10..=19 => 1,\n+        20..=29 => 2,\n+        30..=39 => 3,\n+        40..=42 => 4,\n         _ => 5,\n     }\n }"}, {"sha": "8de45811be4438abff760599520c8f232f6f38b2", "filename": "tests/run-pass/thread-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Frun-pass%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b74c12c86ae9756ec8e61feef484edb5d5e013/tests%2Frun-pass%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local.rs?ref=03b74c12c86ae9756ec8e61feef484edb5d5e013", "patch": "@@ -56,7 +56,7 @@ fn main() {\n         create(None); // check that the no-dtor case works\n \n         // Initialize the keys we use to check destructor ordering\n-        for (key, global) in KEYS.iter_mut().zip(GLOBALS.iter()) {\n+        for (key, global) in KEYS.iter_mut().zip(GLOBALS.iter_mut()) {\n             *key = create(Some(mem::transmute(dtor as unsafe extern fn(*mut u64))));\n             set(*key, global as *const _ as *mut _);\n         }"}]}