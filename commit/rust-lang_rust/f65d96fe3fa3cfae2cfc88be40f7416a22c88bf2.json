{"sha": "f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NWQ5NmZlM2ZhM2NmYWUyY2ZjODhiZTQwZjc0MTZhMjJjODhiZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-15T15:35:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-15T15:35:18Z"}, "message": "Auto merge of #35340 - michaelwoerister:incr-comp-cli-args, r=nikomatsakis\n\nTake commandline arguments into account for incr. comp.\n\nImplements the conservative strategy described in https://github.com/rust-lang/rust/issues/33727.\n\nFrom now one, every time a new commandline option is added, one has to specify if it influences the incremental compilation cache. I've tried to implement this as automatic as possible: One just has to added either the `[TRACKED]` or the `[UNTRACKED]` marker next to the field. The `Options`, `CodegenOptions`, and `DebuggingOptions` definitions in `session::config` show plenty of examples.\n\nThe PR removes some cruft from `session::config::Options`, mostly unnecessary copies of flags also present in `DebuggingOptions` or `CodeGenOptions` in the same struct.\n\nOne notable removal is the `cfg` field that contained the values passed via `--cfg` commandline arguments. I chose to remove it because (1) its content is only a subset of what later is stored in `hir::Crate::config` and it's pretty likely that reading the cfgs from `Options` would not be what you wanted, and (2) we could not incorporate it into the dep-tracking hash of the `Options` struct because of how the test framework works, leaving us with a piece of untracked but vital data.\n\nIt is now recommended (just as before) to access the crate config via the `krate()` method in the HIR map.\n\nBecause the `cfg` field is not present in the `Options` struct any more, some methods in the `CompilerCalls` trait now take the crate config as an explicit parameter -- which might constitute a breaking change for plugin authors.", "tree": {"sha": "85911176229bb3d2f8ec21f4aa41545b0fa5b397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85911176229bb3d2f8ec21f4aa41545b0fa5b397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "html_url": "https://github.com/rust-lang/rust/commit/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b72fa8ca95c02e4b44b216a425fd563ad2ef58bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b72fa8ca95c02e4b44b216a425fd563ad2ef58bb", "html_url": "https://github.com/rust-lang/rust/commit/b72fa8ca95c02e4b44b216a425fd563ad2ef58bb"}, {"sha": "67f19e5e28430773256ee55ab6b315e0130f228f", "url": "https://api.github.com/repos/rust-lang/rust/commits/67f19e5e28430773256ee55ab6b315e0130f228f", "html_url": "https://github.com/rust-lang/rust/commit/67f19e5e28430773256ee55ab6b315e0130f228f"}], "stats": {"total": 1434, "additions": 1186, "deletions": 248}, "files": [{"sha": "f34b14224f7797f0ad798cd4e045e294fdb5104c", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -269,7 +269,7 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }"}, {"sha": "dec6f360847bfb2ac6a4928389f6523b266b9a6d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -73,7 +73,7 @@ pub enum LinkagePreference {\n }\n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq)]\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     pub enum NativeLibraryKind {\n         NativeStatic,    // native static library (.a archive)\n         NativeFramework, // OSX-specific"}, {"sha": "e988ddcd97b1518e34adde4771ca071903db99d6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1026, "deletions": 174, "changes": 1200, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -33,9 +33,15 @@ use syntax::feature_gate::UnstableFeatures;\n use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::btree_map::Iter as BTreeMapIter;\n+use std::collections::btree_map::Keys as BTreeMapKeysIter;\n+use std::collections::btree_map::Values as BTreeMapValuesIter;\n+\n use std::env;\n use std::fmt;\n+use std::hash::{Hasher, SipHasher};\n+use std::iter::FromIterator;\n use std::path::PathBuf;\n \n pub struct Config {\n@@ -44,7 +50,7 @@ pub struct Config {\n     pub uint_type: UintTy,\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Hash)]\n pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n@@ -54,14 +60,15 @@ pub enum OptLevel {\n     SizeMin, // -Oz\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n     LimitedDebugInfo,\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -118,57 +125,173 @@ impl OutputType {\n     }\n }\n \n-#[derive(Clone)]\n-pub struct Options {\n-    // The crate config requested for the session, which may be combined\n-    // with additional crate configurations during the compile process\n-    pub crate_types: Vec<CrateType>,\n-\n-    pub optimize: OptLevel,\n-    pub debug_assertions: bool,\n-    pub debuginfo: DebugInfoLevel,\n-    pub lint_opts: Vec<(String, lint::Level)>,\n-    pub lint_cap: Option<lint::Level>,\n-    pub describe_lints: bool,\n-    pub output_types: HashMap<OutputType, Option<PathBuf>>,\n-    // This was mutable for rustpkg, which updates search paths based on the\n-    // parsed code. It remains mutable in case its replacements wants to use\n-    // this.\n-    pub search_paths: SearchPaths,\n-    pub libs: Vec<(String, cstore::NativeLibraryKind)>,\n-    pub maybe_sysroot: Option<PathBuf>,\n-    pub target_triple: String,\n-    // User-specified cfg meta items. The compiler itself will add additional\n-    // items to the crate config, and during parsing the entire crate config\n-    // will be added to the crate AST node.  This should not be used for\n-    // anything except building the full crate config prior to parsing.\n-    pub cfg: ast::CrateConfig,\n-    pub test: bool,\n-    pub parse_only: bool,\n-    pub no_trans: bool,\n-    pub error_format: ErrorOutputType,\n-    pub treat_err_as_bug: bool,\n-    pub continue_parse_after_error: bool,\n-    pub mir_opt_level: usize,\n-\n-    /// if Some, enable incremental compilation, using the given\n-    /// directory to store intermediate results\n-    pub incremental: Option<PathBuf>,\n-\n-    pub no_analysis: bool,\n-    pub debugging_opts: DebuggingOptions,\n-    pub prints: Vec<PrintRequest>,\n-    pub cg: CodegenOptions,\n-    pub externs: HashMap<String, Vec<String>>,\n-    pub crate_name: Option<String>,\n-    /// An optional name to use as the crate for std during std injection,\n-    /// written `extern crate std = \"name\"`. Default to \"std\". Used by\n-    /// out-of-tree drivers.\n-    pub alt_std_name: Option<String>,\n-    /// Indicates how the compiler should treat unstable features\n-    pub unstable_features: UnstableFeatures\n+// Use tree-based collections to cheaply get a deterministic Hash implementation.\n+// DO NOT switch BTreeMap out for an unsorted container type! That would break\n+// dependency tracking for commandline arguments.\n+#[derive(Clone, Hash)]\n+pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n+\n+impl OutputTypes {\n+    pub fn new(entries: &[(OutputType, Option<PathBuf>)]) -> OutputTypes {\n+        OutputTypes(BTreeMap::from_iter(entries.iter()\n+                                               .map(|&(k, ref v)| (k, v.clone()))))\n+    }\n+\n+    pub fn get(&self, key: &OutputType) -> Option<&Option<PathBuf>> {\n+        self.0.get(key)\n+    }\n+\n+    pub fn contains_key(&self, key: &OutputType) -> bool {\n+        self.0.contains_key(key)\n+    }\n+\n+    pub fn keys<'a>(&'a self) -> BTreeMapKeysIter<'a, OutputType, Option<PathBuf>> {\n+        self.0.keys()\n+    }\n+\n+    pub fn values<'a>(&'a self) -> BTreeMapValuesIter<'a, OutputType, Option<PathBuf>> {\n+        self.0.values()\n+    }\n }\n \n+\n+// Use tree-based collections to cheaply get a deterministic Hash implementation.\n+// DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n+// would break dependency tracking for commandline arguments.\n+#[derive(Clone, Hash)]\n+pub struct Externs(BTreeMap<String, BTreeSet<String>>);\n+\n+impl Externs {\n+    pub fn new(data: BTreeMap<String, BTreeSet<String>>) -> Externs {\n+        Externs(data)\n+    }\n+\n+    pub fn get(&self, key: &str) -> Option<&BTreeSet<String>> {\n+        self.0.get(key)\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> BTreeMapIter<'a, String, BTreeSet<String>> {\n+        self.0.iter()\n+    }\n+}\n+\n+macro_rules! hash_option {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n+        if $sub_hashes.insert(stringify!($opt_name),\n+                              $opt_expr as &dep_tracking::DepTrackingHash).is_some() {\n+            bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+        }\n+    });\n+    ($opt_name:ident,\n+     $opt_expr:expr,\n+     $sub_hashes:expr,\n+     [UNTRACKED_WITH_WARNING $warn_val:expr, $warn_text:expr, $error_format:expr]) => ({\n+        if *$opt_expr == $warn_val {\n+            early_warn($error_format, $warn_text)\n+        }\n+    });\n+}\n+\n+macro_rules! top_level_options {\n+    (pub struct Options { $(\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+    )* } ) => (\n+        #[derive(Clone)]\n+        pub struct Options {\n+            $(pub $opt: $t),*\n+        }\n+\n+        impl Options {\n+            pub fn dep_tracking_hash(&self) -> u64 {\n+                let mut sub_hashes = BTreeMap::new();\n+                $({\n+                    hash_option!($opt,\n+                                 &self.$opt,\n+                                 &mut sub_hashes,\n+                                 [$dep_tracking_marker $($warn_val,\n+                                                         $warn_text,\n+                                                         self.error_format)*]);\n+                })*\n+                let mut hasher =  SipHasher::new();\n+                dep_tracking::stable_hash(sub_hashes,\n+                                          &mut hasher,\n+                                          self.error_format);\n+                hasher.finish()\n+            }\n+        }\n+    );\n+}\n+\n+// The top-level commandline options struct\n+//\n+// For each option, one has to specify how it behaves with regard to the\n+// dependency tracking system of incremental compilation. This is done via the\n+// square-bracketed directive after the field type. The options are:\n+//\n+// [TRACKED]\n+// A change in the given field will cause the compiler to completely clear the\n+// incremental compilation cache before proceeding.\n+//\n+// [UNTRACKED]\n+// Incremental compilation is not influenced by this option.\n+//\n+// [UNTRACKED_WITH_WARNING(val, warning)]\n+// The option is incompatible with incremental compilation in some way. If it\n+// has the value `val`, the string `warning` is emitted as a warning.\n+//\n+// If you add a new option to this struct or one of the sub-structs like\n+// CodegenOptions, think about how it influences incremental compilation. If in\n+// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n+// unnecessary re-compilation.\n+top_level_options!(\n+    pub struct Options {\n+        // The crate config requested for the session, which may be combined\n+        // with additional crate configurations during the compile process\n+        crate_types: Vec<CrateType> [TRACKED],\n+        optimize: OptLevel [TRACKED],\n+        // Include the debug_assertions flag into dependency tracking, since it\n+        // can influence whether overflow checks are done or not.\n+        debug_assertions: bool [TRACKED],\n+        debuginfo: DebugInfoLevel [TRACKED],\n+        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n+        lint_cap: Option<lint::Level> [TRACKED],\n+        describe_lints: bool [UNTRACKED],\n+        output_types: OutputTypes [TRACKED],\n+        // FIXME(mw): We track this for now but it actually doesn't make too\n+        //            much sense: The search path can stay the same while the\n+        //            things discovered there might have changed on disk.\n+        search_paths: SearchPaths [TRACKED],\n+        libs: Vec<(String, cstore::NativeLibraryKind)> [TRACKED],\n+        maybe_sysroot: Option<PathBuf> [TRACKED],\n+\n+        target_triple: String [TRACKED],\n+\n+        test: bool [TRACKED],\n+        error_format: ErrorOutputType [UNTRACKED],\n+        mir_opt_level: usize [TRACKED],\n+\n+        // if Some, enable incremental compilation, using the given\n+        // directory to store intermediate results\n+        incremental: Option<PathBuf> [UNTRACKED],\n+\n+        debugging_opts: DebuggingOptions [TRACKED],\n+        prints: Vec<PrintRequest> [UNTRACKED],\n+        cg: CodegenOptions [TRACKED],\n+        // FIXME(mw): We track this for now but it actually doesn't make too\n+        //            much sense: The value of this option can stay the same\n+        //            while the files they refer to might have changed on disk.\n+        externs: Externs [TRACKED],\n+        crate_name: Option<String> [TRACKED],\n+        // An optional name to use as the crate for std during std injection,\n+        // written `extern crate std = \"name\"`. Default to \"std\". Used by\n+        // out-of-tree drivers.\n+        alt_std_name: Option<String> [TRACKED],\n+        // Indicates how the compiler should treat unstable features\n+        unstable_features: UnstableFeatures [TRACKED],\n+    }\n+);\n+\n #[derive(Clone, PartialEq, Eq)]\n pub enum PrintRequest {\n     FileNames,\n@@ -209,7 +332,7 @@ pub struct OutputFilenames {\n     pub out_filestem: String,\n     pub single_output_file: Option<PathBuf>,\n     pub extra: String,\n-    pub outputs: HashMap<OutputType, Option<PathBuf>>,\n+    pub outputs: OutputTypes,\n }\n \n /// Codegen unit names generated by the numbered naming scheme will contain this\n@@ -301,24 +424,18 @@ pub fn basic_options() -> Options {\n         lint_opts: Vec::new(),\n         lint_cap: None,\n         describe_lints: false,\n-        output_types: HashMap::new(),\n+        output_types: OutputTypes(BTreeMap::new()),\n         search_paths: SearchPaths::new(),\n         maybe_sysroot: None,\n         target_triple: host_triple().to_string(),\n-        cfg: Vec::new(),\n         test: false,\n-        parse_only: false,\n-        no_trans: false,\n-        treat_err_as_bug: false,\n-        continue_parse_after_error: false,\n         mir_opt_level: 1,\n         incremental: None,\n-        no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n         error_format: ErrorOutputType::default(),\n-        externs: HashMap::new(),\n+        externs: Externs(BTreeMap::new()),\n         crate_name: None,\n         alt_std_name: None,\n         libs: Vec::new(),\n@@ -361,7 +478,7 @@ pub enum CrateType {\n     CrateTypeCdylib,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub enum Passes {\n     SomePasses(Vec<String>),\n     AllPasses,\n@@ -376,7 +493,7 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Hash)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,\n@@ -405,7 +522,12 @@ macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n      $stat:ident, $mod_desc:ident, $mod_set:ident,\n-     $($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n+     $($opt:ident : $t:ty = (\n+        $init:expr,\n+        $parse:ident,\n+        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        $desc:expr)\n+     ),* ,) =>\n (\n     #[derive(Clone)]\n     pub struct $struct_name { $(pub $opt: $t),* }\n@@ -457,6 +579,22 @@ macro_rules! options {\n         return op;\n     }\n \n+    impl<'a> dep_tracking::DepTrackingHash for $struct_name {\n+\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            let mut sub_hashes = BTreeMap::new();\n+            $({\n+                hash_option!($opt,\n+                             &self.$opt,\n+                             &mut sub_hashes,\n+                             [$dep_tracking_marker $($dep_warn_val,\n+                                                     $dep_warn_text,\n+                                                     error_format)*]);\n+            })*\n+            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+        }\n+    }\n+\n     pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n     pub const $stat: &'static [(&'static str, $setter_name,\n                                      Option<&'static str>, &'static str)] =\n@@ -622,168 +760,177 @@ macro_rules! options {\n options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          build_codegen_options, \"C\", \"codegen\",\n          CG_OPTIONS, cg_type_desc, cgsetters,\n-    ar: Option<String> = (None, parse_opt_string,\n+    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"tool to assemble archives with\"),\n-    linker: Option<String> = (None, parse_opt_string,\n+    linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n-    link_args: Option<Vec<String>> = (None, parse_opt_list,\n+    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n         \"extra arguments to pass to the linker (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool,\n+    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: bool = (false, parse_bool,\n+    lto: bool = (false, parse_bool, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n-    target_cpu: Option<String> = (None, parse_opt_string,\n+    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (rustc --print target-cpus for details)\"),\n-    target_feature: String = (\"\".to_string(), parse_string,\n+    target_feature: String = (\"\".to_string(), parse_string, [TRACKED],\n         \"target specific attributes (rustc --print target-features for details)\"),\n-    passes: Vec<String> = (Vec::new(), parse_list,\n+    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<String> = (Vec::new(), parse_list,\n+    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of arguments to pass to llvm (space separated)\"),\n-    save_temps: bool = (false, parse_bool,\n+    save_temps: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"`-C save-temps` might not produce all requested temporary products \\\n+         when incremental compilation is enabled.\")],\n         \"save all temporary output files during compilation\"),\n-    rpath: bool = (false, parse_bool,\n+    rpath: bool = (false, parse_bool, [UNTRACKED],\n         \"set rpath values in libs/exes\"),\n-    no_prepopulate_passes: bool = (false, parse_bool,\n+    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n         \"don't pre-populate the pass manager with a list of passes\"),\n-    no_vectorize_loops: bool = (false, parse_bool,\n+    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n         \"don't run the loop vectorization optimization passes\"),\n-    no_vectorize_slp: bool = (false, parse_bool,\n+    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n         \"don't run LLVM's SLP vectorization pass\"),\n-    soft_float: bool = (false, parse_bool,\n+    soft_float: bool = (false, parse_bool, [TRACKED],\n         \"generate software floating point library calls\"),\n-    prefer_dynamic: bool = (false, parse_bool,\n+    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n         \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool,\n+    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    no_redzone: Option<bool> = (None, parse_opt_bool,\n+    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"disable the use of the redzone\"),\n-    relocation_model: Option<String> = (None, parse_opt_string,\n+    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the relocation model to use (rustc --print relocation-models for details)\"),\n-    code_model: Option<String> = (None, parse_opt_string,\n+    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the code model to use (rustc --print code-models for details)\"),\n-    metadata: Vec<String> = (Vec::new(), parse_list,\n+    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n          \"metadata to mangle symbol names with\"),\n-    extra_filename: String = (\"\".to_string(), parse_string,\n+    extra_filename: String = (\"\".to_string(), parse_string, [UNTRACKED],\n          \"extra data to put in each output filename\"),\n-    codegen_units: usize = (1, parse_uint,\n+    codegen_units: usize = (1, parse_uint, [UNTRACKED],\n         \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (SomePasses(Vec::new()), parse_passes,\n+    remark: Passes = (SomePasses(Vec::new()), parse_passes, [UNTRACKED],\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n-    no_stack_check: bool = (false, parse_bool,\n+    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n         \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n-    debuginfo: Option<usize> = (None, parse_opt_uint,\n+    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),\n-    opt_level: Option<String> = (None, parse_opt_string,\n+    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"optimize with possible levels 0-3, s, or z\"),\n-    debug_assertions: Option<bool> = (None, parse_opt_bool,\n+    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n-    inline_threshold: Option<usize> = (None, parse_opt_uint,\n+    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"set the inlining threshold for\"),\n     panic: PanicStrategy = (PanicStrategy::Unwind, parse_panic_strategy,\n-        \"panic strategy to compile crate with\"),\n+        [TRACKED], \"panic strategy to compile crate with\"),\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          build_debugging_options, \"Z\", \"debugging\",\n          DB_OPTIONS, db_type_desc, dbsetters,\n-    verbose: bool = (false, parse_bool,\n+    verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts\"),\n-    time_passes: bool = (false, parse_bool,\n+    time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,\n+        [UNTRACKED_WITH_WARNING(true,\n+        \"The output generated by `-Z count_llvm_insns` might not be reliable \\\n+         when used with incremental compilation\")],\n         \"count where LLVM instrs originate\"),\n-    time_llvm_passes: bool = (false, parse_bool,\n+    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n+         re-translated modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n-    input_stats: bool = (false, parse_bool,\n+    input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    trans_stats: bool = (false, parse_bool,\n+    trans_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n+        \"The output of `-Z trans-stats` might not be accurate when incremental \\\n+         compilation is enabled\")],\n         \"gather trans statistics\"),\n-    asm_comments: bool = (false, parse_bool,\n+    asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n-    no_verify: bool = (false, parse_bool,\n+    no_verify: bool = (false, parse_bool, [TRACKED],\n         \"skip LLVM verification\"),\n-    borrowck_stats: bool = (false, parse_bool,\n+    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather borrowck statistics\"),\n-    no_landing_pads: bool = (false, parse_bool,\n+    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n         \"omit landing pads for unwinding\"),\n-    debug_llvm: bool = (false, parse_bool,\n+    debug_llvm: bool = (false, parse_bool, [UNTRACKED],\n         \"enable debug output from LLVM\"),\n-    meta_stats: bool = (false, parse_bool,\n+    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather metadata statistics\"),\n-    print_link_args: bool = (false, parse_bool,\n+    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n         \"print the arguments passed to the linker\"),\n-    print_llvm_passes: bool = (false, parse_bool,\n+    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"prints the llvm optimization passes being run\"),\n-    ast_json: bool = (false, parse_bool,\n+    ast_json: bool = (false, parse_bool, [UNTRACKED],\n         \"print the AST as JSON and halt\"),\n-    ast_json_noexpand: bool = (false, parse_bool,\n+    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n         \"print the pre-expansion AST as JSON and halt\"),\n-    ls: bool = (false, parse_bool,\n+    ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate\"),\n-    save_analysis: bool = (false, parse_bool,\n+    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information in addition to normal output\"),\n-    save_analysis_csv: bool = (false, parse_bool,\n+    save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in CSV format) information in addition to normal output\"),\n-    print_move_fragments: bool = (false, parse_bool,\n+    print_move_fragments: bool = (false, parse_bool, [UNTRACKED],\n         \"print out move-fragment data for every fn\"),\n-    flowgraph_print_loans: bool = (false, parse_bool,\n+    flowgraph_print_loans: bool = (false, parse_bool, [UNTRACKED],\n         \"include loan analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_moves: bool = (false, parse_bool,\n+    flowgraph_print_moves: bool = (false, parse_bool, [UNTRACKED],\n         \"include move analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_assigns: bool = (false, parse_bool,\n+    flowgraph_print_assigns: bool = (false, parse_bool, [UNTRACKED],\n         \"include assignment analysis data in --unpretty flowgraph output\"),\n-    flowgraph_print_all: bool = (false, parse_bool,\n+    flowgraph_print_all: bool = (false, parse_bool, [UNTRACKED],\n         \"include all dataflow analysis data in --unpretty flowgraph output\"),\n-    print_region_graph: bool = (false, parse_bool,\n+    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n          \"prints region inference graph. \\\n           Use with RUST_REGION_GRAPH=help for more info\"),\n-    parse_only: bool = (false, parse_bool,\n+    parse_only: bool = (false, parse_bool, [UNTRACKED],\n           \"parse only; do not compile, assemble, or link\"),\n-    no_trans: bool = (false, parse_bool,\n+    no_trans: bool = (false, parse_bool, [TRACKED],\n           \"run all passes except translation; no output\"),\n-    treat_err_as_bug: bool = (false, parse_bool,\n+    treat_err_as_bug: bool = (false, parse_bool, [TRACKED],\n           \"treat all errors that occur as bugs\"),\n-    continue_parse_after_error: bool = (false, parse_bool,\n+    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n           \"attempt to recover from parse errors (experimental)\"),\n-    incremental: Option<String> = (None, parse_opt_string,\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_info: bool = (false, parse_bool,\n+    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n-    dump_dep_graph: bool = (false, parse_bool,\n+    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n-    query_dep_graph: bool = (false, parse_bool,\n+    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n-    no_analysis: bool = (false, parse_bool,\n+    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n-    extra_plugins: Vec<String> = (Vec::new(), parse_list,\n+    extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"load extra plugins\"),\n-    unstable_options: bool = (false, parse_bool,\n+    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n           \"adds unstable command line options to rustc interface\"),\n-    force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n+    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force overflow checks on or off\"),\n-    force_dropflag_checks: Option<bool> = (None, parse_opt_bool,\n+    force_dropflag_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force drop flag checks on or off\"),\n-    trace_macros: bool = (false, parse_bool,\n+    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n-    enable_nonzeroing_move_hints: bool = (false, parse_bool,\n+    enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n           \"force nonzeroing move optimization on\"),\n-    keep_hygiene_data: bool = (false, parse_bool,\n+    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n           \"don't clear the hygiene data after analysis\"),\n-    keep_ast: bool = (false, parse_bool,\n+    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n           \"keep the AST after lowering it to HIR\"),\n-    show_span: Option<String> = (None, parse_opt_string,\n+    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n-    print_trans_items: Option<String> = (None, parse_opt_string,\n+    print_trans_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"print the result of the translation item collection pass\"),\n-    mir_opt_level: Option<usize> = (None, parse_opt_uint,\n+    mir_opt_level: Option<usize> = (None, parse_opt_uint, [TRACKED],\n           \"set the MIR optimization level (0-3)\"),\n-    dump_mir: Option<String> = (None, parse_opt_string,\n+    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n-    dump_mir_dir: Option<String> = (None, parse_opt_string,\n+    dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n-    orbit: bool = (true, parse_all_bool,\n+    orbit: bool = (true, parse_all_bool, [UNTRACKED],\n           \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n \n@@ -849,11 +996,12 @@ pub fn append_configuration(cfg: &mut ast::CrateConfig,\n     }\n }\n \n-pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n+pub fn build_configuration(sess: &Session,\n+                           mut user_cfg: ast::CrateConfig)\n+                           -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n-    let mut user_cfg = sess.opts.cfg.clone();\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n@@ -1115,7 +1263,8 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     }).collect::<ast::CrateConfig>()\n }\n \n-pub fn build_session_options(matches: &getopts::Matches) -> Options {\n+pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n+                                              -> (Options, ast::CrateConfig) {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\")   => ColorConfig::Auto,\n         Some(\"always\") => ColorConfig::Always,\n@@ -1185,14 +1334,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         debugging_opts.orbit = true;\n     }\n \n-    let parse_only = debugging_opts.parse_only;\n-    let no_trans = debugging_opts.no_trans;\n-    let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n-    let continue_parse_after_error = debugging_opts.continue_parse_after_error;\n     let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n-    let no_analysis = debugging_opts.no_analysis;\n \n-    let mut output_types = HashMap::new();\n+    let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n             for output_type in list.split(',') {\n@@ -1360,7 +1504,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                                 --debuginfo\");\n     }\n \n-    let mut externs = HashMap::new();\n+    let mut externs = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n@@ -1372,44 +1516,41 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(error_format, \"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        externs.entry(name.to_string()).or_insert(vec![]).push(location.to_string());\n+        externs.entry(name.to_string())\n+               .or_insert_with(BTreeSet::new)\n+               .insert(location.to_string());\n     }\n \n     let crate_name = matches.opt_str(\"crate-name\");\n \n     let incremental = debugging_opts.incremental.as_ref().map(|m| PathBuf::from(m));\n \n-    Options {\n+    (Options {\n         crate_types: crate_types,\n         optimize: opt_level,\n         debuginfo: debuginfo,\n         lint_opts: lint_opts,\n         lint_cap: lint_cap,\n         describe_lints: describe_lints,\n-        output_types: output_types,\n+        output_types: OutputTypes(output_types),\n         search_paths: search_paths,\n         maybe_sysroot: sysroot_opt,\n         target_triple: target,\n-        cfg: cfg,\n         test: test,\n-        parse_only: parse_only,\n-        no_trans: no_trans,\n-        treat_err_as_bug: treat_err_as_bug,\n-        continue_parse_after_error: continue_parse_after_error,\n         mir_opt_level: mir_opt_level,\n         incremental: incremental,\n-        no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         prints: prints,\n         cg: cg,\n         error_format: error_format,\n-        externs: externs,\n+        externs: Externs(externs),\n         crate_name: crate_name,\n         alt_std_name: None,\n         libs: libs,\n         unstable_features: get_unstable_features_setting(),\n         debug_assertions: debug_assertions,\n-    }\n+    },\n+    cfg)\n }\n \n pub fn get_unstable_features_setting() -> UnstableFeatures {\n@@ -1530,15 +1671,139 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+/// Commandline arguments passed to the compiler have to be incorporated with\n+/// the dependency tracking system for incremental compilation. This module\n+/// provides some utilities to make this more convenient.\n+///\n+/// The values of all commandline arguments that are relevant for dependency\n+/// tracking are hashed into a single value that determines whether the\n+/// incremental compilation cache can be re-used or not. This hashing is done\n+/// via the DepTrackingHash trait defined below, since the standard Hash\n+/// implementation might not be suitable (e.g. arguments are stored in a Vec,\n+/// the hash of which is order dependent, but we might not want the order of\n+/// arguments to make a difference for the hash).\n+///\n+/// However, since the value provided by Hash::hash often *is* suitable,\n+/// especially for primitive types, there is the\n+/// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n+/// Hash implementation for DepTrackingHash. It's important though that\n+/// we have an opt-in scheme here, so one is hopefully forced to think about\n+/// how the hash should be calculated when adding a new commandline argument.\n+mod dep_tracking {\n+    use lint;\n+    use middle::cstore;\n+    use session::search_paths::{PathKind, SearchPaths};\n+    use std::collections::BTreeMap;\n+    use std::hash::{Hash, SipHasher};\n+    use std::path::PathBuf;\n+    use super::{Passes, PanicStrategy, CrateType, OptLevel, DebugInfoLevel,\n+                OutputTypes, Externs, ErrorOutputType};\n+    use syntax::feature_gate::UnstableFeatures;\n+\n+    pub trait DepTrackingHash {\n+        fn hash(&self, &mut SipHasher, ErrorOutputType);\n+    }\n+\n+    macro_rules! impl_dep_tracking_hash_via_hash {\n+        ($t:ty) => (\n+            impl DepTrackingHash for $t {\n+                fn hash(&self, hasher: &mut SipHasher, _: ErrorOutputType) {\n+                    Hash::hash(self, hasher);\n+                }\n+            }\n+        )\n+    }\n+\n+    macro_rules! impl_dep_tracking_hash_for_sortable_vec_of {\n+        ($t:ty) => (\n+            impl DepTrackingHash for Vec<$t> {\n+                fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+                    let mut elems: Vec<&$t> = self.iter().collect();\n+                    elems.sort();\n+                    Hash::hash(&elems.len(), hasher);\n+                    for (index, elem) in elems.iter().enumerate() {\n+                        Hash::hash(&index, hasher);\n+                        DepTrackingHash::hash(*elem, hasher, error_format);\n+                    }\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_dep_tracking_hash_via_hash!(bool);\n+    impl_dep_tracking_hash_via_hash!(usize);\n+    impl_dep_tracking_hash_via_hash!(String);\n+    impl_dep_tracking_hash_via_hash!(lint::Level);\n+    impl_dep_tracking_hash_via_hash!(Option<bool>);\n+    impl_dep_tracking_hash_via_hash!(Option<usize>);\n+    impl_dep_tracking_hash_via_hash!(Option<String>);\n+    impl_dep_tracking_hash_via_hash!(Option<lint::Level>);\n+    impl_dep_tracking_hash_via_hash!(Option<PathBuf>);\n+    impl_dep_tracking_hash_via_hash!(CrateType);\n+    impl_dep_tracking_hash_via_hash!(PanicStrategy);\n+    impl_dep_tracking_hash_via_hash!(Passes);\n+    impl_dep_tracking_hash_via_hash!(OptLevel);\n+    impl_dep_tracking_hash_via_hash!(DebugInfoLevel);\n+    impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n+    impl_dep_tracking_hash_via_hash!(Externs);\n+    impl_dep_tracking_hash_via_hash!(OutputTypes);\n+    impl_dep_tracking_hash_via_hash!(cstore::NativeLibraryKind);\n+\n+    impl_dep_tracking_hash_for_sortable_vec_of!(String);\n+    impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n+    impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n+    impl_dep_tracking_hash_for_sortable_vec_of!((String, cstore::NativeLibraryKind));\n+\n+    impl DepTrackingHash for SearchPaths {\n+        fn hash(&self, hasher: &mut SipHasher, _: ErrorOutputType) {\n+            let mut elems: Vec<_> = self\n+                .iter(PathKind::All)\n+                .collect();\n+            elems.sort();\n+            Hash::hash(&elems, hasher);\n+        }\n+    }\n+\n+    impl<T1, T2> DepTrackingHash for (T1, T2)\n+        where T1: DepTrackingHash,\n+              T2: DepTrackingHash\n+    {\n+        fn hash(&self, hasher: &mut SipHasher, error_format: ErrorOutputType) {\n+            Hash::hash(&0, hasher);\n+            DepTrackingHash::hash(&self.0, hasher, error_format);\n+            Hash::hash(&1, hasher);\n+            DepTrackingHash::hash(&self.1, hasher, error_format);\n+        }\n+    }\n+\n+    // This is a stable hash because BTreeMap is a sorted container\n+    pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &DepTrackingHash>,\n+                       hasher: &mut SipHasher,\n+                       error_format: ErrorOutputType) {\n+        for (key, sub_hash) in sub_hashes {\n+            // Using Hash::hash() instead of DepTrackingHash::hash() is fine for\n+            // the keys, as they are just plain strings\n+            Hash::hash(&key.len(), hasher);\n+            Hash::hash(key, hasher);\n+            sub_hash.hash(hasher, error_format);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use dep_graph::DepGraph;\n-    use middle::cstore::DummyCrateStore;\n-    use session::config::{build_configuration, build_session_options};\n-    use session::build_session;\n     use errors;\n-    use std::rc::Rc;\n     use getopts::{getopts, OptGroup};\n+    use lint;\n+    use middle::cstore::{self, DummyCrateStore};\n+    use session::config::{build_configuration, build_session_options_and_crate_config};\n+    use session::build_session;\n+    use std::collections::{BTreeMap, BTreeSet};\n+    use std::iter::FromIterator;\n+    use std::path::PathBuf;\n+    use std::rc::Rc;\n+    use super::{OutputType, OutputTypes, Externs, PanicStrategy};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n \n@@ -1548,6 +1813,14 @@ mod tests {\n                                 .collect()\n     }\n \n+    fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n+        BTreeMap::from_iter(entries.into_iter())\n+    }\n+\n+    fn mk_set<V: Ord>(entries: Vec<V>) -> BTreeSet<V> {\n+        BTreeSet::from_iter(entries.into_iter())\n+    }\n+\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n@@ -1558,9 +1831,9 @@ mod tests {\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = errors::registry::Registry::new(&[]);\n-        let sessopts = build_session_options(matches);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n-        let cfg = build_configuration(&sess);\n+        let cfg = build_configuration(&sess, cfg);\n         assert!((attr::contains_name(&cfg[..], \"test\")));\n     }\n \n@@ -1578,10 +1851,10 @@ mod tests {\n               }\n             };\n         let registry = errors::registry::Registry::new(&[]);\n-        let sessopts = build_session_options(matches);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n-        let cfg = build_configuration(&sess);\n+        let cfg = build_configuration(&sess, cfg);\n         let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n@@ -1595,7 +1868,7 @@ mod tests {\n                 \"-Awarnings\".to_string()\n             ], &optgroups()).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n-            let sessopts = build_session_options(&matches);\n+            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(!sess.diagnostic().can_emit_warnings);\n@@ -1607,7 +1880,7 @@ mod tests {\n                 \"-Dwarnings\".to_string()\n             ], &optgroups()).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n-            let sessopts = build_session_options(&matches);\n+            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(sess.diagnostic().can_emit_warnings);\n@@ -1618,10 +1891,589 @@ mod tests {\n                 \"-Adead_code\".to_string()\n             ], &optgroups()).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n-            let sessopts = build_session_options(&matches);\n+            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }\n+\n+    #[test]\n+    fn test_output_types_tracking_hash_different_paths() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.output_types = OutputTypes::new(&[(OutputType::Exe,\n+                                              Some(PathBuf::from(\"./some/thing\")))]);\n+        v2.output_types = OutputTypes::new(&[(OutputType::Exe,\n+                                              Some(PathBuf::from(\"/some/thing\")))]);\n+        v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_output_types_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+\n+        v1.output_types = OutputTypes::new(&[\n+            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+        ]);\n+\n+        v2.output_types = OutputTypes::new(&[\n+            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+        ]);\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_externs_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v2.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"X\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v3.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"X\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_externs_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+        ]));\n+\n+        v2.externs = Externs::new(mk_map(vec![\n+            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n+                                            String::from(\"f\")])),\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+        ]));\n+\n+        v3.externs = Externs::new(mk_map(vec![\n+            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n+                                            String::from(\"c\")])),\n+            (String::from(\"d\"), mk_set(vec![String::from(\"f\"),\n+                                            String::from(\"e\")])),\n+        ]));\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+        assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_lints_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"X\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v3.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Forbid),\n+                            (String::from(\"d\"), lint::Deny)];\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_lints_tracking_hash_different_construction_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+\n+        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n+                            (String::from(\"c\"), lint::Deny),\n+                            (String::from(\"b\"), lint::Warn),\n+                            (String::from(\"d\"), lint::Forbid)];\n+\n+        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_search_paths_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n+        let mut v5 = super::basic_options();\n+\n+        // Reference\n+        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Native changed\n+        v2.search_paths.add_path(\"native=XXX\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Crate changed\n+        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=XXX\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Dependency changed\n+        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"dependency=XXX\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // Framework changed\n+        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"framework=XXX\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        // All changed\n+        v5.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v5.search_paths.add_path(\"all=XXX\", super::ErrorOutputType::Json);\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v5.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+        assert_eq!(v5.dep_tracking_hash(), v5.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_search_paths_tracking_hash_different_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n+\n+        // Reference\n+        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+\n+        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json);\n+        v4.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json);\n+\n+        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_native_libs_tracking_hash_different_values() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        // Reference\n+        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        // Change label\n+        v2.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"X\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        // Change kind\n+        v3.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeStatic),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_native_libs_tracking_hash_different_order() {\n+        let mut v1 = super::basic_options();\n+        let mut v2 = super::basic_options();\n+        let mut v3 = super::basic_options();\n+\n+        // Reference\n+        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        v2.libs = vec![(String::from(\"b\"), cstore::NativeFramework),\n+                       (String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"c\"), cstore::NativeUnknown)];\n+\n+        v3.libs = vec![(String::from(\"c\"), cstore::NativeUnknown),\n+                       (String::from(\"a\"), cstore::NativeStatic),\n+                       (String::from(\"b\"), cstore::NativeFramework)];\n+\n+        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+        assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n+\n+        // Check clone\n+        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_codegen_options_tracking_hash() {\n+        let reference = super::basic_options();\n+        let mut opts = super::basic_options();\n+\n+        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+        opts.cg.ar = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.linker = Some(String::from(\"linker\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.link_dead_code = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.rpath = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.extra_filename = String::from(\"extra-filename\");\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.codegen_units = 42;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.remark = super::SomePasses(vec![String::from(\"pass1\"),\n+                                                String::from(\"pass2\")]);\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts.cg.save_temps = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+\n+        // Make sure changing a [TRACKED] option changes the hash\n+        opts = reference.clone();\n+        opts.cg.lto = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.target_cpu = Some(String::from(\"abc\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.target_feature = String::from(\"all the features, all of them\");\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_prepopulate_passes = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_vectorize_loops = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_vectorize_slp = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.soft_float = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.prefer_dynamic = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_integrated_as = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.no_redzone = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.code_model = Some(String::from(\"code model\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debuginfo = Some(0xdeadbeef);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debuginfo = Some(0xba5eba11);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.debug_assertions = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.inline_threshold = Some(0xf007ba11);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.panic = PanicStrategy::Abort;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+    }\n+\n+    #[test]\n+    fn test_debugging_options_tracking_hash() {\n+        let reference = super::basic_options();\n+        let mut opts = super::basic_options();\n+\n+        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+        opts.debugging_opts.verbose = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.time_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.count_llvm_insns = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.time_llvm_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.input_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.trans_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.borrowck_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.debug_llvm = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.meta_stats = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_link_args = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_llvm_passes = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ast_json = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ast_json_noexpand = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.ls = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis_csv = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_move_fragments = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_loans = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_moves = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_assigns = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.flowgraph_print_all = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_region_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.parse_only = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_dep_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.query_dep_graph = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.no_analysis = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.unstable_options = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.trace_macros = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.keep_hygiene_data = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.keep_ast = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.print_trans_items = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.dump_mir_dir = Some(String::from(\"abc\"));\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.orbit = false;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        // Make sure changing a [TRACKED] option changes the hash\n+        opts = reference.clone();\n+        opts.debugging_opts.asm_comments = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_verify = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_landing_pads = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.no_trans = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.treat_err_as_bug = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.continue_parse_after_error = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.force_overflow_checks = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.force_dropflag_checks = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.enable_nonzeroing_move_hints = true;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.mir_opt_level = Some(1);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+    }\n }"}, {"sha": "c71253aee568f9a1e0cd8dcc905557cd7fa7bb20", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -363,7 +363,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);\n-    let treat_err_as_bug = sopts.treat_err_as_bug;\n+    let treat_err_as_bug = sopts.debugging_opts.treat_err_as_bug;\n \n     let emitter: Box<Emitter> = match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(color_config) => {"}, {"sha": "5bbc6841693ea3628c75c8ebf35988b046485ac1", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -22,7 +22,7 @@ pub struct Iter<'a> {\n     iter: slice::Iter<'a, (PathKind, PathBuf)>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "c6100004786bef8b97f9018cf30d7cddbd71cd49", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -15,7 +15,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc_mir as mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n+                             OutputTypes};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n@@ -42,7 +43,6 @@ use super::Compilation;\n \n use serialize::json;\n \n-use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n@@ -478,7 +478,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                cfg: ast::CrateConfig,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n-    let continue_after_error = sess.opts.continue_parse_after_error;\n+    let continue_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n     let krate = time(sess.time_passes(), \"parsing\", || {\n@@ -667,7 +667,10 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n         };\n-        let mut loader = macro_import::MacroLoader::new(sess, &cstore, crate_name);\n+        let mut loader = macro_import::MacroLoader::new(sess,\n+                                                        &cstore,\n+                                                        crate_name,\n+                                                        krate.config.clone());\n         let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n                                                       krate.config.clone(),\n                                                       cfg,\n@@ -1024,11 +1027,10 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n-        let mut map = HashMap::new();\n-        map.insert(OutputType::Assembly, None);\n+        let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || write::run_passes(sess, trans, &map, outputs));\n+             || write::run_passes(sess, trans, &output_types, outputs));\n \n         write::run_assembler(sess, outputs);\n "}, {"sha": "6f57ae2941838d8185afde07b900a4b2aa635a5c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -181,7 +181,7 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n         None => return (Ok(()), None),\n     };\n \n-    let sopts = config::build_session_options(&matches);\n+    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n         unsafe { llvm::LLVMRustSetDebug(1); }\n@@ -191,14 +191,15 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n \n     do_or_return!(callbacks.early_callback(&matches,\n                                            &sopts,\n+                                           &cfg,\n                                            &descriptions,\n                                            sopts.error_format),\n                                            None);\n \n     let (odir, ofile) = make_output(&matches);\n     let (input, input_file_path) = match make_input(&matches.free) {\n         Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n-        None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n+        None => match callbacks.no_input(&matches, &sopts, &cfg, &odir, &ofile, &descriptions) {\n             Some((input, input_file_path)) => (input, input_file_path),\n             None => return (Ok(()), None),\n         },\n@@ -214,10 +215,11 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n                                                    cstore.clone(),\n                                                    codemap);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    let mut cfg = config::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess, cfg);\n     target_features::add_configuration(&mut cfg, &sess);\n \n-    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n+    do_or_return!(callbacks.late_callback(&matches, &sess, &cfg, &input, &odir, &ofile),\n+                  Some(sess));\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess, &matches);\n@@ -297,6 +299,7 @@ pub trait CompilerCalls<'a> {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &config::Options,\n+                      _: &ast::CrateConfig,\n                       _: &errors::registry::Registry,\n                       _: ErrorOutputType)\n                       -> Compilation {\n@@ -309,6 +312,7 @@ pub trait CompilerCalls<'a> {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n+                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)\n@@ -334,6 +338,7 @@ pub trait CompilerCalls<'a> {\n     fn no_input(&mut self,\n                 _: &getopts::Matches,\n                 _: &config::Options,\n+                _: &ast::CrateConfig,\n                 _: &Option<PathBuf>,\n                 _: &Option<PathBuf>,\n                 _: &errors::registry::Registry)\n@@ -375,7 +380,7 @@ fn handle_explain(code: &str,\n     }\n }\n \n-fn check_cfg(sopts: &config::Options,\n+fn check_cfg(cfg: &ast::CrateConfig,\n              output: ErrorOutputType) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n@@ -386,7 +391,7 @@ fn check_cfg(sopts: &config::Options,\n     let handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let mut saw_invalid_predicate = false;\n-    for item in sopts.cfg.iter() {\n+    for item in cfg.iter() {\n         if item.is_meta_item_list() {\n             saw_invalid_predicate = true;\n             handler.emit(&MultiSpan::new(),\n@@ -404,7 +409,8 @@ fn check_cfg(sopts: &config::Options,\n impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n-                      sopts: &config::Options,\n+                      _: &config::Options,\n+                      cfg: &ast::CrateConfig,\n                       descriptions: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n@@ -413,13 +419,14 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        check_cfg(sopts, output);\n+        check_cfg(cfg, output);\n         Compilation::Continue\n     }\n \n     fn no_input(&mut self,\n                 matches: &getopts::Matches,\n                 sopts: &config::Options,\n+                cfg: &ast::CrateConfig,\n                 odir: &Option<PathBuf>,\n                 ofile: &Option<PathBuf>,\n                 descriptions: &errors::registry::Registry)\n@@ -440,7 +447,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     descriptions.clone(),\n                     cstore.clone());\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-                let should_stop = RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n+                let mut cfg = config::build_configuration(&sess, cfg.clone());\n+                target_features::add_configuration(&mut cfg, &sess);\n+                let should_stop = RustcDefaultCalls::print_crate_info(&sess,\n+                                                                      &cfg,\n+                                                                      None,\n+                                                                      odir,\n+                                                                      ofile);\n                 if should_stop == Compilation::Stop {\n                     return None;\n                 }\n@@ -456,11 +469,12 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n+                     cfg: &ast::CrateConfig,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n+        RustcDefaultCalls::print_crate_info(sess, cfg, Some(input), odir, ofile)\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n@@ -506,12 +520,14 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return control;\n         }\n \n-        if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||\n+        if sess.opts.debugging_opts.parse_only ||\n+           sess.opts.debugging_opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n         }\n \n-        if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n+        if sess.opts.debugging_opts.no_analysis ||\n+           sess.opts.debugging_opts.ast_json {\n             control.after_hir_lowering.stop = Compilation::Stop;\n         }\n \n@@ -577,6 +593,7 @@ impl RustcDefaultCalls {\n \n \n     fn print_crate_info(sess: &Session,\n+                        cfg: &ast::CrateConfig,\n                         input: Option<&Input>,\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n@@ -629,9 +646,6 @@ impl RustcDefaultCalls {\n                     }\n                 }\n                 PrintRequest::Cfg => {\n-                    let mut cfg = config::build_configuration(&sess);\n-                    target_features::add_configuration(&mut cfg, &sess);\n-\n                     let allow_unstable_cfg = match get_unstable_features_setting() {\n                         UnstableFeatures::Disallow => false,\n                         _ => true,"}, {"sha": "89a79d1a487e0f8106d99270c5bec649f9bc6c61", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -158,6 +158,10 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n         }\n     }\n \n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n     pub fn add(&mut self, def_id: DefId) -> DefPathIndex {\n         debug!(\"DefIdDirectoryBuilder: def_id={:?}\", def_id);\n         let tcx = self.tcx;"}, {"sha": "c736437df1a9e8b178f36e574bc98e425c128eb8", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -101,8 +101,25 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   work_products_data: &[u8])\n                                   -> Result<(), Error>\n {\n+    // Decode the list of work_products\n+    let mut work_product_decoder = Decoder::new(work_products_data, 0);\n+    let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n+\n     // Deserialize the directory and dep-graph.\n     let mut dep_graph_decoder = Decoder::new(dep_graph_data, 0);\n+    let prev_commandline_args_hash = try!(u64::decode(&mut dep_graph_decoder));\n+\n+    if prev_commandline_args_hash != tcx.sess.opts.dep_tracking_hash() {\n+        // We can't reuse the cache, purge it.\n+        debug!(\"decode_dep_graph: differing commandline arg hashes\");\n+        for swp in work_products {\n+            delete_dirty_work_product(tcx, swp);\n+        }\n+\n+        // No need to do any further work\n+        return Ok(());\n+    }\n+\n     let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n     let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n@@ -179,8 +196,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n-    let mut work_product_decoder = Decoder::new(work_products_data, 0);\n-    let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n     reconcile_work_products(tcx, work_products, &dirty_target_nodes);\n \n     dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_source_nodes, &retraced);"}, {"sha": "a9523a81fbaf7b9da78a0f11056fde88b61677bb", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -105,6 +105,10 @@ pub fn encode_dep_graph(preds: &Predecessors,\n                         builder: &mut DefIdDirectoryBuilder,\n                         encoder: &mut Encoder)\n                         -> io::Result<()> {\n+    // First encode the commandline arguments hash\n+    let tcx = builder.tcx();\n+    try!(tcx.sess.opts.dep_tracking_hash().encode(encoder));\n+\n     // Create a flat list of (Input, WorkProduct) edges for\n     // serialization.\n     let mut edges = vec![];"}, {"sha": "4a656b180f259edc3bd05a49dd4e36f304e71327", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -56,6 +56,7 @@ pub struct CrateReader<'a> {\n     next_crate_num: ast::CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n+    local_crate_config: ast::CrateConfig,\n }\n \n impl<'a> visit::Visitor for LocalCrateReader<'a> {\n@@ -152,13 +153,16 @@ enum LoadResult {\n impl<'a> CrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n-               local_crate_name: &str) -> CrateReader<'a> {\n+               local_crate_name: &str,\n+               local_crate_config: ast::CrateConfig)\n+               -> CrateReader<'a> {\n         CrateReader {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FnvHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n+            local_crate_config: local_crate_config,\n         }\n     }\n \n@@ -561,7 +565,7 @@ impl<'a> CrateReader<'a> {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0.\n                 let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                              self.sess.opts.cfg.clone(),\n+                                                              self.local_crate_config.clone(),\n                                                               source_name.clone(),\n                                                               body);\n                 let lo = p.span.lo;\n@@ -863,7 +867,7 @@ impl<'a> LocalCrateReader<'a> {\n         LocalCrateReader {\n             sess: sess,\n             cstore: cstore,\n-            creader: CrateReader::new(sess, cstore, local_crate_name),\n+            creader: CrateReader::new(sess, cstore, local_crate_name, krate.config.clone()),\n             krate: krate,\n             definitions: defs,\n         }"}, {"sha": "2345cd9a92aea2792c0cc77cedc90726370fb5c9", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -400,7 +400,7 @@ impl<'a> Context<'a> {\n         if self.hash.is_none() {\n             self.should_match_name = false;\n             if let Some(s) = self.sess.opts.externs.get(self.crate_name) {\n-                return self.find_commandline_library(s);\n+                return self.find_commandline_library(s.iter());\n             }\n             self.should_match_name = true;\n         }\n@@ -661,7 +661,9 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library(&mut self, locs: &[String]) -> Option<Library> {\n+    fn find_commandline_library<'b, LOCS> (&mut self, locs: LOCS) -> Option<Library>\n+        where LOCS: Iterator<Item=&'b String>\n+    {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n@@ -670,7 +672,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| PathBuf::from(l)).filter(|loc| {\n+            let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display()));"}, {"sha": "b2a2dcf90fa4b65fe4f3a1f981ede966b79e702a", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -29,10 +29,14 @@ pub struct MacroLoader<'a> {\n }\n \n impl<'a> MacroLoader<'a> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> MacroLoader<'a> {\n+    pub fn new(sess: &'a Session,\n+               cstore: &'a CStore,\n+               crate_name: &str,\n+               crate_config: ast::CrateConfig)\n+               -> MacroLoader<'a> {\n         MacroLoader {\n             sess: sess,\n-            reader: CrateReader::new(sess, cstore, crate_name),\n+            reader: CrateReader::new(sess, cstore, crate_name, crate_config),\n         }\n     }\n }"}, {"sha": "fb68eae96476f718d3bd19976e80ddb989b3952a", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -49,7 +49,7 @@ pub fn load_plugins(sess: &Session,\n                     krate: &ast::Crate,\n                     crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n+    let mut loader = PluginLoader::new(sess, cstore, crate_name, krate.config.clone());\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -90,10 +90,14 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> PluginLoader<'a> {\n+    fn new(sess: &'a Session,\n+           cstore: &'a CStore,\n+           crate_name: &str,\n+           crate_config: ast::CrateConfig)\n+            -> PluginLoader<'a> {\n         PluginLoader {\n             sess: sess,\n-            reader: CrateReader::new(sess, cstore, crate_name),\n+            reader: CrateReader::new(sess, cstore, crate_name, crate_config),\n             plugins: vec![],\n         }\n     }"}, {"sha": "f17d1a7f1cf31bd04aae8fe593632bef4f97edc0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -190,7 +190,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-trans, as they will error.\n-        if sess.opts.no_trans && crate_type == config::CrateTypeExecutable {\n+        if sess.opts.debugging_opts.no_trans &&\n+           crate_type == config::CrateTypeExecutable {\n             continue;\n         }\n "}, {"sha": "4b9c29d3d7db3a57b4f17063464315143175d6fb", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -11,7 +11,7 @@\n use back::lto;\n use back::link::{get_linker, remove};\n use rustc_incremental::save_trans_partition;\n-use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n+use session::config::{OutputFilenames, OutputTypes, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config::{self, OutputType};\n use llvm;\n@@ -26,7 +26,6 @@ use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n \n-use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -641,7 +640,7 @@ pub fn cleanup_llvm(trans: &CrateTranslation) {\n \n pub fn run_passes(sess: &Session,\n                   trans: &CrateTranslation,\n-                  output_types: &HashMap<OutputType, Option<PathBuf>>,\n+                  output_types: &OutputTypes,\n                   crate_output: &OutputFilenames) {\n     // It's possible that we have `codegen_units > 1` but only one item in\n     // `trans.modules`.  We could theoretically proceed and do LTO in that"}, {"sha": "30618ff37273569ba6251f5780d76ae3dae1ad51", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -2576,7 +2576,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n-    if tcx.sess.opts.no_trans {\n+    if tcx.sess.opts.debugging_opts.no_trans {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n         return CrateTranslation {\n             modules: modules,"}, {"sha": "10736d2c827cdf8f59a207156332bd1a0e81886f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -45,7 +45,6 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type Externs = HashMap<String, Vec<String>>;\n pub type ExternalPaths = HashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n@@ -99,7 +98,7 @@ impl DocAccessLevels for AccessLevels<DefId> {\n \n pub fn run_core(search_paths: SearchPaths,\n                 cfgs: Vec<String>,\n-                externs: Externs,\n+                externs: config::Externs,\n                 input: Input,\n                 triple: Option<String>) -> (clean::Crate, RenderInfo)\n {\n@@ -120,7 +119,6 @@ pub fn run_core(search_paths: SearchPaths,\n         lint_cap: Some(lint::Allow),\n         externs: externs,\n         target_triple: triple.unwrap_or(config::host_triple().to_string()),\n-        cfg: config::parse_cfgspecs(cfgs),\n         // Ensure that rustdoc works even if rustc is feature-staged\n         unstable_features: UnstableFeatures::Allow,\n         ..config::basic_options().clone()\n@@ -139,7 +137,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                        codemap, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n-    let mut cfg = config::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n     target_features::add_configuration(&mut cfg, &sess);\n \n     let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));"}, {"sha": "255e6b1e786dfd38f621eaee0d7d318a6519a45e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -51,7 +51,7 @@ extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n use std::path::PathBuf;\n@@ -60,7 +60,8 @@ use std::sync::mpsc::channel;\n \n use externalfiles::ExternalHtml;\n use rustc::session::search_paths::SearchPaths;\n-use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options};\n+use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options,\n+                             Externs};\n \n #[macro_use]\n pub mod externalfiles;\n@@ -323,7 +324,7 @@ pub fn main_args(args: &[String]) -> isize {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n-                 externs: core::Externs,\n+                 externs: Externs,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n         Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n@@ -335,28 +336,28 @@ fn acquire_input(input: &str,\n }\n \n /// Extracts `--extern CRATE=PATH` arguments from `matches` and\n-/// returns a `HashMap` mapping crate names to their paths or else an\n+/// returns a map mapping crate names to their paths or else an\n /// error message.\n-fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n-    let mut externs = HashMap::new();\n+fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n+    let mut externs = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n         let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n         let location = parts.next()\n                                  .ok_or(\"--extern value must be of the format `foo=bar`\"\n                                     .to_string())?;\n         let name = name.to_string();\n-        externs.entry(name).or_insert(vec![]).push(location.to_string());\n+        externs.entry(name).or_insert_with(BTreeSet::new).insert(location.to_string());\n     }\n-    Ok(externs)\n+    Ok(Externs::new(externs))\n }\n \n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n+fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");"}, {"sha": "1421a3c78fc5a40a7c4803b2cc21ff73677cc4c4", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -14,10 +14,10 @@ use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use core;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n+use rustc::session::config::Externs;\n \n use externalfiles::ExternalHtml;\n \n@@ -142,7 +142,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n+pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>) -> isize {\n     let input_str = load_or_return!(input, 1, 2);\n "}, {"sha": "7d1dbbe5dc07d9d645656ff7cb35bf1d6165ed23", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -26,7 +26,8 @@ use rustc_lint;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n-use rustc::session::config::{get_unstable_features_setting, OutputType};\n+use rustc::session::config::{get_unstable_features_setting, OutputType,\n+                             OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n@@ -55,7 +56,7 @@ pub struct TestOptions {\n pub fn run(input: &str,\n            cfgs: Vec<String>,\n            libs: SearchPaths,\n-           externs: core::Externs,\n+           externs: Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n            -> isize {\n@@ -89,8 +90,7 @@ pub fn run(input: &str,\n                                        cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n-    let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n+    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n     let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n@@ -172,7 +172,7 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n }\n \n fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n-           externs: core::Externs,\n+           externs: Externs,\n            should_panic: bool, no_run: bool, as_test_harness: bool,\n            compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions) {\n     // the test harness wants its own `main` & top level functions, so\n@@ -182,8 +182,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         name: driver::anon_src(),\n         input: test.to_owned(),\n     };\n-    let mut outputs = HashMap::new();\n-    outputs.insert(OutputType::Exe, None);\n+    let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n     let sessopts = config::Options {\n         maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n@@ -247,8 +246,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n-    let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n+    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n     let out = Some(outdir.lock().unwrap().path().to_path_buf());\n \n     if no_run {\n@@ -396,7 +394,7 @@ pub struct Collector {\n     names: Vec<String>,\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n-    externs: core::Externs,\n+    externs: Externs,\n     cnt: usize,\n     use_headers: bool,\n     current_header: Option<String>,\n@@ -405,7 +403,7 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n+    pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions) -> Collector {\n         Collector {\n             tests: Vec::new(),"}, {"sha": "a6f0e0ca31e3e4fa94dec928990daab430ac29df", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -1194,7 +1194,7 @@ pub fn check_crate(krate: &ast::Crate,\n     visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum UnstableFeatures {\n     /// Hard errors for unstable features are active, as on\n     /// beta/stable channels."}, {"sha": "95187b825be9f2c9d385c9eceb277ba5f33fbd9e", "filename": "src/test/incremental/commandline-args.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcommandline-args.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that changing a tracked commandline argument invalidates\n+// the cache while changing an untracked one doesn't.\n+\n+// revisions:rpass1 rpass2 rpass3\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_translated(module=\"commandline_args\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"commandline_args\", cfg=\"rpass3\")]\n+\n+// Between revisions 1 and 2, we are changing the debuginfo-level, which should\n+// invalidate the cache. Between revisions 2 and 3, we are adding `--verbose`\n+// which should have no effect on the cache:\n+//[rpass1] compile-flags: -C debuginfo=0\n+//[rpass2] compile-flags: -C debuginfo=2\n+//[rpass3] compile-flags: -C debuginfo=2 --verbose\n+\n+pub fn main() {\n+    // empty\n+}"}, {"sha": "35043bdaddf21fcae3dccae36c4283939a494fec", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -19,7 +19,8 @@ extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n use rustc::session::{build_session, Session};\n-use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n+use rustc::session::config::{basic_options, build_configuration, Input,\n+                             OutputType, OutputTypes};\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n@@ -51,7 +52,7 @@ fn main() {\n \n fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     let mut opts = basic_options();\n-    opts.output_types.insert(OutputType::Exe, None);\n+    opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n@@ -64,7 +65,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n-    let cfg = build_configuration(&sess);\n+    let cfg = build_configuration(&sess, vec![]);\n     let control = CompileController::basic();\n \n     compile_input(&sess, &cstore,"}, {"sha": "775ba38004e3a195375194b4a3b48e5993449549", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -24,6 +24,7 @@ extern crate rustc_errors as errors;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n+use syntax::ast;\n \n use std::path::PathBuf;\n \n@@ -35,6 +36,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &config::Options,\n+                      _: &ast::CrateConfig,\n                       _: &errors::registry::Registry,\n                       _: config::ErrorOutputType)\n                       -> Compilation {\n@@ -45,6 +47,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n+                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)\n@@ -62,6 +65,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn no_input(&mut self,\n                 _: &getopts::Matches,\n                 _: &config::Options,\n+                _: &ast::CrateConfig,\n                 _: &Option<PathBuf>,\n                 _: &Option<PathBuf>,\n                 _: &errors::registry::Registry)"}, {"sha": "0d081b267bb7084301f001f4a3f61861b8b7ddf3", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f65d96fe3fa3cfae2cfc88be40f7416a22c88bf2", "patch": "@@ -2008,6 +2008,7 @@ actual:\\n\\\n         // Add an extra flag pointing at the incremental directory.\n         let mut revision_props = self.props.clone();\n         revision_props.incremental_dir = Some(incremental_dir);\n+        revision_props.compile_flags.push(String::from(\"-Zincremental-info\"));\n \n         let revision_cx = TestCx {\n             config: self.config,"}]}