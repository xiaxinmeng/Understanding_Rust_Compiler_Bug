{"sha": "1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlODk4MmJkYjI2MjA4ZDlkOWVkNGNkY2JjZDIxY2M5ZWYzNWJkNDY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-09T13:10:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:54Z"}, "message": "std: replace str::each_split* with an iterator", "tree": {"sha": "54f03a318e14bcdbdb56e01b3c80d00a9db87a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54f03a318e14bcdbdb56e01b3c80d00a9db87a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "html_url": "https://github.com/rust-lang/rust/commit/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff6b298c5f23f48aa993fced41b6e29e446b7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff6b298c5f23f48aa993fced41b6e29e446b7ce", "html_url": "https://github.com/rust-lang/rust/commit/2ff6b298c5f23f48aa993fced41b6e29e446b7ce"}], "stats": {"total": 784, "additions": 269, "deletions": 515}, "files": [{"sha": "782571fc6791ef46a69106886b793168cbb2f8bf", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -141,8 +141,8 @@ fn parse_check_line(line: &str) -> Option<~str> {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs = ~[];\n-        for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n+        let mut strs: ~[~str] = nv.splitn_iter('=', 1).transform(|s| s.to_owned()).collect();\n+\n         match strs.len() {\n           1u => (strs.pop(), ~\"\"),\n           2u => {"}, {"sha": "444f4c8d53908aedc1e0887fc7e928d298cc48e1", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -278,7 +278,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::each_line(ProcRes.stdout) |line| {\n+        for ProcRes.stdout.line_iter().advance |line| {\n             if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -308,7 +308,7 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::each_line(ProcRes.stderr) |line| {\n+    for ProcRes.stderr.line_iter().advance |line| {\n         if str::contains(line, *next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n@@ -358,7 +358,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::each_line(ProcRes.stderr) |line| {\n+    for ProcRes.stderr.line_iter().advance |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n@@ -612,15 +612,11 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n }\n \n fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n-    fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        v.filtered(|s| !str::is_whitespace(*s))\n-    }\n-\n     match *argstr {\n         Some(ref s) => {\n-            let mut ss = ~[];\n-            for str::each_split_char(*s, ' ') |s| { ss.push(s.to_owned()) }\n-            rm_whitespace(ss)\n+            s.split_iter(' ')\n+                .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n+                .collect()\n         }\n         None => ~[]\n     }\n@@ -739,8 +735,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n-    let mut tvec = ~[];\n-    for str::each_split_char(args.prog, '/') |ts| { tvec.push(ts.to_owned()) }\n+    let tvec: ~[~str] = args.prog.split_iter('/').transform(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop();\n \n     // copy to target"}, {"sha": "add857ca9ed07fd0793eaa2410f7608003e7d093", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -416,7 +416,6 @@ mod test {\n \n     use core::iterator::IteratorUtil;\n     use core::io;\n-    use core::str;\n     use core::uint;\n     use core::vec;\n \n@@ -527,9 +526,7 @@ mod test {\n         }\n \n         for input_vec_state(filenames) |line, state| {\n-            let nums = do vec::build |p| {\n-                for str::each_split_char(line, ' ') |s| { p(s.to_owned()); }\n-            };\n+            let nums: ~[&str] = line.split_iter(' ').collect();\n             let file_num = uint::from_str(nums[0]).get();\n             let line_num = uint::from_str(nums[1]).get();\n             assert_eq!(line_num, state.line_num_file);"}, {"sha": "af026473a1bf61f461ff89f06d54f118f67fcbb8", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -82,6 +82,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cmp::Eq;\n use core::result::{Err, Ok};\n use core::result;\n@@ -247,14 +248,13 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2, curlen);\n-                let mut tail_eq = ~[];\n-                for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n+                let tail_eq: ~[&str] = tail.split_iter('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = ~[Long(tail.to_owned())];\n                 } else {\n                     names =\n-                        ~[Long(copy tail_eq[0])];\n-                    i_arg = Some(copy tail_eq[1]);\n+                        ~[Long(tail_eq[0].to_owned())];\n+                    i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n                 let mut j = 1;\n@@ -635,7 +635,7 @@ pub mod groups {\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            for str::each_word(desc) |word| {\n+            for desc.word_iter().advance |word| {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }"}, {"sha": "760fc7485e069684dcf11d824a9d950ccd9f0511", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc;\n use core::comm::{stream, SharedChan};\n use core::ptr;\n@@ -158,9 +159,7 @@ pub mod v4 {\n \n     use core::cast::transmute;\n     use core::result;\n-    use core::str;\n     use core::uint;\n-    use core::vec;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -199,14 +198,12 @@ pub mod v4 {\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let mut parts = ~[];\n-        for str::each_split_char(ip, '.') |s| { parts.push(s.to_owned()) }\n-        let parts = vec::map(parts, |s| {\n-            match uint::from_str(*s) {\n-              Some(n) if n <= 255 => n,\n-              _ => 256\n+        let parts: ~[uint] = ip.split_iter('.').transform(|s| {\n+            match uint::from_str(s) {\n+                Some(n) if n <= 255 => n,\n+                _ => 256\n             }\n-        });\n+        }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n         } else if parts.contains(&256) {"}, {"sha": "f7e86b00d23489e8302009bb116fb84a266aff6b", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -334,7 +334,7 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n-        for str::each_split_char(rawquery, '&') |p| {\n+        for rawquery.split_iter('&').advance |p| {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };"}, {"sha": "08fbb8aacc9306d2161dfb2b02a117ea0d45dc99", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -12,11 +12,10 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cmp;\n use core::from_str::FromStr;\n use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n-use core::str;\n-use core::vec;\n use super::bigint::BigInt;\n \n /// Represents the ratio between 2 numbers.\n@@ -252,11 +251,7 @@ impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { return None; }\n         do FromStr::from_str::<T>(split[0]).chain |a| {\n             do FromStr::from_str::<T>(split[1]).chain |b| {\n@@ -269,11 +264,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { None }\n         else {\n             do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {"}, {"sha": "690596e6248e99e4ef48106a20bd1c43a6df740b", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -14,6 +14,7 @@ use core::prelude::*;\n \n use core::{vec, int, str};\n use core::io::Reader;\n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use super::super::TermInfo;\n \n@@ -212,11 +213,8 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n \n-    let mut term_names: ~[~str] = vec::with_capacity(2);\n     let names_str = str::from_bytes(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n-    for names_str.each_split_char('|') |s| {\n-        term_names.push(s.to_owned());\n-    }\n+    let term_names: ~[~str] = names_str.split_iter('|').transform(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL\n "}, {"sha": "d109bb12e02288f391bb61db0cc65546877c6566", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -12,9 +12,10 @@\n /// Does not support hashed database, only filesystem!\n \n use core::prelude::*;\n-use core::{os, str};\n+use core::{os};\n use core::os::getenv;\n use core::io::{file_reader, Reader};\n+use core::iterator::IteratorUtil;\n use path = core::path::Path;\n \n /// Return path to database entry for `term`\n@@ -36,7 +37,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n                 dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for str::each_split_char(dirs, ':') |i| {\n+                Some(dirs) => for dirs.split_iter(':').advance |i| {\n                     if i == \"\" {\n                         dirs_to_search.push(path(\"/usr/share/terminfo\"));\n                     } else {"}, {"sha": "d765bcff9e23652fb5af4aba189e956a9b3c0e9e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -24,6 +24,7 @@ use middle;\n use util::common::time;\n use util::ppaux;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::int;\n use core::io;\n@@ -684,11 +685,7 @@ pub fn build_session_options(binary: @~str,\n     let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n     let linker = getopts::opt_maybe_str(matches, \"linker\");\n     let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n-        let mut args = ~[];\n-        for str::each_split_char(*a, ' ') |arg| {\n-            args.push(str::to_owned(arg));\n-        }\n-        args\n+        a.split_iter(' ').transform(|arg| arg.to_owned()).collect()\n     });\n \n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n@@ -699,12 +696,9 @@ pub fn build_session_options(binary: @~str,\n     let custom_passes = match getopts::opt_maybe_str(matches, \"passes\") {\n         None => ~[],\n         Some(s) => {\n-            let mut o = ~[];\n-            for s.each_split(|c| c == ' ' || c == ',') |s| {\n-                let s = s.trim().to_owned();\n-                o.push(s);\n-            }\n-            o\n+            s.split_iter(|c: char| c == ' ' || c == ',').transform(|s| {\n+                s.trim().to_owned()\n+            }).collect()\n         }\n     };\n "}, {"sha": "f0cabe5045587e71eb5ea5c82c21617016eb5bac", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -17,6 +17,7 @@ use core::prelude::*;\n use metadata::cstore;\n use metadata::decoder;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::vec;\n use extra;\n@@ -114,7 +115,7 @@ pub fn get_used_libraries(cstore: &CStore) -> ~[~str] {\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for args.each_split_char(' ') |s| {\n+    for args.split_iter(' ').advance |s| {\n         cstore.used_link_args.push(s.to_owned());\n     }\n }"}, {"sha": "6d4043bfc89990e69642b395512710a1b64fd4b2", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -339,9 +339,11 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n                 use_rl: bool)\n     -> Option<Repl> {\n     if line.starts_with(\":\") {\n+        // FIXME #5898: conflicts with Cell.take(), so can't be at the top level\n+        use core::iterator::IteratorUtil;\n+\n         let full = line.substr(1, line.len() - 1);\n-        let mut split = ~[];\n-        for str::each_word(full) |word| { split.push(word.to_owned()) }\n+        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n         let len = split.len();\n \n         if len > 0 {"}, {"sha": "c039eeacbe47a96a85e88700dde576ea6937a327", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -17,6 +17,7 @@ pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n use core::os;\n+use core::iterator::IteratorUtil;\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. In general this should be read from the\n@@ -166,7 +167,7 @@ fn library_in_workspace(full_name: &str, short_name: &str, where: Target,\n         let f_name = match p_path.filename() {\n             Some(s) => s, None => loop\n         };\n-        for f_name.each_split_char('-') |piece| {\n+        for f_name.split_iter('-').advance |piece| {\n             debug!(\"a piece = %s\", piece);\n             if which == 0 && piece != lib_prefix {\n                 break;"}, {"sha": "2db51fe969fc415d8061f96d803947d8053545f6", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -29,6 +29,7 @@ extern mod syntax;\n \n use core::prelude::*;\n use core::*;\n+use core::iterator::IteratorUtil;\n pub use core::path::Path;\n use core::hashmap::HashMap;\n use rustc::driver::{driver, session};\n@@ -161,10 +162,8 @@ impl<'self> PkgScript<'self> {\n                            exe.to_str(), root.to_str(), \"configs\");\n                     let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n                     // Run the configs() function to get the configs\n-                    let mut cfgs = ~[];\n-                    for str::each_word(str::from_bytes(output.output)) |w| {\n-                        cfgs.push(w.to_owned());\n-                    }\n+                    let cfgs = str::from_bytes_slice(output.output).word_iter()\n+                        .transform(|w| w.to_owned()).collect();\n                     (cfgs, output.status)\n                 }\n             }"}, {"sha": "2069e61f11e646500554508bd30b726f8ea2f740", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -30,6 +30,7 @@\n \n use cast;\n use io;\n+use iterator::IteratorUtil;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n use libc::{mode_t, FILE};\n@@ -224,12 +225,11 @@ pub fn env() -> ~[(~str,~str)] {\n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n             for input.each |p| {\n-                let mut vs = ~[];\n-                for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n+                let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n                 assert_eq!(vs.len(), 2);\n-                pairs.push((copy vs[0], copy vs[1]));\n+                pairs.push((vs[0].to_owned(), vs[1].to_owned()));\n             }\n             pairs\n         }"}, {"sha": "b2f25d41157ba4a714ea287d47ad8a89e3f6d49c", "filename": "src/libstd/path.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -18,6 +18,7 @@ Cross-platform file path handling\n \n use container::Container;\n use cmp::Eq;\n+use iterator::IteratorUtil;\n use libc;\n use option::{None, Option, Some};\n use str;\n@@ -449,10 +450,9 @@ impl ToStr for PosixPath {\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n     fn from_str(s: &str) -> PosixPath {\n-        let mut components = ~[];\n-        for str::each_split_nonempty(s, |c| c == '/') |s| {\n-            components.push(s.to_owned())\n-        }\n+        let components = s.split_iter('/')\n+            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n+            .collect();\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         PosixPath {\n             is_absolute: is_absolute,\n@@ -508,7 +508,7 @@ impl GenericPath for PosixPath {\n     }\n \n     fn with_filename(&self, f: &str) -> PosixPath {\n-        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        assert!(! str::any(f, |c| windows::is_sep(c)));\n         self.dir_path().push(f)\n     }\n \n@@ -569,11 +569,11 @@ impl GenericPath for PosixPath {\n     fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = ~[];\n-            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n-                ss.push(s.to_owned())\n+            for e.split_iter(windows::is_sep).advance |s| {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n             }\n-            v.push_all_move(ss);\n         }\n         PosixPath {\n             is_absolute: self.is_absolute,\n@@ -583,11 +583,11 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n-        let mut ss = ~[];\n-        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n-            ss.push(s.to_owned())\n+        for s.split_iter(windows::is_sep).advance |s| {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n         }\n-        v.push_all_move(ss);\n         PosixPath { components: v, ..copy *self }\n     }\n \n@@ -661,11 +661,11 @@ impl GenericPath for WindowsPath {\n             }\n         }\n \n-        let mut components = ~[];\n-        for str::each_split_nonempty(rest, |c| windows::is_sep(c as u8)) |s| {\n-            components.push(s.to_owned())\n-        }\n-        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n+        let components = rest.split_iter(windows::is_sep)\n+            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n+            .collect();\n+\n+        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0] as char));\n         WindowsPath {\n             host: host,\n             device: device,\n@@ -722,7 +722,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn with_filename(&self, f: &str) -> WindowsPath {\n-        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        assert!(! str::any(f, |c| windows::is_sep(c)));\n         self.dir_path().push(f)\n     }\n \n@@ -826,11 +826,11 @@ impl GenericPath for WindowsPath {\n     fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = ~[];\n-            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n-                ss.push(s.to_owned())\n+            for e.split_iter(windows::is_sep).advance |s| {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n             }\n-            v.push_all_move(ss);\n         }\n         // tedious, but as-is, we can't use ..self\n         WindowsPath {\n@@ -843,11 +843,11 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n-        let mut ss = ~[];\n-        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n-            ss.push(s.to_owned())\n+        for s.split_iter(windows::is_sep).advance |s| {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n         }\n-        v.push_all_move(ss);\n         WindowsPath { components: v, ..copy *self }\n     }\n \n@@ -905,8 +905,8 @@ pub mod windows {\n     use option::{None, Option, Some};\n \n     #[inline(always)]\n-    pub fn is_sep(u: u8) -> bool {\n-        u == '/' as u8 || u == '\\\\' as u8\n+    pub fn is_sep(u: char) -> bool {\n+        u == '/' || u == '\\\\'\n     }\n \n     pub fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n@@ -915,7 +915,7 @@ pub mod windows {\n             s[0] == s[1]) {\n             let mut i = 2;\n             while i < s.len() {\n-                if is_sep(s[i]) {\n+                if is_sep(s[i] as char) {\n                     let pre = s.slice(2, i).to_owned();\n                     let rest = s.slice(i, s.len()).to_owned();\n                     return Some((pre, rest));"}, {"sha": "930026fa4f76fb3876f9df2247b5051bfc8551ee", "filename": "src/libstd/str.rs", "status": "modified", "additions": 182, "deletions": 404, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -25,7 +25,7 @@ use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, FilterIterator};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -633,128 +633,92 @@ pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n-/// Splits a string into substrings at each occurrence of a given character\n-pub fn each_split_char<'a>(s: &'a str, sep: char,\n-                           it: &fn(&'a str) -> bool) -> bool {\n-    each_split_char_inner(s, sep, len(s), true, true, it)\n-}\n+/// An iterator over the substrings of a string, separated by `sep`.\n+pub struct StrCharSplitIterator<'self,Sep> {\n+    priv string: &'self str,\n+    priv position: uint,\n+    priv sep: Sep,\n+    /// The number of splits remaining\n+    priv count: uint,\n+    /// Whether an empty string at the end is allowed\n+    priv allow_trailing_empty: bool,\n+    priv finished: bool,\n+    priv only_ascii: bool\n+}\n+\n+/// An iterator over the words of a string, separated by an sequence of whitespace\n+pub type WordIterator<'self> =\n+    FilterIterator<'self, &'self str,\n+             StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n+\n+/// A separator for splitting a string character-wise\n+pub trait StrCharSplitSeparator {\n+    /// Determine if the splitter should split at the given character\n+    fn should_split(&self, char) -> bool;\n+    /// Indicate if the splitter only uses ASCII characters, which\n+    /// allows for a faster implementation.\n+    fn only_ascii(&self) -> bool;\n+}\n+impl StrCharSplitSeparator for char {\n+    #[inline(always)]\n+    fn should_split(&self, c: char) -> bool { *self == c }\n \n-/// Like `each_split_char`, but a trailing empty string is omitted\n-pub fn each_split_char_no_trailing<'a>(s: &'a str,\n-                                       sep: char,\n-                                       it: &fn(&'a str) -> bool) -> bool {\n-    each_split_char_inner(s, sep, len(s), true, false, it)\n+    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n+impl<'self> StrCharSplitSeparator for &'self fn(char) -> bool {\n+    #[inline(always)]\n+    fn should_split(&self, c: char) -> bool { (*self)(c) }\n \n-/**\n- * Splits a string into substrings at each occurrence of a given\n- * character up to 'count' times.\n- *\n- * The character must be a valid UTF-8/ASCII character\n- */\n-pub fn each_splitn_char<'a>(s: &'a str,\n-                            sep: char,\n-                            count: uint,\n-                            it: &fn(&'a str) -> bool) -> bool {\n-    each_split_char_inner(s, sep, count, true, true, it)\n+    fn only_ascii(&self) -> bool { false }\n }\n+impl<'self> StrCharSplitSeparator for extern \"Rust\" fn(char) -> bool {\n+    #[inline(always)]\n+    fn should_split(&self, c: char) -> bool { (*self)(c) }\n \n-/// Like `each_split_char`, but omits empty strings\n-pub fn each_split_char_nonempty<'a>(s: &'a str,\n-                                    sep: char,\n-                                    it: &fn(&'a str) -> bool) -> bool {\n-    each_split_char_inner(s, sep, len(s), false, false, it)\n+    fn only_ascii(&self) -> bool { false }\n }\n \n-fn each_split_char_inner<'a>(s: &'a str,\n-                             sep: char,\n-                             count: uint,\n-                             allow_empty: bool,\n-                             allow_trailing_empty: bool,\n-                             it: &fn(&'a str) -> bool) -> bool {\n-    if sep < 128u as char {\n-        let (b, l) = (sep as u8, len(s));\n-        let mut done = 0u;\n-        let mut (i, start) = (0u, 0u);\n-        while i < l && done < count {\n-            if s[i] == b {\n-                if allow_empty || start < i {\n-                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n-                        return false;\n-                    }\n-                }\n-                start = i + 1u;\n-                done += 1u;\n-            }\n-            i += 1u;\n-        }\n-        // only slice a non-empty trailing substring\n-        if allow_trailing_empty || start < l {\n-            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n-        }\n-        return true;\n-    }\n-    return each_split_inner(s, |cur| cur == sep, count,\n-                            allow_empty, allow_trailing_empty, it)\n-}\n+impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n+    fn next(&mut self) -> Option<&'self str> {\n+        if self.finished { return None }\n \n-/// Splits a string into substrings using a character function\n-pub fn each_split<'a>(s: &'a str,\n-                      sepfn: &fn(char) -> bool,\n-                      it: &fn(&'a str) -> bool) -> bool {\n-    each_split_inner(s, sepfn, len(s), true, true, it)\n-}\n+        let l = self.string.len();\n+        let start = self.position;\n \n-/// Like `each_split`, but a trailing empty string is omitted\n-pub fn each_split_no_trailing<'a>(s: &'a str,\n-                                  sepfn: &fn(char) -> bool,\n-                                  it: &fn(&'a str) -> bool) -> bool {\n-    each_split_inner(s, sepfn, len(s), true, false, it)\n-}\n+        if self.only_ascii {\n+            // this gives a *huge* speed up for splitting on ASCII\n+            // characters (e.g. '\\n' or ' ')\n+            while self.position < l && self.count > 0 {\n+                let byte = self.string[self.position];\n \n-/**\n- * Splits a string into substrings using a character function, cutting at\n- * most `count` times.\n- */\n-pub fn each_splitn<'a>(s: &'a str,\n-                       sepfn: &fn(char) -> bool,\n-                       count: uint,\n-                       it: &fn(&'a str) -> bool) -> bool {\n-    each_split_inner(s, sepfn, count, true, true, it)\n-}\n-\n-/// Like `each_split`, but omits empty strings\n-pub fn each_split_nonempty<'a>(s: &'a str,\n-                               sepfn: &fn(char) -> bool,\n-                               it: &fn(&'a str) -> bool) -> bool {\n-    each_split_inner(s, sepfn, len(s), false, false, it)\n-}\n-\n-fn each_split_inner<'a>(s: &'a str,\n-                        sepfn: &fn(cc: char) -> bool,\n-                        count: uint,\n-                        allow_empty: bool,\n-                        allow_trailing_empty: bool,\n-                        it: &fn(&'a str) -> bool) -> bool {\n-    let l = len(s);\n-    let mut (i, start, done) = (0u, 0u, 0u);\n-    while i < l && done < count {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        if sepfn(ch) {\n-            if allow_empty || start < i {\n-                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n-                    return false;\n+                if self.sep.should_split(byte as char) {\n+                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n+                    self.position += 1;\n+                    self.count -= 1;\n+                    return Some(slice);\n                 }\n+                self.position += 1;\n+            }\n+        } else {\n+            while self.position < l && self.count > 0 {\n+                let CharRange {ch, next} = char_range_at(self.string, self.position);\n+\n+                if self.sep.should_split(ch) {\n+                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n+                    self.position = next;\n+                    self.count -= 1;\n+                    return Some(slice);\n+                }\n+                self.position = next;\n             }\n-            start = next;\n-            done += 1u;\n         }\n-        i = next;\n-    }\n-    if allow_trailing_empty || start < l {\n-        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n+        self.finished = true;\n+        if self.allow_trailing_empty || start < l {\n+            Some(unsafe { raw::slice_bytes(self.string, start, l) })\n+        } else {\n+            None\n+        }\n     }\n-    return true;\n }\n \n // See Issue #1932 for why this is a naive search\n@@ -875,19 +839,12 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n     return dcol[tlen];\n }\n \n-/**\n- * Splits a string into substrings separated by LF ('\\n').\n- */\n-pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    each_split_char_no_trailing(s, '\\n', it)\n-}\n-\n /**\n  * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    for each_line(s) |s| {\n+    for s.line_iter().advance |s| {\n         let l = s.len();\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n             if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n@@ -898,11 +855,6 @@ pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     return true;\n }\n \n-/// Splits a string into substrings separated by whitespace\n-pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    each_split_nonempty(s, char::is_whitespace, it)\n-}\n-\n /** Splits a string into substrings with possibly internal whitespace,\n  *  each of them at most `lim` bytes long. The substrings have leading and trailing\n  *  whitespace removed, and are only cut at whitespace boundaries.\n@@ -2216,7 +2168,7 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n  * ~~~ {.rust}\n  * let string = \"a\\nb\\nc\";\n  * let mut lines = ~[];\n- * for each_line(string) |line| { lines.push(line) }\n+ * for string.line_iter().advance |line| { lines.push(line) }\n  *\n  * assert!(subslice_offset(string, lines[0]) == 0); // &\"a\"\n  * assert!(subslice_offset(string, lines[1]) == 2); // &\"b\"\n@@ -2523,15 +2475,25 @@ pub trait StrSlice<'self> {\n     fn rev_iter(&self) -> StrCharRevIterator<'self>;\n     fn bytes_iter(&self) -> StrBytesIterator<'self>;\n     fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self>;\n+    fn split_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep>;\n+    fn splitn_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep, count: uint)\n+        -> StrCharSplitIterator<'self, Sep>;\n+    fn split_options_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep,\n+                                                      count: uint, allow_trailing_empty: bool)\n+        -> StrCharSplitIterator<'self, Sep>;\n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`).\n+    fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace).\n+    fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool;\n-    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool;\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n@@ -2597,6 +2559,36 @@ impl<'self> StrSlice<'self> for &'self str {\n         StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n     }\n \n+    fn split_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep> {\n+        self.split_options_iter(sep, self.len(), true)\n+    }\n+\n+    fn splitn_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep, count: uint)\n+        -> StrCharSplitIterator<'self, Sep> {\n+        self.split_options_iter(sep, count, true)\n+    }\n+    fn split_options_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep,\n+                                                      count: uint, allow_trailing_empty: bool)\n+        -> StrCharSplitIterator<'self, Sep> {\n+        let only_ascii = sep.only_ascii();\n+        StrCharSplitIterator {\n+            string: *self,\n+            position: 0,\n+            sep: sep,\n+            count: count,\n+            allow_trailing_empty: allow_trailing_empty,\n+            finished: false,\n+            only_ascii: only_ascii\n+        }\n+    }\n+\n+    fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n+        self.split_options_iter('\\n', self.len(), false)\n+    }\n+    fn word_iter(&self) -> WordIterator<'self> {\n+        self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n+    }\n+\n \n     /// Returns true if one string ends with another\n     #[inline]\n@@ -2637,18 +2629,6 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n         slice(*self, begin, end)\n     }\n-    /// Splits a string into substrings using a character function\n-    #[inline]\n-    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool {\n-        each_split(*self, sepfn, it)\n-    }\n-    /**\n-     * Splits a string into substrings at each occurrence of a given character\n-     */\n-    #[inline]\n-    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool {\n-        each_split_char(*self, sep, it)\n-    }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n@@ -2904,131 +2884,6 @@ mod tests {\n         let _cc3 = pop_char(&mut data);\n     }\n \n-    #[test]\n-    fn test_split_char() {\n-        fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(\"split_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n-        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n-\n-        t(\"\", 'z', [~\"\"]);\n-        t(\"z\", 'z', [~\"\",~\"\"]);\n-        t(\"ok\", 'z', [~\"ok\"]);\n-    }\n-\n-    #[test]\n-    fn test_split_char_2() {\n-        fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(\"split_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n-    }\n-\n-    #[test]\n-    fn test_splitn_char() {\n-        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(\"splitn_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            debug!(\"comparing vs. %?\", u);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"abc.hello.there\", '.', 0u, [~\"abc.hello.there\"]);\n-        t(\"abc.hello.there\", '.', 1u, [~\"abc\", ~\"hello.there\"]);\n-        t(\"abc.hello.there\", '.', 2u, [~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(\"abc.hello.there\", '.', 3u, [~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(\".hello.there\", '.', 0u, [~\".hello.there\"]);\n-        t(\".hello.there\", '.', 1u, [~\"\", ~\"hello.there\"]);\n-        t(\"...hello.there.\", '.', 3u, [~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n-        t(\"...hello.there.\", '.', 5u, [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n-\n-        t(\"\", 'z', 5u, [~\"\"]);\n-        t(\"z\", 'z', 5u, [~\"\",~\"\"]);\n-        t(\"ok\", 'z', 5u, [~\"ok\"]);\n-        t(\"z\", 'z', 0u, [~\"z\"]);\n-        t(\"w.x.y\", '.', 0u, [~\"w.x.y\"]);\n-        t(\"w.x.y\", '.', 1u, [~\"w\",~\"x.y\"]);\n-    }\n-\n-    #[test]\n-    fn test_splitn_char_2() {\n-        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(\"splitn_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            debug!(\"comparing vs. %?\", u);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzYYYzWWWz\", 'z', 3u, [~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]);\n-        t(\"z\", 'z', 5u, [~\"\",~\"\"]);\n-        t(\"\", 'z', 5u, [~\"\"]);\n-        t(\"ok\", 'z', 5u, [~\"ok\"]);\n-    }\n-\n-    #[test]\n-    fn test_splitn_char_3() {\n-        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(\"splitn_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            debug!(\"comparing vs. %?\", u);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n-    }\n-\n-    #[test]\n-    fn test_split_char_no_trailing() {\n-        fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(\"split_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n-        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n-\n-        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n-        t(\"\", 'z', []);\n-        t(\"z\", 'z', [~\"\"]);\n-        t(\"ok\", 'z', [~\"ok\"]);\n-    }\n-\n-    #[test]\n-    fn test_split_char_no_trailing_2() {\n-        fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(\"split_byte: %?\", s);\n-            let mut v = ~[];\n-            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n-            debug!(\"split_byte to: %?\", v);\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n-    }\n-\n     #[test]\n     fn test_split_str() {\n         fn t<'a>(s: &str, sep: &'a str, u: &[~str]) {\n@@ -3053,75 +2908,6 @@ mod tests {\n     }\n \n \n-    #[test]\n-    fn test_split() {\n-        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n-            let mut v = ~[];\n-            for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzYYYz\", char::is_lowercase, [~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(\"zzXXXzYYYz\", char::is_uppercase, [~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n-        t(\"z\", |cc| cc == 'z', [~\"\",~\"\"]);\n-        t(\"\", |cc| cc == 'z', [~\"\"]);\n-        t(\"ok\", |cc| cc == 'z', [~\"ok\"]);\n-    }\n-\n-    #[test]\n-    fn test_split_no_trailing() {\n-        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n-            let mut v = ~[];\n-            for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzYYYz\", char::is_lowercase, [~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]);\n-        t(\"zzXXXzYYYz\", char::is_uppercase, [~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n-        t(\"z\", |cc| cc == 'z', [~\"\"]);\n-        t(\"\", |cc| cc == 'z', []);\n-        t(\"ok\", |cc| cc == 'z', [~\"ok\"]);\n-    }\n-\n-    #[test]\n-    fn test_lines() {\n-        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n-\n-        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n-            let mut v = ~[];\n-            for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-\n-        t(lf, each_line, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(lf, each_line_any, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(crlf, each_line, [~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\"]);\n-        t(crlf, each_line_any, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(\"\", each_line, []);\n-        t(\"\", each_line_any, []);\n-        t(\"\\n\", each_line, [~\"\"]);\n-        t(\"\\n\", each_line_any, [~\"\"]);\n-        t(\"banana\", each_line, [~\"banana\"]);\n-        t(\"banana\", each_line_any, [~\"banana\"]);\n-    }\n-\n-    #[test]\n-    fn test_words() {\n-        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n-            let mut v = ~[];\n-            for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-\n-        t(data, each_word, [~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]);\n-        t(\"ok\", each_word, [~\"ok\"]);\n-        t(\"\", each_word, []);\n-    }\n-\n     #[test]\n     fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n@@ -3671,7 +3457,7 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n-        for each_line(string) |line| { lines.push(line) }\n+        for string.line_iter().advance |line| { lines.push(line) }\n         assert_eq!(subslice_offset(string, lines[0]), 0);\n         assert_eq!(subslice_offset(string, lines[1]), 2);\n         assert_eq!(subslice_offset(string, lines[2]), 4);\n@@ -3730,78 +3516,6 @@ mod tests {\n         assert!(!contains_char(\"\", 'a'));\n     }\n \n-    #[test]\n-    fn test_split_char_each() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-\n-        let mut ii = 0;\n-\n-        for each_split_char(data, ' ') |xx| {\n-            match ii {\n-              0 => assert!(\"\\nMary\" == xx),\n-              1 => assert!(\"had\"    == xx),\n-              2 => assert!(\"a\"      == xx),\n-              3 => assert!(\"little\" == xx),\n-              _ => ()\n-            }\n-            ii += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_splitn_char_each() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-\n-        let mut ii = 0;\n-\n-        for each_splitn_char(data, ' ', 2u) |xx| {\n-            match ii {\n-              0 => assert!(\"\\nMary\" == xx),\n-              1 => assert!(\"had\"    == xx),\n-              2 => assert!(\"a little lamb\\nLittle lamb\\n\" == xx),\n-              _ => ()\n-            }\n-            ii += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_words_each() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-\n-        let mut ii = 0;\n-\n-        for each_word(data) |ww| {\n-            match ii {\n-              0 => assert!(\"Mary\"   == ww),\n-              1 => assert!(\"had\"    == ww),\n-              2 => assert!(\"a\"      == ww),\n-              3 => assert!(\"little\" == ww),\n-              _ => ()\n-            }\n-            ii += 1;\n-        }\n-\n-        each_word(\"\", |_x| fail!()); // should not fail\n-    }\n-\n-    #[test]\n-    fn test_lines_each () {\n-        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-\n-        let mut ii = 0;\n-\n-        for each_line(lf) |x| {\n-            match ii {\n-                0 => assert!(\"\" == x),\n-                1 => assert!(\"Mary had a little lamb\" == x),\n-                2 => assert!(\"Little lamb\" == x),\n-                _ => ()\n-            }\n-            ii += 1;\n-        }\n-    }\n-\n     #[test]\n     fn test_map() {\n         assert_eq!(~\"\", map(\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n@@ -4015,4 +3729,68 @@ mod tests {\n             assert_eq!(b, v[pos]);\n         }\n     }\n+\n+    #[test]\n+    fn test_split_char_iterator() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let split: ~[&str] = data.split_iter(' ').collect();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let split: ~[&str] = data.split_iter(|c: char| c == ' ').collect();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        // Unicode\n+        let split: ~[&str] = data.split_iter('\u00e4').collect();\n+        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let split: ~[&str] = data.split_iter(|c: char| c == '\u00e4').collect();\n+        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    }\n+    #[test]\n+    fn test_splitn_char_iterator() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let split: ~[&str] = data.splitn_iter(' ', 3).collect();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+        let split: ~[&str] = data.splitn_iter(|c: char| c == ' ', 3).collect();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+        // Unicode\n+        let split: ~[&str] = data.splitn_iter('\u00e4', 3).collect();\n+        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+        let split: ~[&str] = data.splitn_iter(|c: char| c == '\u00e4', 3).collect();\n+        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+    }\n+\n+    #[test]\n+    fn test_split_char_iterator_no_trailing() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let split: ~[&str] = data.split_options_iter('\\n', 1000, true).collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+        let split: ~[&str] = data.split_options_iter('\\n', 1000, false).collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+    }\n+\n+    #[test]\n+    fn test_word_iter() {\n+        let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+        let words: ~[&str] = data.word_iter().collect();\n+        assert_eq!(words, ~[\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+    }\n+\n+    #[test]\n+    fn test_line_iter() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+        let lines: ~[&str] = data.line_iter().collect();\n+        assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n+        let lines: ~[&str] = data.line_iter().collect();\n+        assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+    }\n }"}, {"sha": "3ff894c267b8f47d626cd78106f1300692155a29", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -92,6 +92,7 @@ use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n+use core::iterator::IteratorUtil;\n use core::either::Either;\n use core::either;\n use core::hashmap::HashSet;\n@@ -3981,17 +3982,15 @@ impl Parser {\n             token::LIT_STR(s) => {\n                 self.bump();\n                 let the_string = ident_to_str(&s);\n-                let mut words = ~[];\n-                for str::each_word(*the_string) |s| { words.push(s) }\n                 let mut abis = AbiSet::empty();\n-                for words.each |word| {\n-                    match abi::lookup(*word) {\n+                for the_string.word_iter().advance |word| {\n+                    match abi::lookup(word) {\n                         Some(abi) => {\n                             if abis.contains(abi) {\n                                 self.span_err(\n                                     *self.span,\n                                     fmt!(\"ABI `%s` appears twice\",\n-                                         *word));\n+                                         word));\n                             } else {\n                                 abis.add(abi);\n                             }\n@@ -4006,7 +4005,7 @@ impl Parser {\n                                      str::connect_slices(\n                                          abi::all_names(),\n                                          \", \"),\n-                                     *word));\n+                                     word));\n                         }\n                     }\n                 }"}, {"sha": "d05edef25a6e2a6dbfe778df647e2b5ae69f75a7", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=1e8982bdb26208d9d9ed4cdcbcd21cc9ef35bd46", "patch": "@@ -14,6 +14,7 @@ extern mod extra;\n \n use std::io::{ReaderUtil, WriterUtil};\n use std::io;\n+use std::iterator::IteratorUtil;\n use std::os;\n use std::str;\n use std::u8;\n@@ -73,8 +74,8 @@ impl Sudoku {\n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n             let line = reader.read_line();\n-            let mut comps = ~[];\n-            for str::each_split_char(line.trim(), ',') |s| { comps.push(s.to_owned()) }\n+            let comps: ~[&str] = line.trim().split_iter(',').collect();\n+\n             if comps.len() == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;"}]}