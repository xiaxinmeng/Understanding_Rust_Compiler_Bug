{"sha": "7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzJlNzc4YWIzY2ZhMGRjN2RjMjIyNjk1MmM2YjlmMWUxYzc2YjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-19T08:42:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:59:40Z"}, "message": "instantiate closure requirements as query-region-constraints [WIP]\n\nMarked as WIP because it invalidates some tests.", "tree": {"sha": "46cb5b3c9bbb60ce5804fb2ccb65e15664bbdf8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46cb5b3c9bbb60ce5804fb2ccb65e15664bbdf8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "html_url": "https://github.com/rust-lang/rust/commit/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e32d42532c9499066c1f45f8a301c2a81e45ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e32d42532c9499066c1f45f8a301c2a81e45ec8", "html_url": "https://github.com/rust-lang/rust/commit/3e32d42532c9499066c1f45f8a301c2a81e45ec8"}], "stats": {"total": 108, "additions": 48, "deletions": 60}, "files": [{"sha": "2e1f7fc9e70076103522dee7d0374ca0dd61a8c6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 52, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "patch": "@@ -11,25 +11,22 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n-use rustc::infer::SubregionOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n     Mir,\n };\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n@@ -1162,16 +1159,15 @@ impl fmt::Debug for OutlivesConstraint {\n pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n-    );\n+    ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n@@ -1194,14 +1190,11 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// requirements.\n     fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n-    ) {\n-        let tcx = infcx.tcx;\n-\n+    ) -> Vec<QueryRegionConstraint<'tcx>> {\n         debug!(\n             \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n             location, closure_def_id, closure_substs\n@@ -1215,59 +1208,52 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         // into a vector.  These are the regions that we will be\n         // relating to one another.\n         let closure_mapping =\n-            &UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+            &UniversalRegions::closure_mapping(tcx, user_closure_ty, self.num_external_vids);\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n \n         // Create the predicates.\n-        for outlives_requirement in &self.outlives_requirements {\n-            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-            // FIXME, this origin is not entirely suitable.\n-            let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n-\n-            match outlives_requirement.subject {\n-                ClosureOutlivesSubject::Region(region) => {\n-                    let region = closure_mapping[region];\n-                    debug!(\n-                        \"apply_requirements: region={:?} \\\n-                         outlived_region={:?} \\\n-                         outlives_requirement={:?}\",\n-                        region, outlived_region, outlives_requirement,\n-                    );\n-                    infcx.sub_regions(origin, outlived_region, region);\n-                }\n+        self.outlives_requirements\n+            .iter()\n+            .map(|outlives_requirement| {\n+                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+\n+                match outlives_requirement.subject {\n+                    ClosureOutlivesSubject::Region(region) => {\n+                        let region = closure_mapping[region];\n+                        debug!(\n+                            \"apply_requirements: region={:?} \\\n+                             outlived_region={:?} \\\n+                             outlives_requirement={:?}\",\n+                            region, outlived_region, outlives_requirement,\n+                        );\n+                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                    }\n \n-                ClosureOutlivesSubject::Ty(ty) => {\n-                    let ty = self.subst_closure_mapping(infcx, closure_mapping, &ty);\n-                    debug!(\n-                        \"apply_requirements: ty={:?} \\\n-                         outlived_region={:?} \\\n-                         outlives_requirement={:?}\",\n-                        ty, outlived_region, outlives_requirement,\n-                    );\n-                    infcx.register_region_obligation(\n-                        body_id,\n-                        RegionObligation {\n-                            sup_type: ty,\n-                            sub_region: outlived_region,\n-                            cause: ObligationCause::misc(outlives_requirement.blame_span, body_id),\n-                        },\n-                    );\n+                    ClosureOutlivesSubject::Ty(ty) => {\n+                        let ty = self.subst_closure_mapping(tcx, closure_mapping, &ty);\n+                        debug!(\n+                            \"apply_requirements: ty={:?} \\\n+                             outlived_region={:?} \\\n+                             outlives_requirement={:?}\",\n+                            ty, outlived_region, outlives_requirement,\n+                        );\n+                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                    }\n                 }\n-            }\n-        }\n+            })\n+            .collect()\n     }\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        infcx.tcx.fold_regions(value, &mut false, |r, _depth| {\n+        tcx.fold_regions(value, &mut false, |r, _depth| {\n             if let ty::ReClosureBound(vid) = r {\n                 closure_mapping[*vid]\n             } else {"}, {"sha": "843fadf62272b90219114614f193f66d4e423d86", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "patch": "@@ -29,7 +29,6 @@ use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::ObligationCause;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n@@ -1507,14 +1506,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Some(closure_region_requirements) =\n                     tcx.mir_borrowck(*def_id).closure_requirements\n                 {\n-                    let dummy_body_id = ObligationCause::dummy().body_id;\n-                    closure_region_requirements.apply_requirements(\n-                        self.infcx,\n-                        dummy_body_id,\n+                    let closure_constraints = closure_region_requirements.apply_requirements(\n+                        self.infcx.tcx,\n                         location,\n                         *def_id,\n                         *substs,\n                     );\n+\n+                    self.push_region_constraints(\n+                        location.at_self(),\n+                        &closure_constraints,\n+                    );\n                 }\n \n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)"}, {"sha": "ec8cd386679c39970592a29f82593069cfe3e189", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=7c72e778ab3cfa0dc7dc2226952c6b9f1e1c76b6", "patch": "@@ -238,13 +238,13 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `'1: '2`, then the caller would impose the constraint that\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         closure_ty: Ty<'tcx>,\n         expected_num_vars: usize,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n-        region_mapping.push(infcx.tcx.types.re_static);\n-        infcx.tcx.for_each_free_region(&closure_ty, |fr| {\n+        region_mapping.push(tcx.types.re_static);\n+        tcx.for_each_free_region(&closure_ty, |fr| {\n             region_mapping.push(fr);\n         });\n "}]}