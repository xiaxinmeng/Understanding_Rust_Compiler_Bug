{"sha": "7fb7765cdab6bd9d0dddd5275dd73775938af299", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYjc3NjVjZGFiNmJkOWQwZGRkZDUyNzVkZDczNzc1OTM4YWYyOTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-26T01:00:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-26T01:00:23Z"}, "message": "Rollup merge of #73674 - estebank:op-trait-bound-suggestion, r=davidtwco\n\nTweak binop errors\n\n* Suggest potentially missing binop trait bound (fix #73416)\n* Use structured suggestion for dereference in binop", "tree": {"sha": "4d9bd2406912f116259ab1add338b82c063d2e19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9bd2406912f116259ab1add338b82c063d2e19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fb7765cdab6bd9d0dddd5275dd73775938af299", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9UioCRBK7hj4Ov3rIwAAdHIIAFpWWdklI2shBKCH348oFcBs\nlN0LtwMSRLrLt/gKUEiflSyB9EzYKW9CiENAP4DdVD5qCaKGD8tWb1XX8LMzk0d6\ngKrSQZnXUBXj9YFxCR0K5nEjksG/ctlnqGuHfyh5TODttCfDJFyxeVlnlC5bstw0\nspuy+tgd8z6xpyE1aowdY96vsjbscsyNP651VYbE0AWP0kdSEUtU14vqMgmMfGa+\ntNi/R7VdGqh1iOlKE/4MWep9yYcVL25UnPBtoSxx4EBChfs3oF4auFhhk1u2dhH6\nnzkyteQscsUpV05F0Wogo3DWesi4/vs0Fy2X5G9HJAugohw95GM4af6sb1Rjxxk=\n=/OHb\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d9bd2406912f116259ab1add338b82c063d2e19\nparent 91f8766cea9e810777c135f857f23333f6b035de\nparent 8f40dae93b3a66a9cdd0f940244da7f602618fba\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593133223 -0700\ncommitter GitHub <noreply@github.com> 1593133223 -0700\n\nRollup merge of #73674 - estebank:op-trait-bound-suggestion, r=davidtwco\n\nTweak binop errors\n\n* Suggest potentially missing binop trait bound (fix #73416)\n* Use structured suggestion for dereference in binop\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb7765cdab6bd9d0dddd5275dd73775938af299", "html_url": "https://github.com/rust-lang/rust/commit/7fb7765cdab6bd9d0dddd5275dd73775938af299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fb7765cdab6bd9d0dddd5275dd73775938af299/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f8766cea9e810777c135f857f23333f6b035de", "url": "https://api.github.com/repos/rust-lang/rust/commits/91f8766cea9e810777c135f857f23333f6b035de", "html_url": "https://github.com/rust-lang/rust/commit/91f8766cea9e810777c135f857f23333f6b035de"}, {"sha": "8f40dae93b3a66a9cdd0f940244da7f602618fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f40dae93b3a66a9cdd0f940244da7f602618fba", "html_url": "https://github.com/rust-lang/rust/commit/8f40dae93b3a66a9cdd0f940244da7f602618fba"}], "stats": {"total": 582, "additions": 328, "deletions": 254}, "files": [{"sha": "7bdf137f116c858f0284b31764aef60105280f54", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -295,8 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, \\\n-                m_name={}, trait_def_id={:?})\",\n+            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?})\",\n             self_ty, m_name, trait_def_id\n         );\n "}, {"sha": "8842ca877268a00bcb3aa98ec78f2a214cab2860", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -380,8 +380,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.sess,\n                         span,\n                         E0699,\n-                        \"the type of this value must be known \\\n-                               to call a method on a raw pointer on it\"\n+                        \"the type of this value must be known to call a method on a raw pointer on \\\n+                         it\"\n                     )\n                     .emit();\n                 } else {"}, {"sha": "94a5685a992feaeec414e9f43c4cf34a57bff810", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 248, "deletions": 246, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -8,8 +8,11 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n+use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -249,254 +252,229 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 method.sig.output()\n             }\n+            // error types are considered \"builtin\"\n+            Err(()) if lhs_ty.references_error() || rhs_ty.references_error() => {\n+                self.tcx.ty_error()\n+            }\n             Err(()) => {\n-                // error types are considered \"builtin\"\n-                if !lhs_ty.references_error() && !rhs_ty.references_error() {\n-                    let source_map = self.tcx.sess.source_map();\n-\n-                    match is_assign {\n-                        IsAssign::Yes => {\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                expr.span,\n-                                E0368,\n-                                \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n-                                op.node.as_str(),\n+                let source_map = self.tcx.sess.source_map();\n+                let (mut err, missing_trait, use_output, involves_fn) = match is_assign {\n+                    IsAssign::Yes => {\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            expr.span,\n+                            E0368,\n+                            \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n+                            op.node.as_str(),\n+                            lhs_ty,\n+                        );\n+                        err.span_label(\n+                            lhs_expr.span,\n+                            format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                        );\n+                        let missing_trait = match op.node {\n+                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n+                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n+                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n+                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n+                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n+                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n+                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n+                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n+                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n+                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n+                            _ => None,\n+                        };\n+                        (err, missing_trait, false, false)\n+                    }\n+                    IsAssign::No => {\n+                        let (message, missing_trait, use_output) = match op.node {\n+                            hir::BinOpKind::Add => (\n+                                format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Add\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Sub => (\n+                                format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Sub\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Mul => (\n+                                format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Mul\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Div => (\n+                                format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Div\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Rem => (\n+                                format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Rem\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitAnd => (\n+                                format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitAnd\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitXor => (\n+                                format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitXor\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitOr => (\n+                                format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitOr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shl => (\n+                                format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shl\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shr => (\n+                                format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialEq\"),\n+                                false,\n+                            ),\n+                            hir::BinOpKind::Lt\n+                            | hir::BinOpKind::Le\n+                            | hir::BinOpKind::Gt\n+                            | hir::BinOpKind::Ge => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialOrd\"),\n+                                false,\n+                            ),\n+                            _ => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                None,\n+                                false,\n+                            ),\n+                        };\n+                        let mut err =\n+                            struct_span_err!(self.tcx.sess, op.span, E0369, \"{}\", message.as_str());\n+                        let mut involves_fn = false;\n+                        if !lhs_expr.span.eq(&rhs_expr.span) {\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                lhs_expr.span,\n                                 lhs_ty,\n+                                rhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            err.span_label(\n-                                lhs_expr.span,\n-                                format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                rhs_expr.span,\n+                                rhs_ty,\n+                                lhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        let msg = &format!(\n-                                            \"`{}=` can be used on '{}', you can dereference `{}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring,\n-                                        );\n-                                        err.span_suggestion(\n-                                            lhs_expr.span,\n-                                            msg,\n-                                            format!(\"*{}\", lstring),\n-                                            rustc_errors::Applicability::MachineApplicable,\n-                                        );\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            let missing_trait = match op.node {\n-                                hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                                hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                                hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                                hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                                hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                                hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                                _ => None,\n-                            };\n-                            if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" += \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        false,\n-                                    );\n-                                } else if !suggested_deref {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n-                            }\n-                            err.emit();\n                         }\n-                        IsAssign::No => {\n-                            let (message, missing_trait, use_output) = match op.node {\n-                                hir::BinOpKind::Add => (\n-                                    format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Add\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Sub => (\n-                                    format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Sub\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Mul => (\n-                                    format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Mul\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Div => (\n-                                    format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Div\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Rem => (\n-                                    format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Rem\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitAnd => (\n-                                    format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitAnd\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitXor => (\n-                                    format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitXor\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitOr => (\n-                                    format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitOr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shl => (\n-                                    format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shl\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shr => (\n-                                    format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialEq\"),\n-                                    false,\n-                                ),\n-                                hir::BinOpKind::Lt\n-                                | hir::BinOpKind::Le\n-                                | hir::BinOpKind::Gt\n-                                | hir::BinOpKind::Ge => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialOrd\"),\n-                                    false,\n-                                ),\n-                                _ => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    None,\n-                                    false,\n-                                ),\n-                            };\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                op.span,\n-                                E0369,\n-                                \"{}\",\n-                                message.as_str()\n+                        (err, missing_trait, use_output, involves_fn)\n+                    }\n+                };\n+                let mut suggested_deref = false;\n+                if let Ref(_, rty, _) = lhs_ty.kind {\n+                    if {\n+                        self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n+                            && self\n+                                .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n+                                .is_ok()\n+                    } {\n+                        if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n+                            let msg = &format!(\n+                                \"`{}{}` can be used on `{}`, you can dereference `{}`\",\n+                                op.node.as_str(),\n+                                match is_assign {\n+                                    IsAssign::Yes => \"=\",\n+                                    IsAssign::No => \"\",\n+                                },\n+                                rty.peel_refs(),\n+                                lstring,\n                             );\n-\n-                            let mut involves_fn = false;\n-                            if !lhs_expr.span.eq(&rhs_expr.span) {\n-                                involves_fn |= self.add_type_neq_err_label(\n-                                    &mut err,\n-                                    lhs_expr.span,\n-                                    lhs_ty,\n-                                    rhs_ty,\n-                                    op,\n-                                    is_assign,\n-                                );\n-                                involves_fn |= self.add_type_neq_err_label(\n+                            err.span_suggestion_verbose(\n+                                lhs_expr.span.shrink_to_lo(),\n+                                msg,\n+                                \"*\".to_string(),\n+                                rustc_errors::Applicability::MachineApplicable,\n+                            );\n+                            suggested_deref = true;\n+                        }\n+                    }\n+                }\n+                if let Some(missing_trait) = missing_trait {\n+                    let mut visitor = TypeParamVisitor(vec![]);\n+                    visitor.visit_ty(lhs_ty);\n+\n+                    if op.node == hir::BinOpKind::Add\n+                        && self.check_str_addition(\n+                            lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, is_assign, op,\n+                        )\n+                    {\n+                        // This has nothing here because it means we did string\n+                        // concatenation (e.g., \"Hello \" + \"World!\"). This means\n+                        // we don't want the note in the else clause to be emitted\n+                    } else if let [ty] = &visitor.0[..] {\n+                        if let ty::Param(p) = ty.kind {\n+                            // Check if the method would be found if the type param wasn't\n+                            // involved. If so, it means that adding a trait bound to the param is\n+                            // enough. Otherwise we do not give the suggestion.\n+                            let mut eraser = TypeParamEraser(&self, expr.span);\n+                            let needs_bound = self\n+                                .lookup_op_method(\n+                                    eraser.fold_ty(lhs_ty),\n+                                    &[eraser.fold_ty(rhs_ty)],\n+                                    Op::Binary(op, is_assign),\n+                                )\n+                                .is_ok();\n+                            if needs_bound {\n+                                suggest_constraining_param(\n+                                    self.tcx,\n+                                    self.body_id,\n                                     &mut err,\n-                                    rhs_expr.span,\n+                                    ty,\n                                     rhs_ty,\n-                                    lhs_ty,\n-                                    op,\n-                                    is_assign,\n+                                    missing_trait,\n+                                    p,\n+                                    use_output,\n                                 );\n+                            } else if *ty != lhs_ty {\n+                                // When we know that a missing bound is responsible, we don't show\n+                                // this note as it is redundant.\n+                                err.note(&format!(\n+                                    \"the trait `{}` is not implemented for `{}`\",\n+                                    missing_trait, lhs_ty\n+                                ));\n                             }\n-\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        err.help(&format!(\n-                                            \"`{}` can be used on '{}', you can \\\n-                                            dereference `{2}`: `*{2}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring\n-                                        ));\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" + \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        use_output,\n-                                    );\n-                                } else if !suggested_deref && !involves_fn {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n-                            }\n-                            err.emit();\n+                        } else {\n+                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind);\n                         }\n+                    } else if !suggested_deref && !involves_fn {\n+                        suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                     }\n                 }\n+                err.emit();\n                 self.tcx.ty_error()\n             }\n         };\n@@ -570,7 +548,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         err: &mut rustc_errors::DiagnosticBuilder<'_>,\n-        is_assign: bool,\n+        is_assign: IsAssign,\n         op: hir::BinOp,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n@@ -593,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\"{:?}\", rhs_ty) == \"&&str\"\n                     ) =>\n             {\n-                if !is_assign { // Do not supply this message if `&str += &str`\n+                if let IsAssign::No = is_assign { // Do not supply this message if `&str += &str`\n                     err.span_label(\n                         op.span,\n                         \"`+` cannot be used to concatenate two `&str` strings\",\n@@ -634,7 +612,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n-                    (Ok(l), Ok(r), false) => {\n+                    (Ok(l), Ok(r), IsAssign::No) => {\n                         let to_string = if l.starts_with('&') {\n                             // let a = String::new(); let b = String::new();\n                             // let _ = &a + b;\n@@ -686,11 +664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                     err.span_label(\n                         ex.span,\n-                        format!(\n-                            \"cannot apply unary \\\n-                                                    operator `{}`\",\n-                            op.as_str()\n-                        ),\n+                        format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n                     match actual.kind {\n                         Uint(_) if op == hir::UnOp::UnNeg => {\n@@ -928,8 +902,7 @@ fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_tra\n     if let Adt(def, _) = ty.peel_refs().kind {\n         if def.did.is_local() {\n             err.note(&format!(\n-                \"an implementation of `{}` might \\\n-                be missing for `{}`\",\n+                \"an implementation of `{}` might be missing for `{}`\",\n                 missing_trait, ty\n             ));\n         }\n@@ -975,3 +948,32 @@ fn suggest_constraining_param(\n         err.span_label(span, msg);\n     }\n }\n+\n+struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n+\n+impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        if let ty::Param(_) = ty.kind {\n+            self.0.push(ty);\n+        }\n+        ty.super_visit_with(self)\n+    }\n+}\n+\n+struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n+\n+impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.0.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.kind {\n+            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::MiscVariable,\n+                span: self.1,\n+            }),\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "de9dc19af29beeb4b10fee7cfd4032fbb0cada71", "filename": "src/test/ui/binary-op-on-double-ref.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let vr = v.iter().filter(|x| {\n+        *x % 2 == 0\n+        //~^ ERROR cannot mod `&&{integer}` by `{integer}`\n+    });\n+    println!(\"{:?}\", vr);\n+}"}, {"sha": "2616c560cbefb6c320808d9086976a0b65ac570e", "filename": "src/test/ui/binary-op-on-double-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let vr = v.iter().filter(|x| {"}, {"sha": "02b0488488c555154537ef7829870465590c6071", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -1,12 +1,15 @@\n error[E0369]: cannot mod `&&{integer}` by `{integer}`\n-  --> $DIR/binary-op-on-double-ref.rs:4:11\n+  --> $DIR/binary-op-on-double-ref.rs:5:11\n    |\n LL |         x % 2 == 0\n    |         - ^ - {integer}\n    |         |\n    |         &&{integer}\n    |\n-   = help: `%` can be used on '{integer}', you can dereference `x`: `*x`\n+help: `%` can be used on `{integer}`, you can dereference `x`\n+   |\n+LL |         *x % 2 == 0\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "600cacc23aef5d1f24a51fba65c278f40722c621", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -5,6 +5,11 @@ LL |     a.iter().map(|a| a*a)\n    |                      -^- &T\n    |                      |\n    |                      &T\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "078a7ef2173bd349961bca1d9f8ff5eca58e788e", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -6,10 +6,10 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n    |\n-help: `+=` can be used on 'isize', you can dereference `x`\n+help: `+=` can be used on `isize`, you can dereference `x`\n    |\n LL |     let x = |ref x: isize| { *x += 1; };\n-   |                              ^^\n+   |                              ^\n \n error: aborting due to previous error\n "}, {"sha": "bea1b91558646a3d48283c052ca6b5a55fefa8cb", "filename": "src/test/ui/suggestions/invalid-bin-op.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,7 @@\n+pub fn foo<T>(s: S<T>, t: S<T>) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `S<T>`\n+}\n+\n+struct S<T>(T);\n+\n+fn main() {}"}, {"sha": "7668eddf6070ab102db3cf6fdc4d3c1cc29d86a0", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,13 @@\n+error[E0369]: binary operation `==` cannot be applied to type `S<T>`\n+  --> $DIR/invalid-bin-op.rs:2:15\n+   |\n+LL |     let _ = s == t;\n+   |             - ^^ - S<T>\n+   |             |\n+   |             S<T>\n+   |\n+   = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "6b24375e41503cc5cb14801243ec85ad745ce6df", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.fixed", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,7 @@\n+// run-rustfix\n+\n+pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+}\n+\n+fn main() {}"}, {"sha": "df47be070c9ea3fa0e03f2edd76d328ef3023eb7", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,7 @@\n+// run-rustfix\n+\n+pub fn foo<T>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+}\n+\n+fn main() {}"}, {"sha": "0e0d397d6fc1546df01e12ca9fe47c06046d182d", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -0,0 +1,16 @@\n+error[E0369]: binary operation `==` cannot be applied to type `&[T]`\n+  --> $DIR/missing-trait-bound-for-op.rs:4:15\n+   |\n+LL |     let _ = s == t;\n+   |             - ^^ - &[T]\n+   |             |\n+   |             &[T]\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "507d53dc07c4c9e4d2684db8afee0dfb3be963cf", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fb7765cdab6bd9d0dddd5275dd73775938af299/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=7fb7765cdab6bd9d0dddd5275dd73775938af299", "patch": "@@ -5,6 +5,11 @@ LL |     a * b\n    |     - ^ - f64\n    |     |\n    |     &T\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}