{"sha": "c417b98f02004a10819111903882482b39e50d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MTdiOThmMDIwMDRhMTA4MTkxMTE5MDM4ODI0ODJiMzllNTBkMTc=", "commit": {"author": {"name": "Evgenii P", "email": "eupn@protonmail.com", "date": "2019-08-02T18:15:43Z"}, "committer": {"name": "Evgenii P", "email": "eupn@protonmail.com", "date": "2019-08-02T18:15:43Z"}, "message": "Implement completion for the .await syntax", "tree": {"sha": "4ab6cce4d3b2c6dc5342cfa6ecfd04f281d8660b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ab6cce4d3b2c6dc5342cfa6ecfd04f281d8660b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c417b98f02004a10819111903882482b39e50d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c417b98f02004a10819111903882482b39e50d17", "html_url": "https://github.com/rust-lang/rust/commit/c417b98f02004a10819111903882482b39e50d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c417b98f02004a10819111903882482b39e50d17/comments", "author": {"login": "eupn", "id": 36292692, "node_id": "MDQ6VXNlcjM2MjkyNjky", "avatar_url": "https://avatars.githubusercontent.com/u/36292692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eupn", "html_url": "https://github.com/eupn", "followers_url": "https://api.github.com/users/eupn/followers", "following_url": "https://api.github.com/users/eupn/following{/other_user}", "gists_url": "https://api.github.com/users/eupn/gists{/gist_id}", "starred_url": "https://api.github.com/users/eupn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eupn/subscriptions", "organizations_url": "https://api.github.com/users/eupn/orgs", "repos_url": "https://api.github.com/users/eupn/repos", "events_url": "https://api.github.com/users/eupn/events{/privacy}", "received_events_url": "https://api.github.com/users/eupn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eupn", "id": 36292692, "node_id": "MDQ6VXNlcjM2MjkyNjky", "avatar_url": "https://avatars.githubusercontent.com/u/36292692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eupn", "html_url": "https://github.com/eupn", "followers_url": "https://api.github.com/users/eupn/followers", "following_url": "https://api.github.com/users/eupn/following{/other_user}", "gists_url": "https://api.github.com/users/eupn/gists{/gist_id}", "starred_url": "https://api.github.com/users/eupn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eupn/subscriptions", "organizations_url": "https://api.github.com/users/eupn/orgs", "repos_url": "https://api.github.com/users/eupn/repos", "events_url": "https://api.github.com/users/eupn/events{/privacy}", "received_events_url": "https://api.github.com/users/eupn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "831d39b0f7ed0041cbc2fb8beb4cb375ab9652b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/831d39b0f7ed0041cbc2fb8beb4cb375ab9652b1", "html_url": "https://github.com/rust-lang/rust/commit/831d39b0f7ed0041cbc2fb8beb4cb375ab9652b1"}], "stats": {"total": 133, "additions": 122, "deletions": 11}, "files": [{"sha": "8496b143aea6dda92456d97e069404b76ed92a18", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c417b98f02004a10819111903882482b39e50d17", "patch": "@@ -23,6 +23,7 @@ use crate::{\n         scope::{ExprScopes, ScopeId},\n         BodySourceMap,\n     },\n+    ty::method_resolution::implements_trait,\n     ids::LocationCtx,\n     AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HirDatabase, HirFileId,\n     MacroDef, Module, Name, Path, PerNs, Resolver, Static, Struct, Trait, Ty,\n@@ -409,6 +410,42 @@ impl SourceAnalyzer {\n         crate::ty::autoderef(db, &self.resolver, canonical).map(|canonical| canonical.value)\n     }\n \n+    /// Checks that particular type `ty` implements `std::future::Future` trait.\n+    /// This function is used in `.await` syntax completion.\n+    pub fn impls_future(&self, db: &impl HirDatabase, ty: Ty) -> bool {\n+        // Search for std::future::Future trait in scope\n+        let future_trait = self.resolver.traits_in_scope(db)\n+            .into_iter()\n+            .filter(|t| {\n+                let std = t.module(db).parent(db)\n+                    .and_then(|m| m\n+                        .name(db)\n+                        .and_then(|n| Some(n.to_string() == \"std\")))\n+                    .unwrap_or(false);\n+\n+                let future = t.module(db).name(db)\n+                    .and_then(|n| Some(n.to_string() == \"future\"))\n+                    .unwrap_or(false);\n+\n+                let future_trait = t.name(db)\n+                    .and_then(|n| Some(n.to_string() == \"Future\"))\n+                    .unwrap_or(false);\n+\n+                std && future && future_trait\n+            })\n+            .nth(0);\n+\n+        if let Some(trait_) = future_trait {\n+            let krate = self.resolver.krate();\n+            if let Some(krate) = krate {\n+                let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n+                return implements_trait(&canonical_ty, db, &self.resolver, krate, trait_);\n+            }\n+        }\n+\n+        false\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()"}, {"sha": "2e2f881388a4ad360ebb9ff89c57854384780b81", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=c417b98f02004a10819111903882482b39e50d17", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     resolve::Resolver,\n     traits::TraitItem,\n     ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n-    ty::{Ty, TypeCtor},\n+    ty::{Ty, TypeCtor, traits::Solution},\n     Crate, Function, HirDatabase, Module, Name, Trait,\n };\n \n@@ -255,6 +255,20 @@ fn iterate_inherent_methods<T>(\n     None\n }\n \n+pub(crate) fn implements_trait(ty: &Canonical<Ty>, db: &impl HirDatabase, resolver: &Resolver, krate: Crate, trait_: Trait) -> bool {\n+    let env = lower::trait_env(db, resolver);\n+    let goal = generic_implements_goal(db, env.clone(), trait_, ty.clone());\n+    let solution = db.trait_solve(krate, goal);\n+\n+    if let Some(solution) = solution {\n+        if let Solution::Unique(_) = solution {\n+            return true\n+        }\n+    }\n+\n+    false\n+}\n+\n impl Ty {\n     // This would be nicer if it just returned an iterator, but that runs into\n     // lifetime problems, because we need to borrow temp `CrateImplBlocks`."}, {"sha": "b6579be63f8c9799fb85d38ac46496f2a44bed86", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c417b98f02004a10819111903882482b39e50d17/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=c417b98f02004a10819111903882482b39e50d17", "patch": "@@ -1,19 +1,49 @@\n use hir::{AdtDef, Ty, TypeCtor};\n \n-use crate::completion::{CompletionContext, Completions};\n+use crate::{completion::{\n+    completion_context::CompletionContext,\n+    completion_item::Completions,\n+}, CompletionItem};\n+use ra_syntax::ast::AstNode;\n+use ra_text_edit::TextEditBuilder;\n use rustc_hash::FxHashSet;\n+use crate::completion::completion_item::{Builder, CompletionKind};\n+use ra_syntax::TextRange;\n \n-/// Complete dot accesses, i.e. fields or methods (currently only fields).\n+/// Applies postfix edition but with CompletionKind::Reference\n+fn postfix_reference(ctx: &CompletionContext, label: &str, detail: &str, snippet: &str) -> Builder {\n+    let edit = {\n+        let receiver_range =\n+            ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax().text_range();\n+        let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(delete_range, snippet.to_string());\n+        builder.finish()\n+    };\n+    CompletionItem::new(CompletionKind::Reference, ctx.source_range(), label)\n+        .detail(detail)\n+        .snippet_edit(edit)\n+}\n+\n+/// Complete dot accesses, i.e. fields or methods (and .await syntax).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let receiver_ty =\n-        match ctx.dot_receiver.as_ref().and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n-            Some(it) => it,\n-            None => return,\n-        };\n-    if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty.clone());\n+    if let Some(dot_receiver) = &ctx.dot_receiver {\n+        let receiver_text = dot_receiver.syntax().text().to_string();\n+        let receiver_ty = ctx.analyzer.type_of(ctx.db, &dot_receiver);\n+\n+        if let Some(receiver_ty) = receiver_ty {\n+            if !ctx.is_call {\n+                complete_fields(acc, ctx, receiver_ty.clone());\n+            }\n+            complete_methods(acc, ctx, receiver_ty.clone());\n+\n+            // Suggest .await syntax for types that implement std::future::Future\n+            if ctx.analyzer.impls_future(ctx.db, receiver_ty) {\n+                postfix_reference(ctx, \".await\", \"expr.await\", &format!(\"{}.await\", receiver_text))\n+                    .add_to(acc);\n+            }\n+        }\n     }\n-    complete_methods(acc, ctx, receiver_ty);\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n@@ -406,4 +436,34 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn test_completion_await_impls_future() {\n+        assert_debug_snapshot_matches!(\n+        do_ref_completion(\n+            r\"\n+            // Mock Future trait from stdlib\n+            pub mod std { pub mod future { pub trait Future {} } }\n+\n+            use std::future::*;\n+            struct A {}\n+            impl Future for A {}\n+\n+            fn foo(a: A) {\n+                a.<|>\n+            }\n+            \"),\n+        @r###\"\n+       \u22ee[\n+       \u22ee    CompletionItem {\n+       \u22ee        label: \".await\",\n+       \u22ee        source_range: [249; 249),\n+       \u22ee        delete: [247; 249),\n+       \u22ee        insert: \"a.await\",\n+       \u22ee        detail: \"expr.await\",\n+       \u22ee    },\n+       \u22ee]\n+        \"###\n+        )\n+    }\n }"}]}