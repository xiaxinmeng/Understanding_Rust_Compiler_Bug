{"sha": "7c27cce9e59bbbc1e556de257de85122dad88dcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMjdjY2U5ZTU5YmJiYzFlNTU2ZGUyNTdkZTg1MTIyZGFkODhkY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-13T02:22:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-13T02:22:32Z"}, "message": "Auto merge of #32803 - eddyb:mir-debuginfo, r=nikomatsakis\n\nInitial implementation of debuginfo in MIR trans.\n\nProgress is made towards #31005, but several issues remain, such as #32790.", "tree": {"sha": "8408e6afd554330489cdbefa02c9b05019804632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8408e6afd554330489cdbefa02c9b05019804632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c27cce9e59bbbc1e556de257de85122dad88dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c27cce9e59bbbc1e556de257de85122dad88dcd", "html_url": "https://github.com/rust-lang/rust/commit/7c27cce9e59bbbc1e556de257de85122dad88dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c27cce9e59bbbc1e556de257de85122dad88dcd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a43eb4e774f6d51b7012bba3d25212819ab0e3dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a43eb4e774f6d51b7012bba3d25212819ab0e3dc", "html_url": "https://github.com/rust-lang/rust/commit/a43eb4e774f6d51b7012bba3d25212819ab0e3dc"}, {"sha": "373b6ec935fb64767d03da9a79d4614ccbb3f084", "url": "https://api.github.com/repos/rust-lang/rust/commits/373b6ec935fb64767d03da9a79d4614ccbb3f084", "html_url": "https://github.com/rust-lang/rust/commit/373b6ec935fb64767d03da9a79d4614ccbb3f084"}], "stats": {"total": 1195, "additions": 560, "deletions": 635}, "files": [{"sha": "75866e3cdaaa769ee588aa9a0e31b0c69877a0d0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -868,27 +868,11 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n         \"-g\".to_owned(),\n         \"--debuginfo\".to_owned()\n     ];\n-    let mut new_options =\n+    let new_options =\n         split_maybe_args(options).into_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n                                  .collect::<Vec<String>>();\n \n-    let mut i = 0;\n-    while i + 1 < new_options.len() {\n-        if new_options[i] == \"-Z\" {\n-            // FIXME #31005 MIR missing debuginfo currently.\n-            if new_options[i + 1] == \"orbit\" {\n-                // Remove \"-Z\" and \"orbit\".\n-                new_options.remove(i);\n-                new_options.remove(i);\n-                continue;\n-            }\n-            // Always skip over -Z's argument.\n-            i += 1;\n-        }\n-        i += 1;\n-    }\n-\n     Some(new_options.join(\" \"))\n }\n "}, {"sha": "aacb3aae81c5e1124aa38ee17a6553d7dba74d1c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -698,6 +698,7 @@ impl ScopeId {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ScopeData {\n+    pub span: Span,\n     pub parent_scope: Option<ScopeId>,\n }\n "}, {"sha": "87f0139104952054aad3798c1672bc644a5d5b5f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -298,9 +298,11 @@ macro_rules! make_mir_visitor {\n             fn super_scope_data(&mut self,\n                                 scope_data: & $($mutability)* ScopeData) {\n                 let ScopeData {\n+                    ref $($mutability)* span,\n                     ref $($mutability)* parent_scope,\n                 } = *scope_data;\n \n+                self.visit_span(span);\n                 if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n                     self.visit_scope_id(parent_scope);\n                 }"}, {"sha": "84fda62067d95910377aa81eafe0372840dcc426", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -255,7 +255,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"push_scope({:?})\", extent);\n         let parent_id = self.scopes.last().map(|s| s.id);\n         let id = ScopeId::new(self.scope_datas.len());\n+        let tcx = self.hir.tcx();\n         self.scope_datas.push(ScopeData {\n+            span: extent.span(&tcx.region_maps, &tcx.map).unwrap_or(DUMMY_SP),\n             parent_scope: parent_id,\n         });\n         self.scopes.push(Scope {"}, {"sha": "e9c9edd118353e7220ad6a78fce0ff1c2bcb0989", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -242,7 +242,11 @@ fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n         if var.mutability == Mutability::Mut {\n             write!(w, \"mut \")?;\n         }\n-        writeln!(w, \"{:?}: {}; // {}\", Lvalue::Var(i as u32), var.ty, var.name)?;\n+        writeln!(w, \"{:?}: {}; // {} in {}\",\n+                 Lvalue::Var(i as u32),\n+                 var.ty,\n+                 var.name,\n+                 comment(tcx, var.scope, var.span))?;\n     }\n \n     // Compiler-introduced temporary types."}, {"sha": "464e5c0cf1c1d6823d7ea565c3e8e7ce17242122", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -1276,7 +1276,7 @@ pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n-    debuginfo::clear_source_location(cx.fcx);\n+    DebugLoc::None.apply(cx.fcx);\n     Alloca(cx, ty, name)\n }\n \n@@ -1400,23 +1400,23 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               def_id: Option<DefId>,\n-               param_substs: &'tcx Substs<'tcx>,\n+               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n                block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n-        common::validate_substs(param_substs);\n+        let (param_substs, def_id) = match definition {\n+            Some((instance, _, _)) => {\n+                common::validate_substs(instance.substs);\n+                (instance.substs, Some(instance.def))\n+            }\n+            None => (ccx.tcx().mk_substs(Substs::empty()), None)\n+        };\n \n         let inlined_did = def_id.and_then(|def_id| inline::get_local_instance(ccx, def_id));\n         let inlined_id = inlined_did.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n \n-        debug!(\"FunctionContext::new(path={}, def_id={:?}, param_substs={:?})\",\n-            inlined_id.map_or(String::new(), |id| ccx.tcx().node_path_str(id)),\n-            def_id,\n-            param_substs);\n-\n-        let debug_context = debuginfo::create_function_debug_context(ccx,\n-            inlined_id.unwrap_or(ast::DUMMY_NODE_ID), param_substs, llfndecl);\n+        debug!(\"FunctionContext::new({})\",\n+               definition.map_or(String::new(), |d| d.0.to_string()));\n \n         let cfg = inlined_id.map(|id| build_cfg(ccx.tcx(), id));\n         let nested_returns = if let Some((blk_id, Some(ref cfg))) = cfg {\n@@ -1428,10 +1428,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let check_attrs = |attrs: &[ast::Attribute]| {\n             let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n             let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n-            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n+            (default_to_mir ^ attrs.iter().any(|item| item.check_name(invert)),\n+             attrs.iter().any(|item| item.check_name(\"no_debug\")))\n         };\n \n-        let use_mir = if let Some(id) = local_id {\n+        let (use_mir, no_debug) = if let Some(id) = local_id {\n             check_attrs(ccx.tcx().map.attrs(id))\n         } else if let Some(def_id) = def_id {\n             check_attrs(&ccx.sess().cstore.item_attrs(def_id))\n@@ -1445,6 +1446,13 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             None\n         };\n \n+        let debug_context = if let (false, Some(definition)) = (no_debug, definition) {\n+            let (instance, sig, abi) = definition;\n+            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl)\n+        } else {\n+            debuginfo::empty_function_debug_context(ccx)\n+        };\n+\n         FunctionContext {\n             needs_ret_allocas: nested_returns && mir.is_none(),\n             mir: mir,\n@@ -1731,7 +1739,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         self.build_return_block(ret_cx, ret_debug_loc);\n \n-        debuginfo::clear_source_location(self);\n+        DebugLoc::None.apply(self);\n         self.cleanup();\n     }\n \n@@ -1810,32 +1818,34 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                decl: &hir::FnDecl,\n                                body: &hir::Block,\n                                llfndecl: ValueRef,\n-                               param_substs: &'tcx Substs<'tcx>,\n-                               def_id: DefId,\n+                               instance: Instance<'tcx>,\n                                inlined_id: ast::NodeId,\n-                               fn_ty: FnType,\n+                               sig: &ty::FnSig<'tcx>,\n                                abi: Abi,\n                                closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     if collector::collecting_debug_information(ccx) {\n-        ccx.record_translation_item_as_generated(\n-            TransItem::Fn(Instance::new(def_id, param_substs)));\n+        ccx.record_translation_item_as_generated(TransItem::Fn(instance));\n     }\n \n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n-    debug!(\"trans_closure(..., param_substs={:?})\", param_substs);\n+    debug!(\"trans_closure(..., {})\", instance);\n+\n+    let fn_ty = FnType::new(ccx, abi, sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some(def_id), param_substs, &arena);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some((instance, sig, abi)), &arena);\n \n     if fcx.mir.is_some() {\n         return mir::trans_mir(&fcx);\n     }\n \n+    debuginfo::fill_scope_map_for_function(&fcx, decl, body, inlined_id);\n+\n     // cleanup scope for the incoming arguments\n     let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(\n         ccx, inlined_id, body.span, true);\n@@ -1890,10 +1900,8 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id, fn_cleanup_debug_loc.span);\n-\n     // Insert the mandatory first few basic blocks before lltop.\n-    fcx.finish(bcx, ret_debug_loc);\n+    fcx.finish(bcx, fn_cleanup_debug_loc.debug_loc());\n }\n \n /// Creates an LLVM function corresponding to a source language function.\n@@ -1906,25 +1914,23 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(id));\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n-    let fn_ty = ccx.tcx().node_id_to_type(id);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let abi = fn_ty.fn_abi();\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n     let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n         def_id\n     } else {\n         ccx.tcx().map.local_def_id(id)\n     };\n+    let fn_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n+    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+    let abi = fn_ty.fn_abi();\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfndecl,\n-                  param_substs,\n-                  def_id,\n+                  Instance::new(def_id, param_substs),\n                   id,\n-                  fn_ty,\n+                  &sig,\n                   abi,\n                   closure::ClosureEnv::NotClosure);\n }\n@@ -2015,9 +2021,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty,\n-                               Some(ccx.tcx().map.local_def_id(ctor_id)),\n-                               param_substs, &arena);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, &arena);\n     let bcx = fcx.init(false, None);\n \n     assert!(!fcx.needs_ret_allocas);"}, {"sha": "7675e1de958277426a9a2f9b374e6ee342caf537", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -24,7 +24,6 @@ use middle::cstore::LOCAL_CRATE;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n use rustc::ty::subst;\n-use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::hir::map as hir_map;\n use abi::{Abi, FnType};\n@@ -385,10 +384,9 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n \n     //\n-    let empty_substs = tcx.mk_substs(Substs::empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n     let mut bcx = fcx.init(false, None);\n \n     let llargs = get_params(fcx.llfn);"}, {"sha": "c2031638044fb02dad9575aab0913d6b4b731583", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -234,16 +234,14 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n         output: sig.output,\n         variadic: false\n     };\n-    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n \n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn,\n-                  param_substs,\n-                  closure_def_id,\n+                  Instance::new(closure_def_id, param_substs),\n                   id,\n-                  fn_ty,\n+                  &sig,\n                   Abi::RustCall,\n                   ClosureEnv::Closure(closure_def_id, id));\n \n@@ -387,7 +385,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, substs.func_substs, &block_arena);\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n     let mut bcx = fcx.init(false, None);\n \n "}, {"sha": "f793f0a6d553ba8ec1326a3e3cbdf33348356e35", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -167,11 +167,11 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if cv == 1 {\n             // if true { .. } [else { .. }]\n             bcx = trans_block(bcx, &thn, dest);\n-            debuginfo::clear_source_location(bcx.fcx);\n+            DebugLoc::None.apply(bcx.fcx);\n         } else {\n             if let Some(elexpr) = els {\n                 bcx = expr::trans_into(bcx, &elexpr, dest);\n-                debuginfo::clear_source_location(bcx.fcx);\n+                DebugLoc::None.apply(bcx.fcx);\n             }\n         }\n \n@@ -181,7 +181,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &thn, dest);\n-    debuginfo::clear_source_location(bcx.fcx);\n+    DebugLoc::None.apply(bcx.fcx);\n \n     let cond_source_loc = cond.debug_loc();\n \n@@ -204,7 +204,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Clear the source location because it is still set to whatever has been translated\n     // right before.\n-    debuginfo::clear_source_location(next_bcx.fcx);\n+    DebugLoc::None.apply(next_bcx.fcx);\n \n     next_bcx\n }"}, {"sha": "3eebd1f5ea25a0bbafa49ad23dbcc9b06e8bc364", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,19 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::FunctionDebugContext;\n use super::metadata::file_metadata;\n-use super::utils::DIB;\n+use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n-use common::CrateContext;\n+use common::{CrateContext, FunctionContext};\n use rustc::hir::pat_util;\n+use rustc::mir::repr::{Mir, ScopeId};\n use rustc::util::nodemap::NodeMap;\n \n use libc::c_uint;\n+use std::ptr;\n+\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n@@ -65,6 +70,74 @@ pub fn create_scope_map(cx: &CrateContext,\n     return scope_map;\n }\n \n+/// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n+/// If debuginfo is disabled, the returned vector is empty.\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n+    let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n+    let mut scopes = vec![ptr::null_mut(); mir.scopes.len()];\n+\n+    let fn_metadata = match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n+        FunctionDebugContext::DebugInfoDisabled |\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            return scopes;\n+        }\n+    };\n+\n+    // Find all the scopes with variables defined in them.\n+    let mut has_variables = BitVector::new(mir.scopes.len());\n+    for var in &mir.var_decls {\n+        has_variables.insert(var.scope.index());\n+    }\n+\n+    // Instantiate all scopes.\n+    for idx in 0..mir.scopes.len() {\n+        let scope = ScopeId::new(idx);\n+        make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+    }\n+\n+    scopes\n+}\n+\n+fn make_mir_scope(ccx: &CrateContext,\n+                  mir: &Mir,\n+                  has_variables: &BitVector,\n+                  fn_metadata: DISubprogram,\n+                  scope: ScopeId,\n+                  scopes: &mut [DIScope]) {\n+    let idx = scope.index();\n+    if !scopes[idx].is_null() {\n+        return;\n+    }\n+\n+    let scope_data = &mir.scopes[scope];\n+    let parent_scope = if let Some(parent) = scope_data.parent_scope {\n+        make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n+        scopes[parent.index()]\n+    } else {\n+        // The root is the function itself.\n+        scopes[idx] = fn_metadata;\n+        return;\n+    };\n+\n+    scopes[idx] = if !has_variables.contains(idx) {\n+        // Do not create a DIScope if there are no variables\n+        // defined in this MIR Scope, to avoid debuginfo bloat.\n+        parent_scope\n+    } else {\n+        let loc = span_start(ccx, scope_data.span);\n+        let file_metadata = file_metadata(ccx, &loc.file.name);\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                DIB(ccx),\n+                parent_scope,\n+                file_metadata,\n+                loc.line as c_uint,\n+                loc.col.to_usize() as c_uint)\n+        }\n+    };\n+}\n+\n // local helper functions for walking the AST.\n fn with_new_scope<F>(cx: &CrateContext,\n                      scope_span: Span,\n@@ -74,7 +147,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n {\n     // Create a new lexical scope and push it onto the stack\n-    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let loc = span_start(cx, scope_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n@@ -199,7 +272,7 @@ fn walk_pattern(cx: &CrateContext,\n \n                 if need_new_scope {\n                     // Create a new lexical scope and push it onto the stack\n-                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let loc = span_start(cx, pat.span);\n                     let file_metadata = file_metadata(cx, &loc.file.name);\n                     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n "}, {"sha": "de403732269febe8ec18cdcd28c8d5fb3bae970c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -16,7 +16,7 @@ use self::EnumDiscriminantInfo::*;\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                    get_namespace_and_span_for_item, create_DIArray,\n                    fn_should_be_ignored, is_node_local_to_unit};\n-use super::namespace::namespace_for_item;\n+use super::namespace::mangled_name_of_item;\n use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n use super::{declare_local, VariableKind, VariableAccess};\n \n@@ -68,8 +68,8 @@ pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-const NO_FILE_METADATA: DIFile = (0 as DIFile);\n-const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n+pub const NO_FILE_METADATA: DIFile = (0 as DIFile);\n+pub const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n const FLAGS_NONE: c_uint = 0;\n \n@@ -1846,28 +1846,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n-    let var_item = cx.tcx().map.get(node_id);\n-\n-    let (name, span) = match var_item {\n-        hir_map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemStatic(..) => (item.name, item.span),\n-                hir::ItemConst(..) => (item.name, item.span),\n-                _ => {\n-                    span_bug!(item.span,\n-                              \"debuginfo::\\\n-                               create_global_var_metadata() -\n-                               Captured var-id refers to \\\n-                               unexpected ast_item variant: {:?}\",\n-                              var_item)\n-                }\n-            }\n-        },\n-        _ => bug!(\"debuginfo::create_global_var_metadata() \\\n-                   - Captured var-id refers to unexpected \\\n-                   hir_map variant: {:?}\",\n-                  var_item)\n-    };\n+    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1879,12 +1859,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let node_def_id = cx.tcx().map.local_def_id(node_id);\n-    let namespace_node = namespace_for_item(cx, node_def_id);\n-    let var_name = name.to_string();\n-    let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n-    let var_scope = namespace_node.scope;\n+    let var_name = cx.tcx().item_name(node_def_id).to_string();\n+    let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");\n \n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();"}, {"sha": "371f6b5efaa94ac72af1204f9aadb8a329537c12", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 109, "deletions": 264, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -14,42 +14,38 @@ mod doc;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n \n-use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n-                  create_DIArray, is_node_local_to_unit};\n-use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit,\n+                  get_namespace_and_span_for_item};\n+use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n use self::metadata::{file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n-use self::source_loc::InternalDebugLocation;\n+use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n-                      DIDescriptor, FlagPrototyped};\n+                      FlagPrototyped};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::normalize_associated_type;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::hir::map::DefPathData;\n+use rustc::ty::subst::Substs;\n use rustc::hir;\n \n use abi::Abi;\n-use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n-use monomorphize;\n-use rustc::infer;\n+use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block, BlockAndBuilder};\n+use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n-use rustc::hir::map as hir_map;\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n use std::ptr;\n-use std::rc::Rc;\n \n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n use syntax::attr::IntType;\n-use syntax::parse::token::{self, special_idents};\n \n pub mod gdb;\n mod utils;\n@@ -59,8 +55,7 @@ mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::source_loc::set_source_location;\n-pub use self::source_loc::clear_source_location;\n+pub use self::create_scope_map::create_mir_scopes;\n pub use self::source_loc::start_emitting_source_locations;\n pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n pub use self::source_loc::with_source_location_override;\n@@ -84,7 +79,7 @@ pub struct CrateDebugContext<'tcx> {\n     created_enum_disr_types: RefCell<FnvHashMap<(DefId, IntType), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n-    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+    namespace_map: RefCell<DefIdMap<DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n@@ -104,7 +99,7 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             created_files: RefCell::new(FnvHashMap()),\n             created_enum_disr_types: RefCell::new(FnvHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n-            namespace_map: RefCell::new(FnvHashMap()),\n+            namespace_map: RefCell::new(DefIdMap()),\n             composite_types_completed: RefCell::new(FnvHashSet()),\n         };\n     }\n@@ -214,121 +209,39 @@ pub fn finalize(cx: &CrateContext) {\n     };\n }\n \n+/// Creates a function-specific debug context for a function w/o debuginfo.\n+pub fn empty_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>)\n+                                              -> FunctionDebugContext {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n+        return FunctionDebugContext::DebugInfoDisabled;\n+    }\n+\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    source_loc::set_debug_location(cx, None, UnknownLocation);\n+    FunctionDebugContext::FunctionWithoutDebugInfo\n+}\n+\n /// Creates the function-specific debug context.\n ///\n /// Returns the FunctionDebugContext for the function which holds state needed\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                               fn_ast_id: ast::NodeId,\n-                                               param_substs: &Substs<'tcx>,\n+                                               instance: Instance<'tcx>,\n+                                               sig: &ty::FnSig<'tcx>,\n+                                               abi: Abi,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n     // Do this here already, in case we do an early exit from this function.\n-    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n-\n-    if fn_ast_id == ast::DUMMY_NODE_ID {\n-        // This is a function not linked to any source location, so don't\n-        // generate debuginfo for it.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-    }\n-\n-    let empty_generics = hir::Generics::empty();\n-\n-    let fnitem = cx.tcx().map.get(fn_ast_id);\n-\n-    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n-        hir_map::NodeItem(ref item) => {\n-            if contains_nodebug_attribute(&item.attrs) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n-            }\n-\n-            match item.node {\n-                hir::ItemFn(ref fn_decl, _, _, _, ref generics, ref top_level_block) => {\n-                    (item.name, fn_decl, generics, top_level_block, item.span, true)\n-                }\n-                _ => {\n-                    span_bug!(item.span,\n-                        \"create_function_debug_context: item bound to non-function\");\n-                }\n-            }\n-        }\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    if contains_nodebug_attribute(&impl_item.attrs) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-                    }\n-\n-                    (impl_item.name,\n-                     &sig.decl,\n-                     &sig.generics,\n-                     body,\n-                     impl_item.span,\n-                     true)\n-                }\n-                _ => {\n-                    span_bug!(impl_item.span,\n-                              \"create_function_debug_context() \\\n-                               called on non-method impl item?!\")\n-                }\n-            }\n-        }\n-        hir_map::NodeExpr(ref expr) => {\n-            match expr.node {\n-                hir::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n-                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::intern(&name[..]);\n-                    (name, fn_decl,\n-                        // This is not quite right. It should actually inherit\n-                        // the generics of the enclosing function.\n-                        &empty_generics,\n-                        top_level_block,\n-                        expr.span,\n-                        // Don't try to lookup the item path:\n-                        false)\n-                }\n-                _ => span_bug!(expr.span,\n-                        \"create_function_debug_context: expected an expr_fn_block here\")\n-            }\n-        }\n-        hir_map::NodeTraitItem(trait_item) => {\n-            match trait_item.node {\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    if contains_nodebug_attribute(&trait_item.attrs) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-                    }\n-\n-                    (trait_item.name,\n-                     &sig.decl,\n-                     &sig.generics,\n-                     body,\n-                     trait_item.span,\n-                     true)\n-                }\n-                _ => {\n-                    bug!(\"create_function_debug_context: \\\n-                          unexpected sort of node: {:?}\",\n-                         fnitem)\n-                }\n-            }\n-        }\n-        hir_map::NodeForeignItem(..) |\n-        hir_map::NodeVariant(..) |\n-        hir_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n-        }\n-        _ => bug!(\"create_function_debug_context: \\\n-                   unexpected sort of node: {:?}\",\n-                  fnitem)\n-    };\n+    source_loc::set_debug_location(cx, None, UnknownLocation);\n \n     // This can be the case for functions inlined from another crate\n+    let (containing_scope, span) = get_namespace_and_span_for_item(cx, instance.def);\n     if span == codemap::DUMMY_SP {\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n@@ -337,44 +250,38 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx,\n-                                                  fn_ast_id,\n-                                                  param_substs,\n-                                                  span);\n+        let fn_signature = get_function_signature(cx, sig, abi);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n+    // Find the enclosing function, in case this is a closure.\n+    let mut fn_def_id = instance.def;\n+    let mut def_key = cx.tcx().def_key(fn_def_id);\n+    let mut name = def_key.disambiguated_data.data.to_string();\n+    let name_len = name.len();\n+    while def_key.disambiguated_data.data == DefPathData::ClosureExpr {\n+        fn_def_id.index = def_key.parent.expect(\"closure without a parent?\");\n+        def_key = cx.tcx().def_key(fn_def_id);\n+    }\n+\n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = name.to_string();\n+    let generics = cx.tcx().lookup_item_type(fn_def_id).generics;\n     let template_parameters = get_template_parameters(cx,\n-                                                      generics,\n-                                                      param_substs,\n+                                                      &generics,\n+                                                      instance.substs,\n                                                       file_metadata,\n-                                                      &mut function_name);\n-\n-    // There is no hir_map::Path for hir::ExprClosure-type functions. For now,\n-    // just don't put them into a namespace. In the future this could be improved\n-    // somehow (storing a path in the hir_map, or construct a path using the\n-    // enclosing function).\n-    let (linkage_name, containing_scope) = if has_path {\n-        let fn_ast_def_id = cx.tcx().map.local_def_id(fn_ast_id);\n-        let namespace_node = namespace_for_item(cx, fn_ast_def_id);\n-        let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            &function_name[..]);\n-        let containing_scope = namespace_node.scope;\n-        (linkage_name, containing_scope)\n-    } else {\n-        (function_name.clone(), file_metadata)\n-    };\n+                                                      &mut name);\n+\n+    // Build the linkage_name out of the item path and \"template\" parameters.\n+    let linkage_name = mangled_name_of_item(cx, instance.def, &name[name_len..]);\n \n-    // Clang sets this parameter to the opening brace of the function's block,\n-    // so let's do this too.\n-    let scope_line = span_start(cx, top_level_block.span).line;\n+    let scope_line = span_start(cx, span).line;\n \n-    let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n+    let local_id = cx.tcx().map.as_local_node_id(instance.def);\n+    let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n-    let function_name = CString::new(function_name).unwrap();\n+    let function_name = CString::new(name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n     let fn_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFunction(\n@@ -395,54 +302,24 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ptr::null_mut())\n     };\n \n-    let scope_map = create_scope_map::create_scope_map(cx,\n-                                                       &fn_decl.inputs,\n-                                                       &top_level_block,\n-                                                       fn_metadata,\n-                                                       fn_ast_id);\n-\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(scope_map),\n+        scope_map: RefCell::new(NodeMap()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n         source_location_override: Cell::new(false),\n     };\n \n-\n-\n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        fn_ast_id: ast::NodeId,\n-                                        param_substs: &Substs<'tcx>,\n-                                        error_reporting_span: Span) -> DIArray {\n+                                        sig: &ty::FnSig<'tcx>,\n+                                        abi: Abi) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n-        // Return type -- llvm::DIBuilder wants this at index 0\n-        assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n-        let fn_type = cx.tcx().node_id_to_type(fn_ast_id);\n-        let fn_type = monomorphize::apply_param_substs(cx.tcx(), param_substs, &fn_type);\n-\n-        let (sig, abi) = match fn_type.sty {\n-            ty::TyFnDef(_, _, ref barefnty) | ty::TyFnPtr(ref barefnty) => {\n-                let sig = cx.tcx().erase_late_bound_regions(&barefnty.sig);\n-                let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-                (sig, barefnty.abi)\n-            }\n-            ty::TyClosure(def_id, ref substs) => {\n-                let closure_type = cx.tcx().closure_type(def_id, substs);\n-                let sig = cx.tcx().erase_late_bound_regions(&closure_type.sig);\n-                let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-                (sig, closure_type.abi)\n-            }\n-\n-            _ => bug!(\"get_function_metdata: Expected a function type!\")\n-        };\n-\n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n@@ -477,86 +354,39 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         generics: &hir::Generics,\n+                                         generics: &ty::Generics<'tcx>,\n                                          param_substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let self_type = param_substs.self_ty();\n-        let self_type = normalize_associated_type(cx.tcx(), &self_type);\n-\n-        // Only true for static default methods:\n-        let has_self_type = self_type.is_some();\n+        let actual_types = param_substs.types.as_slice();\n \n-        if !generics.is_type_parameterized() && !has_self_type {\n+        if actual_types.is_empty() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n         name_to_append_suffix_to.push('<');\n-\n-        // The list to be filled with template parameters:\n-        let mut template_params: Vec<DIDescriptor> =\n-            Vec::with_capacity(generics.ty_params.len() + 1);\n-\n-        // Handle self type\n-        if has_self_type {\n-            let actual_self_type = self_type.unwrap();\n-            // Add self type name to <...> clause of function name\n-            let actual_self_type_name = compute_debuginfo_type_name(\n-                cx,\n-                actual_self_type,\n-                true);\n-\n-            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n-\n-            if generics.is_type_parameterized() {\n-                name_to_append_suffix_to.push_str(\",\");\n-            }\n-\n-            // Only create type information if full debuginfo is enabled\n-            if cx.sess().opts.debuginfo == FullDebugInfo {\n-                let actual_self_type_metadata = type_metadata(cx,\n-                                                              actual_self_type,\n-                                                              codemap::DUMMY_SP);\n-\n-                let name = special_idents::type_self.name.as_str();\n-\n-                let name = CString::new(name.as_bytes()).unwrap();\n-                let param_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        ptr::null_mut(),\n-                        name.as_ptr(),\n-                        actual_self_type_metadata,\n-                        file_metadata,\n-                        0,\n-                        0)\n-                };\n-\n-                template_params.push(param_metadata);\n-            }\n-        }\n-\n-        // Handle other generic parameters\n-        let actual_types = param_substs.types.get_slice(subst::FnSpace);\n-        for (index, &hir::TyParam{ name, .. }) in generics.ty_params.iter().enumerate() {\n-            let actual_type = actual_types[index];\n+        for (i, &actual_type) in actual_types.iter().enumerate() {\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n             name_to_append_suffix_to.push_str(&actual_type_name[..]);\n \n-            if index != generics.ty_params.len() - 1 {\n+            if i != actual_types.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n+        }\n+        name_to_append_suffix_to.push('>');\n \n-            // Again, only create type information if full debuginfo is enabled\n-            if cx.sess().opts.debuginfo == FullDebugInfo {\n+        // Again, only create type information if full debuginfo is enabled\n+        let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n+            generics.types.as_slice().iter().enumerate().map(|(i, param)| {\n+                let actual_type = actual_types[i];\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let name = CString::new(name.as_str().as_bytes()).unwrap();\n-                let param_metadata = unsafe {\n+                let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n+                unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n                         ptr::null_mut(),\n@@ -565,24 +395,42 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         file_metadata,\n                         0,\n                         0)\n-                };\n-                template_params.push(param_metadata);\n-            }\n-        }\n-\n-        name_to_append_suffix_to.push('>');\n+                }\n+            }).collect()\n+        } else {\n+            vec![]\n+        };\n \n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n }\n \n-fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             variable_name: ast::Name,\n-                             variable_type: Ty<'tcx>,\n-                             scope_metadata: DIScope,\n-                             variable_access: VariableAccess,\n-                             variable_kind: VariableKind,\n-                             span: Span) {\n+/// Computes the scope map for a function given its declaration and body.\n+pub fn fill_scope_map_for_function<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                             fn_decl: &hir::FnDecl,\n+                                             top_level_block: &hir::Block,\n+                                             fn_ast_id: ast::NodeId) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            let scope_map = create_scope_map::create_scope_map(fcx.ccx,\n+                                                               &fn_decl.inputs,\n+                                                               top_level_block,\n+                                                               data.fn_metadata,\n+                                                               fn_ast_id);\n+            *data.scope_map.borrow_mut() = scope_map;\n+        }\n+        FunctionDebugContext::DebugInfoDisabled |\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {}\n+    }\n+}\n+\n+pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 variable_name: ast::Name,\n+                                 variable_type: Ty<'tcx>,\n+                                 scope_metadata: DIScope,\n+                                 variable_access: VariableAccess,\n+                                 variable_kind: VariableKind,\n+                                 span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n@@ -616,9 +464,8 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     address_operations.len() as c_uint,\n                     argument_index)\n             };\n-            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n-                                                                          loc.line,\n-                                                                          loc.col.to_usize()));\n+            source_loc::set_debug_location(cx, None,\n+                InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n             unsafe {\n                 let debug_loc = llvm::LLVMGetCurrentDebugLocation(cx.raw_builder());\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n@@ -642,7 +489,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         .get_ref(span)\n                         .source_locations_enabled\n                         .get());\n-            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+            source_loc::set_debug_location(cx, None, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }\n     }\n@@ -651,19 +498,17 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n     At(ast::NodeId, Span),\n+    ScopeAt(DIScope, Span),\n     None\n }\n \n impl DebugLoc {\n-    pub fn apply(&self, fcx: &FunctionContext) {\n-        match *self {\n-            DebugLoc::At(node_id, span) => {\n-                source_loc::set_source_location(fcx, node_id, span);\n-            }\n-            DebugLoc::None => {\n-                source_loc::clear_source_location(fcx);\n-            }\n-        }\n+    pub fn apply(self, fcx: &FunctionContext) {\n+        source_loc::set_source_location(fcx, None, self);\n+    }\n+\n+    pub fn apply_to_bcx(self, bcx: &BlockAndBuilder) {\n+        source_loc::set_source_location(bcx.fcx(), Some(bcx), self);\n     }\n }\n "}, {"sha": "fc31eaa4e74a7961507f2ea92f42623887401819", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 62, "deletions": 98, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -10,118 +10,82 @@\n \n // Namespace Handling.\n \n-use super::utils::{DIB, debug_context};\n+use super::metadata::{file_metadata, NO_FILE_METADATA, UNKNOWN_LINE_NUMBER};\n+use super::utils::{DIB, debug_context, span_start};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::DefPathData;\n use common::CrateContext;\n \n+use libc::c_uint;\n use std::ffi::CString;\n-use std::iter::once;\n use std::ptr;\n-use std::rc::{Rc, Weak};\n-use syntax::ast;\n-use syntax::parse::token;\n-\n-pub struct NamespaceTreeNode {\n-    pub name: ast::Name,\n-    pub scope: DIScope,\n-    pub parent: Option<Weak<NamespaceTreeNode>>,\n-}\n-\n-impl NamespaceTreeNode {\n-    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n-        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n-            match node.parent {\n-                Some(ref parent) => fill_nested(&parent.upgrade().unwrap(), output),\n-                None => {}\n-            }\n-            let string = node.name.as_str();\n-            output.push_str(&string.len().to_string());\n-            output.push_str(&string);\n+use syntax::codemap::DUMMY_SP;\n+\n+pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> String {\n+    fn fill_nested(ccx: &CrateContext, def_id: DefId, extra: &str, output: &mut String) {\n+        let def_key = ccx.tcx().def_key(def_id);\n+        if let Some(parent) = def_key.parent {\n+            fill_nested(ccx, DefId {\n+                krate: def_id.krate,\n+                index: parent\n+            }, \"\", output);\n         }\n \n-        let mut name = String::from(\"_ZN\");\n-        fill_nested(self, &mut name);\n-        name.push_str(&item_name.len().to_string());\n-        name.push_str(item_name);\n-        name.push('E');\n-        name\n-    }\n-}\n-\n-pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeNode> {\n-    // prepend crate name.\n-    // This shouldn't need a roundtrip through InternedString.\n-    let krate = token::intern(&cx.tcx().crate_name(def_id.krate));\n-    let krate = hir_map::DefPathData::TypeNs(krate);\n-    let path = cx.tcx().def_path(def_id).data;\n-    let mut path = once(krate).chain(path.into_iter().map(|e| e.data)).peekable();\n-\n-    let mut current_key = Vec::new();\n-    let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n-\n-    // Create/Lookup namespace for each element of the path.\n-    loop {\n-        // Emulate a for loop so we can use peek below.\n-        let path_element = match path.next() {\n-            Some(e) => e,\n-            None => break\n+        let name = match def_key.disambiguated_data.data {\n+            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+            data => data.as_interned_str()\n         };\n-        // Ignore the name of the item (the last path element).\n-        if path.peek().is_none() {\n-            break;\n-        }\n \n-        // This shouldn't need a roundtrip through InternedString.\n-        let namespace_name = path_element.as_interned_str();\n-        let name = token::intern(&namespace_name);\n-        current_key.push(name);\n-\n-        let existing_node = debug_context(cx).namespace_map.borrow()\n-                                             .get(&current_key).cloned();\n-        let current_node = match existing_node {\n-            Some(existing_node) => existing_node,\n-            None => {\n-                // create and insert\n-                let parent_scope = match parent_node {\n-                    Some(ref node) => node.scope,\n-                    None => ptr::null_mut()\n-                };\n-                let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-                let scope = unsafe {\n-                    llvm::LLVMDIBuilderCreateNameSpace(\n-                        DIB(cx),\n-                        parent_scope,\n-                        namespace_name.as_ptr(),\n-                        // cannot reconstruct file ...\n-                        ptr::null_mut(),\n-                        // ... or line information, but that's not so important.\n-                        0)\n-                };\n-\n-                let node = Rc::new(NamespaceTreeNode {\n-                    name: name,\n-                    scope: scope,\n-                    parent: parent_node.map(|parent| Rc::downgrade(&parent)),\n-                });\n-\n-                debug_context(cx).namespace_map.borrow_mut()\n-                                 .insert(current_key.clone(), node.clone());\n+        output.push_str(&(name.len() + extra.len()).to_string());\n+        output.push_str(&name);\n+        output.push_str(extra);\n+    }\n \n-                node\n-            }\n-        };\n+    let mut name = String::from(\"_ZN\");\n+    fill_nested(ccx, def_id, extra, &mut name);\n+    name.push('E');\n+    name\n+}\n \n-        parent_node = Some(current_node);\n+pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n+    if let Some(&scope) = debug_context(ccx).namespace_map.borrow().get(&def_id) {\n+        return scope;\n     }\n \n-    match parent_node {\n-        Some(node) => node,\n-        None => {\n-            bug!(\"debuginfo::namespace_for_item: path too short for {:?}\", def_id);\n-        }\n-    }\n+    let def_key = ccx.tcx().def_key(def_id);\n+    let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n+        item_namespace(ccx, DefId {\n+            krate: def_id.krate,\n+            index: parent\n+        })\n+    });\n+\n+    let namespace_name = match def_key.disambiguated_data.data {\n+        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+        data => data.as_interned_str()\n+    };\n+\n+    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+    let span = ccx.tcx().map.def_id_span(def_id, DUMMY_SP);\n+    let (file, line) = if span != DUMMY_SP {\n+        let loc = span_start(ccx, span);\n+        (file_metadata(ccx, &loc.file.name), loc.line as c_uint)\n+    } else {\n+        (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+    };\n+\n+    let scope = unsafe {\n+        llvm::LLVMDIBuilderCreateNameSpace(\n+            DIB(ccx),\n+            parent_scope,\n+            namespace_name.as_ptr(),\n+            file,\n+            line as c_uint)\n+    };\n+\n+    debug_context(ccx).namespace_map.borrow_mut().insert(def_id, scope);\n+    scope\n }"}, {"sha": "6b00c1bb1a85582b39484ffdab05b8121c3ae0a6", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -10,12 +10,13 @@\n \n use self::InternalDebugLocation::*;\n \n-use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::utils::{debug_context, span_start};\n use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n use super::{FunctionDebugContext, DebugLoc};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n+use builder::Builder;\n use common::{NodeIdAndSpan, CrateContext, FunctionContext};\n \n use libc::c_uint;\n@@ -86,41 +87,46 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n /// Sets the current debug location at the beginning of the span.\n ///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n-/// parameter is used to reliably find the correct visibility scope for the code\n-/// position.\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n pub fn set_source_location(fcx: &FunctionContext,\n-                           node_id: ast::NodeId,\n-                           span: Span) {\n-    match fcx.debug_context {\n+                           builder: Option<&Builder>,\n+                           debug_loc: DebugLoc) {\n+    let builder = builder.map(|b| b.llbuilder);\n+    let function_debug_context = match fcx.debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n+            set_debug_location(fcx.ccx, builder, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n-            if function_debug_context.source_location_override.get() {\n-                // Just ignore any attempts to set a new debug location while\n-                // the override is active.\n-                return;\n-            }\n-\n-            let cx = fcx.ccx;\n-\n-            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+        FunctionDebugContext::RegularContext(box ref data) => data\n+    };\n \n-            if function_debug_context.source_locations_enabled.get() {\n-                let loc = span_start(cx, span);\n-                let scope = scope_metadata(fcx, node_id, span);\n+    if function_debug_context.source_location_override.get() {\n+        // Just ignore any attempts to set a new debug location while\n+        // the override is active.\n+        return;\n+    }\n \n-                set_debug_location(cx, InternalDebugLocation::new(scope,\n-                                                                  loc.line,\n-                                                                  loc.col.to_usize()));\n-            } else {\n-                set_debug_location(cx, UnknownLocation);\n+    let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n+        let (scope, span) = match debug_loc {\n+            DebugLoc::At(node_id, span) => {\n+                (scope_metadata(fcx, node_id, span), span)\n             }\n-        }\n-    }\n+            DebugLoc::ScopeAt(scope, span) => (scope, span),\n+            DebugLoc::None => {\n+                set_debug_location(fcx.ccx, builder, UnknownLocation);\n+                return;\n+            }\n+        };\n+\n+        debug!(\"set_source_location: {}\",\n+               fcx.ccx.sess().codemap().span_to_string(span));\n+        let loc = span_start(fcx.ccx, span);\n+        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n+    } else {\n+        UnknownLocation\n+    };\n+    set_debug_location(fcx.ccx, builder, dbg_loc);\n }\n \n /// This function makes sure that all debug locations emitted while executing\n@@ -135,7 +141,7 @@ pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n             wrapped_function()\n         }\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n+            set_debug_location(fcx.ccx, None, UnknownLocation);\n             wrapped_function()\n         }\n         FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n@@ -152,17 +158,6 @@ pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n     }\n }\n \n-/// Clears the current debug location.\n-///\n-/// Instructions generated hereafter won't be assigned a source location.\n-pub fn clear_source_location(fcx: &FunctionContext) {\n-    if fn_should_be_ignored(fcx) {\n-        return;\n-    }\n-\n-    set_debug_location(fcx.ccx, UnknownLocation);\n-}\n-\n /// Enables emitting source locations for the given functions.\n ///\n /// Since we don't want source locations to be emitted for the function prelude,\n@@ -195,37 +190,42 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n-    if debug_location == debug_context(cx).current_debug_location.get() {\n-        return;\n+pub fn set_debug_location(cx: &CrateContext,\n+                          builder: Option<llvm::BuilderRef>,\n+                          debug_location: InternalDebugLocation) {\n+    if builder.is_none() {\n+        if debug_location == debug_context(cx).current_debug_location.get() {\n+            return;\n+        }\n     }\n \n-    let metadata_node;\n-\n-    match debug_location {\n+    let metadata_node = match debug_location {\n         KnownLocation { scope, line, .. } => {\n             // Always set the column to zero like Clang and GCC\n             let col = UNKNOWN_COLUMN_NUMBER;\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n-                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                llvm::LLVMDIBuilderCreateDebugLocation(\n                     debug_context(cx).llcontext,\n                     line as c_uint,\n                     col as c_uint,\n                     scope,\n-                    ptr::null_mut());\n+                    ptr::null_mut())\n             }\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            metadata_node = ptr::null_mut();\n+            ptr::null_mut()\n         }\n     };\n \n-    unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    if builder.is_none() {\n+        debug_context(cx).current_debug_location.set(debug_location);\n     }\n \n-    debug_context(cx).current_debug_location.set(debug_location);\n+    let builder = builder.unwrap_or_else(|| cx.raw_builder());\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(builder, metadata_node);\n+    }\n }"}, {"sha": "3fd979371843434db7542198803e8dc028639143", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -11,7 +11,7 @@\n // Utility Functions.\n \n use super::{FunctionDebugContext, CrateDebugContext};\n-use super::namespace::namespace_for_item;\n+use super::namespace::item_namespace;\n \n use rustc::hir::def_id::DefId;\n \n@@ -44,16 +44,6 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n-    attributes.iter().any(|attr| {\n-        let meta_item: &ast::MetaItem = &attr.node.value;\n-        match meta_item.node {\n-            ast::MetaItemKind::Word(ref value) => &value[..] == \"no_debug\",\n-            _ => false\n-        }\n-    })\n-}\n-\n /// Return codemap::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo)\n@@ -87,21 +77,19 @@ pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     }\n }\n \n-pub fn assert_type_for_node_id(cx: &CrateContext,\n-                           node_id: ast::NodeId,\n-                           error_reporting_span: Span) {\n-    if !cx.tcx().node_types().contains_key(&node_id) {\n-        span_bug!(error_reporting_span,\n-                  \"debuginfo: Could not find type for node id!\");\n-    }\n-}\n-\n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n-    let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP /* (1) */ );\n-\n-    // (1) For external items there is no span information\n+    let containing_scope = item_namespace(cx, DefId {\n+        krate: def_id.krate,\n+        index: cx.tcx().def_key(def_id).parent\n+                 .expect(\"get_namespace_and_span_for_item: missing parent?\")\n+    });\n+\n+    // Try to get some span information, if we have an inlined item.\n+    let definition_span = match cx.external().borrow().get(&def_id) {\n+        Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n+        _ => cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP)\n+    };\n \n     (containing_scope, definition_span)\n }"}, {"sha": "6955d51ceccafb3b8e40ab74928701e20dadcc5d", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -115,7 +115,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     if adjustment_required(bcx, expr) {\n         // use trans, which may be less efficient but\n@@ -587,7 +587,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_unadjusted(expr={:?})\", expr);\n     let _indenter = indenter();\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     return match expr_kind(bcx.tcx(), expr) {\n         ExprKind::Lvalue | ExprKind::RvalueDatum => {\n@@ -923,7 +923,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return bcx;\n     }\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     match expr.node {\n         hir::ExprBreak(label_opt) => {\n@@ -987,7 +987,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 //\n                 // We could avoid this intermediary with some analysis\n                 // to determine whether `dst` may possibly own `src`.\n-                debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+                expr.debug_loc().apply(bcx.fcx);\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n                 let opt_hint_datum = dst_datum.kind.drop_flag_info.hint_datum(bcx);\n@@ -1062,7 +1062,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     // Entry into the method table if this is an overloaded call/op.\n     let method_call = MethodCall::expr(expr.id);"}, {"sha": "39ea25619eed01de7e355f03eeeb3fc70522be64", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -272,10 +272,9 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n-    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n \n     let bcx = fcx.init(false, None);\n "}, {"sha": "d79320462430cceaa196843391427462a1b64bae", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -195,8 +195,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n-        DebugLoc::At(_, span) => span,\n-        DebugLoc::None => fcx.span.unwrap_or(DUMMY_SP)\n+        DebugLoc::At(_, span) | DebugLoc::ScopeAt(_, span) => span,\n+        DebugLoc::None => {\n+            span_bug!(fcx.span.unwrap_or(DUMMY_SP),\n+                      \"intrinsic `{}` called with missing span\", name);\n+        }\n     };\n \n     let cleanup_scope = fcx.push_custom_cleanup_scope();\n@@ -1319,10 +1322,9 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     });\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n     let bcx = fcx.init(true, None);\n     trans(bcx);\n     fcx.cleanup();"}, {"sha": "9e5476ae80d4791eb9fe0b9bf752d15108bdc8cb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -93,10 +93,9 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         symbol_names::internal_name_from_type_and_suffix(ccx, method_ty, \"object_shim\");\n     let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n \n-    let empty_substs = tcx.mk_substs(Substs::empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n     let mut bcx = fcx.init(false, None);\n     assert!(!fcx.needs_ret_allocas);\n "}, {"sha": "f70dc0183fdf199fcbf5d06d95c1524d6eb8bff9", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -54,9 +54,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             bcx = self.trans_statement(bcx, statement);\n         }\n \n-        debug!(\"trans_block: terminator: {:?}\", data.terminator());\n-\n-        match data.terminator().kind {\n+        let terminator = data.terminator();\n+        debug!(\"trans_block: terminator: {:?}\", terminator);\n+\n+        let debug_loc = DebugLoc::ScopeAt(self.scopes[terminator.scope.index()],\n+                                          terminator.span);\n+        debug_loc.apply_to_bcx(&bcx);\n+        debug_loc.apply(bcx.fcx());\n+        match terminator.kind {\n             mir::TerminatorKind::Resume => {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n@@ -117,7 +122,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::TerminatorKind::Return => {\n                 bcx.with_block(|bcx| {\n-                    self.fcx.build_return_block(bcx, DebugLoc::None);\n+                    self.fcx.build_return_block(bcx, debug_loc);\n                 })\n             }\n \n@@ -144,7 +149,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                self.llblock(target),\n                                unwind.llbb(),\n                                cleanup_bundle.as_ref());\n-                    self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n+                    self.bcx(target).at_start(|bcx| {\n+                        debug_loc.apply_to_bcx(bcx);\n+                        drop::drop_fill(bcx, lvalue.llval, ty)\n+                    });\n                 } else {\n                     bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n                     drop::drop_fill(&bcx, lvalue.llval, ty);\n@@ -267,7 +275,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         bcx.with_block(|bcx| {\n                             trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n                                                            ArgVals(llargs), dest,\n-                                                           DebugLoc::None);\n+                                                           debug_loc);\n                         });\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -311,13 +319,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                cleanup_bundle.as_ref());\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n-                    landingpad.at_start(|bcx| for op in args {\n-                        self.set_operand_dropped(bcx, op);\n+                    landingpad.at_start(|bcx| {\n+                        debug_loc.apply_to_bcx(bcx);\n+                        for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        }\n                     });\n \n                     if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n                         ret_bcx.at_start(|ret_bcx| {\n+                            debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n                                 val: OperandValue::Immediate(invokeret),\n                                 ty: sig.output.unwrap()\n@@ -514,7 +526,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n         let cleanup_pad = if use_funclets {\n             bcx.set_personality_fn(self.fcx.eh_personality());\n-            bcx.at_start(|bcx| Some(bcx.cleanup_pad(None, &[])))\n+            bcx.at_start(|bcx| {\n+                DebugLoc::None.apply_to_bcx(bcx);\n+                Some(bcx.cleanup_pad(None, &[]))\n+            })\n         } else {\n             None\n         };"}, {"sha": "1869845ccb1896b69e944a3265f8f33743a430a5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -10,11 +10,19 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n+use llvm::debuginfo::DIScope;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use session::config::FullDebugInfo;\n use base;\n use common::{self, Block, BlockAndBuilder, FunctionContext};\n+use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n+use machine;\n+use type_of;\n+\n+use syntax::codemap::DUMMY_SP;\n+use syntax::parse::token;\n \n use std::ops::Deref;\n use std::rc::Rc;\n@@ -44,8 +52,6 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     }\n }\n \n-// FIXME DebugLoc is always None right now\n-\n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n     mir: CachedMir<'bcx, 'tcx>,\n@@ -92,6 +98,9 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// always indirect, though we try to avoid creating an alloca\n     /// when we can (and just reuse the pointer the caller provided).\n     args: Vec<LvalueRef<'tcx>>,\n+\n+    /// Debug information for MIR scopes.\n+    scopes: Vec<DIScope>\n }\n \n enum TempRef<'tcx> {\n@@ -113,11 +122,26 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n       analyze::lvalue_temps(bcx, &mir)\n     });\n \n+    // Compute debuginfo scopes from MIR scopes.\n+    let scopes = debuginfo::create_mir_scopes(fcx);\n+\n     // Allocate variable and temp allocas\n     let vars = mir.var_decls.iter()\n-                            .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n-                            .map(|(mty, name)| LvalueRef::alloca(&bcx, mty, &name.as_str()))\n-                            .collect();\n+                            .map(|decl| (bcx.monomorphize(&decl.ty), decl))\n+                            .map(|(mty, decl)| {\n+        let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n+\n+        let scope = scopes[decl.scope.index()];\n+        if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+            bcx.with_block(|bcx| {\n+                declare_local(bcx, decl.name, mty, scope,\n+                              VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                              VariableKind::LocalVariable, decl.span);\n+            });\n+        }\n+\n+        lvalue\n+    }).collect();\n     let temps = mir.temp_decls.iter()\n                               .map(|decl| bcx.monomorphize(&decl.ty))\n                               .enumerate()\n@@ -132,7 +156,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, &mir);\n+    let args = arg_value_refs(&bcx, &mir, &scopes);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n@@ -152,6 +176,11 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n     bcx.br(start_bcx.llbb);\n \n+    // Up until here, IR instructions for this function have explicitly not been annotated with\n+    // source code location, so we don't step into call setup code. From here on, source location\n+    // emitting should be enabled.\n+    debuginfo::start_emitting_source_locations(fcx);\n+\n     let mut mircx = MirContext {\n         mir: mir.clone(),\n         fcx: fcx,\n@@ -161,6 +190,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         vars: vars,\n         temps: temps,\n         args: args,\n+        scopes: scopes\n     };\n \n     let mut visited = BitVector::new(mir_blocks.len());\n@@ -185,19 +215,33 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         }\n     }\n \n+    DebugLoc::None.apply(fcx);\n     fcx.cleanup();\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              mir: &mir::Mir<'tcx>)\n+                              mir: &mir::Mir<'tcx>,\n+                              scopes: &[DIScope])\n                               -> Vec<LvalueRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+\n+    // Get the argument scope assuming ScopeId(0) has no parent.\n+    let arg_scope = mir.scopes.get(0).and_then(|data| {\n+        let scope = scopes[0];\n+        if data.parent_scope.is_none() && !scope.is_null() &&\n+           bcx.sess().opts.debuginfo == FullDebugInfo {\n+            Some(scope)\n+        } else {\n+            None\n+        }\n+    });\n+\n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n         if arg_decl.spread {\n@@ -211,13 +255,14 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n+            let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n             let lltemp = bcx.with_block(|bcx| {\n                 base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n             });\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &fcx.fn_ty.args[idx];\n-                    idx += 1;\n+                idx += 1;\n                 if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n                         // We pass fat pointers as two words, but inside the tuple\n                         // they are the two sub-fields of a single aggregate field.\n@@ -228,17 +273,37 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n+\n+                bcx.with_block(|bcx| arg_scope.map(|scope| {\n+                    let byte_offset_of_var_in_tuple =\n+                        machine::llelement_offset(bcx.ccx(), lltuplety, i);\n+\n+                    let address_operations = unsafe {\n+                        [llvm::LLVMDIBuilderCreateOpDeref(),\n+                         llvm::LLVMDIBuilderCreateOpPlus(),\n+                         byte_offset_of_var_in_tuple as i64]\n+                    };\n+\n+                    let variable_access = VariableAccess::IndirectVariable {\n+                        alloca: lltemp,\n+                        address_operations: &address_operations\n+                    };\n+                    declare_local(bcx, token::special_idents::invalid.name,\n+                                  tupled_arg_ty, scope, variable_access,\n+                                  VariableKind::ArgumentVariable(arg_index + i + 1),\n+                                  bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                }));\n             }\n             return LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() {\n+        let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up, unless\n             // we emit extra-debug-info, which requires local allocas :(.\n-            // FIXME: lifetimes, debug info\n+            // FIXME: lifetimes\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n@@ -261,6 +326,12 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             }\n             lltemp\n         };\n+        bcx.with_block(|bcx| arg_scope.map(|scope| {\n+            declare_local(bcx, token::special_idents::invalid.name, arg_ty, scope,\n+                          VariableAccess::DirectVariable { alloca: llval },\n+                          VariableKind::ArgumentVariable(arg_index + 1),\n+                          bcx.fcx().span.unwrap_or(DUMMY_SP));\n+        }));\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n     }).collect()\n }"}, {"sha": "641603f5aaad9a88538ca7662f18df7e348d93ee", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -38,7 +38,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bcx: BlockAndBuilder<'bcx, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n-                        rvalue: &mir::Rvalue<'tcx>)\n+                        rvalue: &mir::Rvalue<'tcx>,\n+                        debug_loc: DebugLoc)\n                         -> BlockAndBuilder<'bcx, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n@@ -58,7 +59,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n-                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                     self.store_operand(&bcx, dest.llval, temp);\n                     return bcx;\n                 }\n@@ -217,7 +218,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n-                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                 self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n             }\n@@ -226,7 +227,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     pub fn trans_rvalue_operand(&mut self,\n                                 bcx: BlockAndBuilder<'bcx, 'tcx>,\n-                                rvalue: &mir::Rvalue<'tcx>)\n+                                rvalue: &mir::Rvalue<'tcx>,\n+                                debug_loc: DebugLoc)\n                                 -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n@@ -419,7 +421,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        lhs_addr, lhs_extra,\n                                                        rhs_addr, rhs_extra,\n                                                        lhs.ty, op.to_hir_binop(),\n-                                                       DebugLoc::None)\n+                                                       debug_loc)\n                             })\n                         }\n                         _ => bug!()\n@@ -470,7 +472,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                    box_ty,\n                                                                    llsize,\n                                                                    llalign,\n-                                                                   DebugLoc::None);\n+                                                                   debug_loc);\n                     llval = Some(val);\n                     bcx\n                 });"}, {"sha": "e4967cead07e9b4098f5203bd33bceff0ee4c327", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::mir::repr as mir;\n use common::BlockAndBuilder;\n+use debuginfo::DebugLoc;\n \n use super::MirContext;\n use super::TempRef;\n@@ -21,17 +22,22 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                            -> BlockAndBuilder<'bcx, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n+        let debug_loc = DebugLoc::ScopeAt(self.scopes[statement.scope.index()],\n+                                          statement.span);\n+        debug_loc.apply_to_bcx(&bcx);\n+        debug_loc.apply(bcx.fcx());\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 match *lvalue {\n                     mir::Lvalue::Temp(index) => {\n                         let index = index as usize;\n                         match self.temps[index as usize] {\n                             TempRef::Lvalue(tr_dest) => {\n-                                self.trans_rvalue(bcx, tr_dest, rvalue)\n+                                self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                             }\n                             TempRef::Operand(None) => {\n-                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n+                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue,\n+                                                                               debug_loc);\n                                 self.temps[index] = TempRef::Operand(Some(operand));\n                                 bcx\n                             }\n@@ -44,7 +50,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     _ => {\n                         let tr_dest = self.trans_lvalue(&bcx, lvalue);\n-                        self.trans_rvalue(bcx, tr_dest, rvalue)\n+                        self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                     }\n                 }\n             }"}, {"sha": "cfb64f80767678d250be0cca73e98468115ecd80", "filename": "src/test/compile-fail/bad-intrinsic-monomorphization.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fbad-intrinsic-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fbad-intrinsic-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-intrinsic-monomorphization.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics, rustc_attrs, core_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, core_intrinsics)]\n #![allow(warnings)]\n \n // Bad monomorphizations could previously cause LLVM asserts even though the\n@@ -23,19 +23,16 @@ use std::intrinsics;\n #[derive(Copy, Clone)]\n struct Foo(i64);\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_cttz(v: Foo) -> Foo {\n     intrinsics::cttz(v)\n     //~^ ERROR `cttz` intrinsic: expected basic integer type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_fadd_fast(a: Foo, b: Foo) -> Foo {\n     intrinsics::fadd_fast(a, b)\n     //~^ ERROR `fadd_fast` intrinsic: expected basic float type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_simd_add(a: Foo, b: Foo) -> Foo {\n     simd_add(a, b)\n     //~^ ERROR `simd_add` intrinsic: expected SIMD input type, found non-SIMD `Foo`"}, {"sha": "0b7b33de42193850bd41802a56d2b5d3f2c0aeb6", "filename": "src/test/compile-fail/non-interger-atomic.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core_intrinsics, rustc_attrs)]\n+#![feature(core_intrinsics)]\n #![allow(warnings)]\n \n use std::intrinsics;\n@@ -18,97 +18,81 @@ struct Foo(i64);\n type Bar = &'static Fn();\n type Quux = [u8; 100];\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_bool_load(p: &mut bool, v: bool) {\n     intrinsics::atomic_load(p);\n     //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `bool`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_bool_store(p: &mut bool, v: bool) {\n     intrinsics::atomic_store(p, v);\n     //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `bool`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_bool_xchg(p: &mut bool, v: bool) {\n     intrinsics::atomic_xchg(p, v);\n     //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_bool_cxchg(p: &mut bool, v: bool) {\n     intrinsics::atomic_cxchg(p, v, v);\n     //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Foo_load(p: &mut Foo, v: Foo) {\n     intrinsics::atomic_load(p);\n     //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Foo_store(p: &mut Foo, v: Foo) {\n     intrinsics::atomic_store(p, v);\n     //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Foo_xchg(p: &mut Foo, v: Foo) {\n     intrinsics::atomic_xchg(p, v);\n     //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Foo_cxchg(p: &mut Foo, v: Foo) {\n     intrinsics::atomic_cxchg(p, v, v);\n     //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Bar_load(p: &mut Bar, v: Bar) {\n     intrinsics::atomic_load(p);\n     //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Bar_store(p: &mut Bar, v: Bar) {\n     intrinsics::atomic_store(p, v);\n     //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Bar_xchg(p: &mut Bar, v: Bar) {\n     intrinsics::atomic_xchg(p, v);\n     //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Bar_cxchg(p: &mut Bar, v: Bar) {\n     intrinsics::atomic_cxchg(p, v, v);\n     //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Quux_load(p: &mut Quux, v: Quux) {\n     intrinsics::atomic_load(p);\n     //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Quux_store(p: &mut Quux, v: Quux) {\n     intrinsics::atomic_store(p, v);\n     //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Quux_xchg(p: &mut Quux, v: Quux) {\n     intrinsics::atomic_xchg(p, v);\n     //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n unsafe fn test_Quux_cxchg(p: &mut Quux, v: Quux) {\n     intrinsics::atomic_cxchg(p, v, v);\n     //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`"}, {"sha": "35c368f4cbedb5bb399156b590bbc7ad1f43dfdd", "filename": "src/test/compile-fail/simd-intrinsic-generic-arithmetic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n+#![feature(repr_simd, platform_intrinsics)]\n #![allow(non_camel_case_types)]\n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -34,7 +34,6 @@ extern \"platform-intrinsic\" {\n     fn simd_xor<T>(x: T, y: T) -> T;\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n     let y = u32x4(0, 0, 0, 0);"}, {"sha": "4999b790b130a4e79cb9b9e4ea63b001f0ef93d8", "filename": "src/test/compile-fail/simd-intrinsic-generic-cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n+#![feature(repr_simd, platform_intrinsics)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -35,7 +35,6 @@ extern \"platform-intrinsic\" {\n     fn simd_cast<T, U>(x: T) -> U;\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "617b03a87117b75b3ff97d26c88c1f1b9b6ca2e0", "filename": "src/test/compile-fail/simd-intrinsic-generic-comparison.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n+#![feature(repr_simd, platform_intrinsics)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -29,7 +29,6 @@ extern \"platform-intrinsic\" {\n     fn simd_ge<T, U>(x: T, y: T) -> U;\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "78f7d42e25a1dc0f22c830a6d9c72cb56950077e", "filename": "src/test/compile-fail/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -56,7 +56,6 @@ extern \"platform-intrinsic\" {\n     fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "8615c8a7ef6a488ad9c31c8711537ea889541dff", "filename": "src/test/debuginfo/associated-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -80,7 +80,7 @@\n \n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(omit_gdb_pretty_printer_section)]\n+#![feature(omit_gdb_pretty_printer_section, rustc_attrs)]\n #![omit_gdb_pretty_printer_section]\n \n trait TraitWithAssocType {\n@@ -127,6 +127,7 @@ fn assoc_tuple<T: TraitWithAssocType>(arg: (T, T::Type)) {\n     zzz(); // #break\n }\n \n+#[rustc_no_mir] // FIXME(#32790) MIR reuses scopes for match arms.\n fn assoc_enum<T: TraitWithAssocType>(arg: Enum<T>) {\n \n     match arg {"}, {"sha": "dbd336d2dc6881b4d0f5a2c8da5551cef30f9881", "filename": "src/test/debuginfo/c-style-enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -157,7 +157,8 @@ fn main() {\n \n     zzz(); // #break\n \n-    let a = SINGLE_VARIANT;\n+    // Borrow to avoid an eager load of the constant value in the static.\n+    let a = &SINGLE_VARIANT;\n     let a = unsafe { AUTO_ONE };\n     let a = unsafe { MANUAL_ONE };\n }"}, {"sha": "e90f7d649f599a58abf43d133e9cbbab1cf83fbc", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -247,10 +247,11 @@\n // lldb-command:continue\n \n #![allow(dead_code, unused_assignments, unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n+#![feature(omit_gdb_pretty_printer_section, rustc_attrs)]\n #![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn immediate_args(a: isize, b: bool, c: f64) {\n     println!(\"\");\n }\n@@ -267,43 +268,51 @@ struct BigStruct {\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n     println!(\"\");\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n     println!(\"\");\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n     println!(\"\");\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn function_call(x: u64, y: u64, z: f64) {\n     println!(\"Hi!\")\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn identifier(x: u64, y: u64, z: f64) -> u64 {\n     x\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n     return x;\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n     x + y\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n     if x + y < 1000 {\n         x\n@@ -313,6 +322,7 @@ fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     while x + y < 1000 {\n         x += z\n@@ -321,6 +331,7 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n #[no_stack_check]\n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     loop {\n         x += z;"}, {"sha": "ea237e5970c55645f448813a2d72ff93ac1818d9", "filename": "src/test/debuginfo/no-debug-attribute.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -23,10 +23,11 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(no_debug)]\n+#![feature(no_debug, rustc_attrs)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is inaccurate for returns.\n fn function_with_debuginfo() {\n     let abc = 10_usize;\n     return (); // #break"}, {"sha": "d2af828a8902082164e10af5a503506d6a997172", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -78,7 +78,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_attrs, stmt_expr_attributes)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -88,6 +88,7 @@ struct Struct {\n     c: usize\n }\n \n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -101,10 +102,14 @@ fn main() {\n     let struct_ref = &a_struct;\n     let owned: Box<_> = box 6;\n \n-    let mut closure = || {\n+    let mut closure =\n+    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+    || {\n         let closure_local = 8;\n \n-        let mut nested_closure = || {\n+        let mut nested_closure =\n+        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+        || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned + closure_local;\n         };"}, {"sha": "26d46040c206e116d98054045f393f6924cb2b5b", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -40,7 +40,7 @@\n // lldb-check:[...]$2 = 5\n \n #![allow(unused_variables)]\n-#![feature(unboxed_closures, box_syntax)]\n+#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -50,6 +50,7 @@ struct Struct {\n     c: usize\n }\n \n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let constant = 1;\n \n@@ -61,7 +62,9 @@ fn main() {\n \n     let owned: Box<_> = box 5;\n \n-    let closure = move || {\n+    let closure =\n+    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+    move || {\n         zzz(); // #break\n         do_something(&constant, &a_struct.a, &*owned);\n     };\n@@ -73,7 +76,9 @@ fn main() {\n     // The `self` argument of the following closure should be passed by value\n     // to FnOnce::call_once(self, args), which gets translated a bit differently\n     // than the regular case. Let's make sure this is supported too.\n-    let immedate_env = move || {\n+    let immedate_env =\n+    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+    move || {\n         zzz(); // #break\n         return constant2;\n     };"}, {"sha": "a22fbebfd1ada415bdba19c8de03e387dcc9999e", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -69,7 +69,7 @@\n // lldb-command:print *owned\n // lldb-check:[...]$9 = 6\n \n-#![feature(unboxed_closures, box_syntax)]\n+#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n@@ -80,6 +80,7 @@ struct Struct {\n     c: usize\n }\n \n+#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -94,7 +95,9 @@ fn main() {\n     let owned: Box<_> = box 6;\n \n     {\n-        let mut first_closure = || {\n+        let mut first_closure =\n+        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+        || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };\n@@ -103,7 +106,9 @@ fn main() {\n     }\n \n     {\n-        let mut second_closure = || {\n+        let mut second_closure =\n+        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n+        || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };"}, {"sha": "48df600214ad0813863e490db07492724ab79867", "filename": "src/test/run-pass/backtrace-debuginfo-aux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -11,7 +11,6 @@\n // ignore-test: not a test, used by backtrace-debuginfo.rs to test file!()\n \n #[inline(never)]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n     f((file!(), line!()))\n }\n@@ -21,7 +20,6 @@ pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n pub fn callback_inlined<F>(f: F) where F: FnOnce((&'static str, u32)) {\n     f((file!(), line!()))\n }"}, {"sha": "8b2b26948824f08d89b9252cc024a2714d5e773b", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // We disable tail merging here because it can't preserve debuginfo and thus\n // potentially breaks the backtraces. Also, subtle changes can decide whether\n // tail merging suceeds, so the test might work today but fail tomorrow due to a\n@@ -74,7 +72,6 @@ fn dump_filelines(filelines: &[Pos]) {\n }\n \n #[inline(never)]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n@@ -91,7 +88,6 @@ fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n@@ -117,7 +113,6 @@ fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n }\n \n #[inline(never)]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn outer(mut counter: i32, main_pos: Pos) {\n     inner(&mut counter, main_pos, pos!());\n     inner_inlined(&mut counter, main_pos, pos!());\n@@ -162,7 +157,6 @@ fn run_test(me: &str) {\n }\n \n #[inline(never)]\n-#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() >= 2 {"}, {"sha": "5b364358a59dd45b565f592297941e5a5d6b8b48", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c27cce9e59bbbc1e556de257de85122dad88dcd/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=7c27cce9e59bbbc1e556de257de85122dad88dcd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // no-pretty-expanded FIXME #15189\n // ignore-android FIXME #17520\n // compile-flags:-g\n@@ -18,8 +16,6 @@ use std::env;\n use std::process::{Command, Stdio};\n use std::str;\n \n-// FIXME #31005 MIR missing debuginfo currently.\n-#[cfg_attr(target_env = \"msvc\", rustc_no_mir)]\n #[inline(never)]\n fn foo() {\n     let _v = vec![1, 2, 3];\n@@ -28,8 +24,6 @@ fn foo() {\n     }\n }\n \n-// FIXME #31005 MIR missing debuginfo currently.\n-#[cfg_attr(target_env = \"msvc\", rustc_no_mir)]\n #[inline(never)]\n fn double() {\n     struct Double;"}]}