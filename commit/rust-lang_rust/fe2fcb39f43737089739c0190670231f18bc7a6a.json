{"sha": "fe2fcb39f43737089739c0190670231f18bc7a6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMmZjYjM5ZjQzNzM3MDg5NzM5YzAxOTA2NzAyMzFmMThiYzdhNmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T20:00:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-19T10:31:16Z"}, "message": "Move closure checking into its own file. Shrink check/mod.rs!", "tree": {"sha": "5f63e6aa4e1afdfe11bfe102f92650e9fae53536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f63e6aa4e1afdfe11bfe102f92650e9fae53536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe2fcb39f43737089739c0190670231f18bc7a6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2fcb39f43737089739c0190670231f18bc7a6a", "html_url": "https://github.com/rust-lang/rust/commit/fe2fcb39f43737089739c0190670231f18bc7a6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe2fcb39f43737089739c0190670231f18bc7a6a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf7df1e6382e239619a8447719c3c19787d7b60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7df1e6382e239619a8447719c3c19787d7b60d", "html_url": "https://github.com/rust-lang/rust/commit/cf7df1e6382e239619a8447719c3c19787d7b60d"}], "stats": {"total": 396, "additions": 211, "deletions": 185}, "files": [{"sha": "12b0a90bf7c355014375bcedff9b1751c68f80ef", "filename": "src/librustc/middle/typeck/check/closure.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/fe2fcb39f43737089739c0190670231f18bc7a6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2fcb39f43737089739c0190670231f18bc7a6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs?ref=fe2fcb39f43737089739c0190670231f18bc7a6a", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Code for type-checking closure expressions.\n+ */\n+\n+use super::check_fn;\n+use super::Expectation;\n+use super::FnCtxt;\n+\n+use middle::ty;\n+use middle::typeck::astconv;\n+use middle::typeck::infer;\n+use middle::typeck::rscope::RegionScope;\n+use syntax::abi;\n+use syntax::ast;\n+use syntax::ast_util;\n+use util::ppaux::Repr;\n+\n+pub fn check_unboxed_closure(fcx: &FnCtxt,\n+                             expr: &ast::Expr,\n+                             kind: ast::UnboxedClosureKind,\n+                             decl: &ast::FnDecl,\n+                             body: &ast::Block) {\n+    let expr_def_id = ast_util::local_def(expr.id);\n+\n+    let mut fn_ty = astconv::ty_of_closure(\n+        fcx,\n+        ast::NormalFn,\n+        ast::Many,\n+\n+        // The `RegionTraitStore` and region_existential_bounds\n+        // are lies, but we ignore them so it doesn't matter.\n+        //\n+        // FIXME(pcwalton): Refactor this API.\n+        ty::region_existential_bound(ty::ReStatic),\n+        ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n+\n+        decl,\n+        abi::RustCall,\n+        None);\n+\n+    let region = match fcx.infcx().anon_regions(expr.span, 1) {\n+        Err(_) => {\n+            fcx.ccx.tcx.sess.span_bug(expr.span,\n+                                      \"can't make anon regions here?!\")\n+        }\n+        Ok(regions) => regions[0],\n+    };\n+\n+    let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n+                                              expr_def_id,\n+                                              region,\n+                                              fcx.inh.param_env.free_substs.clone());\n+\n+    fcx.write_ty(expr.id, closure_type);\n+\n+    check_fn(fcx.ccx,\n+             ast::NormalFn,\n+             expr.id,\n+             &fn_ty.sig,\n+             decl,\n+             expr.id,\n+             &*body,\n+             fcx.inh);\n+\n+    // Tuple up the arguments and insert the resulting function type into\n+    // the `unboxed_closures` table.\n+    fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n+\n+    let kind = match kind {\n+        ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n+        ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n+        ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n+    };\n+\n+    debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n+           expr_def_id.repr(fcx.tcx()),\n+           fn_ty.sig.repr(fcx.tcx()),\n+           kind);\n+\n+    let unboxed_closure = ty::UnboxedClosure {\n+        closure_type: fn_ty,\n+        kind: kind,\n+    };\n+\n+    fcx.inh\n+        .unboxed_closures\n+        .borrow_mut()\n+        .insert(expr_def_id, unboxed_closure);\n+}\n+\n+pub fn check_expr_fn<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                              expr: &ast::Expr,\n+                              store: ty::TraitStore,\n+                              decl: &ast::FnDecl,\n+                              body: &ast::Block,\n+                              expected: Expectation<'tcx>) {\n+    let tcx = fcx.ccx.tcx;\n+\n+    // Find the expected input/output types (if any). Substitute\n+    // fresh bound regions for any bound regions we find in the\n+    // expected types so as to avoid capture.\n+    let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n+    let (expected_sig,\n+         expected_onceness,\n+         expected_bounds) = {\n+        match expected_sty {\n+            Some(ty::ty_closure(ref cenv)) => {\n+                let (sig, _) =\n+                    ty::replace_late_bound_regions(\n+                        tcx,\n+                        &cenv.sig,\n+                        |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n+                let onceness = match (&store, &cenv.store) {\n+                    // As the closure type and onceness go, only three\n+                    // combinations are legit:\n+                    //      once closure\n+                    //      many closure\n+                    //      once proc\n+                    // If the actual and expected closure type disagree with\n+                    // each other, set expected onceness to be always Once or\n+                    // Many according to the actual type. Otherwise, it will\n+                    // yield either an illegal \"many proc\" or a less known\n+                    // \"once closure\" in the error message.\n+                    (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n+                    (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n+                        cenv.onceness,\n+                    (&ty::UniqTraitStore, _) => ast::Once,\n+                    (&ty::RegionTraitStore(..), _) => ast::Many,\n+                };\n+                (Some(sig), onceness, cenv.bounds)\n+            }\n+            _ => {\n+                // Not an error! Means we're inferring the closure type\n+                let (bounds, onceness) = match expr.node {\n+                    ast::ExprProc(..) => {\n+                        let mut bounds = ty::region_existential_bound(ty::ReStatic);\n+                        bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n+                        (bounds, ast::Once)\n+                    }\n+                    _ => {\n+                        let region = fcx.infcx().next_region_var(\n+                            infer::AddrOfRegion(expr.span));\n+                        (ty::region_existential_bound(region), ast::Many)\n+                    }\n+                };\n+                (None, onceness, bounds)\n+            }\n+        }\n+    };\n+\n+    // construct the function type\n+    let fn_ty = astconv::ty_of_closure(fcx,\n+                                       ast::NormalFn,\n+                                       expected_onceness,\n+                                       expected_bounds,\n+                                       store,\n+                                       decl,\n+                                       abi::Rust,\n+                                       expected_sig);\n+    let fty_sig = fn_ty.sig.clone();\n+    let fty = ty::mk_closure(tcx, fn_ty);\n+    debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n+\n+    fcx.write_ty(expr.id, fty);\n+\n+    // If the closure is a stack closure and hasn't had some non-standard\n+    // style inferred for it, then check it under its parent's style.\n+    // Otherwise, use its own\n+    let (inherited_style, inherited_style_id) = match store {\n+        ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n+                                     fcx.ps.borrow().def),\n+        ty::UniqTraitStore => (ast::NormalFn, expr.id)\n+    };\n+\n+    check_fn(fcx.ccx,\n+             inherited_style,\n+             inherited_style_id,\n+             &fty_sig,\n+             &*decl,\n+             expr.id,\n+             &*body,\n+             fcx.inh);\n+}"}, {"sha": "02ac6379a5696916f35ba4885f4d8aa8383e9f72", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 185, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/fe2fcb39f43737089739c0190670231f18bc7a6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2fcb39f43737089739c0190670231f18bc7a6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fe2fcb39f43737089739c0190670231f18bc7a6a", "patch": "@@ -147,6 +147,7 @@ pub mod regionck;\n pub mod demand;\n pub mod method;\n pub mod wf;\n+mod closure;\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -3519,174 +3520,6 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         })\n     }\n \n-    fn check_unboxed_closure(fcx: &FnCtxt,\n-                             expr: &ast::Expr,\n-                             kind: ast::UnboxedClosureKind,\n-                             decl: &ast::FnDecl,\n-                             body: &ast::Block) {\n-        let mut fn_ty = astconv::ty_of_closure(\n-            fcx,\n-            ast::NormalFn,\n-            ast::Many,\n-\n-            // The `RegionTraitStore` and region_existential_bounds\n-            // are lies, but we ignore them so it doesn't matter.\n-            //\n-            // FIXME(pcwalton): Refactor this API.\n-            ty::region_existential_bound(ty::ReStatic),\n-            ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n-\n-            decl,\n-            abi::RustCall,\n-            None);\n-\n-        let region = match fcx.infcx().anon_regions(expr.span, 1) {\n-            Err(_) => {\n-                fcx.ccx.tcx.sess.span_bug(expr.span,\n-                                          \"can't make anon regions here?!\")\n-            }\n-            Ok(regions) => regions[0],\n-        };\n-        let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n-                                                  local_def(expr.id),\n-                                                  region,\n-                                                  fcx.inh.param_env.free_substs.clone());\n-        fcx.write_ty(expr.id, closure_type);\n-\n-        check_fn(fcx.ccx,\n-                 ast::NormalFn,\n-                 expr.id,\n-                 &fn_ty.sig,\n-                 decl,\n-                 expr.id,\n-                 &*body,\n-                 fcx.inh);\n-\n-        // Tuple up the arguments and insert the resulting function type into\n-        // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n-\n-        let kind = match kind {\n-            ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n-            ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n-            ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n-        };\n-\n-        debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n-               local_def(expr.id).repr(fcx.tcx()),\n-               fn_ty.sig.repr(fcx.tcx()),\n-               kind);\n-\n-        let unboxed_closure = ty::UnboxedClosure {\n-            closure_type: fn_ty,\n-            kind: kind,\n-        };\n-\n-        fcx.inh\n-           .unboxed_closures\n-           .borrow_mut()\n-           .insert(local_def(expr.id), unboxed_closure);\n-    }\n-\n-    fn check_expr_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                               expr: &ast::Expr,\n-                               store: ty::TraitStore,\n-                               decl: &ast::FnDecl,\n-                               body: &ast::Block,\n-                               expected: Expectation<'tcx>) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        debug!(\"check_expr_fn(expr={}, expected={})\",\n-               expr.repr(tcx),\n-               expected.repr(tcx));\n-\n-        // Find the expected input/output types (if any). Substitute\n-        // fresh bound regions for any bound regions we find in the\n-        // expected types so as to avoid capture.\n-        let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n-        let (expected_sig,\n-             expected_onceness,\n-             expected_bounds) = {\n-            match expected_sty {\n-                Some(ty::ty_closure(ref cenv)) => {\n-                    let (sig, _) =\n-                        replace_late_bound_regions(\n-                            tcx,\n-                            &cenv.sig,\n-                            |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n-                    let onceness = match (&store, &cenv.store) {\n-                        // As the closure type and onceness go, only three\n-                        // combinations are legit:\n-                        //      once closure\n-                        //      many closure\n-                        //      once proc\n-                        // If the actual and expected closure type disagree with\n-                        // each other, set expected onceness to be always Once or\n-                        // Many according to the actual type. Otherwise, it will\n-                        // yield either an illegal \"many proc\" or a less known\n-                        // \"once closure\" in the error message.\n-                        (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n-                        (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n-                            cenv.onceness,\n-                        (&ty::UniqTraitStore, _) => ast::Once,\n-                        (&ty::RegionTraitStore(..), _) => ast::Many,\n-                    };\n-                    (Some(sig), onceness, cenv.bounds)\n-                }\n-                _ => {\n-                    // Not an error! Means we're inferring the closure type\n-                    let (bounds, onceness) = match expr.node {\n-                        ast::ExprProc(..) => {\n-                            let mut bounds = ty::region_existential_bound(ty::ReStatic);\n-                            bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n-                            (bounds, ast::Once)\n-                        }\n-                        _ => {\n-                            let region = fcx.infcx().next_region_var(\n-                                infer::AddrOfRegion(expr.span));\n-                            (ty::region_existential_bound(region), ast::Many)\n-                        }\n-                    };\n-                    (None, onceness, bounds)\n-                }\n-            }\n-        };\n-\n-        // construct the function type\n-        let fn_ty = astconv::ty_of_closure(fcx,\n-                                           ast::NormalFn,\n-                                           expected_onceness,\n-                                           expected_bounds,\n-                                           store,\n-                                           decl,\n-                                           abi::Rust,\n-                                           expected_sig);\n-        let fty_sig = fn_ty.sig.clone();\n-        let fty = ty::mk_closure(tcx, fn_ty);\n-        debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n-\n-        fcx.write_ty(expr.id, fty);\n-\n-        // If the closure is a stack closure and hasn't had some non-standard\n-        // style inferred for it, then check it under its parent's style.\n-        // Otherwise, use its own\n-        let (inherited_style, inherited_style_id) = match store {\n-            ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n-                                         fcx.ps.borrow().def),\n-            ty::UniqTraitStore => (ast::NormalFn, expr.id)\n-        };\n-\n-        check_fn(fcx.ccx,\n-                 inherited_style,\n-                 inherited_style_id,\n-                 &fty_sig,\n-                 &*decl,\n-                 expr.id,\n-                 &*body,\n-                 fcx.inh);\n-    }\n-\n-\n     // Check field access expressions\n     fn check_field(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n@@ -4320,27 +4153,27 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                        fcx.infcx(),\n                                                        expr.span,\n                                                        &None);\n-        check_expr_fn(fcx,\n-                      expr,\n-                      ty::RegionTraitStore(region, ast::MutMutable),\n-                      &**decl,\n-                      &**body,\n-                      expected);\n+        closure::check_expr_fn(fcx,\n+                               expr,\n+                               ty::RegionTraitStore(region, ast::MutMutable),\n+                               &**decl,\n+                               &**body,\n+                               expected);\n       }\n       ast::ExprUnboxedFn(_, kind, ref decl, ref body) => {\n-        check_unboxed_closure(fcx,\n-                              expr,\n-                              kind,\n-                              &**decl,\n-                              &**body);\n+          closure::check_unboxed_closure(fcx,\n+                                         expr,\n+                                         kind,\n+                                         &**decl,\n+                                         &**body);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n-        check_expr_fn(fcx,\n-                      expr,\n-                      ty::UniqTraitStore,\n-                      &**decl,\n-                      &**body,\n-                      expected);\n+          closure::check_expr_fn(fcx,\n+                                 expr,\n+                                 ty::UniqTraitStore,\n+                                 &**decl,\n+                                 &**body,\n+                                 expected);\n       }\n       ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, &**b, expected);"}]}