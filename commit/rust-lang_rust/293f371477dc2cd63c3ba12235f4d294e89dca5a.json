{"sha": "293f371477dc2cd63c3ba12235f4d294e89dca5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5M2YzNzE0NzdkYzJjZDYzYzNiYTEyMjM1ZjRkMjk0ZTg5ZGNhNWE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-08T22:19:27Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-08T23:07:52Z"}, "message": "Default methods in traits get through typeck.", "tree": {"sha": "f6cc1262b9c0b1c10982284e5c4447eb455e7e48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6cc1262b9c0b1c10982284e5c4447eb455e7e48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293f371477dc2cd63c3ba12235f4d294e89dca5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293f371477dc2cd63c3ba12235f4d294e89dca5a", "html_url": "https://github.com/rust-lang/rust/commit/293f371477dc2cd63c3ba12235f4d294e89dca5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293f371477dc2cd63c3ba12235f4d294e89dca5a/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8bad3631234f02c297e9117df67f3a4b3cd645c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8bad3631234f02c297e9117df67f3a4b3cd645c", "html_url": "https://github.com/rust-lang/rust/commit/c8bad3631234f02c297e9117df67f3a4b3cd645c"}], "stats": {"total": 177, "additions": 158, "deletions": 19}, "files": [{"sha": "d2aa73a21f75b2a5862e468619479e7119b9cbe3", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/293f371477dc2cd63c3ba12235f4d294e89dca5a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293f371477dc2cd63c3ba12235f4d294e89dca5a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=293f371477dc2cd63c3ba12235f4d294e89dca5a", "patch": "@@ -79,6 +79,7 @@ export vtable_res;\n export vtable_origin;\n export method_static, method_param, method_trait;\n export vtable_static, vtable_param, vtable_trait;\n+export provided_methods_map;\n \n #[auto_serialize]\n enum method_origin {\n@@ -152,6 +153,11 @@ enum vtable_origin {\n type vtable_map = hashmap<ast::node_id, vtable_res>;\n \n type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n+// Stores information about provided methods, aka \"default methods\" in traits.\n+// Maps from a trait's def_id to a MethodInfo about\n+// that method in that trait.\n+type provided_methods_map = hashmap<ast::node_id,\n+                                    ~[@resolve3::MethodInfo]>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n@@ -160,6 +166,7 @@ type crate_ctxt_ = {impl_map: resolve3::ImplMap,\n                     method_map: method_map,\n                     vtable_map: vtable_map,\n                     coherence_info: @coherence::CoherenceInfo,\n+                    provided_methods_map: provided_methods_map,\n                     tcx: ty::ctxt};\n \n enum crate_ctxt {\n@@ -302,6 +309,7 @@ fn check_crate(tcx: ty::ctxt,\n                             method_map: std::map::int_hash(),\n                             vtable_map: std::map::int_hash(),\n                             coherence_info: @coherence::CoherenceInfo(),\n+                            provided_methods_map: std::map::int_hash(),\n                             tcx: tcx});\n     collect::collect_item_types(ccx, crate);\n     coherence::check_coherence(ccx, crate);"}, {"sha": "2a74a0767bcb965ab26f14a7d99d70b58a5a91d7", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 150, "deletions": 19, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/293f371477dc2cd63c3ba12235f4d294e89dca5a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293f371477dc2cd63c3ba12235f4d294e89dca5a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=293f371477dc2cd63c3ba12235f4d294e89dca5a", "patch": "@@ -7,7 +7,7 @@\n import metadata::csearch::{each_path, get_impl_traits, get_impls_for_mod};\n import metadata::cstore::{cstore, iter_crate_data};\n import metadata::decoder::{dl_def, dl_field, dl_impl};\n-import middle::resolve3::Impl;\n+import middle::resolve3::{Impl, MethodInfo};\n import middle::ty::{get, lookup_item_type, subst, t, ty_box};\n import middle::ty::{ty_uniq, ty_ptr, ty_rptr, ty_enum};\n import middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n@@ -108,6 +108,16 @@ fn get_base_type_def_id(inference_context: infer_ctxt,\n     }\n }\n \n+\n+fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n+    @{\n+        did: local_def(ast_method.id),\n+        n_tps: ast_method.tps.len(),\n+        ident: ast_method.ident,\n+        self_type: ast_method.self_ty.node\n+    }\n+}\n+\n class CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n@@ -151,10 +161,70 @@ class CoherenceChecker {\n         self.privileged_types = new_def_hash();\n     }\n \n+    // Create a mapping containing a MethodInfo for every provided\n+    // method in every trait.\n+    fn build_provided_methods_map(crate: @crate) {\n+\n+        let pmm = self.crate_context.provided_methods_map;\n+\n+        visit_crate(*crate, (), mk_simple_visitor(@{\n+            visit_item: |item| {\n+                match item.node {\n+                  item_trait(_, _, trait_methods) => {\n+                    for trait_methods.each |trait_method| {\n+                        debug!{\"(building provided methods map) checking \\\n+                                trait `%s` with id %d\", *item.ident, item.id};\n+\n+                        match trait_method {\n+                            required(_) => { /* fall through */}\n+                            provided(m) => {\n+                                // For every provided method in the\n+                                // trait, store a MethodInfo.\n+                                let mi = method_to_MethodInfo(m);\n+\n+                                match pmm.find(item.id) {\n+                                    some(mis) => {\n+                                      // If the trait already has an\n+                                      // entry in the\n+                                      // provided_methods_map, we just\n+                                      // need to add this method to\n+                                      // that entry.\n+                                      debug!{\"(building provided \\\n+                                              methods map) adding \\\n+                                              method `%s` to entry for \\\n+                                              existing trait\",\n+                                              *mi.ident};\n+                                      let mut method_infos = mis;\n+                                      push(method_infos, mi);\n+                                      pmm.insert(item.id, method_infos);\n+                                    }\n+                                    none => {\n+                                      // If the trait doesn't have an\n+                                      // entry yet, create one.\n+                                      debug!{\"(building provided \\\n+                                              methods map) creating new \\\n+                                              entry for method `%s`\",\n+                                              *mi.ident};\n+                                      pmm.insert(item.id, ~[mi]);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                  }\n+                  _ => {\n+                    // Nothing to do.\n+                  }\n+                };\n+            }\n+            with *default_simple_visitor()\n+        }));\n+    }\n+\n     fn check_coherence(crate: @crate) {\n+\n         // Check implementations. This populates the tables containing the\n         // inherent methods and extension methods.\n-\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n                 debug!{\"(checking coherence) item '%s'\", *item.ident};\n@@ -430,15 +500,13 @@ class CoherenceChecker {\n                                         // trait was defined in this\n                                         // crate.\n \n-                                        let def_map = self.crate_context.tcx\n-                                            .def_map;\n-                                        let trait_def = def_map.get\n-                                            (trait_ref.ref_id);\n-                                        let trait_id =\n-                                            def_id_of_def(trait_def);\n-                                        if trait_id.crate != local_crate {\n-                                            let session = self.crate_context\n-                                                .tcx.sess;\n+                                        let trait_def_id =\n+                                            self.trait_ref_to_trait_def_id(\n+                                                trait_ref);\n+\n+                                        if trait_def_id.crate != local_crate {\n+                                            let session =\n+                                                self.crate_context.tcx.sess;\n                                             session.span_err(item.span,\n                                                              ~\"cannot \\\n                                                                provide an \\\n@@ -466,6 +534,13 @@ class CoherenceChecker {\n         }));\n     }\n \n+    fn trait_ref_to_trait_def_id(trait_ref: @trait_ref) -> def_id {\n+        let def_map = self.crate_context.tcx.def_map;\n+        let trait_def = def_map.get(trait_ref.ref_id);\n+        let trait_id = def_id_of_def(trait_def);\n+        return trait_id;\n+    }\n+\n     fn gather_privileged_types(items: ~[@item]) -> @dvec<def_id> {\n         let results = @dvec();\n         for items.each |item| {\n@@ -487,16 +562,70 @@ class CoherenceChecker {\n \n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(item: @item) -> @Impl {\n+\n+        fn add_provided_methods(inherent_methods: ~[@MethodInfo],\n+                                all_provided_methods: ~[@MethodInfo])\n+            -> ~[@MethodInfo] {\n+\n+            let mut methods = inherent_methods;\n+\n+            // If there's no inherent method with the same name as a\n+            // provided method, add that provided method to `methods`.\n+            for all_provided_methods.each |provided_method| {\n+                let mut method_inherent_to_impl = false;\n+                for inherent_methods.each |inherent_method| {\n+                    if provided_method.ident == inherent_method.ident {\n+                        method_inherent_to_impl = true;\n+                    }\n+                }\n+\n+                if !method_inherent_to_impl {\n+                    debug!{\"(creating impl) adding provided method `%s` to \\\n+                            impl\", *provided_method.ident};\n+                    push(methods, provided_method);\n+                }\n+            }\n+\n+            return methods;\n+        }\n+\n         match item.node {\n-            item_impl(ty_params, _, _, ast_methods) => {\n+            item_impl(ty_params, trait_refs, _, ast_methods) => {\n                 let mut methods = ~[];\n+\n                 for ast_methods.each |ast_method| {\n-                    push(methods, @{\n-                        did: local_def(ast_method.id),\n-                        n_tps: ast_method.tps.len(),\n-                        ident: ast_method.ident,\n-                        self_type: ast_method.self_ty.node\n-                    });\n+                    push(methods,\n+                         method_to_MethodInfo(ast_method));\n+                }\n+\n+                // For each trait that the impl implements, see what\n+                // methods are provided.  For each of those methods,\n+                // if a method of that name is not inherent to the\n+                // impl, use the provided definition in the trait.\n+                for trait_refs.each |trait_ref| {\n+\n+                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n+\n+                    match self.crate_context.provided_methods_map\n+                        .find(trait_did.node) {\n+                        none => {\n+                            debug!{\"(creating impl) trait with node_id `%d` \\\n+                                    has no provided methods\", trait_did.node};\n+                            /* fall through */\n+                        }\n+                        some(all_provided)\n+                                    => {\n+                            debug!{\"(creating impl) trait with node_id `%d` \\\n+                                    has provided methods\", trait_did.node};\n+                            // Selectively add only those provided\n+                            // methods that aren't inherent to the\n+                            // trait.\n+\n+                            // XXX: could probably be doing this with filter.\n+                            methods = add_provided_methods(methods,\n+                                                           all_provided);\n+                        }\n+                    }\n                 }\n \n                 return @{\n@@ -669,6 +798,8 @@ class CoherenceChecker {\n }\n \n fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n-    CoherenceChecker(crate_context).check_coherence(crate);\n+    let coherence_checker = @CoherenceChecker(crate_context);\n+    (*coherence_checker).build_provided_methods_map(crate);\n+    (*coherence_checker).check_coherence(crate);\n }\n "}]}