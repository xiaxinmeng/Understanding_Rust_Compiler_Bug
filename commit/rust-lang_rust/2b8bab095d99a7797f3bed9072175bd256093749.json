{"sha": "2b8bab095d99a7797f3bed9072175bd256093749", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOGJhYjA5NWQ5OWE3Nzk3ZjNiZWQ5MDcyMTc1YmQyNTYwOTM3NDk=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-23T14:50:05Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-23T14:50:05Z"}, "message": "Move test helper functions to consolidated codemap testing", "tree": {"sha": "dbefbb48bb2a8602f39f6d91668f697f1711287a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbefbb48bb2a8602f39f6d91668f697f1711287a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b8bab095d99a7797f3bed9072175bd256093749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8bab095d99a7797f3bed9072175bd256093749", "html_url": "https://github.com/rust-lang/rust/commit/2b8bab095d99a7797f3bed9072175bd256093749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b8bab095d99a7797f3bed9072175bd256093749/comments", "author": null, "committer": null, "parents": [{"sha": "b68e079522e7bcaf57587ea0502a0ed94a600bc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68e079522e7bcaf57587ea0502a0ed94a600bc0", "html_url": "https://github.com/rust-lang/rust/commit/b68e079522e7bcaf57587ea0502a0ed94a600bc0"}], "stats": {"total": 127, "additions": 64, "deletions": 63}, "files": [{"sha": "c472994599ccb40ee0dc659ec5fa5a0a2f12be55", "filename": "src/librustc_errors/snippet.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=2b8bab095d99a7797f3bed9072175bd256093749", "previous_filename": "src/librustc_errors/snippet/mod.rs"}, {"sha": "1e3e93f514682ea349ffb438a9a0726fcaa836ef", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2b8bab095d99a7797f3bed9072175bd256093749", "patch": "@@ -830,6 +830,7 @@ mod tests {\n     use syntax_pos::*;\n     use errors::{Level, CodeSuggestion};\n     use errors::emitter::EmitterWriter;\n+    use errors::snippet::SnippetData;\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;\n@@ -1077,6 +1078,69 @@ mod tests {\n                     blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n     }\n \n+    /// Returns the span corresponding to the `n`th occurrence of\n+    /// `substring` in `source_text`.\n+    trait CodeMapExtension {\n+        fn span_substr(&self,\n+                    file: &Rc<FileMap>,\n+                    source_text: &str,\n+                    substring: &str,\n+                    n: usize)\n+                    -> Span;\n+    }\n+\n+    impl CodeMapExtension for CodeMap {\n+        fn span_substr(&self,\n+                    file: &Rc<FileMap>,\n+                    source_text: &str,\n+                    substring: &str,\n+                    n: usize)\n+                    -> Span\n+        {\n+            println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                    file.name, file.start_pos, substring, n);\n+            let mut i = 0;\n+            let mut hi = 0;\n+            loop {\n+                let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                    panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                        source_text, n, substring, i);\n+                });\n+                let lo = hi + offset;\n+                hi = lo + substring.len();\n+                if i == n {\n+                    let span = Span {\n+                        lo: BytePos(lo as u32 + file.start_pos.0),\n+                        hi: BytePos(hi as u32 + file.start_pos.0),\n+                        expn_id: NO_EXPANSION,\n+                    };\n+                    assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                            substring);\n+                    return span;\n+                }\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    fn splice(start: Span, end: Span) -> Span {\n+        Span {\n+            lo: start.lo,\n+            hi: end.hi,\n+            expn_id: NO_EXPANSION,\n+        }\n+    }\n+\n+    fn make_string(lines: &[RenderedLine]) -> String {\n+        lines.iter()\n+            .flat_map(|rl| {\n+                rl.text.iter()\n+                        .map(|s| &s.text[..])\n+                        .chain(Some(\"\\n\"))\n+            })\n+            .collect()\n+    }\n+\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end"}, {"sha": "cc3fff09617f48a26382b9a93526fe0cfe7d6a7c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b8bab095d99a7797f3bed9072175bd256093749/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=2b8bab095d99a7797f3bed9072175bd256093749", "patch": "@@ -692,66 +692,3 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n                     vec![field(\"desc\", desc_expr),\n                          field(\"testfn\", testfn_expr)])\n }\n-\n-/// Returns the span corresponding to the `n`th occurrence of\n-/// `substring` in `source_text`.\n-trait CodeMapExtension {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span;\n-}\n-\n-impl CodeMapExtension for CodeMap {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span\n-    {\n-        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n-                 file.name, file.start_pos, substring, n);\n-        let mut i = 0;\n-        let mut hi = 0;\n-        loop {\n-            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n-                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n-                       source_text, n, substring, i);\n-            });\n-            let lo = hi + offset;\n-            hi = lo + substring.len();\n-            if i == n {\n-                let span = Span {\n-                    lo: BytePos(lo as u32 + file.start_pos.0),\n-                    hi: BytePos(hi as u32 + file.start_pos.0),\n-                    expn_id: NO_EXPANSION,\n-                };\n-                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n-                           substring);\n-                return span;\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\n-fn splice(start: Span, end: Span) -> Span {\n-    Span {\n-        lo: start.lo,\n-        hi: end.hi,\n-        expn_id: NO_EXPANSION,\n-    }\n-}\n-\n-fn make_string(lines: &[RenderedLine]) -> String {\n-    lines.iter()\n-         .flat_map(|rl| {\n-             rl.text.iter()\n-                    .map(|s| &s.text[..])\n-                    .chain(Some(\"\\n\"))\n-         })\n-         .collect()\n-}"}]}