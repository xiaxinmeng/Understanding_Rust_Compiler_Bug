{"sha": "866971adf50539f944d9d1e034fcaab9a1be9609", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Njk3MWFkZjUwNTM5Zjk0NGQ5ZDFlMDM0ZmNhYWI5YTFiZTk2MDk=", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-10-06T18:21:54Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-10-06T18:33:29Z"}, "message": "Implement abs, to_bits, and from_bits for float vectors", "tree": {"sha": "af5cbc1a51b31a0a507faf192ef3712d4d86f0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af5cbc1a51b31a0a507faf192ef3712d4d86f0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/866971adf50539f944d9d1e034fcaab9a1be9609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/866971adf50539f944d9d1e034fcaab9a1be9609", "html_url": "https://github.com/rust-lang/rust/commit/866971adf50539f944d9d1e034fcaab9a1be9609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/866971adf50539f944d9d1e034fcaab9a1be9609/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b39351ba5b42becb7bc9b53adb8e95f9490cbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b39351ba5b42becb7bc9b53adb8e95f9490cbdf", "html_url": "https://github.com/rust-lang/rust/commit/0b39351ba5b42becb7bc9b53adb8e95f9490cbdf"}], "stats": {"total": 113, "additions": 106, "deletions": 7}, "files": [{"sha": "214867c5ddce3a889ea22d76073440a0f739179a", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=866971adf50539f944d9d1e034fcaab9a1be9609", "patch": "@@ -270,6 +270,52 @@ macro_rules! define_vector {\n     }\n }\n \n+/// Implements inherent methods for a float vector `$name` containing multiple\n+/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n+/// representation. Called from `define_float_vector!`.\n+macro_rules! impl_float_vector {\n+    { $name:path => [$type:ty; $lanes:literal]; bits $bits_ty:ty; } => {\n+        impl $name {\n+            /// Raw transmutation to an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn to_bits(self) -> $bits_ty {\n+                unsafe { core::mem::transmute(self) }\n+            }\n+\n+            /// Raw transmutation from an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn from_bits(bits: $bits_ty) -> Self {\n+                unsafe { core::mem::transmute(bits) }\n+            }\n+\n+            /// Produces a vector where every lane has the absolute value of the\n+            /// equivalently-indexed lane in `self`.\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                let no_sign = <$bits_ty>::splat(!0 >> 1);\n+                let abs = unsafe { crate::intrinsics::simd_and(self.to_bits(), no_sign) };\n+                Self::from_bits(abs)\n+            }\n+        }\n+    };\n+}\n+\n+/// Defines a float vector `$name` containing multiple `$lanes` of float\n+/// `$type`, which uses `$bits_ty` as its binary representation.\n+macro_rules! define_float_vector {\n+    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); bits $bits_ty:ty; } => {\n+        define_vector! {\n+            $(#[$attr])*\n+            struct $name([$type; $lanes]);\n+        }\n+\n+        impl_float_vector! { $name => [$type; $lanes]; bits $bits_ty; }\n+    }\n+}\n+\n+\n /// Defines an integer vector `$name` containing multiple `$lanes` of integer `$type`.\n macro_rules! define_integer_vector {\n     { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {"}, {"sha": "17b382ee739e58c59dfd249e473276b89a693281", "filename": "crates/core_simd/src/vectors_f32.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs?ref=866971adf50539f944d9d1e034fcaab9a1be9609", "patch": "@@ -1,23 +1,29 @@\n-define_vector! {\n+define_float_vector! {\n     /// Vector of two `f32` values\n     struct f32x2([f32; 2]);\n+    bits crate::u32x2;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of four `f32` values\n     struct f32x4([f32; 4]);\n+    bits crate::u32x4;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of eight `f32` values\n     struct f32x8([f32; 8]);\n+    bits crate::u32x8;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of 16 `f32` values\n     struct f32x16([f32; 16]);\n+    bits crate::u32x16;\n }\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n //from_transmute_x86! { unsafe f32x16 => __m512 }\n+\n+"}, {"sha": "b41923ca6f10d367af6634fe0bb25c41cac7ce3b", "filename": "crates/core_simd/src/vectors_f64.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs?ref=866971adf50539f944d9d1e034fcaab9a1be9609", "patch": "@@ -1,16 +1,19 @@\n-define_vector! {\n+define_float_vector! {\n     /// Vector of two `f64` values\n     struct f64x2([f64; 2]);\n+    bits crate::u64x2;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of four `f64` values\n     struct f64x4([f64; 4]);\n+    bits crate::u64x4;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of eight `f64` values\n     struct f64x8([f64; 8]);\n+    bits crate::u64x8;\n }\n \n from_transmute_x86! { unsafe f64x2 => __m128d }"}, {"sha": "708b4d14327c1170200dd1145c6324994474e49d", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866971adf50539f944d9d1e034fcaab9a1be9609/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=866971adf50539f944d9d1e034fcaab9a1be9609", "patch": "@@ -21,6 +21,26 @@ macro_rules! float_tests {\n \n             const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n             const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n+            const C: [$scalar; 16] = [\n+                -0.0,\n+                0.0,\n+                -1.0,\n+                1.0,\n+                <$scalar>::MIN,\n+                <$scalar>::MAX,\n+                <$scalar>::INFINITY,\n+                -<$scalar>::INFINITY,\n+                <$scalar>::MIN_POSITIVE,\n+                -<$scalar>::MIN_POSITIVE,\n+                <$scalar>::EPSILON,\n+                -<$scalar>::EPSILON,\n+                0.0 / 0.0,\n+                -0.0 / 0.0,\n+                // Still not sure if wasm can have weird nans, or I'd check them\n+                // too. Until then\n+                1.0 / 3.0,\n+                -1.0 / 4.0\n+            ];\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n@@ -264,6 +284,30 @@ macro_rules! float_tests {\n                 let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n                 assert_biteq!(-v, expected);\n             }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_negative() {\n+                let v = -from_slice(&A);\n+                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                assert_biteq!(v.abs(), expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_positive() {\n+                let v = from_slice(&B);\n+                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                assert_biteq!(v.abs(), expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_odd_floats() {\n+                let v = from_slice(&C);\n+                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                assert_biteq!(v.abs(), expected);\n+            }\n         }\n     }\n }"}]}