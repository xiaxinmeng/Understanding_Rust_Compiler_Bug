{"sha": "dd981989726b297d46573ab5a03a661a31927c83", "node_id": "C_kwDOAAsO6NoAKGRkOTgxOTg5NzI2YjI5N2Q0NjU3M2FiNWEwM2E2NjFhMzE5MjdjODM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-23T00:56:24Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T03:35:14Z"}, "message": "Match on both reveal and solver mode at the same time", "tree": {"sha": "59f0179af364a492048b673b061f930c74ffe648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f0179af364a492048b673b061f930c74ffe648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd981989726b297d46573ab5a03a661a31927c83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd981989726b297d46573ab5a03a661a31927c83", "html_url": "https://github.com/rust-lang/rust/commit/dd981989726b297d46573ab5a03a661a31927c83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd981989726b297d46573ab5a03a661a31927c83/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "980da667fec746b6be52447169bc4ff29855c651", "url": "https://api.github.com/repos/rust-lang/rust/commits/980da667fec746b6be52447169bc4ff29855c651", "html_url": "https://github.com/rust-lang/rust/commit/980da667fec746b6be52447169bc4ff29855c651"}], "stats": {"total": 79, "additions": 38, "deletions": 41}, "files": [{"sha": "a5de4ddee82bae4f9334c3e29babc11c6eb51113", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dd981989726b297d46573ab5a03a661a31927c83/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd981989726b297d46573ab5a03a661a31927c83/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=dd981989726b297d46573ab5a03a661a31927c83", "patch": "@@ -15,51 +15,48 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let opaque_ty = goal.predicate.projection_ty;\n         let expected = goal.predicate.term.ty().expect(\"no such thing as an opaque const\");\n \n-        match goal.param_env.reveal() {\n-            Reveal::UserFacing => match self.solver_mode() {\n-                SolverMode::Normal => {\n-                    let Some(opaque_ty_def_id) = opaque_ty.def_id.as_local() else {\n-                        return Err(NoSolution);\n-                    };\n-                    let opaque_ty =\n-                        ty::OpaqueTypeKey { def_id: opaque_ty_def_id, substs: opaque_ty.substs };\n-                    // FIXME: at some point we should call queries without defining\n-                    // new opaque types but having the existing opaque type definitions.\n-                    // This will require moving this below \"Prefer opaques registered already\".\n-                    if !self.can_define_opaque_ty(opaque_ty_def_id) {\n-                        return Err(NoSolution);\n-                    }\n-                    // FIXME: This may have issues when the substs contain aliases...\n-                    match self.tcx().uses_unique_placeholders_ignoring_regions(opaque_ty.substs) {\n-                        Err(NotUniqueParam::NotParam(param)) if param.is_non_region_infer() => {\n-                            return self.evaluate_added_goals_and_make_canonical_response(\n-                                Certainty::AMBIGUOUS,\n-                            );\n-                        }\n-                        Err(_) => {\n-                            return Err(NoSolution);\n-                        }\n-                        Ok(()) => {}\n+        match (goal.param_env.reveal(), self.solver_mode()) {\n+            (Reveal::UserFacing, SolverMode::Normal) => {\n+                let Some(opaque_ty_def_id) = opaque_ty.def_id.as_local() else {\n+                    return Err(NoSolution);\n+                };\n+                let opaque_ty =\n+                    ty::OpaqueTypeKey { def_id: opaque_ty_def_id, substs: opaque_ty.substs };\n+                // FIXME: at some point we should call queries without defining\n+                // new opaque types but having the existing opaque type definitions.\n+                // This will require moving this below \"Prefer opaques registered already\".\n+                if !self.can_define_opaque_ty(opaque_ty_def_id) {\n+                    return Err(NoSolution);\n+                }\n+                // FIXME: This may have issues when the substs contain aliases...\n+                match self.tcx().uses_unique_placeholders_ignoring_regions(opaque_ty.substs) {\n+                    Err(NotUniqueParam::NotParam(param)) if param.is_non_region_infer() => {\n+                        return self.evaluate_added_goals_and_make_canonical_response(\n+                            Certainty::AMBIGUOUS,\n+                        );\n                     }\n-                    // Prefer opaques registered already.\n-                    let matches =\n-                        self.unify_existing_opaque_tys(goal.param_env, opaque_ty, expected);\n-                    if !matches.is_empty() {\n-                        if let Some(response) = self.try_merge_responses(&matches) {\n-                            return Ok(response);\n-                        } else {\n-                            return self.flounder(&matches);\n-                        }\n+                    Err(_) => {\n+                        return Err(NoSolution);\n                     }\n-                    // Otherwise, define a new opaque type\n-                    self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n-                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                    Ok(()) => {}\n                 }\n-                SolverMode::Coherence => {\n-                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                // Prefer opaques registered already.\n+                let matches = self.unify_existing_opaque_tys(goal.param_env, opaque_ty, expected);\n+                if !matches.is_empty() {\n+                    if let Some(response) = self.try_merge_responses(&matches) {\n+                        return Ok(response);\n+                    } else {\n+                        return self.flounder(&matches);\n+                    }\n                 }\n-            },\n-            Reveal::All => {\n+                // Otherwise, define a new opaque type\n+                self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            (Reveal::UserFacing, SolverMode::Coherence) => {\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+            }\n+            (Reveal::All, _) => {\n                 // FIXME: Add an assertion that opaque type storage is empty.\n                 let actual = tcx.type_of(opaque_ty.def_id).subst(tcx, opaque_ty.substs);\n                 self.eq(goal.param_env, expected, actual)?;"}]}