{"sha": "501eea0842b71f3530c4178e7b50973a728280b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMWVlYTA4NDJiNzFmMzUzMGM0MTc4ZTdiNTA5NzNhNzI4MjgwYjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T10:51:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T10:51:19Z"}, "message": "auto merge of #8744 : jld/rust/discr64, r=nikomatsakis\n\nThis is in preparation for making discriminants not always be int (#1647), but it also makes compiles for a 64-bit target not behave differently \u2014 with respect to how many bits of discriminants are preserved \u2014 depending on the build host's word size, which is a nice property to have.\r\n\r\nWe may want to standardize how to abbreviate \"discriminant\" in a followup change.", "tree": {"sha": "86bf3fbbc4ea90aa5f3789492c3d46097c293a9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86bf3fbbc4ea90aa5f3789492c3d46097c293a9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/501eea0842b71f3530c4178e7b50973a728280b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/501eea0842b71f3530c4178e7b50973a728280b6", "html_url": "https://github.com/rust-lang/rust/commit/501eea0842b71f3530c4178e7b50973a728280b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/501eea0842b71f3530c4178e7b50973a728280b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd188d003b56b55f534ad692ea1b17ca569b6fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd188d003b56b55f534ad692ea1b17ca569b6fe", "html_url": "https://github.com/rust-lang/rust/commit/bdd188d003b56b55f534ad692ea1b17ca569b6fe"}, {"sha": "0db2b198f2ff3e5353acbc477a47592d1f43480e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0db2b198f2ff3e5353acbc477a47592d1f43480e", "html_url": "https://github.com/rust-lang/rust/commit/0db2b198f2ff3e5353acbc477a47592d1f43480e"}], "stats": {"total": 126, "additions": 79, "deletions": 47}, "files": [{"sha": "3fdd1587c0d7adbde4d8add3b46b947c843bb90f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -26,7 +26,7 @@ use middle::astencode::vtable_decoder_helpers;\n \n \n use std::hash::HashUtil;\n-use std::uint;\n+use std::u64;\n use std::io::WriterUtil;\n use std::io;\n use std::option;\n@@ -207,9 +207,9 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n+fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n-        do reader::with_doc_data(val_doc) |data| { uint::parse_bytes(data, 10u) }\n+        do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n     }\n }\n "}, {"sha": "21eee26620c0d74d25f2c63022184a306c81bc98", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -292,7 +292,7 @@ fn encode_symbol(ecx: &EncodeContext,\n \n fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n-                   disr_val: uint) {\n+                   disr_val: ty::Disr) {\n     ebml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_str();\n     ebml_w.writer.write(s.as_bytes());"}, {"sha": "9a92d91ab5041032f0fdbcecdaada1abbba29a39", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -245,7 +245,7 @@ pub enum VecLenOpt {\n // range)\n enum Opt {\n     lit(Lit),\n-    var(/* disr val */ uint, @adt::Repr),\n+    var(ty::Disr, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n@@ -992,7 +992,7 @@ struct ExtractedBlock {\n \n fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n-                            disr_val: uint,\n+                            disr_val: ty::Disr,\n                             val: ValueRef)\n     -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_variant_args\");"}, {"sha": "5c255ad081811e85185549417eee9a35d4082ad3", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -55,6 +55,7 @@ use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::ty;\n+use middle::ty::Disr;\n use syntax::ast;\n use util::ppaux::ty_to_str;\n \n@@ -64,7 +65,7 @@ use middle::trans::type_::Type;\n /// Representations.\n pub enum Repr {\n     /// C-like enums; basically an int.\n-    CEnum(uint, uint), // discriminant range\n+    CEnum(Disr, Disr), // discriminant range\n     /**\n      * Single-case variants, and structs/tuples/records.\n      *\n@@ -89,7 +90,7 @@ pub enum Repr {\n      * is represented such that `None` is a null pointer and `Some` is the\n      * identity function.\n      */\n-    NullablePointer{ nonnull: Struct, nndiscr: uint, ptrfield: uint,\n+    NullablePointer{ nonnull: Struct, nndiscr: Disr, ptrfield: uint,\n                      nullfields: ~[ty::t] }\n }\n \n@@ -140,7 +141,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: uint, tys: ~[ty::t] };\n+            struct Case { discr: Disr, tys: ~[ty::t] };\n             impl Case {\n                 fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n                     mk_struct(cx, self.tys, false).size == 0\n@@ -177,7 +178,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.iter().enumerate().all(|(i,c)| c.discr == i) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))\n@@ -305,16 +306,16 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n-        Univariant(*) => C_uint(bcx.ccx(), 0),\n-        General(ref cases) => load_discr(bcx, scrutinee, 0, cases.len() - 1),\n+        Univariant(*) => C_disr(bcx.ccx(), 0),\n+        General(ref cases) => load_discr(bcx, scrutinee, 0, (cases.len() - 1) as Disr),\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n                  Type::enum_discrim(bcx.ccx()))\n         }\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: uint, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -323,7 +324,7 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: uint, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: uint, max: uint)\n+fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n     if max + 1 == min {\n@@ -347,16 +348,16 @@ fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: uint, max: uint)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @mut Block, r: &Repr, discr: uint) -> _match::opt_result {\n+pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n         CEnum(*) => {\n-            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n         }\n         Univariant(*) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n         General(*) => {\n-            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n         }\n         NullablePointer{ _ } => {\n             assert!(discr == 0 || discr == 1);\n@@ -370,11 +371,11 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: uint) -> _match::opt_result\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n+pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(min, max) => {\n             assert!(min <= discr && discr <= max);\n-            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n@@ -385,7 +386,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n             assert_eq!(discr, 0);\n         }\n         General(*) => {\n-            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr != nndiscr {\n@@ -401,7 +402,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n  * The number of fields in a given case; for use when obtaining this\n  * information from the type or definition is less convenient.\n  */\n-pub fn num_args(r: &Repr, discr: uint) -> uint {\n+pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     match *r {\n         CEnum(*) => 0,\n         Univariant(ref st, dtor) => {\n@@ -416,7 +417,7 @@ pub fn num_args(r: &Repr, discr: uint) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint,\n+pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -494,13 +495,13 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n+pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n             assert_eq!(vals.len(), 0);\n             assert!(min <= discr && discr <= max);\n-            C_uint(ccx, discr)\n+            C_disr(ccx, discr)\n         }\n         Univariant(ref st, _dro) => {\n             assert_eq!(discr, 0);\n@@ -509,7 +510,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n         General(ref cases) => {\n             let case = &cases[discr];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n-            let discr_ty = C_uint(ccx, discr);\n+            let discr_ty = C_disr(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n             C_struct(contents + &[padding(max_sz - case.size)])\n@@ -581,15 +582,15 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n-    -> uint {\n+    -> Disr {\n     match *r {\n-        CEnum(*) => const_to_uint(val) as uint,\n+        CEnum(*) => const_to_uint(val) as Disr,\n         Univariant(*) => 0,\n-        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as uint,\n+        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr,\n         NullablePointer{ nndiscr, ptrfield, _ } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as uint\n+                (1 - nndiscr) as Disr\n             } else {\n                 nndiscr\n             }\n@@ -605,7 +606,7 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n  * raw LLVM-level structs and arrays.)\n  */\n pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: uint, ix: uint) -> ValueRef {\n+                       _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n@@ -644,3 +645,7 @@ pub fn is_newtypeish(r: &Repr) -> bool {\n         _ => false\n     }\n }\n+\n+fn C_disr(cx: &CrateContext, i: Disr) -> ValueRef {\n+    return C_integral(cx.int_type, i, false);\n+}"}, {"sha": "634e339e03de068bf7ac9220f1ac2e2e944bbf70", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -2014,7 +2014,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n-                          disr: uint,\n+                          disr: ty::Disr,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n@@ -2063,7 +2063,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @mut CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n-    disr: uint,\n+    disr: ty::Disr,\n     param_substs: Option<@param_substs>,\n     llfndecl: ValueRef)\n {"}, {"sha": "2ac481cf73070b9bf4b0f19abc5c3645ddd34f0e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -453,7 +453,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, repr, v);\n-                let iv = C_uint(cx, discr);\n+                let iv = C_integral(cx.int_type, discr, false);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {"}, {"sha": "06c45e563c0da36622e7671e90ce5aa7d1de8251", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -1118,7 +1118,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::NodeId>,\n-                         op: &fn(uint, (&[ty::field])) -> R) -> R {\n+                         op: &fn(ty::Disr, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))\n@@ -1235,7 +1235,7 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n+fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> @mut Block {"}, {"sha": "98d2b6df88787531cd945f7bdf94d987920dbf9e", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -317,7 +317,7 @@ impl Reflector {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n-                                         this.c_uint(v.disr_val),\n+                                         C_integral(self.bcx.ccx().int_type, v.disr_val, false),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {"}, {"sha": "6593e5632fbd84567fb7098f17ec8a3d93939e17", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -48,7 +48,9 @@ use syntax::abi::AbiSet;\n use syntax;\n use extra::enum_set::{EnumSet, CLike};\n \n-pub static INITIAL_DISCRIMINANT_VALUE: uint = 0;\n+pub type Disr = u64;\n+\n+pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n@@ -3803,7 +3805,7 @@ pub struct VariantInfo {\n     ctor_ty: t,\n     name: ast::ident,\n     id: ast::def_id,\n-    disr_val: uint,\n+    disr_val: Disr,\n     vis: visibility\n }\n \n@@ -3814,7 +3816,7 @@ impl VariantInfo {\n     /// Does not do any caching of the value in the type context.\n     pub fn from_ast_variant(cx: ctxt,\n                             ast_variant: &ast::variant,\n-                            discriminant: uint) -> VariantInfo {\n+                            discriminant: Disr) -> VariantInfo {\n \n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n \n@@ -4008,7 +4010,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut last_discriminant: Option<uint> = None;\n+            let mut last_discriminant: Option<Disr> = None;\n             @enum_definition.variants.iter().map(|variant| {\n \n                 let mut discriminant = match last_discriminant {\n@@ -4018,8 +4020,8 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n \n                 match variant.node.disr_expr {\n                     Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                        Ok(const_eval::const_int(val)) => discriminant = val as uint,\n-                        Ok(const_eval::const_uint(val)) => discriminant = val as uint,\n+                        Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n+                        Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n                         Ok(_) => {\n                             cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}, {"sha": "a839ea976e62e60a44481aadac5f2b9a315b8556", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -83,7 +83,7 @@ use middle::pat_util;\n use middle::lint::unreachable_code;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{substs, param_ty, ExprTyProvider};\n+use middle::ty::{substs, param_ty, Disr, ExprTyProvider};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -3000,8 +3000,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: ~[@ty::VariantInfo] = ~[];\n-        let mut disr_vals: ~[uint] = ~[];\n-        let mut prev_disr_val: Option<uint> = None;\n+        let mut disr_vals: ~[ty::Disr] = ~[];\n+        let mut prev_disr_val: Option<ty::Disr> = None;\n \n         for v in vs.iter() {\n \n@@ -3024,8 +3024,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     // handle, so we may still get an internal compiler error\n \n                     match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as uint,\n-                        Ok(const_eval::const_uint(val)) => current_disr_val = val as uint,\n+                        Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n+                        Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}, {"sha": "a0b180f6e6df2ae7fe2a88538e2e4cca2eb32af3", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/501eea0842b71f3530c4178e7b50973a728280b6/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501eea0842b71f3530c4178e7b50973a728280b6/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=501eea0842b71f3530c4178e7b50973a728280b6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sys;\n+\n+pub fn main() {\n+    enum E { V = 0x1717171717171717 }\n+    static C: E = V;\n+    let expected: u64 = if sys::size_of::<uint>() < 8 {\n+        0x17171717\n+    } else {\n+        0x1717171717171717\n+    };\n+    assert_eq!(expected, V as u64);\n+    assert_eq!(expected, C as u64);\n+    assert_eq!(fmt!(\"%?\", V), ~\"V\");\n+    assert_eq!(fmt!(\"%?\", C), ~\"V\");\n+}"}]}