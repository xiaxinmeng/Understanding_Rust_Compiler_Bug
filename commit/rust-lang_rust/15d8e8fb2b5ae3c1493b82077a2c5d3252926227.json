{"sha": "15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZDhlOGZiMmI1YWUzYzE0OTNiODIwNzdhMmM1ZDMyNTI5MjYyMjc=", "commit": {"author": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-12-22T23:06:14Z"}, "committer": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2019-01-09T01:57:22Z"}, "message": "[Cleanup] This is the first in the series of removals of with_freevars usage.\n\nCurrently, there are many places in rustc, where we use\nwith_freevars to iterate over freevars of a closure. The\nproblem with this is the argument to with_freevars is a\nNodeId and this will get in the way of our eventual goal\nof solving for issue (#53488), sub-issue (#56905)", "tree": {"sha": "65b1edb099ef9e8ba0858c7a7a349a4b7bc60153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b1edb099ef9e8ba0858c7a7a349a4b7bc60153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "html_url": "https://github.com/rust-lang/rust/commit/15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/comments", "author": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7853b780fc678e670362690ddeb8648d552db0bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7853b780fc678e670362690ddeb8648d552db0bf", "html_url": "https://github.com/rust-lang/rust/commit/7853b780fc678e670362690ddeb8648d552db0bf"}], "stats": {"total": 120, "additions": 74, "deletions": 46}, "files": [{"sha": "8d4b8aae8b1767641a3705010f4fdd0e4a7f668c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "patch": "@@ -422,7 +422,7 @@ pub struct TypeckTables<'tcx> {\n     /// The upvarID contains the HIR node ID and it also contains the full path\n     /// leading to the member of the struct or tuple that is used instead of the\n     /// entire variable.\n-    pub upvar_list: ty::UpvarListMap<'tcx>,\n+    pub upvar_list: ty::UpvarListMap,\n }\n \n impl<'tcx> TypeckTables<'tcx> {"}, {"sha": "cfd99948e4370424f991da6d61dc16a159006182", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "patch": "@@ -808,7 +808,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n-pub type UpvarListMap<'tcx> = FxHashMap<ast::NodeId, Vec<UpvarId>>;\n+pub type UpvarListMap = FxHashMap<DefId, Vec<UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]"}, {"sha": "b1a377591e31025c1243bd1fa10080cada89a9b2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "patch": "@@ -4,7 +4,7 @@ use hair::cx::Cx;\n use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::hir::def_id::{DefId, LocalDefId};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n@@ -640,47 +640,49 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let arguments: Vec<_> = arguments.collect();\n \n     let tcx = hir.tcx();\n-    let span = tcx.hir().span(fn_id);\n+    let tcx_hir = tcx.hir();\n+    let span = tcx_hir.span(fn_id);\n \n-    // hir.tables().upvar_list[fn_id].\n-    // Gather the upvars of a closure, if any.\n-    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n-        freevars.iter().map(|fv| {\n-            let var_id = fv.var_id();\n-            let var_hir_id = tcx.hir().node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir().local_def_id(fn_id);\n-            let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_path: ty::UpvarPath {hir_id: var_hir_id},\n-                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n-            });\n-            let by_ref = match capture {\n-                ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => true\n-            };\n-            let mut decl = UpvarDecl {\n-                debug_name: keywords::Invalid.name(),\n-                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n-                by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            if let Some(Node::Binding(pat)) = tcx.hir().find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n+    let hir_tables = hir.tables();\n+    let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n-                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::MutMutable) {\n-                            decl.mutability = Mutability::Mut;\n+    // Gather the upvars of a closure, if any.\n+    let upvar_decls: Vec<_> = match hir_tables.upvar_list.get(&fn_def_id) {\n+        Some(upvars) => upvars\n+            .iter()\n+            .map(|upvar_id| {\n+                let var_hir_id = upvar_id.var_path.hir_id;\n+                let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n+                let capture = hir_tables.upvar_capture(*upvar_id);\n+                let by_ref = match capture {\n+                    ty::UpvarCapture::ByValue => false,\n+                    ty::UpvarCapture::ByRef(..) => true,\n+                };\n+                let mut decl = UpvarDecl {\n+                    debug_name: keywords::Invalid.name(),\n+                    var_hir_id: ClearCrossCrate::Set(var_hir_id),\n+                    by_ref,\n+                    mutability: Mutability::Not,\n+                };\n+                if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                        decl.debug_name = ident.name;\n+                        if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                            if bm == ty::BindByValue(hir::MutMutable) {\n+                                decl.mutability = Mutability::Mut;\n+                            } else {\n+                                decl.mutability = Mutability::Not;\n+                            }\n                         } else {\n-                            decl.mutability = Mutability::Not;\n+                            tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                         }\n-                    } else {\n-                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n-            }\n-            decl\n-        }).collect()\n-    });\n+                decl\n+            })\n+            .collect(),\n+        _ => vec![],\n+    };\n \n     let mut builder = Builder::new(hir,\n         span,\n@@ -690,7 +692,6 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         return_ty_span,\n         upvar_decls);\n \n-    let fn_def_id = tcx.hir().local_def_id(fn_id);\n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n         data: region::ScopeData::CallSite\n@@ -733,7 +734,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    let closure_expr_id = tcx.hir().local_def_id(fn_id);\n+    let closure_expr_id = tcx_hir.local_def_id(fn_id);\n     info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n           tcx.get_attrs(closure_expr_id));\n "}, {"sha": "ffd7c2114e5ab34294c4f03584d02d669ce4cf42", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "patch": "@@ -156,10 +156,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Add the vector of freevars to the map keyed with the closure id.\n             // This gives us an easier access to them without having to call\n             // with_freevars again..\n-            self.tables\n-                .borrow_mut()\n-                .upvar_list\n-                .insert(closure_node_id, freevar_list);\n+            if !freevar_list.is_empty() {\n+                self.tables\n+                    .borrow_mut()\n+                    .upvar_list\n+                    .insert(closure_def_id, freevar_list);\n+            }\n         });\n \n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());"}, {"sha": "8499a492bccec7bc7523ff943258fea194b88c84", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8e8fb2b5ae3c1493b82077a2c5d3252926227/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "patch": "@@ -20,6 +20,15 @@ use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n+/// During type inference, partially inferred types are\n+/// represented using Type variables (ty::Infer). These don't appear in\n+/// the final TypeckTables since all of the types should have been\n+/// inferred once typeck_tables_of is done.\n+/// When type inference is running however, having to update the typeck\n+/// tables every time a new type is inferred would be unreasonably slow,\n+/// so instead all of the replacement happens at the end in\n+/// resolve_type_vars_in_body, which creates a new TypeTables which\n+/// doesn't contain any inference types.\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n@@ -35,7 +44,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n         wbcx.visit_body(body);\n-        wbcx.visit_upvar_borrow_map();\n+        wbcx.visit_upvar_capture_map();\n+        wbcx.visit_upvar_list_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n@@ -291,7 +301,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_upvar_borrow_map(&mut self) {\n+    fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n@@ -314,6 +324,21 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Runs through the function context's upvar list map and adds the same to\n+    /// the TypeckTables. upvarlist is a hashmap of the list of upvars referred\n+    /// to in a closure..\n+    fn visit_upvar_list_map(&mut self) {\n+        for (closure_def_id, upvar_list) in self.fcx.tables.borrow().upvar_list.iter() {\n+            debug!(\n+                \"UpvarIDs captured by closure {:?} are: {:?}\",\n+                closure_def_id, upvar_list\n+            );\n+            self.tables\n+                .upvar_list\n+                .insert(*closure_def_id, upvar_list.to_vec());\n+        }\n+    }\n+\n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);"}]}