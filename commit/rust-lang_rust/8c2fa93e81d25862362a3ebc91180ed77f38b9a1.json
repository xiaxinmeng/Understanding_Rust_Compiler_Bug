{"sha": "8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMmZhOTNlODFkMjU4NjIzNjJhM2ViYzkxMTgwZWQ3N2YzOGI5YTE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-05T20:20:23Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-09T00:48:44Z"}, "message": "Remove a use of `ast_map.span_if_local()` in `resolve`", "tree": {"sha": "9ae35c272624c26f1447354430d34f7d7011849c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ae35c272624c26f1447354430d34f7d7011849c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "html_url": "https://github.com/rust-lang/rust/commit/8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c2fa93e81d25862362a3ebc91180ed77f38b9a1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebe6da34ffc72a701f4189ef7be5ab2c1cb6e8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6da34ffc72a701f4189ef7be5ab2c1cb6e8c9", "html_url": "https://github.com/rust-lang/rust/commit/ebe6da34ffc72a701f4189ef7be5ab2c1cb6e8c9"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "6f7904e0efb376a68ebee35de219ec180da70ce0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8c2fa93e81d25862362a3ebc91180ed77f38b9a1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2fa93e81d25862362a3ebc91180ed77f38b9a1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "patch": "@@ -145,7 +145,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference(DefId, Option<Name>),\n+    StaticVariableReference(&'a NameBinding<'a>),\n     /// error E0418: is not an enum variant, struct or const\n     NotAnEnumVariantStructOrConst(&'a str),\n     /// error E0419: unresolved enum variant, struct or const\n@@ -197,16 +197,16 @@ enum UnresolvedNameContext<'a> {\n     Other,\n }\n \n-fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n-                                       span: syntax::codemap::Span,\n-                                       resolution_error: ResolutionError<'b>) {\n+fn resolve_error<'b, 'a: 'b, 'tcx: 'a, 'c>(resolver: &'b Resolver<'a, 'tcx>,\n+                                           span: syntax::codemap::Span,\n+                                           resolution_error: ResolutionError<'c>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n-fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n-                                              span: syntax::codemap::Span,\n-                                              resolution_error: ResolutionError<'b>)\n-                                              -> DiagnosticBuilder<'a> {\n+fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a, 'c>(resolver: &'b Resolver<'a, 'tcx>,\n+                                                  span: syntax::codemap::Span,\n+                                                  resolution_error: ResolutionError<'b>)\n+                                                  -> DiagnosticBuilder<'c> {\n     if !resolver.emit_errors {\n         return resolver.session.diagnostic().struct_dummy();\n     }\n@@ -350,22 +350,15 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier)\n         }\n-        ResolutionError::StaticVariableReference(did, name) => {\n+        ResolutionError::StaticVariableReference(binding) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0417,\n                                            \"static variables cannot be referenced in a \\\n                                             pattern, use a `const` instead\");\n-            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n-                err.span_note(sp, \"static variable defined here\");\n-            }\n-            if let Some(name) = name {\n-                if let Some(binding) = resolver.current_module\n-                                               .resolve_name_in_lexical_scope(name, ValueNS) {\n-                    if binding.is_import() {\n-                        err.span_note(binding.span, \"static variable imported here\");\n-                    }\n-                }\n+            if binding.span != codemap::DUMMY_SP {\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                err.span_note(binding.span, &format!(\"static variable {} here\", participle));\n             }\n             err\n         }\n@@ -766,10 +759,6 @@ impl<'a> LexicalScopeBinding<'a> {\n         }\n     }\n \n-    fn def(self) -> Def {\n-        self.local_def().def\n-    }\n-\n     fn module(self) -> Option<Module<'a>> {\n         match self {\n             LexicalScopeBinding::Item(binding) => binding.module(),\n@@ -2328,11 +2317,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Def::Variant(..) | Def::Const(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n-                            Def::Static(did, _) => {\n-                                resolve_error(&self,\n-                                              path.span,\n-                                              ResolutionError::StaticVariableReference(\n-                                                  did, None));\n+                            Def::Static(..) => {\n+                                let segments = &path.segments;\n+                                let binding = if path.global {\n+                                    self.resolve_crate_relative_path(path.span, segments, ValueNS)\n+                                } else {\n+                                    self.resolve_module_relative_path(path.span, segments, ValueNS)\n+                                }.unwrap();\n+\n+                                let error = ResolutionError::StaticVariableReference(binding);\n+                                resolve_error(self, path.span, error);\n                                 self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n@@ -2464,17 +2458,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_bare_identifier_pattern(&mut self, ident: hir::Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        match self.resolve_ident_in_lexical_scope(ident, ValueNS, true)\n-                  .map(LexicalScopeBinding::def) {\n-            Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                FoundStructOrEnumVariant(def)\n-            }\n-            Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                FoundConst(def, ident.unhygienic_name)\n-            }\n-            Some(Def::Static(did, _)) => {\n-                resolve_error(self, span, ResolutionError::StaticVariableReference(\n-                    did, Some(ident.unhygienic_name)));\n+        let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n+            Some(LexicalScopeBinding::Item(binding)) => binding,\n+            _ => return BareIdentifierPatternUnresolved,\n+        };\n+        let def = binding.def().unwrap();\n+\n+        match def {\n+            Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n+            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(def, ident.unhygienic_name),\n+            Def::Static(..) => {\n+                let error = ResolutionError::StaticVariableReference(binding);\n+                resolve_error(self, span, error);\n                 BareIdentifierPatternUnresolved\n             }\n             _ => BareIdentifierPatternUnresolved,"}, {"sha": "31604e2fdd3a7175e87e497b543b0a33e168dcc8", "filename": "src/test/compile-fail/issue-23716.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c2fa93e81d25862362a3ebc91180ed77f38b9a1/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2fa93e81d25862362a3ebc91180ed77f38b9a1/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=8c2fa93e81d25862362a3ebc91180ed77f38b9a1", "patch": "@@ -16,7 +16,6 @@ fn bar(foo: i32) {}\n \n mod submod {\n     pub static answer: i32 = 42;\n-    //~^ NOTE static variable defined here\n }\n \n use self::submod::answer;"}]}