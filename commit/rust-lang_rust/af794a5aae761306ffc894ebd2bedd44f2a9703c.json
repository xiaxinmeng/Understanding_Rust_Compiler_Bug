{"sha": "af794a5aae761306ffc894ebd2bedd44f2a9703c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzk0YTVhYWU3NjEzMDZmZmM4OTRlYmQyYmVkZDQ0ZjJhOTcwM2M=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-07T23:26:30Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-08T23:27:38Z"}, "message": "make macros non-capturing", "tree": {"sha": "3387cead84218027fa48e516a3e95239385bc478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3387cead84218027fa48e516a3e95239385bc478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af794a5aae761306ffc894ebd2bedd44f2a9703c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af794a5aae761306ffc894ebd2bedd44f2a9703c", "html_url": "https://github.com/rust-lang/rust/commit/af794a5aae761306ffc894ebd2bedd44f2a9703c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af794a5aae761306ffc894ebd2bedd44f2a9703c/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48c3e5f740df66c192ac9436d99283176aef7649", "url": "https://api.github.com/repos/rust-lang/rust/commits/48c3e5f740df66c192ac9436d99283176aef7649", "html_url": "https://github.com/rust-lang/rust/commit/48c3e5f740df66c192ac9436d99283176aef7649"}], "stats": {"total": 146, "additions": 73, "deletions": 73}, "files": [{"sha": "c1d782991b43d08888aa5b829f410fea866e9c65", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af794a5aae761306ffc894ebd2bedd44f2a9703c/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af794a5aae761306ffc894ebd2bedd44f2a9703c/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=af794a5aae761306ffc894ebd2bedd44f2a9703c", "patch": "@@ -185,15 +185,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n macro_rules! bound_setup {\n     // initialiser of the iterator to manipulate\n-    ($iter:expr,\n+    ($iter:expr, $k:expr,\n      // whether we are looking for the lower or upper bound.\n      $is_lower_bound:expr) => {\n         {\n             let mut iter = $iter;\n             loop {\n                 if !iter.node.is_null() {\n                     let node_k = unsafe {&(*iter.node).key};\n-                    match k.cmp(node_k) {\n+                    match $k.cmp(node_k) {\n                         Less => iter.traverse_left(),\n                         Greater => iter.traverse_right(),\n                         Equal => {\n@@ -230,13 +230,13 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n     pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), true)\n+        bound_setup!(self.iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n     pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), false)\n+        bound_setup!(self.iter_for_traversal(), k, false)\n     }\n \n     /// Get a lazy iterator that should be initialized using\n@@ -256,7 +256,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n     pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.mut_iter_for_traversal(), true)\n+        bound_setup!(self.mut_iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair (with the\n@@ -265,7 +265,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// If all keys in map are not greater than `k` an empty iterator\n     /// is returned.\n     pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.mut_iter_for_traversal(), false)\n+        bound_setup!(self.mut_iter_for_traversal(), k, false)\n     }\n }\n "}, {"sha": "3230873883e19113bcf78fc8e4b9a785080fa7c7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/af794a5aae761306ffc894ebd2bedd44f2a9703c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af794a5aae761306ffc894ebd2bedd44f2a9703c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=af794a5aae761306ffc894ebd2bedd44f2a9703c", "patch": "@@ -769,16 +769,16 @@ pub trait ToPrimitive {\n }\n \n macro_rules! impl_to_primitive_int_to_int(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n-                let n = *self as i64;\n+                let n = $slf as i64;\n                 let min_value: $DstT = Bounded::min_value();\n                 let max_value: $DstT = Bounded::max_value();\n                 if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some(*self as $DstT)\n+                    Some($slf as $DstT)\n                 } else {\n                     None\n                 }\n@@ -788,12 +788,12 @@ macro_rules! impl_to_primitive_int_to_int(\n )\n \n macro_rules! impl_to_primitive_int_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             let zero: $SrcT = Zero::zero();\n             let max_value: $DstT = Bounded::max_value();\n-            if zero <= *self && *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n+            if zero <= $slf && $slf as u64 <= max_value as u64 {\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -805,26 +805,26 @@ macro_rules! impl_to_primitive_int(\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int, *self) }\n             #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n             #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n             #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32, *self) }\n             #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint, *self) }\n             #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n             #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n             #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32, *self) }\n             #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64, *self) }\n \n             #[inline]\n             fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n@@ -841,11 +841,11 @@ impl_to_primitive_int!(i32)\n impl_to_primitive_int!(i64)\n \n macro_rules! impl_to_primitive_uint_to_int(\n-    ($DstT:ty) => (\n+    ($DstT:ty, $slf:expr) => (\n         {\n             let max_value: $DstT = Bounded::max_value();\n-            if *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n+            if $slf as u64 <= max_value as u64 {\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -854,15 +854,15 @@ macro_rules! impl_to_primitive_uint_to_int(\n )\n \n macro_rules! impl_to_primitive_uint_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n                 let zero: $SrcT = Zero::zero();\n                 let max_value: $DstT = Bounded::max_value();\n-                if zero <= *self && *self as u64 <= max_value as u64 {\n-                    Some(*self as $DstT)\n+                if zero <= $slf && $slf as u64 <= max_value as u64 {\n+                    Some($slf as $DstT)\n                 } else {\n                     None\n                 }\n@@ -875,26 +875,26 @@ macro_rules! impl_to_primitive_uint(\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }\n             #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n             #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n             #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }\n             #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint, *self) }\n             #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n             #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n             #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32, *self) }\n             #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64, *self) }\n \n             #[inline]\n             fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n@@ -911,14 +911,14 @@ impl_to_primitive_uint!(u32)\n impl_to_primitive_uint!(u64)\n \n macro_rules! impl_to_primitive_float_to_float(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some(*self as $DstT)\n+            Some($slf as $DstT)\n         } else {\n-            let n = *self as f64;\n+            let n = $slf as f64;\n             let max_value: $SrcT = Bounded::max_value();\n             if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -952,9 +952,9 @@ macro_rules! impl_to_primitive_float(\n             fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n \n             #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n+            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32, *self) }\n             #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n+            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n         }\n     )\n )\n@@ -1104,38 +1104,38 @@ pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n }\n \n macro_rules! impl_from_primitive(\n-    ($T:ty, $to_ty:expr) => (\n+    ($T:ty, $to_ty:ident) => (\n         impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n+            #[inline] fn from_int(n: int) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n+\n+            #[inline] fn from_uint(n: uint) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u64(n: u64) -> Option<$T> { n.$to_ty() }\n+\n+            #[inline] fn from_f32(n: f32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n         }\n     )\n )\n \n-impl_from_primitive!(int, n.to_int())\n-impl_from_primitive!(i8, n.to_i8())\n-impl_from_primitive!(i16, n.to_i16())\n-impl_from_primitive!(i32, n.to_i32())\n-impl_from_primitive!(i64, n.to_i64())\n-impl_from_primitive!(uint, n.to_uint())\n-impl_from_primitive!(u8, n.to_u8())\n-impl_from_primitive!(u16, n.to_u16())\n-impl_from_primitive!(u32, n.to_u32())\n-impl_from_primitive!(u64, n.to_u64())\n-impl_from_primitive!(f32, n.to_f32())\n-impl_from_primitive!(f64, n.to_f64())\n+impl_from_primitive!(int, to_int)\n+impl_from_primitive!(i8, to_i8)\n+impl_from_primitive!(i16, to_i16)\n+impl_from_primitive!(i32, to_i32)\n+impl_from_primitive!(i64, to_i64)\n+impl_from_primitive!(uint, to_uint)\n+impl_from_primitive!(u8, to_u8)\n+impl_from_primitive!(u16, to_u16)\n+impl_from_primitive!(u32, to_u32)\n+impl_from_primitive!(u64, to_u64)\n+impl_from_primitive!(f32, to_f32)\n+impl_from_primitive!(f64, to_f64)\n \n /// Cast from one machine scalar to another.\n ///"}]}