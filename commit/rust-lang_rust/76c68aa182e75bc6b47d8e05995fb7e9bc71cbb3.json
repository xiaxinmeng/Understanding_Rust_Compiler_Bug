{"sha": "76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzY4YWExODJlNzViYzZiNDdkOGUwNTk5NWZiN2U5YmM3MWNiYjM=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-21T09:52:18Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-06T20:48:19Z"}, "message": "Writeback min_capture map to TypeckResults\n\n- Derive TypeFoldable on `hir::place::Place` and associated\n  structs, to them to be written into typeck results.\n\nCo-authored-by: Jennifer Wills <wills.jenniferg@gmail.com>\nCo-authored-by: Logan Mosier <logmosier@gmail.com>", "tree": {"sha": "cc457c17cab854f5ffb3cd8adc3f876272d2a170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc457c17cab854f5ffb3cd8adc3f876272d2a170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "html_url": "https://github.com/rust-lang/rust/commit/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15eaa0020b79ad9a9a0c486d1abd00b29c6c5ae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/15eaa0020b79ad9a9a0c486d1abd00b29c6c5ae2", "html_url": "https://github.com/rust-lang/rust/commit/15eaa0020b79ad9a9a0c486d1abd00b29c6c5ae2"}], "stats": {"total": 158, "additions": 94, "deletions": 64}, "files": [{"sha": "143b3867d9fc754ace4cd74ae2fee40b75a6bc1a", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "patch": "@@ -4,7 +4,18 @@ use crate::ty::Ty;\n use rustc_hir::HirId;\n use rustc_target::abi::VariantIdx;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum PlaceBase {\n     /// A temporary variable\n     Rvalue,\n@@ -16,7 +27,18 @@ pub enum PlaceBase {\n     Upvar(ty::UpvarId),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum ProjectionKind {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref,\n@@ -36,7 +58,18 @@ pub enum ProjectionKind {\n     Subslice,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct Projection<'tcx> {\n     /// Type after the projection is being applied.\n     pub ty: Ty<'tcx>,\n@@ -48,7 +81,7 @@ pub struct Projection<'tcx> {\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n     pub base_ty: Ty<'tcx>,\n@@ -61,7 +94,7 @@ pub struct Place<'tcx> {\n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,"}, {"sha": "1a9a6a33fefd40c313834e81ee518a57976f8ade", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "patch": "@@ -672,15 +672,26 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n@@ -692,7 +703,7 @@ impl UpvarId {\n     }\n }\n \n-#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -746,7 +757,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -763,7 +774,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -790,7 +801,7 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n /// A `Place` and the corresponding `CaptureInfo`.\n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n     pub place: HirPlace<'tcx>,\n     pub info: CaptureInfo<'tcx>,\n@@ -799,7 +810,7 @@ pub struct CapturedPlace<'tcx> {\n /// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///"}, {"sha": "7c9cfe69fc94b4874df12003de13e2224cbe655c", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "patch": "@@ -55,6 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }\n         wbcx.visit_body(body);\n+        wbcx.visit_min_capture_map();\n         wbcx.visit_upvar_capture_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -331,6 +332,37 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n+    fn visit_min_capture_map(&mut self) {\n+        let mut min_captures_wb = ty::MinCaptureInformationMap::with_capacity_and_hasher(\n+            self.fcx.typeck_results.borrow().closure_min_captures.len(),\n+            Default::default(),\n+        );\n+        for (closure_def_id, root_min_captures) in\n+            self.fcx.typeck_results.borrow().closure_min_captures.iter()\n+        {\n+            let mut root_var_map_wb = ty::RootVariableMinCaptureList::with_capacity_and_hasher(\n+                root_min_captures.len(),\n+                Default::default(),\n+            );\n+            for (var_hir_id, min_list) in root_min_captures.iter() {\n+                let min_list_wb = min_list\n+                    .iter()\n+                    .map(|captured_place| {\n+                        let locatable = captured_place.info.expr_id.unwrap_or(\n+                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n+                        );\n+\n+                        self.resolve(captured_place.clone(), &locatable)\n+                    })\n+                    .collect();\n+                root_var_map_wb.insert(*var_hir_id, min_list_wb);\n+            }\n+            min_captures_wb.insert(*closure_def_id, root_var_map_wb);\n+        }\n+\n+        self.typeck_results.closure_min_captures = min_captures_wb;\n+    }\n+\n     fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {"}, {"sha": "8a324807417da0fe5444bf376283d7976bc4e0e7", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 52, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "patch": "@@ -15,7 +15,6 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n-use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n@@ -571,38 +570,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    /// Walk closure captures but using `closure_caputes` instead\n-    /// of `closure_min_captures`.\n-    ///\n-    /// This is needed because clippy uses `ExprUseVisitor` after TypeckResults\n-    /// are written back. We don't currently writeback min_captures to\n-    /// TypeckResults.\n-    fn walk_captures_closure_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n-        // FIXME(arora-aman): Remove this function once rust-lang/project-rfc-2229#18\n-        // is completed.\n-        debug!(\"walk_captures_closure_captures({:?}), \", closure_expr);\n-\n-        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n-        let cl_span = self.tcx().hir().span(closure_expr.hir_id);\n-\n-        let captures = &self.mc.typeck_results.closure_captures[&closure_def_id];\n-\n-        for (&var_id, &upvar_id) in captures {\n-            let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n-            let captured_place =\n-                return_if_err!(self.cat_captured_var(closure_expr.hir_id, cl_span, var_id));\n-            match upvar_capture {\n-                ty::UpvarCapture::ByValue(_) => {\n-                    let mode = copy_or_move(&self.mc, &captured_place);\n-                    self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n-                }\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    self.delegate.borrow(&captured_place, captured_place.hir_id, upvar_borrow.kind);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Handle the case where the current body contains a closure.\n     ///\n     /// When the current body being handled is a closure, then we must make sure that\n@@ -646,16 +613,18 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     let place = &captured_place.place;\n                     let capture_info = captured_place.info;\n \n-                    let upvar_id = if body_owner_is_closure {\n+                    let place_base = if body_owner_is_closure {\n                         // Mark the place to be captured by the enclosing closure\n-                        ty::UpvarId::new(*var_hir_id, self.body_owner)\n+                        PlaceBase::Upvar(ty::UpvarId::new(*var_hir_id, self.body_owner))\n                     } else {\n-                        ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local())\n+                        // If the body owner isn't a closure then the variable must\n+                        // be a local variable\n+                        PlaceBase::Local(*var_hir_id)\n                     };\n                     let place_with_id = PlaceWithHirId::new(\n                         capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n                         place.base_ty,\n-                        PlaceBase::Upvar(upvar_id),\n+                        place_base,\n                         place.projections.clone(),\n                     );\n \n@@ -674,23 +643,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-        } else if self.mc.typeck_results.closure_captures.contains_key(&closure_def_id) {\n-            // Handle the case where clippy calls ExprUseVisitor after\n-            self.walk_captures_closure_captures(closure_expr)\n         }\n     }\n-\n-    fn cat_captured_var(\n-        &mut self,\n-        closure_hir_id: hir::HirId,\n-        closure_span: Span,\n-        var_id: hir::HirId,\n-    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n-        // Create the place for the variable being borrowed, from the\n-        // perspective of the creator (parent) of the closure.\n-        let var_ty = self.mc.node_ty(var_id)?;\n-        self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))\n-    }\n }\n \n fn copy_or_move<'a, 'tcx>("}]}