{"sha": "f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5Yjk1ZjkyYzhhZjA3YTI0YTg3MGU1ZjYxMTdhYTVkZmNlZTVmMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T10:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T10:21:23Z"}, "message": "Auto merge of #86461 - crlf0710:rich_vtable, r=nikomatsakis\n\nRefactor vtable format for upcoming trait_upcasting feature.\n\nThis modifies vtable format:\n1. reordering occurrence order of methods coming from different traits\n2. include `VPtr`s for supertraits where this vtable cannot be directly reused during trait upcasting.\nAlso, during codegen, the vtables corresponding to these newly included `VPtr` will be requested and generated.\n\nFor the cases where this vtable can directly used, now the super trait vtable has exactly the same content to some prefix of this one.\n\nr? `@bjorn3`\ncc `@RalfJung`\ncc `@rust-lang/wg-traits`", "tree": {"sha": "db71445130307ccf0e6f2ff04581852b430dccb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db71445130307ccf0e6f2ff04581852b430dccb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "html_url": "https://github.com/rust-lang/rust/commit/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c66d11a34047be1eb6c50703f8ba6689a15e716", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c66d11a34047be1eb6c50703f8ba6689a15e716", "html_url": "https://github.com/rust-lang/rust/commit/1c66d11a34047be1eb6c50703f8ba6689a15e716"}, {"sha": "fbb353ae2b5cef75c7d97be4f3c2283a63e0fd7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb353ae2b5cef75c7d97be4f3c2283a63e0fd7f", "html_url": "https://github.com/rust-lang/rust/commit/fbb353ae2b5cef75c7d97be4f3c2283a63e0fd7f"}], "stats": {"total": 981, "additions": 894, "deletions": 87}, "files": [{"sha": "36d035cdfd3ae34bd53566d79b0ccad199852d04", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -603,6 +603,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_dump_program_clauses, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_dump_env_program_clauses, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_object_lifetime_default, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_vtable, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/)),\n     gated!(\n         omit_gdb_pretty_printer_section, AssumedUsed, template!(Word),"}, {"sha": "ce1445f8a47466609116d60603fdce9b95c9e02e", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -14,17 +14,17 @@ pub fn anonymize_predicate<'tcx>(\n     tcx.reuse_or_mk_predicate(pred, new)\n }\n \n-struct PredicateSet<'tcx> {\n+pub struct PredicateSet<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n impl PredicateSet<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n         Self { tcx, set: Default::default() }\n     }\n \n-    fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+    pub fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n         //    for<'a> Foo<&'a i32>"}, {"sha": "5904f133e78c34d9a7ddde04178b7bde97dce484", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -1,17 +1,39 @@\n use std::convert::TryFrom;\n+use std::fmt;\n \n use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar, ScalarMaybeUninit};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{self, Instance, PolyTraitRef, Ty, TyCtxt};\n use rustc_ast::Mutability;\n \n-#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+#[derive(Clone, Copy, PartialEq, HashStable)]\n pub enum VtblEntry<'tcx> {\n+    /// destructor of this type (used in vtable header)\n     MetadataDropInPlace,\n+    /// layout size of this type (used in vtable header)\n     MetadataSize,\n+    /// layout align of this type (used in vtable header)\n     MetadataAlign,\n+    /// non-dispatchable associated function that is excluded from trait object\n     Vacant,\n-    Method(DefId, SubstsRef<'tcx>),\n+    /// dispatchable associated function\n+    Method(Instance<'tcx>),\n+    /// pointer to a separate supertrait vtable, can be used by trait upcasting coercion\n+    TraitVPtr(PolyTraitRef<'tcx>),\n+}\n+\n+impl<'tcx> fmt::Debug for VtblEntry<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // We want to call `Display` on `Instance` and `PolyTraitRef`,\n+        // so we implement this manually.\n+        match self {\n+            VtblEntry::MetadataDropInPlace => write!(f, \"MetadataDropInPlace\"),\n+            VtblEntry::MetadataSize => write!(f, \"MetadataSize\"),\n+            VtblEntry::MetadataAlign => write!(f, \"MetadataAlign\"),\n+            VtblEntry::Vacant => write!(f, \"Vacant\"),\n+            VtblEntry::Method(instance) => write!(f, \"Method({})\", instance),\n+            VtblEntry::TraitVPtr(trait_ref) => write!(f, \"TraitVPtr({})\", trait_ref),\n+        }\n+    }\n }\n \n pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n@@ -36,11 +58,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n         drop(vtables_cache);\n \n-        // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n-        assert!(\n-            !ty.needs_subst() && !poly_trait_ref.map_or(false, |trait_ref| trait_ref.needs_subst())\n-        );\n-        let param_env = ty::ParamEnv::reveal_all();\n         let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n             let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n             let trait_ref = tcx.erase_regions(trait_ref);\n@@ -50,8 +67,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             COMMON_VTABLE_ENTRIES\n         };\n \n-        let layout =\n-            tcx.layout_of(param_env.and(ty)).expect(\"failed to build vtable representation\");\n+        let layout = tcx\n+            .layout_of(ty::ParamEnv::reveal_all().and(ty))\n+            .expect(\"failed to build vtable representation\");\n         assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n@@ -79,19 +97,21 @@ impl<'tcx> TyCtxt<'tcx> {\n                 VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n                 VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n                 VtblEntry::Vacant => continue,\n-                VtblEntry::Method(def_id, substs) => {\n-                    // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n-                    assert!(!substs.needs_subst());\n-\n+                VtblEntry::Method(instance) => {\n                     // Prepare the fn ptr we write into the vtable.\n-                    let instance =\n-                        ty::Instance::resolve_for_vtable(tcx, param_env, *def_id, substs)\n-                            .expect(\"resolution failed during building vtable representation\")\n-                            .polymorphize(tcx);\n+                    let instance = instance.polymorphize(tcx);\n                     let fn_alloc_id = tcx.create_fn_alloc(instance);\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n                     ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n+                VtblEntry::TraitVPtr(trait_ref) => {\n+                    let super_trait_ref = trait_ref.map_bound(|trait_ref| {\n+                        ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n+                    });\n+                    let supertrait_alloc_id = self.vtable_allocation(ty, Some(super_trait_ref));\n+                    let vptr = Pointer::from(supertrait_alloc_id);\n+                    ScalarMaybeUninit::from_pointer(vptr, &tcx)\n+                }\n             };\n             vtable\n                 .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)"}, {"sha": "95c4237f38396b58c9e5c12c9f8eba2b40f67b56", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -1116,13 +1116,13 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n                     | VtblEntry::MetadataSize\n                     | VtblEntry::MetadataAlign\n                     | VtblEntry::Vacant => None,\n-                    VtblEntry::Method(def_id, substs) => ty::Instance::resolve_for_vtable(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        *def_id,\n-                        substs,\n-                    )\n-                    .filter(|instance| should_codegen_locally(tcx, instance)),\n+                    VtblEntry::TraitVPtr(_) => {\n+                        // all super trait items already covered, so skip them.\n+                        None\n+                    }\n+                    VtblEntry::Method(instance) => {\n+                        Some(*instance).filter(|instance| should_codegen_locally(tcx, instance))\n+                    }\n                 })\n                 .map(|item| create_fn_mono_item(tcx, item, source));\n             output.extend(methods);"}, {"sha": "c0f63f40853da98e98cfd043d2e054bb5b903b70", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -1047,6 +1047,7 @@ symbols! {\n         rustc_dump_env_program_clauses,\n         rustc_dump_program_clauses,\n         rustc_dump_user_substs,\n+        rustc_dump_vtable,\n         rustc_error,\n         rustc_evaluate_where_clauses,\n         rustc_expected_cgu_reuse,"}, {"sha": "017a7c45bbf9d21fd8d6c49dad2264a9a6beac92", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -31,6 +31,8 @@ extern crate rustc_data_structures;\n extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n+#[macro_use]\n+extern crate smallvec;\n \n pub mod autoderef;\n pub mod infer;"}, {"sha": "693384602a75f7090aa2b245c57126c5d1b29df2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 319, "deletions": 58, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -34,9 +34,11 @@ use rustc_middle::ty::{\n     self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry, WithConstness,\n     COMMON_VTABLE_ENTRIES,\n };\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n+use smallvec::SmallVec;\n \n use std::fmt::Debug;\n+use std::ops::ControlFlow;\n \n pub use self::FulfillmentErrorCode::*;\n pub use self::ImplSource::*;\n@@ -454,6 +456,174 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     result\n }\n \n+#[derive(Clone, Debug)]\n+enum VtblSegment<'tcx> {\n+    MetadataDSA,\n+    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n+}\n+\n+/// Prepare the segments for a vtable\n+fn prepare_vtable_segments<'tcx, T>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n+) -> Option<T> {\n+    // The following constraints holds for the final arrangement.\n+    // 1. The whole virtual table of the first direct super trait is included as the\n+    //    the prefix. If this trait doesn't have any super traits, then this step\n+    //    consists of the dsa metadata.\n+    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n+    //    other super traits except those already included as part of the first\n+    //    direct super trait virtual table.\n+    // 3. finally, the own methods of this trait.\n+\n+    // This has the advantage that trait upcasting to the first direct super trait on each level\n+    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n+    // while not using too much extra memory.\n+\n+    // For a single inheritance relationship like this,\n+    //   D --> C --> B --> A\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, D\n+\n+    // For a multiple inheritance relationship like this,\n+    //   D --> C --> A\n+    //           \\-> B\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D\n+\n+    // For a diamond inheritance relationship like this,\n+    //   D --> B --> A\n+    //     \\-> C -/\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, C-vptr, D\n+\n+    // For a more complex inheritance relationship like this:\n+    //   O --> G --> C --> A\n+    //     \\     \\     \\-> B\n+    //     |     |-> F --> D\n+    //     |           \\-> E\n+    //     |-> N --> J --> H\n+    //           \\     \\-> I\n+    //           |-> M --> K\n+    //                 \\-> L\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n+    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n+    //  N, N-vptr, O\n+\n+    // emit dsa segment first.\n+    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n+        return Some(v);\n+    }\n+\n+    let mut emit_vptr_on_new_entry = false;\n+    let mut visited = util::PredicateSet::new(tcx);\n+    let predicate = trait_ref.without_const().to_predicate(tcx);\n+    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n+        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n+    visited.insert(predicate);\n+\n+    // the main traversal loop:\n+    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n+    // that each node is emited after all its descendents have been emitted.\n+    // so we convert the directed graph into a tree by skipping all previously visted nodes using a visited set.\n+    // this is done on the fly.\n+    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n+    // stops after it finds a node that has a next-sibling node.\n+    // This next-sibling node will used as the starting point of next slice.\n+\n+    // Example:\n+    // For a diamond inheritance relationship like this,\n+    //   D#1 --> B#0 --> A#0\n+    //     \\-> C#1 -/\n+\n+    // Starting point 0 stack [D]\n+    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n+    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n+    // Loop run #0: Emiting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n+    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n+    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n+    // Loop run #1: Emiting the slice [D C] (in reverse order). No one has a next-sibling node.\n+    // Loop run #1: Stack after exiting out is []. Now the function exits.\n+\n+    loop {\n+        // dive deeper into the stack, recording the path\n+        'diving_in: loop {\n+            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n+                let inner_most_trait_ref = *inner_most_trait_ref;\n+                let mut direct_super_traits_iter = tcx\n+                    .super_predicates_of(inner_most_trait_ref.def_id())\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(move |(pred, _)| {\n+                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_ref()\n+                    });\n+\n+                'diving_in_skip_visited_traits: loop {\n+                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n+                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n+                            stack.push((\n+                                next_super_trait.value,\n+                                emit_vptr_on_new_entry,\n+                                Some(direct_super_traits_iter),\n+                            ));\n+                            break 'diving_in_skip_visited_traits;\n+                        } else {\n+                            continue 'diving_in_skip_visited_traits;\n+                        }\n+                    } else {\n+                        break 'diving_in;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Other than the left-most path, vptr should be emitted for each trait.\n+        emit_vptr_on_new_entry = true;\n+\n+        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n+        'exiting_out: loop {\n+            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n+                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n+                    trait_ref: *inner_most_trait_ref,\n+                    emit_vptr: *emit_vptr,\n+                }) {\n+                    return Some(v);\n+                }\n+\n+                'exiting_out_skip_visited_traits: loop {\n+                    if let Some(siblings) = siblings_opt {\n+                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n+                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n+                                *inner_most_trait_ref = next_inner_most_trait_ref.value;\n+                                *emit_vptr = emit_vptr_on_new_entry;\n+                                break 'exiting_out;\n+                            } else {\n+                                continue 'exiting_out_skip_visited_traits;\n+                            }\n+                        }\n+                    }\n+                    stack.pop();\n+                    continue 'exiting_out;\n+                }\n+            }\n+            // all done\n+            return None;\n+        }\n+    }\n+}\n+\n+fn dump_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    entries: &[VtblEntry<'tcx>],\n+) {\n+    let msg = format!(\"Vtable entries for `{}`: {:#?}\", trait_ref, entries);\n+    tcx.sess.struct_span_err(sp, &msg).emit();\n+}\n+\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n fn vtable_entries<'tcx>(\n@@ -462,57 +632,86 @@ fn vtable_entries<'tcx>(\n ) -> &'tcx [VtblEntry<'tcx>] {\n     debug!(\"vtable_entries({:?})\", trait_ref);\n \n-    let entries = COMMON_VTABLE_ENTRIES.iter().cloned().chain(\n-        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-            let trait_methods = tcx\n-                .associated_items(trait_ref.def_id())\n-                .in_definition_order()\n-                .filter(|item| item.kind == ty::AssocKind::Fn);\n-\n-            // Now list each method's DefId and InternalSubsts (for within its trait).\n-            // If the method can never be called from this object, produce `Vacant`.\n-            trait_methods.map(move |trait_method| {\n-                debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n-                let def_id = trait_method.def_id;\n-\n-                // Some methods cannot be called on an object; skip those.\n-                if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                    debug!(\"vtable_entries: not vtable safe\");\n-                    return VtblEntry::Vacant;\n-                }\n+    let mut entries = vec![];\n \n-                // The method may have some early-bound lifetimes; add regions for those.\n-                let substs = trait_ref.map_bound(|trait_ref| {\n-                    InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                        GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                            trait_ref.substs[param.index as usize]\n-                        }\n-                    })\n+    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n+        match segment {\n+            VtblSegment::MetadataDSA => {\n+                entries.extend(COMMON_VTABLE_ENTRIES);\n+            }\n+            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                let trait_methods = tcx\n+                    .associated_items(trait_ref.def_id())\n+                    .in_definition_order()\n+                    .filter(|item| item.kind == ty::AssocKind::Fn);\n+                // Now list each method's DefId and InternalSubsts (for within its trait).\n+                // If the method can never be called from this object, produce `Vacant`.\n+                let own_entries = trait_methods.map(move |trait_method| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n+                    let def_id = trait_method.def_id;\n+\n+                    // Some methods cannot be called on an object; skip those.\n+                    if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+                        debug!(\"vtable_entries: not vtable safe\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    // The method may have some early-bound lifetimes; add regions for those.\n+                    let substs = trait_ref.map_bound(|trait_ref| {\n+                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                            GenericParamDefKind::Type { .. }\n+                            | GenericParamDefKind::Const { .. } => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        })\n+                    });\n+\n+                    // The trait type may have higher-ranked lifetimes in it;\n+                    // erase them if they appear, so that we get the type\n+                    // at some particular call site.\n+                    let substs = tcx\n+                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                    // It's possible that the method relies on where-clauses that\n+                    // do not hold for this particular set of type parameters.\n+                    // Note that this method could then never be called, so we\n+                    // do not want to try and codegen it, in that case (see #23435).\n+                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                    if impossible_predicates(tcx, predicates.predicates) {\n+                        debug!(\"vtable_entries: predicates do not hold\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    let instance = ty::Instance::resolve_for_vtable(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .expect(\"resolution failed during building vtable representation\");\n+                    VtblEntry::Method(instance)\n                 });\n \n-                // The trait type may have higher-ranked lifetimes in it;\n-                // erase them if they appear, so that we get the type\n-                // at some particular call site.\n-                let substs =\n-                    tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-                // It's possible that the method relies on where-clauses that\n-                // do not hold for this particular set of type parameters.\n-                // Note that this method could then never be called, so we\n-                // do not want to try and codegen it, in that case (see #23435).\n-                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                if impossible_predicates(tcx, predicates.predicates) {\n-                    debug!(\"vtable_entries: predicates do not hold\");\n-                    return VtblEntry::Vacant;\n+                entries.extend(own_entries);\n+\n+                if emit_vptr {\n+                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n                 }\n+            }\n+        }\n \n-                VtblEntry::Method(def_id, substs)\n-            })\n-        }),\n-    );\n+        ControlFlow::Continue(())\n+    };\n+\n+    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n+\n+    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n+        let sp = tcx.def_span(trait_ref.def_id());\n+        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n+    }\n \n-    tcx.arena.alloc_from_iter(entries)\n+    tcx.arena.alloc_from_iter(entries.into_iter())\n }\n \n /// Find slot base for trait methods within vtable entries of another trait\n@@ -525,20 +724,82 @@ fn vtable_trait_first_method_offset<'tcx>(\n ) -> usize {\n     let (trait_to_be_found, trait_owning_vtable) = key;\n \n-    let mut supertraits = util::supertraits(tcx, trait_owning_vtable);\n+    let vtable_segment_callback = {\n+        let mut vtable_base = 0;\n+\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vtable_base += COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    if trait_ref == trait_to_be_found {\n+                        return ControlFlow::Break(vtable_base);\n+                    }\n+                    vtable_base += util::count_own_vtable_entries(tcx, trait_ref);\n+                    if emit_vptr {\n+                        vtable_base += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n+\n+    if let Some(vtable_base) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vtable_base\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n+}\n+\n+/// Find slot offset for trait vptr within vtable entries of another trait\n+/// FIXME: This function is not yet used. Remove `#[allow(dead_code)]` when it's used in upcoming pr.\n+#[allow(dead_code)]\n+fn vtable_trait_vptr_slot_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> Option<usize> {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    let vtable_segment_callback = {\n+        let mut vptr_offset = 0;\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vptr_offset += COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                    if trait_ref == trait_to_be_found {\n+                        if emit_vptr {\n+                            return ControlFlow::Break(Some(vptr_offset));\n+                        } else {\n+                            return ControlFlow::Break(None);\n+                        }\n+                    }\n \n-    // For each of the non-matching predicates that\n-    // we pass over, we sum up the set of number of vtable\n-    // entries, so that we can compute the offset for the selected\n-    // trait.\n-    let vtable_base = ty::COMMON_VTABLE_ENTRIES.len()\n-        + supertraits\n-            .by_ref()\n-            .take_while(|t| *t != trait_to_be_found)\n-            .map(|t| util::count_own_vtable_entries(tcx, t))\n-            .sum::<usize>();\n+                    if emit_vptr {\n+                        vptr_offset += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n \n-    vtable_base\n+    if let Some(vptr_offset) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vptr_offset\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "f64ae95f1d4dd04e6f325114d3e5772b6c943f7f", "filename": "src/test/ui/traits/vtable/vtable-diamond.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,39 @@\n+// build-fail\n+#![feature(rustc_attrs)]\n+\n+#[rustc_dump_vtable]\n+trait A {\n+    fn foo_a(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait B: A {\n+    fn foo_b(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait C: A {\n+    //~^ error Vtable\n+    fn foo_c(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait D: B + C {\n+    //~^ error Vtable\n+    fn foo_d(&self) {}\n+}\n+\n+struct S;\n+\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+\n+fn foo(d: &dyn D) {\n+    d.foo_d();\n+}\n+\n+fn main() {\n+    foo(&S);\n+}"}, {"sha": "92a7f29536e3dc4a64e14bf35cce966163b0090d", "filename": "src/test/ui/traits/vtable/vtable-diamond.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.stderr?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,35 @@\n+error: Vtable entries for `<S as D>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as A>::foo_a),\n+    Method(<S as B>::foo_b),\n+    Method(<S as C>::foo_c),\n+    TraitVPtr(<S as C>),\n+    Method(<S as D>::foo_d),\n+]\n+  --> $DIR/vtable-diamond.rs:21:1\n+   |\n+LL | / trait D: B + C {\n+LL | |\n+LL | |     fn foo_d(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as C>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as A>::foo_a),\n+    Method(<S as C>::foo_c),\n+]\n+  --> $DIR/vtable-diamond.rs:15:1\n+   |\n+LL | / trait C: A {\n+LL | |\n+LL | |     fn foo_c(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "33112b4eaaade2bbd876ea173c7adf7b6e256269", "filename": "src/test/ui/traits/vtable/vtable-multi-level.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,122 @@\n+// build-fail\n+#![feature(rustc_attrs)]\n+\n+//   O --> G --> C --> A\n+//     \\     \\     \\-> B\n+//     |     |-> F --> D\n+//     |           \\-> E\n+//     |-> N --> J --> H\n+//           \\     \\-> I\n+//           |-> M --> K\n+//                 \\-> L\n+\n+#[rustc_dump_vtable]\n+trait A {\n+    fn foo_a(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait B {\n+    //~^ error Vtable\n+    fn foo_b(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait C: A + B {\n+    fn foo_c(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait D {\n+    //~^ error Vtable\n+    fn foo_d(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait E {\n+    //~^ error Vtable\n+    fn foo_e(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait F: D + E {\n+    //~^ error Vtable\n+    fn foo_f(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait G: C + F {\n+    fn foo_g(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait H {\n+    //~^ error Vtable\n+    fn foo_h(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait I {\n+    //~^ error Vtable\n+    fn foo_i(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait J: H + I {\n+    //~^ error Vtable\n+    fn foo_j(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait K {\n+    //~^ error Vtable\n+    fn foo_k(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait L {\n+    //~^ error Vtable\n+    fn foo_l(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait M: K + L {\n+    //~^ error Vtable\n+    fn foo_m(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait N: J + M {\n+    //~^ error Vtable\n+    fn foo_n(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait O: G + N {\n+    //~^ error Vtable\n+    fn foo_o(&self) {}\n+}\n+\n+struct S;\n+\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+impl E for S {}\n+impl F for S {}\n+impl G for S {}\n+impl H for S {}\n+impl I for S {}\n+impl J for S {}\n+impl K for S {}\n+impl L for S {}\n+impl M for S {}\n+impl N for S {}\n+impl O for S {}\n+\n+fn foo(_: &dyn O) {}\n+\n+fn main() {\n+    foo(&S);\n+}"}, {"sha": "7700db98e0bf1e58b46eabccc72a8e6b4995411e", "filename": "src/test/ui/traits/vtable/vtable-multi-level.stderr", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,214 @@\n+error: Vtable entries for `<S as O>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as A>::foo_a),\n+    Method(<S as B>::foo_b),\n+    TraitVPtr(<S as B>),\n+    Method(<S as C>::foo_c),\n+    Method(<S as D>::foo_d),\n+    TraitVPtr(<S as D>),\n+    Method(<S as E>::foo_e),\n+    TraitVPtr(<S as E>),\n+    Method(<S as F>::foo_f),\n+    TraitVPtr(<S as F>),\n+    Method(<S as G>::foo_g),\n+    Method(<S as H>::foo_h),\n+    TraitVPtr(<S as H>),\n+    Method(<S as I>::foo_i),\n+    TraitVPtr(<S as I>),\n+    Method(<S as J>::foo_j),\n+    TraitVPtr(<S as J>),\n+    Method(<S as K>::foo_k),\n+    TraitVPtr(<S as K>),\n+    Method(<S as L>::foo_l),\n+    TraitVPtr(<S as L>),\n+    Method(<S as M>::foo_m),\n+    TraitVPtr(<S as M>),\n+    Method(<S as N>::foo_n),\n+    TraitVPtr(<S as N>),\n+    Method(<S as O>::foo_o),\n+]\n+  --> $DIR/vtable-multi-level.rs:95:1\n+   |\n+LL | / trait O: G + N {\n+LL | |\n+LL | |     fn foo_o(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as B>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as B>::foo_b),\n+]\n+  --> $DIR/vtable-multi-level.rs:19:1\n+   |\n+LL | / trait B {\n+LL | |\n+LL | |     fn foo_b(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as D>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as D>::foo_d),\n+]\n+  --> $DIR/vtable-multi-level.rs:30:1\n+   |\n+LL | / trait D {\n+LL | |\n+LL | |     fn foo_d(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as E>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as E>::foo_e),\n+]\n+  --> $DIR/vtable-multi-level.rs:36:1\n+   |\n+LL | / trait E {\n+LL | |\n+LL | |     fn foo_e(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as F>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as D>::foo_d),\n+    Method(<S as E>::foo_e),\n+    TraitVPtr(<S as E>),\n+    Method(<S as F>::foo_f),\n+]\n+  --> $DIR/vtable-multi-level.rs:42:1\n+   |\n+LL | / trait F: D + E {\n+LL | |\n+LL | |     fn foo_f(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as H>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as H>::foo_h),\n+]\n+  --> $DIR/vtable-multi-level.rs:53:1\n+   |\n+LL | / trait H {\n+LL | |\n+LL | |     fn foo_h(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as I>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as I>::foo_i),\n+]\n+  --> $DIR/vtable-multi-level.rs:59:1\n+   |\n+LL | / trait I {\n+LL | |\n+LL | |     fn foo_i(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as J>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as H>::foo_h),\n+    Method(<S as I>::foo_i),\n+    TraitVPtr(<S as I>),\n+    Method(<S as J>::foo_j),\n+]\n+  --> $DIR/vtable-multi-level.rs:65:1\n+   |\n+LL | / trait J: H + I {\n+LL | |\n+LL | |     fn foo_j(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as K>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as K>::foo_k),\n+]\n+  --> $DIR/vtable-multi-level.rs:71:1\n+   |\n+LL | / trait K {\n+LL | |\n+LL | |     fn foo_k(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as L>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as L>::foo_l),\n+]\n+  --> $DIR/vtable-multi-level.rs:77:1\n+   |\n+LL | / trait L {\n+LL | |\n+LL | |     fn foo_l(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as M>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as K>::foo_k),\n+    Method(<S as L>::foo_l),\n+    TraitVPtr(<S as L>),\n+    Method(<S as M>::foo_m),\n+]\n+  --> $DIR/vtable-multi-level.rs:83:1\n+   |\n+LL | / trait M: K + L {\n+LL | |\n+LL | |     fn foo_m(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as N>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as H>::foo_h),\n+    Method(<S as I>::foo_i),\n+    TraitVPtr(<S as I>),\n+    Method(<S as J>::foo_j),\n+    Method(<S as K>::foo_k),\n+    TraitVPtr(<S as K>),\n+    Method(<S as L>::foo_l),\n+    TraitVPtr(<S as L>),\n+    Method(<S as M>::foo_m),\n+    TraitVPtr(<S as M>),\n+    Method(<S as N>::foo_n),\n+]\n+  --> $DIR/vtable-multi-level.rs:89:1\n+   |\n+LL | / trait N: J + M {\n+LL | |\n+LL | |     fn foo_n(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "cb0d0b72481903be5857052fb0c17e68f84a4ad4", "filename": "src/test/ui/traits/vtable/vtable-multiple.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,31 @@\n+// build-fail\n+#![feature(rustc_attrs)]\n+\n+#[rustc_dump_vtable]\n+trait A {\n+    fn foo_a(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait B {\n+    //~^ error Vtable\n+    fn foo_b(&self) {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait C: A + B {\n+    //~^ error Vtable\n+    fn foo_c(&self) {}\n+}\n+\n+struct S;\n+\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+\n+fn foo(c: &dyn C) {}\n+\n+fn main() {\n+    foo(&S);\n+}"}, {"sha": "f51b083de251565961fa200da42fe486851b4670", "filename": "src/test/ui/traits/vtable/vtable-multiple.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.stderr?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,33 @@\n+error: Vtable entries for `<S as C>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as A>::foo_a),\n+    Method(<S as B>::foo_b),\n+    TraitVPtr(<S as B>),\n+    Method(<S as C>::foo_c),\n+]\n+  --> $DIR/vtable-multiple.rs:16:1\n+   |\n+LL | / trait C: A + B {\n+LL | |\n+LL | |     fn foo_c(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: Vtable entries for `<S as B>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as B>::foo_b),\n+]\n+  --> $DIR/vtable-multiple.rs:10:1\n+   |\n+LL | / trait B {\n+LL | |\n+LL | |     fn foo_b(&self) {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ebea94171f2ab698ac32f42f79921b945f9182e3", "filename": "src/test/ui/traits/vtable/vtable-vacant.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.rs?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,28 @@\n+// build-fail\n+#![feature(rustc_attrs)]\n+\n+// B --> A\n+\n+#[rustc_dump_vtable]\n+trait A {\n+    fn foo_a1(&self) {}\n+    fn foo_a2(&self) where Self: Sized {}\n+}\n+\n+#[rustc_dump_vtable]\n+trait B: A {\n+    //~^ error Vtable\n+    fn foo_b1(&self) {}\n+    fn foo_b2() where Self: Sized {}\n+}\n+\n+struct S;\n+\n+impl A for S {}\n+impl B for S {}\n+\n+fn foo(_: &dyn B) {}\n+\n+fn main() {\n+    foo(&S);\n+}"}, {"sha": "768cca526894ac81ecd6f1ade8e0140fc4234b89", "filename": "src/test/ui/traits/vtable/vtable-vacant.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-vacant.stderr?ref=f9b95f92c8af07a24a870e5f6117aa5dfcee5f17", "patch": "@@ -0,0 +1,20 @@\n+error: Vtable entries for `<S as B>`: [\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Method(<S as A>::foo_a1),\n+    Vacant,\n+    Method(<S as B>::foo_b1),\n+    Vacant,\n+]\n+  --> $DIR/vtable-vacant.rs:13:1\n+   |\n+LL | / trait B: A {\n+LL | |\n+LL | |     fn foo_b1(&self) {}\n+LL | |     fn foo_b2() where Self: Sized {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}