{"sha": "7921572acf98d573464eae4aad73112a0d3d6f82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MjE1NzJhY2Y5OGQ1NzM0NjRlYWU0YWFkNzMxMTJhMGQzZDZmODI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-13T11:22:53Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-13T11:22:53Z"}, "message": "Rollup merge of #55722 - RalfJung:impl-stable-hash, r=varkor\n\nimpl_stable_hash_for: support enums and tuple structs with generic parameters\n\nPort a bunch of implementations over to the macro, now that that is possible.", "tree": {"sha": "44b976ca4b731eba7e76471aa56524ac66dcfa07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44b976ca4b731eba7e76471aa56524ac66dcfa07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7921572acf98d573464eae4aad73112a0d3d6f82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvqtA0ACgkQ/vbIBR0O\nATxeVQ//UaqcXImzaBxibdSQNL8RmkpGWsz+SYzbf5C9lwvBNSrS6PXUSWnMCGST\neqCsVx5MybwL5yYDf3X6YmxQQz0qLFvWTk15dutjEc6AL1cnvp+R4zCQB8bnSetn\nZoeFLTbWVl4GKQzRDcOHn22e2rQWDR/BDXbpfa6/6jysnIQnxMtlQci+CvOxF5Sd\n+Po8em86JfgdNyLKA4EVBpf0FVlAGJCbuNAY2is0LRla8cqV4oGsSYFYO5tcVYHJ\nPUMvnex1VFA6Kw4szT5RynFbqSg0bdeZ/XnAxKpgQ19n7PjAjlsno1HVMAsUwMg2\n1njVdvAb9AjQbOdBRDNNY5XvKWhjiwFNpzwn/MvNnOzuQroul4MmtNoLSQcjbquj\nV/n+mSRXHYYCoHJz4eOZWwhaqbOFqdaiTLfUIMCFv0pZgJzJNXIz114nGSNKfsv9\n4+0L4Ts19tmu59MRNeeZ4iP3PVQV7v7eLVCFz+yofVtfWNVFXpvhrklE087i/x+M\nPTit/qNwzE3YJ0PgZf+cudx/7uM79UHvucnv5BOmLJPtRtXntvmeAMOL6+tglMXk\ny3Ld4SWFhzouiWbrkAjmypvdKDPfmG04SzDIMwLIL+XGaEVDVg7ray4W+aY9Jy4T\ndv+SWXx72IGScg4fqsvQY2OYHcCmXLYht6cjpdwbrFroBwLNfUo=\n=/I81\n-----END PGP SIGNATURE-----", "payload": "tree 44b976ca4b731eba7e76471aa56524ac66dcfa07\nparent 21736816478b96b6e4cc4dc594d1e2a91898d73c\nparent db3c69ec80a9a9fbb2c4a7d3e10547549152387a\nauthor kennytm <kennytm@gmail.com> 1542108173 +0800\ncommitter kennytm <kennytm@gmail.com> 1542108173 +0800\n\nRollup merge of #55722 - RalfJung:impl-stable-hash, r=varkor\n\nimpl_stable_hash_for: support enums and tuple structs with generic parameters\n\nPort a bunch of implementations over to the macro, now that that is possible.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7921572acf98d573464eae4aad73112a0d3d6f82", "html_url": "https://github.com/rust-lang/rust/commit/7921572acf98d573464eae4aad73112a0d3d6f82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7921572acf98d573464eae4aad73112a0d3d6f82/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21736816478b96b6e4cc4dc594d1e2a91898d73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/21736816478b96b6e4cc4dc594d1e2a91898d73c", "html_url": "https://github.com/rust-lang/rust/commit/21736816478b96b6e4cc4dc594d1e2a91898d73c"}, {"sha": "db3c69ec80a9a9fbb2c4a7d3e10547549152387a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db3c69ec80a9a9fbb2c4a7d3e10547549152387a", "html_url": "https://github.com/rust-lang/rust/commit/db3c69ec80a9a9fbb2c4a7d3e10547549152387a"}], "stats": {"total": 569, "additions": 192, "deletions": 377}, "files": [{"sha": "c42c19e82c7c8a23f8faef1902c8c8a25fe646e7", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 17, "deletions": 54, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=7921572acf98d573464eae4aad73112a0d3d6f82", "patch": "@@ -37,68 +37,31 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, details, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::BorrowKind {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::BorrowKind::Shared |\n-            mir::BorrowKind::Shallow |\n-            mir::BorrowKind::Unique => {}\n-            mir::BorrowKind::Mut { allow_two_phase_borrow } => {\n-                allow_two_phase_borrow.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::UnsafetyViolationKind {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::UnsafetyViolationKind::General => {}\n-            mir::UnsafetyViolationKind::MinConstFn => {}\n-            mir::UnsafetyViolationKind::ExternStatic(lint_node_id) |\n-            mir::UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n-                lint_node_id.hash_stable(hcx, hasher);\n-            }\n+impl_stable_hash_for!(enum mir::BorrowKind {\n+    Shared,\n+    Shallow,\n+    Unique,\n+    Mut { allow_two_phase_borrow },\n+});\n \n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n+    General,\n+    MinConstFn,\n+    ExternStatic(lint_node_id),\n+    BorrowPacked(lint_node_id),\n+});\n \n impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n     kind,\n     source_info\n });\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for mir::ClearCrossCrate<T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ClearCrossCrate::Clear => {}\n-            mir::ClearCrossCrate::Set(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<T> for enum mir::ClearCrossCrate<T> [ mir::ClearCrossCrate ] {\n+        Clear,\n+        Set(value),\n     }\n-}\n+);\n \n impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n     #[inline]"}, {"sha": "f3a62975dd9f4547eb254960fc8d605c5ffa9a36", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 125, "deletions": 301, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7921572acf98d573464eae4aad73112a0d3d6f82", "patch": "@@ -224,20 +224,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::UpvarCapture<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::UpvarCapture::ByValue => {}\n-            ty::UpvarCapture::ByRef(ref up_var_borrow) => {\n-                up_var_borrow.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n+impl_stable_hash_for!(impl<'gcx> for enum ty::UpvarCapture<'gcx> [ ty::UpvarCapture ] {\n+    ByValue,\n+    ByRef(up_var_borrow),\n+});\n \n impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n     yield_ty,\n@@ -272,64 +262,23 @@ impl_stable_hash_for!(enum ty::Visibility {\n impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n-\n-impl<'a, 'gcx, A, B> HashStable<StableHashingContext<'a>>\n-for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a>>,\n-          B: HashStable<StableHashingContext<'a>>,\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::OutlivesPredicate(ref a, ref b) = *self;\n-        a.hash_stable(hcx, hasher);\n-        b.hash_stable(hcx, hasher);\n-    }\n-}\n-\n+impl_stable_hash_for!(impl<A, B> for tuple_struct ty::OutlivesPredicate<A, B> { a, b });\n impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::Predicate<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::Predicate::Trait(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::Subtype(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::RegionOutlives(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::TypeOutlives(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::Projection(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::WellFormed(ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ObjectSafe(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ClosureKind(def_id, closure_substs, closure_kind) => {\n-                def_id.hash_stable(hcx, hasher);\n-                closure_substs.hash_stable(hcx, hasher);\n-                closure_kind.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx> for enum ty::Predicate<'tcx> [ ty::Predicate ] {\n+        Trait(pred),\n+        Subtype(pred),\n+        RegionOutlives(pred),\n+        TypeOutlives(pred),\n+        Projection(pred),\n+        WellFormed(ty),\n+        ObjectSafe(def_id),\n+        ClosureKind(def_id, closure_substs, closure_kind),\n+        ConstEvaluatable(def_id, substs),\n     }\n-}\n+);\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -358,70 +307,39 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis,\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::ConstValue<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::ConstValue::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Unevaluated(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Scalar(val) => {\n-                val.hash_stable(hcx, hasher);\n-            }\n-            ScalarPair(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            ByRef(id, alloc, offset) => {\n-                id.hash_stable(hcx, hasher);\n-                alloc.hash_stable(hcx, hasher);\n-                offset.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n+        Unevaluated(def_id, substs),\n+        Scalar(val),\n+        ScalarPair(a, b),\n+        ByRef(id, alloc, offset),\n     }\n-}\n+);\n \n-impl<'a, Tag> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::Pointer<Tag>\n-where Tag: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ::mir::interpret::Pointer { alloc_id, offset, tag } = self;\n-        alloc_id.hash_stable(hcx, hasher);\n-        offset.hash_stable(hcx, hasher);\n-        tag.hash_stable(hcx, hasher);\n+impl_stable_hash_for! {\n+    impl<Tag> for struct mir::interpret::Pointer<Tag> {\n+        alloc_id,\n+        offset,\n+        tag,\n     }\n }\n \n-impl<'a, Tag> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::Scalar<Tag>\n-where Tag: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::Scalar::*;\n+impl_stable_hash_for!(\n+    impl<Tag> for enum mir::interpret::Scalar<Tag> [ mir::interpret::Scalar ] {\n+        Bits { bits, size },\n+        Ptr(ptr),\n+    }\n+);\n \n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Bits { bits, size } => {\n-                bits.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-            },\n-            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx, M> for enum mir::interpret::AllocType<'tcx, M> [ mir::interpret::AllocType ] {\n+        Function(instance),\n+        Static(def_id),\n+        Memory(mem),\n     }\n-}\n+);\n \n+// AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -437,23 +355,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-impl<'a, 'gcx, M: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n-for mir::interpret::AllocType<'gcx, M> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::AllocType::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Function(instance) => instance.hash_stable(hcx, hasher),\n-            Static(def_id) => def_id.hash_stable(hcx, hasher),\n-            Memory(ref mem) => mem.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n+// Allocations treat their relocations specially\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -485,7 +387,7 @@ impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n     TooGeneric\n });\n \n-impl_stable_hash_for!(struct ::mir::interpret::FrameInfo {\n+impl_stable_hash_for!(struct mir::interpret::FrameInfo {\n     span,\n     lint_root,\n     location\n@@ -499,124 +401,75 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n-impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::EvalErrorKind<'gcx, O> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::EvalErrorKind::*;\n-\n-        mem::discriminant(&self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            FunctionArgCountMismatch |\n-            DanglingPointerDeref |\n-            DoubleFree |\n-            InvalidMemoryAccess |\n-            InvalidFunctionPointer |\n-            InvalidBool |\n-            InvalidNullPointerUsage |\n-            ReadPointerAsBytes |\n-            ReadBytesAsPointer |\n-            ReadForeignStatic |\n-            InvalidPointerMath |\n-            DeadLocal |\n-            StackFrameLimitReached |\n-            OutOfTls |\n-            TlsOutOfBounds |\n-            CalledClosureAsFunction |\n-            VtableForArgumentlessMethod |\n-            ModifiedConstantMemory |\n-            AssumptionNotHeld |\n-            InlineAsm |\n-            ReallocateNonBasePtr |\n-            DeallocateNonBasePtr |\n-            HeapAllocZeroBytes |\n-            Unreachable |\n-            ReadFromReturnPointer |\n-            UnimplementedTraitSelection |\n-            TypeckError |\n-            TooGeneric |\n-            DerefFunctionPointer |\n-            ExecuteMemory |\n-            OverflowNeg |\n-            RemainderByZero |\n-            DivisionByZero |\n-            GeneratorResumedAfterReturn |\n-            GeneratorResumedAfterPanic |\n-            ReferencedConstant |\n-            InfiniteLoop => {}\n-            ReadUndefBytes(offset) => offset.hash_stable(hcx, hasher),\n-            InvalidDiscriminant(val) => val.hash_stable(hcx, hasher),\n-            Panic { ref msg, ref file, line, col } => {\n-                msg.hash_stable(hcx, hasher);\n-                file.hash_stable(hcx, hasher);\n-                line.hash_stable(hcx, hasher);\n-                col.hash_stable(hcx, hasher);\n-            },\n-            MachineError(ref err) => err.hash_stable(hcx, hasher),\n-            FunctionAbiMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            FunctionArgMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            FunctionRetMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            NoMirFor(ref s) => s.hash_stable(hcx, hasher),\n-            UnterminatedCString(ptr) => ptr.hash_stable(hcx, hasher),\n-            PointerOutOfBounds {\n-                ptr,\n-                access,\n-                allocation_size,\n-            } => {\n-                ptr.hash_stable(hcx, hasher);\n-                access.hash_stable(hcx, hasher);\n-                allocation_size.hash_stable(hcx, hasher)\n-            },\n-            InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n-            Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n-            BoundsCheck { ref len, ref index } => {\n-                len.hash_stable(hcx, hasher);\n-                index.hash_stable(hcx, hasher)\n-            },\n-            Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n-            InvalidChar(c) => c.hash_stable(hcx, hasher),\n-            AbiViolation(ref s) => s.hash_stable(hcx, hasher),\n-            AlignmentCheckFailed {\n-                required,\n-                has,\n-            } => {\n-                required.hash_stable(hcx, hasher);\n-                has.hash_stable(hcx, hasher)\n-            },\n-            ValidationFailure(ref s) => s.hash_stable(hcx, hasher),\n-            TypeNotPrimitive(ty) => ty.hash_stable(hcx, hasher),\n-            ReallocatedWrongMemoryKind(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            DeallocatedWrongMemoryKind(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            IncorrectAllocationInformation(a, b, c, d) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-                c.hash_stable(hcx, hasher);\n-                d.hash_stable(hcx, hasher)\n-            },\n-            Layout(lay) => lay.hash_stable(hcx, hasher),\n-            HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n-            PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n-            Overflow(op) => op.hash_stable(hcx, hasher),\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx, O> for enum mir::interpret::EvalErrorKind<'tcx, O>\n+        [ mir::interpret::EvalErrorKind ]\n+    {\n+        FunctionArgCountMismatch,\n+        DanglingPointerDeref,\n+        DoubleFree,\n+        InvalidMemoryAccess,\n+        InvalidFunctionPointer,\n+        InvalidBool,\n+        InvalidNullPointerUsage,\n+        ReadPointerAsBytes,\n+        ReadBytesAsPointer,\n+        ReadForeignStatic,\n+        InvalidPointerMath,\n+        DeadLocal,\n+        StackFrameLimitReached,\n+        OutOfTls,\n+        TlsOutOfBounds,\n+        CalledClosureAsFunction,\n+        VtableForArgumentlessMethod,\n+        ModifiedConstantMemory,\n+        AssumptionNotHeld,\n+        InlineAsm,\n+        ReallocateNonBasePtr,\n+        DeallocateNonBasePtr,\n+        HeapAllocZeroBytes,\n+        Unreachable,\n+        ReadFromReturnPointer,\n+        UnimplementedTraitSelection,\n+        TypeckError,\n+        TooGeneric,\n+        DerefFunctionPointer,\n+        ExecuteMemory,\n+        OverflowNeg,\n+        RemainderByZero,\n+        DivisionByZero,\n+        GeneratorResumedAfterReturn,\n+        GeneratorResumedAfterPanic,\n+        ReferencedConstant,\n+        InfiniteLoop,\n+        ReadUndefBytes(offset),\n+        InvalidDiscriminant(val),\n+        Panic { msg, file, line, col },\n+        MachineError(err),\n+        FunctionAbiMismatch(a, b),\n+        FunctionArgMismatch(a, b),\n+        FunctionRetMismatch(a, b),\n+        NoMirFor(s),\n+        UnterminatedCString(ptr),\n+        PointerOutOfBounds { ptr, access, allocation_size },\n+        InvalidBoolOp(bop),\n+        Unimplemented(s),\n+        BoundsCheck { len, index },\n+        Intrinsic(s),\n+        InvalidChar(c),\n+        AbiViolation(s),\n+        AlignmentCheckFailed { required, has },\n+        ValidationFailure(s),\n+        TypeNotPrimitive(ty),\n+        ReallocatedWrongMemoryKind(a, b),\n+        DeallocatedWrongMemoryKind(a, b),\n+        IncorrectAllocationInformation(a, b, c, d),\n+        Layout(lay),\n+        HeapAllocNonPowerOfTwoAlignment(n),\n+        PathNotFound(v),\n+        Overflow(op),\n     }\n-}\n+);\n \n impl_stable_hash_for!(enum mir::interpret::Lock {\n     NoLock,\n@@ -663,47 +516,18 @@ impl_stable_hash_for!(struct ty::GenericParamDef {\n     kind\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::GenericParamDefKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::GenericParamDefKind::Lifetime => {}\n-            ty::GenericParamDefKind::Type {\n-                has_default,\n-                ref object_lifetime_default,\n-                ref synthetic,\n-            } => {\n-                has_default.hash_stable(hcx, hasher);\n-                object_lifetime_default.hash_stable(hcx, hasher);\n-                synthetic.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use middle::resolve_lifetime::Set1;\n+impl_stable_hash_for!(enum ty::GenericParamDefKind {\n+    Lifetime,\n+    Type { has_default, object_lifetime_default, synthetic },\n+});\n \n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Set1::Empty |\n-            Set1::Many => {\n-                // Nothing to do.\n-            }\n-            Set1::One(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<T> for enum ::middle::resolve_lifetime::Set1<T> [ ::middle::resolve_lifetime::Set1 ] {\n+        Empty,\n+        Many,\n+        One(value),\n     }\n-}\n+);\n \n impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n     ExplicitOrElided,\n@@ -1250,7 +1074,7 @@ impl_stable_hash_for!(\n );\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct infer::canonical::CanonicalVarValues<'tcx> {\n+    struct infer::canonical::CanonicalVarValues<'tcx> {\n         var_values\n     }\n );\n@@ -1369,7 +1193,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n }\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct traits::ProgramClause<'tcx> {\n+    struct traits::ProgramClause<'tcx> {\n         goal, hypotheses, category\n     }\n );\n@@ -1404,7 +1228,7 @@ impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty\n impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct traits::Environment<'tcx> {\n+    struct traits::Environment<'tcx> {\n         clauses,\n     }\n );"}, {"sha": "50375435eb9203b588e2eb34cf11256a4195691e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7921572acf98d573464eae4aad73112a0d3d6f82/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=7921572acf98d573464eae4aad73112a0d3d6f82", "patch": "@@ -71,6 +71,7 @@ macro_rules! __impl_stable_hash_field {\n \n #[macro_export]\n macro_rules! impl_stable_hash_for {\n+    // Enums\n     // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n     // them back when `?` is supported again.\n     (enum $enum_name:path {\n@@ -81,12 +82,37 @@ macro_rules! impl_stable_hash_for {\n            $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n         ),* $(,)*\n     }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n+        impl_stable_hash_for!(\n+            impl<> for enum $enum_name [ $enum_name ] { $( $variant\n+                $( ( $($field $(-> $delegate)*),* ) )*\n+                $( { $($named_field $(-> $named_delegate)*),* } )*\n+            ),* }\n+        );\n+    };\n+    // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n+    // importing all the variants. Unfortunately it seems we have to take the name\n+    // twice for this purpose\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+        for enum $enum_name:path\n+        [ $enum_path:path ]\n+    {\n+        $( $variant:ident\n+           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n+           // when it should be only one or the other\n+           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n+           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n+        ),* $(,)*\n+    }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n+            for $enum_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                use $enum_name::*;\n+                use $enum_path::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n \n                 match *self {\n@@ -100,9 +126,20 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+    // Structs\n     // FIXME(mark-i-m): same here.\n     (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n+        impl_stable_hash_for!(\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+        );\n+    };\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n@@ -115,36 +152,27 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+    // Tuple structs\n+    // We cannot use normale parentheses here, the parser won't allow it\n     // FIXME(mark-i-m): same here.\n     (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n-            #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                let $struct_name (\n-                    $(ref $field),*\n-                ) = *self;\n-\n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n-            }\n-        }\n+        impl_stable_hash_for!(\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+        );\n     };\n-\n-    (impl<$tcx:lifetime $(, $lt:lifetime $(: $lt_bound:lifetime)*)* $(, $T:ident)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n-    }) => {\n-        impl<'a, $tcx, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                let $struct_name {\n+                let $struct_name (\n                     $(ref $field),*\n-                } = *self;\n+                ) = *self;\n \n                 $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }"}]}