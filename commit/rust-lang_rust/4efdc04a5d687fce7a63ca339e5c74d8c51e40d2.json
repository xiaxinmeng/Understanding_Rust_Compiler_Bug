{"sha": "4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZmRjMDRhNWQ2ODdmY2U3YTYzY2EzMzllNWM3NGQ4YzUxZTQwZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-06T20:04:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-06T20:04:18Z"}, "message": "Auto merge of #54756 - ljedrz:cleanup_middle, r=michaelwoerister\n\nCleanup rustc/middle\n\n- improve allocations\n- use `Cow<'static, str>` where applicable\n- improve some patterns\n- whitespace & formatting fixes", "tree": {"sha": "5acf43273b4911032b0951612a32b7be894e98e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5acf43273b4911032b0951612a32b7be894e98e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "html_url": "https://github.com/rust-lang/rust/commit/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ec50f4659ae112a16381bc916466e12aaf7b044", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec50f4659ae112a16381bc916466e12aaf7b044", "html_url": "https://github.com/rust-lang/rust/commit/7ec50f4659ae112a16381bc916466e12aaf7b044"}, {"sha": "786b86ef5d8d55957f70f51e98003a9ac0ea0405", "url": "https://api.github.com/repos/rust-lang/rust/commits/786b86ef5d8d55957f70f51e98003a9ac0ea0405", "html_url": "https://github.com/rust-lang/rust/commit/786b86ef5d8d55957f70f51e98003a9ac0ea0405"}], "stats": {"total": 1352, "additions": 641, "deletions": 711}, "files": [{"sha": "2a157a9ff68f36956bc0f882a6a81e4fb6cf1e39", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -131,12 +131,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn mark_live_symbols(&mut self) {\n         let mut scanned = FxHashSet();\n-        while !self.worklist.is_empty() {\n-            let id = self.worklist.pop().unwrap();\n-            if scanned.contains(&id) {\n+        while let Some(id) = self.worklist.pop() {\n+            if !scanned.insert(id) {\n                 continue\n             }\n-            scanned.insert(id);\n \n             if let Some(ref node) = self.tcx.hir.find(id) {\n                 self.live_symbols.insert(id);\n@@ -212,7 +210,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n-                        _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n+                          _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields().iter().filter(|f| {\n@@ -494,8 +492,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       ctor_id: Option<ast::NodeId>)\n                       -> bool {\n         if self.live_symbols.contains(&id)\n-           || ctor_id.map_or(false,\n-                             |ctor| self.live_symbols.contains(&ctor)) {\n+           || ctor_id.map_or(false, |ctor| self.live_symbols.contains(&ctor))\n+        {\n             return true;\n         }\n         // If it's a type whose items are live, then it's live, too."}, {"sha": "95fb35165e7601599bed83d22c357c7e3eb55117", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -163,7 +163,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let src = tcx.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n-                                  but was not found in this form\",\n+                                   but was not found in this form\",\n                                   tcx.crate_name(cnum)));\n             }\n             return Vec::new();\n@@ -247,13 +247,13 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     _ => \"dylib\",\n                 };\n                 sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n-                                  but was not found in this form\",\n+                                   but was not found in this form\",\n                                   tcx.crate_name(cnum), kind));\n             }\n         }\n     }\n \n-    return ret;\n+    ret\n }\n \n fn add_library(tcx: TyCtxt<'_, '_, '_>,"}, {"sha": "93fe607f5fa1499ca0882b8ffd42ca6a1f89ab90", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use hir::map as hir_map;\n use hir::def_id::{CRATE_DEF_INDEX};\n use session::{config, Session};\n@@ -131,7 +130,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n                 ctxt.attr_main_fn = Some((item.id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0137,\n-                          \"multiple functions with a #[main] attribute\")\n+                                 \"multiple functions with a #[main] attribute\")\n                 .span_label(item.span, \"additional #[main] function\")\n                 .span_label(ctxt.attr_main_fn.unwrap().1, \"first #[main] function\")\n                 .emit();\n@@ -141,11 +140,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((item.id, item.span));\n             } else {\n-                struct_span_err!(\n-                    ctxt.session, item.span, E0138,\n-                    \"multiple 'start' functions\")\n-                    .span_label(ctxt.start_fn.unwrap().1,\n-                                \"previous `start` function here\")\n+                struct_span_err!(ctxt.session, item.span, E0138, \"multiple 'start' functions\")\n+                    .span_label(ctxt.start_fn.unwrap().1, \"previous `start` function here\")\n                     .span_label(item.span, \"multiple `start` functions\")\n                     .emit();\n             }"}, {"sha": "44572a1977ab4dd40580c44c3c4aa2e781d6daba", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -35,12 +35,8 @@ impl_stable_hash_for!(enum self::SymbolExportLevel {\n \n impl SymbolExportLevel {\n     pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n-        if threshold == SymbolExportLevel::Rust {\n-            // We export everything from Rust dylibs\n-            true\n-        } else {\n-            self == SymbolExportLevel::C\n-        }\n+        threshold == SymbolExportLevel::Rust // export everything from Rust dylibs\n+          || self == SymbolExportLevel::C\n     }\n }\n "}, {"sha": "d6b43ffe6da625dc73aefd8d0b4cb4761e88d814", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     region::Scope {\n                         id: body.value.hir_id.local_id,\n                         data: region::ScopeData::Node\n-                    }));\n+                }));\n             let arg_cmt = Rc::new(self.mc.cat_rvalue(\n                 arg.hir_id,\n                 arg.pat.span,\n@@ -402,20 +402,20 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.walk_expr(&subexpr)\n             }\n \n-            hir::ExprKind::Unary(hir::UnDeref, ref base) => {      // *base\n+            hir::ExprKind::Unary(hir::UnDeref, ref base) => { // *base\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprKind::Field(ref base, _) => {         // base.f\n+            hir::ExprKind::Field(ref base, _) => { // base.f\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprKind::Index(ref lhs, ref rhs) => {       // lhs[rhs]\n+            hir::ExprKind::Index(ref lhs, ref rhs) => { // lhs[rhs]\n                 self.select_from_expr(&lhs);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprKind::Call(ref callee, ref args) => {    // callee(args)\n+            hir::ExprKind::Call(ref callee, ref args) => { // callee(args)\n                 self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);\n             }\n@@ -801,10 +801,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             self.walk_pat(discr_cmt.clone(), &pat, mode);\n         }\n \n-        if let Some(ref guard) = arm.guard {\n-            match guard {\n-                hir::Guard::If(ref e) => self.consume_expr(e),\n-            }\n+        if let Some(hir::Guard::If(ref e)) = arm.guard {\n+            self.consume_expr(e)\n         }\n \n         self.consume_expr(&arm.body);\n@@ -826,12 +824,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &hir::Pat,\n                                mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n-               pat);\n+        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n+\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             if let PatKind::Binding(..) = pat.node {\n-                let bm = *self.mc.tables.pat_binding_modes().get(pat.hir_id)\n-                                                          .expect(\"missing binding mode\");\n+                let bm = *self.mc.tables.pat_binding_modes()\n+                                        .get(pat.hir_id)\n+                                        .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByReference(..) =>\n                         mode.lub(BorrowingMatch),"}, {"sha": "9d54e798469f7f36fa33ccdae179cee9e895572d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n                 }\n                 Err(LayoutError::Unknown(bad)) => {\n                     if bad == ty {\n-                        \"this type's size can vary\".to_string()\n+                        \"this type's size can vary\".to_owned()\n                     } else {\n                         format!(\"size can vary because of {}\", bad)\n                     }\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n         };\n \n         struct_span_err!(self.tcx.sess, span, E0512,\n-            \"transmute called with types of different sizes\")\n+                         \"transmute called with types of different sizes\")\n             .note(&format!(\"source type: {} ({})\", from, skeleton_string(from, sk_from)))\n             .note(&format!(\"target type: {} ({})\", to, skeleton_string(to, sk_to)))\n             .emit();"}, {"sha": "0bd816b3e55f0ea5ea78ad1b1ffb015138187d0e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -39,7 +39,6 @@ macro_rules! language_item_table {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-\n enum_from_u32! {\n     #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n@@ -145,8 +144,8 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n \n     fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n         // Check for duplicates.\n-        match self.items.items[item_index] {\n-            Some(original_def_id) if original_def_id != item_def_id => {\n+        if let Some(original_def_id) = self.items.items[item_index] {\n+            if original_def_id != item_def_id {\n                 let name = LangItem::from_u32(item_index as u32).unwrap().name();\n                 let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n@@ -161,17 +160,13 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                             name)),\n                 };\n                 if let Some(span) = self.tcx.hir.span_if_local(original_def_id) {\n-                    span_note!(&mut err, span,\n-                               \"first defined here.\");\n+                    span_note!(&mut err, span, \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n                                       self.tcx.crate_name(original_def_id.krate)));\n                 }\n                 err.emit();\n             }\n-            _ => {\n-                // OK.\n-            }\n         }\n \n         // Matched.\n@@ -194,7 +189,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n         }\n     }\n \n-    return None;\n+    None\n }\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {"}, {"sha": "6055a05158fe08a1e1ad93a1fa2833f03ea71614", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -128,8 +128,8 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                 let msg = format!(\n                     \"feature `{}` is declared {}, but was previously declared {}\",\n                     feature,\n-                    if since.is_some() { \"stable\"} else { \"unstable\" },\n-                    if since.is_none() { \"stable\"} else { \"unstable\" },\n+                    if since.is_some() { \"stable\" } else { \"unstable\" },\n+                    if since.is_none() { \"stable\" } else { \"unstable\" },\n                 );\n                 self.tcx.sess.struct_span_err_with_code(span, &msg,\n                     DiagnosticId::Error(\"E0711\".into())).emit();"}, {"sha": "1b258a23462c722b31a7e7875abb1ce38841b44e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 272, "deletions": 288, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -170,7 +170,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n         VarDefNode(s) => {\n             format!(\"Var def node [{}]\", cm.span_to_string(s))\n         }\n-        ExitNode => \"Exit node\".to_string(),\n+        ExitNode => \"Exit node\".to_owned(),\n     }\n }\n \n@@ -257,7 +257,6 @@ enum VarKind {\n \n struct IrMaps<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n     num_live_nodes: usize,\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n@@ -330,7 +329,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { name, .. }) | Arg(_, name) => {\n                 name.to_string()\n             },\n-            CleanExit => \"<clean-exit>\".to_string()\n+            CleanExit => \"<clean-exit>\".to_owned()\n         }\n     }\n \n@@ -474,13 +473,15 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // construction site.\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n-            for fv in freevars {\n+            call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     let var_hid = ir.tcx.hir.node_to_hir_id(rv);\n-                    call_caps.push(CaptureInfo { ln: fv_ln, var_hid });\n+                    Some(CaptureInfo { ln: fv_ln, var_hid })\n+                } else {\n+                    None\n                 }\n-            }\n+            }));\n         });\n         ir.set_captures(expr.id, call_caps);\n \n@@ -918,8 +919,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    // _______________________________________________________________________\n-\n     fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n@@ -941,10 +940,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let entry_ln = self.propagate_through_expr(body, s.fallthrough_ln);\n \n         // hack to skip the loop unless debug! is enabled:\n-        debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n-               {\n+        debug!(\"^^ liveness computation results for body {} (entry={:?})\", {\n                    for ln_idx in 0..self.ir.num_live_nodes {\n-                       debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                        debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n                    }\n                    body.id\n                },\n@@ -1026,241 +1024,232 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n         match expr.node {\n-          // Interesting cases with control flow or which gen/kill\n-          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-              self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n-          }\n+            // Interesting cases with control flow or which gen/kill\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n+            }\n \n-          hir::ExprKind::Field(ref e, _) => {\n-              self.propagate_through_expr(&e, succ)\n-          }\n+            hir::ExprKind::Field(ref e, _) => {\n+                self.propagate_through_expr(&e, succ)\n+            }\n \n-          hir::ExprKind::Closure(.., blk_id, _, _) => {\n-              debug!(\"{} is an ExprKind::Closure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n-\n-              // The next-node for a break is the successor of the entire\n-              // loop. The next-node for a continue is the top of this loop.\n-              let node = self.live_node(expr.hir_id, expr.span);\n-\n-              let break_ln = succ;\n-              let cont_ln = node;\n-              self.break_ln.insert(blk_id.node_id, break_ln);\n-              self.cont_ln.insert(blk_id.node_id, cont_ln);\n-\n-              // the construction of a closure itself is not important,\n-              // but we have to consider the closed over variables.\n-              let caps = match self.ir.capture_info_map.get(&expr.id) {\n-                  Some(caps) => caps.clone(),\n-                  None => {\n-                      span_bug!(expr.span, \"no registered caps\");\n-                  }\n-              };\n-              caps.iter().rev().fold(succ, |succ, cap| {\n-                  self.init_from_succ(cap.ln, succ);\n-                  let var = self.variable(cap.var_hid, expr.span);\n-                  self.acc(cap.ln, var, ACC_READ | ACC_USE);\n-                  cap.ln\n-              })\n-          }\n+            hir::ExprKind::Closure(.., blk_id, _, _) => {\n+                debug!(\"{} is an ExprKind::Closure\",\n+                       self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+\n+                // The next-node for a break is the successor of the entire\n+                // loop. The next-node for a continue is the top of this loop.\n+                let node = self.live_node(expr.hir_id, expr.span);\n+\n+                let break_ln = succ;\n+                let cont_ln = node;\n+                self.break_ln.insert(blk_id.node_id, break_ln);\n+                self.cont_ln.insert(blk_id.node_id, cont_ln);\n+\n+                // the construction of a closure itself is not important,\n+                // but we have to consider the closed over variables.\n+                let caps = self.ir.capture_info_map.get(&expr.id).cloned().unwrap_or_else(||\n+                    span_bug!(expr.span, \"no registered caps\"));\n+\n+                caps.iter().rev().fold(succ, |succ, cap| {\n+                    self.init_from_succ(cap.ln, succ);\n+                    let var = self.variable(cap.var_hid, expr.span);\n+                    self.acc(cap.ln, var, ACC_READ | ACC_USE);\n+                    cap.ln\n+                })\n+            }\n \n-          hir::ExprKind::If(ref cond, ref then, ref els) => {\n-            //\n-            //     (cond)\n-            //       |\n-            //       v\n-            //     (expr)\n-            //     /   \\\n-            //    |     |\n-            //    v     v\n-            //  (then)(els)\n-            //    |     |\n-            //    v     v\n-            //   (  succ  )\n-            //\n-            let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-            let then_ln = self.propagate_through_expr(&then, succ);\n-            let ln = self.live_node(expr.hir_id, expr.span);\n-            self.init_from_succ(ln, else_ln);\n-            self.merge_from_succ(ln, then_ln, false);\n-            self.propagate_through_expr(&cond, ln)\n-          }\n+            hir::ExprKind::If(ref cond, ref then, ref els) => {\n+                //\n+                //     (cond)\n+                //       |\n+                //       v\n+                //     (expr)\n+                //     /   \\\n+                //    |     |\n+                //    v     v\n+                //  (then)(els)\n+                //    |     |\n+                //    v     v\n+                //   (  succ  )\n+                //\n+                let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n+                let then_ln = self.propagate_through_expr(&then, succ);\n+                let ln = self.live_node(expr.hir_id, expr.span);\n+                self.init_from_succ(ln, else_ln);\n+                self.merge_from_succ(ln, then_ln, false);\n+                self.propagate_through_expr(&cond, ln)\n+            }\n \n-          hir::ExprKind::While(ref cond, ref blk, _) => {\n-            self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n-          }\n+            hir::ExprKind::While(ref cond, ref blk, _) => {\n+                self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n+            }\n \n-          // Note that labels have been resolved, so we don't need to look\n-          // at the label ident\n-          hir::ExprKind::Loop(ref blk, _, _) => {\n-            self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n-          }\n+            // Note that labels have been resolved, so we don't need to look\n+            // at the label ident\n+            hir::ExprKind::Loop(ref blk, _, _) => {\n+                self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n+            }\n \n-          hir::ExprKind::Match(ref e, ref arms, _) => {\n-            //\n-            //      (e)\n-            //       |\n-            //       v\n-            //     (expr)\n-            //     / | \\\n-            //    |  |  |\n-            //    v  v  v\n-            //   (..arms..)\n-            //    |  |  |\n-            //    v  v  v\n-            //   (  succ  )\n-            //\n-            //\n-            let ln = self.live_node(expr.hir_id, expr.span);\n-            self.init_empty(ln, succ);\n-            let mut first_merge = true;\n-            for arm in arms {\n-                let body_succ =\n-                    self.propagate_through_expr(&arm.body, succ);\n-                let guard_succ =\n-                    self.propagate_through_opt_expr(\n-                        arm.guard.as_ref().map(|g|\n-                            match g {\n-                                hir::Guard::If(e) => &**e,\n-                            }),\n-                        body_succ);\n-                // only consider the first pattern; any later patterns must have\n-                // the same bindings, and we also consider the first pattern to be\n-                // the \"authoritative\" set of ids\n-                let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n-                                                     guard_succ);\n-                self.merge_from_succ(ln, arm_succ, first_merge);\n-                first_merge = false;\n-            };\n-            self.propagate_through_expr(&e, ln)\n-          }\n+            hir::ExprKind::Match(ref e, ref arms, _) => {\n+                //\n+                //      (e)\n+                //       |\n+                //       v\n+                //     (expr)\n+                //     / | \\\n+                //    |  |  |\n+                //    v  v  v\n+                //   (..arms..)\n+                //    |  |  |\n+                //    v  v  v\n+                //   (  succ  )\n+                //\n+                //\n+                let ln = self.live_node(expr.hir_id, expr.span);\n+                self.init_empty(ln, succ);\n+                let mut first_merge = true;\n+                for arm in arms {\n+                    let body_succ = self.propagate_through_expr(&arm.body, succ);\n+\n+                    let guard_succ = self.propagate_through_opt_expr(\n+                        arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n+                        body_succ\n+                    );\n+                    // only consider the first pattern; any later patterns must have\n+                    // the same bindings, and we also consider the first pattern to be\n+                    // the \"authoritative\" set of ids\n+                    let arm_succ =\n+                        self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n+                                                         guard_succ);\n+                    self.merge_from_succ(ln, arm_succ, first_merge);\n+                    first_merge = false;\n+                };\n+                self.propagate_through_expr(&e, ln)\n+            }\n \n-          hir::ExprKind::Ret(ref o_e) => {\n-            // ignore succ and subst exit_ln:\n-            let exit_ln = self.s.exit_ln;\n-            self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n-          }\n+            hir::ExprKind::Ret(ref o_e) => {\n+                // ignore succ and subst exit_ln:\n+                let exit_ln = self.s.exit_ln;\n+                self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n+            }\n \n-          hir::ExprKind::Break(label, ref opt_expr) => {\n-              // Find which label this break jumps to\n-              let target = match label.target_id {\n+            hir::ExprKind::Break(label, ref opt_expr) => {\n+                // Find which label this break jumps to\n+                let target = match label.target_id {\n                     Ok(node_id) => self.break_ln.get(&node_id),\n                     Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n-              }.map(|x| *x);\n-\n-              // Now that we know the label we're going to,\n-              // look it up in the break loop nodes table\n+                }.cloned();\n \n-              match target {\n-                  Some(b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n-                  None => span_bug!(expr.span, \"break to unknown label\")\n-              }\n-          }\n+                // Now that we know the label we're going to,\n+                // look it up in the break loop nodes table\n \n-          hir::ExprKind::Continue(label) => {\n-              // Find which label this expr continues to\n-              let sc = match label.target_id {\n-                    Ok(node_id) => node_id,\n-                    Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n-              };\n+                match target {\n+                    Some(b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n+                    None => span_bug!(expr.span, \"break to unknown label\")\n+                }\n+            }\n \n-              // Now that we know the label we're going to,\n-              // look it up in the continue loop nodes table\n+            hir::ExprKind::Continue(label) => {\n+                // Find which label this expr continues to\n+                let sc = label.target_id.unwrap_or_else(|err|\n+                    span_bug!(expr.span, \"loop scope error: {}\", err));\n \n-              match self.cont_ln.get(&sc) {\n-                  Some(&b) => b,\n-                  None => span_bug!(expr.span, \"continue to unknown label\")\n-              }\n-          }\n-\n-          hir::ExprKind::Assign(ref l, ref r) => {\n-            // see comment on places in\n-            // propagate_through_place_components()\n-            let succ = self.write_place(&l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_place_components(&l, succ);\n-            self.propagate_through_expr(&r, succ)\n-          }\n+                // Now that we know the label we're going to,\n+                // look it up in the continue loop nodes table\n+                self.cont_ln.get(&sc).cloned().unwrap_or_else(||\n+                    span_bug!(expr.span, \"continue to unknown label\"))\n+            }\n \n-          hir::ExprKind::AssignOp(_, ref l, ref r) => {\n-            // an overloaded assign op is like a method call\n-            if self.tables.is_method_call(expr) {\n-                let succ = self.propagate_through_expr(&l, succ);\n-                self.propagate_through_expr(&r, succ)\n-            } else {\n+            hir::ExprKind::Assign(ref l, ref r) => {\n                 // see comment on places in\n                 // propagate_through_place_components()\n-                let succ = self.write_place(&l, succ, ACC_WRITE|ACC_READ);\n-                let succ = self.propagate_through_expr(&r, succ);\n-                self.propagate_through_place_components(&l, succ)\n+                let succ = self.write_place(&l, succ, ACC_WRITE);\n+                let succ = self.propagate_through_place_components(&l, succ);\n+                self.propagate_through_expr(&r, succ)\n             }\n-          }\n \n-          // Uninteresting cases: just propagate in rev exec order\n+            hir::ExprKind::AssignOp(_, ref l, ref r) => {\n+                // an overloaded assign op is like a method call\n+                if self.tables.is_method_call(expr) {\n+                    let succ = self.propagate_through_expr(&l, succ);\n+                    self.propagate_through_expr(&r, succ)\n+                } else {\n+                    // see comment on places in\n+                    // propagate_through_place_components()\n+                    let succ = self.write_place(&l, succ, ACC_WRITE|ACC_READ);\n+                    let succ = self.propagate_through_expr(&r, succ);\n+                    self.propagate_through_place_components(&l, succ)\n+                }\n+            }\n \n-          hir::ExprKind::Array(ref exprs) => {\n-            self.propagate_through_exprs(exprs, succ)\n-          }\n+            // Uninteresting cases: just propagate in rev exec order\n \n-          hir::ExprKind::Struct(_, ref fields, ref with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n-            fields.iter().rev().fold(succ, |succ, field| {\n-                self.propagate_through_expr(&field.expr, succ)\n-            })\n-          }\n+            hir::ExprKind::Array(ref exprs) => {\n+                self.propagate_through_exprs(exprs, succ)\n+            }\n \n-          hir::ExprKind::Call(ref f, ref args) => {\n-            // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let succ = if self.tables.expr_ty(expr).is_never() {\n-                self.s.exit_ln\n-            } else {\n-                succ\n-            };\n-            let succ = self.propagate_through_exprs(args, succ);\n-            self.propagate_through_expr(&f, succ)\n-          }\n+            hir::ExprKind::Struct(_, ref fields, ref with_expr) => {\n+                let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n+                fields.iter().rev().fold(succ, |succ, field| {\n+                    self.propagate_through_expr(&field.expr, succ)\n+                })\n+            }\n \n-          hir::ExprKind::MethodCall(.., ref args) => {\n-            // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let succ = if self.tables.expr_ty(expr).is_never() {\n-                self.s.exit_ln\n-            } else {\n-                succ\n-            };\n-            self.propagate_through_exprs(args, succ)\n-          }\n+            hir::ExprKind::Call(ref f, ref args) => {\n+                // FIXME(canndrew): This is_never should really be an is_uninhabited\n+                let succ = if self.tables.expr_ty(expr).is_never() {\n+                    self.s.exit_ln\n+                } else {\n+                    succ\n+                };\n+                let succ = self.propagate_through_exprs(args, succ);\n+                self.propagate_through_expr(&f, succ)\n+            }\n \n-          hir::ExprKind::Tup(ref exprs) => {\n-            self.propagate_through_exprs(exprs, succ)\n-          }\n+            hir::ExprKind::MethodCall(.., ref args) => {\n+                // FIXME(canndrew): This is_never should really be an is_uninhabited\n+                let succ = if self.tables.expr_ty(expr).is_never() {\n+                    self.s.exit_ln\n+                } else {\n+                    succ\n+                };\n \n-          hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n-            let r_succ = self.propagate_through_expr(&r, succ);\n+                self.propagate_through_exprs(args, succ)\n+            }\n \n-            let ln = self.live_node(expr.hir_id, expr.span);\n-            self.init_from_succ(ln, succ);\n-            self.merge_from_succ(ln, r_succ, false);\n+            hir::ExprKind::Tup(ref exprs) => {\n+                self.propagate_through_exprs(exprs, succ)\n+            }\n \n-            self.propagate_through_expr(&l, ln)\n-          }\n+            hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n+                let r_succ = self.propagate_through_expr(&r, succ);\n \n-          hir::ExprKind::Index(ref l, ref r) |\n-          hir::ExprKind::Binary(_, ref l, ref r) => {\n-            let r_succ = self.propagate_through_expr(&r, succ);\n-            self.propagate_through_expr(&l, r_succ)\n-          }\n+                let ln = self.live_node(expr.hir_id, expr.span);\n+                self.init_from_succ(ln, succ);\n+                self.merge_from_succ(ln, r_succ, false);\n \n-          hir::ExprKind::Box(ref e) |\n-          hir::ExprKind::AddrOf(_, ref e) |\n-          hir::ExprKind::Cast(ref e, _) |\n-          hir::ExprKind::Type(ref e, _) |\n-          hir::ExprKind::Unary(_, ref e) |\n-          hir::ExprKind::Yield(ref e) |\n-          hir::ExprKind::Repeat(ref e, _) => {\n-            self.propagate_through_expr(&e, succ)\n-          }\n+                self.propagate_through_expr(&l, ln)\n+            }\n+\n+            hir::ExprKind::Index(ref l, ref r) |\n+            hir::ExprKind::Binary(_, ref l, ref r) => {\n+                let r_succ = self.propagate_through_expr(&r, succ);\n+                self.propagate_through_expr(&l, r_succ)\n+            }\n+\n+            hir::ExprKind::Box(ref e) |\n+            hir::ExprKind::AddrOf(_, ref e) |\n+            hir::ExprKind::Cast(ref e, _) |\n+            hir::ExprKind::Type(ref e, _) |\n+            hir::ExprKind::Unary(_, ref e) |\n+            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Repeat(ref e, _) => {\n+                self.propagate_through_expr(&e, succ)\n+            }\n \n-          hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n-            let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n+            hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n+                let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n                 // see comment on places\n                 // in propagate_through_place_components()\n                 if o.is_indirect {\n@@ -1269,29 +1258,28 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let acc = if o.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n                     let succ = self.write_place(output, succ, acc);\n                     self.propagate_through_place_components(output, succ)\n-                }\n-            });\n+                }});\n \n-            // Inputs are executed first. Propagate last because of rev order\n-            self.propagate_through_exprs(inputs, succ)\n-          }\n+                // Inputs are executed first. Propagate last because of rev order\n+                self.propagate_through_exprs(inputs, succ)\n+            }\n \n-          hir::ExprKind::Lit(..) | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n-            succ\n-          }\n+            hir::ExprKind::Lit(..) | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n+                succ\n+            }\n \n-          // Note that labels have been resolved, so we don't need to look\n-          // at the label ident\n-          hir::ExprKind::Block(ref blk, _) => {\n-            self.propagate_through_block(&blk, succ)\n-          }\n+            // Note that labels have been resolved, so we don't need to look\n+            // at the label ident\n+            hir::ExprKind::Block(ref blk, _) => {\n+                self.propagate_through_block(&blk, succ)\n+            }\n         }\n     }\n \n     fn propagate_through_place_components(&mut self,\n-                                           expr: &Expr,\n-                                           succ: LiveNode)\n-                                           -> LiveNode {\n+                                          expr: &Expr,\n+                                          succ: LiveNode)\n+                                          -> LiveNode {\n         // # Places\n         //\n         // In general, the full flow graph structure for an\n@@ -1349,18 +1337,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     // see comment on propagate_through_place()\n-    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n-                    -> LiveNode {\n+    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32) -> LiveNode {\n         match expr.node {\n-          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-              self.access_path(expr.hir_id, path, succ, acc)\n-          }\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                self.access_path(expr.hir_id, path, succ, acc)\n+            }\n \n-          // We do not track other places, so just propagate through\n-          // to their subcomponents.  Also, it may happen that\n-          // non-places occur here, because those are detected in the\n-          // later pass borrowck.\n-          _ => succ\n+            // We do not track other places, so just propagate through\n+            // to their subcomponents.  Also, it may happen that\n+            // non-places occur here, because those are detected in the\n+            // later pass borrowck.\n+            _ => succ\n         }\n     }\n \n@@ -1379,10 +1366,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, hir_id: HirId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match path.def {\n-          Def::Local(nid) => {\n-            self.access_var(hir_id, nid, succ, acc, path.span)\n-          }\n-          _ => succ\n+            Def::Local(nid) => {\n+              self.access_var(hir_id, nid, succ, acc, path.span)\n+            }\n+            _ => succ\n         }\n     }\n \n@@ -1392,7 +1379,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               body: &hir::Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n-\n         /*\n \n         We model control flow like this:\n@@ -1450,8 +1436,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.propagate_through_expr(&cond, ln)\n                 }\n             };\n-            assert!(cond_ln == new_cond_ln);\n-            assert!(body_ln == self.propagate_through_block(body, cond_ln));\n+            assert_eq!(cond_ln, new_cond_ln);\n+            assert_eq!(body_ln, self.propagate_through_block(body, cond_ln));\n         }\n \n         cond_ln\n@@ -1505,49 +1491,49 @@ fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n \n fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n-      hir::ExprKind::Assign(ref l, _) => {\n-        this.check_place(&l);\n-\n-        intravisit::walk_expr(this, expr);\n-      }\n-\n-      hir::ExprKind::AssignOp(_, ref l, _) => {\n-        if !this.tables.is_method_call(expr) {\n+        hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n+\n+            intravisit::walk_expr(this, expr);\n         }\n \n-        intravisit::walk_expr(this, expr);\n-      }\n+        hir::ExprKind::AssignOp(_, ref l, _) => {\n+            if !this.tables.is_method_call(expr) {\n+                this.check_place(&l);\n+            }\n \n-      hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n-        for input in inputs {\n-          this.visit_expr(input);\n+            intravisit::walk_expr(this, expr);\n         }\n \n-        // Output operands must be places\n-        for (o, output) in ia.outputs.iter().zip(outputs) {\n-          if !o.is_indirect {\n-            this.check_place(output);\n-          }\n-          this.visit_expr(output);\n-        }\n+        hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n+            for input in inputs {\n+                this.visit_expr(input);\n+            }\n \n-        intravisit::walk_expr(this, expr);\n-      }\n+            // Output operands must be places\n+            for (o, output) in ia.outputs.iter().zip(outputs) {\n+                if !o.is_indirect {\n+                    this.check_place(output);\n+                }\n+                this.visit_expr(output);\n+            }\n \n-      // no correctness conditions related to liveness\n-      hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n-      hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n-      hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n-      hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n-      hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Ret(..) |\n-      hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) | hir::ExprKind::Lit(_) |\n-      hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n-      hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n-      hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n-      hir::ExprKind::Box(..) | hir::ExprKind::Type(..) => {\n-        intravisit::walk_expr(this, expr);\n-      }\n+            intravisit::walk_expr(this, expr);\n+        }\n+\n+        // no correctness conditions related to liveness\n+        hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n+        hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n+        hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n+        hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n+        hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Ret(..) |\n+        hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) | hir::ExprKind::Lit(_) |\n+        hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n+        hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+        hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n+        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) => {\n+            intravisit::walk_expr(this, expr);\n+        }\n     }\n }\n \n@@ -1576,7 +1562,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.is_empty() || name.as_bytes()[0] == ('_' as u8) {\n+        if name.is_empty() || name.as_bytes()[0] == b'_' {\n             None\n         } else {\n             Some(name)\n@@ -1617,7 +1603,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n             if let Some(name) = r {\n-\n                 // annoying: for parameters in funcs like `fn(x: i32)\n                 // {ret}`, there is only one node, so asking about\n                 // assigned_on_exit() is not meaningful.\n@@ -1627,8 +1612,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.assigned_on_exit(ln, var).is_some()\n                 };\n \n-                let suggest_underscore_msg = format!(\"consider using `_{}` instead\",\n-                                                     name);\n+                let suggest_underscore_msg = format!(\"consider using `_{}` instead\", name);\n \n                 if is_assigned {\n                     self.ir.tcx"}, {"sha": "13e6f7a4c745a18c4e884d1c4579202f1540ed41", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 234, "deletions": 243, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -83,6 +83,7 @@ use hir;\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n+use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n@@ -91,13 +92,13 @@ use util::nodemap::ItemLocalSet;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {\n-    Rvalue(ty::Region<'tcx>),              // temporary val, argument is its scope\n+    Rvalue(ty::Region<'tcx>),            // temporary val, argument is its scope\n     StaticItem,\n-    Upvar(Upvar),                          // upvar referenced by closure env\n-    Local(ast::NodeId),                    // local variable\n+    Upvar(Upvar),                        // upvar referenced by closure env\n+    Local(ast::NodeId),                  // local variable\n     Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n-    Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n-    Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n+    Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n+    Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -149,8 +150,8 @@ impl Hash for FieldIndex {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorOffsetKind {\n-    Index,            // e.g. `array_expr[index_expr]`\n-    Pattern,          // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n+    Index,   // e.g. `array_expr[index_expr]`\n+    Pattern, // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -580,7 +581,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                   expr: &hir::Expr,\n                                   adjustments: &[adjustment::Adjustment<'tcx>])\n-                                   -> McResult<cmt_<'tcx>> {\n+                                  -> McResult<cmt_<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -640,61 +641,61 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n-          hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n-            if self.tables.is_method_call(expr) {\n-                self.cat_overloaded_place(expr, e_base, NoteNone)\n-            } else {\n-                let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n-                self.cat_deref(expr, base_cmt, NoteNone)\n+            hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n+                if self.tables.is_method_call(expr) {\n+                    self.cat_overloaded_place(expr, e_base, NoteNone)\n+                } else {\n+                    let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n+                    self.cat_deref(expr, base_cmt, NoteNone)\n+                }\n             }\n-          }\n-\n-          hir::ExprKind::Field(ref base, f_ident) => {\n-            let base_cmt = Rc::new(self.cat_expr(&base)?);\n-            debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n-                   expr.id,\n-                   expr,\n-                   base_cmt);\n-            let f_index = self.tcx.field_index(expr.id, self.tables);\n-            Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n-          }\n-\n-          hir::ExprKind::Index(ref base, _) => {\n-            if self.tables.is_method_call(expr) {\n-                // If this is an index implemented by a method call, then it\n-                // will include an implicit deref of the result.\n-                // The call to index() returns a `&T` value, which\n-                // is an rvalue. That is what we will be\n-                // dereferencing.\n-                self.cat_overloaded_place(expr, base, NoteIndex)\n-            } else {\n+\n+            hir::ExprKind::Field(ref base, f_ident) => {\n                 let base_cmt = Rc::new(self.cat_expr(&base)?);\n-                self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n+                debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n+                       expr.id,\n+                       expr,\n+                       base_cmt);\n+                let f_index = self.tcx.field_index(expr.id, self.tables);\n+                Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n+            }\n+\n+            hir::ExprKind::Index(ref base, _) => {\n+                if self.tables.is_method_call(expr) {\n+                    // If this is an index implemented by a method call, then it\n+                    // will include an implicit deref of the result.\n+                    // The call to index() returns a `&T` value, which\n+                    // is an rvalue. That is what we will be\n+                    // dereferencing.\n+                    self.cat_overloaded_place(expr, base, NoteIndex)\n+                } else {\n+                    let base_cmt = Rc::new(self.cat_expr(&base)?);\n+                    self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n+                }\n+            }\n+\n+            hir::ExprKind::Path(ref qpath) => {\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n+                self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n+            }\n+\n+            hir::ExprKind::Type(ref e, _) => {\n+                self.cat_expr(&e)\n+            }\n+\n+            hir::ExprKind::AddrOf(..) | hir::ExprKind::Call(..) |\n+            hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n+            hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n+            hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n+            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) |\n+            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n+            hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n+            hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n+            hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n+            hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+            hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) => {\n+                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n             }\n-          }\n-\n-          hir::ExprKind::Path(ref qpath) => {\n-              let def = self.tables.qpath_def(qpath, expr.hir_id);\n-              self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n-          }\n-\n-          hir::ExprKind::Type(ref e, _) => {\n-            self.cat_expr(&e)\n-          }\n-\n-          hir::ExprKind::AddrOf(..) | hir::ExprKind::Call(..) |\n-          hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n-          hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n-          hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n-          hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) |\n-          hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n-          hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n-          hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n-          hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n-          hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n-          hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) => {\n-            Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n-          }\n         }\n     }\n \n@@ -708,44 +709,45 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                hir_id, expr_ty, def);\n \n         match def {\n-          Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) |\n-          Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n+            Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) |\n+            Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n                 Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n-          }\n+            }\n \n-          Def::Static(def_id, mutbl) => {\n-            // `#[thread_local]` statics may not outlive the current function.\n-            for attr in &self.tcx.get_attrs(def_id)[..] {\n-                if attr.check_name(\"thread_local\") {\n-                    return Ok(self.cat_rvalue_node(hir_id, span, expr_ty));\n+            Def::Static(def_id, mutbl) => {\n+                // `#[thread_local]` statics may not outlive the current function.\n+                for attr in &self.tcx.get_attrs(def_id)[..] {\n+                    if attr.check_name(\"thread_local\") {\n+                        return Ok(self.cat_rvalue_node(hir_id, span, expr_ty));\n+                    }\n                 }\n+\n+                Ok(cmt_ {\n+                    hir_id,\n+                    span:span,\n+                    cat:Categorization::StaticItem,\n+                    mutbl: if mutbl { McDeclared } else { McImmutable},\n+                    ty:expr_ty,\n+                    note: NoteNone\n+                })\n+            }\n+\n+            Def::Upvar(var_id, _, fn_node_id) => {\n+                self.cat_upvar(hir_id, span, var_id, fn_node_id)\n             }\n-              Ok(cmt_ {\n-                  hir_id,\n-                  span:span,\n-                  cat:Categorization::StaticItem,\n-                  mutbl: if mutbl { McDeclared } else { McImmutable},\n-                  ty:expr_ty,\n-                  note: NoteNone\n-              })\n-          }\n-\n-          Def::Upvar(var_id, _, fn_node_id) => {\n-              self.cat_upvar(hir_id, span, var_id, fn_node_id)\n-          }\n-\n-          Def::Local(vid) => {\n-            Ok(cmt_ {\n-                hir_id,\n-                span,\n-                cat: Categorization::Local(vid),\n-                mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n-                ty: expr_ty,\n-                note: NoteNone\n-            })\n-          }\n \n-          def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n+            Def::Local(vid) => {\n+                Ok(cmt_ {\n+                    hir_id,\n+                    span,\n+                    cat: Categorization::Local(vid),\n+                    mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n+                    ty: expr_ty,\n+                    note: NoteNone\n+                })\n+            }\n+\n+            def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n         }\n     }\n \n@@ -941,30 +943,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt_<'tcx> {\n-        debug!(\n-            \"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n-            hir_id,\n-            span,\n-            expr_ty,\n-        );\n+        debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n+               hir_id, span, expr_ty);\n+\n         let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n                                                             .unwrap_or(false);\n \n-        debug!(\n-            \"cat_rvalue_node: promotable = {:?}\",\n-            promotable,\n-        );\n+        debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n             ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,\n         };\n \n-        debug!(\n-            \"cat_rvalue_node: promotable = {:?} (2)\",\n-            promotable,\n-        );\n+        debug!(\"cat_rvalue_node: promotable = {:?} (2)\", promotable);\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n@@ -1022,12 +1015,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         base: &hir::Expr,\n         note: Note,\n     ) -> McResult<cmt_<'tcx>> {\n-        debug!(\n-            \"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n-            expr,\n-            base,\n-            note,\n-        );\n+        debug!(\"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n+               expr,\n+               base,\n+               note);\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n@@ -1037,9 +1028,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let (region, mutbl) = match base_ty.sty {\n             ty::Ref(region, _, mutbl) => (region, mutbl),\n-            _ => {\n-                span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n-            }\n+            _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n         };\n         let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n             ty: place_ty,\n@@ -1062,8 +1051,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let deref_ty = match base_cmt_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,\n             None => {\n-                debug!(\"Explicit deref of non-derefable type: {:?}\",\n-                       base_cmt_ty);\n+                debug!(\"Explicit deref of non-derefable type: {:?}\", base_cmt_ty);\n                 return Err(());\n             }\n         };\n@@ -1120,11 +1108,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_imm_interior<N:HirNode>(&self,\n-                                        node: &N,\n-                                        base_cmt: cmt<'tcx>,\n-                                        interior_ty: Ty<'tcx>,\n-                                        interior: InteriorKind)\n-                                        -> cmt_<'tcx> {\n+                                       node: &N,\n+                                       base_cmt: cmt<'tcx>,\n+                                       interior_ty: Ty<'tcx>,\n+                                       interior: InteriorKind)\n+                                       -> cmt_<'tcx> {\n         let ret = cmt_ {\n             hir_id: node.hir_id(),\n             span: node.span(),\n@@ -1138,10 +1126,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_downcast_if_needed<N:HirNode>(&self,\n-                                              node: &N,\n-                                              base_cmt: cmt<'tcx>,\n-                                              variant_did: DefId)\n-                                              -> cmt<'tcx> {\n+                                             node: &N,\n+                                             base_cmt: cmt<'tcx>,\n+                                             variant_did: DefId)\n+                                             -> cmt<'tcx> {\n         // univariant enums do not need downcasts\n         let base_did = self.tcx.parent_def_id(variant_did).unwrap();\n         if self.tcx.adt_def(base_did).variants.len() != 1 {\n@@ -1277,117 +1265,120 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         op(cmt.clone(), pat);\n \n         match pat.node {\n-          PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.tables.qpath_def(qpath, pat.hir_id);\n-            let (cmt, expected_len) = match def {\n-                Def::Err => {\n-                    debug!(\"access to unresolvable pattern {:?}\", pat);\n-                    return Err(())\n-                }\n-                Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                    let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n-                    (self.cat_downcast_if_needed(pat, cmt, def_id),\n-                     self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n-                }\n-                Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n-                    match self.pat_ty_unadjusted(&pat)?.sty {\n-                        ty::Adt(adt_def, _) => {\n-                            (cmt, adt_def.non_enum_variant().fields.len())\n-                        }\n-                        ref ty => {\n-                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n+            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let (cmt, expected_len) = match def {\n+                    Def::Err => {\n+                        debug!(\"access to unresolvable pattern {:?}\", pat);\n+                        return Err(())\n+                    }\n+                    Def::VariantCtor(def_id, CtorKind::Fn) => {\n+                        let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n+                        (self.cat_downcast_if_needed(pat, cmt, def_id),\n+                        self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n+                    }\n+                    Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n+                        match self.pat_ty_unadjusted(&pat)?.sty {\n+                            ty::Adt(adt_def, _) => {\n+                                (cmt, adt_def.non_enum_variant().fields.len())\n+                            }\n+                            ref ty => {\n+                                span_bug!(pat.span,\n+                                          \"tuple struct pattern unexpected type {:?}\", ty);\n+                            }\n                         }\n                     }\n+                    def => {\n+                        span_bug!(pat.span, \"tuple struct pattern didn't resolve \\\n+                                             to variant or struct {:?}\", def);\n+                    }\n+                };\n+\n+                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n+                    let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                    let subcmt = Rc::new(\n+                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n+                    self.cat_pattern_(subcmt, &subpat, op)?;\n                 }\n-                def => {\n-                    span_bug!(pat.span, \"tuple struct pattern didn't resolve \\\n-                                         to variant or struct {:?}\", def);\n+            }\n+\n+            PatKind::Struct(ref qpath, ref field_pats, _) => {\n+                // {f1: p1, ..., fN: pN}\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let cmt = match def {\n+                    Def::Err => {\n+                        debug!(\"access to unresolvable pattern {:?}\", pat);\n+                        return Err(())\n+                    },\n+                    Def::Variant(variant_did) |\n+                    Def::VariantCtor(variant_did, ..) => {\n+                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n+                    },\n+                    _ => cmt\n+                };\n+\n+                for fp in field_pats {\n+                    let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n+                    let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                    let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n+                                                           fp.node.ident, field_ty));\n+                    self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n                 }\n-            };\n+            }\n \n-            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n-                self.cat_pattern_(subcmt, &subpat, op)?;\n+            PatKind::Binding(.., Some(ref subpat)) => {\n+                self.cat_pattern_(cmt, &subpat, op)?;\n             }\n-          }\n-\n-          PatKind::Struct(ref qpath, ref field_pats, _) => {\n-            // {f1: p1, ..., fN: pN}\n-            let def = self.tables.qpath_def(qpath, pat.hir_id);\n-            let cmt = match def {\n-                Def::Err => {\n-                    debug!(\"access to unresolvable pattern {:?}\", pat);\n-                    return Err(())\n-                },\n-                Def::Variant(variant_did) |\n-                Def::VariantCtor(variant_did, ..) => {\n-                    self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                },\n-                _ => cmt\n-            };\n-\n-            for fp in field_pats {\n-                let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                let f_index = self.tcx.field_index(fp.node.id, self.tables);\n-                let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n-                                                       fp.node.ident, field_ty));\n-                self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n+\n+            PatKind::Tuple(ref subpats, ddpos) => {\n+                // (p1, ..., pN)\n+                let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n+                    ty::Tuple(ref tys) => tys.len(),\n+                    ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n+                };\n+                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n+                    let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                    let subcmt = Rc::new(\n+                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n+                    self.cat_pattern_(subcmt, &subpat, op)?;\n+                }\n             }\n-          }\n-\n-          PatKind::Binding(.., Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &subpat, op)?;\n-          }\n-\n-          PatKind::Tuple(ref subpats, ddpos) => {\n-            // (p1, ..., pN)\n-            let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n-                ty::Tuple(ref tys) => tys.len(),\n-                ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n-            };\n-            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n+\n+                PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n+                // box p1, &p1, &mut p1.  we can ignore the mutability of\n+                // PatKind::Ref since that information is already contained\n+                // in the type.\n+                let subcmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n-          }\n-\n-          PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n-            // box p1, &p1, &mut p1.  we can ignore the mutability of\n-            // PatKind::Ref since that information is already contained\n-            // in the type.\n-            let subcmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n-            self.cat_pattern_(subcmt, &subpat, op)?;\n-          }\n-\n-          PatKind::Slice(ref before, ref slice, ref after) => {\n-            let element_ty = match cmt.ty.builtin_index() {\n-                Some(ty) => ty,\n-                None => {\n-                    debug!(\"Explicit index of non-indexable type {:?}\", cmt);\n-                    return Err(());\n+\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n+                let element_ty = match cmt.ty.builtin_index() {\n+                    Some(ty) => ty,\n+                    None => {\n+                        debug!(\"Explicit index of non-indexable type {:?}\", cmt);\n+                        return Err(());\n+                    }\n+                };\n+                let context = InteriorOffsetKind::Pattern;\n+                let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n+                for before_pat in before {\n+                    self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n+                }\n+                if let Some(ref slice_pat) = *slice {\n+                    self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n+                }\n+                for after_pat in after {\n+                    self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n                 }\n-            };\n-            let context = InteriorOffsetKind::Pattern;\n-            let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n-            for before_pat in before {\n-                self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n-            }\n-            if let Some(ref slice_pat) = *slice {\n-                self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n-            }\n-            for after_pat in after {\n-                self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n             }\n-          }\n \n-          PatKind::Path(_) | PatKind::Binding(.., None) |\n-          PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n-            // always ok\n-          }\n+            PatKind::Path(_) | PatKind::Binding(.., None) |\n+            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n+                // always ok\n+            }\n         }\n \n         Ok(())\n@@ -1489,59 +1480,59 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    pub fn descriptive_string(&self, tcx: TyCtxt<'_, '_, '_>) -> String {\n+    pub fn descriptive_string(&self, tcx: TyCtxt<'_, '_, '_>) -> Cow<'static, str> {\n         match self.cat {\n             Categorization::StaticItem => {\n-                \"static item\".to_string()\n+                \"static item\".into()\n             }\n             Categorization::Rvalue(..) => {\n-                \"non-place\".to_string()\n+                \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n                 if tcx.hir.is_argument(vid) {\n-                    \"argument\".to_string()\n+                    \"argument\"\n                 } else {\n-                    \"local variable\".to_string()\n-                }\n+                    \"local variable\"\n+                }.into()\n             }\n             Categorization::Deref(_, pk) => {\n                 match self.upvar_cat() {\n                     Some(&Categorization::Upvar(ref var)) => {\n-                        var.to_string()\n+                        var.to_string().into()\n                     }\n                     Some(_) => bug!(),\n                     None => {\n                         match pk {\n                             Unique => {\n-                                \"`Box` content\".to_string()\n+                                \"`Box` content\"\n                             }\n                             UnsafePtr(..) => {\n-                                \"dereference of raw pointer\".to_string()\n+                                \"dereference of raw pointer\"\n                             }\n                             BorrowedPtr(..) => {\n                                 match self.note {\n-                                    NoteIndex => \"indexed content\".to_string(),\n-                                    _ => \"borrowed content\".to_string(),\n+                                    NoteIndex => \"indexed content\",\n+                                    _ => \"borrowed content\"\n                                 }\n                             }\n-                        }\n+                        }.into()\n                     }\n                 }\n             }\n             Categorization::Interior(_, InteriorField(..)) => {\n-                \"field\".to_string()\n+                \"field\".into()\n             }\n             Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n-                \"indexed content\".to_string()\n+                \"indexed content\".into()\n             }\n             Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern)) => {\n-                \"pattern-bound indexed content\".to_string()\n+                \"pattern-bound indexed content\".into()\n             }\n             Categorization::Upvar(ref var) => {\n-                var.to_string()\n+                var.to_string().into()\n             }\n             Categorization::Downcast(ref cmt, _) => {\n-                cmt.descriptive_string(tcx)\n+                cmt.descriptive_string(tcx).into()\n             }\n         }\n     }"}, {"sha": "14293afc7078f8ce3e8c6fcd771b6256421c7cea", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -371,7 +371,9 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                     return\n                 }\n \n-                for default_method in self.tcx.provided_trait_methods(trait_def_id) {\n+                let provided_trait_methods = self.tcx.provided_trait_methods(trait_def_id);\n+                self.worklist.reserve(provided_trait_methods.len());\n+                for default_method in provided_trait_methods {\n                     let node_id = self.tcx\n                                       .hir\n                                       .as_local_node_id(default_method.def_id)\n@@ -394,7 +396,6 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n #[derive(Clone)]\n pub struct ReachableSet(pub Lrc<NodeSet>);\n \n-\n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n "}, {"sha": "edb571da7dbc50c010d07079f9b45e93960e2dde", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -459,13 +459,13 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(Scope, Scope) {\n+    pub fn each_encl_scope<E>(&self, mut e: E) where E: FnMut(Scope, Scope) {\n         for (&child, &parent) in &self.parent_map {\n             e(child, parent.0)\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, Scope) {\n+    pub fn each_var_scope<E>(&self, mut e: E) where E: FnMut(&hir::ItemLocalId, Scope) {\n         for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n@@ -515,10 +515,8 @@ impl<'tcx> ScopeTree {\n \n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n-        match self.var_map.get(&var_id) {\n-            Some(&r) => r,\n-            None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n-        }\n+        self.var_map.get(&var_id).cloned().unwrap_or_else(||\n+            bug!(\"no enclosing scope for id {:?}\", var_id))\n     }\n \n     pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n@@ -559,8 +557,7 @@ impl<'tcx> ScopeTree {\n         scope\n     }\n \n-    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope)\n-                            -> bool {\n+    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n         self.is_subscope_of(scope1, scope2) ||\n         self.is_subscope_of(scope2, scope1)\n     }\n@@ -584,14 +581,13 @@ impl<'tcx> ScopeTree {\n             }\n         }\n \n-        debug!(\"is_subscope_of({:?}, {:?})=true\",\n-               subscope, superscope);\n+        debug!(\"is_subscope_of({:?}, {:?})=true\", subscope, superscope);\n \n         return true;\n     }\n \n     /// Returns the id of the innermost containing body\n-    pub fn containing_body(&self, mut scope: Scope)-> Option<hir::ItemLocalId> {\n+    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n                 return Some(scope.item_local_id());\n@@ -664,8 +660,8 @@ impl<'tcx> ScopeTree {\n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n     pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       br: &ty::EarlyBoundRegion)\n-                                       -> Scope {\n+                                      br: &ty::EarlyBoundRegion)\n+                                      -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n@@ -828,10 +824,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            hir::Guard::If(ref expr) => visitor.terminating_scopes.insert(expr.hir_id.local_id),\n-        };\n+    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n@@ -890,11 +884,9 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // This ensures fixed size stacks.\n \n             hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::And, .. },\n-                _, ref r) |\n+                source_map::Spanned { node: hir::BinOpKind::And, .. }, _, ref r) |\n             hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n-                _, ref r) => {\n+                source_map::Spanned { node: hir::BinOpKind::Or, .. }, _, ref r) => {\n                     // For shortcircuiting operators, mark the RHS as a terminating\n                     // scope since it only executes conditionally.\n                     terminating(r.hir_id.local_id);"}, {"sha": "a10b387672ad6311a4da7e7497dbbcd17a46bd7b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 55, "deletions": 76, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -25,6 +25,7 @@ use errors::DiagnosticBuilder;\n use rustc::lint;\n use rustc_data_structures::sync::Lrc;\n use session::Session;\n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::mem::replace;\n use syntax::ast;\n@@ -360,17 +361,17 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         is_late_bound_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-                .late_bound\n-                .get(&id)\n-                .cloned()\n+               .late_bound\n+               .get(&id)\n+               .cloned()\n         },\n \n         object_lifetime_defaults_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-                .object_lifetime_defaults\n-                .get(&id)\n-                .cloned()\n+               .object_lifetime_defaults\n+               .get(&id)\n+               .cloned()\n         },\n \n         ..*providers\n@@ -410,8 +411,8 @@ fn resolve_lifetimes<'tcx>(\n     for (k, v) in named_region_map.object_lifetime_defaults {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = rl.object_lifetime_defaults\n-            .entry(hir_id.owner_local_def_id())\n-            .or_default();\n+                    .entry(hir_id.owner_local_def_id())\n+                    .or_default();\n         Lrc::get_mut(map)\n             .unwrap()\n             .insert(hir_id.local_id, Lrc::new(v));\n@@ -676,7 +677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                         lifetime.span,\n                                         E0657,\n                                         \"`impl Trait` can only capture lifetimes \\\n-                                        bound at the fn or impl level\"\n+                                         bound at the fn or impl level\"\n                                     );\n                                     self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                                 }\n@@ -1250,24 +1251,24 @@ fn compute_object_lifetime_defaults(\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {\n-                            Set1::Empty => \"BaseDefault\".to_string(),\n-                            Set1::One(Region::Static) => \"'static\".to_string(),\n+                            Set1::Empty => \"BaseDefault\".into(),\n+                            Set1::One(Region::Static) => \"'static\".into(),\n                             Set1::One(Region::EarlyBound(mut i, _, _)) => {\n                                 generics.params.iter().find_map(|param| match param.kind {\n-                                        GenericParamKind::Lifetime { .. } => {\n-                                            if i == 0 {\n-                                                return Some(param.name.ident().to_string());\n-                                            }\n-                                            i -= 1;\n-                                            None\n+                                    GenericParamKind::Lifetime { .. } => {\n+                                        if i == 0 {\n+                                            return Some(param.name.ident().to_string().into());\n                                         }\n-                                        _ => None,\n-                                    }).unwrap()\n+                                        i -= 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                }).unwrap()\n                             }\n                             Set1::One(_) => bug!(),\n-                            Set1::Many => \"Ambiguous\".to_string(),\n+                            Set1::Many => \"Ambiguous\".into(),\n                         })\n-                        .collect::<Vec<String>>()\n+                        .collect::<Vec<Cow<'static, str>>>()\n                         .join(\",\");\n                     tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n@@ -1420,16 +1421,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         def_ids.sort_by_key(|&def_id| self.tcx.def_path_hash(def_id));\n \n         for def_id in def_ids {\n-            debug!(\n-                \"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\",\n-                def_id,\n-            );\n+            debug!(\"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\", def_id);\n \n             let lifetimeuseset = self.lifetime_uses.remove(&def_id);\n-            debug!(\n-                \"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n-                lifetimeuseset\n-            );\n+\n+            debug!(\"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n+                   lifetimeuseset);\n+\n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -1669,7 +1667,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n                              explicitly declared using `<...>` binders\"\n                         ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n-                            .emit();\n+                         .emit();\n                     }\n \n                     Region::Static\n@@ -1689,7 +1687,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 \"use of undeclared lifetime name `{}`\",\n                 lifetime_ref\n             ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n-                .emit();\n+             .emit();\n         }\n     }\n \n@@ -1872,18 +1870,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n-                match self.tcx\n+                if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemKind::Trait(.., ref trait_items) => {\n-                        assoc_item_kind = trait_items\n-                            .iter()\n-                            .find(|ti| ti.id.node_id == parent)\n-                            .map(|ti| ti.kind);\n-                    }\n-                    _ => {}\n+                    assoc_item_kind = trait_items\n+                        .iter()\n+                        .find(|ti| ti.id.node_id == parent)\n+                        .map(|ti| ti.kind);\n                 }\n                 match *m {\n                     hir::TraitMethod::Required(_) => None,\n@@ -1895,19 +1890,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n-                match self.tcx\n+                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemKind::Impl(.., ref self_ty, ref impl_items) => {\n-                        impl_self = Some(self_ty);\n-                        assoc_item_kind = impl_items\n-                            .iter()\n-                            .find(|ii| ii.id.node_id == parent)\n-                            .map(|ii| ii.kind);\n-                    }\n-                    _ => {}\n+                    impl_self = Some(self_ty);\n+                    assoc_item_kind = impl_items\n+                        .iter()\n+                        .find(|ii| ii.id.node_id == parent)\n+                        .map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }\n@@ -2255,9 +2247,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault {\n-                    lifetime: Some(l), ..\n-                } => break l,\n+                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -2329,13 +2319,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     lifetime_i.name.ident(),\n                                 ),\n                             ).help(&format!(\n-                                \"you can use the `'static` lifetime directly, in place \\\n-                                    of `{}`\",\n+                                \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                 lifetime_i.name.ident(),\n                             )).emit();\n                         }\n-                        hir::LifetimeName::Param(_)\n-                        | hir::LifetimeName::Implicit => {\n+                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n                     }\n@@ -2492,8 +2480,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n /// Detects late-bound lifetimes and inserts them into\n /// `map.late_bound`.\n ///\n@@ -2509,10 +2495,8 @@ fn insert_late_bound_lifetimes(\n     decl: &hir::FnDecl,\n     generics: &hir::Generics,\n ) {\n-    debug!(\n-        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-        decl, generics\n-    );\n+    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n+           decl, generics);\n \n     let mut constrained_by_input = ConstrainedCollector {\n         regions: FxHashSet(),\n@@ -2526,10 +2510,8 @@ fn insert_late_bound_lifetimes(\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\n-        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-        constrained_by_input.regions\n-    );\n+    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+           constrained_by_input.regions);\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -2541,15 +2523,12 @@ fn insert_late_bound_lifetimes(\n     appears_in_where_clause.visit_generics(generics);\n \n     for param in &generics.params {\n-        match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                if !param.bounds.is_empty() {\n-                    // `'a: 'b` means both `'a` and `'b` are referenced\n-                    appears_in_where_clause\n-                        .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n-                }\n+        if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n+            if !param.bounds.is_empty() {\n+                // `'a: 'b` means both `'a` and `'b` are referenced\n+                appears_in_where_clause\n+                    .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n             }\n-            hir::GenericParamKind::Type { .. } => {}\n         }\n     }\n \n@@ -2661,10 +2640,10 @@ pub fn report_missing_lifetime_specifiers(\n         if count > 1 { \"s\" } else { \"\" }\n     );\n \n-    let msg = if count > 1 {\n-        format!(\"expected {} lifetime parameters\", count)\n+    let msg: Cow<'static, str> = if count > 1 {\n+        format!(\"expected {} lifetime parameters\", count).into()\n     } else {\n-        \"expected lifetime parameter\".to_string()\n+        \"expected lifetime parameter\".into()\n     };\n \n     err.span_label(span, msg);"}, {"sha": "9dd13dd2272b048a5e24ec4f358e0584b75ffd9c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -164,8 +164,10 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 if let (&Some(attr::RustcDeprecation {since: dep_since, ..}),\n                         &attr::Stable {since: stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in\n-                            dep_since.as_str().split('.').zip(stab_since.as_str().split('.')) {\n+                    for (dep_v, stab_v) in dep_since.as_str()\n+                                                    .split('.')\n+                                                    .zip(stab_since.as_str().split('.'))\n+                    {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n                             match dep_v.cmp(&stab_v) {\n                                 Ordering::Less => {\n@@ -523,15 +525,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Some(Def::Method(_)) |\n             Some(Def::AssociatedTy(_)) |\n             Some(Def::AssociatedConst(_)) => {\n-                match self.associated_item(def_id).container {\n-                    ty::TraitContainer(trait_def_id) => {\n-                        // Trait methods do not declare visibility (even\n-                        // for visibility info in cstore). Use containing\n-                        // trait instead, so methods of pub traits are\n-                        // themselves considered pub.\n-                        def_id = trait_def_id;\n-                    }\n-                    _ => {}\n+                if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n+                    // Trait methods do not declare visibility (even\n+                    // for visibility info in cstore). Use containing\n+                    // trait instead, so methods of pub traits are\n+                    // themselves considered pub.\n+                    def_id = trait_def_id;\n                 }\n             }\n             _ => {}\n@@ -561,8 +560,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `id`.\n     pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n         if span.allows_unstable() {\n-            debug!(\"stability: \\\n-                    skipping span={:?} since it is internal\", span);\n+            debug!(\"stability: skipping span={:?} since it is internal\", span);\n             return EvalResult::Allow;\n         }\n \n@@ -770,8 +768,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     let param_env = self.tcx.param_env(def_id);\n                     if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                        \"untagged_unions\", item.span, GateIssue::Language,\n-                                        \"unions with non-`Copy` fields are unstable\");\n+                                         \"untagged_unions\", item.span, GateIssue::Language,\n+                                         \"unions with non-`Copy` fields are unstable\");\n                     }\n                 }\n             }"}, {"sha": "0d407765c9e10be413f07a9ada0c699efb0c7515", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -113,13 +113,13 @@ fn verify<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            items.$name().is_none() {\n             if lang_items::$item == lang_items::PanicImplLangItem {\n                 tcx.sess.err(&format!(\"`#[panic_handler]` function required, \\\n-                                        but not found\"));\n+                                       but not found\"));\n             } else if lang_items::$item == lang_items::OomLangItem {\n                 tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, \\\n-                                        but not found\"));\n+                                       but not found\"));\n             } else {\n                 tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n-                                        stringify!($name)));\n+                                      stringify!($name)));\n             }\n         }\n     )*"}, {"sha": "0ef0d284770f555f4577a758e68c5a590a4c3e93", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efdc04a5d687fce7a63ca339e5c74d8c51e40d2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4efdc04a5d687fce7a63ca339e5c74d8c51e40d2", "patch": "@@ -38,6 +38,7 @@ use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use rustc_mir::util::suggest_ref_mut;\n use rustc::util::nodemap::FxHashSet;\n \n+use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::rc::Rc;\n@@ -808,34 +809,34 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         match err.code {\n             err_mutbl => {\n-                let descr = match err.cmt.note {\n+                let descr: Cow<'static, str> = match err.cmt.note {\n                     mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n-                        self.cmt_to_string(&err.cmt)\n+                        self.cmt_to_cow_str(&err.cmt)\n                     }\n                     _ => match opt_loan_path_is_field(&err.cmt) {\n                         (None, true) => {\n                             format!(\"{} of {} binding\",\n-                                    self.cmt_to_string(&err.cmt),\n-                                    err.cmt.mutbl.to_user_str())\n+                                    self.cmt_to_cow_str(&err.cmt),\n+                                    err.cmt.mutbl.to_user_str()).into()\n \n                         }\n                         (None, false) => {\n                             format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_string(&err.cmt))\n+                                    self.cmt_to_cow_str(&err.cmt)).into()\n \n                         }\n                         (Some(lp), true) => {\n                             format!(\"{} `{}` of {} binding\",\n-                                    self.cmt_to_string(&err.cmt),\n+                                    self.cmt_to_cow_str(&err.cmt),\n                                     self.loan_path_to_string(&lp),\n-                                    err.cmt.mutbl.to_user_str())\n+                                    err.cmt.mutbl.to_user_str()).into()\n                         }\n                         (Some(lp), false) => {\n                             format!(\"{} {} `{}`\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_string(&err.cmt),\n-                                    self.loan_path_to_string(&lp))\n+                                    self.cmt_to_cow_str(&err.cmt),\n+                                    self.loan_path_to_string(&lp)).into()\n                         }\n                     }\n                 };\n@@ -1058,11 +1059,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(err.cmt);\n                 let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n-                let descr = match opt_loan_path(&err.cmt) {\n+                let descr: Cow<'static, str> = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&lp)).into()\n                     }\n-                    None => self.cmt_to_string(&err.cmt),\n+                    None => self.cmt_to_cow_str(&err.cmt)\n                 };\n                 self.tcx.note_and_explain_region(\n                     &self.region_scope_tree,\n@@ -1477,14 +1478,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         result\n     }\n \n-    pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n+    pub fn cmt_to_cow_str(&self, cmt: &mc::cmt_<'tcx>) -> Cow<'static, str> {\n         cmt.descriptive_string(self.tcx)\n     }\n \n     pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         match opt_loan_path(cmt) {\n             Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n-            None => self.cmt_to_string(cmt),\n+            None => self.cmt_to_cow_str(cmt).into_owned(),\n         }\n     }\n }"}]}