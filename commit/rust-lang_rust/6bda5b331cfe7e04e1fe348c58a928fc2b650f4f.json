{"sha": "6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "node_id": "C_kwDOAAsO6NoAKDZiZGE1YjMzMWNmZTdlMDRlMWZlMzQ4YzU4YTkyOGZjMmI2NTBmNGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-12T17:28:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-12T17:28:52Z"}, "message": "Auto merge of #90716 - euclio:libloading, r=cjgillot\n\nreplace dynamic library module with libloading\n\nThis PR deletes the `rustc_metadata::dynamic_lib` module in favor of the popular and better tested [`libloading` crate](https://github.com/nagisa/rust_libloading/).\n\nWe don't benefit from `libloading`'s symbol lifetimes since we end up leaking the loaded library in all cases, but the call-sites look much nicer by improving error handling and abstracting away some transmutes. We also can remove `rustc_metadata`'s direct dependencies on `libc` and `winapi`.\n\nThis PR also adds an exception for `libloading` (and its license) to tidy, so this will need sign-off from the compiler team.", "tree": {"sha": "fa337d4fa5d7143dfe8fc6aed1b3c77fd287af74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa337d4fa5d7143dfe8fc6aed1b3c77fd287af74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "html_url": "https://github.com/rust-lang/rust/commit/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "753e569c9c2a4e3ef394ef7abd0802bf57f66bce", "url": "https://api.github.com/repos/rust-lang/rust/commits/753e569c9c2a4e3ef394ef7abd0802bf57f66bce", "html_url": "https://github.com/rust-lang/rust/commit/753e569c9c2a4e3ef394ef7abd0802bf57f66bce"}, {"sha": "923f939791a08d3f58566b0fc755381de031f43e", "url": "https://api.github.com/repos/rust-lang/rust/commits/923f939791a08d3f58566b0fc755381de031f43e", "html_url": "https://github.com/rust-lang/rust/commit/923f939791a08d3f58566b0fc755381de031f43e"}], "stats": {"total": 404, "additions": 91, "deletions": 313}, "files": [{"sha": "3cee22dedee72cf26caa9f7ba47255369ae1f9f3", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1926,6 +1926,16 @@ dependencies = [\n  \"pkg-config\",\n ]\n \n+[[package]]\n+name = \"libloading\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0cf036d15402bea3c5d4de17b3fce76b3e4a56ebc1f577be0e7a72f7c607cf0\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"libm\"\n version = \"0.1.4\"\n@@ -3694,6 +3704,7 @@ dependencies = [\n  \"bitflags\",\n  \"cstr\",\n  \"libc\",\n+ \"libloading\",\n  \"measureme 10.0.0\",\n  \"rustc-demangle\",\n  \"rustc_arena\",\n@@ -3978,6 +3989,7 @@ name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n+ \"libloading\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_ast\",\n@@ -4090,7 +4102,7 @@ dependencies = [\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n- \"libc\",\n+ \"libloading\",\n  \"odht\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -4110,7 +4122,6 @@ dependencies = [\n  \"smallvec\",\n  \"snap\",\n  \"tracing\",\n- \"winapi\",\n ]\n \n [[package]]\n@@ -4283,6 +4294,7 @@ dependencies = [\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n+ \"libloading\",\n  \"rustc_ast\",\n  \"rustc_errors\",\n  \"rustc_hir\","}, {"sha": "3b410c2cb4a7ec629bf133d0cc13c2e6e4d0c8af", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -11,6 +11,7 @@ doctest = false\n bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n+libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "79a261244d3ffddeeb8bd6617414d229e383dfca", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1,9 +1,9 @@\n use crate::back::write::create_informational_target_machine;\n use crate::{llvm, llvm_util};\n use libc::c_int;\n+use libloading::Library;\n use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc_middle::bug;\n use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n@@ -13,7 +13,6 @@ use std::ffi::{CStr, CString};\n use tracing::debug;\n \n use std::mem;\n-use std::path::Path;\n use std::ptr;\n use std::slice;\n use std::str;\n@@ -120,14 +119,14 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n+    // Register LLVM plugins by loading them into the compiler process.\n     for plugin in &sess.opts.debugging_opts.llvm_plugins {\n-        let path = Path::new(plugin);\n-        let res = DynamicLibrary::open(path);\n-        match res {\n-            Ok(_) => debug!(\"LLVM plugin loaded succesfully {} ({})\", path.display(), plugin),\n-            Err(e) => bug!(\"couldn't load plugin: {}\", e),\n-        }\n-        mem::forget(res);\n+        let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n+        debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n+\n+        // Intentionally leak the dynamic library. We can't ever unload it\n+        // since the library can make things that will live arbitrarily long.\n+        mem::forget(lib);\n     }\n \n     rustc_llvm::initialize_available_targets();"}, {"sha": "f5823e521b9e67d6c9453287994ae5b1689e1dca", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -8,6 +8,7 @@ doctest = false\n \n [dependencies]\n libc = \"0.2\"\n+libloading = \"0.7.1\"\n tracing = \"0.1\"\n rustc-rayon-core = \"0.3.1\"\n rayon = { version = \"0.3.1\", package = \"rustc-rayon\" }"}, {"sha": "b04f91634cc267e1b16984d5d39da9ac027e26bf", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1,3 +1,4 @@\n+use libloading::Library;\n use rustc_ast::mut_visit::{visit_clobber, MutVisitor, *};\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode};\n@@ -7,7 +8,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::jobserver;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::registry::Registry;\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n #[cfg(parallel_compiler)]\n use rustc_middle::ty::tls;\n use rustc_parse::validate_attr;\n@@ -39,6 +39,9 @@ use std::sync::{Arc, Mutex};\n use std::thread;\n use tracing::info;\n \n+/// Function pointer type that constructs a new CodegenBackend.\n+pub type MakeBackendFn = fn() -> Box<dyn CodegenBackend>;\n+\n /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n@@ -211,28 +214,24 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     })\n }\n \n-fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n-    let lib = DynamicLibrary::open(path).unwrap_or_else(|err| {\n-        let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n+fn load_backend_from_dylib(path: &Path) -> MakeBackendFn {\n+    let lib = unsafe { Library::new(path) }.unwrap_or_else(|err| {\n+        let err = format!(\"couldn't load codegen backend {:?}: {}\", path, err);\n         early_error(ErrorOutputType::default(), &err);\n     });\n-    unsafe {\n-        match lib.symbol(\"__rustc_codegen_backend\") {\n-            Ok(f) => {\n-                mem::forget(lib);\n-                mem::transmute::<*mut u8, _>(f)\n-            }\n-            Err(e) => {\n-                let err = format!(\n-                    \"couldn't load codegen backend as it \\\n-                                   doesn't export the `__rustc_codegen_backend` \\\n-                                   symbol: {:?}\",\n-                    e\n-                );\n-                early_error(ErrorOutputType::default(), &err);\n-            }\n-        }\n-    }\n+\n+    let backend_sym = unsafe { lib.get::<MakeBackendFn>(b\"__rustc_codegen_backend\") }\n+        .unwrap_or_else(|e| {\n+            let err = format!(\"couldn't load codegen backend: {}\", e);\n+            early_error(ErrorOutputType::default(), &err);\n+        });\n+\n+    // Intentionally leak the dynamic library. We can't ever unload it\n+    // since the library can make things that will live arbitrarily long.\n+    let backend_sym = unsafe { backend_sym.into_raw() };\n+    mem::forget(lib);\n+\n+    *backend_sym\n }\n \n /// Get the codegen backend based on the name and specified sysroot.\n@@ -380,10 +379,7 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n     }\n }\n \n-pub fn get_codegen_sysroot(\n-    maybe_sysroot: &Option<PathBuf>,\n-    backend_name: &str,\n-) -> fn() -> Box<dyn CodegenBackend> {\n+pub fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> MakeBackendFn {\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In\n     // general this assertion never trips due to the once guard in `get_codegen_backend`,"}, {"sha": "59796dd6529435c4cd3f1f6c64788ff5980b4348", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-libc = \"0.2\"\n+libloading = \"0.7.1\"\n odht = { version = \"0.3.1\", features = [\"nightly\"] }\n snap = \"1\"\n tracing = \"0.1\"\n@@ -27,6 +27,3 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_expand = { path = \"../rustc_expand\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_session = { path = \"../rustc_session\" }\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"libloaderapi\"] }"}, {"sha": "e304682a2d4e304cf28840572c6df274fdc343c2", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1,6 +1,5 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::dynamic_lib::DynamicLibrary;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -676,25 +675,19 @@ impl<'a> CrateLoader<'a> {\n     ) -> Result<&'static [ProcMacro], CrateError> {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n-        let lib = match DynamicLibrary::open(&path) {\n-            Ok(lib) => lib,\n-            Err(s) => return Err(CrateError::DlOpen(s)),\n-        };\n+        let lib = unsafe { libloading::Library::new(path) }\n+            .map_err(|err| CrateError::DlOpen(err.to_string()))?;\n \n-        let sym = self.sess.generate_proc_macro_decls_symbol(stable_crate_id);\n-        let decls = unsafe {\n-            let sym = match lib.symbol(&sym) {\n-                Ok(f) => f,\n-                Err(s) => return Err(CrateError::DlSym(s)),\n-            };\n-            *(sym as *const &[ProcMacro])\n-        };\n+        let sym_name = self.sess.generate_proc_macro_decls_symbol(stable_crate_id);\n+        let sym = unsafe { lib.get::<*const &[ProcMacro]>(sym_name.as_bytes()) }\n+            .map_err(|err| CrateError::DlSym(err.to_string()))?;\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n+        let sym = unsafe { sym.into_raw() };\n         std::mem::forget(lib);\n \n-        Ok(decls)\n+        Ok(unsafe { **sym })\n     }\n \n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {"}, {"sha": "e8929cd5c0237b91eff421c617c40c3683e5d363", "filename": "compiler/rustc_metadata/src/dynamic_lib.rs", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs?ref=753e569c9c2a4e3ef394ef7abd0802bf57f66bce", "patch": "@@ -1,194 +0,0 @@\n-//! Dynamic library facilities.\n-//!\n-//! A simple wrapper over the platform's dynamic library facilities\n-\n-use std::ffi::CString;\n-use std::path::Path;\n-\n-pub struct DynamicLibrary {\n-    handle: *mut u8,\n-}\n-\n-impl Drop for DynamicLibrary {\n-    fn drop(&mut self) {\n-        unsafe { dl::close(self.handle) }\n-    }\n-}\n-\n-impl DynamicLibrary {\n-    /// Lazily open a dynamic library.\n-    pub fn open(filename: &Path) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open(filename.as_os_str());\n-\n-        // The dynamic library must not be constructed if there is\n-        // an error opening the library so the destructor does not\n-        // run.\n-        match maybe_library {\n-            Err(err) => Err(err),\n-            Ok(handle) => Ok(DynamicLibrary { handle }),\n-        }\n-    }\n-\n-    /// Accesses the value at the symbol of the dynamic library.\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n-        // This function should have a lifetime constraint of 'a on\n-        // T but that feature is still unimplemented\n-\n-        let raw_string = CString::new(symbol).unwrap();\n-        let maybe_symbol_value = dl::symbol(self.handle, raw_string.as_ptr());\n-\n-        // The value must not be constructed if there is an error so\n-        // the destructor does not run.\n-        match maybe_symbol_value {\n-            Err(err) => Err(err),\n-            Ok(symbol_value) => Ok(symbol_value as *mut T),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;\n-\n-#[cfg(unix)]\n-mod dl {\n-    use std::ffi::{CString, OsStr};\n-    use std::os::unix::prelude::*;\n-\n-    // As of the 2017 revision of the POSIX standard (IEEE 1003.1-2017), it is\n-    // implementation-defined whether `dlerror` is thread-safe (in which case it returns the most\n-    // recent error in the calling thread) or not thread-safe (in which case it returns the most\n-    // recent error in *any* thread).\n-    //\n-    // There's no easy way to tell what strategy is used by a given POSIX implementation, so we\n-    // lock around all calls that can modify `dlerror` in this module lest we accidentally read an\n-    // error from a different thread. This is bulletproof when we are the *only* code using the\n-    // dynamic library APIs at a given point in time. However, it's still possible for us to race\n-    // with other code (see #74469) on platforms where `dlerror` is not thread-safe.\n-    mod error {\n-        use std::ffi::CStr;\n-        use std::lazy::SyncLazy;\n-        use std::sync::{Mutex, MutexGuard};\n-\n-        pub fn lock() -> MutexGuard<'static, Guard> {\n-            static LOCK: SyncLazy<Mutex<Guard>> = SyncLazy::new(|| Mutex::new(Guard));\n-            LOCK.lock().unwrap()\n-        }\n-\n-        #[non_exhaustive]\n-        pub struct Guard;\n-\n-        impl Guard {\n-            pub fn get(&mut self) -> Result<(), String> {\n-                let msg = unsafe { libc::dlerror() };\n-                if msg.is_null() {\n-                    Ok(())\n-                } else {\n-                    let msg = unsafe { CStr::from_ptr(msg as *const _) };\n-                    Err(msg.to_string_lossy().into_owned())\n-                }\n-            }\n-\n-            pub fn clear(&mut self) {\n-                let _ = unsafe { libc::dlerror() };\n-            }\n-        }\n-    }\n-\n-    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n-        let s = CString::new(filename.as_bytes()).unwrap();\n-\n-        let mut dlerror = error::lock();\n-        let ret = unsafe { libc::dlopen(s.as_ptr(), libc::RTLD_LAZY | libc::RTLD_LOCAL) };\n-\n-        if !ret.is_null() {\n-            return Ok(ret.cast());\n-        }\n-\n-        // A null return from `dlopen` indicates that an error has definitely occurred, so if\n-        // nothing is in `dlerror`, we are racing with another thread that has stolen our error\n-        // message. See the explanation on the `dl::error` module for more information.\n-        dlerror.get().and_then(|()| Err(\"Unknown error\".to_string()))\n-    }\n-\n-    pub(super) unsafe fn symbol(\n-        handle: *mut u8,\n-        symbol: *const libc::c_char,\n-    ) -> Result<*mut u8, String> {\n-        let mut dlerror = error::lock();\n-\n-        // Unlike `dlopen`, it's possible for `dlsym` to return null without overwriting `dlerror`.\n-        // Because of this, we clear `dlerror` before calling `dlsym` to avoid picking up a stale\n-        // error message by accident.\n-        dlerror.clear();\n-\n-        let ret = libc::dlsym(handle as *mut libc::c_void, symbol);\n-\n-        if !ret.is_null() {\n-            return Ok(ret.cast());\n-        }\n-\n-        // If `dlsym` returns null but there is nothing in `dlerror` it means one of two things:\n-        // - We tried to load a symbol mapped to address 0. This is not technically an error but is\n-        //   unlikely to occur in practice and equally unlikely to be handled correctly by calling\n-        //   code. Therefore we treat it as an error anyway.\n-        // - An error has occurred, but we are racing with another thread that has stolen our error\n-        //   message. See the explanation on the `dl::error` module for more information.\n-        dlerror.get().and_then(|()| Err(\"Tried to load symbol mapped to address 0\".to_string()))\n-    }\n-\n-    pub(super) unsafe fn close(handle: *mut u8) {\n-        libc::dlclose(handle as *mut libc::c_void);\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod dl {\n-    use std::ffi::OsStr;\n-    use std::io;\n-    use std::os::windows::prelude::*;\n-    use std::ptr;\n-\n-    use winapi::shared::minwindef::HMODULE;\n-    use winapi::um::errhandlingapi::SetThreadErrorMode;\n-    use winapi::um::libloaderapi::{FreeLibrary, GetProcAddress, LoadLibraryW};\n-    use winapi::um::winbase::SEM_FAILCRITICALERRORS;\n-\n-    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n-        // disable \"dll load failed\" error dialog.\n-        let prev_error_mode = unsafe {\n-            let new_error_mode = SEM_FAILCRITICALERRORS;\n-            let mut prev_error_mode = 0;\n-            let result = SetThreadErrorMode(new_error_mode, &mut prev_error_mode);\n-            if result == 0 {\n-                return Err(io::Error::last_os_error().to_string());\n-            }\n-            prev_error_mode\n-        };\n-\n-        let filename_str: Vec<_> = filename.encode_wide().chain(Some(0)).collect();\n-        let result = unsafe { LoadLibraryW(filename_str.as_ptr()) } as *mut u8;\n-        let result = ptr_result(result);\n-\n-        unsafe {\n-            SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n-        }\n-\n-        result\n-    }\n-\n-    pub(super) unsafe fn symbol(\n-        handle: *mut u8,\n-        symbol: *const libc::c_char,\n-    ) -> Result<*mut u8, String> {\n-        let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n-        ptr_result(ptr)\n-    }\n-\n-    pub(super) unsafe fn close(handle: *mut u8) {\n-        FreeLibrary(handle as HMODULE);\n-    }\n-\n-    fn ptr_result<T>(ptr: *mut T) -> Result<*mut T, String> {\n-        if ptr.is_null() { Err(io::Error::last_os_error().to_string()) } else { Ok(ptr) }\n-    }\n-}"}, {"sha": "7090bbf61c794747cf0d57d9f54da91c77069733", "filename": "compiler/rustc_metadata/src/dynamic_lib/tests.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib%2Ftests.rs?ref=753e569c9c2a4e3ef394ef7abd0802bf57f66bce", "patch": "@@ -1,18 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_errors_do_not_crash() {\n-    use std::path::Path;\n-\n-    if !cfg!(unix) {\n-        return;\n-    }\n-\n-    // Open /dev/null as a library to get an error, and make sure\n-    // that only causes an error, and not a crash.\n-    let path = Path::new(\"/dev/null\");\n-    match DynamicLibrary::open(&path) {\n-        Err(_) => {}\n-        Ok(_) => panic!(\"Successfully opened the empty library.\"),\n-    }\n-}"}, {"sha": "0bf6c266b80e02024beccb34abf5fb9a55df113c", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -28,7 +28,6 @@ mod native_libs;\n mod rmeta;\n \n pub mod creader;\n-pub mod dynamic_lib;\n pub mod locator;\n \n pub use rmeta::{encode_metadata, EncodedMetadata, METADATA_HEADER};"}, {"sha": "f5071eb6e8f9657c842077b498a00eec82f9135d", "filename": "compiler/rustc_plugin_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_plugin_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_plugin_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2FCargo.toml?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -8,6 +8,7 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n+libloading = \"0.7.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "618682da4e5972d9b830f2025335635bd1ac39b6", "filename": "compiler/rustc_plugin_impl/src/load.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1,6 +1,7 @@\n //! Used by `rustc` when loading a plugin.\n \n use crate::Registry;\n+use libloading::Library;\n use rustc_ast::Crate;\n use rustc_errors::struct_span_err;\n use rustc_metadata::locator;\n@@ -56,37 +57,28 @@ fn load_plugin(\n     ident: Ident,\n ) {\n     let lib = locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n-    let fun = dylink_registrar(sess, ident.span, lib);\n+    let fun = dylink_registrar(lib).unwrap_or_else(|err| {\n+        // This is fatal: there are almost certainly macros we need inside this crate, so\n+        // continuing would spew \"macro undefined\" errors.\n+        sess.span_fatal(ident.span, &err.to_string());\n+    });\n     plugins.push(fun);\n }\n \n-// Dynamically link a registrar function into the compiler process.\n-fn dylink_registrar(sess: &Session, span: Span, path: PathBuf) -> PluginRegistrarFn {\n-    use rustc_metadata::dynamic_lib::DynamicLibrary;\n-\n+/// Dynamically link a registrar function into the compiler process.\n+fn dylink_registrar(lib_path: PathBuf) -> Result<PluginRegistrarFn, libloading::Error> {\n     // Make sure the path contains a / or the linker will search for it.\n-    let path = env::current_dir().unwrap().join(&path);\n+    let lib_path = env::current_dir().unwrap().join(&lib_path);\n \n-    let lib = match DynamicLibrary::open(&path) {\n-        Ok(lib) => lib,\n-        // this is fatal: there are almost certainly macros we need\n-        // inside this crate, so continue would spew \"macro undefined\"\n-        // errors\n-        Err(err) => sess.span_fatal(span, &err),\n-    };\n+    let lib = unsafe { Library::new(&lib_path) }?;\n \n-    unsafe {\n-        let registrar = match lib.symbol(\"__rustc_plugin_registrar\") {\n-            Ok(registrar) => mem::transmute::<*mut u8, PluginRegistrarFn>(registrar),\n-            // again fatal if we can't register macros\n-            Err(err) => sess.span_fatal(span, &err),\n-        };\n+    let registrar_sym = unsafe { lib.get::<PluginRegistrarFn>(b\"__rustc_plugin_registrar\") }?;\n \n-        // Intentionally leak the dynamic library. We can't ever unload it\n-        // since the library can make things that will live arbitrarily long\n-        // (e.g., an Rc cycle or a thread).\n-        mem::forget(lib);\n+    // Intentionally leak the dynamic library. We can't ever unload it\n+    // since the library can make things that will live arbitrarily long\n+    // (e.g., an Rc cycle or a thread).\n+    let registrar_sym = unsafe { registrar_sym.into_raw() };\n+    mem::forget(lib);\n \n-        registrar\n-    }\n+    Ok(*registrar_sym)\n }"}, {"sha": "9231a2b3574db8b490d533c25c5360adb91637e9", "filename": "src/test/run-make-fulldeps/extern-fn-reachable/Makefile", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2FMakefile?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -1,9 +1,25 @@\n -include ../tools.mk\n \n+# ignore-windows-msvc\n+\n+NM=nm -D\n+\n+ifeq ($(UNAME),Darwin)\n+NM=nm -gU\n+endif\n+\n+ifdef IS_WINDOWS\n+NM=nm -g\n+endif\n+\n # This overrides the LD_LIBRARY_PATH for RUN\n TARGET_RPATH_DIR:=$(TARGET_RPATH_DIR):$(TMPDIR)\n \n all:\n \t$(RUSTC) dylib.rs -o $(TMPDIR)/libdylib.so -C prefer-dynamic\n-\t$(RUSTC) main.rs -C prefer-dynamic\n-\t$(call RUN,main)\n+\n+\t[ \"$$($(NM) $(TMPDIR)/libdylib.so | grep -v __imp_ | grep -c fun1)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/libdylib.so | grep -v __imp_ | grep -c fun2)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/libdylib.so | grep -v __imp_ | grep -c fun3)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/libdylib.so | grep -v __imp_ | grep -c fun4)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/libdylib.so | grep -v __imp_ | grep -c fun5)\" -eq \"1\" ]"}, {"sha": "c1de6477585851296f8d535f682d61f24d75b1b5", "filename": "src/test/run-make-fulldeps/extern-fn-reachable/main.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753e569c9c2a4e3ef394ef7abd0802bf57f66bce/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs?ref=753e569c9c2a4e3ef394ef7abd0802bf57f66bce", "patch": "@@ -1,18 +0,0 @@\n-#![feature(rustc_private)]\n-\n-extern crate rustc_metadata;\n-\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n-use std::path::Path;\n-\n-pub fn main() {\n-    unsafe {\n-        let path = Path::new(\"libdylib.so\");\n-        let a = DynamicLibrary::open(&path).unwrap();\n-        assert!(a.symbol::<isize>(\"fun1\").is_ok());\n-        assert!(a.symbol::<isize>(\"fun2\").is_ok());\n-        assert!(a.symbol::<isize>(\"fun3\").is_ok());\n-        assert!(a.symbol::<isize>(\"fun4\").is_ok());\n-        assert!(a.symbol::<isize>(\"fun5\").is_ok());\n-    }\n-}"}, {"sha": "d27afa497f6957c2174a23d41df8dbabbe4adcfa", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bda5b331cfe7e04e1fe348c58a928fc2b650f4f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=6bda5b331cfe7e04e1fe348c58a928fc2b650f4f", "patch": "@@ -15,6 +15,7 @@ const LICENSES: &[&str] = &[\n     \"Apache-2.0 OR MIT\",\n     \"Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT\", // wasi license\n     \"MIT\",\n+    \"ISC\",\n     \"Unlicense/MIT\",\n     \"Unlicense OR MIT\",\n     \"0BSD OR MIT OR Apache-2.0\", // adler license\n@@ -53,7 +54,6 @@ const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n     (\"cranelift-module\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-native\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-object\", \"Apache-2.0 WITH LLVM-exception\"),\n-    (\"libloading\", \"ISC\"),\n     (\"mach\", \"BSD-2-Clause\"),\n     (\"regalloc\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"target-lexicon\", \"Apache-2.0 WITH LLVM-exception\"),\n@@ -129,6 +129,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"jobserver\",\n     \"lazy_static\",\n     \"libc\",\n+    \"libloading\",\n     \"libz-sys\",\n     \"lock_api\",\n     \"log\","}]}