{"sha": "cae5999a542fc391e9764ca181f6ac39beec06cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTU5OTlhNTQyZmMzOTFlOTc2NGNhMTgxZjZhYzM5YmVlYzA2Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T03:26:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T03:26:50Z"}, "message": "auto merge of #12317 : huonw/rust/utf16, r=alexcrichton\n\nIterators! Use them (in `is_utf16`), create them (in `utf16_items`).\r\n\r\nHandle errors gracefully (`from_utf16_lossy`) and `from_utf16` returning `Option<~str>` instead of failing.\r\n\r\nAdd a pile of tests.", "tree": {"sha": "7967b6c7873af7e70c4ed781db376fddca9e6aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7967b6c7873af7e70c4ed781db376fddca9e6aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae5999a542fc391e9764ca181f6ac39beec06cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae5999a542fc391e9764ca181f6ac39beec06cb", "html_url": "https://github.com/rust-lang/rust/commit/cae5999a542fc391e9764ca181f6ac39beec06cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae5999a542fc391e9764ca181f6ac39beec06cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25f44783546333e90b88f5af798fda692de7324", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25f44783546333e90b88f5af798fda692de7324", "html_url": "https://github.com/rust-lang/rust/commit/a25f44783546333e90b88f5af798fda692de7324"}, {"sha": "c9b4538babbc85b971b19bbeff16bd12a4f4db54", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b4538babbc85b971b19bbeff16bd12a4f4db54", "html_url": "https://github.com/rust-lang/rust/commit/c9b4538babbc85b971b19bbeff16bd12a4f4db54"}], "stats": {"total": 359, "additions": 308, "deletions": 51}, "files": [{"sha": "6d3a156a2b01a9711e0e7a71136ebfe3cbe9bf0b", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=cae5999a542fc391e9764ca181f6ac39beec06cb", "patch": "@@ -571,7 +571,9 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                         else {\n                             let fp_vec = vec::from_buf(\n                                 fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_str = str::from_utf16(fp_vec);\n+                            let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n+                            let fp_str = str::from_utf16(fp_trimmed)\n+                                    .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n                             paths.push(Path::new(fp_str));\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);"}, {"sha": "74e2fceb6cae6d7854a93db3eb2f36a91fd3f6a5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cae5999a542fc391e9764ca181f6ac39beec06cb", "patch": "@@ -88,7 +88,8 @@ pub fn getcwd() -> Path {\n             fail!();\n         }\n     }\n-    Path::new(str::from_utf16(buf))\n+    Path::new(str::from_utf16(str::truncate_utf16_at_nul(buf))\n+              .expect(\"GetCurrentDirectoryW returned invalid UTF-16\"))\n }\n \n #[cfg(windows)]\n@@ -124,7 +125,12 @@ pub mod win32 {\n                 }\n                 if k != 0 && done {\n                     let sub = buf.slice(0, k as uint);\n-                    res = option::Some(str::from_utf16(sub));\n+                    // We want to explicitly catch the case when the\n+                    // closure returned invalid UTF-16, rather than\n+                    // set `res` to None and continue.\n+                    let s = str::from_utf16(sub)\n+                        .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n+                    res = option::Some(s)\n                 }\n             }\n             return res;\n@@ -739,7 +745,8 @@ pub fn last_os_error() -> ~str {\n                 fail!(\"[{}] FormatMessage failure\", errno());\n             }\n \n-            str::from_utf16(buf)\n+            str::from_utf16(str::truncate_utf16_at_nul(buf))\n+                .expect(\"FormatMessageW returned invalid UTF-16\")\n         }\n     }\n \n@@ -828,8 +835,10 @@ fn real_args() -> ~[~str] {\n             while *ptr.offset(len as int) != 0 { len += 1; }\n \n             // Push it onto the list.\n-            args.push(vec::raw::buf_as_slice(ptr, len,\n-                                             str::from_utf16));\n+            let opt_s = vec::raw::buf_as_slice(ptr, len, |buf| {\n+                    str::from_utf16(str::truncate_utf16_at_nul(buf))\n+                });\n+            args.push(opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\"));\n         }\n     }\n "}, {"sha": "2ac3a9817872e24b0b08452cd90e9d245cf45350", "filename": "src/libstd/str.rs", "status": "modified", "additions": 291, "deletions": 45, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae5999a542fc391e9764ca181f6ac39beec06cb/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cae5999a542fc391e9764ca181f6ac39beec06cb", "patch": "@@ -830,60 +830,192 @@ fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n \n /// Determines if a vector of `u16` contains valid UTF-16\n pub fn is_utf16(v: &[u16]) -> bool {\n-    let len = v.len();\n-    let mut i = 0u;\n-    while i < len {\n-        let u = v[i];\n+    let mut it = v.iter();\n+    macro_rules! next ( ($ret:expr) => {\n+            match it.next() { Some(u) => *u, None => return $ret }\n+        }\n+    )\n+    loop {\n+        let u = next!(true);\n \n-        if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n-            i += 1u;\n+        match char::from_u32(u as u32) {\n+            Some(_) => {}\n+            None => {\n+                let u2 = next!(false);\n+                if u < 0xD7FF || u > 0xDBFF ||\n+                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from a vector\n+/// of `u16`s.\n+#[deriving(Clone)]\n+pub struct UTF16Items<'a> {\n+    priv iter: vec::Items<'a, u16>\n+}\n+/// The possibilities for values decoded from a `u16` stream.\n+#[deriving(Eq, TotalEq, Clone)]\n+pub enum UTF16Item {\n+    /// A valid codepoint.\n+    ScalarValue(char),\n+    /// An invalid surrogate without its pair.\n+    LoneSurrogate(u16)\n+}\n+\n+impl UTF16Item {\n+    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n+    /// replacement character (U+FFFD).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        match *self {\n+            ScalarValue(c) => c,\n+            LoneSurrogate(_) => '\\uFFFD'\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n+    fn next(&mut self) -> Option<UTF16Item> {\n+        let u = match self.iter.next() {\n+            Some(u) => *u,\n+            None => return None\n+        };\n \n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(LoneSurrogate(u))\n         } else {\n-            if i+1u < len { return false; }\n-            let u2 = v[i+1u];\n-            if u < 0xD7FF_u16 || u > 0xDBFF_u16 { return false; }\n-            if u2 < 0xDC00_u16 || u2 > 0xDFFF_u16 { return false; }\n-            i += 2u;\n+            // preserve state for rewinding.\n+            let old = self.iter;\n+\n+            let u2 = match self.iter.next() {\n+                Some(u2) => *u2,\n+                // eof\n+                None => return Some(LoneSurrogate(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.iter = old;\n+                return Some(LoneSurrogate(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(ScalarValue(unsafe {cast::transmute(c)}))\n         }\n     }\n-    return true;\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n }\n \n-/// Iterates over the utf-16 characters in the specified slice, yielding each\n-/// decoded unicode character to the function provided.\n+/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n+/// returning invalid surrogates as `LoneSurrogate`s.\n ///\n-/// # Failures\n+/// # Example\n ///\n-/// * Fails on invalid utf-16 data\n-pub fn utf16_chars(v: &[u16], f: |char|) {\n-    let len = v.len();\n-    let mut i = 0u;\n-    while i < len && v[i] != 0u16 {\n-        let u = v[i];\n-\n-        if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n-            f(unsafe { cast::transmute(u as u32) });\n-            i += 1u;\n+/// ```rust\n+/// use std::str;\n+/// use std::str::{ScalarValue, LoneSurrogate};\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::utf16_items(v).to_owned_vec(),\n+///            ~[ScalarValue('\ud834\udd1e'),\n+///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///              LoneSurrogate(0xDD1E),\n+///              ScalarValue('i'), ScalarValue('c'),\n+///              LoneSurrogate(0xD834)]);\n+/// ```\n+pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n+    UTF16Items { iter : v.iter() }\n+}\n \n-        } else {\n-            let u2 = v[i+1u];\n-            assert!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n-            assert!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n-            let mut c: u32 = (u - 0xD800_u16) as u32;\n-            c = c << 10;\n-            c |= (u2 - 0xDC00_u16) as u32;\n-            c |= 0x1_0000_u32;\n-            f(unsafe { cast::transmute(c) });\n-            i += 2u;\n+/// Return a slice of `v` ending at (and not including) the first NUL\n+/// (0).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \"abcd\"\n+/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n+/// // no NULs so no change\n+/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n+///\n+/// // \"ab\\0d\"\n+/// v[2] = 0;\n+/// assert_eq!(str::truncate_utf16_at_nul(v),\n+///            &['a' as u16, 'b' as u16]);\n+/// ```\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => v.slice_to(i),\n+        None => v\n+    }\n+}\n+\n+/// Decode a UTF-16 encoded vector `v` into a string, returning `None`\n+/// if `v` contains any invalid data.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \ud834\udd1emusic\n+/// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0x0069, 0x0063];\n+/// assert_eq!(str::from_utf16(v), Some(~\"\ud834\udd1emusic\"));\n+///\n+/// // \ud834\udd1emu<invalid>ic\n+/// v[4] = 0xD800;\n+/// assert_eq!(str::from_utf16(v), None);\n+/// ```\n+pub fn from_utf16(v: &[u16]) -> Option<~str> {\n+    let mut s = with_capacity(v.len() / 2);\n+    for c in utf16_items(v) {\n+        match c {\n+            ScalarValue(c) => s.push_char(c),\n+            LoneSurrogate(_) => return None\n         }\n     }\n+    Some(s)\n }\n \n-/// Allocates a new string from the utf-16 slice provided\n-pub fn from_utf16(v: &[u16]) -> ~str {\n-    let mut buf = with_capacity(v.len());\n-    utf16_chars(v, |ch| buf.push_char(ch));\n-    buf\n+/// Decode a UTF-16 encoded vector `v` into a string, replacing\n+/// invalid data with the replacement character (U+FFFD).\n+///\n+/// # Example\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::from_utf16_lossy(v),\n+///            ~\"\ud834\udd1emus\\uFFFDic\\uFFFD\");\n+/// ```\n+pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n+    utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n /// Allocates a new string with the specified capacity. The string returned is\n@@ -3536,6 +3668,65 @@ mod tests {\n         assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n+    #[test]\n+    fn test_is_utf16() {\n+        macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n+\n+        // non-surrogates\n+        pos!([0x0000],\n+             [0x0001, 0x0002],\n+             [0xD7FF],\n+             [0xE000]);\n+\n+        // surrogate pairs (randomly generated with Python 3's\n+        // .encode('utf-16be'))\n+        pos!([0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n+             [0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n+             [0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n+\n+        // mixtures (also random)\n+        pos!([0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n+             [0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n+             [0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n+\n+        // negative tests\n+        macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n+\n+        neg!(\n+            // surrogate + regular unit\n+            [0xdb45, 0x0000],\n+            // surrogate + lead surrogate\n+            [0xd900, 0xd900],\n+            // unterminated surrogate\n+            [0xd8ff],\n+            // trail surrogate without a lead\n+            [0xddb7]);\n+\n+        // random byte sequences that Python 3's .decode('utf-16be')\n+        // failed on\n+        neg!([0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n+             [0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n+             [0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n+             [0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n+             [0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n+             [0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n+             [0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n+             [0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n+             [0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n+             [0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n+             [0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n+             [0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n+             [0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n+             [0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n+             [0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n+             [0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n+             [0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n+             [0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n+             [0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n+             [0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n+             [0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n+    }\n+\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n@@ -3687,17 +3878,72 @@ mod tests {\n                 0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n                 0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n-                0x000a_u16 ]) ];\n+                0x000a_u16 ]),\n+             // Issue #12318, even-numbered non-BMP planes\n+             (~\"\\U00020000\",\n+              ~[0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            assert!(s.to_utf16() == u);\n-            assert!(from_utf16(u) == s);\n-            assert!(from_utf16(s.to_utf16()) == s);\n-            assert!(from_utf16(u).to_utf16() == u);\n+            assert!(is_utf16(u));\n+            assert_eq!(s.to_utf16(), u);\n+\n+            assert_eq!(from_utf16(u).unwrap(), s);\n+            assert_eq!(from_utf16_lossy(u), s);\n+\n+            assert_eq!(from_utf16(s.to_utf16()).unwrap(), s);\n+            assert_eq!(from_utf16(u).unwrap().to_utf16(), u);\n         }\n     }\n \n+    #[test]\n+    fn test_utf16_invalid() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(from_utf16([0xD800]), None);\n+        // lead + lead\n+        assert_eq!(from_utf16([0xD800, 0xD800]), None);\n+\n+        // isolated trail\n+        assert_eq!(from_utf16([0x0061, 0xDC00]), None);\n+\n+        // general\n+        assert_eq!(from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+    }\n+\n+    #[test]\n+    fn test_utf16_lossy() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(from_utf16_lossy([0xD800]), ~\"\\uFFFD\");\n+        // lead + lead\n+        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), ~\"\\uFFFD\\uFFFD\");\n+\n+        // isolated trail\n+        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), ~\"a\\uFFFD\");\n+\n+        // general\n+        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]), ~\"\\uFFFD\ud801\udc8b\\uFFFD\");\n+    }\n+\n+    #[test]\n+    fn test_truncate_utf16_at_nul() {\n+        let v = [];\n+        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+\n+        let v = [0, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+\n+        let v = [1, 0, 3];\n+        assert_eq!(truncate_utf16_at_nul(v), &[1]);\n+\n+        let v = [1, 2, 0];\n+        assert_eq!(truncate_utf16_at_nul(v), &[1, 2]);\n+\n+        let v = [1, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(v), &[1, 2, 3]);\n+    }\n+\n     #[test]\n     fn test_char_at() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";"}]}