{"sha": "11057fee08a6de23edbb8cb188336c104b4d25f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMDU3ZmVlMDhhNmRlMjNlZGJiOGNiMTg4MzM2YzEwNGI0ZDI1Zjk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-27T17:16:30Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-03T11:10:58Z"}, "message": "Incorporated first review sugestion from eddyb.\n\nSuggestion was here:\n\n  https://github.com/rust-lang/rust/pull/22532#discussion_r25505609", "tree": {"sha": "333057cd1755ca6f6ada230c8a15d9bc9fe174a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/333057cd1755ca6f6ada230c8a15d9bc9fe174a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11057fee08a6de23edbb8cb188336c104b4d25f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11057fee08a6de23edbb8cb188336c104b4d25f9", "html_url": "https://github.com/rust-lang/rust/commit/11057fee08a6de23edbb8cb188336c104b4d25f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11057fee08a6de23edbb8cb188336c104b4d25f9/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85b3c9b2b018e8dd8685db3217faa72ab82b965", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85b3c9b2b018e8dd8685db3217faa72ab82b965", "html_url": "https://github.com/rust-lang/rust/commit/b85b3c9b2b018e8dd8685db3217faa72ab82b965"}], "stats": {"total": 134, "additions": 34, "deletions": 100}, "files": [{"sha": "f5f0357976634b8f4e3dcc7c0bb157da6c2fb2c9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 34, "deletions": 100, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/11057fee08a6de23edbb8cb188336c104b4d25f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11057fee08a6de23edbb8cb188336c104b4d25f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=11057fee08a6de23edbb8cb188336c104b4d25f9", "patch": "@@ -283,106 +283,40 @@ impl ConstEvalErr {\n     }\n }\n \n-fn invalid_op_for_bools(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForBools(op) }\n-}\n-fn invalid_op_for_floats(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForFloats(op) }\n-}\n-fn invalid_op_for_int_uint(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForIntUint(op) }\n-}\n-fn invalid_op_for_uint_int(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForUintInt(op) }\n-}\n-fn negate_on_string(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NegateOnString }\n-}\n-fn negate_on_boolean(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NegateOnBoolean }\n-}\n-fn not_on_float(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NotOnFloat }\n-}\n-fn not_on_string(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NotOnString }\n-}\n-\n-fn addi_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::AddiWithOverflow(a, b) }\n-}\n-fn subi_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::SubiWithOverflow(a, b) }\n-}\n-fn muli_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::MuliWithOverflow(a, b) }\n-}\n-fn addu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::AdduWithOverflow(a, b) }\n-}\n-fn subu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::SubuWithOverflow(a, b) }\n-}\n-fn mulu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::MuluWithOverflow(a, b) }\n-}\n-fn divide_by_zero(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::DivideByZero }\n-}\n-fn divide_with_overflow(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::DivideWithOverflow }\n-}\n-fn modulo_by_zero(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::ModuloByZero }\n-}\n-fn modulo_with_overflow(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::ModuloWithOverflow }\n-}\n-fn missing_struct_field(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::MissingStructField }\n-}\n-fn non_const_path(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NonConstPath }\n-}\n-fn non_const_struct(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::NonConstStruct }\n-}\n-fn tuple_index_out_of_bounds(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::TupleIndexOutOfBounds }\n-}\n+macro_rules! signal {\n+    ($e:expr, $ctor:ident) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor })\n+    };\n \n-fn misc_binary_op(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::MiscBinaryOp }\n-}\n-fn misc_catch_all(e: &Expr) -> ConstEvalErr {\n-    ConstEvalErr { span: e.span, kind: ErrKind::MiscCatchAll }\n+    ($e:expr, $ctor:ident($($arg:expr),*)) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor($($arg),*) })\n+    }\n }\n \n-\n fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(addi_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, AddiWithOverflow(a, b)) }\n }\n fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(subi_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, SubiWithOverflow(a, b)) }\n }\n fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(muli_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, MuliWithOverflow(a, b)) }\n }\n \n fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(addu_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, AdduWithOverflow(a, b)) }\n }\n fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(subu_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, SubuWithOverflow(a, b)) }\n }\n fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(mulu_with_overflow(e, a, b)) }\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, MuluWithOverflow(a, b)) }\n }\n \n \n@@ -400,8 +334,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(negate_on_string(e)),\n-          Ok(const_bool(_)) => Err(negate_on_boolean(e)),\n+          Ok(const_str(_)) => signal!(e, NegateOnString),\n+          Ok(const_bool(_)) => signal!(e, NegateOnBoolean),\n           err => err\n         }\n       }\n@@ -410,8 +344,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          Ok(const_str(_)) => Err(not_on_string(e)),\n-          Ok(const_float(_)) => Err(not_on_float(e)),\n+          Ok(const_str(_)) => signal!(e, NotOnString),\n+          Ok(const_float(_)) => signal!(e, NotOnFloat),\n           err => err\n         }\n       }\n@@ -435,7 +369,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiNe => fromb(a != b),\n               ast::BiGe => fromb(a >= b),\n               ast::BiGt => fromb(a > b),\n-              _ => Err(invalid_op_for_floats(e, op.node)),\n+              _ => signal!(e, InvalidOpForFloats(op.node))\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n@@ -463,18 +397,18 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiMul => checked_mul_int(e, a, b),\n               ast::BiDiv => {\n                   if b == 0 {\n-                      Err(divide_by_zero(e))\n+                      signal!(e, DivideByZero);\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(divide_with_overflow(e))\n+                      signal!(e, DivideWithOverflow);\n                   } else {\n                       Ok(const_int(a / b))\n                   }\n               }\n               ast::BiRem => {\n                   if b == 0 {\n-                      Err(modulo_by_zero(e))\n+                      signal!(e, ModuloByZero)\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(modulo_with_overflow(e))\n+                      signal!(e, ModuloWithOverflow)\n                   } else {\n                       Ok(const_int(a % b))\n                   }\n@@ -497,9 +431,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiAdd => checked_add_uint(e, a, b),\n               ast::BiSub => checked_sub_uint(e, a, b),\n               ast::BiMul => checked_mul_uint(e, a, b),\n-              ast::BiDiv if b == 0 => Err(divide_by_zero(e)),\n+              ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n               ast::BiDiv => Ok(const_uint(a / b)),\n-              ast::BiRem if b == 0 => Err(modulo_by_zero(e)),\n+              ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n               ast::BiRem => Ok(const_uint(a % b)),\n               ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n               ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n@@ -519,14 +453,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             match op.node {\n               ast::BiShl => Ok(const_int(a << b as uint)),\n               ast::BiShr => Ok(const_int(a >> b as uint)),\n-              _ => Err(invalid_op_for_int_uint(e, op.node)),\n+              _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op.node {\n               ast::BiShl => Ok(const_uint(a << b as uint)),\n               ast::BiShr => Ok(const_uint(a >> b as uint)),\n-              _ => Err(invalid_op_for_uint_int(e, op.node)),\n+              _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n@@ -538,13 +472,13 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiBitOr => a | b,\n               ast::BiEq => a == b,\n               ast::BiNe => a != b,\n-              _ => return Err(invalid_op_for_bools(e, op.node)),\n+              _ => signal!(e, InvalidOpForBools(op.node)),\n              }))\n           }\n           (err @ Err(..), _) |\n           (_, err @ Err(..)) => err,\n \n-          _ => Err(misc_binary_op(e)),\n+          _ => signal!(e, MiscBinaryOp),\n         }\n       }\n       ast::ExprCast(ref base, ref target_ty) => {\n@@ -589,7 +523,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           };\n           let const_expr = match const_expr {\n               Some(actual_e) => actual_e,\n-              None => return Err(non_const_path(e)),\n+              None => signal!(e, NonConstPath)\n           };\n           let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n           eval_const_expr_partial(tcx, const_expr, ety)\n@@ -611,11 +545,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if fields.len() > index.node {\n                 return eval_const_expr_partial(tcx, &*fields[index.node], None)\n             } else {\n-                return Err(tuple_index_out_of_bounds(e))\n+                signal!(e, TupleIndexOutOfBounds);\n             }\n         }\n \n-        Err(non_const_struct(e))\n+        signal!(e, NonConstStruct);\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n@@ -626,13 +560,13 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n                 return eval_const_expr_partial(tcx, &*f.expr, None)\n             } else {\n-                return Err(missing_struct_field(e));\n+                signal!(e, MissingStructField);\n             }\n         }\n \n-        Err(non_const_struct(e))\n+        signal!(e, NonConstStruct);\n       }\n-      _ => Err(misc_catch_all(e))\n+      _ => signal!(e, MiscCatchAll)\n     }\n }\n "}]}