{"sha": "0055678f7a5f49fc5df93a38cc27fea4eb6ae416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNTU2NzhmN2E1ZjQ5ZmM1ZGY5M2EzOGNjMjdmZWE0ZWI2YWU0MTY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-05T21:44:03Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:46Z"}, "message": "libcollections: use unboxed closures in `Bitv` methods", "tree": {"sha": "c0fe851f38756dd54fb9b5a4a8aadd60c7052c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0fe851f38756dd54fb9b5a4a8aadd60c7052c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0055678f7a5f49fc5df93a38cc27fea4eb6ae416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0055678f7a5f49fc5df93a38cc27fea4eb6ae416", "html_url": "https://github.com/rust-lang/rust/commit/0055678f7a5f49fc5df93a38cc27fea4eb6ae416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0055678f7a5f49fc5df93a38cc27fea4eb6ae416/comments", "author": null, "committer": null, "parents": [{"sha": "0d39fc01bf2b105abd323a8f8ebd59b60f2790e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d39fc01bf2b105abd323a8f8ebd59b60f2790e7", "html_url": "https://github.com/rust-lang/rust/commit/0d39fc01bf2b105abd323a8f8ebd59b60f2790e7"}], "stats": {"total": 24, "additions": 16, "deletions": 8}, "files": [{"sha": "a0c4f6e7ee8c7f68629eabf901facffa3a17e7c6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0055678f7a5f49fc5df93a38cc27fea4eb6ae416/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0055678f7a5f49fc5df93a38cc27fea4eb6ae416/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=0055678f7a5f49fc5df93a38cc27fea4eb6ae416", "patch": "@@ -174,7 +174,7 @@ impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n \n impl Bitv {\n     #[inline]\n-    fn process(&mut self, other: &Bitv, op: |u32, u32| -> u32) -> bool {\n+    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         let len = other.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n@@ -816,7 +816,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n /// let bv = from_fn(5, |i| { i % 2 == 0 });\n /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n /// ```\n-pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n+pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n     let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n@@ -1182,7 +1182,7 @@ impl BitvSet {\n     }\n \n     #[inline]\n-    fn other_op(&mut self, other: &BitvSet, f: |u32, u32| -> u32) {\n+    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n         // Expand the vector if necessary\n         self.reserve(other.capacity());\n \n@@ -1277,10 +1277,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 | w2,\n+            merge: or,\n             current_word: 0u32,\n             next_idx: 0u\n         }\n@@ -1306,11 +1308,13 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+        fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n+\n         let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & w2,\n+            merge: bitand,\n             current_word: 0u32,\n             next_idx: 0\n         }.take(min)\n@@ -1343,10 +1347,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & !w2,\n+            merge: diff,\n             current_word: 0u32,\n             next_idx: 0\n         }\n@@ -1373,10 +1379,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 ^ w2,\n+            merge: bitxor,\n             current_word: 0u32,\n             next_idx: 0\n         }\n@@ -1614,7 +1622,7 @@ pub struct BitPositions<'a> {\n pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,\n-    merge: |u32, u32|: 'a -> u32,\n+    merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: uint\n }"}]}