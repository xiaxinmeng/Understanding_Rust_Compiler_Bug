{"sha": "84654fa4bf8e532469787889efa01b59a3c98aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjU0ZmE0YmY4ZTUzMjQ2OTc4Nzg4OWVmYTAxYjU5YTNjOThhYTA=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-04-18T18:08:27Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-04-18T18:08:27Z"}, "message": "Split core::iter module implementation into parts\n\nsplit iter.rs into a directory of (implementation private) modules.\n\n+ mod Adaptor structs\n  - Private fields need to be available both for them and Iterator\n+ iterator (Iterator trait)\n+ traits (FromIterator, traits but Iterator itself)\n+ range (range related)\n+ sources (Repeat, Once, Empty)", "tree": {"sha": "2632a3b3380e0bfd29ebcaa29d7fee8eb471e794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2632a3b3380e0bfd29ebcaa29d7fee8eb471e794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84654fa4bf8e532469787889efa01b59a3c98aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84654fa4bf8e532469787889efa01b59a3c98aa0", "html_url": "https://github.com/rust-lang/rust/commit/84654fa4bf8e532469787889efa01b59a3c98aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84654fa4bf8e532469787889efa01b59a3c98aa0/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63760acf31e605c8a91bb5cbcbcb4bfb95435e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/63760acf31e605c8a91bb5cbcbcb4bfb95435e48", "html_url": "https://github.com/rust-lang/rust/commit/63760acf31e605c8a91bb5cbcbcb4bfb95435e48"}], "stats": {"total": 10122, "additions": 5110, "deletions": 5012}, "files": [{"sha": "69f10d197f74b47ecdde0e50674e5f6d5221c8bc", "filename": "src/libcore/iter.rs", "status": "removed", "additions": 0, "deletions": 5012, "changes": 5012, "blob_url": "https://github.com/rust-lang/rust/blob/63760acf31e605c8a91bb5cbcbcb4bfb95435e48/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63760acf31e605c8a91bb5cbcbcb4bfb95435e48/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=63760acf31e605c8a91bb5cbcbcb4bfb95435e48"}, {"sha": "0cc83d42ce06b715cde525203a452be407169c4a", "filename": "src/libcore/iter/iterator.rs", "status": "added", "additions": 2109, "deletions": 0, "changes": 2109, "blob_url": "https://github.com/rust-lang/rust/blob/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=84654fa4bf8e532469787889efa01b59a3c98aa0", "patch": "@@ -0,0 +1,2109 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n+use default::Default;\n+use marker;\n+use num::{Zero, One};\n+use ops::{Add, FnMut, Mul};\n+use option::Option::{self, Some, None};\n+use marker::Sized;\n+\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse, Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev, Zip};\n+use super::ChainState;\n+use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator};\n+\n+fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n+\n+/// An interface for dealing with iterators.\n+///\n+/// This is the main iterator trait. For more about the concept of iterators\n+/// generally, please see the [module-level documentation]. In particular, you\n+/// may want to know how to [implement `Iterator`][impl].\n+///\n+/// [module-level documentation]: index.html\n+/// [impl]: index.html#implementing-iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n+                            `.iter()` or a similar method\"]\n+pub trait Iterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Advances the iterator and returns the next value.\n+    ///\n+    /// Returns `None` when iteration is finished. Individual iterator\n+    /// implementations may choose to resume iteration, and so calling `next()`\n+    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// // A call to next() returns the next value...\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    ///\n+    /// // ... and then None once it's over.\n+    /// assert_eq!(None, iter.next());\n+    ///\n+    /// // More calls may or may not return None. Here, they always will.\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next(&mut self) -> Option<Self::Item>;\n+\n+    /// Returns the bounds on the remaining length of the iterator.\n+    ///\n+    /// Specifically, `size_hint()` returns a tuple where the first element\n+    /// is the lower bound, and the second element is the upper bound.\n+    ///\n+    /// The second half of the tuple that is returned is an `Option<usize>`. A\n+    /// `None` here means that either there is no known upper bound, or the\n+    /// upper bound is larger than `usize`.\n+    ///\n+    /// # Implementation notes\n+    ///\n+    /// It is not enforced that an iterator implementation yields the declared\n+    /// number of elements. A buggy iterator may yield less than the lower bound\n+    /// or more than the upper bound of elements.\n+    ///\n+    /// `size_hint()` is primarily intended to be used for optimizations such as\n+    /// reserving space for the elements of the iterator, but must not be\n+    /// trusted to e.g. omit bounds checks in unsafe code. An incorrect\n+    /// implementation of `size_hint()` should not lead to memory safety\n+    /// violations.\n+    ///\n+    /// That said, the implementation should provide a correct estimation,\n+    /// because otherwise it would be a violation of the trait's protocol.\n+    ///\n+    /// The default implementation returns `(0, None)` which is correct for any\n+    /// iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// let iter = a.iter();\n+    ///\n+    /// assert_eq!((3, Some(3)), iter.size_hint());\n+    /// ```\n+    ///\n+    /// A more complex example:\n+    ///\n+    /// ```\n+    /// // The even numbers from zero to ten.\n+    /// let iter = (0..10).filter(|x| x % 2 == 0);\n+    ///\n+    /// // We might iterate from zero to ten times. Knowing that it's five\n+    /// // exactly wouldn't be possible without executing filter().\n+    /// assert_eq!((0, Some(10)), iter.size_hint());\n+    ///\n+    /// // Let's add one five more numbers with chain()\n+    /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n+    ///\n+    /// // now both bounds are increased by five\n+    /// assert_eq!((5, Some(15)), iter.size_hint());\n+    /// ```\n+    ///\n+    /// Returning `None` for an upper bound:\n+    ///\n+    /// ```\n+    /// // an infinite iterator has no upper bound\n+    /// let iter = 0..;\n+    ///\n+    /// assert_eq!((0, None), iter.size_hint());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n+\n+    /// Consumes the iterator, counting the number of iterations and returning it.\n+    ///\n+    /// This method will evaluate the iterator until its [`next()`] returns\n+    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// times it called [`next()`].\n+    ///\n+    /// [`next()`]: #tymethod.next\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so counting elements of\n+    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// wrong result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().count(), 3);\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().count(), 5);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn count(self) -> usize where Self: Sized {\n+        // Might overflow.\n+        self.fold(0, |cnt, _| cnt + 1)\n+    }\n+\n+    /// Consumes the iterator, returning the last element.\n+    ///\n+    /// This method will evaluate the iterator until it returns `None`. While\n+    /// doing so, it keeps track of the current element. After `None` is\n+    /// returned, `last()` will then return the last element it saw.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().last(), Some(&3));\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().last(), Some(&5));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn last(self) -> Option<Self::Item> where Self: Sized {\n+        let mut last = None;\n+        for x in self { last = Some(x); }\n+        last\n+    }\n+\n+    /// Consumes the `n` first elements of the iterator, then returns the\n+    /// `next()` one.\n+    ///\n+    /// This method will evaluate the iterator `n` times, discarding those elements.\n+    /// After it does so, it will call [`next()`] and return its value.\n+    ///\n+    /// [`next()`]: #tymethod.next\n+    ///\n+    /// Like most indexing operations, the count starts from zero, so `nth(0)`\n+    /// returns the first value, `nth(1)` the second, and so on.\n+    ///\n+    /// `nth()` will return `None` if `n` is larger than the length of the\n+    /// iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(1), Some(&2));\n+    /// ```\n+    ///\n+    /// Calling `nth()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth(1), Some(&2));\n+    /// assert_eq!(iter.nth(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n` elements:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(10), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> where Self: Sized {\n+        for x in self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n+    /// Takes two iterators and creates a new iterator over both in sequence.\n+    ///\n+    /// `chain()` will return a new iterator which will first iterate over\n+    /// values from the first iterator and then over values from the second\n+    /// iterator.\n+    ///\n+    /// In other words, it links two iterators together, in a chain. \ud83d\udd17\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().chain(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Since the argument to `chain()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `chain()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    ///\n+    /// ```\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().chain(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n+        Self: Sized, U: IntoIterator<Item=Self::Item>,\n+    {\n+        Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n+    }\n+\n+    /// 'Zips up' two iterators into a single iterator of pairs.\n+    ///\n+    /// `zip()` returns a new iterator that will iterate over two other\n+    /// iterators, returning a tuple where the first element comes from the\n+    /// first iterator, and the second element comes from the second iterator.\n+    ///\n+    /// In other words, it zips two iterators together, into a single one.\n+    ///\n+    /// When either iterator returns `None`, all further calls to `next()`\n+    /// will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().zip(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Since the argument to `zip()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `zip()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    ///\n+    /// ```\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().zip(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `zip()` is often used to zip an infinite iterator to a finite one.\n+    /// This works because the finite iterator will eventually return `None`,\n+    /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n+    ///\n+    /// ```\n+    /// let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n+    ///\n+    /// let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n+    ///\n+    /// assert_eq!((0, 'f'), enumerate[0]);\n+    /// assert_eq!((0, 'f'), zipper[0]);\n+    ///\n+    /// assert_eq!((1, 'o'), enumerate[1]);\n+    /// assert_eq!((1, 'o'), zipper[1]);\n+    ///\n+    /// assert_eq!((2, 'o'), enumerate[2]);\n+    /// assert_eq!((2, 'o'), zipper[2]);\n+    /// ```\n+    ///\n+    /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n+        Self: Sized, U: IntoIterator\n+    {\n+        Zip{a: self, b: other.into_iter()}\n+    }\n+\n+    /// Takes a closure and creates an iterator which calls that closure on each\n+    /// element.\n+    ///\n+    /// `map()` transforms one iterator into another, by means of its argument:\n+    /// something that implements `FnMut`. It produces a new iterator which\n+    /// calls this closure on each element of the original iterator.\n+    ///\n+    /// If you are good at thinking in types, you can think of `map()` like this:\n+    /// If you have an iterator that gives you elements of some type `A`, and\n+    /// you want an iterator of some other type `B`, you can use `map()`,\n+    /// passing a closure that takes an `A` and returns a `B`.\n+    ///\n+    /// `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n+    /// lazy, it is best used when you're already working with other iterators.\n+    /// If you're doing some sort of looping for a side effect, it's considered\n+    /// more idiomatic to use [`for`] than `map()`.\n+    ///\n+    /// [`for`]: ../../book/loops.html#for\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter().map(|x| 2 * x);\n+    ///\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// If you're doing some sort of side effect, prefer [`for`] to `map()`:\n+    ///\n+    /// ```\n+    /// # #![allow(unused_must_use)]\n+    /// // don't do this:\n+    /// (0..5).map(|x| println!(\"{}\", x));\n+    ///\n+    /// // it won't even execute, as it is lazy. Rust will warn you about this.\n+    ///\n+    /// // Instead, use for:\n+    /// for x in 0..5 {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn map<B, F>(self, f: F) -> Map<Self, F> where\n+        Self: Sized, F: FnMut(Self::Item) -> B,\n+    {\n+        Map{iter: self, f: f}\n+    }\n+\n+    /// Creates an iterator which uses a closure to determine if an element\n+    /// should be yielded.\n+    ///\n+    /// The closure must return `true` or `false`. `filter()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `true`, then the element is returned. If the closure returns\n+    /// `false`, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [0i32, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| x.is_positive());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `filter()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// It's common to instead use destructuring on the argument to strip away\n+    /// one:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// or both:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// of these layers.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        Filter{iter: self, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that both filters and maps.\n+    ///\n+    /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `Some(element)`, then that element is returned. If the\n+    /// closure returns `None`, it will try again, and call the closure on the\n+    /// next element, seeing if it will return `Some`.\n+    ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    ///\n+    /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n+    /// part:\n+    ///\n+    /// [`filter()`]: #method.filter\n+    /// [`map()`]: #method.map\n+    ///\n+    /// > If the closure returns `Some(element)`, then that element is returned.\n+    ///\n+    /// In other words, it removes the [`Option<T>`] layer automatically. If your\n+    /// mapping is already returning an [`Option<T>`] and you want to skip over\n+    /// `None`s, then `filter_map()` is much, much nicer to use.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter().filter_map(|s| s.parse().ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`filter()`] and [`map()`]:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|s| s.parse().ok())\n+    ///                 .filter(|s| s.is_some());\n+    ///\n+    /// assert_eq!(iter.next(), Some(Some(1)));\n+    /// assert_eq!(iter.next(), Some(Some(2)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// There's an extra layer of `Some` in there.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n+        Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n+    {\n+        FilterMap { iter: self, f: f }\n+    }\n+\n+    /// Creates an iterator which gives the current iteration count as well as\n+    /// the next value.\n+    ///\n+    /// The iterator returned yields pairs `(i, val)`, where `i` is the\n+    /// current index of iteration and `val` is the value returned by the\n+    /// iterator.\n+    ///\n+    /// `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n+    /// different sized integer, the [`zip()`] function provides similar\n+    /// functionality.\n+    ///\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`zip()`]: #method.zip\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// [`usize::MAX`] elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// The returned iterator might panic if the to-be-returned index would\n+    /// overflow a `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().enumerate();\n+    ///\n+    /// assert_eq!(iter.next(), Some((0, &1)));\n+    /// assert_eq!(iter.next(), Some((1, &2)));\n+    /// assert_eq!(iter.next(), Some((2, &3)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n+        Enumerate { iter: self, count: 0 }\n+    }\n+\n+    /// Creates an iterator which can use `peek` to look at the next element of\n+    /// the iterator without consuming it.\n+    ///\n+    /// Adds a [`peek()`] method to an iterator. See its documentation for\n+    /// more information.\n+    ///\n+    /// Note that the underlying iterator is still advanced when `peek` is\n+    /// called for the first time: In order to retrieve the next element,\n+    /// `next` is called on the underlying iterator, hence any side effects of\n+    /// the `next` method will occur.\n+    ///\n+    /// [`peek()`]: struct.Peekable.html#method.peek\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the iterator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the iterator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn peekable(self) -> Peekable<Self> where Self: Sized {\n+        Peekable{iter: self, peeked: None}\n+    }\n+\n+    /// Creates an iterator that [`skip()`]s elements based on a predicate.\n+    ///\n+    /// [`skip()`]: #method.skip\n+    ///\n+    /// `skip_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and ignore elements\n+    /// until it returns `false`.\n+    ///\n+    /// After `false` is returned, `skip_while()`'s job is over, and the\n+    /// rest of the elements are yielded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `skip_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// // while this would have been false, since we already got a false,\n+    /// // skip_while() isn't used any more\n+    /// assert_eq!(iter.next(), Some(&-2));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        SkipWhile{iter: self, flag: false, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that yields elements based on a predicate.\n+    ///\n+    /// `take_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns `true`.\n+    ///\n+    /// After `false` is returned, `take_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `take_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    ///\n+    /// // We have more elements that are less than zero, but since we already\n+    /// // got a false, take_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because `take_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4];\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// let result: Vec<i32> = iter.by_ref()\n+    ///                            .take_while(|n| **n != 3)\n+    ///                            .cloned()\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator or\n+    /// some similar thing.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        TakeWhile{iter: self, flag: false, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that skips the first `n` elements.\n+    ///\n+    /// After they have been consumed, the rest of the elements are yielded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().skip(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n+        Skip{iter: self, n: n}\n+    }\n+\n+    /// Creates an iterator that yields its first `n` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().take(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `take()` is often used with an infinite iterator, to make it finite:\n+    ///\n+    /// ```\n+    /// let mut iter = (0..).take(3);\n+    ///\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n+        Take{iter: self, n: n}\n+    }\n+\n+    /// An iterator adaptor similar to [`fold()`] that holds internal state and\n+    /// produces a new iterator.\n+    ///\n+    /// [`fold()`]: #method.fold\n+    ///\n+    /// `scan()` takes two arguments: an initial value which seeds the internal\n+    /// state, and a closure with two arguments, the first being a mutable\n+    /// reference to the internal state and the second an iterator element.\n+    /// The closure can assign to the internal state to share state between\n+    /// iterations.\n+    ///\n+    /// On iteration, the closure will be applied to each element of the\n+    /// iterator and the return value from the closure, an [`Option`], is\n+    /// yielded by the iterator.\n+    ///\n+    /// [`Option`]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().scan(1, |state, &x| {\n+    ///     // each iteration, we'll multiply the state by the element\n+    ///     *state = *state * x;\n+    ///\n+    ///     // the value passed on to the next iteration\n+    ///     Some(*state)\n+    /// });\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n+        where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n+    {\n+        Scan{iter: self, f: f, state: initial_state}\n+    }\n+\n+    /// Creates an iterator that works like map, but flattens nested structure.\n+    ///\n+    /// The [`map()`] adapter is very useful, but only when the closure\n+    /// argument produces values. If it produces an iterator instead, there's\n+    /// an extra layer of indirection. `flat_map()` will remove this extra layer\n+    /// on its own.\n+    ///\n+    /// [`map()`]: #method.map\n+    ///\n+    /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n+    /// one item for each element, and `flat_map()`'s closure returns an\n+    /// iterator for each element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n+        where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n+    {\n+        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+    }\n+\n+    /// Creates an iterator which ends after the first `None`.\n+    ///\n+    /// After an iterator returns `None`, future calls may or may not yield\n+    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n+    /// `None` is given, it will always return `None` forever.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // an iterator which alternates between Some and None\n+    /// struct Alternate {\n+    ///     state: i32,\n+    /// }\n+    ///\n+    /// impl Iterator for Alternate {\n+    ///     type Item = i32;\n+    ///\n+    ///     fn next(&mut self) -> Option<i32> {\n+    ///         let val = self.state;\n+    ///         self.state = self.state + 1;\n+    ///\n+    ///         // if it's even, Some(i32), else None\n+    ///         if val % 2 == 0 {\n+    ///             Some(val)\n+    ///         } else {\n+    ///             None\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut iter = Alternate { state: 0 };\n+    ///\n+    /// // we can see our iterator going back and forth\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // however, once we fuse it...\n+    /// let mut iter = iter.fuse();\n+    ///\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // it will always return None after the first time.\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn fuse(self) -> Fuse<Self> where Self: Sized {\n+        Fuse{iter: self, done: false}\n+    }\n+\n+    /// Do something with each element of an iterator, passing the value on.\n+    ///\n+    /// When using iterators, you'll often chain several of them together.\n+    /// While working on such code, you might want to check out what's\n+    /// happening at various parts in the pipeline. To do that, insert\n+    /// a call to `inspect()`.\n+    ///\n+    /// It's much more common for `inspect()` to be used as a debugging tool\n+    /// than to exist in your final code, but never say never.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 4, 2, 3];\n+    ///\n+    /// // this iterator sequence is complex.\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n+    /// println!(\"{}\", sum);\n+    ///\n+    /// // let's add some inspect() calls to investigate what's happening\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n+    /// println!(\"{}\", sum);\n+    /// ```\n+    ///\n+    /// This will print:\n+    ///\n+    /// ```text\n+    /// about to filter: 1\n+    /// about to filter: 4\n+    /// made it through filter: 4\n+    /// about to filter: 2\n+    /// made it through filter: 2\n+    /// about to filter: 3\n+    /// 6\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n+        Self: Sized, F: FnMut(&Self::Item),\n+    {\n+        Inspect{iter: self, f: f}\n+    }\n+\n+    /// Borrows an iterator, rather than consuming it.\n+    ///\n+    /// This is useful to allow applying iterator adaptors while still\n+    /// retaining ownership of the original iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let iter = a.into_iter();\n+    ///\n+    /// let sum: i32 = iter.take(5)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 6);\n+    ///\n+    /// // if we try to use iter again, it won't work. The following line\n+    /// // gives \"error: use of moved value: `iter`\n+    /// // assert_eq!(iter.next(), None);\n+    ///\n+    /// // let's try that again\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// // instead, we add in a .by_ref()\n+    /// let sum: i32 = iter.by_ref()\n+    ///                    .take(2)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 3);\n+    ///\n+    /// // now this is just fine:\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+\n+    /// Transforms an iterator into a collection.\n+    ///\n+    /// `collect()` can take anything iterable, and turn it into a relevant\n+    /// collection. This is one of the more powerful methods in the standard\n+    /// library, used in a variety of contexts.\n+    ///\n+    /// The most basic pattern in which `collect()` is used is to turn one\n+    /// collection into another. You take a collection, call `iter()` on it,\n+    /// do a bunch of transformations, and then `collect()` at the end.\n+    ///\n+    /// One of the keys to `collect()`'s power is that many things you might\n+    /// not think of as 'collections' actually are. For example, a [`String`]\n+    /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n+    /// be thought of as single `Result<Collection<T>, E>`. See the examples\n+    /// below for more.\n+    ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    ///\n+    /// Because `collect()` is so general, it can cause problems with type\n+    /// inference. As such, `collect()` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which collection\n+    /// you're trying to collect into.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: Vec<i32> = a.iter()\n+    ///                          .map(|&x| x * 2)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n+    /// we could collect into, for example, a [`VecDeque<T>`] instead:\n+    ///\n+    /// [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: VecDeque<i32> = a.iter()\n+    ///                               .map(|&x| x * 2)\n+    ///                               .collect();\n+    ///\n+    /// assert_eq!(2, doubled[0]);\n+    /// assert_eq!(4, doubled[1]);\n+    /// assert_eq!(6, doubled[2]);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `doubled`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<i32>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Because `collect()` cares about what you're collecting into, you can\n+    /// still use a partial type hint, `_`, with the turbofish:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<_>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Using `collect()` to make a [`String`]:\n+    ///\n+    /// ```\n+    /// let chars = ['g', 'd', 'k', 'k', 'n'];\n+    ///\n+    /// let hello: String = chars.iter()\n+    ///                          .map(|&x| x as u8)\n+    ///                          .map(|x| (x + 1) as char)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(\"hello\", hello);\n+    /// ```\n+    ///\n+    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// see if any of them failed:\n+    ///\n+    /// ```\n+    /// let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the first error\n+    /// assert_eq!(Err(\"nope\"), result);\n+    ///\n+    /// let results = [Ok(1), Ok(3)];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the list of answers\n+    /// assert_eq!(Ok(vec![1, 3]), result);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n+        FromIterator::from_iter(self)\n+    }\n+\n+    /// Consumes an iterator, creating two collections from it.\n+    ///\n+    /// The predicate passed to `partition()` can return `true`, or `false`.\n+    /// `partition()` returns a pair, all of the elements for which it returned\n+    /// `true`, and all of the elements for which it returned `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n+    ///                                          .partition(|&n| n % 2 == 0);\n+    ///\n+    /// assert_eq!(even, vec![2]);\n+    /// assert_eq!(odd, vec![1, 3]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+        Self: Sized,\n+        B: Default + Extend<Self::Item>,\n+        F: FnMut(&Self::Item) -> bool\n+    {\n+        let mut left: B = Default::default();\n+        let mut right: B = Default::default();\n+\n+        for x in self {\n+            if f(&x) {\n+                left.extend(Some(x))\n+            } else {\n+                right.extend(Some(x))\n+            }\n+        }\n+\n+        (left, right)\n+    }\n+\n+    /// An iterator adaptor that applies a function, producing a single, final value.\n+    ///\n+    /// `fold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. The closure returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `fold()`\n+    /// returns the accumulator.\n+    ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .fold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// Let's walk through each step of the iteration here:\n+    ///\n+    /// | element | acc | x | result |\n+    /// |---------|-----|---|--------|\n+    /// |         | 0   |   |        |\n+    /// | 1       | 0   | 1 | 1      |\n+    /// | 2       | 1   | 2 | 3      |\n+    /// | 3       | 3   | 3 | 6      |\n+    ///\n+    /// And so, our final result, `6`.\n+    ///\n+    /// It's common for people who haven't used iterators a lot to\n+    /// use a `for` loop with a list of things to build up a result. Those\n+    /// can be turned into `fold()`s:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let mut result = 0;\n+    ///\n+    /// // for loop:\n+    /// for i in &numbers {\n+    ///     result = result + i;\n+    /// }\n+    ///\n+    /// // fold:\n+    /// let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n+    ///\n+    /// // they're the same\n+    /// assert_eq!(result, result2);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn fold<B, F>(self, init: B, mut f: F) -> B where\n+        Self: Sized, F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        for x in self {\n+            accum = f(accum, x);\n+        }\n+        accum\n+    }\n+\n+    /// Tests if every element of the iterator matches a predicate.\n+    ///\n+    /// `all()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if they all return\n+    /// `true`, then so does `all()`. If any of them return `false`, it\n+    /// returns `false`.\n+    ///\n+    /// `all()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as it finds a `false`, given that no matter what else happens,\n+    /// the result will also be `false`.\n+    ///\n+    /// An empty iterator returns `true`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().all(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().all(|&x| x > 2));\n+    /// ```\n+    ///\n+    /// Stopping at the first `false`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(!iter.all(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn all<F>(&mut self, mut f: F) -> bool where\n+        Self: Sized, F: FnMut(Self::Item) -> bool\n+    {\n+        for x in self {\n+            if !f(x) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Tests if any element of the iterator matches a predicate.\n+    ///\n+    /// `any()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then so does `any()`. If they all return `false`, it\n+    /// returns `false`.\n+    ///\n+    /// `any()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as it finds a `true`, given that no matter what else happens,\n+    /// the result will also be `true`.\n+    ///\n+    /// An empty iterator returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().any(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().any(|&x| x > 5));\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(iter.any(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn any<F>(&mut self, mut f: F) -> bool where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> bool\n+    {\n+        for x in self {\n+            if f(x) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Searches for an element of an iterator that satisfies a predicate.\n+    ///\n+    /// `find()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then `find()` returns `Some(element)`. If they all return\n+    /// `false`, it returns `None`.\n+    ///\n+    /// `find()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as the closure returns `true`.\n+    ///\n+    /// Because `find()` takes a reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// argument is a double reference. You can see this effect in the\n+    /// examples below, with `&&x`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        for x in self {\n+            if predicate(&x) { return Some(x) }\n+        }\n+        None\n+    }\n+\n+    /// Searches for an element in an iterator, returning its index.\n+    ///\n+    /// `position()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if one of them\n+    /// returns `true`, then `position()` returns `Some(index)`. If all of\n+    /// them return `false`, it returns `None`.\n+    ///\n+    /// `position()` is short-circuiting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so if there are more\n+    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// non-matching elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 2), Some(1));\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.position(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+        Self: Sized,\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        // `enumerate` might overflow.\n+        for (i, x) in self.enumerate() {\n+            if predicate(x) {\n+                return Some(i);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Searches for an element in an iterator from the right, returning its\n+    /// index.\n+    ///\n+    /// `rposition()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, starting from the end,\n+    /// and if one of them returns `true`, then `rposition()` returns\n+    /// `Some(index)`. If all of them return `false`, it returns `None`.\n+    ///\n+    /// `rposition()` is short-circuiting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+        P: FnMut(Self::Item) -> bool,\n+        Self: Sized + ExactSizeIterator + DoubleEndedIterator\n+    {\n+        let mut i = self.len();\n+\n+        while let Some(v) = self.next_back() {\n+            if predicate(v) {\n+                return Some(i - 1);\n+            }\n+            // No need for an overflow check here, because `ExactSizeIterator`\n+            // implies that the number of elements fits into a `usize`.\n+            i -= 1;\n+        }\n+        None\n+    }\n+\n+    /// Returns the maximum element of an iterator.\n+    ///\n+    /// If the two elements are equally maximum, the latest element is\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().max(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |_, x, _, y| *x <= *y)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the minimum element of an iterator.\n+    ///\n+    /// If the two elements are equally minimum, the first element is\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().min(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |_, x, _, y| *x > *y)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the element that gives the maximum value from the\n+    /// specified function.\n+    ///\n+    /// Returns the rightmost element if the comparison determines two elements\n+    /// to be equally maximum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    {\n+        select_fold1(self,\n+                     f,\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |x_p, _, y_p, _| x_p <= y_p)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the element that gives the minimum value from the\n+    /// specified function.\n+    ///\n+    /// Returns the latest element if the comparison determines two elements\n+    /// to be equally minimum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n+    /// ```\n+    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    {\n+        select_fold1(self,\n+                     f,\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |x_p, _, y_p, _| x_p > y_p)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Reverses an iterator's direction.\n+    ///\n+    /// Usually, iterators iterate from left to right. After using `rev()`,\n+    /// an iterator will instead iterate from right to left.\n+    ///\n+    /// This is only possible if the iterator has an end, so `rev()` only\n+    /// works on [`DoubleEndedIterator`]s.\n+    ///\n+    /// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().rev();\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n+        Rev{iter: self}\n+    }\n+\n+    /// Converts an iterator of pairs into a pair of containers.\n+    ///\n+    /// `unzip()` consumes an entire iterator of pairs, producing two\n+    /// collections: one from the left elements of the pairs, and one\n+    /// from the right elements.\n+    ///\n+    /// This function is, in some sense, the opposite of [`zip()`].\n+    ///\n+    /// [`zip()`]: #method.zip\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [(1, 2), (3, 4)];\n+    ///\n+    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n+    ///\n+    /// assert_eq!(left, [1, 3]);\n+    /// assert_eq!(right, [2, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n+        FromA: Default + Extend<A>,\n+        FromB: Default + Extend<B>,\n+        Self: Sized + Iterator<Item=(A, B)>,\n+    {\n+        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);\n+        impl<A> Iterator for SizeHint<A> {\n+            type Item = A;\n+\n+            fn next(&mut self) -> Option<A> { None }\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                (self.0, self.1)\n+            }\n+        }\n+\n+        let (lo, hi) = self.size_hint();\n+        let mut ts: FromA = Default::default();\n+        let mut us: FromB = Default::default();\n+\n+        ts.extend(SizeHint(lo, hi, marker::PhantomData));\n+        us.extend(SizeHint(lo, hi, marker::PhantomData));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t));\n+            us.extend(Some(u));\n+        }\n+\n+        (ts, us)\n+    }\n+\n+    /// Creates an iterator which `clone()`s all of its elements.\n+    ///\n+    /// This is useful when you have an iterator over `&T`, but you need an\n+    /// iterator over `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let v_cloned: Vec<_> = a.iter().cloned().collect();\n+    ///\n+    /// // cloned is the same as .map(|&x| x), for integers\n+    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_map, vec![1, 2, 3]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n+        where Self: Sized + Iterator<Item=&'a T>, T: Clone\n+    {\n+        Cloned { it: self }\n+    }\n+\n+    /// Repeats an iterator endlessly.\n+    ///\n+    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// from the beginning. After iterating again, it will start at the\n+    /// beginning again. And again. And again. Forever.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut it = a.iter().cycle();\n+    ///\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone {\n+        Cycle{orig: self.clone(), iter: self}\n+    }\n+\n+    /// Sums the elements of an iterator.\n+    ///\n+    /// Takes each element, adds them together, and returns the result.\n+    ///\n+    /// An empty iterator returns the zero value of the type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_arith)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let sum: i32 = a.iter().sum();\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    #[unstable(feature = \"iter_arith\", reason = \"bounds recently changed\",\n+               issue = \"27739\")]\n+    fn sum<S>(self) -> S where\n+        S: Add<Self::Item, Output=S> + Zero,\n+        Self: Sized,\n+    {\n+        self.fold(Zero::zero(), |s, e| s + e)\n+    }\n+\n+    /// Iterates over the entire iterator, multiplying all the elements\n+    ///\n+    /// An empty iterator returns the one value of the type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iter_arith)]\n+    ///\n+    /// fn factorial(n: u32) -> u32 {\n+    ///     (1..).take_while(|&i| i <= n).product()\n+    /// }\n+    /// assert_eq!(factorial(0), 1);\n+    /// assert_eq!(factorial(1), 1);\n+    /// assert_eq!(factorial(5), 120);\n+    /// ```\n+    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\",\n+               issue = \"27739\")]\n+    fn product<P>(self) -> P where\n+        P: Mul<Self::Item, Output=P> + One,\n+        Self: Sized,\n+    {\n+        self.fold(One::one(), |p, e| p * e)\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn cmp<I>(mut self, other: I) -> Ordering where\n+        I: IntoIterator<Item = Self::Item>,\n+        Self::Item: Ord,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Ordering::Equal,\n+                (None, _   ) => return Ordering::Less,\n+                (_   , None) => return Ordering::Greater,\n+                (Some(x), Some(y)) => match x.cmp(&y) {\n+                    Ordering::Equal => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Some(Ordering::Equal),\n+                (None, _   ) => return Some(Ordering::Less),\n+                (_   , None) => return Some(Ordering::Greater),\n+                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n+                    Some(Ordering::Equal) => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn eq<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if x != y { return false },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are unequal to those of\n+    /// another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn ne<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _) | (_, None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return true },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less than those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn lt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less or equal to those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn le<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn gt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than or equal to those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn ge<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+}\n+\n+/// Select an element from an iterator based on the given projection\n+/// and \"comparison\" function.\n+///\n+/// This is an idiosyncratic helper to try to factor out the\n+/// commonalities of {max,min}{,_by}. In particular, this avoids\n+/// having to implement optimizations several times.\n+#[inline]\n+fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n+                                  mut f_proj: FProj,\n+                                  mut f_cmp: FCmp) -> Option<(B, I::Item)>\n+    where I: Iterator,\n+          FProj: FnMut(&I::Item) -> B,\n+          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+{\n+    // start with the first element as our selection. This avoids\n+    // having to use `Option`s inside the loop, translating to a\n+    // sizeable performance gain (6x in one case).\n+    it.next().map(|mut sel| {\n+        let mut sel_p = f_proj(&sel);\n+\n+        for x in it {\n+            let x_p = f_proj(&x);\n+            if f_cmp(&sel_p,  &sel, &x_p, &x) {\n+                sel = x;\n+                sel_p = x_p;\n+            }\n+        }\n+        (sel_p, sel)\n+    })\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n+    type Item = I::Item;\n+    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+}\n+"}, {"sha": "8449ee78501954864db18e957ad7e4f8f5425ad4", "filename": "src/libcore/iter/mod.rs", "status": "added", "additions": 1657, "deletions": 0, "changes": 1657, "blob_url": "https://github.com/rust-lang/rust/blob/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=84654fa4bf8e532469787889efa01b59a3c98aa0", "patch": "@@ -0,0 +1,1657 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Composable external iteration.\n+//!\n+//! If you've found yourself with a collection of some kind, and needed to\n+//! perform an operation on the elements of said collection, you'll quickly run\n+//! into 'iterators'. Iterators are heavily used in idiomatic Rust code, so\n+//! it's worth becoming familiar with them.\n+//!\n+//! Before explaining more, let's talk about how this module is structured:\n+//!\n+//! # Organization\n+//!\n+//! This module is largely organized by type:\n+//!\n+//! * [Traits] are the core portion: these traits define what kind of iterators\n+//!   exist and what you can do with them. The methods of these traits are worth\n+//!   putting some extra study time into.\n+//! * [Functions] provide some helpful ways to create some basic iterators.\n+//! * [Structs] are often the return types of the various methods on this\n+//!   module's traits. You'll usually want to look at the method that creates\n+//!   the `struct`, rather than the `struct` itself. For more detail about why,\n+//!   see '[Implementing Iterator](#implementing-iterator)'.\n+//!\n+//! [Traits]: #traits\n+//! [Functions]: #functions\n+//! [Structs]: #structs\n+//!\n+//! That's it! Let's dig into iterators.\n+//!\n+//! # Iterator\n+//!\n+//! The heart and soul of this module is the [`Iterator`] trait. The core of\n+//! [`Iterator`] looks like this:\n+//!\n+//! ```\n+//! trait Iterator {\n+//!     type Item;\n+//!     fn next(&mut self) -> Option<Self::Item>;\n+//! }\n+//! ```\n+//!\n+//! An iterator has a method, [`next()`], which when called, returns an\n+//! [`Option`]`<Item>`. [`next()`] will return `Some(Item)` as long as there\n+//! are elements, and once they've all been exhausted, will return `None` to\n+//! indicate that iteration is finished. Individual iterators may choose to\n+//! resume iteration, and so calling [`next()`] again may or may not eventually\n+//! start returning `Some(Item)` again at some point.\n+//!\n+//! [`Iterator`]'s full definition includes a number of other methods as well,\n+//! but they are default methods, built on top of [`next()`], and so you get\n+//! them for free.\n+//!\n+//! Iterators are also composable, and it's common to chain them together to do\n+//! more complex forms of processing. See the [Adapters](#adapters) section\n+//! below for more details.\n+//!\n+//! [`Iterator`]: trait.Iterator.html\n+//! [`next()`]: trait.Iterator.html#tymethod.next\n+//! [`Option`]: ../../std/option/enum.Option.html\n+//!\n+//! # The three forms of iteration\n+//!\n+//! There are three common methods which can create iterators from a collection:\n+//!\n+//! * `iter()`, which iterates over `&T`.\n+//! * `iter_mut()`, which iterates over `&mut T`.\n+//! * `into_iter()`, which iterates over `T`.\n+//!\n+//! Various things in the standard library may implement one or more of the\n+//! three, where appropriate.\n+//!\n+//! # Implementing Iterator\n+//!\n+//! Creating an iterator of your own involves two steps: creating a `struct` to\n+//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n+//! `struct`. This is why there are so many `struct`s in this module: there is\n+//! one for each iterator and iterator adapter.\n+//!\n+//! Let's make an iterator named `Counter` which counts from `1` to `5`:\n+//!\n+//! ```\n+//! // First, the struct:\n+//!\n+//! /// An iterator which counts from one to five\n+//! struct Counter {\n+//!     count: usize,\n+//! }\n+//!\n+//! // we want our count to start at one, so let's add a new() method to help.\n+//! // This isn't strictly necessary, but is convenient. Note that we start\n+//! // `count` at zero, we'll see why in `next()`'s implementation below.\n+//! impl Counter {\n+//!     fn new() -> Counter {\n+//!         Counter { count: 0 }\n+//!     }\n+//! }\n+//!\n+//! // Then, we implement `Iterator` for our `Counter`:\n+//!\n+//! impl Iterator for Counter {\n+//!     // we will be counting with usize\n+//!     type Item = usize;\n+//!\n+//!     // next() is the only required method\n+//!     fn next(&mut self) -> Option<usize> {\n+//!         // increment our count. This is why we started at zero.\n+//!         self.count += 1;\n+//!\n+//!         // check to see if we've finished counting or not.\n+//!         if self.count < 6 {\n+//!             Some(self.count)\n+//!         } else {\n+//!             None\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! // And now we can use it!\n+//!\n+//! let mut counter = Counter::new();\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//! ```\n+//!\n+//! This will print `1` through `5`, each on their own line.\n+//!\n+//! Calling `next()` this way gets repetitive. Rust has a construct which can\n+//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n+//! next.\n+//!\n+//! # for Loops and IntoIterator\n+//!\n+//! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n+//! example of `for`:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in values {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! This will print the numbers one through five, each on their own line. But\n+//! you'll notice something here: we never called anything on our vector to\n+//! produce an iterator. What gives?\n+//!\n+//! There's a trait in the standard library for converting something into an\n+//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter()`],\n+//! which converts the thing implementing [`IntoIterator`] into an iterator.\n+//! Let's take a look at that `for` loop again, and what the compiler converts\n+//! it into:\n+//!\n+//! [`IntoIterator`]: trait.IntoIterator.html\n+//! [`into_iter()`]: trait.IntoIterator.html#tymethod.into_iter\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in values {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! Rust de-sugars this into:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//! {\n+//!     let result = match IntoIterator::into_iter(values) {\n+//!         mut iter => loop {\n+//!             match iter.next() {\n+//!                 Some(x) => { println!(\"{}\", x); },\n+//!                 None => break,\n+//!             }\n+//!         },\n+//!     };\n+//!     result\n+//! }\n+//! ```\n+//!\n+//! First, we call `into_iter()` on the value. Then, we match on the iterator\n+//! that returns, calling [`next()`] over and over until we see a `None`. At\n+//! that point, we `break` out of the loop, and we're done iterating.\n+//!\n+//! There's one more subtle bit here: the standard library contains an\n+//! interesting implementation of [`IntoIterator`]:\n+//!\n+//! ```ignore\n+//! impl<I: Iterator> IntoIterator for I\n+//! ```\n+//!\n+//! In other words, all [`Iterator`]s implement [`IntoIterator`], by just\n+//! returning themselves. This means two things:\n+//!\n+//! 1. If you're writing an [`Iterator`], you can use it with a `for` loop.\n+//! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n+//!    will allow your collection to be used with the `for` loop.\n+//!\n+//! # Adapters\n+//!\n+//! Functions which take an [`Iterator`] and return another [`Iterator`] are\n+//! often called 'iterator adapters', as they're a form of the 'adapter\n+//! pattern'.\n+//!\n+//! Common iterator adapters include [`map()`], [`take()`], and [`collect()`].\n+//! For more, see their documentation.\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//! [`take()`]: trait.Iterator.html#method.take\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Laziness\n+//!\n+//! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n+//! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n+//! until you call [`next()`]. This is sometimes a source of confusion when\n+//! creating an iterator solely for its side effects. For example, the [`map()`]\n+//! method calls a closure on each element it iterates over:\n+//!\n+//! ```\n+//! # #![allow(unused_must_use)]\n+//! let v = vec![1, 2, 3, 4, 5];\n+//! v.iter().map(|x| println!(\"{}\", x));\n+//! ```\n+//!\n+//! This will not print any values, as we only created an iterator, rather than\n+//! using it. The compiler will warn us about this kind of behavior:\n+//!\n+//! ```text\n+//! warning: unused result which must be used: iterator adaptors are lazy and\n+//! do nothing unless consumed\n+//! ```\n+//!\n+//! The idiomatic way to write a [`map()`] for its side effects is to use a\n+//! `for` loop instead:\n+//!\n+//! ```\n+//! let v = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in &v {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//!\n+//! The two most common ways to evaluate an iterator are to use a `for` loop\n+//! like this, or using the [`collect()`] adapter to produce a new collection.\n+//!\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Infinity\n+//!\n+//! Iterators do not have to be finite. As an example, an open-ended range is\n+//! an infinite iterator:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! ```\n+//!\n+//! It is common to use the [`take()`] iterator adapter to turn an infinite\n+//! iterator into a finite one:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! let five_numbers = numbers.take(5);\n+//!\n+//! for number in five_numbers {\n+//!     println!(\"{}\", number);\n+//! }\n+//! ```\n+//!\n+//! This will print the numbers `0` through `4`, each on their own line.\n+//!\n+//! [`take()`]: trait.Iterator.html#method.take\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use clone::Clone;\n+use cmp;\n+use fmt;\n+use ops::FnMut;\n+use option::Option::{self, Some, None};\n+use usize;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iterator::Iterator;\n+\n+#[unstable(feature = \"step_trait\",\n+           reason = \"likely to be replaced by finer-grained traits\",\n+           issue = \"27741\")]\n+pub use self::range::Step;\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n+pub use self::range::StepBy;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::sources::{Repeat, repeat};\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub use self::sources::{Empty, empty};\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub use self::sources::{Once, once};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend,\n+                       ExactSizeIterator};\n+\n+mod iterator;\n+mod range;\n+mod sources;\n+mod traits;\n+\n+// All adaptors that preserve the size of the wrapped iterator are fine\n+// Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where\n+    F: FnMut(&I::Item),\n+{}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+    where I: ExactSizeIterator + DoubleEndedIterator {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n+{}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+\n+/// An double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev()`]: trait.Iterator.html#method.rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+}\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned()`]: trait.Iterator.html#method.cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+    where I: Iterator<Item=&'a T>, T: Clone\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n+{}\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle()`]: trait.Iterator.html#method.cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => { self.iter = self.orig.clone(); self.iter.next() }\n+            y => y\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None)\n+        }\n+    }\n+}\n+\n+/// An iterator that strings two iterators together.\n+///\n+/// This `struct` is created by the [`chain()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`chain()`]: trait.Iterator.html#method.chain\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chain<A, B> {\n+    a: A,\n+    b: B,\n+    state: ChainState,\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone, Debug)]\n+enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => {\n+                // Must exhaust a before b.\n+                let a_last = self.a.last();\n+                let b_last = self.b.last();\n+                b_last.or(a_last)\n+            },\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = a_lower.saturating_add(b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => x.checked_add(y),\n+            _ => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n+        }\n+    }\n+}\n+\n+/// An iterator that iterates two other iterators simultaneously.\n+///\n+/// This `struct` is created by the [`zip()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`zip()`]: trait.Iterator.html#method.zip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        let a_sz = self.a.len();\n+        let b_sz = self.b.len();\n+        if a_sz != b_sz {\n+            // Adjust a, b to equal length\n+            if a_sz > b_sz {\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+            } else {\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+            }\n+        }\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            (None, None) => None,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map()`]: trait.Iterator.html#method.map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map()`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map()`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().rev().map(|x| x + 1).collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazilly on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Map\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+}\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter()`]: trait.Iterator.html#method.filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Filter\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref().rev() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map()`]: trait.Iterator.html#method.filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref().rev() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next().map(|a| {\n+            let ret = (self.count, a);\n+            // Possible undefined overflow.\n+            self.count += 1;\n+            ret\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next_back().map(|a| {\n+            let len = self.iter.len();\n+            // Can safely add, `ExactSizeIterator` promises that the number of\n+            // elements fits into a `usize`.\n+            (self.count + len, a)\n+        })\n+    }\n+}\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable()`]: trait.Iterator.html#method.peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    peeked: Option<I::Item>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) => self.peeked.take(),\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) if n == 0 => self.peeked.take(),\n+            Some(_) => {\n+                self.peeked = None;\n+                self.iter.nth(n-1)\n+            },\n+            None => self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last().or(self.peeked)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lo, hi) = self.iter.size_hint();\n+        if self.peeked.is_some() {\n+            let lo = lo.saturating_add(1);\n+            let hi = hi.and_then(|x| x.checked_add(1));\n+            (lo, hi)\n+        } else {\n+            (lo, hi)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// The `peek()` method will return the value that a call to [`next()`] would\n+    /// return, but does not advance the iterator. Like [`next()`], if there is\n+    /// a value, it's wrapped in a `Some(T)`, but if the iterator is over, it\n+    /// will return `None`.\n+    ///\n+    /// [`next()`]: trait.Iterator.html#tymethod.next\n+    ///\n+    /// Because `peek()` returns reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below, with `&&i32`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the iterator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the iterator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        if self.peeked.is_none() {\n+            self.peeked = self.iter.next();\n+        }\n+        match self.peeked {\n+            Some(ref value) => Some(value),\n+            None => None,\n+        }\n+    }\n+\n+    /// Checks if the iterator has finished iterating.\n+    ///\n+    /// Returns `true` if there are no more elements in the iterator, and\n+    /// `false` if there are.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(peekable_is_empty)]\n+    ///\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // there are still elements to iterate over\n+    /// assert_eq!(iter.is_empty(), false);\n+    ///\n+    /// // let's consume the iterator\n+    /// iter.next();\n+    /// iter.next();\n+    /// iter.next();\n+    ///\n+    /// assert_eq!(iter.is_empty(), true);\n+    /// ```\n+    #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n+    #[inline]\n+    pub fn is_empty(&mut self) -> bool {\n+        self.peek().is_none()\n+    }\n+}\n+\n+/// An iterator that rejects elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`skip_while()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while()`]: trait.Iterator.html#method.skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref() {\n+            if self.flag || !(self.predicate)(&x) {\n+                self.flag = true;\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+/// An iterator that only accepts elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`take_while()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while()`]: trait.Iterator.html#method.take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            self.iter.next().and_then(|x| {\n+                if (self.predicate)(&x) {\n+                    Some(x)\n+                } else {\n+                    self.flag = true;\n+                    None\n+                }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip()`]: trait.Iterator.html#method.skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = upper.map(|x| x.saturating_sub(self.n));\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.8.0\")]\n+impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 {\n+            self.iter.next_back()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take()`]: trait.Iterator.html#method.take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    iter: I,\n+    n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan()`]: trait.Iterator.html#method.scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Scan\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+}\n+\n+/// An iterator that maps each element to an iterator, and yields the elements\n+/// of the produced iterators.\n+///\n+/// This `struct` is created by the [`flat_map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flat_map()`]: trait.Iterator.html#method.flat_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    iter: I,\n+    f: F,\n+    frontiter: Option<U::IntoIter>,\n+    backiter: Option<U::IntoIter>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"frontiter\", &self.frontiter)\n+            .field(\"backiter\", &self.backiter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.frontiter {\n+                if let Some(x) = inner.by_ref().next() {\n+                    return Some(x)\n+                }\n+            }\n+            match self.iter.next().map(&mut self.f) {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                next => self.frontiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n+            _ => (lo, None)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n+    F: FnMut(I::Item) -> U,\n+    U: IntoIterator,\n+    U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.backiter {\n+                if let Some(y) = inner.next_back() {\n+                    return Some(y)\n+                }\n+            }\n+            match self.iter.next_back().map(&mut self.f) {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                next => self.backiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// This `struct` is created by the [`fuse()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`fuse()`]: trait.Iterator.html#method.fuse\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Fuse<I> {\n+    iter: I,\n+    done: bool\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next_back();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect()`]: trait.Iterator.html#method.inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Inspect\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+}"}, {"sha": "08143567beaf3892cfb82ff66ab5ab94c531fed8", "filename": "src/libcore/iter/range.rs", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=84654fa4bf8e532469787889efa01b59a3c98aa0", "patch": "@@ -0,0 +1,548 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use cmp::PartialOrd;\n+use mem;\n+use num::{Zero, One};\n+use ops::{self, Add, Sub};\n+use option::Option::{self, Some, None};\n+use marker::Sized;\n+use usize;\n+\n+use super::{DoubleEndedIterator, ExactSizeIterator, Iterator};\n+\n+/// Objects that can be stepped over in both directions.\n+///\n+/// The `steps_between` function provides a way to efficiently compare\n+/// two `Step` objects.\n+#[unstable(feature = \"step_trait\",\n+           reason = \"likely to be replaced by finer-grained traits\",\n+           issue = \"27741\")]\n+pub trait Step: PartialOrd + Sized {\n+    /// Steps `self` if possible.\n+    fn step(&self, by: &Self) -> Option<Self>;\n+\n+    /// Returns the number of steps between two step objects. The count is\n+    /// inclusive of `start` and exclusive of `end`.\n+    ///\n+    /// Returns `None` if it is not possible to calculate `steps_between`\n+    /// without overflow.\n+    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n+}\n+\n+macro_rules! step_impl_unsigned {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *by == 0 { return None; }\n+                if *start < *end {\n+                    // Note: We assume $t <= usize here\n+                    let diff = (*end - *start) as usize;\n+                    let by = *by as usize;\n+                    if diff % by > 0 {\n+                        Some(diff / by + 1)\n+                    } else {\n+                        Some(diff / by)\n+                    }\n+                } else {\n+                    Some(0)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+macro_rules! step_impl_signed {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *by == 0 { return None; }\n+                let diff: usize;\n+                let by_u: usize;\n+                if *by > 0 {\n+                    if *start >= *end {\n+                        return Some(0);\n+                    }\n+                    // Note: We assume $t <= isize here\n+                    // Use .wrapping_sub and cast to usize to compute the\n+                    // difference that may not fit inside the range of isize.\n+                    diff = (*end as isize).wrapping_sub(*start as isize) as usize;\n+                    by_u = *by as usize;\n+                } else {\n+                    if *start <= *end {\n+                        return Some(0);\n+                    }\n+                    diff = (*start as isize).wrapping_sub(*end as isize) as usize;\n+                    by_u = (*by as isize).wrapping_mul(-1) as usize;\n+                }\n+                if diff % by_u > 0 {\n+                    Some(diff / by_u + 1)\n+                } else {\n+                    Some(diff / by_u)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! step_impl_no_between {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n+                None\n+            }\n+        }\n+    )*)\n+}\n+\n+step_impl_unsigned!(usize u8 u16 u32);\n+step_impl_signed!(isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl_unsigned!(u64);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl_signed!(i64);\n+// If the target pointer width is not 64-bits, we\n+// assume here that it is less than 64-bits.\n+#[cfg(not(target_pointer_width = \"64\"))]\n+step_impl_no_between!(u64 i64);\n+\n+/// An adapter for stepping range iterators by a custom amount.\n+///\n+/// The resulting iterator handles overflow by stopping. The `A`\n+/// parameter is the type being iterated over, while `R` is the range\n+/// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n+#[derive(Clone, Debug)]\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n+pub struct StepBy<A, R> {\n+    step_by: A,\n+    range: R,\n+}\n+\n+impl<A: Step> ops::RangeFrom<A> {\n+    /// Creates an iterator starting at the same point, but stepping by\n+    /// the given amount at each iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(step_by)]\n+    ///\n+    /// for i in (0u8..).step_by(2).take(10) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints the first ten even natural integers (0 to 18).\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+impl<A: Step> ops::Range<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by)]\n+    ///\n+    /// for i in (0..10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+impl<A: Step> ops::RangeInclusive<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by, inclusive_range_syntax)]\n+    ///\n+    /// for i in (0...10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// 10\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n+    A: Clone,\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let mut n = &self.range.start + &self.step_by;\n+        mem::swap(&mut n, &mut self.range.start);\n+        Some(n)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None) // Too bad we can't specify an infinite lower bound\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let rev = self.step_by < A::zero();\n+        if (rev && self.range.start > self.range.end) ||\n+           (!rev && self.range.start < self.range.end)\n+        {\n+            match self.range.start.step(&self.step_by) {\n+                Some(mut n) => {\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                },\n+                None => {\n+                    let mut n = self.range.end.clone();\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match Step::steps_between(&self.range.start,\n+                                  &self.range.end,\n+                                  &self.step_by) {\n+            Some(hint) => (hint, Some(hint)),\n+            None       => (0, None)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\",\n+           reason = \"recently added, follows RFC\",\n+           issue = \"28237\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self.range, so borrows of start and end need to end early\n+\n+        let (finishing, n) = match self.range {\n+            Empty { .. } => return None, // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let zero = A::zero();\n+                let rev = self.step_by < zero;\n+\n+                // march start towards (maybe past!) end and yield the old value\n+                if (rev && start >= end) ||\n+                   (!rev && start <= end)\n+                {\n+                    match start.step(&self.step_by) {\n+                        Some(mut n) => {\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        },\n+                        None => {\n+                            let mut n = end.clone();\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        }\n+                    }\n+                } else {\n+                    // found range in inconsistent state (start at or past end), so become empty\n+                    (Some(mem::replace(end, zero)), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if we've reached the end\n+        if let Some(end) = finishing {\n+            self.range = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match self.range {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start,\n+                                          end,\n+                                          &self.step_by) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None       => (0, None)\n+                }\n+        }\n+    }\n+}\n+\n+macro_rules! range_exact_iter_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl ExactSizeIterator for ops::Range<$t> { }\n+\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n+    )*)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One> Iterator for ops::Range<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            let mut n = &self.start + &A::one();\n+            mem::swap(&mut n, &mut self.start);\n+            Some(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match Step::steps_between(&self.start, &self.end, &A::one()) {\n+            Some(hint) => (hint, Some(hint)),\n+            None => (0, None)\n+        }\n+    }\n+}\n+\n+// Ranges of u64 and i64 are excluded because they cannot guarantee having\n+// a length <= usize::MAX, which is required by ExactSizeIterator.\n+range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            self.end = &self.end - &A::one();\n+            Some(self.end.clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let mut n = &self.start + &A::one();\n+        mem::swap(&mut n, &mut self.start);\n+        Some(n)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self, so borrows of self.start and self.end need to end early\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => (None, None), // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(end, A::one())), Some(mem::replace(start, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*start + &one;\n+                    mem::swap(&mut n, start);\n+\n+                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n+                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n+                    // (they are equal now, so it doesn't matter which)\n+                    // to pull out end, we need to swap something back in -- use the previously\n+                    // created A::one() as a dummy value\n+\n+                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    // ^ are we done yet?\n+                    Some(n)) // < the value to output\n+                } else {\n+                    (Some(mem::replace(start, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if this is the last value\n+        if let Some(end) = finishing {\n+            *self = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start, end, &A::one()) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None => (0, None),\n+                }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // see Iterator::next for comments\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => return None,\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(start, A::one())), Some(mem::replace(end, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*end - &one;\n+                    mem::swap(&mut n, end);\n+\n+                    (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                     Some(n))\n+                } else {\n+                    (Some(mem::replace(end, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        if let Some(start) = finishing {\n+            *self = Empty { at: start };\n+        }\n+\n+        n\n+    }\n+}\n+"}, {"sha": "ecd4a78b9e760000686fb8c50f51d7704d8eb31f", "filename": "src/libcore/iter/sources.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=84654fa4bf8e532469787889efa01b59a3c98aa0", "patch": "@@ -0,0 +1,270 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use default::Default;\n+use fmt;\n+use marker;\n+use option::Option::{self, Some, None};\n+use usize;\n+\n+use super::{DoubleEndedIterator, IntoIterator, Iterator, ExactSizeIterator};\n+\n+/// An iterator that repeats an element endlessly.\n+///\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n+///\n+/// [`repeat()`]: fn.repeat.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Repeat<A> {\n+    element: A\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n+}\n+\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over and over and\n+/// over and over and \ud83d\udd01.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`take()`], in order to make them finite.\n+///\n+/// [`take()`]: trait.Iterator.html#method.take\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+    Repeat{element: elt}\n+}\n+\n+/// An iterator that yields nothing.\n+///\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n+///\n+/// [`empty()`]: fn.empty.html\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub struct Empty<T>(marker::PhantomData<T>);\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Iterator for Empty<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>){\n+        (0, Some(0))\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Empty<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Empty<T> {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+// not #[derive] because that adds a Clone bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Clone for Empty<T> {\n+    fn clone(&self) -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+// not #[derive] because that adds a Default bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Default for Empty<T> {\n+    fn default() -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+/// Creates an iterator that yields nothing.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub fn empty<T>() -> Empty<T> {\n+    Empty(marker::PhantomData)\n+}\n+\n+/// An iterator that yields an element exactly once.\n+///\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n+///\n+/// [`once()`]: fn.once.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub struct Once<T> {\n+    inner: ::option::IntoIter<T>\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> Iterator for Once<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Once<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Once<T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+/// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: trait.Iterator.html#method.chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub fn once<T>(value: T) -> Once<T> {\n+    Once { inner: Some(value).into_iter() }\n+}"}, {"sha": "67503984450a45806a3af0bd1f8667397269a058", "filename": "src/libcore/iter/traits.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84654fa4bf8e532469787889efa01b59a3c98aa0/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=84654fa4bf8e532469787889efa01b59a3c98aa0", "patch": "@@ -0,0 +1,526 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::Option::{self, Some};\n+use marker::Sized;\n+\n+use super::Iterator;\n+\n+/// Conversion from an `Iterator`.\n+///\n+/// By implementing `FromIterator` for a type, you define how it will be\n+/// created from an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// `FromIterator`'s [`from_iter()`] is rarely called explicitly, and is instead\n+/// used through [`Iterator`]'s [`collect()`] method. See [`collect()`]'s\n+/// documentation for more examples.\n+///\n+/// [`from_iter()`]: #tymethod.from_iter\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`collect()`]: trait.Iterator.html#method.collect\n+///\n+/// See also: [`IntoIterator`].\n+///\n+/// [`IntoIterator`]: trait.IntoIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v = Vec::from_iter(five_fives);\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Using [`collect()`] to implicitly use `FromIterator`:\n+///\n+/// ```\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v: Vec<i32> = five_fives.collect();\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Implementing `FromIterator` for your type:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement FromIterator\n+/// impl FromIterator<i32> for MyCollection {\n+///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n+///         let mut c = MyCollection::new();\n+///\n+///         for i in iter {\n+///             c.add(i);\n+///         }\n+///\n+///         c\n+///     }\n+/// }\n+///\n+/// // Now we can make a new iterator...\n+/// let iter = (0..5).into_iter();\n+///\n+/// // ... and make a MyCollection out of it\n+/// let c = MyCollection::from_iter(iter);\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+///\n+/// // collect works too!\n+///\n+/// let iter = (0..5).into_iter();\n+/// let c: MyCollection = iter.collect();\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n+                          built from an iterator over elements of type `{A}`\"]\n+pub trait FromIterator<A>: Sized {\n+    /// Creates a value from an iterator.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: trait.FromIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::iter::FromIterator;\n+    ///\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v = Vec::from_iter(five_fives);\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n+}\n+\n+/// Conversion into an `Iterator`.\n+///\n+/// By implementing `IntoIterator` for a type, you define how it will be\n+/// converted to an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// One benefit of implementing `IntoIterator` is that your type will [work\n+/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+///\n+/// See also: [`FromIterator`].\n+///\n+/// [`FromIterator`]: trait.FromIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// let mut iter = v.into_iter();\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(1), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(2), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(3), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(None, n);\n+/// ```\n+///\n+/// Implementing `IntoIterator` for your type:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement IntoIterator\n+/// impl IntoIterator for MyCollection {\n+///     type Item = i32;\n+///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///\n+///     fn into_iter(self) -> Self::IntoIter {\n+///         self.0.into_iter()\n+///     }\n+/// }\n+///\n+/// // Now we can make a new collection...\n+/// let mut c = MyCollection::new();\n+///\n+/// // ... add some stuff to it ...\n+/// c.add(0);\n+/// c.add(1);\n+/// c.add(2);\n+///\n+/// // ... and then turn it into an Iterator:\n+/// for (i, n) in c.into_iter().enumerate() {\n+///     assert_eq!(i as i32, n);\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoIterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Which kind of iterator are we turning this into?\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    /// Creates an iterator from a value.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: trait.IntoIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// let mut iter = v.into_iter();\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(1), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(2), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(3), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(None, n);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+/// Extend a collection with the contents of an iterator.\n+///\n+/// Iterators produce a series of values, and collections can also be thought\n+/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n+/// to extend a collection by including the contents of that iterator.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // You can extend a String with some chars:\n+/// let mut message = String::from(\"The first three letters are: \");\n+///\n+/// message.extend(&['a', 'b', 'c']);\n+///\n+/// assert_eq!(\"abc\", &message[29..32]);\n+/// ```\n+///\n+/// Implementing `Extend`:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // since MyCollection has a list of i32s, we implement Extend for i32\n+/// impl Extend<i32> for MyCollection {\n+///\n+///     // This is a bit simpler with the concrete type signature: we can call\n+///     // extend on anything which can be turned into an Iterator which gives\n+///     // us i32s. Because we need i32s to put into MyCollection.\n+///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n+///\n+///         // The implementation is very straightforward: loop through the\n+///         // iterator, and add() each element to ourselves.\n+///         for elem in iter {\n+///             self.add(elem);\n+///         }\n+///     }\n+/// }\n+///\n+/// let mut c = MyCollection::new();\n+///\n+/// c.add(5);\n+/// c.add(6);\n+/// c.add(7);\n+///\n+/// // let's extend our collection with three more numbers\n+/// c.extend(vec![1, 2, 3]);\n+///\n+/// // we've added these elements onto the end\n+/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Extend<A> {\n+    /// Extends a collection with the contents of an iterator.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.Extend.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // You can extend a String with some chars:\n+    /// let mut message = String::from(\"abc\");\n+    ///\n+    /// message.extend(['d', 'e', 'f'].iter());\n+    ///\n+    /// assert_eq!(\"abcdef\", &message);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n+}\n+\n+/// An iterator able to yield elements from both ends.\n+///\n+/// Something that implements `DoubleEndedIterator` has one extra capability\n+/// over something that implements [`Iterator`]: the ability to also take\n+/// `Item`s from the back, as well as the front.\n+///\n+/// It is important to note that both back and forth work on the same range,\n+/// and do not cross: iteration is over when they meet in the middle.\n+///\n+/// In a similar fashion to the [`Iterator`] protocol, once a\n+/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n+/// may or may not ever return `Some` again. `next()` and `next_back()` are\n+/// interchangable for this purpose.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let numbers = vec![1, 2, 3];\n+///\n+/// let mut iter = numbers.iter();\n+///\n+/// assert_eq!(Some(&1), iter.next());\n+/// assert_eq!(Some(&3), iter.next_back());\n+/// assert_eq!(Some(&2), iter.next_back());\n+/// assert_eq!(None, iter.next());\n+/// assert_eq!(None, iter.next_back());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DoubleEndedIterator: Iterator {\n+    /// An iterator able to yield elements from both ends.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let numbers = vec![1, 2, 3];\n+    ///\n+    /// let mut iter = numbers.iter();\n+    ///\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&3), iter.next_back());\n+    /// assert_eq!(Some(&2), iter.next_back());\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next_back());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next_back(&mut self) -> Option<Self::Item>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n+    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n+}\n+\n+/// An iterator that knows its exact length.\n+///\n+/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n+/// If an iterator knows how many times it can iterate, providing access to\n+/// that information can be useful. For example, if you want to iterate\n+/// backwards, a good start is to know where the end is.\n+///\n+/// When implementing an `ExactSizeIterator`, You must also implement\n+/// [`Iterator`]. When doing so, the implementation of [`size_hint()`] *must*\n+/// return the exact size of the iterator.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`size_hint()`]: trait.Iterator.html#method.size_hint\n+///\n+/// The [`len()`] method has a default implementation, so you usually shouldn't\n+/// implement it. However, you may be able to provide a more performant\n+/// implementation than the default, so overriding it in this case makes sense.\n+///\n+/// [`len()`]: #method.len\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // a finite range knows exactly how many times it will iterate\n+/// let five = 0..5;\n+///\n+/// assert_eq!(5, five.len());\n+/// ```\n+///\n+/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n+/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n+///\n+/// [moddocs]: index.html\n+///\n+/// ```\n+/// # struct Counter {\n+/// #     count: usize,\n+/// # }\n+/// # impl Counter {\n+/// #     fn new() -> Counter {\n+/// #         Counter { count: 0 }\n+/// #     }\n+/// # }\n+/// # impl Iterator for Counter {\n+/// #     type Item = usize;\n+/// #     fn next(&mut self) -> Option<usize> {\n+/// #         self.count += 1;\n+/// #         if self.count < 6 {\n+/// #             Some(self.count)\n+/// #         } else {\n+/// #             None\n+/// #         }\n+/// #     }\n+/// # }\n+/// impl ExactSizeIterator for Counter {\n+///     // We already have the number of iterations, so we can use it directly.\n+///     fn len(&self) -> usize {\n+///         self.count\n+///     }\n+/// }\n+///\n+/// // And now we can use it!\n+///\n+/// let counter = Counter::new();\n+///\n+/// assert_eq!(0, counter.len());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExactSizeIterator: Iterator {\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Returns the exact number of times the iterator will iterate.\n+    ///\n+    /// This method has a default implementation, so you usually should not\n+    /// implement it directly. However, if you can provide a more efficient\n+    /// implementation, you can do so. See the [trait-level] docs for an\n+    /// example.\n+    ///\n+    /// This function has the same safety guarantees as the [`size_hint()`]\n+    /// function.\n+    ///\n+    /// [trait-level]: trait.ExactSizeIterator.html\n+    /// [`size_hint()`]: trait.Iterator.html#method.size_hint\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // a finite range knows exactly how many times it will iterate\n+    /// let five = 0..5;\n+    ///\n+    /// assert_eq!(5, five.len());\n+    /// ```\n+    fn len(&self) -> usize {\n+        let (lower, upper) = self.size_hint();\n+        // Note: This assertion is overly defensive, but it checks the invariant\n+        // guaranteed by the trait. If this trait were rust-internal,\n+        // we could use debug_assert!; assert_eq! will check all Rust user\n+        // implementations too.\n+        assert_eq!(upper, Some(lower));\n+        lower\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n+"}]}