{"sha": "786db7399fa8214aa2412fbeb18033524bfa8b34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NmRiNzM5OWZhODIxNGFhMjQxMmZiZWIxODAzMzUyNGJmYThiMzQ=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T01:28:50Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:40:50Z"}, "message": "Move report_region_errors to region_errors.rs", "tree": {"sha": "77fbe9780bef54374842e733f663be5cb54dac38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77fbe9780bef54374842e733f663be5cb54dac38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786db7399fa8214aa2412fbeb18033524bfa8b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786db7399fa8214aa2412fbeb18033524bfa8b34", "html_url": "https://github.com/rust-lang/rust/commit/786db7399fa8214aa2412fbeb18033524bfa8b34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786db7399fa8214aa2412fbeb18033524bfa8b34/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "736348ac41b00657bd8d5d6b8acae1eeef9985c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/736348ac41b00657bd8d5d6b8acae1eeef9985c7", "html_url": "https://github.com/rust-lang/rust/commit/736348ac41b00657bd8d5d6b8acae1eeef9985c7"}], "stats": {"total": 249, "additions": 125, "deletions": 124}, "files": [{"sha": "5980ff00732538f819c9cab73f704c2f9a0b9e3d", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 123, "deletions": 3, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/786db7399fa8214aa2412fbeb18033524bfa8b34/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786db7399fa8214aa2412fbeb18033524bfa8b34/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=786db7399fa8214aa2412fbeb18033524bfa8b34", "patch": "@@ -1,6 +1,8 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc::infer::{error_reporting::nice_region_error::NiceRegionError, NLLRegionVariableOrigin};\n+use rustc::infer::{\n+    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n+};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -109,8 +111,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// existentially bound, then we check its inferred value and try\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n-    // TODO(mark-i-m): make this private when we move report_region_errors here...\n-    crate fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+    pub(super) fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n         self.to_error_region_vid(r)\n             .and_then(|r| self.nonlexical_regioncx.definitions[r].external_name)\n     }\n@@ -147,6 +148,125 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n+    pub(in crate::borrow_check) fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n+        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n+        // buffered in the `MirBorrowckCtxt`.\n+\n+        // TODO(mark-i-m): Would be great to get rid of the naming context.\n+        let mut region_naming = RegionErrorNamingCtx::new();\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n+\n+        for nll_error in nll_errors.into_iter() {\n+            match nll_error {\n+                RegionErrorKind::TypeTestError { type_test } => {\n+                    // Try to convert the lower-bound region into something named we can print for the user.\n+                    let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+\n+                    // Skip duplicate-ish errors.\n+                    let type_test_span = type_test.locations.span(&self.body);\n+\n+                    if let Some(lower_bound_region) = lower_bound_region {\n+                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                        self.infcx\n+                            .construct_generic_bound_failure(\n+                                region_scope_tree,\n+                                type_test_span,\n+                                None,\n+                                type_test.generic_kind,\n+                                lower_bound_region,\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    } else {\n+                        // FIXME. We should handle this case better. It\n+                        // indicates that we have e.g., some region variable\n+                        // whose value is like `'a+'b` where `'a` and `'b` are\n+                        // distinct unrelated univesal regions that are not\n+                        // known to outlive one another. It'd be nice to have\n+                        // some examples where this arises to decide how best\n+                        // to report it; we could probably handle it by\n+                        // iterating over the universal regions and reporting\n+                        // an error that multiple bounds are required.\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(\n+                                type_test_span,\n+                                &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    }\n+                }\n+\n+                RegionErrorKind::UnexpectedHiddenRegion {\n+                    opaque_type_def_id,\n+                    hidden_ty,\n+                    member_region,\n+                } => {\n+                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    opaque_types::unexpected_hidden_region_diagnostic(\n+                        self.infcx.tcx,\n+                        Some(region_scope_tree),\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                    )\n+                    .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::BoundUniversalRegionError {\n+                    longer_fr,\n+                    fr_origin,\n+                    error_element,\n+                } => {\n+                    let error_region =\n+                        self.nonlexical_regioncx.region_from_element(longer_fr, error_element);\n+\n+                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n+                        &self.body,\n+                        longer_fr,\n+                        fr_origin,\n+                        error_region,\n+                    );\n+\n+                    // FIXME: improve this error message\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .struct_span_err(span, \"higher-ranked subtype error\")\n+                        .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n+                    if is_reported {\n+                        self.report_error(\n+                            longer_fr,\n+                            fr_origin,\n+                            shorter_fr,\n+                            &mut outlives_suggestion,\n+                            &mut region_naming,\n+                        );\n+                    } else {\n+                        // We only report the first error, so as not to overwhelm the user. See\n+                        // `RegRegionErrorKind` docs.\n+                        //\n+                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n+                        // FIXME: try collecting these constraints on the outlives suggestion\n+                        // builder. Does it make the suggestions any better?\n+                        debug!(\n+                            \"Unreported region error: can't prove that {:?}: {:?}\",\n+                            longer_fr, shorter_fr\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Emit one outlives suggestions for each MIR def we borrowck\n+        outlives_suggestion.add_suggestion(self, &mut region_naming);\n+    }\n+\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///"}, {"sha": "22037ac6c81b25780b47a1d74966ccbef658d62c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 121, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/786db7399fa8214aa2412fbeb18033524bfa8b34/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786db7399fa8214aa2412fbeb18033524bfa8b34/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=786db7399fa8214aa2412fbeb18033524bfa8b34", "patch": "@@ -1,6 +1,6 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc::infer::{opaque_types, InferCtxt};\n+use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n@@ -39,9 +39,7 @@ use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n-use self::diagnostics::{\n-    AccessKind, OutlivesSuggestionBuilder, RegionErrorKind, RegionErrorNamingCtx, RegionErrors,\n-};\n+use self::diagnostics::AccessKind;\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -1465,123 +1463,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n-\n-    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n-    fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n-        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n-        // buffered in the `MirBorrowckCtxt`.\n-\n-        // TODO(mark-i-m): Would be great to get rid of the naming context.\n-        let mut region_naming = RegionErrorNamingCtx::new();\n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n-\n-        for nll_error in nll_errors.into_iter() {\n-            match nll_error {\n-                RegionErrorKind::TypeTestError { type_test } => {\n-                    // Try to convert the lower-bound region into something named we can print for the user.\n-                    let lower_bound_region = self.to_error_region(type_test.lower_bound);\n-\n-                    // Skip duplicate-ish errors.\n-                    let type_test_span = type_test.locations.span(&self.body);\n-\n-                    if let Some(lower_bound_region) = lower_bound_region {\n-                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                        self.infcx\n-                            .construct_generic_bound_failure(\n-                                region_scope_tree,\n-                                type_test_span,\n-                                None,\n-                                type_test.generic_kind,\n-                                lower_bound_region,\n-                            )\n-                            .buffer(&mut self.errors_buffer);\n-                    } else {\n-                        // FIXME. We should handle this case better. It indicates that we have\n-                        // e.g., some region variable whose value is like `'a+'b` where `'a` and\n-                        // `'b` are distinct unrelated univesal regions that are not known to\n-                        // outlive one another. It'd be nice to have some examples where this\n-                        // arises to decide how best to report it; we could probably handle it by\n-                        // iterating over the universal regions and reporting an error that\n-                        // multiple bounds are required.\n-                        self.infcx\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(\n-                                type_test_span,\n-                                &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n-                            )\n-                            .buffer(&mut self.errors_buffer);\n-                    }\n-                }\n-\n-                RegionErrorKind::UnexpectedHiddenRegion {\n-                    opaque_type_def_id,\n-                    hidden_ty,\n-                    member_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    opaque_types::unexpected_hidden_region_diagnostic(\n-                        self.infcx.tcx,\n-                        Some(region_scope_tree),\n-                        opaque_type_def_id,\n-                        hidden_ty,\n-                        member_region,\n-                    )\n-                    .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::BoundUniversalRegionError {\n-                    longer_fr,\n-                    fr_origin,\n-                    error_element,\n-                } => {\n-                    let error_region =\n-                        self.nonlexical_regioncx.region_from_element(longer_fr, error_element);\n-\n-                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n-                        &self.body,\n-                        longer_fr,\n-                        fr_origin,\n-                        error_region,\n-                    );\n-\n-                    // FIXME: improve this error message\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, \"higher-ranked subtype error\")\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n-                    if is_reported {\n-                        self.report_error(\n-                            longer_fr,\n-                            fr_origin,\n-                            shorter_fr,\n-                            &mut outlives_suggestion,\n-                            &mut region_naming,\n-                        );\n-                    } else {\n-                        // We only report the first error, so as not to overwhelm the user. See\n-                        // `RegRegionErrorKind` docs.\n-                        //\n-                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n-                        // FIXME: try collecting these constraints on the outlives suggestion\n-                        // builder. Does it make the suggestions any better?\n-                        debug!(\n-                            \"Unreported region error: can't prove that {:?}: {:?}\",\n-                            longer_fr, shorter_fr\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Emit one outlives suggestions for each MIR def we borrowck\n-        outlives_suggestion.add_suggestion(self, &mut region_naming);\n-    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {"}]}