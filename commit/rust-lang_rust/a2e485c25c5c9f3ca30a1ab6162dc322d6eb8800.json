{"sha": "a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "node_id": "C_kwDOAAsO6NoAKGEyZTQ4NWMyNWM1YzlmM2NhMzBhMWFiNjE2MmRjMzIyZDZlYjg4MDA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-11-26T16:47:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-26T16:47:23Z"}, "message": "Rollup merge of #104786 - WaffleLapkin:amp-mut-help, r=compiler-errors\n\nUse the power of adding helper function to simplify code w/ `Mutability`\n\nr? `@compiler-errors`", "tree": {"sha": "71f4fcb4b1cda40d24b76f6f9cf136b5b84ceec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f4fcb4b1cda40d24b76f6f9cf136b5b84ceec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjgkMbCRBK7hj4Ov3rIwAAjdAIAKknCI3T5UqFPcLRuW8oQn1H\nRrLYaLcwy7fRROgGGlUP4tLsOY4iVl1ePZMnxTOSoN9456nX9XUBsQ6b6SPi8TjY\ndKGkZv0bacrUpNu8MLj+DsZGfeHb0eveAULw1oAhe2090MMhjqunxoR+QdJQpfT0\npJtZnDmkzZE8M7pclTpZ2IUs49lx7/6HQIlh6za9LOSpard9t+CEpOcDTdjke3HX\nV8tik76hT0tpE9a5ZI36LKkeu8xCcgdgUu1ki73xvtakoeM28ZVrmHEabN7ZVx3F\nEB3TODh6rgHCe5Dqcgz+qQFDkFp+ujGcH1IQOHoeHCmQoz4tupXr2Bfm8kHa1Zs=\n=jX2y\n-----END PGP SIGNATURE-----\n", "payload": "tree 71f4fcb4b1cda40d24b76f6f9cf136b5b84ceec4\nparent 579c993b35a02dc439b74bba18b0a14f77911c95\nparent e143fa21566b4ff32fe8a140642d8037a03a237f\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1669481243 +0100\ncommitter GitHub <noreply@github.com> 1669481243 +0100\n\nRollup merge of #104786 - WaffleLapkin:amp-mut-help, r=compiler-errors\n\nUse the power of adding helper function to simplify code w/ `Mutability`\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "html_url": "https://github.com/rust-lang/rust/commit/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579c993b35a02dc439b74bba18b0a14f77911c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/579c993b35a02dc439b74bba18b0a14f77911c95", "html_url": "https://github.com/rust-lang/rust/commit/579c993b35a02dc439b74bba18b0a14f77911c95"}, {"sha": "e143fa21566b4ff32fe8a140642d8037a03a237f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e143fa21566b4ff32fe8a140642d8037a03a237f", "html_url": "https://github.com/rust-lang/rust/commit/e143fa21566b4ff32fe8a140642d8037a03a237f"}], "stats": {"total": 362, "additions": 144, "deletions": 218}, "files": [{"sha": "b48a7d29f509723272a4dc77f887edf9cf610fbc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -775,8 +775,9 @@ pub enum PatKind {\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n-    Mut,\n+    // N.B. Order is deliberate, so that Not < Mut\n     Not,\n+    Mut,\n }\n \n impl Mutability {\n@@ -787,12 +788,39 @@ impl Mutability {\n         }\n     }\n \n-    pub fn prefix_str(&self) -> &'static str {\n+    /// Returns `\"\"` (empty string) or `\"mut \"` depending on the mutability.\n+    pub fn prefix_str(self) -> &'static str {\n         match self {\n             Mutability::Mut => \"mut \",\n             Mutability::Not => \"\",\n         }\n     }\n+\n+    /// Returns `\"&\"` or `\"&mut \"` depending on the mutability.\n+    pub fn ref_prefix_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"&\",\n+            Mutability::Mut => \"&mut \",\n+        }\n+    }\n+\n+    /// Returns `\"\"` (empty string) or `\"mutably \"` depending on the mutability.\n+    pub fn mutably_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"\",\n+            Mutability::Mut => \"mutably \",\n+        }\n+    }\n+\n+    /// Return `true` if self is mutable\n+    pub fn is_mut(self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Return `true` if self is **not** mutable\n+    pub fn is_not(self) -> bool {\n+        matches!(self, Self::Not)\n+    }\n }\n \n /// The kind of borrow in an `AddrOf` expression,"}, {"sha": "4ec943f33e230c4b4e4449f594509502759e0a95", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -1781,14 +1781,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, mt)\n-                        if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n-                    {\n-                        hir::ImplicitSelfKind::MutRef\n-                    }\n-                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => {\n-                        hir::ImplicitSelfKind::ImmRef\n-                    }\n+                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => match mt.mutbl {\n+                        hir::Mutability::Not => hir::ImplicitSelfKind::ImmRef,\n+                        hir::Mutability::Mut => hir::ImplicitSelfKind::MutRef,\n+                    },\n                     _ => hir::ImplicitSelfKind::None,\n                 }\n             }),"}, {"sha": "919117651e2db87b6754593ea8b397b03e8fc4b5", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -716,19 +716,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n-                let suggestion = if borrow_level == hir::Mutability::Mut {\n-                    \"&mut \".to_string()\n-                } else {\n-                    \"&\".to_string()\n-                };\n+                let suggestion = borrow_level.ref_prefix_str().to_owned();\n                 (move_span.shrink_to_lo(), suggestion)\n             })\n             .collect();\n         err.multipart_suggestion_verbose(\n-            &format!(\n-                \"consider {}borrowing {value_name}\",\n-                if borrow_level == hir::Mutability::Mut { \"mutably \" } else { \"\" }\n-            ),\n+            format!(\"consider {}borrowing {value_name}\", borrow_level.mutably_str()),\n             sugg,\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "5122f9808ed29e60cf0f70cc6f2db69cf6bd211f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -389,13 +389,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n             PlaceRef { local: _, projection: [] }\n-                if {\n-                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        snippet.starts_with(\"&mut \")\n-                    } else {\n-                        false\n-                    }\n-                } =>\n+                if self\n+                    .infcx\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(span)\n+                    .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_suggestion("}, {"sha": "a6bde88408497ed9d12a7cd28a82966d7fc52439", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -257,9 +257,9 @@ pub(crate) fn data_id_for_alloc_id(\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n     cx.todo.push(TodoItem::Alloc(alloc_id));\n-    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n-    })\n+    *cx.anon_allocs\n+        .entry(alloc_id)\n+        .or_insert_with(|| module.declare_anonymous_data(mutability.is_mut(), false).unwrap())\n }\n \n fn data_id_for_static(\n@@ -343,12 +343,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-                    module\n-                        .declare_anonymous_data(\n-                            alloc.inner().mutability == rustc_hir::Mutability::Mut,\n-                            false,\n-                        )\n-                        .unwrap()\n+                    module.declare_anonymous_data(alloc.inner().mutability.is_mut(), false).unwrap()\n                 });\n                 (data_id, alloc, None)\n             }"}, {"sha": "2f5dd519b2600af5113b40afb83fb0c6ac04d376", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -1500,7 +1500,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n         let (pointer_count, underlying_ty) = match element_ty1.kind() {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl.is_mut() => {\n                 (ptr_count(element_ty1), non_ptr(element_ty1))\n             }\n             _ => {"}, {"sha": "6e2fbf96cbfb3f26aabf1eb23901dffc687d68d8", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -130,10 +130,7 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::REF => match result {\n-                None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n-                _ => {}\n-            },\n+            hir::BindingAnnotation::REF if result.is_none() => result = Some(hir::Mutability::Not),\n             hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });"}, {"sha": "193ecdb1678802b1e3a01371238ae1787a779cc2", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -370,7 +370,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                        mt_b: ty::TypeAndMut<'tcx>,\n                        mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-        if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n+        if mt_a.mutbl < mt_b.mutbl {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types("}, {"sha": "cc5114dba5efefbdb1283de86487177a701094e6", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -292,7 +292,7 @@ fn emit_newtype_suggestion_for_raw_ptr(\n     diag: &mut Diagnostic,\n ) {\n     if !self_ty.needs_subst() {\n-        let mut_key = if ptr_ty.mutbl == rustc_middle::mir::Mutability::Mut { \"mut \" } else { \"\" };\n+        let mut_key = ptr_ty.mutbl.prefix_str();\n         let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n         let sugg = vec![\n             ("}, {"sha": "99a7f52efdb742716f7ced2626359cfeafcb3a5c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -398,7 +398,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(t, m) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -519,7 +519,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ty, m, expr) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);"}, {"sha": "e25a9e9036a15607e6b2000aac8c03f8281eaa63", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -574,8 +574,5 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n fn arms_contain_ref_bindings<'tcx>(arms: &'tcx [hir::Arm<'tcx>]) -> Option<hir::Mutability> {\n-    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max_by_key(|m| match *m {\n-        hir::Mutability::Mut => 1,\n-        hir::Mutability::Not => 0,\n-    })\n+    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max()\n }"}, {"sha": "1c14c1d35f7997ef026f08ed22134a100f6ae75f", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -257,15 +257,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return None;\n                     };\n \n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded function call ops.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n+                    // For initial two-phase borrow\n+                    // deployment, conservatively omit\n+                    // overloaded function call ops.\n+                    let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::No);\n+\n                     autoref = Some(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                         target: method.sig.inputs()[0],"}, {"sha": "1cea8c9dadce3e32e9d51f478bb163871ecdef6f", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -951,7 +951,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         m_cast: ty::TypeAndMut<'tcx>,\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast: allow mut-to-mut, mut-to-const, const-to-const\n-        if m_expr.mutbl == hir::Mutability::Mut || m_cast.mutbl == hir::Mutability::Not {\n+        if m_expr.mutbl >= m_cast.mutbl {\n             if let ty::Array(ety, _) = m_expr.ty.kind() {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "1ceb07def72e7f15f7091f90b558145803c8c7a1", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -202,7 +202,7 @@ fn check_panic_info_fn(\n     let arg_is_panic_info = match *inputs[0].kind() {\n         ty::Ref(region, ty, mutbl) => match *ty.kind() {\n             ty::Adt(ref adt, _) => {\n-                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n+                adt.did() == panic_info_did && mutbl.is_not() && !region.is_static()\n             }\n             _ => false,\n         },"}, {"sha": "6b6d54db5062f0b3623fa02e338402231d25a59b", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -108,11 +108,7 @@ fn coerce_mutbls<'tcx>(\n     from_mutbl: hir::Mutability,\n     to_mutbl: hir::Mutability,\n ) -> RelateResult<'tcx, ()> {\n-    match (from_mutbl, to_mutbl) {\n-        (hir::Mutability::Mut, hir::Mutability::Mut | hir::Mutability::Not)\n-        | (hir::Mutability::Not, hir::Mutability::Not) => Ok(()),\n-        (hir::Mutability::Not, hir::Mutability::Mut) => Err(TypeError::Mutability),\n-    }\n+    if from_mutbl >= to_mutbl { Ok(()) } else { Err(TypeError::Mutability) }\n }\n \n /// Do not require any adjustments, i.e. coerce `x -> x`.\n@@ -456,7 +452,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return Err(err);\n         };\n \n-        if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl.is_not() && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -468,7 +464,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mutbl_b, hir::Mutability::Not); // can only coerce &T -> &U\n+            assert!(mutbl_b.is_not()); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -482,12 +478,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let ty::Ref(r_borrow, _, _) = ty.kind() else {\n             span_bug!(span, \"expected a ref type, got {:?}\", ty);\n         };\n-        let mutbl = match mutbl_b {\n-            hir::Mutability::Not => AutoBorrowMutability::Not,\n-            hir::Mutability::Mut => {\n-                AutoBorrowMutability::Mut { allow_two_phase_borrow: self.allow_two_phase }\n-            }\n-        };\n+        let mutbl = AutoBorrowMutability::new(mutbl_b, self.allow_two_phase);\n         adjustments.push(Adjustment {\n             kind: Adjust::Borrow(AutoBorrow::Ref(*r_borrow, mutbl)),\n             target: ty,\n@@ -556,15 +547,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                let mutbl = match mutbl_b {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // We don't allow two-phase borrows here, at least for initial\n-                        // implementation. If it happens that this coercion is a function argument,\n-                        // the reborrow in coerce_borrowed_ptr will pick it up.\n-                        allow_two_phase_borrow: AllowTwoPhase::No,\n-                    },\n-                };\n+\n+                // We don't allow two-phase borrows here, at least for initial\n+                // implementation. If it happens that this coercion is a function argument,\n+                // the reborrow in coerce_borrowed_ptr will pick it up.\n+                let mutbl = AutoBorrowMutability::new(mutbl_b, AllowTwoPhase::No);\n+\n                 Some((\n                     Adjustment { kind: Adjust::Deref(None), target: ty_a },\n                     Adjustment {"}, {"sha": "2106dce6f407ed2e03dd901732798e2e08e4a28b", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 29, "deletions": 68, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -19,6 +19,7 @@ use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n \n+use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -855,31 +856,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {\n-                            if mutability == hir::Mutability::Mut {\n+                            if mutability.is_mut() {\n                                 // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n                                 return None;\n                             }\n                         }\n \n                         let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n-                        return Some(match mutability {\n-                            hir::Mutability::Mut => (\n-                                sp,\n-                                \"consider mutably borrowing here\".to_string(),\n-                                format!(\"{prefix}&mut {sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                            hir::Mutability::Not => (\n-                                sp,\n-                                \"consider borrowing here\".to_string(),\n-                                format!(\"{prefix}&{sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                        });\n+                        return Some((\n+                            sp,\n+                            format!(\"consider {}borrowing here\", mutability.mutably_str()),\n+                            format!(\"{prefix}{}{sugg_expr}\", mutability.ref_prefix_str()),\n+                            Applicability::MachineApplicable,\n+                            false,\n+                            false,\n+                        ));\n                     }\n                 }\n             }\n@@ -937,51 +928,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && let Ok(src) = sm.span_to_snippet(sp)\n                 {\n                     let derefs = \"*\".repeat(steps);\n-                    if let Some((span, src, applicability)) = match mutbl_b {\n-                        hir::Mutability::Mut => {\n-                            let new_prefix = \"&mut \".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (\n-                                            sp,\n-                                            format!(\"mut {derefs}\"),\n-                                            Applicability::Unspecified,\n-                                        )\n-                                    })\n-                                }\n-                            }\n-                        }\n-                        hir::Mutability::Not => {\n-                            let new_prefix = \"&\".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let lo = sp.lo() + BytePos(1);\n-                                        let hi = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(lo).with_hi(hi);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    } {\n+                    let old_prefix = mutbl_a.ref_prefix_str();\n+                    let new_prefix = mutbl_b.ref_prefix_str().to_owned() + &derefs;\n+\n+                    let suggestion = replace_prefix(&src, old_prefix, &new_prefix).map(|_| {\n+                        // skip `&` or `&mut ` if both mutabilities are mutable\n+                        let lo = sp.lo() + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n+                        // skip `&` or `&mut `\n+                        let hi = sp.lo() + BytePos(old_prefix.len() as _);\n+                        let sp = sp.with_lo(lo).with_hi(hi);\n+\n+                        (\n+                            sp,\n+                            format!(\"{}{derefs}\", if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }),\n+                            if mutbl_b <= mutbl_a { Applicability::MachineApplicable } else { Applicability::MaybeIncorrect }\n+                        )\n+                    });\n+\n+                    if let Some((span, src, applicability)) = suggestion {\n                         return Some((\n                             span,\n                             \"consider dereferencing\".to_string(),\n@@ -1005,10 +969,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If the expression has `&`, removing it would fix the error\n                             prefix_span = prefix_span.with_hi(inner.span.lo());\n                             expr = inner;\n-                            remove += match mutbl {\n-                                hir::Mutability::Not => \"&\",\n-                                hir::Mutability::Mut => \"&mut \",\n-                            };\n+                            remove.push_str(mutbl.ref_prefix_str());\n                             steps -= 1;\n                         } else {\n                             break;"}, {"sha": "25fdf31d53f01a065ad0931d3a4ab0f338fbd3ca", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -345,8 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, _) => mutbl.ref_prefix_str(),\n                     _ => return true,\n                 };\n                 let mut tuple_indexes = Vec::new();"}, {"sha": "f50a16dcb236d58c640fd316a03d27090b1293ff", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -170,14 +170,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 let base_ty = target;\n \n                 target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n-                let mutbl = match mutbl {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // Method call receivers are the primary use case\n-                        // for two-phase borrows.\n-                        allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                    },\n-                };\n+\n+                // Method call receivers are the primary use case\n+                // for two-phase borrows.\n+                let mutbl = AutoBorrowMutability::new(mutbl, AllowTwoPhase::Yes);\n+\n                 adjustments.push(Adjustment {\n                     kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                     target,\n@@ -202,7 +199,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n                 target = match target.kind() {\n                     &ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n-                        assert_eq!(mutbl, hir::Mutability::Mut);\n+                        assert!(mutbl.is_mut());\n                         self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n                     }\n                     other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),"}, {"sha": "dea14dd93d6acd15e0ec4199ad0f677b5461ce6b", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -5,7 +5,6 @@ use crate::{\n use hir::def_id::DefId;\n use hir::HirId;\n use hir::ItemKind;\n-use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -88,14 +87,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let derefs = \"*\".repeat(pick.autoderefs);\n \n                     let autoref = match pick.autoref_or_ptr_adjustment {\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Mut,\n-                            ..\n-                        }) => \"&mut \",\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Not,\n-                            ..\n-                        }) => \"&\",\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => {\n+                            mutbl.ref_prefix_str()\n+                        }\n                         Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n                     };\n                     if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n@@ -386,8 +380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let derefs = \"*\".repeat(pick.autoderefs);\n \n         let autoref = match pick.autoref_or_ptr_adjustment {\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Mut, .. }) => \"&mut \",\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Not, .. }) => \"&\",\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => mutbl.ref_prefix_str(),\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n         };\n "}, {"sha": "9814d3a9dd5a0de2324054e464a84afb86c2f721", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -1147,19 +1147,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && assoc.kind == ty::AssocKind::Fn\n             {\n                 let sig = self.tcx.fn_sig(assoc.def_id);\n-                if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                    if first.peel_refs() == rcvr_ty.peel_refs() {\n-                        None\n-                    } else {\n-                        Some(if first.is_region_ptr() {\n-                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                        } else {\n-                            \"\"\n-                        })\n-                    }\n-                } else {\n+                sig.inputs().skip_binder().get(0).and_then(|first| if first.peel_refs() == rcvr_ty.peel_refs() {\n                     None\n-                }\n+                } else {\n+                    Some(first.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()))\n+                })\n             } else {\n                 None\n             };\n@@ -2627,11 +2619,7 @@ fn print_disambiguation_help<'tcx>(\n     let (span, sugg) = if let (ty::AssocKind::Fn, Some((receiver, args))) = (kind, args) {\n         let args = format!(\n             \"({}{})\",\n-            if rcvr_ty.is_region_ptr() {\n-                if rcvr_ty.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-            } else {\n-                \"\"\n-            },\n+            rcvr_ty.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()),\n             std::iter::once(receiver)\n                 .chain(args.iter())\n                 .map(|arg| source_map.span_to_snippet(arg.span).unwrap_or_else(|_| {"}, {"sha": "b12d84af4adbca81f0e04f1b7e36e092c70a872f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -263,14 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[0],\n@@ -280,14 +273,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        // Allow two-phase borrows for binops in initial deployment\n+                        // since they desugar to methods\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n+\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[1],"}, {"sha": "decd317d9fc9b1e3a8943e9419bd0dedbb66e5eb", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -702,7 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n             let mut_var_suggestion = 'block: {\n-                if !matches!(mutbl, ast::Mutability::Mut) {\n+                if mutbl.is_not() {\n                     break 'block None;\n                 }\n \n@@ -749,7 +749,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"to take parameter `{binding}` by reference, move `&{mutability}` to the type\"),\n                         vec![\n                             (pat.span.until(inner.span), \"\".to_owned()),\n-                            (ty_span.shrink_to_lo(), format!(\"&{}\", mutbl.prefix_str())),\n+                            (ty_span.shrink_to_lo(), mutbl.ref_prefix_str().to_owned()),\n                         ],\n                         Applicability::MachineApplicable\n                     );"}, {"sha": "31235ce191832023d042df69c7671cc33372200e", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Body, Closure, Expr, ExprKind, FnRetTy, HirId, Local, LocalSource};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n@@ -508,10 +508,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     [\n                         ..,\n                         Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mut_)), target: _ },\n-                    ] => match mut_ {\n-                        AutoBorrowMutability::Mut { .. } => \"&mut \",\n-                        AutoBorrowMutability::Not => \"&\",\n-                    },\n+                    ] => hir::Mutability::from(*mut_).ref_prefix_str(),\n                     _ => \"\",\n                 };\n "}, {"sha": "7fb8ed8c233521183055846f60937d925b2ce031", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -1268,10 +1268,10 @@ declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n+        if let Some((&ty::Ref(_, _, from_mutbl), &ty::Ref(_, _, to_mutbl))) =\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n-            if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+            if from_mutbl < to_mutbl {\n                 cx.struct_span_lint(\n                     MUTABLE_TRANSMUTES,\n                     expr.span,"}, {"sha": "7036c4a7b27d60b8da7772a1e575c33297736d4d", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -159,6 +159,18 @@ pub enum AutoBorrowMutability {\n     Not,\n }\n \n+impl AutoBorrowMutability {\n+    /// Creates an `AutoBorrowMutability` from a mutability and allowance of two phase borrows.\n+    ///\n+    /// Note that when `mutbl.is_not()`, `allow_two_phase_borrow` is ignored\n+    pub fn new(mutbl: hir::Mutability, allow_two_phase_borrow: AllowTwoPhase) -> Self {\n+        match mutbl {\n+            hir::Mutability::Not => Self::Not,\n+            hir::Mutability::Mut => Self::Mut { allow_two_phase_borrow },\n+        }\n+    }\n+}\n+\n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {"}, {"sha": "74048ff7da3bdd0c5edf1075a75f693728ad066c", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -169,7 +169,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let mut prefix = \"&\".to_owned();\n                 prefix.push_str(&lifetime.name.ident().to_string());\n                 prefix.push(' ');\n-                if let hir::Mutability::Mut = mt.mutbl {\n+                if mt.mutbl.is_mut() {\n                     prefix.push_str(\"mut \");\n                 };\n \n@@ -332,7 +332,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n         match self.kind {\n             hir::ItemKind::Static(ref ty, m, ref body) => {\n                 let mut text = \"static \".to_owned();\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();"}, {"sha": "2cca480f271c73331046c25302e291f9e26e58ad", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -622,7 +622,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 });\n \n                 match inner_ty.kind() {\n-                    ty::Str if *mutbl == hir::Mutability::Not => {\n+                    ty::Str if mutbl.is_not() => {\n                         match ct.kind() {\n                             ty::ConstKind::Value(valtree) => {\n                                 let slice ="}, {"sha": "da6ca30cc9a32edab5cee65eabe8b8dc9a79d30a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a2e485c25c5c9f3ca30a1ab6162dc322d6eb8800", "patch": "@@ -1055,7 +1055,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     (\n                         mk_result(old_pred.map_bound(|trait_pred| (trait_pred, *ty))),\n-                        matches!(mutability, hir::Mutability::Mut),\n+                        mutability.is_mut(),\n                     )\n                 } else {\n                     (false, false)\n@@ -1344,7 +1344,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         .sess\n                         .source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n-                    if points_at_arg && mutability == hir::Mutability::Not && refs_number > 0 {\n+                    if points_at_arg && mutability.is_not() && refs_number > 0 {\n                         err.span_suggestion_verbose(\n                             sp,\n                             \"consider changing this borrow's mutability\","}]}