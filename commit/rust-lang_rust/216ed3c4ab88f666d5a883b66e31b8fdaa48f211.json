{"sha": "216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNmVkM2M0YWI4OGY2NjZkNWE4ODNiNjZlMzFiOGZkYWE0OGYyMTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-22T16:29:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-22T16:29:05Z"}, "message": "Rollup merge of #74237 - lzutao:compiletest, r=Mark-Simulacrum\n\ncompiletest: Rewrite extract_*_version functions\n\nThis makes extract_lldb_version has the same version type like\nextract_gdb_version.", "tree": {"sha": "c8937f6743b56f1e1793ca9d3a44721560fd8296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8937f6743b56f1e1793ca9d3a44721560fd8296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGGlSCRBK7hj4Ov3rIwAAdHIIAKCs5VXljkMDqX9dLNYfyvO7\neeBaAPNWVAJ2mauiBFHdA/ke1XHdr2QJ8TAH0fBCUqTZbKjEsEScW2ZeILLEMwYU\nJogpERJli3sgYqcDAuHPbZYuNKba5Bd9XMU06AumxETu4a8vvWV+cpd4GBDPGUDo\ne789OcrB0nK9vR4RLZLE/Z/eYuRYYeXJHLfugre/aGWSMSjnAIbEaLhgrPgFfZrM\n0+1dOw7wtPJ9UD7fxQ4XFD380YACxG7uA5vvUkMdOfQTVV3s28QzBQjJ3PYfuerZ\ndIRi1zkxfuR+2c0Cn31vLLM5fHvH3eAMQSxx4F8XFP4+Zr5EZYBNS17S1/1lY8k=\n=+UCO\n-----END PGP SIGNATURE-----\n", "payload": "tree c8937f6743b56f1e1793ca9d3a44721560fd8296\nparent 8afb305e7200b05dacf6129e2c10575f4ca6ebb0\nparent 1314d31fb5974e8c32aa8d695a02d37c4ab4bd7e\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595435345 -0700\ncommitter GitHub <noreply@github.com> 1595435345 -0700\n\nRollup merge of #74237 - lzutao:compiletest, r=Mark-Simulacrum\n\ncompiletest: Rewrite extract_*_version functions\n\nThis makes extract_lldb_version has the same version type like\nextract_gdb_version.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "html_url": "https://github.com/rust-lang/rust/commit/216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8afb305e7200b05dacf6129e2c10575f4ca6ebb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8afb305e7200b05dacf6129e2c10575f4ca6ebb0", "html_url": "https://github.com/rust-lang/rust/commit/8afb305e7200b05dacf6129e2c10575f4ca6ebb0"}, {"sha": "1314d31fb5974e8c32aa8d695a02d37c4ab4bd7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1314d31fb5974e8c32aa8d695a02d37c4ab4bd7e", "html_url": "https://github.com/rust-lang/rust/commit/1314d31fb5974e8c32aa8d695a02d37c4ab4bd7e"}], "stats": {"total": 461, "additions": 208, "deletions": 253}, "files": [{"sha": "7c61b7809901f81c7f67d1d7c0b45ee5489fffe4", "filename": "src/test/codegen/abi-efiapi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -2,7 +2,7 @@\n \n // revisions:x86_64 i686 arm\n \n-// min-llvm-version 9.0\n+// min-llvm-version: 9.0\n \n //[x86_64] compile-flags: --target x86_64-unknown-uefi\n //[i686] compile-flags: --target i686-unknown-linux-musl"}, {"sha": "eba4a7469f9308d2ade0946fdaa1d916cc82e6e0", "filename": "src/test/codegen/force-unwind-tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -1,4 +1,4 @@\n-// min-llvm-version 8.0\n+// min-llvm-version: 8.0\n // compile-flags: -C no-prepopulate-passes -C force-unwind-tables=y\n \n #![crate_type=\"lib\"]"}, {"sha": "a5d5942b539539861978d420ba2bd61630c7a591", "filename": "src/test/debuginfo/function-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Ffunction-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Ffunction-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-call.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -1,5 +1,5 @@\n // This test does not passed with gdb < 8.0. See #53497.\n-// min-gdb-version 8.0\n+// min-gdb-version: 8.0\n \n // compile-flags:-g\n "}, {"sha": "cbd2278f7e27c863f3dd5211e5022f82afc5f0a3", "filename": "src/test/debuginfo/pretty-huge-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -2,7 +2,7 @@\n // ignore-freebsd: gdb package too new\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// min-gdb-version 8.1\n+// min-gdb-version: 8.1\n // min-lldb-version: 310\n \n // === GDB TESTS ==================================================================================="}, {"sha": "a4fbff5725c97aa20bbf0694a219199d597384c4", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -6,7 +6,7 @@\n \n // The pretty printers being tested here require the patch from\n // https://sourceware.org/bugzilla/show_bug.cgi?id=21763\n-// min-gdb-version 8.1\n+// min-gdb-version: 8.1\n \n // min-lldb-version: 310\n "}, {"sha": "7ae82d522b09dc37dfe588b52b7da46a4d428501", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -2,7 +2,7 @@\n // only-cdb // \"Temporarily\" ignored on GDB/LLDB due to debuginfo tests being disabled, see PR 47155\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// min-gdb-version 7.7\n+// min-gdb-version: 7.7\n // min-lldb-version: 310\n \n // === GDB TESTS ==================================================================================="}, {"sha": "61791f48f4db76683adde4dcbacbed0038a72015", "filename": "src/test/debuginfo/pretty-uninitialized-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -2,7 +2,7 @@\n // ignore-freebsd: gdb package too new\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// min-gdb-version 8.1\n+// min-gdb-version: 8.1\n // min-lldb-version: 310\n \n // === GDB TESTS ==================================================================================="}, {"sha": "9439df266d59bbe6c7da7b1d0a822e3462f55917", "filename": "src/test/ui/sanitize/new-llvm-pass-manager-thin-lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -2,7 +2,7 @@\n // being run when compiling with new LLVM pass manager and ThinLTO.\n // Note: The issue occurred only on non-zero opt-level.\n //\n-// min-llvm-version 9.0\n+// min-llvm-version: 9.0\n // needs-sanitizer-support\n // needs-sanitizer-address\n //"}, {"sha": "9269a63b41aab9d29f3904c534b6538e213cd4bc", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -271,13 +271,13 @@ pub struct Config {\n     pub gdb_native_rust: bool,\n \n     /// Version of LLDB\n-    pub lldb_version: Option<String>,\n+    pub lldb_version: Option<u32>,\n \n     /// Whether LLDB has native rust support\n     pub lldb_native_rust: bool,\n \n     /// Version of LLVM\n-    pub llvm_version: Option<String>,\n+    pub llvm_version: Option<u32>,\n \n     /// Is LLVM a system LLVM\n     pub system_llvm: bool,"}, {"sha": "2ab764eb9207c4fc96680aa20e99a1caac67e39d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 88, "deletions": 105, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -132,72 +132,46 @@ impl EarlyProps {\n \n         fn ignore_gdb(config: &Config, line: &str) -> bool {\n             if let Some(actual_version) = config.gdb_version {\n-                if line.starts_with(\"min-gdb-version\") {\n-                    let (start_ver, end_ver) = extract_gdb_version_range(line);\n+                if let Some(rest) = line.strip_prefix(\"min-gdb-version:\").map(str::trim) {\n+                    let (start_ver, end_ver) = extract_version_range(rest, extract_gdb_version)\n+                        .unwrap_or_else(|| {\n+                            panic!(\"couldn't parse version range: {:?}\", rest);\n+                        });\n \n                     if start_ver != end_ver {\n                         panic!(\"Expected single GDB version\")\n                     }\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    actual_version < start_ver\n-                } else if line.starts_with(\"ignore-gdb-version\") {\n-                    let (min_version, max_version) = extract_gdb_version_range(line);\n+                    return actual_version < start_ver;\n+                } else if let Some(rest) = line.strip_prefix(\"ignore-gdb-version:\").map(str::trim) {\n+                    let (min_version, max_version) =\n+                        extract_version_range(rest, extract_gdb_version).unwrap_or_else(|| {\n+                            panic!(\"couldn't parse version range: {:?}\", rest);\n+                        });\n \n                     if max_version < min_version {\n                         panic!(\"Malformed GDB version range: max < min\")\n                     }\n \n-                    actual_version >= min_version && actual_version <= max_version\n-                } else {\n-                    false\n-                }\n-            } else {\n-                false\n-            }\n-        }\n-\n-        // Takes a directive of the form \"ignore-gdb-version <version1> [- <version2>]\",\n-        // returns the numeric representation of <version1> and <version2> as\n-        // tuple: (<version1> as u32, <version2> as u32)\n-        // If the <version2> part is omitted, the second component of the tuple\n-        // is the same as <version1>.\n-        fn extract_gdb_version_range(line: &str) -> (u32, u32) {\n-            const ERROR_MESSAGE: &'static str = \"Malformed GDB version directive\";\n-\n-            let range_components = line\n-                .split(&[' ', '-'][..])\n-                .filter(|word| !word.is_empty())\n-                .map(extract_gdb_version)\n-                .skip_while(Option::is_none)\n-                .take(3) // 3 or more = invalid, so take at most 3.\n-                .collect::<Vec<Option<u32>>>();\n-\n-            match range_components.len() {\n-                1 => {\n-                    let v = range_components[0].unwrap();\n-                    (v, v)\n-                }\n-                2 => {\n-                    let v_min = range_components[0].unwrap();\n-                    let v_max = range_components[1].expect(ERROR_MESSAGE);\n-                    (v_min, v_max)\n+                    return actual_version >= min_version && actual_version <= max_version;\n                 }\n-                _ => panic!(ERROR_MESSAGE),\n             }\n+            false\n         }\n \n         fn ignore_lldb(config: &Config, line: &str) -> bool {\n-            if let Some(ref actual_version) = config.lldb_version {\n-                if line.starts_with(\"min-lldb-version\") {\n-                    let min_version = line\n-                        .trim_end()\n-                        .rsplit(' ')\n-                        .next()\n-                        .expect(\"Malformed lldb version directive\");\n+            if let Some(actual_version) = config.lldb_version {\n+                if let Some(min_version) = line.strip_prefix(\"min-lldb-version:\").map(str::trim) {\n+                    let min_version = min_version.parse().unwrap_or_else(|e| {\n+                        panic!(\n+                            \"Unexpected format of LLDB version string: {}\\n{:?}\",\n+                            min_version, e\n+                        );\n+                    });\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    lldb_version_to_int(actual_version) < lldb_version_to_int(min_version)\n+                    actual_version < min_version\n                 } else if line.starts_with(\"rust-lldb\") && !config.lldb_native_rust {\n                     true\n                 } else {\n@@ -212,69 +186,38 @@ impl EarlyProps {\n             if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n                 return true;\n             }\n-            if let Some(ref actual_version) = config.llvm_version {\n-                let actual_version = version_to_int(actual_version);\n-                if line.starts_with(\"min-llvm-version\") {\n-                    let min_version = line\n-                        .trim_end()\n-                        .rsplit(' ')\n-                        .next()\n-                        .expect(\"Malformed llvm version directive\");\n+            if let Some(actual_version) = config.llvm_version {\n+                if let Some(rest) = line.strip_prefix(\"min-llvm-version:\").map(str::trim) {\n+                    let min_version = extract_llvm_version(rest).unwrap();\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    actual_version < version_to_int(min_version)\n-                } else if line.starts_with(\"min-system-llvm-version\") {\n-                    let min_version = line\n-                        .trim_end()\n-                        .rsplit(' ')\n-                        .next()\n-                        .expect(\"Malformed llvm version directive\");\n+                    actual_version < min_version\n+                } else if let Some(rest) =\n+                    line.strip_prefix(\"min-system-llvm-version:\").map(str::trim)\n+                {\n+                    let min_version = extract_llvm_version(rest).unwrap();\n                     // Ignore if using system LLVM and actual version\n                     // is smaller the minimum required version\n-                    config.system_llvm && actual_version < version_to_int(min_version)\n-                } else if line.starts_with(\"ignore-llvm-version\") {\n-                    // Syntax is: \"ignore-llvm-version <version1> [- <version2>]\"\n-                    let range_components = line\n-                        .split(' ')\n-                        .skip(1) // Skip the directive.\n-                        .map(|s| s.trim())\n-                        .filter(|word| !word.is_empty() && word != &\"-\")\n-                        .take(3) // 3 or more = invalid, so take at most 3.\n-                        .collect::<Vec<&str>>();\n-                    match range_components.len() {\n-                        1 => actual_version == version_to_int(range_components[0]),\n-                        2 => {\n-                            let v_min = version_to_int(range_components[0]);\n-                            let v_max = version_to_int(range_components[1]);\n-                            if v_max < v_min {\n-                                panic!(\"Malformed LLVM version range: max < min\")\n-                            }\n-                            // Ignore if version lies inside of range.\n-                            actual_version >= v_min && actual_version <= v_max\n-                        }\n-                        _ => panic!(\"Malformed LLVM version directive\"),\n+                    config.system_llvm && actual_version < min_version\n+                } else if let Some(rest) = line.strip_prefix(\"ignore-llvm-version:\").map(str::trim)\n+                {\n+                    // Syntax is: \"ignore-llvm-version: <version1> [- <version2>]\"\n+                    let (v_min, v_max) = extract_version_range(rest, extract_llvm_version)\n+                        .unwrap_or_else(|| {\n+                            panic!(\"couldn't parse version range: {:?}\", rest);\n+                        });\n+                    if v_max < v_min {\n+                        panic!(\"Malformed LLVM version range: max < min\")\n                     }\n+                    // Ignore if version lies inside of range.\n+                    actual_version >= v_min && actual_version <= v_max\n                 } else {\n                     false\n                 }\n             } else {\n                 false\n             }\n         }\n-\n-        fn version_to_int(version: &str) -> u32 {\n-            let version_without_suffix = version.trim_end_matches(\"git\").split('-').next().unwrap();\n-            let components: Vec<u32> = version_without_suffix\n-                .split('.')\n-                .map(|s| s.parse().expect(\"Malformed version component\"))\n-                .collect();\n-            match components.len() {\n-                1 => components[0] * 10000,\n-                2 => components[0] * 10000 + components[1] * 100,\n-                3 => components[0] * 10000 + components[1] * 100 + components[2],\n-                _ => panic!(\"Malformed version\"),\n-            }\n-        }\n     }\n }\n \n@@ -944,12 +887,6 @@ impl Config {\n     }\n }\n \n-pub fn lldb_version_to_int(version_string: &str) -> isize {\n-    let error_string =\n-        format!(\"Encountered LLDB version string with unexpected format: {}\", version_string);\n-    version_string.parse().expect(&error_string)\n-}\n-\n fn expand_variables(mut value: String, config: &Config) -> String {\n     const CWD: &'static str = \"{{cwd}}\";\n     const SRC_BASE: &'static str = \"{{src-base}}\";\n@@ -990,3 +927,49 @@ fn parse_normalization_string(line: &mut &str) -> Option<String> {\n     *line = &line[end + 1..];\n     Some(result)\n }\n+\n+pub fn extract_llvm_version(version: &str) -> Option<u32> {\n+    let version_without_suffix = version.trim_end_matches(\"git\").split('-').next().unwrap();\n+    let components: Vec<u32> = version_without_suffix\n+        .split('.')\n+        .map(|s| s.parse().expect(\"Malformed version component\"))\n+        .collect();\n+    let version = match *components {\n+        [a] => a * 10_000,\n+        [a, b] => a * 10_000 + b * 100,\n+        [a, b, c] => a * 10_000 + b * 100 + c,\n+        _ => panic!(\"Malformed version\"),\n+    };\n+    Some(version)\n+}\n+\n+// Takes a directive of the form \"<version1> [- <version2>]\",\n+// returns the numeric representation of <version1> and <version2> as\n+// tuple: (<version1> as u32, <version2> as u32)\n+// If the <version2> part is omitted, the second component of the tuple\n+// is the same as <version1>.\n+fn extract_version_range<F>(line: &str, parse: F) -> Option<(u32, u32)>\n+where\n+    F: Fn(&str) -> Option<u32>,\n+{\n+    let mut splits = line.splitn(2, \"- \").map(str::trim);\n+    let min = splits.next().unwrap();\n+    if min.ends_with('-') {\n+        return None;\n+    }\n+\n+    let max = splits.next();\n+\n+    if min.is_empty() {\n+        return None;\n+    }\n+\n+    let min = parse(min)?;\n+    let max = match max {\n+        Some(max) if max.is_empty() => return None,\n+        Some(max) => parse(max)?,\n+        _ => min,\n+    };\n+\n+    Some((min, max))\n+}"}, {"sha": "1f82b137ee6cf1fb312375882c9fbc4e64678157", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -119,17 +119,17 @@ fn no_system_llvm() {\n fn llvm_version() {\n     let mut config = config();\n \n-    config.llvm_version = Some(\"8.1.2-rust\".to_owned());\n-    assert!(parse_rs(&config, \"// min-llvm-version 9.0\").ignore);\n+    config.llvm_version = Some(80102);\n+    assert!(parse_rs(&config, \"// min-llvm-version: 9.0\").ignore);\n \n-    config.llvm_version = Some(\"9.0.1-rust-1.43.0-dev\".to_owned());\n-    assert!(parse_rs(&config, \"// min-llvm-version 9.2\").ignore);\n+    config.llvm_version = Some(90001);\n+    assert!(parse_rs(&config, \"// min-llvm-version: 9.2\").ignore);\n \n-    config.llvm_version = Some(\"9.3.1-rust-1.43.0-dev\".to_owned());\n-    assert!(!parse_rs(&config, \"// min-llvm-version 9.2\").ignore);\n+    config.llvm_version = Some(90301);\n+    assert!(!parse_rs(&config, \"// min-llvm-version: 9.2\").ignore);\n \n-    config.llvm_version = Some(\"10.0.0-rust\".to_owned());\n-    assert!(!parse_rs(&config, \"// min-llvm-version 9.0\").ignore);\n+    config.llvm_version = Some(100000);\n+    assert!(!parse_rs(&config, \"// min-llvm-version: 9.0\").ignore);\n }\n \n #[test]\n@@ -220,3 +220,18 @@ fn sanitizers() {\n     assert!(parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n     assert!(parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n }\n+\n+#[test]\n+fn test_extract_version_range() {\n+    use super::{extract_llvm_version, extract_version_range};\n+\n+    assert_eq!(extract_version_range(\"1.2.3 - 4.5.6\", extract_llvm_version), Some((10203, 40506)));\n+    assert_eq!(extract_version_range(\"0   - 4.5.6\", extract_llvm_version), Some((0, 40506)));\n+    assert_eq!(extract_version_range(\"1.2.3 -\", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\"1.2.3 - \", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\"- 4.5.6\", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\"-\", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\" - 4.5.6\", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\"   - 4.5.6\", extract_llvm_version), None);\n+    assert_eq!(extract_version_range(\"0  -\", extract_llvm_version), None);\n+}"}, {"sha": "bf3510ea0894bfeb74b01b7de1a5fb731dbdc61d", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 66, "deletions": 129, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -166,14 +166,20 @@ pub fn parse_config(args: Vec<String>) -> Config {\n     let cdb = analyze_cdb(matches.opt_str(\"cdb\"), &target);\n     let (gdb, gdb_version, gdb_native_rust) =\n         analyze_gdb(matches.opt_str(\"gdb\"), &target, &android_cross_path);\n-    let (lldb_version, lldb_native_rust) = extract_lldb_version(matches.opt_str(\"lldb-version\"));\n-\n-    let color = match matches.opt_str(\"color\").as_ref().map(|x| &**x) {\n+    let (lldb_version, lldb_native_rust) = matches\n+        .opt_str(\"lldb-version\")\n+        .as_deref()\n+        .and_then(extract_lldb_version)\n+        .map(|(v, b)| (Some(v), b))\n+        .unwrap_or((None, false));\n+    let color = match matches.opt_str(\"color\").as_deref() {\n         Some(\"auto\") | None => ColorConfig::AutoColor,\n         Some(\"always\") => ColorConfig::AlwaysColor,\n         Some(\"never\") => ColorConfig::NeverColor,\n         Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n     };\n+    let llvm_version =\n+        matches.opt_str(\"llvm-version\").as_deref().and_then(header::extract_llvm_version);\n \n     let src_base = opt_path(matches, \"src-base\");\n     let run_ignored = matches.opt_present(\"ignored\");\n@@ -215,7 +221,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         gdb_native_rust,\n         lldb_version,\n         lldb_native_rust,\n-        llvm_version: matches.opt_str(\"llvm-version\"),\n+        llvm_version,\n         system_llvm: matches.opt_present(\"system-llvm\"),\n         android_cross_path,\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n@@ -254,7 +260,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\", opt_str(&config.filter.as_ref().map(|re| re.to_owned()))));\n+    logv(c, format!(\"filter: {}\", opt_str(&config.filter)));\n     logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n     logv(\n         c,\n@@ -403,17 +409,14 @@ fn configure_lldb(config: &Config) -> Option<Config> {\n         return None;\n     }\n \n-    if let Some(lldb_version) = config.lldb_version.as_ref() {\n-        if lldb_version == \"350\" {\n-            println!(\n-                \"WARNING: The used version of LLDB ({}) has a \\\n-                 known issue that breaks debuginfo tests. See \\\n-                 issue #32520 for more information. Skipping all \\\n-                 LLDB-based tests!\",\n-                lldb_version\n-            );\n-            return None;\n-        }\n+    if let Some(350) = config.lldb_version {\n+        println!(\n+            \"WARNING: The used version of LLDB (350) has a \\\n+             known issue that breaks debuginfo tests. See \\\n+             issue #32520 for more information. Skipping all \\\n+             LLDB-based tests!\",\n+        );\n+        return None;\n     }\n \n     // Some older versions of LLDB seem to have problems with multiple\n@@ -727,9 +730,7 @@ fn make_test_closure(\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n     let revision = revision.cloned();\n-    test::DynTestFn(Box::new(move || {\n-        runtest::run(config, &testpaths, revision.as_ref().map(|s| s.as_str()))\n-    }))\n+    test::DynTestFn(Box::new(move || runtest::run(config, &testpaths, revision.as_deref())))\n }\n \n /// Returns `true` if the given target is an Android target for the\n@@ -845,75 +846,40 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n     // This particular form is documented in the GNU coding standards:\n     // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n \n-    // don't start parsing in the middle of a number\n-    let mut prev_was_digit = false;\n-    let mut in_parens = false;\n-    for (pos, c) in full_version_line.char_indices() {\n-        if in_parens {\n-            if c == ')' {\n-                in_parens = false;\n-            }\n-            continue;\n-        } else if c == '(' {\n-            in_parens = true;\n-            continue;\n-        }\n-\n-        if prev_was_digit || !c.is_digit(10) {\n-            prev_was_digit = c.is_digit(10);\n-            continue;\n+    let mut splits = full_version_line.rsplit(' ');\n+    let version_string = splits.next().unwrap();\n+\n+    let mut splits = version_string.split('.');\n+    let major = splits.next().unwrap();\n+    let minor = splits.next().unwrap();\n+    let patch = splits.next();\n+\n+    let major: u32 = major.parse().unwrap();\n+    let (minor, patch): (u32, u32) = match minor.find(not_a_digit) {\n+        None => {\n+            let minor = minor.parse().unwrap();\n+            let patch: u32 = match patch {\n+                Some(patch) => match patch.find(not_a_digit) {\n+                    None => patch.parse().unwrap(),\n+                    Some(idx) if idx > 3 => 0,\n+                    Some(idx) => patch[..idx].parse().unwrap(),\n+                },\n+                None => 0,\n+            };\n+            (minor, patch)\n         }\n-\n-        prev_was_digit = true;\n-\n-        let line = &full_version_line[pos..];\n-\n-        let next_split = match line.find(|c: char| !c.is_digit(10)) {\n-            Some(idx) => idx,\n-            None => continue, // no minor version\n-        };\n-\n-        if line.as_bytes()[next_split] != b'.' {\n-            continue; // no minor version\n+        // There is no patch version after minor-date (e.g. \"4-2012\").\n+        Some(idx) => {\n+            let minor = minor[..idx].parse().unwrap();\n+            (minor, 0)\n         }\n+    };\n \n-        let major = &line[..next_split];\n-        let line = &line[next_split + 1..];\n-\n-        let (minor, patch) = match line.find(|c: char| !c.is_digit(10)) {\n-            Some(idx) => {\n-                if line.as_bytes()[idx] == b'.' {\n-                    let patch = &line[idx + 1..];\n-\n-                    let patch_len =\n-                        patch.find(|c: char| !c.is_digit(10)).unwrap_or_else(|| patch.len());\n-                    let patch = &patch[..patch_len];\n-                    let patch = if patch_len > 3 || patch_len == 0 { None } else { Some(patch) };\n-\n-                    (&line[..idx], patch)\n-                } else {\n-                    (&line[..idx], None)\n-                }\n-            }\n-            None => (line, None),\n-        };\n-\n-        if minor.is_empty() {\n-            continue;\n-        }\n-\n-        let major: u32 = major.parse().unwrap();\n-        let minor: u32 = minor.parse().unwrap();\n-        let patch: u32 = patch.unwrap_or(\"0\").parse().unwrap();\n-\n-        return Some(((major * 1000) + minor) * 1000 + patch);\n-    }\n-\n-    None\n+    Some(((major * 1000) + minor) * 1000 + patch)\n }\n \n /// Returns (LLDB version, LLDB is rust-enabled)\n-fn extract_lldb_version(full_version_line: Option<String>) -> (Option<String>, bool) {\n+fn extract_lldb_version(full_version_line: &str) -> Option<(u32, bool)> {\n     // Extract the major LLDB version from the given version string.\n     // LLDB version strings are different for Apple and non-Apple platforms.\n     // The Apple variant looks like this:\n@@ -922,7 +888,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> (Option<String>, b\n     // lldb-300.2.51 (new versions)\n     //\n     // We are only interested in the major version number, so this function\n-    // will return `Some(\"179\")` and `Some(\"300\")` respectively.\n+    // will return `Some(179)` and `Some(300)` respectively.\n     //\n     // Upstream versions look like:\n     // lldb version 6.0.1\n@@ -934,53 +900,24 @@ fn extract_lldb_version(full_version_line: Option<String>) -> (Option<String>, b\n     // normally fine because the only non-Apple version we test is\n     // rust-enabled.\n \n-    if let Some(ref full_version_line) = full_version_line {\n-        if !full_version_line.trim().is_empty() {\n-            let full_version_line = full_version_line.trim();\n-\n-            for (pos, l) in full_version_line.char_indices() {\n-                if l != 'l' && l != 'L' {\n-                    continue;\n-                }\n-                if pos + 5 >= full_version_line.len() {\n-                    continue;\n-                }\n-                let l = full_version_line[pos + 1..].chars().next().unwrap();\n-                if l != 'l' && l != 'L' {\n-                    continue;\n-                }\n-                let d = full_version_line[pos + 2..].chars().next().unwrap();\n-                if d != 'd' && d != 'D' {\n-                    continue;\n-                }\n-                let b = full_version_line[pos + 3..].chars().next().unwrap();\n-                if b != 'b' && b != 'B' {\n-                    continue;\n-                }\n-                let dash = full_version_line[pos + 4..].chars().next().unwrap();\n-                if dash != '-' {\n-                    continue;\n-                }\n-\n-                let vers = full_version_line[pos + 5..]\n-                    .chars()\n-                    .take_while(|c| c.is_digit(10))\n-                    .collect::<String>();\n-                if !vers.is_empty() {\n-                    return (Some(vers), full_version_line.contains(\"rust-enabled\"));\n-                }\n-            }\n+    let full_version_line = full_version_line.trim();\n \n-            if full_version_line.starts_with(\"lldb version \") {\n-                let vers = full_version_line[13..]\n-                    .chars()\n-                    .take_while(|c| c.is_digit(10))\n-                    .collect::<String>();\n-                if !vers.is_empty() {\n-                    return (Some(vers + \"00\"), full_version_line.contains(\"rust-enabled\"));\n-                }\n-            }\n+    if let Some(apple_ver) =\n+        full_version_line.strip_prefix(\"LLDB-\").or_else(|| full_version_line.strip_prefix(\"lldb-\"))\n+    {\n+        if let Some(idx) = apple_ver.find(not_a_digit) {\n+            let version: u32 = apple_ver[..idx].parse().unwrap();\n+            return Some((version, full_version_line.contains(\"rust-enabled\")));\n+        }\n+    } else if let Some(lldb_ver) = full_version_line.strip_prefix(\"lldb version \") {\n+        if let Some(idx) = lldb_ver.find(not_a_digit) {\n+            let version: u32 = lldb_ver[..idx].parse().unwrap();\n+            return Some((version * 100, full_version_line.contains(\"rust-enabled\")));\n         }\n     }\n-    (None, false)\n+    None\n+}\n+\n+fn not_a_digit(c: char) -> bool {\n+    !c.is_digit(10)\n }"}, {"sha": "ea9bc1c1a5b7f5a7413c26b0939db1bec0767d98", "filename": "src/tools/compiletest/src/tests.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216ed3c4ab88f666d5a883b66e31b8fdaa48f211/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs?ref=216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "patch": "@@ -1,8 +1,9 @@\n+use super::header::extract_llvm_version;\n use super::*;\n \n #[test]\n fn test_extract_gdb_version() {\n-    macro_rules! test { ($($expectation:tt: $input:tt,)*) => {{$(\n+    macro_rules! test { ($($expectation:literal: $input:literal,)*) => {{$(\n         assert_eq!(extract_gdb_version($input), Some($expectation));\n     )*}}}\n \n@@ -41,6 +42,17 @@ fn test_extract_gdb_version() {\n     }\n }\n \n+#[test]\n+fn test_extract_lldb_version() {\n+    // Apple variants\n+    assert_eq!(extract_lldb_version(\"LLDB-179.5\"), Some((179, false)));\n+    assert_eq!(extract_lldb_version(\"lldb-300.2.51\"), Some((300, false)));\n+\n+    // Upstream versions\n+    assert_eq!(extract_lldb_version(\"lldb version 6.0.1\"), Some((600, false)));\n+    assert_eq!(extract_lldb_version(\"lldb version 9.0.0\"), Some((900, false)));\n+}\n+\n #[test]\n fn is_test_test() {\n     assert_eq!(true, is_test(&OsString::from(\"a_test.rs\")));\n@@ -49,3 +61,11 @@ fn is_test_test() {\n     assert_eq!(false, is_test(&OsString::from(\"#a_dog_gif\")));\n     assert_eq!(false, is_test(&OsString::from(\"~a_temp_file\")));\n }\n+\n+#[test]\n+fn test_extract_llvm_version() {\n+    assert_eq!(extract_llvm_version(\"8.1.2-rust\"), Some(80102));\n+    assert_eq!(extract_llvm_version(\"9.0.1-rust-1.43.0-dev\"), Some(90001));\n+    assert_eq!(extract_llvm_version(\"9.3.1-rust-1.43.0-dev\"), Some(90301));\n+    assert_eq!(extract_llvm_version(\"10.0.0-rust\"), Some(100000));\n+}"}]}