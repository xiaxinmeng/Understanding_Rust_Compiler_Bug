{"sha": "3ba9733d718768edd1d5a8f26d1f2940b0aea327", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTk3MzNkNzE4NzY4ZWRkMWQ1YThmMjZkMWYyOTQwYjBhZWEzMjc=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-17T22:29:39Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move FromIterator, IntoIterator, Extend into own module", "tree": {"sha": "b1deae94406513a1fbb475f180e1ec9ff2e165ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1deae94406513a1fbb475f180e1ec9ff2e165ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba9733d718768edd1d5a8f26d1f2940b0aea327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba9733d718768edd1d5a8f26d1f2940b0aea327", "html_url": "https://github.com/rust-lang/rust/commit/3ba9733d718768edd1d5a8f26d1f2940b0aea327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba9733d718768edd1d5a8f26d1f2940b0aea327/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a2845954a94a639bf3beb1b9f2ab615b839f8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2845954a94a639bf3beb1b9f2ab615b839f8d9", "html_url": "https://github.com/rust-lang/rust/commit/6a2845954a94a639bf3beb1b9f2ab615b839f8d9"}], "stats": {"total": 701, "additions": 351, "deletions": 350}, "files": [{"sha": "5204f6a64250959f1ff72aa2099f0764f41fb4c0", "filename": "src/libcore/iter/traits/collect.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/3ba9733d718768edd1d5a8f26d1f2940b0aea327/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba9733d718768edd1d5a8f26d1f2940b0aea327/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=3ba9733d718768edd1d5a8f26d1f2940b0aea327", "patch": "@@ -0,0 +1,349 @@\n+/// Conversion from an `Iterator`.\n+///\n+/// By implementing `FromIterator` for a type, you define how it will be\n+/// created from an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n+/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n+/// documentation for more examples.\n+///\n+/// [`from_iter`]: #tymethod.from_iter\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`collect`]: trait.Iterator.html#method.collect\n+///\n+/// See also: [`IntoIterator`].\n+///\n+/// [`IntoIterator`]: trait.IntoIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v = Vec::from_iter(five_fives);\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Using [`collect`] to implicitly use `FromIterator`:\n+///\n+/// ```\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v: Vec<i32> = five_fives.collect();\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Implementing `FromIterator` for your type:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement FromIterator\n+/// impl FromIterator<i32> for MyCollection {\n+///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n+///         let mut c = MyCollection::new();\n+///\n+///         for i in iter {\n+///             c.add(i);\n+///         }\n+///\n+///         c\n+///     }\n+/// }\n+///\n+/// // Now we can make a new iterator...\n+/// let iter = (0..5).into_iter();\n+///\n+/// // ... and make a MyCollection out of it\n+/// let c = MyCollection::from_iter(iter);\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+///\n+/// // collect works too!\n+///\n+/// let iter = (0..5).into_iter();\n+/// let c: MyCollection = iter.collect();\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented(\n+    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n+             over elements of type `{A}`\",\n+    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n+)]\n+pub trait FromIterator<A>: Sized {\n+    /// Creates a value from an iterator.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::iter::FromIterator;\n+    ///\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v = Vec::from_iter(five_fives);\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n+}\n+\n+/// Conversion into an `Iterator`.\n+///\n+/// By implementing `IntoIterator` for a type, you define how it will be\n+/// converted to an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// One benefit of implementing `IntoIterator` is that your type will [work\n+/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+///\n+/// See also: [`FromIterator`].\n+///\n+/// [`FromIterator`]: trait.FromIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// let mut iter = v.into_iter();\n+///\n+/// assert_eq!(Some(1), iter.next());\n+/// assert_eq!(Some(2), iter.next());\n+/// assert_eq!(Some(3), iter.next());\n+/// assert_eq!(None, iter.next());\n+/// ```\n+/// Implementing `IntoIterator` for your type:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement IntoIterator\n+/// impl IntoIterator for MyCollection {\n+///     type Item = i32;\n+///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///\n+///     fn into_iter(self) -> Self::IntoIter {\n+///         self.0.into_iter()\n+///     }\n+/// }\n+///\n+/// // Now we can make a new collection...\n+/// let mut c = MyCollection::new();\n+///\n+/// // ... add some stuff to it ...\n+/// c.add(0);\n+/// c.add(1);\n+/// c.add(2);\n+///\n+/// // ... and then turn it into an Iterator:\n+/// for (i, n) in c.into_iter().enumerate() {\n+///     assert_eq!(i as i32, n);\n+/// }\n+/// ```\n+///\n+/// It is common to use `IntoIterator` as a trait bound. This allows\n+/// the input collection type to change, so long as it is still an\n+/// iterator. Additional bounds can be specified by restricting on\n+/// `Item`:\n+///\n+/// ```rust\n+/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n+///     where T: IntoIterator,\n+///           T::Item : std::fmt::Debug,\n+/// {\n+///     collection\n+///         .into_iter()\n+///         .map(|item| format!(\"{:?}\", item))\n+///         .collect()\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoIterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Which kind of iterator are we turning this into?\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    /// Creates an iterator from a value.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    /// let mut iter = v.into_iter();\n+    ///\n+    /// assert_eq!(Some(1), iter.next());\n+    /// assert_eq!(Some(2), iter.next());\n+    /// assert_eq!(Some(3), iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+/// Extend a collection with the contents of an iterator.\n+///\n+/// Iterators produce a series of values, and collections can also be thought\n+/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n+/// to extend a collection by including the contents of that iterator. When\n+/// extending a collection with an already existing key, that entry is updated\n+/// or, in the case of collections that permit multiple entries with equal\n+/// keys, that entry is inserted.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // You can extend a String with some chars:\n+/// let mut message = String::from(\"The first three letters are: \");\n+///\n+/// message.extend(&['a', 'b', 'c']);\n+///\n+/// assert_eq!(\"abc\", &message[29..32]);\n+/// ```\n+///\n+/// Implementing `Extend`:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // since MyCollection has a list of i32s, we implement Extend for i32\n+/// impl Extend<i32> for MyCollection {\n+///\n+///     // This is a bit simpler with the concrete type signature: we can call\n+///     // extend on anything which can be turned into an Iterator which gives\n+///     // us i32s. Because we need i32s to put into MyCollection.\n+///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n+///\n+///         // The implementation is very straightforward: loop through the\n+///         // iterator, and add() each element to ourselves.\n+///         for elem in iter {\n+///             self.add(elem);\n+///         }\n+///     }\n+/// }\n+///\n+/// let mut c = MyCollection::new();\n+///\n+/// c.add(5);\n+/// c.add(6);\n+/// c.add(7);\n+///\n+/// // let's extend our collection with three more numbers\n+/// c.extend(vec![1, 2, 3]);\n+///\n+/// // we've added these elements onto the end\n+/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Extend<A> {\n+    /// Extends a collection with the contents of an iterator.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.Extend.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // You can extend a String with some chars:\n+    /// let mut message = String::from(\"abc\");\n+    ///\n+    /// message.extend(['d', 'e', 'f'].iter());\n+    ///\n+    /// assert_eq!(\"abcdef\", &message);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n+}\n+\n+#[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n+impl Extend<()> for () {\n+    fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n+        iter.into_iter().for_each(drop)\n+    }\n+}"}, {"sha": "093799d7bce20b14689900f8748ea3c2c7b1536f", "filename": "src/libcore/iter/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 350, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/3ba9733d718768edd1d5a8f26d1f2940b0aea327/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba9733d718768edd1d5a8f26d1f2940b0aea327/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs?ref=3ba9733d718768edd1d5a8f26d1f2940b0aea327", "patch": "@@ -4,360 +4,12 @@ use num::Wrapping;\n mod iterator;\n mod double_ended;\n mod exact_size;\n+mod collect;\n \n pub use self::iterator::Iterator;\n pub use self::double_ended::DoubleEndedIterator;\n pub use self::exact_size::ExactSizeIterator;\n-\n-/// Conversion from an `Iterator`.\n-///\n-/// By implementing `FromIterator` for a type, you define how it will be\n-/// created from an iterator. This is common for types which describe a\n-/// collection of some kind.\n-///\n-/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n-/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n-/// documentation for more examples.\n-///\n-/// [`from_iter`]: #tymethod.from_iter\n-/// [`Iterator`]: trait.Iterator.html\n-/// [`collect`]: trait.Iterator.html#method.collect\n-///\n-/// See also: [`IntoIterator`].\n-///\n-/// [`IntoIterator`]: trait.IntoIterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter::FromIterator;\n-///\n-/// let five_fives = std::iter::repeat(5).take(5);\n-///\n-/// let v = Vec::from_iter(five_fives);\n-///\n-/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-/// ```\n-///\n-/// Using [`collect`] to implicitly use `FromIterator`:\n-///\n-/// ```\n-/// let five_fives = std::iter::repeat(5).take(5);\n-///\n-/// let v: Vec<i32> = five_fives.collect();\n-///\n-/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-/// ```\n-///\n-/// Implementing `FromIterator` for your type:\n-///\n-/// ```\n-/// use std::iter::FromIterator;\n-///\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // and we'll implement FromIterator\n-/// impl FromIterator<i32> for MyCollection {\n-///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n-///         let mut c = MyCollection::new();\n-///\n-///         for i in iter {\n-///             c.add(i);\n-///         }\n-///\n-///         c\n-///     }\n-/// }\n-///\n-/// // Now we can make a new iterator...\n-/// let iter = (0..5).into_iter();\n-///\n-/// // ... and make a MyCollection out of it\n-/// let c = MyCollection::from_iter(iter);\n-///\n-/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n-///\n-/// // collect works too!\n-///\n-/// let iter = (0..5).into_iter();\n-/// let c: MyCollection = iter.collect();\n-///\n-/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n-             over elements of type `{A}`\",\n-    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n-)]\n-pub trait FromIterator<A>: Sized {\n-    /// Creates a value from an iterator.\n-    ///\n-    /// See the [module-level documentation] for more.\n-    ///\n-    /// [module-level documentation]: index.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::iter::FromIterator;\n-    ///\n-    /// let five_fives = std::iter::repeat(5).take(5);\n-    ///\n-    /// let v = Vec::from_iter(five_fives);\n-    ///\n-    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n-}\n-\n-/// Conversion into an `Iterator`.\n-///\n-/// By implementing `IntoIterator` for a type, you define how it will be\n-/// converted to an iterator. This is common for types which describe a\n-/// collection of some kind.\n-///\n-/// One benefit of implementing `IntoIterator` is that your type will [work\n-/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n-///\n-/// See also: [`FromIterator`].\n-///\n-/// [`FromIterator`]: trait.FromIterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// let mut iter = v.into_iter();\n-///\n-/// assert_eq!(Some(1), iter.next());\n-/// assert_eq!(Some(2), iter.next());\n-/// assert_eq!(Some(3), iter.next());\n-/// assert_eq!(None, iter.next());\n-/// ```\n-/// Implementing `IntoIterator` for your type:\n-///\n-/// ```\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // and we'll implement IntoIterator\n-/// impl IntoIterator for MyCollection {\n-///     type Item = i32;\n-///     type IntoIter = ::std::vec::IntoIter<i32>;\n-///\n-///     fn into_iter(self) -> Self::IntoIter {\n-///         self.0.into_iter()\n-///     }\n-/// }\n-///\n-/// // Now we can make a new collection...\n-/// let mut c = MyCollection::new();\n-///\n-/// // ... add some stuff to it ...\n-/// c.add(0);\n-/// c.add(1);\n-/// c.add(2);\n-///\n-/// // ... and then turn it into an Iterator:\n-/// for (i, n) in c.into_iter().enumerate() {\n-///     assert_eq!(i as i32, n);\n-/// }\n-/// ```\n-///\n-/// It is common to use `IntoIterator` as a trait bound. This allows\n-/// the input collection type to change, so long as it is still an\n-/// iterator. Additional bounds can be specified by restricting on\n-/// `Item`:\n-///\n-/// ```rust\n-/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n-///     where T: IntoIterator,\n-///           T::Item : std::fmt::Debug,\n-/// {\n-///     collection\n-///         .into_iter()\n-///         .map(|item| format!(\"{:?}\", item))\n-///         .collect()\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait IntoIterator {\n-    /// The type of the elements being iterated over.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Item;\n-\n-    /// Which kind of iterator are we turning this into?\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type IntoIter: Iterator<Item=Self::Item>;\n-\n-    /// Creates an iterator from a value.\n-    ///\n-    /// See the [module-level documentation] for more.\n-    ///\n-    /// [module-level documentation]: index.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v = vec![1, 2, 3];\n-    /// let mut iter = v.into_iter();\n-    ///\n-    /// assert_eq!(Some(1), iter.next());\n-    /// assert_eq!(Some(2), iter.next());\n-    /// assert_eq!(Some(3), iter.next());\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_iter(self) -> Self::IntoIter;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> IntoIterator for I {\n-    type Item = I::Item;\n-    type IntoIter = I;\n-\n-    fn into_iter(self) -> I {\n-        self\n-    }\n-}\n-\n-/// Extend a collection with the contents of an iterator.\n-///\n-/// Iterators produce a series of values, and collections can also be thought\n-/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n-/// to extend a collection by including the contents of that iterator. When\n-/// extending a collection with an already existing key, that entry is updated\n-/// or, in the case of collections that permit multiple entries with equal\n-/// keys, that entry is inserted.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// // You can extend a String with some chars:\n-/// let mut message = String::from(\"The first three letters are: \");\n-///\n-/// message.extend(&['a', 'b', 'c']);\n-///\n-/// assert_eq!(\"abc\", &message[29..32]);\n-/// ```\n-///\n-/// Implementing `Extend`:\n-///\n-/// ```\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // since MyCollection has a list of i32s, we implement Extend for i32\n-/// impl Extend<i32> for MyCollection {\n-///\n-///     // This is a bit simpler with the concrete type signature: we can call\n-///     // extend on anything which can be turned into an Iterator which gives\n-///     // us i32s. Because we need i32s to put into MyCollection.\n-///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n-///\n-///         // The implementation is very straightforward: loop through the\n-///         // iterator, and add() each element to ourselves.\n-///         for elem in iter {\n-///             self.add(elem);\n-///         }\n-///     }\n-/// }\n-///\n-/// let mut c = MyCollection::new();\n-///\n-/// c.add(5);\n-/// c.add(6);\n-/// c.add(7);\n-///\n-/// // let's extend our collection with three more numbers\n-/// c.extend(vec![1, 2, 3]);\n-///\n-/// // we've added these elements onto the end\n-/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Extend<A> {\n-    /// Extends a collection with the contents of an iterator.\n-    ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n-    /// contain more details.\n-    ///\n-    /// [trait-level]: trait.Extend.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // You can extend a String with some chars:\n-    /// let mut message = String::from(\"abc\");\n-    ///\n-    /// message.extend(['d', 'e', 'f'].iter());\n-    ///\n-    /// assert_eq!(\"abcdef\", &message);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n-}\n-\n-#[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n-impl Extend<()> for () {\n-    fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n-        iter.into_iter().for_each(drop)\n-    }\n-}\n+pub use self::collect::{FromIterator, IntoIterator, Extend};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///"}]}