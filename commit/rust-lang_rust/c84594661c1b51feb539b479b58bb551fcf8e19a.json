{"sha": "c84594661c1b51feb539b479b58bb551fcf8e19a", "node_id": "C_kwDOAAsO6NoAKGM4NDU5NDY2MWMxYjUxZmViNTM5YjQ3OWI1OGJiNTUxZmNmOGUxOWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T04:00:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T04:00:23Z"}, "message": "Auto merge of #97905 - nnethercote:revert-infallible-encoder, r=bjorn3\n\nRevert part of #94372 to improve performance\n\n#94732 was supposed to give small but widespread performance improvements, as judged from three per-merge performance runs. But the performance run that occurred after merging included a roughly equal number of improvements and regressions, for unclear reasons.\n\nThis PR is for a test run reverting those changes, to see what happens.\n\nr? `@ghost`", "tree": {"sha": "01b9fceb009ece71d814e5fa5a9f06467885f01f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01b9fceb009ece71d814e5fa5a9f06467885f01f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84594661c1b51feb539b479b58bb551fcf8e19a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84594661c1b51feb539b479b58bb551fcf8e19a", "html_url": "https://github.com/rust-lang/rust/commit/c84594661c1b51feb539b479b58bb551fcf8e19a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84594661c1b51feb539b479b58bb551fcf8e19a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75307c22f33cb47966466ba1daca08573a3c583e", "url": "https://api.github.com/repos/rust-lang/rust/commits/75307c22f33cb47966466ba1daca08573a3c583e", "html_url": "https://github.com/rust-lang/rust/commit/75307c22f33cb47966466ba1daca08573a3c583e"}, {"sha": "3186e311e526e3dad197dacc91c2d84cde2be846", "url": "https://api.github.com/repos/rust-lang/rust/commits/3186e311e526e3dad197dacc91c2d84cde2be846", "html_url": "https://github.com/rust-lang/rust/commit/3186e311e526e3dad197dacc91c2d84cde2be846"}], "stats": {"total": 423, "additions": 250, "deletions": 173}, "files": [{"sha": "4e2495ab14c9ada093e2ca319646730e8b3b6900", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -31,7 +31,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{self, Decoder, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -2488,11 +2488,11 @@ rustc_index::newtype_index! {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for AttrId {\n+impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n     fn encode(&self, _s: &mut S) {}\n }\n \n-impl<D: Decoder> Decodable<D> for AttrId {\n+impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n     fn decode(_: &mut D) -> AttrId {\n         crate::attr::mk_attr_id()\n     }"}, {"sha": "771157dcad95493a9c412549fb852f661412b620", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -29,8 +29,7 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::{CrateType, OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_session::cstore::{self, CrateSource};\n use rustc_session::utils::NativeLibKind;\n@@ -204,14 +203,14 @@ const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n impl CodegenResults {\n     pub fn serialize_rlink(codegen_results: &CodegenResults) -> Vec<u8> {\n-        let mut encoder = MemEncoder::new();\n+        let mut encoder = opaque::Encoder::new();\n         encoder.emit_raw_bytes(RLINK_MAGIC);\n         // `emit_raw_bytes` is used to make sure that the version representation does not depend on\n         // Encoder's inner representation of `u32`.\n         encoder.emit_raw_bytes(&RLINK_VERSION.to_be_bytes());\n         encoder.emit_str(RUSTC_VERSION.unwrap());\n         Encodable::encode(codegen_results, &mut encoder);\n-        encoder.finish()\n+        encoder.finish().unwrap()\n     }\n \n     pub fn deserialize_rlink(data: Vec<u8>) -> Result<Self, String> {\n@@ -231,7 +230,7 @@ impl CodegenResults {\n             return Err(\".rlink file was produced with encoding version {version_array}, but the current version is {RLINK_VERSION}\".to_string());\n         }\n \n-        let mut decoder = MemDecoder::new(&data[4..], 0);\n+        let mut decoder = opaque::Decoder::new(&data[4..], 0);\n         let rustc_version = decoder.read_str();\n         let current_version = RUSTC_VERSION.unwrap();\n         if rustc_version != current_version {"}, {"sha": "a032b039f34ef234f980dddd4de6ab7c02ffaf8c", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -1,5 +1,5 @@\n use crate::stable_hasher;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Encodable};\n use std::convert::TryInto;\n use std::hash::{Hash, Hasher};\n \n@@ -142,14 +142,14 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n \n impl_stable_hash_via_hash!(Fingerprint);\n \n-impl<E: Encoder> Encodable<E> for Fingerprint {\n+impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n     #[inline]\n     fn encode(&self, s: &mut E) {\n         s.emit_raw_bytes(&self.to_le_bytes());\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for Fingerprint {\n+impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {\n     #[inline]\n     fn decode(d: &mut D) -> Self {\n         Fingerprint::from_le_bytes(d.read_raw_bytes(16).try_into().unwrap())\n@@ -184,7 +184,7 @@ impl std::fmt::Display for PackedFingerprint {\n     }\n }\n \n-impl<E: Encoder> Encodable<E> for PackedFingerprint {\n+impl<E: rustc_serialize::Encoder> Encodable<E> for PackedFingerprint {\n     #[inline]\n     fn encode(&self, s: &mut E) {\n         // Copy to avoid taking reference to packed field.\n@@ -193,7 +193,7 @@ impl<E: Encoder> Encodable<E> for PackedFingerprint {\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for PackedFingerprint {\n+impl<D: rustc_serialize::Decoder> Decodable<D> for PackedFingerprint {\n     #[inline]\n     fn decode(d: &mut D) -> Self {\n         Self(Fingerprint::decode(d))"}, {"sha": "9de14950aa8d33d23ad9bd353261e5d1eff99bf6", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::OnDiskCache;\n-use rustc_serialize::opaque::MemDecoder;\n+use rustc_serialize::opaque::Decoder;\n use rustc_serialize::Decodable;\n use rustc_session::config::IncrementalStateAssertion;\n use rustc_session::Session;\n@@ -156,7 +156,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n         if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n             // Decode the list of work_products\n-            let mut work_product_decoder = MemDecoder::new(&work_products_data[..], start_pos);\n+            let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n             let work_products: Vec<SerializedWorkProduct> =\n                 Decodable::decode(&mut work_product_decoder);\n \n@@ -193,7 +193,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n             LoadResult::Error { message } => LoadResult::Error { message },\n             LoadResult::Ok { data: (bytes, start_pos) } => {\n-                let mut decoder = MemDecoder::new(&bytes, start_pos);\n+                let mut decoder = Decoder::new(&bytes, start_pos);\n                 let prev_commandline_args_hash = u64::decode(&mut decoder);\n \n                 if prev_commandline_args_hash != expected_hash {"}, {"sha": "9341a742925d9d321438d647b78701cba3ad0489", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::sync::join;\n use rustc_middle::dep_graph::{DepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n-use rustc_serialize::Encodable;\n+use rustc_serialize::{Encodable as RustcEncodable, Encoder};\n use rustc_session::Session;\n use std::fs;\n "}, {"sha": "775ebb48402aabef8b08384c3dd1743baf51f132", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -26,8 +26,7 @@ use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::GeneratorDiagnosticData;\n use rustc_middle::ty::{self, ParameterizedOverTcx, Ty, TyCtxt, Visibility};\n-use rustc_serialize::opaque::MemDecoder;\n-use rustc_serialize::{Decodable, Decoder};\n+use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::cstore::{\n     CrateSource, ExternCrate, ForeignModule, LinkagePreference, NativeLib,\n };\n@@ -155,7 +154,7 @@ struct ImportedSourceFile {\n }\n \n pub(super) struct DecodeContext<'a, 'tcx> {\n-    opaque: MemDecoder<'a>,\n+    opaque: opaque::Decoder<'a>,\n     cdata: Option<CrateMetadataRef<'a>>,\n     blob: &'a MetadataBlob,\n     sess: Option<&'tcx Session>,\n@@ -187,7 +186,7 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n         DecodeContext {\n-            opaque: MemDecoder::new(self.blob(), pos),\n+            opaque: opaque::Decoder::new(self.blob(), pos),\n             cdata: self.cdata(),\n             blob: self.blob(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n@@ -419,7 +418,7 @@ impl<'a, 'tcx> TyDecoder for DecodeContext<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n-        let new_opaque = MemDecoder::new(self.opaque.data, pos);\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n         let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n         let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n         let r = f(self);"}, {"sha": "3285273ba909e4f903952321cbfa45e53f8dad0a", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -27,8 +27,7 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n@@ -44,7 +43,7 @@ use std::num::NonZeroUsize;\n use tracing::{debug, trace};\n \n pub(super) struct EncodeContext<'a, 'tcx> {\n-    opaque: MemEncoder,\n+    opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n     feat: &'tcx rustc_feature::Features,\n \n@@ -94,6 +93,9 @@ macro_rules! encoder_methods {\n }\n \n impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n+    type Ok = <opaque::Encoder as Encoder>::Ok;\n+    type Err = <opaque::Encoder as Encoder>::Err;\n+\n     encoder_methods! {\n         emit_usize(usize);\n         emit_u128(u128);\n@@ -116,6 +118,10 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n+\n+    fn finish(self) -> Result<Self::Ok, Self::Err> {\n+        self.opaque.finish()\n+    }\n }\n \n impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyValue<T> {\n@@ -2182,7 +2188,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n }\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n-    let mut encoder = MemEncoder::new();\n+    let mut encoder = opaque::Encoder::new();\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n@@ -2217,7 +2223,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     // culminating in the `CrateRoot` which points to all of it.\n     let root = ecx.encode_crate_root();\n \n-    let mut result = ecx.opaque.finish();\n+    let mut result = ecx.opaque.finish().unwrap();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();"}, {"sha": "fb2ffe1d73d96b46c514112537e2139d48cdd772", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_middle::ty::{GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n+use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::edition::Edition;\n@@ -323,7 +323,7 @@ macro_rules! define_tables {\n         }\n \n         impl TableBuilders {\n-            fn encode(&self, buf: &mut MemEncoder) -> LazyTables {\n+            fn encode(&self, buf: &mut Encoder) -> LazyTables {\n                 LazyTables {\n                     $($name: self.$name.encode(buf)),+\n                 }"}, {"sha": "8baa67a8f9fcf91cddcd8568e36b7fe44996276b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -4,8 +4,8 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::ParameterizedOverTcx;\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::Encoder;\n+use rustc_serialize::opaque::Encoder;\n+use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n@@ -281,7 +281,7 @@ where\n         Some(value).write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut MemEncoder) -> LazyTable<I, T>\n+    pub(crate) fn encode<const N: usize>(&self, buf: &mut Encoder) -> LazyTable<I, T>\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {"}, {"sha": "096bf8cbc158a1a996b58d8979c3e0aa13cb7687", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::graph::{\n };\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize as serialize;\n \n /// Helper type to cache the result of `graph::is_cyclic`.\n #[derive(Clone, Debug)]\n@@ -36,17 +36,17 @@ impl GraphIsCyclicCache {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for GraphIsCyclicCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for GraphIsCyclicCache {\n     #[inline]\n     fn encode(&self, s: &mut S) {\n-        Encodable::encode(&(), s);\n+        serialize::Encodable::encode(&(), s);\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for GraphIsCyclicCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for GraphIsCyclicCache {\n     #[inline]\n     fn decode(d: &mut D) -> Self {\n-        let () = Decodable::decode(d);\n+        let () = serialize::Decodable::decode(d);\n         Self::new()\n     }\n }"}, {"sha": "9bc0cb1138ff1ac0ee39eac77283817bc4f402fa", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -3,7 +3,7 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize as serialize;\n use smallvec::SmallVec;\n \n use crate::mir::{BasicBlock, BasicBlockData};\n@@ -54,12 +54,12 @@ impl PredecessorCache {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for PredecessorCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n     fn encode(&self, _s: &mut S) {}\n }\n \n-impl<D: Decoder> Decodable<D> for PredecessorCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for PredecessorCache {\n     #[inline]\n     fn decode(_: &mut D) -> Self {\n         Self::new()"}, {"sha": "4872a7835e3fadea4e2cc066be0997cb74f9cfa6", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize as serialize;\n use smallvec::SmallVec;\n \n use crate::mir::{BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n@@ -54,12 +54,12 @@ impl SwitchSourceCache {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for SwitchSourceCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for SwitchSourceCache {\n     #[inline]\n     fn encode(&self, _s: &mut S) {}\n }\n \n-impl<D: Decoder> Decodable<D> for SwitchSourceCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for SwitchSourceCache {\n     #[inline]\n     fn decode(_: &mut D) -> Self {\n         Self::new()"}, {"sha": "f745e55307ae23a661b1e16528e84c65b0772c61", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n use rustc_index::bit_set::BitSet;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize as serialize;\n \n use super::*;\n \n@@ -365,12 +365,12 @@ impl PostorderCache {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for PostorderCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for PostorderCache {\n     #[inline]\n     fn encode(&self, _s: &mut S) {}\n }\n \n-impl<D: Decoder> Decodable<D> for PostorderCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for PostorderCache {\n     #[inline]\n     fn decode(_: &mut D) -> Self {\n         Self::new()"}, {"sha": "c2c876f7f1a128756128d4707d90b9535f9aa33e", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 72, "deletions": 32, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::{QueryCache, QueryContext, QuerySideEffects};\n use rustc_serialize::{\n-    opaque::{FileEncodeResult, FileEncoder, IntEncodedWithFixedSize, MemDecoder},\n+    opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize},\n     Decodable, Decoder, Encodable, Encoder,\n };\n use rustc_session::Session;\n@@ -25,7 +25,6 @@ use rustc_span::hygiene::{\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, ExpnHash, Pos, SourceFile, Span};\n-use std::io;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -159,7 +158,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n \n         // Wrap in a scope so we can borrow `data`.\n         let footer: Footer = {\n-            let mut decoder = MemDecoder::new(&data, start_pos);\n+            let mut decoder = opaque::Decoder::new(&data, start_pos);\n \n             // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n@@ -438,7 +437,7 @@ impl<'sess> OnDiskCache<'sess> {\n         let serialized_data = self.serialized_data.read();\n         let mut decoder = CacheDecoder {\n             tcx,\n-            opaque: MemDecoder::new(serialized_data.as_deref().unwrap_or(&[]), pos.to_usize()),\n+            opaque: opaque::Decoder::new(serialized_data.as_deref().unwrap_or(&[]), pos.to_usize()),\n             source_map: self.source_map,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n@@ -459,7 +458,7 @@ impl<'sess> OnDiskCache<'sess> {\n /// will also handle things that contain `Ty` instances.\n pub struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    opaque: MemDecoder<'a>,\n+    opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n@@ -511,7 +510,7 @@ trait DecoderWithPosition: Decoder {\n     fn position(&self) -> usize;\n }\n \n-impl<'a> DecoderWithPosition for MemDecoder<'a> {\n+impl<'a> DecoderWithPosition for opaque::Decoder<'a> {\n     fn position(&self) -> usize {\n         self.position()\n     }\n@@ -587,7 +586,7 @@ impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n     {\n         debug_assert!(pos < self.opaque.data.len());\n \n-        let new_opaque = MemDecoder::new(self.opaque.data, pos);\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n         let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n         let r = f(self);\n         self.opaque = old_opaque;\n@@ -808,10 +807,21 @@ impl_ref_decoder! {<'tcx>\n \n //- ENCODING -------------------------------------------------------------------\n \n+pub trait OpaqueEncoder: Encoder {\n+    fn position(&self) -> usize;\n+}\n+\n+impl OpaqueEncoder for FileEncoder {\n+    #[inline]\n+    fn position(&self) -> usize {\n+        FileEncoder::position(self)\n+    }\n+}\n+\n /// An encoder that can write to the incremental compilation cache.\n-pub struct CacheEncoder<'a, 'tcx> {\n+pub struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n-    encoder: FileEncoder,\n+    encoder: E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::PredicateKind<'tcx>, usize>,\n     interpret_allocs: FxIndexSet<interpret::AllocId>,\n@@ -820,7 +830,10 @@ pub struct CacheEncoder<'a, 'tcx> {\n     hygiene_context: &'a HygieneEncodeContext,\n }\n \n-impl<'a, 'tcx> CacheEncoder<'a, 'tcx> {\n+impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n+where\n+    E: OpaqueEncoder,\n+{\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n     }\n@@ -839,27 +852,32 @@ impl<'a, 'tcx> CacheEncoder<'a, 'tcx> {\n         let end_pos = self.position();\n         ((end_pos - start_pos) as u64).encode(self);\n     }\n-\n-    fn finish(self) -> Result<usize, io::Error> {\n-        self.encoder.finish()\n-    }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for SyntaxContext {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for SyntaxContext\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         rustc_span::hygiene::raw_encode_syntax_context(*self, s.hygiene_context, s);\n     }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for ExpnId {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for ExpnId\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         s.hygiene_context.schedule_expn_data_for_encoding(*self);\n         self.expn_hash().encode(s);\n     }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for Span {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for Span\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         let span_data = self.data_untracked();\n         span_data.ctxt.encode(s);\n         span_data.parent.encode(s);\n@@ -902,7 +920,10 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder for CacheEncoder<'a, 'tcx> {\n+impl<'a, 'tcx, E> TyEncoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: OpaqueEncoder,\n+{\n     type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n@@ -922,20 +943,29 @@ impl<'a, 'tcx> TyEncoder for CacheEncoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for CrateNum {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for CrateNum\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         s.tcx.stable_crate_id(*self).encode(s);\n     }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for DefId {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefId\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         s.tcx.def_path_hash(*self).encode(s);\n     }\n }\n \n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for DefIndex {\n-    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefIndex\n+where\n+    E: OpaqueEncoder,\n+{\n+    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx, E>) {\n         bug!(\"encoding `DefIndex` without context\");\n     }\n }\n@@ -949,7 +979,13 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'a, 'tcx> Encoder for CacheEncoder<'a, 'tcx> {\n+impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: OpaqueEncoder,\n+{\n+    type Ok = E::Ok;\n+    type Err = E::Err;\n+\n     encoder_methods! {\n         emit_usize(usize);\n         emit_u128(u128);\n@@ -972,26 +1008,30 @@ impl<'a, 'tcx> Encoder for CacheEncoder<'a, 'tcx> {\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n+\n+    fn finish(self) -> Result<E::Ok, E::Err> {\n+        self.encoder.finish()\n+    }\n }\n \n // This ensures that the `Encodable<opaque::FileEncoder>::encode` specialization for byte slices\n // is used when a `CacheEncoder` having an `opaque::FileEncoder` is passed to `Encodable::encode`.\n // Unfortunately, we have to manually opt into specializations this way, given how `CacheEncoder`\n // and the encoding traits currently work.\n-impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n-    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx>) {\n+impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, FileEncoder>> for [u8] {\n+    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, FileEncoder>) {\n         self.encode(&mut e.encoder);\n     }\n }\n \n pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n     tcx: CTX,\n-    encoder: &mut CacheEncoder<'a, 'tcx>,\n+    encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n     CTX: QueryContext + 'tcx,\n     Q: super::QueryDescription<CTX>,\n-    Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n+    Q::Value: Encodable<CacheEncoder<'a, 'tcx, FileEncoder>>,\n {\n     let _timer = tcx\n         .dep_context()"}, {"sha": "87aedc6542d8d44a369dacbf183e274605e4a158", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -12,6 +12,7 @@ use rustc_query_system::query::{QueryContext, QueryJobId, QueryMap, QuerySideEff\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Diagnostic, Handler};\n+use rustc_serialize::opaque;\n \n use std::any::Any;\n use std::num::NonZeroU64;\n@@ -139,7 +140,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n \n     pub(super) fn encode_query_results(\n         self,\n-        encoder: &mut on_disk_cache::CacheEncoder<'_, 'tcx>,\n+        encoder: &mut on_disk_cache::CacheEncoder<'_, 'tcx, opaque::FileEncoder>,\n         query_result_index: &mut on_disk_cache::EncodedDepNodeIndex,\n     ) {\n         macro_rules! encode_queries {"}, {"sha": "7fde9c0119b855e30c588e376ec148e240d08523", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -19,8 +19,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::opaque::{FileEncodeResult, FileEncoder, IntEncodedWithFixedSize, MemDecoder};\n-use rustc_serialize::{Decodable, Decoder, Encodable};\n+use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use smallvec::SmallVec;\n use std::convert::TryInto;\n \n@@ -96,11 +96,11 @@ impl<K: DepKind> SerializedDepGraph<K> {\n     }\n }\n \n-impl<'a, K: DepKind + Decodable<MemDecoder<'a>>> Decodable<MemDecoder<'a>>\n+impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<'a>>\n     for SerializedDepGraph<K>\n {\n     #[instrument(level = \"debug\", skip(d))]\n-    fn decode(d: &mut MemDecoder<'a>) -> SerializedDepGraph<K> {\n+    fn decode(d: &mut opaque::Decoder<'a>) -> SerializedDepGraph<K> {\n         let start_position = d.position();\n \n         // The last 16 bytes are the node count and edge count."}, {"sha": "b2dbf937eb75a7155448945ebb2c3e6c7e03e10a", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -1,5 +1,5 @@\n use crate::leb128::{self, max_leb128_len};\n-use crate::serialize::{Decodable, Decoder, Encodable, Encoder};\n+use crate::serialize::{self, Decoder as _, Encoder as _};\n use std::convert::TryInto;\n use std::fs::File;\n use std::io::{self, Write};\n@@ -11,23 +11,19 @@ use std::ptr;\n // Encoder\n // -----------------------------------------------------------------------------\n \n-pub struct MemEncoder {\n+pub struct Encoder {\n     pub data: Vec<u8>,\n }\n \n-impl MemEncoder {\n-    pub fn new() -> MemEncoder {\n-        MemEncoder { data: vec![] }\n+impl Encoder {\n+    pub fn new() -> Encoder {\n+        Encoder { data: vec![] }\n     }\n \n     #[inline]\n     pub fn position(&self) -> usize {\n         self.data.len()\n     }\n-\n-    pub fn finish(self) -> Vec<u8> {\n-        self.data\n-    }\n }\n \n macro_rules! write_leb128 {\n@@ -57,7 +53,10 @@ macro_rules! write_leb128 {\n /// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n const STR_SENTINEL: u8 = 0xC1;\n \n-impl Encoder for MemEncoder {\n+impl serialize::Encoder for Encoder {\n+    type Ok = Vec<u8>;\n+    type Err = !;\n+\n     #[inline]\n     fn emit_usize(&mut self, v: usize) {\n         write_leb128!(self, v, usize, write_usize_leb128)\n@@ -151,14 +150,18 @@ impl Encoder for MemEncoder {\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n     }\n+\n+    fn finish(self) -> Result<Self::Ok, Self::Err> {\n+        Ok(self.data)\n+    }\n }\n \n pub type FileEncodeResult = Result<usize, io::Error>;\n \n // `FileEncoder` encodes data to file via fixed-size buffer.\n //\n // When encoding large amounts of data to a file, using `FileEncoder` may be\n-// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n+// preferred over using `Encoder` to encode to a `Vec`, and then writing the\n // `Vec` to file, as the latter uses as much memory as there is encoded data,\n // while the former uses the fixed amount of memory allocated to the buffer.\n // `FileEncoder` also has the advantage of not needing to reallocate as data\n@@ -386,13 +389,6 @@ impl FileEncoder {\n             }\n         }\n     }\n-\n-    pub fn finish(mut self) -> Result<usize, io::Error> {\n-        self.flush();\n-\n-        let res = std::mem::replace(&mut self.res, Ok(()));\n-        res.map(|()| self.position())\n-    }\n }\n \n impl Drop for FileEncoder {\n@@ -429,7 +425,10 @@ macro_rules! file_encoder_write_leb128 {\n     }};\n }\n \n-impl Encoder for FileEncoder {\n+impl serialize::Encoder for FileEncoder {\n+    type Ok = usize;\n+    type Err = io::Error;\n+\n     #[inline]\n     fn emit_usize(&mut self, v: usize) {\n         file_encoder_write_leb128!(self, v, usize, write_usize_leb128)\n@@ -523,21 +522,28 @@ impl Encoder for FileEncoder {\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.write_all(s);\n     }\n+\n+    fn finish(mut self) -> Result<usize, io::Error> {\n+        self.flush();\n+\n+        let res = std::mem::replace(&mut self.res, Ok(()));\n+        res.map(|()| self.position())\n+    }\n }\n \n // -----------------------------------------------------------------------------\n // Decoder\n // -----------------------------------------------------------------------------\n \n-pub struct MemDecoder<'a> {\n+pub struct Decoder<'a> {\n     pub data: &'a [u8],\n     position: usize,\n }\n \n-impl<'a> MemDecoder<'a> {\n+impl<'a> Decoder<'a> {\n     #[inline]\n-    pub fn new(data: &'a [u8], position: usize) -> MemDecoder<'a> {\n-        MemDecoder { data, position }\n+    pub fn new(data: &'a [u8], position: usize) -> Decoder<'a> {\n+        Decoder { data, position }\n     }\n \n     #[inline]\n@@ -560,7 +566,7 @@ macro_rules! read_leb128 {\n     ($dec:expr, $fun:ident) => {{ leb128::$fun($dec.data, &mut $dec.position) }};\n }\n \n-impl<'a> Decoder for MemDecoder<'a> {\n+impl<'a> serialize::Decoder for Decoder<'a> {\n     #[inline]\n     fn read_u128(&mut self) -> u128 {\n         read_leb128!(self, read_u128_leb128)\n@@ -682,25 +688,25 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n // Specialize encoding byte slices. This specialization also applies to encoding `Vec<u8>`s, etc.,\n // since the default implementations call `encode` on their slices internally.\n-impl Encodable<MemEncoder> for [u8] {\n-    fn encode(&self, e: &mut MemEncoder) {\n-        Encoder::emit_usize(e, self.len());\n+impl serialize::Encodable<Encoder> for [u8] {\n+    fn encode(&self, e: &mut Encoder) {\n+        serialize::Encoder::emit_usize(e, self.len());\n         e.emit_raw_bytes(self);\n     }\n }\n \n-impl Encodable<FileEncoder> for [u8] {\n+impl serialize::Encodable<FileEncoder> for [u8] {\n     fn encode(&self, e: &mut FileEncoder) {\n-        Encoder::emit_usize(e, self.len());\n+        serialize::Encoder::emit_usize(e, self.len());\n         e.emit_raw_bytes(self);\n     }\n }\n \n // Specialize decoding `Vec<u8>`. This specialization also applies to decoding `Box<[u8]>`s, etc.,\n // since the default implementations call `decode` to produce a `Vec<u8>` internally.\n-impl<'a> Decodable<MemDecoder<'a>> for Vec<u8> {\n-    fn decode(d: &mut MemDecoder<'a>) -> Self {\n-        let len = Decoder::read_usize(d);\n+impl<'a> serialize::Decodable<Decoder<'a>> for Vec<u8> {\n+    fn decode(d: &mut Decoder<'a>) -> Self {\n+        let len = serialize::Decoder::read_usize(d);\n         d.read_raw_bytes(len).to_owned()\n     }\n }\n@@ -712,17 +718,17 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl Encodable<MemEncoder> for IntEncodedWithFixedSize {\n+impl serialize::Encodable<Encoder> for IntEncodedWithFixedSize {\n     #[inline]\n-    fn encode(&self, e: &mut MemEncoder) {\n+    fn encode(&self, e: &mut Encoder) {\n         let _start_pos = e.position();\n         e.emit_raw_bytes(&self.0.to_le_bytes());\n         let _end_pos = e.position();\n         debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n     }\n }\n \n-impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n+impl serialize::Encodable<FileEncoder> for IntEncodedWithFixedSize {\n     #[inline]\n     fn encode(&self, e: &mut FileEncoder) {\n         let _start_pos = e.position();\n@@ -732,9 +738,9 @@ impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n     }\n }\n \n-impl<'a> Decodable<MemDecoder<'a>> for IntEncodedWithFixedSize {\n+impl<'a> serialize::Decodable<Decoder<'a>> for IntEncodedWithFixedSize {\n     #[inline]\n-    fn decode(decoder: &mut MemDecoder<'a>) -> IntEncodedWithFixedSize {\n+    fn decode(decoder: &mut Decoder<'a>) -> IntEncodedWithFixedSize {\n         let _start_pos = decoder.position();\n         let bytes = decoder.read_raw_bytes(IntEncodedWithFixedSize::ENCODED_SIZE);\n         let value = u64::from_le_bytes(bytes.try_into().unwrap());"}, {"sha": "98bb18581f517f03a0d7d6b48f4bc6001e021232", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -18,10 +18,13 @@ use std::sync::Arc;\n /// is pervasive and has non-trivial cost. Instead, impls of this trait must\n /// implement a delayed error handling strategy. If a failure occurs, they\n /// should record this internally, and all subsequent encoding operations can\n-/// be processed or ignored, whichever is appropriate. Then they should provide\n-/// a `finish` method that finishes up encoding. If the encoder is fallible,\n-/// `finish` should return a `Result` that indicates success or failure.\n+/// be processed or ignored, whichever is appropriate. Then when `finish()` is\n+/// called, an error result should be returned to indicate the failure. If no\n+/// failures occurred, then `finish()` should return a success result.\n pub trait Encoder {\n+    type Ok;\n+    type Err;\n+\n     // Primitive types:\n     fn emit_usize(&mut self, v: usize);\n     fn emit_u128(&mut self, v: u128);\n@@ -61,6 +64,9 @@ pub trait Encoder {\n     fn emit_fieldless_enum_variant<const ID: usize>(&mut self) {\n         self.emit_usize(ID)\n     }\n+\n+    // Consume the encoder, getting the result.\n+    fn finish(self) -> Result<Self::Ok, Self::Err>;\n }\n \n // Note: all the methods in this trait are infallible, which may be surprising."}, {"sha": "703b7f5e7a5f468f217b70466949c5ede51713cc", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -1,8 +1,8 @@\n #![allow(rustc::internal)]\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::opaque::{Decoder, Encoder};\n+use rustc_serialize::{Decodable, Encodable, Encoder as EncoderTrait};\n use std::fmt::Debug;\n \n #[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n@@ -28,18 +28,16 @@ struct Struct {\n     q: Option<u32>,\n }\n \n-fn check_round_trip<\n-    T: Encodable<MemEncoder> + for<'a> Decodable<MemDecoder<'a>> + PartialEq + Debug,\n->(\n+fn check_round_trip<T: Encodable<Encoder> + for<'a> Decodable<Decoder<'a>> + PartialEq + Debug>(\n     values: Vec<T>,\n ) {\n-    let mut encoder = MemEncoder::new();\n+    let mut encoder = Encoder::new();\n     for value in &values {\n         Encodable::encode(value, &mut encoder);\n     }\n \n-    let data = encoder.finish();\n-    let mut decoder = MemDecoder::new(&data[..], 0);\n+    let data = encoder.finish().unwrap();\n+    let mut decoder = Decoder::new(&data[..], 0);\n \n     for value in values {\n         let decoded = Decodable::decode(&mut decoder);"}, {"sha": "7f227217e3c2f88fb425ac8bb43f0b178cbbd11d", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -1911,13 +1911,13 @@ impl_pos! {\n     pub struct CharPos(pub usize);\n }\n \n-impl<S: Encoder> Encodable<S> for BytePos {\n+impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n     fn encode(&self, s: &mut S) {\n         s.emit_u32(self.0);\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for BytePos {\n+impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {\n     fn decode(d: &mut D) -> BytePos {\n         BytePos(d.read_u32())\n     }"}, {"sha": "a6a0d02c8ba992caf9acb36ce7cc6c19d0dbba63", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -14,7 +14,7 @@ use crate::UintTy;\n use self::TyKind::*;\n \n use rustc_data_structures::stable_hasher::HashStable;\n-use rustc_serialize::{Decodable, Decoder, Encodable};\n+use rustc_serialize::{Decodable, Encodable};\n \n /// Defines the kinds of types used by the type system.\n ///\n@@ -833,34 +833,56 @@ where\n     I::AllocId: Decodable<D>,\n {\n     fn decode(d: &mut D) -> Self {\n-        match Decoder::read_usize(d) {\n+        match rustc_serialize::Decoder::read_usize(d) {\n             0 => Bool,\n             1 => Char,\n-            2 => Int(Decodable::decode(d)),\n-            3 => Uint(Decodable::decode(d)),\n-            4 => Float(Decodable::decode(d)),\n-            5 => Adt(Decodable::decode(d), Decodable::decode(d)),\n-            6 => Foreign(Decodable::decode(d)),\n+            2 => Int(rustc_serialize::Decodable::decode(d)),\n+            3 => Uint(rustc_serialize::Decodable::decode(d)),\n+            4 => Float(rustc_serialize::Decodable::decode(d)),\n+            5 => Adt(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d)),\n+            6 => Foreign(rustc_serialize::Decodable::decode(d)),\n             7 => Str,\n-            8 => Array(Decodable::decode(d), Decodable::decode(d)),\n-            9 => Slice(Decodable::decode(d)),\n-            10 => RawPtr(Decodable::decode(d)),\n-            11 => Ref(Decodable::decode(d), Decodable::decode(d), Decodable::decode(d)),\n-            12 => FnDef(Decodable::decode(d), Decodable::decode(d)),\n-            13 => FnPtr(Decodable::decode(d)),\n-            14 => Dynamic(Decodable::decode(d), Decodable::decode(d)),\n-            15 => Closure(Decodable::decode(d), Decodable::decode(d)),\n-            16 => Generator(Decodable::decode(d), Decodable::decode(d), Decodable::decode(d)),\n-            17 => GeneratorWitness(Decodable::decode(d)),\n+            8 => {\n+                Array(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            9 => Slice(rustc_serialize::Decodable::decode(d)),\n+            10 => RawPtr(rustc_serialize::Decodable::decode(d)),\n+            11 => Ref(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            12 => {\n+                FnDef(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            13 => FnPtr(rustc_serialize::Decodable::decode(d)),\n+            14 => Dynamic(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            15 => Closure(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            16 => Generator(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            17 => GeneratorWitness(rustc_serialize::Decodable::decode(d)),\n             18 => Never,\n-            19 => Tuple(Decodable::decode(d)),\n-            20 => Projection(Decodable::decode(d)),\n-            21 => Opaque(Decodable::decode(d), Decodable::decode(d)),\n-            22 => Param(Decodable::decode(d)),\n-            23 => Bound(Decodable::decode(d), Decodable::decode(d)),\n-            24 => Placeholder(Decodable::decode(d)),\n-            25 => Infer(Decodable::decode(d)),\n-            26 => Error(Decodable::decode(d)),\n+            19 => Tuple(rustc_serialize::Decodable::decode(d)),\n+            20 => Projection(rustc_serialize::Decodable::decode(d)),\n+            21 => {\n+                Opaque(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            22 => Param(rustc_serialize::Decodable::decode(d)),\n+            23 => {\n+                Bound(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            24 => Placeholder(rustc_serialize::Decodable::decode(d)),\n+            25 => Infer(rustc_serialize::Decodable::decode(d)),\n+            26 => Error(rustc_serialize::Decodable::decode(d)),\n             _ => panic!(\n                 \"{}\",\n                 format!("}, {"sha": "242f926967c937201b83318c18b55e895f44d3ec", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -17,8 +17,8 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_serialize::{\n-    opaque::{FileEncoder, MemDecoder},\n-    Decodable, Encodable,\n+    opaque::{Decoder, FileEncoder},\n+    Decodable, Encodable, Encoder,\n };\n use rustc_session::getopts;\n use rustc_span::{\n@@ -336,7 +336,7 @@ pub(crate) fn load_call_locations(\n         let mut all_calls: AllCallLocations = FxHashMap::default();\n         for path in with_examples {\n             let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n-            let mut decoder = MemDecoder::new(&bytes, 0);\n+            let mut decoder = Decoder::new(&bytes, 0);\n             let calls = AllCallLocations::decode(&mut decoder);\n \n             for (function, fn_calls) in calls.into_iter() {"}, {"sha": "a09deeec4f182f6c1cdc136f65d2820d5d75cb68", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -7,7 +7,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable, Encoder};\n \n #[derive(Encodable, Decodable)]\n@@ -18,11 +18,11 @@ struct A {\n fn main() {\n     let obj = A { foo: Box::new([true, false]) };\n \n-    let mut encoder = MemEncoder::new();\n+    let mut encoder = opaque::Encoder::new();\n     obj.encode(&mut encoder);\n-    let data = encoder.finish();\n+    let data = encoder.finish().unwrap();\n \n-    let mut decoder = MemDecoder::new(&data, 0);\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = A::decode(&mut decoder);\n \n     assert_eq!(obj.foo, obj2.foo);"}, {"sha": "9b6fb0e580621ee2f7572ad6ae3aa9828b447e3c", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -9,7 +9,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable, Encoder};\n use std::cell::{Cell, RefCell};\n \n@@ -27,11 +27,11 @@ struct B {\n fn main() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n \n-    let mut encoder = MemEncoder::new();\n+    let mut encoder = opaque::Encoder::new();\n     obj.encode(&mut encoder);\n-    let data = encoder.finish();\n+    let data = encoder.finish().unwrap();\n \n-    let mut decoder = MemDecoder::new(&data, 0);\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = B::decode(&mut decoder);\n \n     assert_eq!(obj.foo.get(), obj2.foo.get());"}, {"sha": "4241456367e46fe0a25377aa58eb4a5029ebe1c4", "filename": "src/test/ui-fulldeps/issue-14021.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84594661c1b51feb539b479b58bb551fcf8e19a/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs?ref=c84594661c1b51feb539b479b58bb551fcf8e19a", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable, Encoder};\n \n #[derive(Encodable, Decodable, PartialEq, Debug)]\n@@ -17,11 +17,11 @@ struct UnitLikeStruct;\n pub fn main() {\n     let obj = UnitLikeStruct;\n \n-    let mut encoder = MemEncoder::new();\n+    let mut encoder = opaque::Encoder::new();\n     obj.encode(&mut encoder);\n-    let data = encoder.finish();\n+    let data = encoder.finish().unwrap();\n \n-    let mut decoder = MemDecoder::new(&data, 0);\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = UnitLikeStruct::decode(&mut decoder);\n \n     assert_eq!(obj, obj2);"}]}