{"sha": "3cce5c79778088a26f6099f293256d5d7834fdb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjY2U1Yzc5Nzc4MDg4YTI2ZjYwOTlmMjkzMjU2ZDVkNzgzNGZkYjM=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-11-07T03:31:09Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-11-10T03:11:40Z"}, "message": "Don't inline virtual calls (take 2)\n\nWhen I fixed the previous mis-optimizations, I didn't realize there were\nactually two different places where we mutate `callsites` and both of\nthem should have the same behavior.\n\nAs a result, if a function was inlined and that function contained\nvirtual function calls, they were incorrectly being inlined. I also\nadded a test case which covers this.", "tree": {"sha": "6684650ae06e79c0806415acb3e15e12cf076a51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6684650ae06e79c0806415acb3e15e12cf076a51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cce5c79778088a26f6099f293256d5d7834fdb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cce5c79778088a26f6099f293256d5d7834fdb3", "html_url": "https://github.com/rust-lang/rust/commit/3cce5c79778088a26f6099f293256d5d7834fdb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cce5c79778088a26f6099f293256d5d7834fdb3/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a50c29f6c5c386fba6ab685818755ac55152e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a50c29f6c5c386fba6ab685818755ac55152e5", "html_url": "https://github.com/rust-lang/rust/commit/36a50c29f6c5c386fba6ab685818755ac55152e5"}], "stats": {"total": 130, "additions": 85, "deletions": 45}, "files": [{"sha": "1cce0de5152fda7bd649b1b92c80235f9a2958d6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3cce5c79778088a26f6099f293256d5d7834fdb3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cce5c79778088a26f6099f293256d5d7834fdb3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=3cce5c79778088a26f6099f293256d5d7834fdb3", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, InstanceDef, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -85,39 +85,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir.as_local_node_id(self.source.def_id).unwrap();\n         let body_owner_kind = self.tcx.hir.body_owner_kind(id);\n+\n         if let (hir::BodyOwnerKind::Fn, None) = (body_owner_kind, self.source.promoted) {\n \n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n-                // Don't inline calls that are in cleanup blocks.\n-                if bb_data.is_cleanup { continue; }\n-\n-                // Only consider direct calls to functions\n-                let terminator = bb_data.terminator();\n-                if let TerminatorKind::Call {\n-                    func: ref op, .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n-                            if let Some(instance) = Instance::resolve(self.tcx,\n-                                                                      param_env,\n-                                                                      callee_def_id,\n-                                                                      substs) {\n-                                let is_virtual =\n-                                    if let InstanceDef::Virtual(..) = instance.def {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                if !is_virtual {\n-                                    callsites.push_back(CallSite {\n-                                        callee: instance.def_id(),\n-                                        substs: instance.substs,\n-                                        bb,\n-                                        location: terminator.source_info\n-                                    });\n-                                }\n-                            }\n-                        }\n-                    }\n+                if let Some(callsite) = self.get_valid_function_call(bb,\n+                                                                     bb_data,\n+                                                                     caller_mir,\n+                                                                     param_env) {\n+                    callsites.push_back(callsite);\n+                }\n             }\n         } else {\n             return;\n@@ -163,20 +140,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n-                    // Only consider direct calls to functions\n-                    let terminator = bb_data.terminator();\n-                    if let TerminatorKind::Call {\n-                        func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n-                            // Don't inline the same function multiple times.\n-                            if callsite.callee != callee_def_id {\n-                                callsites.push_back(CallSite {\n-                                    callee: callee_def_id,\n-                                    substs,\n-                                    bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n+                    if let Some(new_callsite) = self.get_valid_function_call(bb,\n+                                                                             bb_data,\n+                                                                             caller_mir,\n+                                                                             param_env) {\n+                        // Don't inline the same function multiple times.\n+                        if callsite.callee != new_callsite.callee {\n+                            callsites.push_back(new_callsite);\n                         }\n                     }\n                 }\n@@ -198,6 +168,40 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n+    fn get_valid_function_call(&self,\n+                               bb: BasicBlock,\n+                               bb_data: &BasicBlockData<'tcx>,\n+                               caller_mir: &Mir<'tcx>,\n+                               param_env: ParamEnv<'tcx>,\n+    ) -> Option<CallSite<'tcx>> {\n+        // Don't inline calls that are in cleanup blocks.\n+        if bb_data.is_cleanup { return None; }\n+\n+        // Only consider direct calls to functions\n+        let terminator = bb_data.terminator();\n+        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n+                let instance = Instance::resolve(self.tcx,\n+                                                 param_env,\n+                                                 callee_def_id,\n+                                                 substs)?;\n+\n+                if let InstanceDef::Virtual(..) = instance.def {\n+                    return None;\n+                }\n+\n+                return Some(CallSite {\n+                    callee: instance.def_id(),\n+                    substs: instance.substs,\n+                    bb,\n+                    location: terminator.source_info\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n                            callee_mir: &Mir<'tcx>)"}, {"sha": "aa756f4a2337058da474c8484529e98fee5a653a", "filename": "src/test/mir-opt/inline-trait-method_2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3cce5c79778088a26f6099f293256d5d7834fdb3/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cce5c79778088a26f6099f293256d5d7834fdb3/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs?ref=3cce5c79778088a26f6099f293256d5d7834fdb3", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -Z span_free_formats -Z mir-opt-level=3\n+\n+#[inline]\n+fn test(x: &dyn X) -> bool {\n+    x.y()\n+}\n+\n+fn test2(x: &dyn X) -> bool {\n+    test(x)\n+}\n+\n+trait X {\n+    fn y(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl X for () {\n+    fn y(&self) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Should be true: {}\", test2(&()));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.test2.Inline.after.mir\n+// ...\n+// bb0: {\n+// ...\n+//     _0 = const X::y(move _2) -> bb1;\n+// }\n+// ...\n+// END rustc.test2.Inline.after.mir"}]}