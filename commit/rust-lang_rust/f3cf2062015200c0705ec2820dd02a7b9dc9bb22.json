{"sha": "f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzY2YyMDYyMDE1MjAwYzA3MDVlYzI4MjBkZDAyYTdiOWRjOWJiMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T23:33:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T23:33:18Z"}, "message": "Auto merge of #43836 - taleks:issue-39827, r=arielb1\n\nFix for issue #39827\n\n*Cause of the issue*\n\nWhile preparing for `trans_intrinsic_call()` invoke arguments are processed with `trans_argument()` method which excludes zero-sized types from argument list (to be more correct - all arguments for which `ArgKind` is `Ignore` are filtered out). As result `volatile_store()` intrinsic gets one argument instead of expected address and value.\n\n*How it is fixed*\n\nModification of the `trans_argument()` method may cause side effects, therefore change was implemented in `volatile_store()` intrinsic building code itself. Now it checks function signature and if it was specialised with zero-sized type, then emits `C_nil()` instead of accessing non-existing second argument.", "tree": {"sha": "b149697c31af598a1db90730d72d8dca1d2cd8b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b149697c31af598a1db90730d72d8dca1d2cd8b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "html_url": "https://github.com/rust-lang/rust/commit/f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "html_url": "https://github.com/rust-lang/rust/commit/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8"}, {"sha": "faf6b84304dbc96f7bf142973f394f820e390a4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf6b84304dbc96f7bf142973f394f820e390a4c", "html_url": "https://github.com/rust-lang/rust/commit/faf6b84304dbc96f7bf142973f394f820e390a4c"}], "stats": {"total": 67, "additions": 63, "deletions": 4}, "files": [{"sha": "ad776c8605ac83cef3dec2ce8194603fa6f1a5f8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "patch": "@@ -1044,20 +1044,23 @@ extern \"rust-intrinsic\" {\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n                                                   count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero..\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer."}, {"sha": "e35777d222c0657475fb1f490a7c7093359c3245", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "patch": "@@ -384,6 +384,11 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// The compiler shouldn't change the relative order or number of volatile\n+/// memory operations. However, volatile memory operations on zero-sized types\n+/// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// and may be ignored.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety\n@@ -427,6 +432,11 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// The compiler shouldn't change the relative order or number of volatile\n+/// memory operations. However, volatile memory operations on zero-sized types\n+/// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// and may be ignored.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety"}, {"sha": "033ef988571dd263a5ad4c82161a3a522b89b2a3", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "patch": "@@ -246,7 +246,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let val = if fn_ty.args[1].is_indirect() {\n                     bcx.load(llargs[1], None)\n                 } else {\n-                    from_immediate(bcx, llargs[1])\n+                    if !type_is_zero_size(ccx, tp_ty) {\n+                        from_immediate(bcx, llargs[1])\n+                    } else {\n+                        C_nil(ccx)\n+                    }\n                 };\n                 let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);"}, {"sha": "b753cf5844fa9185d34d88eed9e81d1b10968ecb", "filename": "src/test/run-pass/issue-39827.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Ftest%2Frun-pass%2Fissue-39827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cf2062015200c0705ec2820dd02a7b9dc9bb22/src%2Ftest%2Frun-pass%2Fissue-39827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39827.rs?ref=f3cf2062015200c0705ec2820dd02a7b9dc9bb22", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics::{ volatile_copy_memory, volatile_store, volatile_load,\n+                       volatile_copy_nonoverlapping_memory,\n+                       volatile_set_memory };\n+\n+//\n+// This test ensures that volatile intrinsics can be specialised with\n+// zero-sized types and, in case of copy/set functions, can accept\n+// number of elements equal to zero.\n+//\n+fn main () {\n+    let mut dst_pair = (1, 2);\n+    let src_pair = (3, 4);\n+    let mut dst_empty = ();\n+    let src_empty = ();\n+\n+    const COUNT_0: usize = 0;\n+    const COUNT_100: usize = 100;\n+\n+    unsafe {\n+        volatile_copy_memory(&mut dst_pair, &dst_pair, COUNT_0);\n+        volatile_copy_nonoverlapping_memory(&mut dst_pair, &src_pair, 0);\n+        volatile_copy_memory(&mut dst_empty, &dst_empty, 100);\n+        volatile_copy_nonoverlapping_memory(&mut dst_empty, &src_empty,\n+                                            COUNT_100);\n+        volatile_set_memory(&mut dst_empty, 0, COUNT_100);\n+        volatile_set_memory(&mut dst_pair, 0, COUNT_0);\n+        volatile_store(&mut dst_empty, ());\n+        volatile_store(&mut dst_empty, src_empty);\n+        volatile_load(&src_empty);\n+    }\n+}"}]}