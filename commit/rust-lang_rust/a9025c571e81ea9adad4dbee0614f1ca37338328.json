{"sha": "a9025c571e81ea9adad4dbee0614f1ca37338328", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDI1YzU3MWU4MWVhOWFkYWQ0ZGJlZTA2MTRmMWNhMzczMzgzMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T04:10:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T04:10:39Z"}, "message": "Auto merge of #74621 - LukasKalbertodt:float-docs, r=GuillaumeGomez\n\nImprove `f32` and `f64` primitive documentation\n\nI noticed that the docs for the primitive floats were fairly short. I first only wanted to add the IEEE specification information (compare [the reference](https://doc.rust-lang.org/reference/types/numeric.html)), but then also added some more beginner-friendly docs. Let me know what you think!\n\nRandom doc team assign:\nr? @rylev", "tree": {"sha": "6ce22584f85953eb9409b351432a0e3699db4d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ce22584f85953eb9409b351432a0e3699db4d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9025c571e81ea9adad4dbee0614f1ca37338328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9025c571e81ea9adad4dbee0614f1ca37338328", "html_url": "https://github.com/rust-lang/rust/commit/a9025c571e81ea9adad4dbee0614f1ca37338328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9025c571e81ea9adad4dbee0614f1ca37338328/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "html_url": "https://github.com/rust-lang/rust/commit/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7"}, {"sha": "e4d27fab92cbcc4c3dc5ddbdcb5077279d4e7f12", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d27fab92cbcc4c3dc5ddbdcb5077279d4e7f12", "html_url": "https://github.com/rust-lang/rust/commit/e4d27fab92cbcc4c3dc5ddbdcb5077279d4e7f12"}], "stats": {"total": 44, "additions": 41, "deletions": 3}, "files": [{"sha": "f9c96b7c3d4b3ffdb8847e4aa179c9e459d3d5e0", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a9025c571e81ea9adad4dbee0614f1ca37338328/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9025c571e81ea9adad4dbee0614f1ca37338328/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=a9025c571e81ea9adad4dbee0614f1ca37338328", "patch": "@@ -764,19 +764,57 @@ mod prim_str {}\n mod prim_tuple {}\n \n #[doc(primitive = \"f32\")]\n-/// The 32-bit floating point type.\n+/// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n+///\n+/// This type can represent a wide range of decimal numbers, like `3.5`, `27`,\n+/// `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\n+/// (like `i32`), floating point types can represent non-integer numbers, too.\n+///\n+/// However, being able to represent this wide range of numbers comes at the\n+/// cost of precision: floats can only represent some of the real numbers and\n+/// calculation with floats round to a nearby representable number. For example,\n+/// `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\n+/// in `0.20000000298023223876953125` since `0.2` cannot be exactly represented\n+/// as `f32`. Note however, that printing floats with `println` and friends will\n+/// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n+/// print `0.2`.\n+///\n+/// The precision is better for numbers near 0 and worse for large numbers. For\n+/// example, above 2<sup>24</sup>, not even all integers are representable.\n+///\n+/// Additionally, `f32` can represent a couple of special values:\n+///\n+/// - `-0`: this is just due to how floats are encoded. It is semantically\n+///   equivalent to `0` and `-0.0 == 0.0` results in `true`.\n+/// - [\u221e](#associatedconstant.INFINITY) and\n+///   [-\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n+///   like `1.0 / 0.0`.\n+/// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n+///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n+///   behavior: it is unequal to any float, including itself! It is also neither\n+///   smaller nor greater than any float, making it impossible to sort. Lastly,\n+///   it is considered infectious as almost all calculations where one of the\n+///   operands is NaN will also result in NaN.\n+///\n+/// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///\n /// *[See also the `std::f32::consts` module](f32/consts/index.html).*\n ///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_f32 {}\n \n #[doc(primitive = \"f64\")]\n-//\n-/// The 64-bit floating point type.\n+/// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n+///\n+/// This type is very similar to [`f32`](primitive.f32.html), but has increased\n+/// precision by using twice as many bits. Please see [the documentation for\n+/// `f32`](primitive.f32.html) or [Wikipedia on double precision\n+/// values][wikipedia] for more information.\n ///\n /// *[See also the `std::f64::consts` module](f64/consts/index.html).*\n ///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_f64 {}\n "}]}