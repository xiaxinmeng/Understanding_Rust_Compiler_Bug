{"sha": "b8093bad581c8e23883f254f052fe7a3b7d14a3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MDkzYmFkNTgxYzhlMjM4ODNmMjU0ZjA1MmZlN2EzYjdkMTRhM2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-24T20:32:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-24T20:32:29Z"}, "message": "Rollup merge of #70241 - RalfJung:global-mem, r=oli-obk\n\nMiri: move ModifiedStatic to ConstEval errors\n\nAlso generally adjust terminology from \"static\" to \"global\" where appropriate (to avoid confusion with specifically `static` items).", "tree": {"sha": "33ff88c5f8f4affe546f16e9f69e1ed2501725dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ff88c5f8f4affe546f16e9f69e1ed2501725dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8093bad581c8e23883f254f052fe7a3b7d14a3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeem5dCRBK7hj4Ov3rIwAAdHIIAHElmujqTRYro0t+t11IcrTm\nXL8F+j3oFck4/gUljl85ILS4PehT6OhcgRo9I2leiZG5x/LlT5C1oWatnPATyJKh\nB/o3PR8e2uRvKd1G+Q/H472ssB1ab0Slig9l9Xj/qlthO0VgdYo3nmS4ZqGg7hFF\nCgLz1NbADp05t2tkvWfqnOQxjuwBTkYoKm2J0gPcf/kubqnYVre6p4PGPkLUv/q3\nDBK++EjgpDl1GAujdjhGSmFLeP4C0FIjsPB2Q/5ON3d04WW9BgDAdDU9I0OrWnQ9\nUYSwQ5oLp/l6Tt7UZ6Nc/J72K8kBuSErOB+SjXkT3QX0HK6fPKyO8ljyOIV+8/I=\n=Bxws\n-----END PGP SIGNATURE-----\n", "payload": "tree 33ff88c5f8f4affe546f16e9f69e1ed2501725dc\nparent 50d2f302cbf512271eac3e6242f08e7d77e1a2f3\nparent 1939b4c940be8569eadbb556e3987534a3d26594\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585081949 +0100\ncommitter GitHub <noreply@github.com> 1585081949 +0100\n\nRollup merge of #70241 - RalfJung:global-mem, r=oli-obk\n\nMiri: move ModifiedStatic to ConstEval errors\n\nAlso generally adjust terminology from \"static\" to \"global\" where appropriate (to avoid confusion with specifically `static` items).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8093bad581c8e23883f254f052fe7a3b7d14a3a", "html_url": "https://github.com/rust-lang/rust/commit/b8093bad581c8e23883f254f052fe7a3b7d14a3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8093bad581c8e23883f254f052fe7a3b7d14a3a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d2f302cbf512271eac3e6242f08e7d77e1a2f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d2f302cbf512271eac3e6242f08e7d77e1a2f3", "html_url": "https://github.com/rust-lang/rust/commit/50d2f302cbf512271eac3e6242f08e7d77e1a2f3"}, {"sha": "1939b4c940be8569eadbb556e3987534a3d26594", "url": "https://api.github.com/repos/rust-lang/rust/commits/1939b4c940be8569eadbb556e3987534a3d26594", "html_url": "https://github.com/rust-lang/rust/commit/1939b4c940be8569eadbb556e3987534a3d26594"}], "stats": {"total": 290, "additions": 179, "deletions": 111}, "files": [{"sha": "f7871952452128b4dc78b173bf1fad043893a7dd", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -453,9 +453,6 @@ pub enum UnsupportedOpInfo {\n     ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n     NoMirFor(DefId),\n-    /// Modified a static during const-eval.\n-    /// FIXME: move this to `ConstEvalErrKind` through a machine hook.\n-    ModifiedStatic,\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n     /// Encountered raw bytes where we needed a pointer.\n@@ -471,12 +468,6 @@ impl fmt::Debug for UnsupportedOpInfo {\n                 write!(f, \"tried to read from foreign (extern) static {:?}\", did)\n             }\n             NoMirFor(did) => write!(f, \"could not load MIR for {:?}\", did),\n-            ModifiedStatic => write!(\n-                f,\n-                \"tried to modify a static's initial value from another static's \\\n-                    initializer\"\n-            ),\n-\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n             ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),\n         }"}, {"sha": "1dc2f2a6f248b00ade6dd45ff2d9e49a66da59e1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -984,6 +984,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n+    /// Stores memory for globals (statics/consts).\n     pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: ShardedHashMap<&'tcx LayoutDetails, ()>,"}, {"sha": "aa30f43df93500018eebc19b9fb7abb95303dc7d", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -12,6 +12,7 @@ use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n pub enum ConstEvalErrKind {\n     NeedsRfc(String),\n     ConstAccessesStatic,\n+    ModifiedGlobal,\n     AssertFailure(AssertKind<u64>),\n     Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n }\n@@ -33,6 +34,9 @@ impl fmt::Display for ConstEvalErrKind {\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+            ModifiedGlobal => {\n+                write!(f, \"modifying a static's initial value from another static's initializer\")\n+            }\n             AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)"}, {"sha": "8f4501cc3fb69ace1fd213244a418c1bab5d4275", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -8,8 +8,9 @@ use std::hash::Hash;\n use rustc_data_structures::fx::FxHashMap;\n \n use rustc::mir::AssertMessage;\n-use rustc_span::source_map::Span;\n+use rustc_ast::ast::Mutability;\n use rustc_span::symbol::Symbol;\n+use rustc_span::{def_id::DefId, Span};\n \n use crate::interpret::{\n     self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n@@ -167,7 +168,7 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n-    type MemoryKinds = !;\n+    type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n \n@@ -177,7 +178,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n \n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n-    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+    const GLOBAL_KIND: Option<!> = None; // no copying of globals allowed\n \n     // We do not check for alignment to avoid having to carry an `Align`\n     // in `ConstValue::ByRef`.\n@@ -317,7 +318,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n+    fn tag_global_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -345,11 +346,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n         Ok(())\n     }\n \n-    fn before_access_static(\n+    fn before_access_global(\n         memory_extra: &MemoryExtra,\n-        _allocation: &Allocation,\n+        alloc_id: AllocId,\n+        allocation: &Allocation,\n+        def_id: Option<DefId>,\n+        is_write: bool,\n     ) -> InterpResult<'tcx> {\n-        if memory_extra.can_access_statics {\n+        if is_write && allocation.mutability == Mutability::Not {\n+            Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n+        } else if is_write {\n+            Err(ConstEvalErrKind::ModifiedGlobal.into())\n+        } else if memory_extra.can_access_statics || def_id.is_none() {\n+            // `def_id.is_none()` indicates this is not a static, but a const or so.\n             Ok(())\n         } else {\n             Err(ConstEvalErrKind::ConstAccessesStatic.into())"}, {"sha": "c50146f295adb67e8517934a7408f619f2732e08", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -253,8 +253,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This represents a *direct* access to that memory, as opposed to access\n     /// through a pointer that was created by the program.\n     #[inline(always)]\n-    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        self.memory.tag_static_base_pointer(ptr)\n+    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        self.memory.tag_global_base_pointer(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "b9ed69842f1a9b28beaffdedf30170b241f6b149", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -16,7 +16,7 @@ use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, Scalar\n pub trait CompileTimeMachine<'mir, 'tcx> = Machine<\n     'mir,\n     'tcx,\n-    MemoryKinds = !,\n+    MemoryKind = !,\n     PointerTag = (),\n     ExtraFnVal = !,\n     FrameExtra = (),\n@@ -104,7 +104,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         MemoryKind::Stack | MemoryKind::Vtable | MemoryKind::CallerLocation => {}\n     }\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n-    // read-only memory, and also by Miri when evluating other constants/statics that\n+    // read-only memory, and also by Miri when evaluating other globals that\n     // access this one.\n     if mode == InternMode::Static {\n         // When `ty` is `None`, we assume no interior mutability."}, {"sha": "cc87c2916862be2e88b414ae56b07a530f4c2482", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc_span::Span;\n+use rustc_span::{def_id::DefId, Span};\n \n use super::{\n     AllocId, Allocation, AllocationExtra, Frame, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n@@ -79,7 +79,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n+    type MemoryKind: ::std::fmt::Debug + MayLeak + Eq + 'static;\n \n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n@@ -105,16 +105,17 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKinds>, Allocation<Self::PointerTag, Self::AllocExtra>),\n+            (MemoryKind<Self::MemoryKind>, Allocation<Self::PointerTag, Self::AllocExtra>),\n         > + Default\n         + Clone;\n \n-    /// The memory kind to use for copied statics -- or None if statics should not be mutated\n-    /// and thus any such attempt will cause a `ModifiedStatic` error to be raised.\n+    /// The memory kind to use for copied global memory (held in `tcx`) --\n+    /// or None if such memory should not be mutated and thus any such attempt will cause\n+    /// a `ModifiedStatic` error to be raised.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n-    /// `tag_allocation` or `find_foreign_static` (see below) returns an owned allocation\n+    /// `tag_allocation` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n-    const STATIC_KIND: Option<Self::MemoryKinds>;\n+    const GLOBAL_KIND: Option<Self::MemoryKind>;\n \n     /// Whether memory accesses should be alignment-checked.\n     const CHECK_ALIGN: bool;\n@@ -207,11 +208,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called before a `Static` value is accessed.\n+    /// Called before a global allocation is accessed.\n+    /// `def_id` is `Some` if this is the \"lazy\" allocation of a static.\n     #[inline]\n-    fn before_access_static(\n+    fn before_access_global(\n         _memory_extra: &Self::MemoryExtra,\n+        _alloc_id: AllocId,\n         _allocation: &Allocation,\n+        _def_id: Option<DefId>,\n+        _is_write: bool,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -231,10 +236,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n     /// This keeps uniform code paths for handling both allocations created by CTFE\n-    /// for statics, and allocations created by Miri during evaluation.\n+    /// for globals, and allocations created by Miri during evaluation.\n     ///\n     /// `kind` is the kind of the allocation being tagged; it can be `None` when\n-    /// it's a static and `STATIC_KIND` is `None`.\n+    /// it's a global and `GLOBAL_KIND` is `None`.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n@@ -243,20 +248,20 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Also return the \"base\" tag to use for this allocation: the one that is used for direct\n     /// accesses to this allocation. If `kind == STATIC_KIND`, this tag must be consistent\n-    /// with `tag_static_base_pointer`.\n+    /// with `tag_global_base_pointer`.\n     fn init_allocation_extra<'b>(\n         memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n-        kind: Option<MemoryKind<Self::MemoryKinds>>,\n+        kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n-    /// Return the \"base\" tag for the given *static* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a static allocation,\n+    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n     /// this will return an unusable tag (i.e., accesses will be UB)!\n     ///\n     /// Expects `id` to be already canonical, if needed.\n-    fn tag_static_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n+    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n     #[inline]"}, {"sha": "110f2ffd9d78c8045affa8d9e6545e415d1785c3", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -80,12 +80,12 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine. The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation. When an allocation is not found here, it is a\n-    /// static and looked up in the `tcx` for read access. Some machines may\n-    /// have to mutate this map even on a read-only access to a static (because\n+    /// global and looked up in the `tcx` for read access. Some machines may\n+    /// have to mutate this map even on a read-only access to a global (because\n     /// they do pointer provenance tracking and the allocations in `tcx` have\n     /// the wrong type), so we let the machine override this type.\n-    /// Either way, if the machine allows writing to a static, doing so will\n-    /// create a copy of the static allocation here.\n+    /// Either way, if the machine allows writing to a global, doing so will\n+    /// create a copy of the global allocation here.\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) alloc_map: M::MemoryMap,\n \n@@ -130,9 +130,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// This represents a *direct* access to that memory, as opposed to access\n     /// through a pointer that was created by the program.\n     #[inline]\n-    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        ptr.with_tag(M::tag_static_base_pointer(&self.extra, id))\n+        ptr.with_tag(M::tag_global_base_pointer(&self.extra, id))\n     }\n \n     pub fn create_fn_alloc(\n@@ -149,23 +149,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 id\n             }\n         };\n-        self.tag_static_base_pointer(Pointer::from(id))\n+        self.tag_global_base_pointer(Pointer::from(id))\n     }\n \n     pub fn allocate(\n         &mut self,\n         size: Size,\n         align: Align,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::undef(size, align);\n         self.allocate_with(alloc, kind)\n     }\n \n-    pub fn allocate_static_bytes(\n+    pub fn allocate_bytes(\n         &mut self,\n         bytes: &[u8],\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_byte_aligned_bytes(bytes);\n         self.allocate_with(alloc, kind)\n@@ -174,13 +174,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn allocate_with(\n         &mut self,\n         alloc: Allocation,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n         debug_assert_ne!(\n             Some(kind),\n-            M::STATIC_KIND.map(MemoryKind::Machine),\n-            \"dynamically allocating static memory\"\n+            M::GLOBAL_KIND.map(MemoryKind::Machine),\n+            \"dynamically allocating global memory\"\n         );\n         let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n@@ -193,7 +193,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             throw_ub_format!(\n@@ -215,9 +215,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    /// Deallocate a local, or do nothing if that local has been made into a static\n+    /// Deallocate a local, or do nothing if that local has been made into a global.\n     pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx> {\n-        // The allocation might be already removed by static interning.\n+        // The allocation might be already removed by global interning.\n         // This can only really happen in the CTFE instance, not in miri.\n         if self.alloc_map.contains_key(&ptr.alloc_id) {\n             self.deallocate(ptr, None, MemoryKind::Stack)\n@@ -230,7 +230,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n         old_size_and_align: Option<(Size, Align)>,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n@@ -244,7 +244,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n-                // Deallocating static memory -- always an error\n+                // Deallocating global memory -- always an error\n                 return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n                     Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => {\n@@ -403,43 +403,45 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    /// Helper function to obtain the global (tcx) allocation for a static.\n+    /// Helper function to obtain a global (tcx) allocation.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n     /// this machine use the same pointer tag, so it is indirected through\n     /// `M::tag_allocation`.\n-    ///\n-    /// Notice that every static has two `AllocId` that will resolve to the same\n-    /// thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n-    /// and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n-    /// `const_eval_raw` and it is the \"resolved\" ID.\n-    /// The resolved ID is never used by the interpreted progrma, it is hidden.\n-    /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n-    /// contains a reference to memory that was created during its evaluation (i.e., not to\n-    /// another static), those inner references only exist in \"resolved\" form.\n-    ///\n-    /// Assumes `id` is already canonical.\n-    fn get_static_alloc(\n+    fn get_global_alloc(\n         memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n         id: AllocId,\n+        is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n-        let alloc = match alloc {\n-            Some(GlobalAlloc::Memory(mem)) => Cow::Borrowed(mem),\n+        let (alloc, def_id) = match alloc {\n+            Some(GlobalAlloc::Memory(mem)) => {\n+                // Memory of a constant or promoted or anonymous memory referenced by a static.\n+                (mem, None)\n+            }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n-                // We got a \"lazy\" static that has not been computed yet.\n+                // Notice that every static has two `AllocId` that will resolve to the same\n+                // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n+                // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n+                // `const_eval_raw` and it is the \"resolved\" ID.\n+                // The resolved ID is never used by the interpreted progrma, it is hidden.\n+                // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n+                // contains a reference to memory that was created during its evaluation (i.e., not\n+                // to another static), those inner references only exist in \"resolved\" form.\n+                //\n+                // Assumes `id` is already canonical.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n+                    trace!(\"get_global_alloc: foreign item {:?}\", def_id);\n                     throw_unsup!(ReadForeignStatic(def_id))\n                 }\n-                trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n+                trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n                 let instance = Instance::mono(tcx.tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n-                // use the raw query here to break validation cycles. Later uses of the static\n-                // will call the full query anyway\n+                // Use the raw query here to break validation cycles. Later uses of the static\n+                // will call the full query anyway.\n                 let raw_const =\n                     tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n                         // no need to report anything, the const_eval call takes care of that\n@@ -454,18 +456,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let id = raw_const.alloc_id;\n                 let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n \n-                M::before_access_static(memory_extra, allocation)?;\n-                Cow::Borrowed(allocation)\n+                (allocation, Some(def_id))\n             }\n         };\n+        M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n+        let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let (alloc, tag) = M::init_allocation_extra(\n             memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n-            M::STATIC_KIND.map(MemoryKind::Machine),\n+            M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n-        debug_assert_eq!(tag, M::tag_static_base_pointer(memory_extra, id));\n+        debug_assert_eq!(tag, M::tag_global_base_pointer(memory_extra, id));\n         Ok(alloc)\n     }\n \n@@ -478,10 +481,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n-        // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n+        // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(&self.extra, self.tcx, id).map_err(Err)?;\n+            let alloc = Self::get_global_alloc(&self.extra, self.tcx, id, /*is_write*/ false)\n+                .map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -490,8 +494,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 Cow::Owned(alloc) => {\n                     // Need to put it into the map and return a ref to that\n-                    let kind = M::STATIC_KIND.expect(\n-                        \"I got an owned allocation that I have to copy but the machine does \\\n+                    let kind = M::GLOBAL_KIND.expect(\n+                        \"I got a global allocation that I have to copy but the machine does \\\n                             not expect that to happen\",\n                     );\n                     Ok((MemoryKind::Machine(kind), alloc))\n@@ -515,16 +519,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n-            // Need to make a copy, even if `get_static_alloc` is able\n+            // Need to make a copy, even if `get_global_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n+            let alloc = Self::get_global_alloc(memory_extra, tcx, id, /*is_write*/ true)?;\n             if alloc.mutability == Mutability::Not {\n                 throw_ub!(WriteToReadOnly(id))\n             }\n-            match M::STATIC_KIND {\n-                Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => throw_unsup!(ModifiedStatic),\n-            }\n+            let kind = M::GLOBAL_KIND.expect(\n+                \"I got a global allocation that I have to copy but the machine does \\\n+                    not expect that to happen\",\n+            );\n+            Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n         });\n         // Unpack the error type manually because type inference doesn't\n         // work otherwise (and we cannot help it because `impl Trait`)\n@@ -553,7 +558,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n-        // b) duplicate a static's allocation in miri\n+        // b) duplicate a global's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n             return Ok((alloc.size, alloc.align));\n         }\n@@ -728,7 +733,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     );\n                 }\n                 Err(()) => {\n-                    // static alloc?\n+                    // global alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             self.dump_alloc_helper("}, {"sha": "90fb7eb2bb3ac0cdf60f0c35b4a41c8d620dd5e9", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -517,7 +517,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let tag_scalar = |scalar| match scalar {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_static_base_pointer(ptr)),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_global_base_pointer(ptr)),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         };\n         // Early-return cases.\n@@ -547,7 +547,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n-                let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n+                let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             }\n             ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n@@ -559,7 +559,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start as u64), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.tag_static_base_pointer(ptr).into(),\n+                    self.tag_global_base_pointer(ptr).into(),\n                     (end - start) as u64, // len: `end - start`\n                     self,\n                 ))"}, {"sha": "6cf11c071e4f7edc767faaedd9bf0a13677a71b9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -290,7 +290,7 @@ where\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n     M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKind>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n@@ -1015,7 +1015,7 @@ where\n     pub fn allocate(\n         &mut self,\n         layout: TyLayout<'tcx>,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n@@ -1025,9 +1025,9 @@ where\n     pub fn allocate_str(\n         &mut self,\n         str: &str,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n+        let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n@@ -1118,7 +1118,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n-        let ptr = self.tag_static_base_pointer(Pointer::from(raw.alloc_id));\n+        let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }"}, {"sha": "cbb79637076bc3b31bcfcf3f4daef64a2eb86fc3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_session::lint;\n-use rustc_span::Span;\n+use rustc_span::{def_id::DefId, Span};\n use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n@@ -162,7 +162,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n struct ConstPropMachine;\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n-    type MemoryKinds = !;\n+    type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n \n@@ -172,7 +172,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n-    const STATIC_KIND: Option<!> = None;\n+    const GLOBAL_KIND: Option<!> = None;\n \n     const CHECK_ALIGN: bool = false;\n \n@@ -247,7 +247,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n+    fn tag_global_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -270,14 +270,23 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         l.access()\n     }\n \n-    fn before_access_static(\n+    fn before_access_global(\n         _memory_extra: &(),\n+        _alloc_id: AllocId,\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        def_id: Option<DefId>,\n+        is_write: bool,\n     ) -> InterpResult<'tcx> {\n-        // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n-        // the memory behind that in the future), then we can't const prop it\n-        if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n-            throw_machine_stop_str!(\"can't eval mutable statics in ConstProp\")\n+        if is_write {\n+            throw_machine_stop_str!(\"can't write to global\");\n+        }\n+        // If the static allocation is mutable or if it has relocations (it may be legal to mutate\n+        // the memory behind that in the future), then we can't const prop it.\n+        if allocation.mutability == Mutability::Mut {\n+            throw_machine_stop_str!(\"can't eval mutable globals in ConstProp\");\n+        }\n+        if def_id.is_some() && allocation.relocations().len() > 0 {\n+            throw_machine_stop_str!(\"can't eval statics with pointers in ConstProp\");\n         }\n \n         Ok(())"}, {"sha": "bf5e476d80045711821a4f014efab4ed776bb231", "filename": "src/test/ui/consts/const-eval/assign-to-static-within-other-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/assign-to-static-within-other-static.rs:10:5\n    |\n LL |     FOO = 5;\n-   |     ^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |     ^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "acc6fb026cd696352e91f36eea106f3612343070", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+// Make sure we cannot mutate globals.\n+\n+static mut GLOBAL: i32 = 0;\n+\n+const MUTATING_GLOBAL: () = {\n+    unsafe {\n+        GLOBAL = 99 //~ ERROR any use of this value will cause an error\n+        //~^ WARN skipping const checks\n+        //~| WARN skipping const checks\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "4e67d2c0fb85e88721f290c0c482c20b39004f0c", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -0,0 +1,29 @@\n+warning: skipping const checks\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL |         GLOBAL = 99\n+   |         ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL |         GLOBAL = 99\n+   |         ^^^^^^\n+\n+error: any use of this value will cause an error\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL | / const MUTATING_GLOBAL: () = {\n+LL | |     unsafe {\n+LL | |         GLOBAL = 99\n+   | |         ^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n+LL | |\n+LL | |\n+LL | |     }\n+LL | | };\n+   | |__-\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "8db75dd63cf2a0e5357f7e65bf3ee69bd4d52a98", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.mut_refs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/static_mut_containing_mut_ref2.rs:7:45\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "91f9dbd8d0b9efc8b1e385eebc9b604455af2daf", "filename": "src/test/ui/consts/static_mut_containing_mut_ref3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/static_mut_containing_mut_ref3.rs:3:31\n    |\n LL | static mut BAR: () = unsafe { FOO.0 = 99; };\n-   |                               ^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                               ^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "6c2bd13d433ad7f99ad93a8f72ca141130d79037", "filename": "src/test/ui/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8093bad581c8e23883f254f052fe7a3b7d14a3a/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr?ref=b8093bad581c8e23883f254f052fe7a3b7d14a3a", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/write-to-static-mut-in-static.rs:2:33\n    |\n LL | pub static mut B: () = unsafe { A = 1; };\n-   |                                 ^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                                 ^^^^^ modifying a static's initial value from another static's initializer\n \n error[E0391]: cycle detected when const-evaluating `C`\n   --> $DIR/write-to-static-mut-in-static.rs:5:34"}]}