{"sha": "bdb475cf6c5712e706146635c4dd8bf6b2e506ff", "node_id": "C_kwDOAAsO6NoAKGJkYjQ3NWNmNmM1NzEyZTcwNjE0NjYzNWM0ZGQ4YmY2YjJlNTA2ZmY", "commit": {"author": {"name": "Florian Bartels", "email": "Florian.Bartels@elektrobit.com", "date": "2023-03-18T17:45:51Z"}, "committer": {"name": "Florian Bartels", "email": "Florian.Bartels@elektrobit.com", "date": "2023-06-02T14:12:21Z"}, "message": "Retry to fork/spawn with exponential backoff", "tree": {"sha": "e90149da2097dd5ae40d8fea83aad6d8b2a62022", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e90149da2097dd5ae40d8fea83aad6d8b2a62022"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb475cf6c5712e706146635c4dd8bf6b2e506ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb475cf6c5712e706146635c4dd8bf6b2e506ff", "html_url": "https://github.com/rust-lang/rust/commit/bdb475cf6c5712e706146635c4dd8bf6b2e506ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb475cf6c5712e706146635c4dd8bf6b2e506ff/comments", "author": {"login": "flba-eb", "id": 108917393, "node_id": "U_kgDOBn3ykQ", "avatar_url": "https://avatars.githubusercontent.com/u/108917393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flba-eb", "html_url": "https://github.com/flba-eb", "followers_url": "https://api.github.com/users/flba-eb/followers", "following_url": "https://api.github.com/users/flba-eb/following{/other_user}", "gists_url": "https://api.github.com/users/flba-eb/gists{/gist_id}", "starred_url": "https://api.github.com/users/flba-eb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flba-eb/subscriptions", "organizations_url": "https://api.github.com/users/flba-eb/orgs", "repos_url": "https://api.github.com/users/flba-eb/repos", "events_url": "https://api.github.com/users/flba-eb/events{/privacy}", "received_events_url": "https://api.github.com/users/flba-eb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flba-eb", "id": 108917393, "node_id": "U_kgDOBn3ykQ", "avatar_url": "https://avatars.githubusercontent.com/u/108917393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flba-eb", "html_url": "https://github.com/flba-eb", "followers_url": "https://api.github.com/users/flba-eb/followers", "following_url": "https://api.github.com/users/flba-eb/following{/other_user}", "gists_url": "https://api.github.com/users/flba-eb/gists{/gist_id}", "starred_url": "https://api.github.com/users/flba-eb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flba-eb/subscriptions", "organizations_url": "https://api.github.com/users/flba-eb/orgs", "repos_url": "https://api.github.com/users/flba-eb/repos", "events_url": "https://api.github.com/users/flba-eb/events{/privacy}", "received_events_url": "https://api.github.com/users/flba-eb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0939ec13d88dfafcbb7f25314bd0d2f1519bf0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0939ec13d88dfafcbb7f25314bd0d2f1519bf0d5", "html_url": "https://github.com/rust-lang/rust/commit/0939ec13d88dfafcbb7f25314bd0d2f1519bf0d5"}], "stats": {"total": 54, "additions": 44, "deletions": 10}, "files": [{"sha": "f68f2541902548e225d3058c218585f73742e526", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bdb475cf6c5712e706146635c4dd8bf6b2e506ff/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb475cf6c5712e706146635c4dd8bf6b2e506ff/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=bdb475cf6c5712e706146635c4dd8bf6b2e506ff", "patch": "@@ -35,8 +35,20 @@ cfg_if::cfg_if! {\n     if #[cfg(all(target_os = \"nto\", target_env = \"nto71\"))] {\n         use crate::thread;\n         use libc::{c_char, posix_spawn_file_actions_t, posix_spawnattr_t};\n-        // arbitrary number of tries:\n-        const MAX_FORKSPAWN_TRIES: u32 = 4;\n+        use crate::time::Duration;\n+        // Get smallest amount of time we can sleep.\n+        // Return a common value if it cannot be determined.\n+        fn get_clock_resolution() -> Duration {\n+            let mut mindelay = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n+            if unsafe { libc::clock_getres(libc::CLOCK_MONOTONIC, &mut mindelay) } == 0\n+            {\n+                Duration::from_nanos(mindelay.tv_nsec as u64)\n+            } else {\n+                Duration::from_millis(1)\n+            }\n+        }\n+        // Arbitrary minimum sleep duration for retrying fork/spawn\n+        const MIN_FORKSPAWN_SLEEP: Duration = Duration::from_nanos(1);\n     }\n }\n \n@@ -163,12 +175,24 @@ impl Command {\n     unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n         use crate::sys::os::errno;\n \n-        let mut tries_left = MAX_FORKSPAWN_TRIES;\n+        let mut minimum_delay = None;\n+        let mut delay = MIN_FORKSPAWN_SLEEP;\n+\n         loop {\n             let r = libc::fork();\n-            if r == -1 as libc::pid_t && tries_left > 0 && errno() as libc::c_int == libc::EBADF {\n-                thread::yield_now();\n-                tries_left -= 1;\n+            if r == -1 as libc::pid_t && errno() as libc::c_int == libc::EBADF {\n+                if minimum_delay.is_none() {\n+                    minimum_delay = Some(get_clock_resolution());\n+                }\n+                if delay < minimum_delay.unwrap() {\n+                    // We cannot sleep this short (it would be longer).\n+                    // Yield instead.\n+                    thread::yield_now();\n+                } else {\n+                    thread::sleep(delay);\n+                }\n+                delay *= 2;\n+                continue;\n             } else {\n                 return cvt(r).map(|res| (res, -1));\n             }\n@@ -481,12 +505,22 @@ impl Command {\n             argv: *const *mut c_char,\n             envp: *const *mut c_char,\n         ) -> i32 {\n-            let mut tries_left = MAX_FORKSPAWN_TRIES;\n+            let mut minimum_delay = None;\n+            let mut delay = MIN_FORKSPAWN_SLEEP;\n             loop {\n                 match libc::posix_spawnp(pid, file, file_actions, attrp, argv, envp) {\n-                    libc::EBADF if tries_left > 0 => {\n-                        thread::yield_now();\n-                        tries_left -= 1;\n+                    libc::EBADF => {\n+                        if minimum_delay.is_none() {\n+                            minimum_delay = Some(get_clock_resolution());\n+                        }\n+                        if delay < minimum_delay.unwrap() {\n+                            // We cannot sleep this short (it would be longer).\n+                            // Yield instead.\n+                            thread::yield_now();\n+                        } else {\n+                            thread::sleep(delay);\n+                        }\n+                        delay *= 2;\n                         continue;\n                     }\n                     r => {"}]}