{"sha": "d63b3f9bbb66b6ec4c7eea42078fca23730761c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2M2IzZjliYmI2NmI2ZWM0YzdlZWE0MjA3OGZjYTIzNzMwNzYxYzE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-04T13:21:22Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-05T12:03:27Z"}, "message": "Remove duplicate unwrap_or_else", "tree": {"sha": "a8766c9494517170f3b750ad6cbdbc3304bc5cf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8766c9494517170f3b750ad6cbdbc3304bc5cf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d63b3f9bbb66b6ec4c7eea42078fca23730761c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d63b3f9bbb66b6ec4c7eea42078fca23730761c1", "html_url": "https://github.com/rust-lang/rust/commit/d63b3f9bbb66b6ec4c7eea42078fca23730761c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d63b3f9bbb66b6ec4c7eea42078fca23730761c1/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58e71896506edb701f276158bd2f47e8788a1133", "url": "https://api.github.com/repos/rust-lang/rust/commits/58e71896506edb701f276158bd2f47e8788a1133", "html_url": "https://github.com/rust-lang/rust/commit/58e71896506edb701f276158bd2f47e8788a1133"}], "stats": {"total": 90, "additions": 47, "deletions": 43}, "files": [{"sha": "295f1087d63ae1282fbdb93924cbaa363f9fbd1f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d63b3f9bbb66b6ec4c7eea42078fca23730761c1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63b3f9bbb66b6ec4c7eea42078fca23730761c1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d63b3f9bbb66b6ec4c7eea42078fca23730761c1", "patch": "@@ -377,7 +377,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         module_id: DefId,\n         item_name: Symbol,\n-        item_str: &'path str,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n \n@@ -399,7 +398,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .map(|out| {\n                         (\n                             Res::Primitive(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_str)),\n+                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_name)),\n                         )\n                     })\n             })\n@@ -413,7 +412,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 ResolutionFailure::NotResolved {\n                     module_id,\n                     partial_res: Some(Res::Primitive(prim_ty)),\n-                    unresolved: item_str.into(),\n+                    unresolved: item_name.to_string().into(),\n                 }\n                 .into()\n             })\n@@ -490,8 +489,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let tcx = self.cx.tcx;\n-\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -534,29 +531,44 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n-        // FIXME: are these both necessary?\n-        let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n+        // FIXME(#83862): this arbitrarily gives precedence to primitives over modules to support\n+        // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n+        // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n+        // primitives.\n+        resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n-        {\n-            ty_res\n-        } else {\n-            // FIXME: this is duplicated on the end of this function.\n-            return if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: None,\n-                    unresolved: path_root.into(),\n+            .and_then(|ty_res| {\n+                self.resolve_associated_item(ty_res, item_name, ns, module_id, extra_fragment)\n+            })\n+            .unwrap_or_else(|| {\n+                if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, module_id)\n+                } else {\n+                    Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: None,\n+                        unresolved: path_root.into(),\n+                    }\n+                    .into())\n                 }\n-                .into())\n-            };\n-        };\n+            })\n+    }\n+\n+    fn resolve_associated_item(\n+        &mut self,\n+        root_res: Res,\n+        item_name: Symbol,\n+        ns: Namespace,\n+        module_id: DefId,\n+        extra_fragment: &Option<String>,\n+        // lol this is so bad\n+    ) -> Option<Result<(Res, Option<String>), ErrorKind<'static>>> {\n+        let tcx = self.cx.tcx;\n \n-        let res = match ty_res {\n-            Res::Primitive(prim) => Some(\n-                self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n-            ),\n+        match root_res {\n+            Res::Primitive(prim) => {\n+                Some(self.resolve_primitive_associated_item(prim, ns, module_id, item_name))\n+            }\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -600,13 +612,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n                     Some(if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n+                            root_res,\n+                        )))\n                     } else {\n                         // HACK(jynelson): `clean` expects the type, not the associated item\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_str))))\n+                        Ok((root_res, Some(format!(\"{}.{}\", out, item_name))))\n                     })\n                 } else if ns == Namespace::ValueNS {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n@@ -637,7 +651,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                     ))\n                                 } else {\n                                     Ok((\n-                                        ty_res,\n+                                        root_res,\n                                         Some(format!(\n                                             \"{}.{}\",\n                                             if def.is_enum() { \"variant\" } else { \"structfield\" },\n@@ -670,26 +684,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     };\n \n                     if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n+                            root_res,\n+                        )))\n                     } else {\n                         let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_str))))\n+                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                     }\n                 }),\n             _ => None,\n-        };\n-        res.unwrap_or_else(|| {\n-            if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(ty_res),\n-                    unresolved: item_str.into(),\n-                }\n-                .into())\n-            }\n-        })\n+        }\n     }\n \n     /// Used for reporting better errors."}]}