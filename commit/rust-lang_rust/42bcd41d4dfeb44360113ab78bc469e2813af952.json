{"sha": "42bcd41d4dfeb44360113ab78bc469e2813af952", "node_id": "C_kwDOAAsO6NoAKDQyYmNkNDFkNGRmZWI0NDM2MDExM2FiNzhiYzQ2OWUyODEzYWY5NTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T21:37:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T21:37:38Z"}, "message": "Auto merge of #97598 - spastorino:simplify-universal-impl-trait-lowering, r=cjgillot\n\nSimplify universal impl trait lowering\n\nCloses #96644\n\nr? `@cjgillot`", "tree": {"sha": "59411ae7c6af85717e4ca0f474ef6e0c10380295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59411ae7c6af85717e4ca0f474ef6e0c10380295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42bcd41d4dfeb44360113ab78bc469e2813af952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42bcd41d4dfeb44360113ab78bc469e2813af952", "html_url": "https://github.com/rust-lang/rust/commit/42bcd41d4dfeb44360113ab78bc469e2813af952", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42bcd41d4dfeb44360113ab78bc469e2813af952/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e71440575c930dcecac288b7c3536410d688b351", "url": "https://api.github.com/repos/rust-lang/rust/commits/e71440575c930dcecac288b7c3536410d688b351", "html_url": "https://github.com/rust-lang/rust/commit/e71440575c930dcecac288b7c3536410d688b351"}, {"sha": "15a82d6917c66e695e8932771217f164c8fe008c", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a82d6917c66e695e8932771217f164c8fe008c", "html_url": "https://github.com/rust-lang/rust/commit/15a82d6917c66e695e8932771217f164c8fe008c"}], "stats": {"total": 461, "additions": 194, "deletions": 267}, "files": [{"sha": "85d3bf66d8e1c79354daa156a723087a6c07dfd3", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 137, "deletions": 135, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=42bcd41d4dfeb44360113ab78bc469e2813af952", "patch": "@@ -83,6 +83,8 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             task_context: None,\n             current_item: None,\n             captured_lifetimes: None,\n+            impl_trait_defs: Vec::new(),\n+            impl_trait_bounds: Vec::new(),\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n             allow_into_future: Some([sym::into_future][..].into()),\n@@ -264,16 +266,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let body_id =\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n-                    let (generics, decl) =\n-                        this.add_implicit_generics(generics, id, |this, idty, idpb| {\n-                            let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(\n-                                &decl,\n-                                Some((id, idty, idpb)),\n-                                FnDeclKind::Fn,\n-                                ret_id,\n-                            )\n-                        });\n+                    let itctx = ImplTraitContext::Universal(this.current_hir_id_owner);\n+                    let (generics, decl) = this.lower_generics(generics, id, itctx, |this| {\n+                        let ret_id = asyncness.opt_return_id();\n+                        this.lower_fn_decl(&decl, Some(id), FnDeclKind::Fn, ret_id)\n+                    });\n                     let sig = hir::FnSig {\n                         decl,\n                         header: this.lower_fn_header(header),\n@@ -311,57 +308,59 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n-                let ty = self.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, where_clauses, true);\n-                let generics = self.lower_generics(\n+                let (generics, ty) = self.lower_generics(\n                     &generics,\n+                    id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n             ItemKind::TyAlias(box TyAlias {\n                 ref generics, ref where_clauses, ty: None, ..\n             }) => {\n-                let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n-                let generics = self.lower_generics(\n+                let (generics, ty) = self.lower_generics(\n                     &generics,\n+                    id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n-                hir::EnumDef {\n-                    variants: self.arena.alloc_from_iter(\n-                        enum_definition.variants.iter().map(|x| self.lower_variant(x)),\n-                    ),\n-                },\n-                self.lower_generics(\n+            ItemKind::Enum(ref enum_definition, ref generics) => {\n+                let (generics, variants) = self.lower_generics(\n                     generics,\n+                    id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                ),\n-            ),\n+                    |this| {\n+                        this.arena.alloc_from_iter(\n+                            enum_definition.variants.iter().map(|x| this.lower_variant(x)),\n+                        )\n+                    },\n+                );\n+                hir::ItemKind::Enum(hir::EnumDef { variants }, generics)\n+            }\n             ItemKind::Struct(ref struct_def, ref generics) => {\n-                let struct_def = self.lower_variant_data(hir_id, struct_def);\n-                hir::ItemKind::Struct(\n-                    struct_def,\n-                    self.lower_generics(\n-                        generics,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                )\n+                let (generics, struct_def) = self.lower_generics(\n+                    generics,\n+                    id,\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.lower_variant_data(hir_id, struct_def),\n+                );\n+                hir::ItemKind::Struct(struct_def, generics)\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n-                let vdata = self.lower_variant_data(hir_id, vdata);\n-                hir::ItemKind::Union(\n-                    vdata,\n-                    self.lower_generics(\n-                        generics,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                )\n+                let (generics, vdata) = self.lower_generics(\n+                    generics,\n+                    id,\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.lower_variant_data(hir_id, vdata),\n+                );\n+                hir::ItemKind::Union(vdata, generics)\n             }\n             ItemKind::Impl(box Impl {\n                 unsafety,\n@@ -386,8 +385,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n+                let itctx = ImplTraitContext::Universal(self.current_hir_id_owner);\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.add_implicit_generics(ast_generics, id, |this, _, _| {\n+                    self.lower_generics(ast_generics, id, itctx, |this| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -432,34 +432,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounds,\n                 ref items,\n             }) => {\n-                let bounds = self.lower_param_bounds(\n-                    bounds,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                let (generics, (unsafety, items, bounds)) = self.lower_generics(\n+                    generics,\n+                    id,\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| {\n+                        let bounds = this.lower_param_bounds(\n+                            bounds,\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                        );\n+                        let items = this.arena.alloc_from_iter(\n+                            items.iter().map(|item| this.lower_trait_item_ref(item)),\n+                        );\n+                        let unsafety = this.lower_unsafety(unsafety);\n+                        (unsafety, items, bounds)\n+                    },\n                 );\n-                let items = self\n-                    .arena\n-                    .alloc_from_iter(items.iter().map(|item| self.lower_trait_item_ref(item)));\n-                hir::ItemKind::Trait(\n-                    is_auto,\n-                    self.lower_unsafety(unsafety),\n-                    self.lower_generics(\n-                        generics,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                    bounds,\n-                    items,\n-                )\n+                hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, items)\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n-                self.lower_generics(\n+            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                let (generics, bounds) = self.lower_generics(\n                     generics,\n+                    id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                ),\n-                self.lower_param_bounds(\n-                    bounds,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                ),\n-            ),\n+                    |this| {\n+                        this.lower_param_bounds(\n+                            bounds,\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                        )\n+                    },\n+                );\n+                hir::ItemKind::TraitAlias(generics, bounds)\n+            }\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n                 let body = P(self.lower_mac_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.resolver.local_def_id(id));\n@@ -651,8 +655,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n+                    let itctx = ImplTraitContext::Universal(self.current_hir_id_owner);\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.add_implicit_generics(generics, i.id, |this, _, _| {\n+                        self.lower_generics(generics, i.id, itctx, |this| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n@@ -789,24 +794,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref ty,\n                 ..\n             }) => {\n-                let ty = ty.as_ref().map(|x| {\n-                    self.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n-                });\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, where_clauses, false);\n-                let generics = self.lower_generics(\n+                self.lower_generics(\n                     &generics,\n+                    i.id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                );\n-                let kind = hir::TraitItemKind::Type(\n-                    self.lower_param_bounds(\n-                        bounds,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                    ty,\n-                );\n-\n-                (generics, kind)\n+                    |this| {\n+                        let ty = ty.as_ref().map(|x| {\n+                            this.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                        });\n+                        hir::TraitItemKind::Type(\n+                            this.lower_param_bounds(\n+                                bounds,\n+                                ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                            ),\n+                            ty,\n+                        )\n+                    },\n+                )\n             }\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n@@ -876,21 +882,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n-                let generics = self.lower_generics(\n+                self.lower_generics(\n                     &generics,\n+                    i.id,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                );\n-                let kind = match ty {\n-                    None => {\n-                        let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n-                        hir::ImplItemKind::TyAlias(ty)\n-                    }\n-                    Some(ty) => {\n-                        let ty = self.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n-                        hir::ImplItemKind::TyAlias(ty)\n-                    }\n-                };\n-                (generics, kind)\n+                    |this| match ty {\n+                        None => {\n+                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n+                            hir::ImplItemKind::TyAlias(ty)\n+                        }\n+                        Some(ty) => {\n+                            let ty = this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n+                            hir::ImplItemKind::TyAlias(ty)\n+                        }\n+                    },\n+                )\n             }\n             AssocItemKind::MacCall(..) => panic!(\"`TyMac` should have been expanded by now\"),\n         };\n@@ -1231,8 +1237,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         is_async: Option<NodeId>,\n     ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty, idpb| {\n-            this.lower_fn_decl(&sig.decl, Some((id, idty, idpb)), kind, is_async)\n+        let itctx = ImplTraitContext::Universal(self.current_hir_id_owner);\n+        let (generics, decl) = self.lower_generics(generics, id, itctx, |this| {\n+            this.lower_fn_decl(&sig.decl, Some(id), kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1289,11 +1296,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    pub(super) fn lower_generics_mut(\n+    /// Return the pair of the lowered `generics` as `hir::Generics` and the evaluation of `f` with\n+    /// the carried impl trait definitions and bounds.\n+    fn lower_generics<T>(\n         &mut self,\n         generics: &Generics,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> GenericsCtor<'hir> {\n+        parent_node_id: NodeId,\n+        itctx: ImplTraitContext,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> (&'hir hir::Generics<'hir>, T) {\n+        debug_assert!(self.impl_trait_defs.is_empty());\n+        debug_assert!(self.impl_trait_bounds.is_empty());\n+\n         // Error if `?Trait` bounds in where clauses don't refer directly to type parameters.\n         // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n         // these into hir when we lower thee where clauses), but this makes it quite difficult to\n@@ -1341,9 +1355,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n         }\n \n-        let mut predicates = SmallVec::new();\n+        let mut predicates: SmallVec<[hir::WherePredicate<'hir>; 4]> = SmallVec::new();\n         predicates.extend(generics.params.iter().filter_map(|param| {\n-            let bounds = self.lower_param_bounds(&param.bounds, itctx.reborrow());\n+            let bounds = self.lower_param_bounds(&param.bounds, itctx);\n             self.lower_generic_bound_predicate(\n                 param.ident,\n                 param.id,\n@@ -1360,22 +1374,31 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 .map(|predicate| self.lower_where_predicate(predicate)),\n         );\n \n-        GenericsCtor {\n-            params: self.lower_generic_params_mut(&generics.params).collect(),\n-            predicates,\n-            has_where_clause: !generics.where_clause.predicates.is_empty(),\n-            where_clause_span: self.lower_span(generics.where_clause.span),\n-            span: self.lower_span(generics.span),\n-        }\n-    }\n+        let mut params: Vec<_> = self.lower_generic_params_mut(&generics.params).collect();\n+        let has_where_clause = !generics.where_clause.predicates.is_empty();\n+        let where_clause_span = self.lower_span(generics.where_clause.span);\n+        let span = self.lower_span(generics.span);\n+        let res = f(self);\n \n-    pub(super) fn lower_generics(\n-        &mut self,\n-        generics: &Generics,\n-        itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> &'hir hir::Generics<'hir> {\n-        let generics_ctor = self.lower_generics_mut(generics, itctx);\n-        generics_ctor.into_generics(self.arena)\n+        let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n+        let impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n+        params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n+            self.lifetime_res_to_generic_param(ident, node_id, res)\n+        }));\n+        params.extend(impl_trait_defs.into_iter());\n+\n+        let impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);\n+        predicates.extend(impl_trait_bounds.into_iter());\n+\n+        let lowered_generics = self.arena.alloc(hir::Generics {\n+            params: self.arena.alloc_from_iter(params),\n+            predicates: self.arena.alloc_from_iter(predicates),\n+            has_where_clause,\n+            where_clause_span,\n+            span,\n+        });\n+\n+        (lowered_generics, res)\n     }\n \n     pub(super) fn lower_generic_bound_predicate(\n@@ -1491,24 +1514,3 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n }\n-\n-/// Helper struct for delayed construction of Generics.\n-pub(super) struct GenericsCtor<'hir> {\n-    pub(super) params: SmallVec<[hir::GenericParam<'hir>; 4]>,\n-    pub(super) predicates: SmallVec<[hir::WherePredicate<'hir>; 4]>,\n-    has_where_clause: bool,\n-    where_clause_span: Span,\n-    span: Span,\n-}\n-\n-impl<'hir> GenericsCtor<'hir> {\n-    pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> &'hir hir::Generics<'hir> {\n-        arena.alloc(hir::Generics {\n-            params: arena.alloc_from_iter(self.params),\n-            predicates: arena.alloc_from_iter(self.predicates),\n-            has_where_clause: self.has_where_clause,\n-            where_clause_span: self.where_clause_span,\n-            span: self.span,\n-        })\n-    }\n-}"}, {"sha": "2e93ce2f47e160cd268940f37baf9f5a5dca78cb", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 49, "deletions": 122, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=42bcd41d4dfeb44360113ab78bc469e2813af952", "patch": "@@ -121,6 +121,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n     local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n \n+    impl_trait_defs: Vec<hir::GenericParam<'hir>>,\n+    impl_trait_bounds: Vec<hir::WherePredicate<'hir>>,\n+\n     /// NodeIds that are lowered inside the current HIR owner.\n     node_id_to_local_id: FxHashMap<NodeId, hir::ItemLocalId>,\n \n@@ -243,14 +246,14 @@ pub trait ResolverAstLowering {\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n-#[derive(Debug)]\n-enum ImplTraitContext<'b, 'a> {\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum ImplTraitContext {\n     /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n     /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'b mut Vec<hir::GenericParam<'a>>, &'b mut Vec<hir::WherePredicate<'a>>, LocalDefId),\n+    Universal(LocalDefId),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -290,18 +293,6 @@ enum ImplTraitPosition {\n     ImplReturn,\n }\n \n-impl<'a> ImplTraitContext<'_, 'a> {\n-    fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n-        use self::ImplTraitContext::*;\n-        match self {\n-            Universal(params, bounds, parent) => Universal(params, bounds, *parent),\n-            ReturnPositionOpaqueTy { origin } => ReturnPositionOpaqueTy { origin: *origin },\n-            TypeAliasesOpaqueTy => TypeAliasesOpaqueTy,\n-            Disallowed(pos) => Disallowed(*pos),\n-        }\n-    }\n-}\n-\n impl std::fmt::Display for ImplTraitPosition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let name = match self {\n@@ -479,13 +470,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n+        let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n+        let current_impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);\n \n         // Always allocate the first `HirId` for the owner itself.\n         let _old = self.node_id_to_local_id.insert(owner, hir::ItemLocalId::new(0));\n         debug_assert_eq!(_old, None);\n \n         let item = f(self);\n         debug_assert_eq!(def_id, item.def_id());\n+        // `f` should have consumed all the elements in these vectors when constructing `item`.\n+        debug_assert!(self.impl_trait_defs.is_empty());\n+        debug_assert!(self.impl_trait_bounds.is_empty());\n         let info = self.make_owner_info(item);\n \n         self.attrs = current_attrs;\n@@ -495,6 +491,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.trait_map = current_trait_map;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n+        self.impl_trait_defs = current_impl_trait_defs;\n+        self.impl_trait_bounds = current_impl_trait_bounds;\n \n         let _old = self.children.insert(def_id, hir::MaybeOwner::Owner(info));\n         debug_assert!(_old.is_none())\n@@ -694,46 +692,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    /// Creates a new `hir::GenericParam` for every new `Fresh` lifetime and\n-    /// universal `impl Trait` type parameter encountered while evaluating `f`.\n-    /// Definitions are created with the provided `parent_def_id`.\n-    fn add_implicit_generics<T>(\n-        &mut self,\n-        generics: &Generics,\n-        parent_node_id: NodeId,\n-        f: impl FnOnce(\n-            &mut Self,\n-            &mut Vec<hir::GenericParam<'hir>>,\n-            &mut Vec<hir::WherePredicate<'hir>>,\n-        ) -> T,\n-    ) -> (&'hir hir::Generics<'hir>, T) {\n-        let mut impl_trait_defs = Vec::new();\n-        let mut impl_trait_bounds = Vec::new();\n-        let mut lowered_generics = self.lower_generics_mut(\n-            generics,\n-            ImplTraitContext::Universal(\n-                &mut impl_trait_defs,\n-                &mut impl_trait_bounds,\n-                self.current_hir_id_owner,\n-            ),\n-        );\n-        let res = f(self, &mut impl_trait_defs, &mut impl_trait_bounds);\n-\n-        let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n-        lowered_generics.params.extend(\n-            extra_lifetimes\n-                .into_iter()\n-                .filter_map(|(ident, node_id, res)| {\n-                    self.lifetime_res_to_generic_param(ident, node_id, res)\n-                })\n-                .chain(impl_trait_defs),\n-        );\n-        lowered_generics.predicates.extend(impl_trait_bounds);\n-\n-        let lowered_generics = lowered_generics.into_generics(self.arena);\n-        (lowered_generics, res)\n-    }\n-\n     /// Setup lifetime capture for and impl-trait.\n     /// The captures will be added to `captures`.\n     fn while_capturing_lifetimes<T>(\n@@ -898,20 +856,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_assoc_ty_constraint(\n         &mut self,\n         constraint: &AssocConstraint,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n         // lower generic arguments of identifier in constraint\n         let gen_args = if let Some(ref gen_args) = constraint.gen_args {\n             let gen_args_ctor = match gen_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(\n-                        data,\n-                        ParamMode::Explicit,\n-                        itctx.reborrow(),\n-                    )\n-                    .0\n+                    self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n                 GenericArgs::Parenthesized(ref data) => {\n                     let mut err = self.sess.struct_span_err(\n@@ -923,7 +876,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(\n                         &data.as_angle_bracketed_args(),\n                         ParamMode::Explicit,\n-                        itctx.reborrow(),\n+                        itctx,\n                     )\n                     .0\n                 }\n@@ -962,7 +915,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(_, _, parent) if self.is_in_dyn_type => {\n+                    ImplTraitContext::Universal(parent) if self.is_in_dyn_type => {\n                         parent_def_id = parent;\n                         (true, itctx)\n                     }\n@@ -1036,7 +989,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n@@ -1103,7 +1056,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_, 'hir>) -> &'hir hir::Ty<'hir> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> &'hir hir::Ty<'hir> {\n         self.arena.alloc(self.lower_ty_direct(t, itctx))\n     }\n \n@@ -1113,7 +1066,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::Ty<'hir> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n@@ -1128,7 +1081,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_, 'hir>) -> hir::Ty<'hir> {\n+    fn lower_ty_direct(&mut self, t: &Ty, itctx: ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1160,11 +1113,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }))\n             }),\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => {\n-                hir::TyKind::Tup(self.arena.alloc_from_iter(\n-                    tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())),\n-                ))\n-            }\n+            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n+                self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n+            ),\n             TyKind::Paren(ref ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n@@ -1198,7 +1149,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 GenericBound::Trait(\n                                     ref ty,\n                                     TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n-                                ) => Some(this.lower_poly_trait_ref(ty, itctx.reborrow())),\n+                                ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n                                 // `~const ?Bound` will cause an error during AST validation\n                                 // anyways, so treat it like `?Bound` as compilation proceeds.\n                                 GenericBound::Trait(\n@@ -1235,40 +1186,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(\n-                        in_band_ty_params,\n-                        in_band_ty_bounds,\n-                        parent_def_id,\n-                    ) => {\n+                    ImplTraitContext::Universal(parent_def_id) => {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n-                        let hir_bounds = self.lower_param_bounds(\n-                            bounds,\n-                            ImplTraitContext::Universal(\n-                                in_band_ty_params,\n-                                in_band_ty_bounds,\n-                                parent_def_id,\n-                            ),\n-                        );\n+                        let hir_bounds = self\n+                            .lower_param_bounds(bounds, ImplTraitContext::Universal(parent_def_id));\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n-                        in_band_ty_params.push(hir::GenericParam {\n+                        let param = hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(self.lower_ident(ident)),\n                             pure_wrt_drop: false,\n                             span: self.lower_span(span),\n                             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n                             colon_span: None,\n-                        });\n+                        };\n+                        self.impl_trait_defs.push(param);\n+\n                         if let Some(preds) = self.lower_generic_bound_predicate(\n                             ident,\n                             def_node_id,\n                             &GenericParamKind::Type { default: None },\n                             hir_bounds,\n                             hir::PredicateOrigin::ImplTrait,\n                         ) {\n-                            in_band_ty_bounds.push(preds)\n+                            self.impl_trait_bounds.push(preds)\n                         }\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n@@ -1439,26 +1382,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // `make_ret_async`: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n     //      return type. This is used for `async fn` declarations. The `NodeId` is the ID of the\n     //      return type `impl Trait` item.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(\n-            NodeId,\n-            &mut Vec<hir::GenericParam<'hir>>,\n-            &mut Vec<hir::WherePredicate<'hir>>,\n-        )>,\n+        fn_node_id: Option<NodeId>,\n         kind: FnDeclKind,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n-        debug!(\n-            \"lower_fn_decl(\\\n-            fn_decl: {:?}, \\\n-            in_band_ty_params: {:?}, \\\n-            kind: {:?}, \\\n-            make_ret_async: {:?})\",\n-            decl, in_band_ty_params, kind, make_ret_async,\n-        );\n-\n         let c_variadic = decl.c_variadic();\n \n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n@@ -1469,10 +1400,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             inputs = &inputs[..inputs.len() - 1];\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n-            if let Some((_, ibty, ibpb)) = &mut in_band_ty_params {\n+            if fn_node_id.is_some() {\n                 self.lower_ty_direct(\n                     &param.ty,\n-                    ImplTraitContext::Universal(ibty, ibpb, self.current_hir_id_owner),\n+                    ImplTraitContext::Universal(self.current_hir_id_owner),\n                 )\n             } else {\n                 self.lower_ty_direct(\n@@ -1494,15 +1425,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let output = if let Some(ret_id) = make_ret_async {\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n-                in_band_ty_params.expect(\"`make_ret_async` but no `fn_def_id`\").0,\n+                fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n                 ret_id,\n             )\n         } else {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n-                    let context = match in_band_ty_params {\n-                        Some((node_id, _, _)) if kind.impl_trait_return_allowed() => {\n-                            let fn_def_id = self.resolver.local_def_id(node_id);\n+                    let context = match fn_node_id {\n+                        Some(fn_node_id) if kind.impl_trait_return_allowed() => {\n+                            let fn_def_id = self.resolver.local_def_id(fn_node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             }\n@@ -1788,7 +1719,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::GenericBound<'hir> {\n         match tpb {\n             GenericBound::Trait(p, modifier) => hir::GenericBound::Trait(\n@@ -1966,11 +1897,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_trait_ref(\n-        &mut self,\n-        p: &TraitRef,\n-        itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::TraitRef<'hir> {\n+    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => panic!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n@@ -1982,35 +1909,35 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n         let bound_generic_params = self.lower_generic_params(&p.bound_generic_params);\n \n         let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx.reborrow())\n+            this.lower_trait_ref(&p.trait_ref, itctx)\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_, 'hir>) -> hir::MutTy<'hir> {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::GenericBounds<'hir> {\n         self.arena.alloc_from_iter(self.lower_param_bounds_mut(bounds, itctx))\n     }\n \n     fn lower_param_bounds_mut<'s>(\n         &'s mut self,\n         bounds: &'s [GenericBound],\n-        mut itctx: ImplTraitContext<'s, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> impl Iterator<Item = hir::GenericBound<'hir>> + Captures<'s> + Captures<'a> {\n-        bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx.reborrow()))\n+        bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx))\n     }\n \n     /// Lowers a block directly to an expression, presuming that it"}, {"sha": "d56974b773de6f4268ebbb622a445c32602552f6", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bcd41d4dfeb44360113ab78bc469e2813af952/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=42bcd41d4dfeb44360113ab78bc469e2813af952", "patch": "@@ -21,11 +21,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         p: &Path,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::QPath<'hir> {\n         debug!(\"lower_qpath(id: {:?}, qself: {:?}, p: {:?})\", id, qself, p);\n         let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx));\n \n         let partial_res =\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n@@ -70,7 +70,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         segment,\n                         param_mode,\n                         parenthesized_generic_args,\n-                        itctx.reborrow(),\n+                        itctx,\n                     )\n                 },\n             )),\n@@ -116,7 +116,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 segment,\n                 param_mode,\n                 ParenthesizedGenericArgs::Err,\n-                itctx.reborrow(),\n+                itctx,\n             ));\n             let qpath = hir::QPath::TypeRelative(ty, hir_segment);\n \n@@ -180,7 +180,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         segment: &PathSegment,\n         param_mode: ParamMode,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n@@ -318,7 +318,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n+        itctx: ImplTraitContext,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         let has_non_lt_args = data.args.iter().any(|arg| match arg {\n             AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_))\n@@ -329,14 +329,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .args\n             .iter()\n             .filter_map(|arg| match arg {\n-                AngleBracketedArg::Arg(arg) => Some(self.lower_generic_arg(arg, itctx.reborrow())),\n+                AngleBracketedArg::Arg(arg) => Some(self.lower_generic_arg(arg, itctx)),\n                 AngleBracketedArg::Constraint(_) => None,\n             })\n             .collect();\n         let bindings = self.arena.alloc_from_iter(data.args.iter().filter_map(|arg| match arg {\n-            AngleBracketedArg::Constraint(c) => {\n-                Some(self.lower_assoc_ty_constraint(c, itctx.reborrow()))\n-            }\n+            AngleBracketedArg::Constraint(c) => Some(self.lower_assoc_ty_constraint(c, itctx)),\n             AngleBracketedArg::Arg(_) => None,\n         }));\n         let ctor = GenericArgsCtor { args, bindings, parenthesized: false, span: data.span };"}]}