{"sha": "f0705bf033363757a8a2901cd1a7bd76f0fea820", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzA1YmYwMzMzNjM3NTdhOGEyOTAxY2QxYTdiZDc2ZjBmZWE4MjA=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-07T19:56:02Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-21T07:47:37Z"}, "message": "Replace StrExt with inherent str methods in libcore", "tree": {"sha": "acf32897096a473c675c4112efcbce258c3c91e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acf32897096a473c675c4112efcbce258c3c91e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0705bf033363757a8a2901cd1a7bd76f0fea820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0705bf033363757a8a2901cd1a7bd76f0fea820", "html_url": "https://github.com/rust-lang/rust/commit/f0705bf033363757a8a2901cd1a7bd76f0fea820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0705bf033363757a8a2901cd1a7bd76f0fea820/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "html_url": "https://github.com/rust-lang/rust/commit/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef"}], "stats": {"total": 3611, "additions": 1818, "deletions": 1793}, "files": [{"sha": "702d7b70cd36cadf33d100fce94000d9ec1d196b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -91,6 +91,7 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![cfg_attr(stage0, feature(core_slice_ext))]\n+#![cfg_attr(stage0, feature(core_str_ext))]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]"}, {"sha": "82ba2f4571193e09f9a871bc0fd569e72f7e3715", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 59, "deletions": 1776, "changes": 1835, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -40,6 +40,7 @@\n \n use core::fmt;\n use core::str as core_str;\n+#[cfg(stage0)] use core::str::StrExt;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n@@ -76,7 +77,8 @@ pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError\n pub use core::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n-\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub use core::str::EncodeUtf16;\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n@@ -90,1729 +92,78 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n-    }\n-\n-    fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n-        }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n-\n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n-            }\n-            result.push_str(s.borrow());\n-        }\n-        result\n-    }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n-}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// [`u16`]: ../../std/primitive.u16.html\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n-/// [`str`]: ../../std/primitive.str.html\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    chars: Chars<'a>,\n-    extra: u16,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a> fmt::Debug for EncodeUtf16<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(&mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for EncodeUtf16<'a> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Borrow<str> for String {\n-    #[inline]\n-    fn borrow(&self) -> &str {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ToOwned for str {\n-    type Owned = String;\n-    fn to_owned(&self) -> String {\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n-    }\n-\n-    fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n-        self.as_bytes().clone_into(&mut b);\n-        *target = unsafe { String::from_utf8_unchecked(b) }\n-    }\n-}\n-\n-/// Methods for string slices.\n-#[lang = \"str\"]\n-#[cfg(not(test))]\n-impl str {\n-    /// Returns the length of `self`.\n-    ///\n-    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n-    /// it may not be what a human considers the length of the string.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let len = \"foo\".len();\n-    /// assert_eq!(3, len);\n-    ///\n-    /// let len = \"\u0192oo\".len(); // fancy f!\n-    /// assert_eq!(4, len);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_str::StrExt::len(self)\n-    }\n-\n-    /// Returns `true` if `self` has a length of zero bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"\";\n-    /// assert!(s.is_empty());\n-    ///\n-    /// let s = \"not empty\";\n-    /// assert!(!s.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self)\n-    }\n-\n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n-    ///\n-    /// Returns `false` if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    #[inline]\n-    pub fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(self, index)\n-    }\n-\n-    /// Converts a string slice to a byte slice. To convert the byte slice back\n-    /// into a string slice, use the [`str::from_utf8`] function.\n-    ///\n-    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bytes = \"bors\".as_bytes();\n-    /// assert_eq!(b\"bors\", bytes);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline(always)]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self)\n-    }\n-\n-    /// Converts a mutable string slice to a mutable byte slice. To convert the\n-    /// mutable byte slice back into a mutable string slice, use the\n-    /// [`str::from_utf8_mut`] function.\n-    ///\n-    /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = String::from(\"Hello\");\n-    /// let bytes = unsafe { s.as_bytes_mut() };\n-    ///\n-    /// assert_eq!(b\"Hello\", bytes);\n-    /// ```\n-    ///\n-    /// Mutability:\n-    ///\n-    /// ```\n-    /// let mut s = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    ///\n-    /// unsafe {\n-    ///     let bytes = s.as_bytes_mut();\n-    ///\n-    ///     bytes[0] = 0xF0;\n-    ///     bytes[1] = 0x9F;\n-    ///     bytes[2] = 0x8D;\n-    ///     bytes[3] = 0x94;\n-    /// }\n-    ///\n-    /// assert_eq!(\"\ud83c\udf54\u2208\ud83c\udf0f\", s);\n-    /// ```\n-    #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        core_str::StrExt::as_bytes_mut(self)\n-    }\n-\n-    /// Converts a string slice to a raw pointer.\n-    ///\n-    /// As string slices are a slice of bytes, the raw pointer points to a\n-    /// [`u8`]. This pointer will be pointing to the first byte of the string\n-    /// slice.\n-    ///\n-    /// [`u8`]: primitive.u8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Hello\";\n-    /// let ptr = s.as_ptr();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self)\n-    }\n-\n-    /// Returns a subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    ///\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n-    ///\n-    /// // indices not on UTF-8 sequence boundaries\n-    /// assert!(v.get(1..).is_none());\n-    /// assert!(v.get(..8).is_none());\n-    ///\n-    /// // out of bounds\n-    /// assert!(v.get(..42).is_none());\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        core_str::StrExt::get(self, i)\n-    }\n-\n-    /// Returns a mutable subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = String::from(\"hello\");\n-    /// // correct length\n-    /// assert!(v.get_mut(0..5).is_some());\n-    /// // out of bounds\n-    /// assert!(v.get_mut(..42).is_none());\n-    /// assert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n-    ///\n-    /// assert_eq!(\"hello\", v);\n-    /// {\n-    ///     let s = v.get_mut(0..2);\n-    ///     let s = s.map(|s| {\n-    ///         s.make_ascii_uppercase();\n-    ///         &*s\n-    ///     });\n-    ///     assert_eq!(Some(\"HE\"), s);\n-    /// }\n-    /// assert_eq!(\"HEllo\", v);\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        core_str::StrExt::get_mut(self, i)\n-    }\n-\n-    /// Returns a unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        core_str::StrExt::get_unchecked(self, i)\n-    }\n-\n-    /// Returns a mutable, unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        core_str::StrExt::get_unchecked_mut(self, i)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`Index`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`Index`]: ops/trait.Index.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get a mutable string slice instead, see the\n-    /// [`slice_mut_unchecked`] method.\n-    ///\n-    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n-    /// }\n-    ///\n-    /// let s = \"Hello, world!\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(self, begin, end)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`IndexMut`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`IndexMut`]: ops/trait.IndexMut.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get an immutable string slice instead, see the\n-    /// [`slice_unchecked`] method.\n-    ///\n-    /// [`slice_unchecked`]: #method.slice_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n-    #[inline]\n-    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n-    }\n-\n-    /// Divide one string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get mutable string slices instead, see the [`split_at_mut`]\n-    /// method.\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Per Martin-L\u00f6f\";\n-    ///\n-    /// let (first, last) = s.split_at(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n-        core_str::StrExt::split_at(self, mid)\n-    }\n-\n-    /// Divide one mutable string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get immutable string slices instead, see the [`split_at`] method.\n-    ///\n-    /// [`split_at`]: #method.split_at\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n-    /// {\n-    ///     let (first, last) = s.split_at_mut(3);\n-    ///     first.make_ascii_uppercase();\n-    ///     assert_eq!(\"PER\", first);\n-    ///     assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// }\n-    /// assert_eq!(\"PER Martin-L\u00f6f\", s);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        core_str::StrExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over the [`char`]s of a string slice.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns such an iterator.\n-    ///\n-    /// It's important to remember that [`char`] represents a Unicode Scalar\n-    /// Value, and may not match your idea of what a 'character' is. Iteration\n-    /// over grapheme clusters may be what you actually want.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.chars().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut chars = word.chars();\n-    ///\n-    /// assert_eq!(Some('g'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('d'), chars.next());\n-    /// assert_eq!(Some('b'), chars.next());\n-    /// assert_eq!(Some('y'), chars.next());\n-    /// assert_eq!(Some('e'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut chars = y.chars();\n-    ///\n-    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n-    /// assert_eq!(Some('\\u{0306}'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self)\n-    }\n-    /// Returns an iterator over the [`char`]s of a string slice, and their\n-    /// positions.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns an iterator of both\n-    /// these [`char`]s, as well as their byte positions.\n-    ///\n-    /// The iterator yields tuples. The position is first, the [`char`] is\n-    /// second.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.char_indices().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut char_indices = word.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'g')), char_indices.next());\n-    /// assert_eq!(Some((1, 'o')), char_indices.next());\n-    /// assert_eq!(Some((2, 'o')), char_indices.next());\n-    /// assert_eq!(Some((3, 'd')), char_indices.next());\n-    /// assert_eq!(Some((4, 'b')), char_indices.next());\n-    /// assert_eq!(Some((5, 'y')), char_indices.next());\n-    /// assert_eq!(Some((6, 'e')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let yes = \"y\u0306es\";\n-    ///\n-    /// let mut char_indices = yes.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n-    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n-    ///\n-    /// // note the 3 here - the last character took up two bytes\n-    /// assert_eq!(Some((3, 'e')), char_indices.next());\n-    /// assert_eq!(Some((4, 's')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self)\n-    }\n-\n-    /// An iterator over the bytes of a string slice.\n-    ///\n-    /// As a string slice consists of a sequence of bytes, we can iterate\n-    /// through a string slice by byte. This method returns such an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut bytes = \"bors\".bytes();\n-    ///\n-    /// assert_eq!(Some(b'b'), bytes.next());\n-    /// assert_eq!(Some(b'o'), bytes.next());\n-    /// assert_eq!(Some(b'r'), bytes.next());\n-    /// assert_eq!(Some(b's'), bytes.next());\n-    ///\n-    /// assert_eq!(None, bytes.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self)\n-    }\n-\n-    /// Split a string slice by whitespace.\n-    ///\n-    /// The iterator returned will return string slices that are sub-slices of\n-    /// the original string slice, separated by any amount of whitespace.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut iter = \"A few words\".split_whitespace();\n-    ///\n-    /// assert_eq!(Some(\"A\"), iter.next());\n-    /// assert_eq!(Some(\"few\"), iter.next());\n-    /// assert_eq!(Some(\"words\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    ///\n-    /// All kinds of whitespace are considered:\n-    ///\n-    /// ```\n-    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n-    /// assert_eq!(Some(\"Mary\"), iter.next());\n-    /// assert_eq!(Some(\"had\"), iter.next());\n-    /// assert_eq!(Some(\"a\"), iter.next());\n-    /// assert_eq!(Some(\"little\"), iter.next());\n-    /// assert_eq!(Some(\"lamb\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    #[inline]\n-    pub fn split_whitespace(&self) -> SplitWhitespace {\n-        StrExt::split_whitespace(self)\n-    }\n-\n-    /// An iterator over the lines of a string, as string slices.\n-    ///\n-    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n-    /// a line feed (`\\r\\n`).\n-    ///\n-    /// The final line ending is optional.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    ///\n-    /// The final line ending isn't required:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self)\n-    }\n-\n-    /// An iterator over the lines of a string.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self)\n-    }\n-\n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"Za\u017c\u00f3\u0142\u0107 g\u0119\u015bl\u0105 ja\u017a\u0144\";\n-    ///\n-    /// let utf8_len = text.len();\n-    /// let utf16_len = text.encode_utf16().count();\n-    ///\n-    /// assert!(utf16_len <= utf8_len);\n-    /// ```\n-    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-    pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16 { chars: self[..].chars(), extra: 0 }\n-    }\n-\n-    /// Returns `true` if the given pattern matches a sub-slice of\n-    /// this string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.contains(\"nana\"));\n-    /// assert!(!bananas.contains(\"apples\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a prefix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.starts_with(\"bana\"));\n-    /// assert!(!bananas.starts_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::starts_with(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a suffix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.ends_with(\"anas\"));\n-    /// assert!(!bananas.ends_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::ends_with(self, pat)\n-    }\n-\n-    /// Returns the byte index of the first character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n-    /// ```\n-    ///\n-    /// More complex patterns using point-free style and closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n-    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n-    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.find(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(self, pat)\n-    }\n-\n-    /// Returns the byte index of the last character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n-    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.rfind(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(self, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit`] method can be used.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`rsplit`]: #method.rsplit\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    /// ```\n-    ///\n-    /// If a string contains multiple contiguous separators, you will end up\n-    /// with empty strings in the output:\n-    ///\n-    /// ```\n-    /// let x = \"||||a||b|c\".to_string();\n-    /// let d: Vec<_> = x.split('|').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators are separated by the empty string.\n-    ///\n-    /// ```\n-    /// let x = \"(///)\".to_string();\n-    /// let d: Vec<_> = x.split('/').collect();\n-    ///\n-    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n-    /// ```\n-    ///\n-    /// Separators at the start or end of a string are neighbored\n-    /// by empty strings.\n-    ///\n-    /// ```\n-    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n-    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n-    /// ```\n-    ///\n-    /// When the empty string is used as a separator, it separates\n-    /// every character in the string, along with the beginning\n-    /// and end of the string.\n-    ///\n-    /// ```\n-    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n-    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators can lead to possibly surprising behavior\n-    /// when whitespace is used as the separator. This code is correct:\n-    ///\n-    /// ```\n-    /// let x = \"    a  b c\".to_string();\n-    /// let d: Vec<_> = x.split(' ').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// It does _not_ give you:\n-    ///\n-    /// ```,ignore\n-    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Use [`split_whitespace`] for this behavior.\n-    ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`split`] method can be used.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring\n-    /// is skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit_terminator`] method can be used.\n-    ///\n-    /// [`rsplit_terminator`]: #method.rsplit_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring is\n-    /// skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search, and it will be double ended if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// For iterating from the front, the [`split_terminator`] method can be\n-    /// used.\n-    ///\n-    /// [`split_terminator`]: #method.split_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n-    /// assert_eq!(v, [\"B\", \"A\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is\n-    /// not efficient to support.\n-    ///\n-    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n-    /// used.\n-    ///\n-    /// [`rsplitn`]: #method.rsplitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, n, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by a\n-    /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is not\n-    /// efficient to support.\n-    ///\n-    /// For splitting from the front, the [`splitn`] method can be used.\n-    ///\n-    /// [`splitn`]: #method.splitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplitn(self, n, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within the given string\n-    /// slice.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatches`] method can be used.\n-    ///\n-    /// [`rmatches`]: #method.rmatches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        core_str::StrExt::matches(self, pat)\n-    }\n+        let len = self.iter().map(|s| s.borrow().len()).sum();\n+        let mut result = String::with_capacity(len);\n \n-    /// An iterator over the disjoint matches of a pattern within this string slice,\n-    /// yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`matches`] method can be used.\n-    ///\n-    /// [`matches`]: #method.matches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatches(self, pat)\n-    }\n+        for s in self {\n+            result.push_str(s.borrow())\n+        }\n \n-    /// An iterator over the disjoint matches of a pattern within this string\n-    /// slice as well as the index that the match starts at.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the first match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines\n-    /// if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatch_indices`] method can be used.\n-    ///\n-    /// [`rmatch_indices`]: #method.rmatch_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(self, pat)\n+        result\n     }\n \n-    /// An iterator over the disjoint matches of a pattern within `self`,\n-    /// yielded in reverse order along with the index of the match.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the last match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`match_indices`] method can be used.\n-    ///\n-    /// [`match_indices`]: #method.match_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatch_indices(self, pat)\n-    }\n+    fn join(&self, sep: &str) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n \n-    /// Returns a string slice with leading and trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\", s.trim());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim(&self) -> &str {\n-        StrExt::trim(self)\n-    }\n+        // concat is faster\n+        if sep.is_empty() {\n+            return self.concat();\n+        }\n \n-    /// Returns a string slice with leading whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"  English\";\n-    /// assert!(Some('E') == s.trim_left().chars().next());\n-    ///\n-    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n-    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left(&self) -> &str {\n-        StrExt::trim_left(self)\n-    }\n+        // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let mut result = String::with_capacity(len);\n+        let mut first = true;\n \n-    /// Returns a string slice with trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"English  \";\n-    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n-    ///\n-    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n-    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right(&self) -> &str {\n-        StrExt::trim_right(self)\n+        for s in self {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n+            }\n+            result.push_str(s.borrow());\n+        }\n+        result\n     }\n \n-    /// Returns a string slice with all prefixes and suffixes that match a\n-    /// pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a [`char`] or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        core_str::StrExt::trim_matches(self, pat)\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n     }\n+}\n \n-    /// Returns a string slice with all prefixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(self, pat)\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    #[inline]\n+    fn borrow(&self) -> &str {\n+        &self[..]\n     }\n+}\n \n-    /// Returns a string slice with all suffixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::trim_right_matches(self, pat)\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n+    fn to_owned(&self) -> String {\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n     }\n \n-    /// Parses this string slice into another type.\n-    ///\n-    /// Because `parse` is so general, it can cause problems with type\n-    /// inference. As such, `parse` is one of the few times you'll see\n-    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n-    /// helps the inference algorithm understand specifically which type\n-    /// you're trying to parse into.\n-    ///\n-    /// `parse` can parse any type that implements the [`FromStr`] trait.\n-    ///\n-    /// [`FromStr`]: str/trait.FromStr.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will return [`Err`] if it's not possible to parse this string slice into\n-    /// the desired type.\n-    ///\n-    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage\n-    ///\n-    /// ```\n-    /// let four: u32 = \"4\".parse().unwrap();\n-    ///\n-    /// assert_eq!(4, four);\n-    /// ```\n-    ///\n-    /// Using the 'turbofish' instead of annotating `four`:\n-    ///\n-    /// ```\n-    /// let four = \"4\".parse::<u32>();\n-    ///\n-    /// assert_eq!(Ok(4), four);\n-    /// ```\n-    ///\n-    /// Failing to parse:\n-    ///\n-    /// ```\n-    /// let nope = \"j\".parse::<u32>();\n-    ///\n-    /// assert!(nope.is_err());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(self)\n+    fn clone_into(&self, target: &mut String) {\n+        let mut b = mem::replace(target, String::new()).into_bytes();\n+        self.as_bytes().clone_into(&mut b);\n+        *target = unsafe { String::from_utf8_unchecked(b) }\n     }\n+}\n+\n+/// Methods for string slices.\n+#[cfg_attr(stage0, lang = \"str\")]\n+#[cfg_attr(not(stage0), lang = \"str_alloc\")]\n+#[cfg(not(test))]\n+impl str {\n+    #[cfg(stage0)]\n+    str_core_methods!();\n \n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n     ///\n@@ -2140,26 +491,6 @@ impl str {\n         unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n-    /// Checks if all characters in this string are within the ASCII range.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let ascii = \"hello!\\n\";\n-    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n-    ///\n-    /// assert!(ascii.is_ascii());\n-    /// assert!(!non_ascii.is_ascii());\n-    /// ```\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn is_ascii(&self) -> bool {\n-        // We can treat each byte as character here: all multibyte characters\n-        // start with a byte that is not in the ascii range, so we will stop\n-        // there already.\n-        self.bytes().all(|b| b.is_ascii())\n-    }\n-\n     /// Returns a copy of this string where each character is mapped to its\n     /// ASCII upper case equivalent.\n     ///\n@@ -2219,54 +550,6 @@ impl str {\n         // make_ascii_lowercase() preserves the UTF-8 invariant.\n         unsafe { String::from_utf8_unchecked(bytes) }\n     }\n-\n-    /// Checks that two strings are an ASCII case-insensitive match.\n-    ///\n-    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n-    /// but without allocating and copying temporaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n-    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n-    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n-    /// ```\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n-        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n-    }\n-\n-    /// Converts this string to its ASCII upper case equivalent in-place.\n-    ///\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    pub fn make_ascii_uppercase(&mut self) {\n-        let me = unsafe { self.as_bytes_mut() };\n-        me.make_ascii_uppercase()\n-    }\n-\n-    /// Converts this string to its ASCII lower case equivalent in-place.\n-    ///\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    pub fn make_ascii_lowercase(&mut self) {\n-        let me = unsafe { self.as_bytes_mut() };\n-        me.make_ascii_lowercase()\n-    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "5a107951b0b0e566835b7e2319ef0adaf5bbcc72", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -93,6 +93,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(simd_ffi)]\n #![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "8212648f2d8fb308f054ea49e2f94b9c70eb9250", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -62,4 +62,5 @@ pub use result::Result::{self, Ok, Err};\n pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n+#[cfg(stage0)]\n pub use str::StrExt;"}, {"sha": "d33eaace79d54078caa7ea3911a6098173a55a3c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1748, "deletions": 14, "changes": 1762, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -2218,10 +2218,6 @@ pub trait StrExt {\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n-    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n-    fn is_whitespace(&self) -> bool;\n-    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n-    fn is_alphanumeric(&self) -> bool;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2555,31 +2551,1700 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool {\n-        self.chars().all(|c| c.is_whitespace())\n+    fn trim(&self) -> &str {\n+        self.trim_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &str {\n+        self.trim_left_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &str {\n+        self.trim_right_matches(|c: char| c.is_whitespace())\n+    }\n+}\n+\n+// FIXME: remove (inline) this macro and the SliceExt trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n+macro_rules! str_core_methods { () => {\n+    /// Returns the length of `self`.\n+    ///\n+    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n+    /// it may not be what a human considers the length of the string.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let len = \"foo\".len();\n+    /// assert_eq!(3, len);\n+    ///\n+    /// let len = \"\u0192oo\".len(); // fancy f!\n+    /// assert_eq!(4, len);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        StrExt::len(self)\n+    }\n+\n+    /// Returns `true` if `self` has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"\";\n+    /// assert!(s.is_empty());\n+    ///\n+    /// let s = \"not empty\";\n+    /// assert!(!s.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        StrExt::is_empty(self)\n+    }\n+\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n+    /// boundaries.\n+    ///\n+    /// Returns `false` if `index` is greater than `self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n+    #[inline]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        StrExt::is_char_boundary(self, index)\n+    }\n+\n+    /// Converts a string slice to a byte slice. To convert the byte slice back\n+    /// into a string slice, use the [`str::from_utf8`] function.\n+    ///\n+    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bytes = \"bors\".as_bytes();\n+    /// assert_eq!(b\"bors\", bytes);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline(always)]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        StrExt::as_bytes(self)\n+    }\n+\n+    /// Converts a mutable string slice to a mutable byte slice. To convert the\n+    /// mutable byte slice back into a mutable string slice, use the\n+    /// [`str::from_utf8_mut`] function.\n+    ///\n+    /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"Hello\");\n+    /// let bytes = unsafe { s.as_bytes_mut() };\n+    ///\n+    /// assert_eq!(b\"Hello\", bytes);\n+    /// ```\n+    ///\n+    /// Mutability:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n+    /// unsafe {\n+    ///     let bytes = s.as_bytes_mut();\n+    ///\n+    ///     bytes[0] = 0xF0;\n+    ///     bytes[1] = 0x9F;\n+    ///     bytes[2] = 0x8D;\n+    ///     bytes[3] = 0x94;\n+    /// }\n+    ///\n+    /// assert_eq!(\"\ud83c\udf54\u2208\ud83c\udf0f\", s);\n+    /// ```\n+    #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        StrExt::as_bytes_mut(self)\n+    }\n+\n+    /// Converts a string slice to a raw pointer.\n+    ///\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// [`u8`]. This pointer will be pointing to the first byte of the string\n+    /// slice.\n+    ///\n+    /// [`u8`]: primitive.u8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let ptr = s.as_ptr();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const u8 {\n+        StrExt::as_ptr(self)\n+    }\n+\n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    ///\n+    /// // indices not on UTF-8 sequence boundaries\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    ///\n+    /// // out of bounds\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        StrExt::get(self, i)\n+    }\n+\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = String::from(\"hello\");\n+    /// // correct length\n+    /// assert!(v.get_mut(0..5).is_some());\n+    /// // out of bounds\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// assert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n+    ///\n+    /// assert_eq!(\"hello\", v);\n+    /// {\n+    ///     let s = v.get_mut(0..2);\n+    ///     let s = s.map(|s| {\n+    ///         s.make_ascii_uppercase();\n+    ///         &*s\n+    ///     });\n+    ///     assert_eq!(Some(\"HE\"), s);\n+    /// }\n+    /// assert_eq!(\"HEllo\", v);\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        StrExt::get_mut(self, i)\n+    }\n+\n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        StrExt::get_unchecked(self, i)\n+    }\n+\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        StrExt::get_unchecked_mut(self, i)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`Index`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`Index`]: ops/trait.Index.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get a mutable string slice instead, see the\n+    /// [`slice_mut_unchecked`] method.\n+    ///\n+    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n+    /// }\n+    ///\n+    /// let s = \"Hello, world!\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        StrExt::slice_unchecked(self, begin, end)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`IndexMut`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`IndexMut`]: ops/trait.IndexMut.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get an immutable string slice instead, see the\n+    /// [`slice_unchecked`] method.\n+    ///\n+    /// [`slice_unchecked`]: #method.slice_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n+    #[inline]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n+\n+    /// Divide one string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get mutable string slices instead, see the [`split_at_mut`]\n+    /// method.\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n+        StrExt::split_at(self, mid)\n+    }\n+\n+    /// Divide one mutable string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get immutable string slices instead, see the [`split_at`] method.\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n+    /// {\n+    ///     let (first, last) = s.split_at_mut(3);\n+    ///     first.make_ascii_uppercase();\n+    ///     assert_eq!(\"PER\", first);\n+    ///     assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// }\n+    /// assert_eq!(\"PER Martin-L\u00f6f\", s);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        StrExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Returns an iterator over the [`char`]s of a string slice.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns such an iterator.\n+    ///\n+    /// It's important to remember that [`char`] represents a Unicode Scalar\n+    /// Value, and may not match your idea of what a 'character' is. Iteration\n+    /// over grapheme clusters may be what you actually want.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.chars().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut chars = word.chars();\n+    ///\n+    /// assert_eq!(Some('g'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('d'), chars.next());\n+    /// assert_eq!(Some('b'), chars.next());\n+    /// assert_eq!(Some('y'), chars.next());\n+    /// assert_eq!(Some('e'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut chars = y.chars();\n+    ///\n+    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n+    /// assert_eq!(Some('\\u{0306}'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chars(&self) -> Chars {\n+        StrExt::chars(self)\n+    }\n+    /// Returns an iterator over the [`char`]s of a string slice, and their\n+    /// positions.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns an iterator of both\n+    /// these [`char`]s, as well as their byte positions.\n+    ///\n+    /// The iterator yields tuples. The position is first, the [`char`] is\n+    /// second.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.char_indices().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut char_indices = word.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'g')), char_indices.next());\n+    /// assert_eq!(Some((1, 'o')), char_indices.next());\n+    /// assert_eq!(Some((2, 'o')), char_indices.next());\n+    /// assert_eq!(Some((3, 'd')), char_indices.next());\n+    /// assert_eq!(Some((4, 'b')), char_indices.next());\n+    /// assert_eq!(Some((5, 'y')), char_indices.next());\n+    /// assert_eq!(Some((6, 'e')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let yes = \"y\u0306es\";\n+    ///\n+    /// let mut char_indices = yes.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n+    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n+    ///\n+    /// // note the 3 here - the last character took up two bytes\n+    /// assert_eq!(Some((3, 'e')), char_indices.next());\n+    /// assert_eq!(Some((4, 's')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn char_indices(&self) -> CharIndices {\n+        StrExt::char_indices(self)\n+    }\n+\n+    /// An iterator over the bytes of a string slice.\n+    ///\n+    /// As a string slice consists of a sequence of bytes, we can iterate\n+    /// through a string slice by byte. This method returns such an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut bytes = \"bors\".bytes();\n+    ///\n+    /// assert_eq!(Some(b'b'), bytes.next());\n+    /// assert_eq!(Some(b'o'), bytes.next());\n+    /// assert_eq!(Some(b'r'), bytes.next());\n+    /// assert_eq!(Some(b's'), bytes.next());\n+    ///\n+    /// assert_eq!(None, bytes.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn bytes(&self) -> Bytes {\n+        StrExt::bytes(self)\n+    }\n+\n+    /// Split a string slice by whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of whitespace.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut iter = \"A few words\".split_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    #[inline]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        StrExt::split_whitespace(self)\n+    }\n+\n+    /// An iterator over the lines of a string, as string slices.\n+    ///\n+    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n+    /// a line feed (`\\r\\n`).\n+    ///\n+    /// The final line ending is optional.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    ///\n+    /// The final line ending isn't required:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn lines(&self) -> Lines {\n+        StrExt::lines(self)\n+    }\n+\n+    /// An iterator over the lines of a string.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n+    #[inline]\n+    #[allow(deprecated)]\n+    pub fn lines_any(&self) -> LinesAny {\n+        StrExt::lines_any(self)\n+    }\n+\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"Za\u017c\u00f3\u0142\u0107 g\u0119\u015bl\u0105 ja\u017a\u0144\";\n+    ///\n+    /// let utf8_len = text.len();\n+    /// let utf16_len = text.encode_utf16().count();\n+    ///\n+    /// assert!(utf16_len <= utf8_len);\n+    /// ```\n+    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+    pub fn encode_utf16(&self) -> EncodeUtf16 {\n+        EncodeUtf16::new(self)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a sub-slice of\n+    /// this string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.contains(\"nana\"));\n+    /// assert!(!bananas.contains(\"apples\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        StrExt::contains(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a prefix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.starts_with(\"bana\"));\n+    /// assert!(!bananas.starts_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        StrExt::starts_with(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a suffix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.ends_with(\"anas\"));\n+    /// assert!(!bananas.ends_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::ends_with(self, pat)\n+    }\n+\n+    /// Returns the byte index of the first character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// ```\n+    ///\n+    /// More complex patterns using point-free style and closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n+    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        StrExt::find(self, pat)\n+    }\n+\n+    /// Returns the byte index of the last character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rfind(self, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit`] method can be used.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`rsplit`]: #method.rsplit\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// ```\n+    ///\n+    /// If a string contains multiple contiguous separators, you will end up\n+    /// with empty strings in the output:\n+    ///\n+    /// ```\n+    /// let x = \"||||a||b|c\".to_string();\n+    /// let d: Vec<_> = x.split('|').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators are separated by the empty string.\n+    ///\n+    /// ```\n+    /// let x = \"(///)\".to_string();\n+    /// let d: Vec<_> = x.split('/').collect();\n+    ///\n+    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n+    /// ```\n+    ///\n+    /// Separators at the start or end of a string are neighbored\n+    /// by empty strings.\n+    ///\n+    /// ```\n+    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n+    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n+    /// ```\n+    ///\n+    /// When the empty string is used as a separator, it separates\n+    /// every character in the string, along with the beginning\n+    /// and end of the string.\n+    ///\n+    /// ```\n+    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n+    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators can lead to possibly surprising behavior\n+    /// when whitespace is used as the separator. This code is correct:\n+    ///\n+    /// ```\n+    /// let x = \"    a  b c\".to_string();\n+    /// let d: Vec<_> = x.split(' ').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// It does _not_ give you:\n+    ///\n+    /// ```,ignore\n+    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Use [`split_whitespace`] for this behavior.\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        StrExt::split(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`split`] method can be used.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplit(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring\n+    /// is skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit_terminator`] method can be used.\n+    ///\n+    /// [`rsplit_terminator`]: #method.rsplit_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        StrExt::split_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring is\n+    /// skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// For iterating from the front, the [`split_terminator`] method can be\n+    /// used.\n+    ///\n+    /// [`split_terminator`]: #method.split_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplit_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by a\n+    /// pattern, restricted to returning at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n+    /// used.\n+    ///\n+    /// [`rsplitn`]: #method.rsplitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        StrExt::splitn(self, n, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by a\n+    /// pattern, starting from the end of the string, restricted to returning\n+    /// at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// For splitting from the front, the [`splitn`] method can be used.\n+    ///\n+    /// [`splitn`]: #method.splitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplitn(self, n, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within the given string\n+    /// slice.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatches`] method can be used.\n+    ///\n+    /// [`rmatches`]: #method.rmatches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        StrExt::matches(self, pat)\n     }\n \n+    /// An iterator over the disjoint matches of a pattern within this string slice,\n+    /// yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`matches`] method can be used.\n+    ///\n+    /// [`matches`]: #method.matches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     #[inline]\n-    fn is_alphanumeric(&self) -> bool {\n-        self.chars().all(|c| c.is_alphanumeric())\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rmatches(self, pat)\n     }\n \n+    /// An iterator over the disjoint matches of a pattern within this string\n+    /// slice as well as the index that the match starts at.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n+    /// if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatch_indices`] method can be used.\n+    ///\n+    /// [`rmatch_indices`]: #method.rmatch_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n     #[inline]\n-    fn trim(&self) -> &str {\n-        self.trim_matches(|c: char| c.is_whitespace())\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        StrExt::match_indices(self, pat)\n     }\n \n+    /// An iterator over the disjoint matches of a pattern within `self`,\n+    /// yielded in reverse order along with the index of the match.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`match_indices`] method can be used.\n+    ///\n+    /// [`match_indices`]: #method.match_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n     #[inline]\n-    fn trim_left(&self) -> &str {\n-        self.trim_left_matches(|c: char| c.is_whitespace())\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rmatch_indices(self, pat)\n+    }\n+\n+    /// Returns a string slice with leading and trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\", s.trim());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim(&self) -> &str {\n+        StrExt::trim(self)\n+    }\n+\n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English\";\n+    /// assert!(Some('E') == s.trim_left().chars().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n+    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left(&self) -> &str {\n+        StrExt::trim_left(self)\n+    }\n+\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"English  \";\n+    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n+    ///\n+    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right(&self) -> &str {\n+        StrExt::trim_right(self)\n+    }\n+\n+    /// Returns a string slice with all prefixes and suffixes that match a\n+    /// pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a [`char`] or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        StrExt::trim_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all prefixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        StrExt::trim_left_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::trim_right_matches(self, pat)\n+    }\n+\n+    /// Parses this string slice into another type.\n+    ///\n+    /// Because `parse` is so general, it can cause problems with type\n+    /// inference. As such, `parse` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which type\n+    /// you're trying to parse into.\n+    ///\n+    /// `parse` can parse any type that implements the [`FromStr`] trait.\n+    ///\n+    /// [`FromStr`]: str/trait.FromStr.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will return [`Err`] if it's not possible to parse this string slice into\n+    /// the desired type.\n+    ///\n+    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage\n+    ///\n+    /// ```\n+    /// let four: u32 = \"4\".parse().unwrap();\n+    ///\n+    /// assert_eq!(4, four);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `four`:\n+    ///\n+    /// ```\n+    /// let four = \"4\".parse::<u32>();\n+    ///\n+    /// assert_eq!(Ok(4), four);\n+    /// ```\n+    ///\n+    /// Failing to parse:\n+    ///\n+    /// ```\n+    /// let nope = \"j\".parse::<u32>();\n+    ///\n+    /// assert!(nope.is_err());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        StrExt::parse(self)\n     }\n \n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = \"hello!\\n\";\n+    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n-    fn trim_right(&self) -> &str {\n-        self.trim_right_matches(|c: char| c.is_whitespace())\n+    pub fn is_ascii(&self) -> bool {\n+        // We can treat each byte as character here: all multibyte characters\n+        // start with a byte that is not in the ascii range, so we will stop\n+        // there already.\n+        self.bytes().all(|b| b.is_ascii())\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n     }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_lowercase()\n+    }\n+}}\n+\n+#[lang = \"str\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl str {\n+    str_core_methods!();\n }\n \n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<[u8]> for str {\n     #[inline]\n@@ -2665,3 +4330,72 @@ impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for SplitWhitespace<'a> {}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n+/// [`str`]: ../../std/primitive.str.html\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    chars: Chars<'a>,\n+    extra: u16,\n+}\n+\n+// FIXME: remove (inline) this method\n+// when updating to a bootstrap compiler that has the new lang items.\n+// For grepping purpose: #[cfg(stage0)]\n+impl<'a> EncodeUtf16<'a> {\n+    #[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n+    #[doc(hidden)]\n+    pub fn new(s: &'a str) -> Self {\n+        EncodeUtf16 { chars: s.chars(), extra: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<'a> fmt::Debug for EncodeUtf16<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a> FusedIterator for EncodeUtf16<'a> {}"}, {"sha": "24c7f3b0aba5936c18ddfaeddba7c445a9f1b24f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -214,6 +214,7 @@ language_item_table! {\n     StrImplItem,                     \"str\",                     str_impl;\n     SliceImplItem,                   \"slice\",                   slice_impl;\n     SliceU8ImplItem,                 \"slice_u8\",                slice_u8_impl;\n+    StrAllocImplItem,                \"str_alloc\",               str_alloc_impl;\n     SliceAllocImplItem,              \"slice_alloc\",             slice_alloc_impl;\n     SliceU8AllocImplItem,            \"slice_u8_alloc\",          slice_u8_alloc_impl;\n     ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;"}, {"sha": "c538004c8387888b266421792d4b157f2f258d9f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -471,6 +471,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TyStr => {\n                 let lang_def_id = lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.str_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TySlice(_) => {\n                 let lang_def_id = lang_items.slice_impl();"}, {"sha": "97e57ba668f5f2c4a9fc0638b40cd67f65e23e99", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::TyStr => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.str_impl(),\n-                                          None,\n+                                          lang_items.str_alloc_impl(),\n                                           \"str\",\n                                           \"str\",\n                                           item.span);"}, {"sha": "65f6b227a563bdc16863db62735a706208496a0b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -290,6 +290,7 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         lang_items.str_impl(),\n         lang_items.slice_impl(),\n         lang_items.slice_u8_impl(),\n+        lang_items.str_alloc_impl(),\n         lang_items.slice_alloc_impl(),\n         lang_items.slice_u8_alloc_impl(),\n         lang_items.const_ptr_impl(),"}, {"sha": "0a0f9ce4bd10eb878a4b4a82dafdd4eea0085735", "filename": "src/test/compile-fail/single-primitive-inherent-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -15,7 +15,7 @@\n #![no_std]\n \n // OK\n-#[lang = \"str\"]\n+#[lang = \"str_alloc\"]\n impl str {}\n \n impl str {"}, {"sha": "ee0a5c1aa1b5eb88e1ee810e56ffbf9f1f9d24cb", "filename": "src/test/rustdoc/issue-23511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0705bf033363757a8a2901cd1a7bd76f0fea820/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-23511.rs?ref=f0705bf033363757a8a2901cd1a7bd76f0fea820", "patch": "@@ -14,7 +14,7 @@\n pub mod str {\n     #![doc(primitive = \"str\")]\n \n-    #[lang = \"str\"]\n+    #[lang = \"str_alloc\"]\n     impl str {\n         // @has search-index.js foo\n         pub fn foo(&self) {}"}]}