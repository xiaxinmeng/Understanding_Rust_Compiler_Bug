{"sha": "4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNGVhYmZkNmM3ZTM5ZTJiMDE4NTFhZjJlNThkMzhkODk4YWFjMzk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-28T01:37:08Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-28T01:37:08Z"}, "message": "save-analysis: fix spans for paths to struct variants", "tree": {"sha": "0bcde9fa93319b6879f7f03a272a80d2c6a4a5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bcde9fa93319b6879f7f03a272a80d2c6a4a5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "html_url": "https://github.com/rust-lang/rust/commit/4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c4eabfd6c7e39e2b01851af2e58d38d898aac39/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a77fbd4837d07fe752c648562e68d6e19111f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a77fbd4837d07fe752c648562e68d6e19111f0", "html_url": "https://github.com/rust-lang/rust/commit/25a77fbd4837d07fe752c648562e68d6e19111f0"}], "stats": {"total": 101, "additions": 54, "deletions": 47}, "files": [{"sha": "1992708eeb9e13956860b4ce8eea883f74a681df", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4c4eabfd6c7e39e2b01851af2e58d38d898aac39/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4eabfd6c7e39e2b01851af2e58d38d898aac39/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "patch": "@@ -763,37 +763,38 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_path(&mut self,\n-                    ex: &ast::Expr,\n-                    path: &ast::Path) {\n+                    id: NodeId,\n+                    span: Span,\n+                    path: &ast::Path,\n+                    ref_kind: Option<recorder::Row>) {\n         if generated_code(path.span) {\n             return\n         }\n \n         let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&ex.id) {\n-            self.sess.span_bug(ex.span,\n-                               format!(\"def_map has no key for {} in visit_expr\",\n-                                       ex.id)[]);\n+        if !def_map.contains_key(&id) {\n+            self.sess.span_bug(span,\n+                               format!(\"def_map has no key for {} in visit_expr\", id)[]);\n         }\n-        let def = &(*def_map)[ex.id];\n-        let sub_span = self.span.span_for_last_ident(ex.span);\n+        let def = &(*def_map)[id];\n+        let sub_span = self.span.span_for_last_ident(span);\n         match *def {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n-                                                    ex.span,\n+            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    span,\n                                                     sub_span,\n                                                     def.def_id(),\n                                                     self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n-                                                       ex.span,\n+                                                       span,\n                                                        sub_span,\n                                                        def_id,\n-                                                        self.cur_scope),\n+                                                       self.cur_scope),\n             def::DefStaticMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+                let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n                                                     declid);\n@@ -828,34 +829,31 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                self.fmt.meth_call_str(ex.span,\n+                self.fmt.meth_call_str(span,\n                                        sub_span,\n                                        defid,\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n-                                                             sub_span,\n-                                                             def_id,\n-                                                             self.cur_scope),\n-            _ => self.sess.span_bug(ex.span,\n+            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n+                                                          sub_span,\n+                                                          def_id,\n+                                                          self.cur_scope),\n+            _ => self.sess.span_bug(span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(ex.span))[]),\n+                                            self.span.snippet(span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n-            def::DefStaticMethod(..) => {\n-                self.write_sub_path_trait_truncated(path);\n-            },\n+            def::DefStaticMethod(..) => self.write_sub_path_trait_truncated(path),\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n             def::DefStruct(_) |\n+            def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path),\n             _ => {},\n         }\n-\n-        visit::walk_path(self, path);\n     }\n \n     fn process_struct_lit(&mut self,\n@@ -1309,7 +1307,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             },\n-            ast::ExprPath(ref path) => self.process_path(ex, path),\n+            ast::ExprPath(ref path) => {\n+                self.process_path(ex.id, ex.span, path, None);\n+                visit::walk_path(self, path);\n+            }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1406,44 +1407,50 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-\n         for pattern in arm.pats.iter() {\n             // collect paths from the arm's patterns\n             self.visit_pat(&**pattern);\n         }\n-        self.collecting = false;\n+\n+        // This is to get around borrow checking, because we need mut self to call process_path.\n+        let mut paths_to_process = vec![];\n         // process collected paths\n         for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n-            let value = if *immut {\n-                self.span.snippet(p.span).to_string()\n-            } else {\n-                \"<mutable>\".to_string()\n-            };\n-            let sub_span = self.span.span_for_first_ident(p.span);\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    format!(\"def_map has no key for {} in visit_arm\", id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n-                def::DefLocal(id)  => self.fmt.variable_str(p.span,\n-                                                            sub_span,\n-                                                            id,\n-                                                            path_to_string(p)[],\n-                                                            value[],\n-                                                            \"\"),\n-                def::DefVariant(_, id ,_) => self.fmt.ref_str(ref_kind,\n-                                                              p.span,\n-                                                              sub_span,\n-                                                              id,\n-                                                              self.cur_scope),\n-                // FIXME(nrc) what is this doing here?\n+                def::DefLocal(id)  => {\n+                    let value = if *immut {\n+                        self.span.snippet(p.span).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+\n+                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span,\n+                                          Some(p.span),\n+                                          id,\n+                                          path_to_string(p)[],\n+                                          value[],\n+                                          \"\")\n+                }\n+                def::DefVariant(..) => {\n+                    paths_to_process.push((id, p.span, p.clone(), Some(ref_kind)))\n+                }\n+                // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {}\", *def)\n             }\n         }\n+        for &(id, span, ref path, ref_kind) in paths_to_process.iter() {\n+            self.process_path(id, span, path, ref_kind);\n+        }\n+        self.collecting = false;\n         self.collected_paths.clear();\n         visit::walk_expr_opt(self, &arm.guard);\n         self.visit_expr(&*arm.body);"}, {"sha": "f62073e54e6d963e4345d811c0d4c1dc060e4191", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c4eabfd6c7e39e2b01851af2e58d38d898aac39/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4eabfd6c7e39e2b01851af2e58d38d898aac39/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "patch": "@@ -61,7 +61,7 @@ macro_rules! svec {\n     })\n }\n \n-#[deriving(Copy)]\n+#[deriving(Copy,Show)]\n pub enum Row {\n     Variable,\n     Enum,"}]}