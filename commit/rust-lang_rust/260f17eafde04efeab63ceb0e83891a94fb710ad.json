{"sha": "260f17eafde04efeab63ceb0e83891a94fb710ad", "node_id": "C_kwDOAAsO6NoAKDI2MGYxN2VhZmRlMDRlZmVhYjYzY2ViMGU4Mzg5MWE5NGZiNzEwYWQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-18T10:45:00Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-30T09:23:58Z"}, "message": "fix rustdoc", "tree": {"sha": "32643a2fd598380760d9098bbc42cd1a7445090d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32643a2fd598380760d9098bbc42cd1a7445090d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260f17eafde04efeab63ceb0e83891a94fb710ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260f17eafde04efeab63ceb0e83891a94fb710ad", "html_url": "https://github.com/rust-lang/rust/commit/260f17eafde04efeab63ceb0e83891a94fb710ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260f17eafde04efeab63ceb0e83891a94fb710ad/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a3ebde96b49832fe9b0f683d13348abc1cc503", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a3ebde96b49832fe9b0f683d13348abc1cc503", "html_url": "https://github.com/rust-lang/rust/commit/36a3ebde96b49832fe9b0f683d13348abc1cc503"}], "stats": {"total": 117, "additions": 60, "deletions": 57}, "files": [{"sha": "3e60ed2f7c4e5099409fb52c251c4ad51a950ee4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=260f17eafde04efeab63ceb0e83891a94fb710ad", "patch": "@@ -1,6 +1,7 @@\n use std::cell::RefCell;\n use std::default::Default;\n use std::hash::Hash;\n+use std::iter;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -22,6 +23,7 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE}\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n@@ -1625,6 +1627,7 @@ crate enum PrimitiveType {\n     Never,\n }\n \n+type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 2>>;\n impl PrimitiveType {\n     crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         use ast::{FloatTy, IntTy, UintTy};\n@@ -1680,68 +1683,68 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static ArrayVec<DefId, 4> {\n-        Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n-    }\n-\n-    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, ArrayVec<DefId, 4>> {\n-        static CELL: OnceCell<FxHashMap<PrimitiveType, ArrayVec<DefId, 4>>> = OnceCell::new();\n+    crate fn simplified_types() -> &'static SimplifiedTypes {\n+        use ty::fast_reject::SimplifiedTypeGen::*;\n+        use ty::{FloatTy, IntTy, UintTy};\n+        use PrimitiveType::*;\n+        static CELL: OnceCell<SimplifiedTypes> = OnceCell::new();\n \n+        let single = |x| iter::once(x).collect();\n         CELL.get_or_init(move || {\n-            use self::PrimitiveType::*;\n-\n-            let single = |a: Option<DefId>| a.into_iter().collect();\n-            let both = |a: Option<DefId>, b: Option<DefId>| -> ArrayVec<_, 4> {\n-                a.into_iter().chain(b).collect()\n-            };\n-\n-            let lang_items = tcx.lang_items();\n             map! {\n-                Isize => single(lang_items.isize_impl()),\n-                I8 => single(lang_items.i8_impl()),\n-                I16 => single(lang_items.i16_impl()),\n-                I32 => single(lang_items.i32_impl()),\n-                I64 => single(lang_items.i64_impl()),\n-                I128 => single(lang_items.i128_impl()),\n-                Usize => single(lang_items.usize_impl()),\n-                U8 => single(lang_items.u8_impl()),\n-                U16 => single(lang_items.u16_impl()),\n-                U32 => single(lang_items.u32_impl()),\n-                U64 => single(lang_items.u64_impl()),\n-                U128 => single(lang_items.u128_impl()),\n-                F32 => both(lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n-                F64 => both(lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n-                Char => single(lang_items.char_impl()),\n-                Bool => single(lang_items.bool_impl()),\n-                Str => both(lang_items.str_impl(), lang_items.str_alloc_impl()),\n-                Slice => {\n-                    lang_items\n-                        .slice_impl()\n-                        .into_iter()\n-                        .chain(lang_items.slice_u8_impl())\n-                        .chain(lang_items.slice_alloc_impl())\n-                        .chain(lang_items.slice_u8_alloc_impl())\n-                        .collect()\n-                },\n-                Array => single(lang_items.array_impl()),\n-                Tuple => ArrayVec::new(),\n-                Unit => ArrayVec::new(),\n-                RawPointer => {\n-                    lang_items\n-                        .const_ptr_impl()\n-                        .into_iter()\n-                        .chain(lang_items.mut_ptr_impl())\n-                        .chain(lang_items.const_slice_ptr_impl())\n-                        .chain(lang_items.mut_slice_ptr_impl())\n-                        .collect()\n-                },\n-                Reference => ArrayVec::new(),\n+                Isize => single(IntSimplifiedType(IntTy::Isize)),\n+                I8 => single(IntSimplifiedType(IntTy::I8)),\n+                I16 => single(IntSimplifiedType(IntTy::I16)),\n+                I32 => single(IntSimplifiedType(IntTy::I32)),\n+                I64 => single(IntSimplifiedType(IntTy::I64)),\n+                I128 => single(IntSimplifiedType(IntTy::I128)),\n+                Usize => single(UintSimplifiedType(UintTy::Usize)),\n+                U8 => single(UintSimplifiedType(UintTy::U8)),\n+                U16 => single(UintSimplifiedType(UintTy::U16)),\n+                U32 => single(UintSimplifiedType(UintTy::U32)),\n+                U64 => single(UintSimplifiedType(UintTy::U64)),\n+                U128 => single(UintSimplifiedType(UintTy::U128)),\n+                F32 => single(FloatSimplifiedType(FloatTy::F32)),\n+                F64 => single(FloatSimplifiedType(FloatTy::F64)),\n+                Str => single(StrSimplifiedType),\n+                Bool => single(BoolSimplifiedType),\n+                Char => single(CharSimplifiedType),\n+                Array => single(ArraySimplifiedType),\n+                Slice => single(SliceSimplifiedType),\n+                // FIXME: If we ever add an inherent impl for tuples\n+                // with different lengths, they won't show in rustdoc.\n+                //\n+                // Either manually update this arrayvec at this point\n+                // or start with a more complex refactoring.\n+                Tuple => [TupleSimplifiedType(2), TupleSimplifiedType(3)].into(),\n+                Unit => single(TupleSimplifiedType(0)),\n+                RawPointer => [PtrSimplifiedType(Mutability::Not), PtrSimplifiedType(Mutability::Mut)].into(),\n+                Reference => [RefSimplifiedType(Mutability::Not), RefSimplifiedType(Mutability::Mut)].into(),\n+                // FIXME: This will be wrong if we ever add inherent impls\n+                // for function pointers.\n                 Fn => ArrayVec::new(),\n-                Never => ArrayVec::new(),\n+                Never => single(NeverSimplifiedType),\n             }\n         })\n     }\n \n+    crate fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n+        Self::simplified_types()\n+            .get(self)\n+            .into_iter()\n+            .flatten()\n+            .flat_map(move |&simp| tcx.incoherent_impls(simp))\n+            .copied()\n+    }\n+\n+    crate fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n+        Self::simplified_types()\n+            .values()\n+            .flatten()\n+            .flat_map(move |&simp| tcx.incoherent_impls(simp))\n+            .copied()\n+    }\n+\n     crate fn as_sym(&self) -> Symbol {\n         use PrimitiveType::*;\n         match self {"}, {"sha": "00f512ded0e79b535da3a6df0b3372237eac3339", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=260f17eafde04efeab63ceb0e83891a94fb710ad", "patch": "@@ -184,7 +184,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n \n         if let Some(prim) = target.primitive_type() {\n             let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n-            for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n+            for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }\n         } else if let Type::Path { path } = target {"}, {"sha": "8d66021fcaa90b7169aafd4ecdafbc5ca2d6bb2a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=260f17eafde04efeab63ceb0e83891a94fb710ad", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n+        prim_ty.impls(tcx).find_map(|impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {"}, {"sha": "2852c3b616df1a4afd84d3606d939d23f2cb0911", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260f17eafde04efeab63ceb0e83891a94fb710ad/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=260f17eafde04efeab63ceb0e83891a94fb710ad", "patch": "@@ -45,7 +45,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n \n     // Also try to inline primitive impls from other crates.\n     cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n-        for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n+        for def_id in PrimitiveType::all_impls(cx.tcx) {\n             if !def_id.is_local() {\n                 inline::build_impl(cx, None, def_id, None, &mut new_items);\n "}]}