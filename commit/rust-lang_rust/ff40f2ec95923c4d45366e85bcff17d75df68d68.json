{"sha": "ff40f2ec95923c4d45366e85bcff17d75df68d68", "node_id": "C_kwDOAAsO6NoAKGZmNDBmMmVjOTU5MjNjNGQ0NTM2NmU4NWJjZmYxN2Q3NWRmNjhkNjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T21:37:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T21:37:10Z"}, "message": "Auto merge of #101710 - jyn514:move-dep-kind-node, r=cjgillot\n\nMove DepKindStruct from rustc_middle to rustc_query_system\n\nHelps with https://github.com/rust-lang/rust/issues/96524. cc https://rust-lang.zulipchat.com/#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/Moving.20.60DepKindStruct.60.20to.20rustc_query_system.20.2396524\n\nr? `@cjgillot`", "tree": {"sha": "32ea6f6e49361168058806d001ae913add2a24a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ea6f6e49361168058806d001ae913add2a24a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff40f2ec95923c4d45366e85bcff17d75df68d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff40f2ec95923c4d45366e85bcff17d75df68d68", "html_url": "https://github.com/rust-lang/rust/commit/ff40f2ec95923c4d45366e85bcff17d75df68d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff40f2ec95923c4d45366e85bcff17d75df68d68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "html_url": "https://github.com/rust-lang/rust/commit/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032"}, {"sha": "00cde6d4b94bba23ad06b352bc589805574f62b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/00cde6d4b94bba23ad06b352bc589805574f62b2", "html_url": "https://github.com/rust-lang/rust/commit/00cde6d4b94bba23ad06b352bc589805574f62b2"}], "stats": {"total": 282, "additions": 135, "deletions": 147}, "files": [{"sha": "40b9d73db94cfa841f64aac0ae05b1bbbe7d641a", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 89, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -69,79 +69,6 @@ use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n \n-/// This struct stores metadata about each DepKind.\n-///\n-/// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n-/// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n-/// jump table instead of large matches.\n-pub struct DepKindStruct<'tcx> {\n-    /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n-    /// When their result is needed, it is recomputed. They are useful for fine-grained\n-    /// dependency tracking, and caching within one compiler invocation.\n-    pub is_anon: bool,\n-\n-    /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n-    /// their inputs have not changed since the last compiler invocation. The result is still\n-    /// cached within one compiler invocation.\n-    pub is_eval_always: bool,\n-\n-    /// Whether the query key can be recovered from the hashed fingerprint.\n-    /// See [DepNodeParams] trait for the behaviour of each key type.\n-    pub fingerprint_style: FingerprintStyle,\n-\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    pub force_from_dep_node: Option<fn(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool>,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: Option<fn(TyCtxt<'tcx>, DepNode)>,\n-}\n-\n-impl DepKind {\n-    #[inline(always)]\n-    pub fn fingerprint_style(self, tcx: TyCtxt<'_>) -> FingerprintStyle {\n-        // Only fetch the DepKindStruct once.\n-        let data = tcx.query_kind(self);\n-        if data.is_anon {\n-            return FingerprintStyle::Opaque;\n-        }\n-        data.fingerprint_style\n-    }\n-}\n-\n macro_rules! define_dep_nodes {\n     (\n      $($(#[$attr:meta])*\n@@ -159,7 +86,7 @@ macro_rules! define_dep_nodes {\n             $( $( #[$attr] )* $variant),*\n         }\n \n-        fn dep_kind_from_label_string(label: &str) -> Result<DepKind, ()> {\n+        pub(super) fn dep_kind_from_label_string(label: &str) -> Result<DepKind, ()> {\n             match label {\n                 $(stringify!($variant) => Ok(DepKind::$variant),)*\n                 _ => Err(()),\n@@ -214,11 +141,6 @@ static_assert_size!(DepNode, 18);\n static_assert_size!(DepNode, 24);\n \n pub trait DepNodeExt: Sized {\n-    /// Construct a DepNode from the given DepKind and DefPathHash. This\n-    /// method will assert that the given DepKind actually requires a\n-    /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> Self;\n-\n     /// Extracts the DefId corresponding to this DepNode. This will work\n     /// if two conditions are met:\n     ///\n@@ -243,14 +165,6 @@ pub trait DepNodeExt: Sized {\n }\n \n impl DepNodeExt for DepNode {\n-    /// Construct a DepNode from the given DepKind and DefPathHash. This\n-    /// method will assert that the given DepKind actually requires a\n-    /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-        debug_assert!(kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash);\n-        DepNode { kind, hash: def_path_hash.0.into() }\n-    }\n-\n     /// Extracts the DefId corresponding to this DepNode. This will work\n     /// if two conditions are met:\n     ///\n@@ -262,7 +176,7 @@ impl DepNodeExt for DepNode {\n     /// refers to something from the previous compilation session that\n     /// has been removed.\n     fn extract_def_id<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-        if self.kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash {\n+        if tcx.fingerprint_style(self.kind) == FingerprintStyle::DefPathHash {\n             Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into()), &mut || {\n                 panic!(\"Failed to extract DefId: {:?} {}\", self.kind, self.hash)\n             }))\n@@ -279,7 +193,7 @@ impl DepNodeExt for DepNode {\n     ) -> Result<DepNode, ()> {\n         let kind = dep_kind_from_label_string(label)?;\n \n-        match kind.fingerprint_style(tcx) {\n+        match tcx.fingerprint_style(kind) {\n             FingerprintStyle::Opaque => Err(()),\n             FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n             FingerprintStyle::DefPathHash => {"}, {"sha": "2e62bebc8525b7596cc5428c38bc8ee225001002", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -11,15 +11,17 @@ pub use rustc_query_system::dep_graph::{\n     SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n+pub use dep_node::{label_strs, DepKind, DepNode, DepNodeExt};\n pub(crate) use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n+\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n pub type TaskDepsRef<'a> = rustc_query_system::dep_graph::TaskDepsRef<'a, DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n+pub type DepKindStruct<'tcx> = rustc_query_system::dep_graph::DepKindStruct<TyCtxt<'tcx>>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n@@ -91,50 +93,8 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         self.sess\n     }\n \n-    #[inline(always)]\n-    fn fingerprint_style(&self, kind: DepKind) -> rustc_query_system::dep_graph::FingerprintStyle {\n-        kind.fingerprint_style(*self)\n-    }\n-\n-    #[inline(always)]\n-    fn is_eval_always(&self, kind: DepKind) -> bool {\n-        self.query_kind(kind).is_eval_always\n-    }\n-\n-    fn try_force_from_dep_node(&self, dep_node: DepNode) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        let cb = self.query_kind(dep_node.kind);\n-        if let Some(f) = cb.force_from_dep_node {\n-            f(*self, dep_node);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn try_load_from_on_disk_cache(&self, dep_node: DepNode) {\n-        let cb = self.query_kind(dep_node.kind);\n-        if let Some(f) = cb.try_load_from_on_disk_cache {\n-            f(*self, dep_node)\n-        }\n+    #[inline]\n+    fn dep_kind_info(&self, dep_kind: DepKind) -> &DepKindStruct<'tcx> {\n+        &self.query_kinds[dep_kind as usize]\n     }\n }"}, {"sha": "e430c327efe7c08cb90456258ac877c5a6eb0b4d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n+use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintLevelSource};\n@@ -1085,7 +1085,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n-    query_kinds: &'tcx [DepKindStruct<'tcx>],\n+    pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -1292,10 +1292,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub(crate) fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct<'tcx> {\n-        &self.query_kinds[k as usize]\n-    }\n-\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n     pub fn ty_error(self) -> Ty<'tcx> {"}, {"sha": "ac95c8edf3f12a2af8499e128f2afb864065ab90", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -380,6 +380,24 @@ where\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n     Q::Value: Value<TyCtxt<'tcx>>,\n {\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n+    debug_assert!(\n+        dep_node.kind != DepKind::codegen_unit,\n+        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+    );\n+\n     if let Some(key) = Q::Key::recover(tcx, &dep_node) {\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();"}, {"sha": "5c6ce0556eb8a4b22b744dbfd5592fbc1cb6e6a6", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -47,6 +47,7 @@ use crate::ich::StableHashingContext;\n \n use rustc_data_structures::fingerprint::{Fingerprint, PackedFingerprint};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::definitions::DefPathHash;\n use std::fmt;\n use std::hash::Hash;\n \n@@ -88,6 +89,17 @@ impl<K: DepKind> DepNode<K> {\n \n         dep_node\n     }\n+\n+    /// Construct a DepNode from the given DepKind and DefPathHash. This\n+    /// method will assert that the given DepKind actually requires a\n+    /// single DefId/DefPathHash parameter.\n+    pub fn from_def_path_hash<Ctxt>(tcx: Ctxt, def_path_hash: DefPathHash, kind: K) -> Self\n+    where\n+        Ctxt: super::DepContext<DepKind = K>,\n+    {\n+        debug_assert!(tcx.fingerprint_style(kind) == FingerprintStyle::DefPathHash);\n+        DepNode { kind, hash: def_path_hash.0.into() }\n+    }\n }\n \n impl<K: DepKind> fmt::Debug for DepNode<K> {\n@@ -149,6 +161,67 @@ where\n     }\n }\n \n+/// This struct stores metadata about each DepKind.\n+///\n+/// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n+/// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n+/// jump table instead of large matches.\n+pub struct DepKindStruct<CTX: DepContext> {\n+    /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n+    /// When their result is needed, it is recomputed. They are useful for fine-grained\n+    /// dependency tracking, and caching within one compiler invocation.\n+    pub is_anon: bool,\n+\n+    /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n+    /// their inputs have not changed since the last compiler invocation. The result is still\n+    /// cached within one compiler invocation.\n+    pub is_eval_always: bool,\n+\n+    /// Whether the query key can be recovered from the hashed fingerprint.\n+    /// See [DepNodeParams] trait for the behaviour of each key type.\n+    pub fingerprint_style: FingerprintStyle,\n+\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    pub force_from_dep_node: Option<fn(tcx: CTX, dep_node: DepNode<CTX::DepKind>) -> bool>,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub try_load_from_on_disk_cache: Option<fn(CTX, DepNode<CTX::DepKind>)>,\n+}\n+\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without"}, {"sha": "5003a14b9108314ee0ebe5dbc7d3c55c8892493d", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff40f2ec95923c4d45366e85bcff17d75df68d68/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=ff40f2ec95923c4d45366e85bcff17d75df68d68", "patch": "@@ -4,7 +4,7 @@ mod graph;\n mod query;\n mod serialized;\n \n-pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n+pub use dep_node::{DepKindStruct, DepNode, DepNodeParams, WorkProductId};\n pub use graph::{\n     hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef, WorkProduct,\n };\n@@ -34,16 +34,43 @@ pub trait DepContext: Copy {\n     /// Access the compiler session.\n     fn sess(&self) -> &Session;\n \n-    /// Return whether this kind always require evaluation.\n-    fn is_eval_always(&self, kind: Self::DepKind) -> bool;\n+    fn dep_kind_info(&self, dep_node: Self::DepKind) -> &DepKindStruct<Self>;\n \n-    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n+    #[inline(always)]\n+    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle {\n+        let data = self.dep_kind_info(kind);\n+        if data.is_anon {\n+            return FingerprintStyle::Opaque;\n+        }\n+        data.fingerprint_style\n+    }\n+\n+    #[inline(always)]\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self, kind: Self::DepKind) -> bool {\n+        self.dep_kind_info(kind).is_eval_always\n+    }\n \n     /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: DepNode<Self::DepKind>) -> bool;\n+    fn try_force_from_dep_node(self, dep_node: DepNode<Self::DepKind>) -> bool {\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        let cb = self.dep_kind_info(dep_node.kind);\n+        if let Some(f) = cb.force_from_dep_node {\n+            f(self, dep_node);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n \n     /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: DepNode<Self::DepKind>);\n+    fn try_load_from_on_disk_cache(self, dep_node: DepNode<Self::DepKind>) {\n+        let cb = self.dep_kind_info(dep_node.kind);\n+        if let Some(f) = cb.try_load_from_on_disk_cache {\n+            f(self, dep_node)\n+        }\n+    }\n }\n \n pub trait HasDepContext: Copy {"}]}