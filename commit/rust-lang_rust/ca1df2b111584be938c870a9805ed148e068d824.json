{"sha": "ca1df2b111584be938c870a9805ed148e068d824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMWRmMmIxMTE1ODRiZTkzOGM4NzBhOTgwNWVkMTQ4ZTA2OGQ4MjQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T10:39:38Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T10:49:00Z"}, "message": "Pretty-print for new arg-mode syntax", "tree": {"sha": "0bffabbe71810e66b3b2b3ffeceed218260d286a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bffabbe71810e66b3b2b3ffeceed218260d286a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1df2b111584be938c870a9805ed148e068d824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1df2b111584be938c870a9805ed148e068d824", "html_url": "https://github.com/rust-lang/rust/commit/ca1df2b111584be938c870a9805ed148e068d824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1df2b111584be938c870a9805ed148e068d824/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bc424e4ea8580f03bbd10e3fa241dfc72c3412c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc424e4ea8580f03bbd10e3fa241dfc72c3412c", "html_url": "https://github.com/rust-lang/rust/commit/5bc424e4ea8580f03bbd10e3fa241dfc72c3412c"}], "stats": {"total": 561, "additions": 311, "deletions": 250}, "files": [{"sha": "03090276bff81392a131527a7ab9c5e9580d0721", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -40,10 +40,9 @@ fn llvm_err(sess: session::session, msg: str) {\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n     let path = fs::connect(sess.get_opts().sysroot, \"lib/intrinsics.bc\");\n-    let membuf =\n-        str::as_buf(path, {|buf|\n-          llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-                    });\n+    let membuf = str::as_buf(path, {|buf|\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+    });\n     if membuf as uint == 0u {\n         llvm_err(sess, \"installation problem: couldn't open \" + path);\n         fail;\n@@ -191,17 +190,16 @@ mod write {\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n-                    let _: () =\n-                        str::as_buf(x86::get_target_triple(), {|buf_t|\n-                            str::as_buf(output, {|buf_o|\n-                                llvm::LLVMRustWriteOutputFile(pm.llpm,\n-                                                              llmod,\n-                                                              buf_t,\n-                                                              buf_o,\n-                                                             LLVMAssemblyFile,\n-                                                              CodeGenOptLevel)\n-                                                    })\n-                                    });\n+                    let _: () = str::as_buf(x86::get_target_triple(), {|buf_t|\n+                        str::as_buf(output, {|buf_o|\n+                            llvm::LLVMRustWriteOutputFile(pm.llpm,\n+                                                          llmod,\n+                                                          buf_t,\n+                                                          buf_o,\n+                                                          LLVMAssemblyFile,\n+                                                          CodeGenOptLevel)\n+                        })\n+                    });\n                 }\n \n \n@@ -218,8 +216,8 @@ mod write {\n                                                               buf_o,\n                                                               LLVMObjectFile,\n                                                               CodeGenOptLevel)\n-                                                    })\n-                                    });\n+                            })\n+                        });\n                 }\n             } else {\n                 // If we aren't saving temps then just output the file\n@@ -234,8 +232,8 @@ mod write {\n                                                           buf_o,\n                                                           FileType,\n                                                           CodeGenOptLevel)\n-                                                })\n-                                });\n+                        })\n+                    });\n             }\n             // Clean up and return\n "}, {"sha": "51b23c4177e51e15a020b5a3308c00e9e4317ad4", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -515,6 +515,7 @@ fn main(args: [str]) {\n \n \n \n+\n               // Object and exe output both use the '.o' extension here\n               link::output_type_object. | link::output_type_exe. {\n                 \"o\""}, {"sha": "fa7871042b8c4c7086f229717aea5d953daa11e5", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -810,18 +810,14 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n     fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef,\n                                                    Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n-        (PMB: PassManagerBuilderRef,\n-                                                        Value: Bool);\n+        (PMB: PassManagerBuilderRef, Value: Bool);\n     fn LLVMPassManagerBuilderUseInlinerWithThreshold\n-        (PMB: PassManagerBuilderRef,\n-                                                     threshold: uint);\n-    fn LLVMPassManagerBuilderPopulateModulePassManager(PMB:\n-                                                        PassManagerBuilderRef,\n-                                                       PM: PassManagerRef);\n+        (PMB: PassManagerBuilderRef, threshold: uint);\n+    fn LLVMPassManagerBuilderPopulateModulePassManager\n+        (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n-    fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB:\n-                                                        PassManagerBuilderRef,\n-                                                         PM: PassManagerRef);\n+    fn LLVMPassManagerBuilderPopulateFunctionPassManager\n+        (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n     fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -962,6 +958,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       // FIXME: more enum-as-int constants determined from Core::h;\n       // horrible, horrible. Complete as needed.\n \n@@ -979,6 +976,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       7 {\n         ret \"i\" + std::int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n@@ -987,6 +985,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       8 {\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n@@ -1003,6 +1002,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n@@ -1017,6 +1017,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n         ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n@@ -1026,6 +1027,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       11 {\n         let i: uint = 0u;\n         for tout: TypeRef in outer0 {\n@@ -1043,6 +1045,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n \n \n \n+\n       12 {\n         ret \"Opaque\";\n       }"}, {"sha": "f77b2eb5130ab2cedc8434685af051307b78c852", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -185,10 +185,9 @@ fn find_library_crate_aux(nn: {prefix: str, suffix: str}, crate_name: str,\n }\n \n fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n-    let mb =\n-        str::as_buf(filename, {|buf|\n-                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-                    });\n+    let mb = str::as_buf(filename, {|buf|\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+    });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);"}, {"sha": "186201b10106ee5d35e3184ce6e3363cbd3b03e7", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -41,7 +41,7 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n type entry<T> = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: ebml::writer, variants: [variant],\n-                            path: [str], index: &mutable [entry<str>]) {\n+                            path: [str], &index: [entry<str>]) {\n     for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -51,16 +51,15 @@ fn encode_tag_variant_paths(ebml_w: ebml::writer, variants: [variant],\n     }\n }\n \n-fn add_to_index(ebml_w: ebml::writer, path: [str],\n-                index: &mutable [entry<str>], name: str) {\n+fn add_to_index(ebml_w: ebml::writer, path: [str], &index: [entry<str>],\n+                name: str) {\n     let full_path = path + [name];\n     index +=\n         [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n-                                   path: [str],\n-                                   index: &mutable [entry<str>]) {\n+                                   path: [str], &index: [entry<str>]) {\n     for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -71,7 +70,7 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n }\n \n fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n-                            index: &mutable [entry<str>]) {\n+                            &index: [entry<str>]) {\n     for it: @item in module.items {\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -226,8 +225,7 @@ fn encode_tag_id(ebml_w: ebml::writer, id: def_id) {\n \n fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                            id: node_id, variants: [variant],\n-                           index: &mutable [entry<int>],\n-                           ty_params: [ty_param]) {\n+                           &index: [entry<int>], ty_params: [ty_param]) {\n     for variant: variant in variants {\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -246,7 +244,7 @@ fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        index: &mutable [entry<int>]) {\n+                        &index: [entry<int>]) {\n     alt item.node {\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);"}, {"sha": "33ffc75e25f421fddc42c07b45ffaa8d61f94e95", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -70,12 +70,14 @@ fn visit_fn(f: ast::_fn, _tp: [ast::ty_param], _sp: span, _name: fn_ident,\n         alt f.proto {\n \n \n+\n           // Blocks need to obey any restrictions from the enclosing scope.\n           ast::proto_block. | ast::proto_closure. {\n             sc\n           }\n \n \n+\n           // Non capturing functions start out fresh.\n           _ {\n             @[]\n@@ -234,8 +236,9 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n                 if i != j &&\n                        ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n                        cant_copy(cx, r) {\n-                    cx.tcx.sess.span_err(args[i].span,\n-                               #fmt[\"argument %u may alias with argument %u, \\\n+                    cx.tcx.sess.span_err\n+                        (args[i].span,\n+                         #fmt[\"argument %u may alias with argument %u, \\\n                               which is not immutably rooted\",\n                                               i, j]);\n                 }\n@@ -478,6 +481,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n \n \n \n+\n           // These may contain anything.\n           ty::ty_fn(_, _, _, _, _) {\n             ret true;\n@@ -487,6 +491,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n \n \n \n+\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be"}, {"sha": "d50491e7458fd9242a23307b21f3901073297565", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -114,6 +114,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_rec(fields) {\n         for f in fields { if type_is_gc_relevant(cx, f.mt.ty) { ret true; } }\n         ret false;\n@@ -126,6 +127,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_tag(did, tps) {\n         let variants = ty::tag_variants(cx, did);\n         for variant in variants {\n@@ -140,6 +142,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_vec(tm) {\n         ret type_is_gc_relevant(cx, tm.ty);\n       }\n@@ -148,6 +151,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _) |\n       ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n       ty::ty_res(_, _, _) {\n@@ -157,6 +161,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";\n       }"}, {"sha": "19eab256c93e6cefd877ea5ead03e80d5bdc2d7e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -243,6 +243,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n \n \n+\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n@@ -1106,13 +1107,15 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n \n \n+\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n           }\n \n \n \n \n+\n           ast::view_item_import_from(_, idents, _) {\n             for ident in idents {\n                 add_to_index(index, ident.node.name,\n@@ -1123,6 +1126,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n \n \n+\n           //globbed imports have to be resolved lazily.\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {\n           }"}, {"sha": "9e0b136e6c79a6d8c2a248cd35f089a65338075d", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -276,15 +276,13 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n          llshapetables: llshapetables};\n }\n \n-fn add_bool(dest: &mutable [u8], val: bool) {\n-    dest += [if val { 1u8 } else { 0u8 }];\n-}\n+fn add_bool(&dest: [u8], val: bool) { dest += [if val { 1u8 } else { 0u8 }]; }\n \n-fn add_u16(dest: &mutable [u8], val: u16) {\n+fn add_u16(&dest: [u8], val: u16) {\n     dest += [val & 0xffu16 as u8, val >> 8u16 as u8];\n }\n \n-fn add_substr(dest: &mutable [u8], src: [u8]) {\n+fn add_substr(&dest: [u8], src: [u8]) {\n     add_u16(dest, vec::len(src) as u16);\n     dest += src;\n }\n@@ -300,6 +298,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_int. {\n         s += [s_int(ccx.tcx)];\n       }\n@@ -308,13 +307,15 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n         s += [s_uint(ccx.tcx)];\n       }\n \n \n \n \n+\n       ty::ty_machine(ast::ty_i8.) {\n         s += [shape_i8];\n       }\n@@ -328,6 +329,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_str. {\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n@@ -337,6 +339,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n           tk_unit. {\n@@ -376,6 +379,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_box(mt) {\n         s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n@@ -407,6 +411,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_fn(_, _, _, _, _) {\n         s += [shape_fn];\n       }\n@@ -416,6 +421,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, t: subt};\n@@ -433,12 +439,14 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n \n \n \n+\n       ty::ty_var(n) {\n         fail \"shape_of ty_var\";\n       }\n \n \n \n+\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n         let found = false;"}, {"sha": "7d7fb9693361d9bbd091b54f1631b7b881a72ced", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -943,7 +943,7 @@ tag ty_param_storage { tps_normal; tps_obj(uint); tps_fn(uint); }\n \n fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n                       storage: ty_param_storage,\n-                      static_ti: &mutable option::t<@tydesc_info>) -> result {\n+                      &static_ti: option::t<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n \n@@ -1026,9 +1026,8 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n type get_tydesc_result = {kind: tydesc_kind, result: result};\n \n fn get_tydesc(cx: @block_ctxt, orig_t: ty::t, escapes: bool,\n-              storage: ty_param_storage,\n-              static_ti: &mutable option::t<@tydesc_info>) ->\n-   get_tydesc_result {\n+              storage: ty_param_storage, &static_ti: option::t<@tydesc_info>)\n+   -> get_tydesc_result {\n \n     let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n \n@@ -1434,8 +1433,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     // Kludge to work around the fact that we know the precise type of the\n     // value here, but the dtor expects a type that still has opaque pointers\n     // for type variables.\n-    let val_llty =\n-        lib::llvm::fn_ty_param_tys\n+    let val_llty = lib::llvm::fn_ty_param_tys\n         (llvm::LLVMGetElementType\n          (llvm::LLVMTypeOf(dtor_addr)))[std::vec::len(args)];\n     let val_cast = BitCast(cx, val.val, val_llty);\n@@ -2180,6 +2178,7 @@ fn trans_unary(cx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         } // FIXME: can remove the else{} once we have\n           // a new snapshot\n \n+\n         let bcx = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n         ret rslt(bcx, sub.box);\n       }\n@@ -3360,6 +3359,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n \n \n \n+\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n@@ -3379,6 +3379,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n           }\n \n \n+\n           // Arg will be provided when the thunk is invoked.\n           none. {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n@@ -3489,9 +3490,9 @@ fn trans_bind_1(cx: @block_ctxt, f: @ast::expr, f_res: lval_result,\n }\n \n fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n-                  to_zero: &mutable [{v: ValueRef, t: ty::t}],\n-                  to_revoke: &mutable [{v: ValueRef, t: ty::t}],\n-                  e: @ast::expr) -> result {\n+                  &to_zero: [{v: ValueRef, t: ty::t}],\n+                  &to_revoke: [{v: ValueRef, t: ty::t}], e: @ast::expr) ->\n+   result {\n     let ccx = bcx_ccx(cx);\n     let e_ty = ty::expr_ty(ccx.tcx, e);\n     let is_bot = ty::type_is_bot(ccx.tcx, e_ty);\n@@ -5531,7 +5532,7 @@ fn decl_native_fn_and_pair(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     }\n \n     fn trans_simple_native_abi(bcx: @block_ctxt, name: str,\n-                               call_args: &mutable [ValueRef], fn_type: ty::t,\n+                               &call_args: [ValueRef], fn_type: ty::t,\n                                uses_retptr: bool, cc: uint) ->\n        {val: ValueRef, rptr: ValueRef} {\n         let call_arg_tys: [TypeRef] = [];\n@@ -5640,16 +5641,12 @@ fn collect_item_1(ccx: @crate_ctxt, i: @ast::item, pt: [str], v: vt<[str]>) {\n         let s =\n             mangle_exported_name(ccx, pt + [i.ident],\n                                  node_id_type(ccx, i.id));\n-        let g = str::as_buf\n-            (s,\n-             // FIXME: Could follow from a constraint on types of const\n-             // items\n-             {|buf|\n-                 check (type_has_static_size(ccx, typ));\n-              llvm::LLVMAddGlobal(ccx.llmod,\n-                                  type_of(ccx, i.span, typ),\n-                                  buf)\n-             });\n+        // FIXME: Could follow from a constraint on types of const\n+        // items\n+        let g = str::as_buf(s, {|buf|\n+            check (type_has_static_size(ccx, typ));\n+            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n+        });\n         ccx.item_symbols.insert(i.id, s);\n         ccx.consts.insert(i.id, g);\n       }\n@@ -5825,11 +5822,10 @@ fn make_common_glue(sess: session::session, output: str) {\n     let task_type = T_task();\n     let taskptr_type = T_ptr(task_type);\n \n-    let llmod =\n-        str::as_buf(\"rust_out\", {|buf|\n-            llvm::LLVMModuleCreateWithNameInContext\n+    let llmod = str::as_buf(\"rust_out\", {|buf|\n+        llvm::LLVMModuleCreateWithNameInContext\n             (buf, llvm::LLVMGetGlobalContext())\n-                                });\n+    });\n     let _: () =\n         str::as_buf(x86::get_data_layout(),\n                     {|buf| llvm::LLVMSetDataLayout(llmod, buf) });\n@@ -5937,12 +5933,10 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, amap: ast_map::map, mut_map: mut::mut_map,\n                copy_map: alias::copy_map) -> ModuleRef {\n-    let llmod =\n-        str::as_buf(\"rust_out\",\n-                    {|buf|\n-                        llvm::LLVMModuleCreateWithNameInContext(buf,\n-                                       llvm::LLVMGetGlobalContext())\n-                    });\n+    let llmod = str::as_buf(\"rust_out\", {|buf|\n+        llvm::LLVMModuleCreateWithNameInContext\n+            (buf, llvm::LLVMGetGlobalContext())\n+    });\n     let _: () =\n         str::as_buf(x86::get_data_layout(),\n                     {|buf| llvm::LLVMSetDataLayout(llmod, buf) });"}, {"sha": "126bb32547a3099ac3d1dd1725d2b234fe0b915d", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -184,7 +184,7 @@ fn enter_box(m: match, col: uint, val: ValueRef) -> match {\n }\n \n fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n-    fn add_to_set(set: &mutable [opt], val: opt) {\n+    fn add_to_set(&set: [opt], val: opt) {\n         for l: opt in set { if opt_eq(l, val) { ret; } }\n         set += [val];\n     }\n@@ -294,7 +294,7 @@ fn pick_col(m: match) -> uint {\n }\n \n fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n-                    exits: &mutable [exit_node]) {\n+                    &exits: [exit_node]) {\n     if vec::len(m) == 0u { Br(bcx, f()); ret; }\n     if vec::len(m[0].pats) == 0u {\n         let data = m[0].data;"}, {"sha": "8eaed5f718fc02c04562934bee6e086dd909fb2d", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -170,7 +170,7 @@ fn log_states_err(pp: pre_and_post_state) {\n \n fn print_ident(i: ident) { log \" \" + i + \" \"; }\n \n-fn print_idents(idents: &mutable [ident]) {\n+fn print_idents(&idents: [ident]) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n     log \"an ident: \" + vec::pop::<ident>(idents);\n     print_idents(idents);"}, {"sha": "9ca8a2da79f909cca154eda3d26f376741a97992", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -32,6 +32,7 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n \n \n \n+\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands) {"}, {"sha": "f8d2209040ad52570034053bb54ac101fc7dc546", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -546,6 +546,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n \n \n+\n       expr_bind(operator, maybe_args) {\n         let args = [];\n         let cmodes = callee_modes(fcx, operator.id);"}, {"sha": "ed5e8bcc144a02032859128d994e9e4f15fb2cb9", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -57,6 +57,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n \n \n \n+\n           /* internally contradictory, but\n              I guess it'll get flagged? */\n           dont_care. {\n@@ -70,6 +71,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n \n \n \n+\n           /* see above comment */\n           _ {\n             tfalse\n@@ -89,6 +91,7 @@ fn trit_or(a: trit, b: trit) -> trit {\n \n \n \n+\n           /* FIXME: ?????? */\n           _ {\n             tfalse\n@@ -109,13 +112,15 @@ fn trit_and(a: trit, b: trit) -> trit {\n \n \n \n+\n       // also seems wrong for case b = ttrue\n       ttrue. {\n         alt b {\n           dont_care. { ttrue }\n \n \n \n+\n           // ??? Seems wrong\n           ttrue. {\n             ttrue\n@@ -124,6 +129,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n \n \n \n+\n           // false wins, since if something is uninit\n           // on one path, we care\n           // (Rationale: it's always safe to assume that\n@@ -138,6 +144,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n \n \n \n+\n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n       tfalse. {"}, {"sha": "d93efd569e31c6e9e8e728dbc3d3547d4edec6fd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -412,22 +412,20 @@ fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n     let has_vars: bool = false;\n-    fn derive_flags_t(cx: ctxt, has_params: &mutable bool,\n-                      has_vars: &mutable bool, tt: t) {\n+    fn derive_flags_t(cx: ctxt, &has_params: bool, &has_vars: bool, tt: t) {\n         let rt = interner::get::<@raw_t>(*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_vars = has_vars || rt.has_vars;\n     }\n-    fn derive_flags_mt(cx: ctxt, has_params: &mutable bool,\n-                       has_vars: &mutable bool, m: mt) {\n+    fn derive_flags_mt(cx: ctxt, &has_params: bool, &has_vars: bool, m: mt) {\n         derive_flags_t(cx, has_params, has_vars, m.ty);\n     }\n-    fn derive_flags_arg(cx: ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, a: arg) {\n+    fn derive_flags_arg(cx: ctxt, &has_params: bool, &has_vars: bool,\n+                        a: arg) {\n         derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n-    fn derive_flags_sig(cx: ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, args: [arg], tt: t) {\n+    fn derive_flags_sig(cx: ctxt, &has_params: bool, &has_vars: bool,\n+                        args: [arg], tt: t) {\n         for a: arg in args { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n@@ -909,6 +907,7 @@ fn type_has_pointers(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n \n \n+\n       // scalar types\n       ty_nil. {\n         /* no-op */\n@@ -977,6 +976,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Scalar types are unique-kind, no substructure.\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n       ty_machine(_) | ty_char. | ty_native(_) {\n@@ -986,6 +986,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // A handful of other built-in are unique too.\n       ty_type. | ty_str. | ty_native_fn(_, _, _) {\n         // no-op\n@@ -994,6 +995,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) {\n@@ -1003,6 +1005,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n@@ -1017,6 +1020,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) {\n@@ -1026,6 +1030,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_vec(tm) {\n@@ -1037,6 +1042,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         for f: field in flds {\n@@ -1047,6 +1053,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         for ty: t in tys {\n@@ -1058,6 +1065,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1075,6 +1083,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Resources are always pinned.\n       ty_res(did, inner, tps) {\n         result = ast::kind_pinned;\n@@ -1083,27 +1092,31 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       ty_var(_) {\n         fail;\n       }\n \n \n \n \n+\n       ty_param(_, k) {\n         result = kind::lower_kind(result, k);\n       }\n \n \n \n \n+\n       ty_constr(t, _) {\n         result = type_kind(cx, t);\n       }\n \n \n \n \n+\n       _ {\n         cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n       }\n@@ -1273,6 +1286,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n \n \n \n+\n       // Scalar types\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n       ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n@@ -1282,6 +1296,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n \n \n \n+\n       // Boxed types\n       ty_str. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _, _) | ty_obj(_) {\n@@ -1291,6 +1306,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n \n \n \n+\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1318,6 +1334,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n \n \n \n+\n       ty_var(_) {\n         fail \"ty_var in type_is_pod\";\n       }\n@@ -1461,6 +1478,7 @@ fn hash_type_structure(st: sty) -> uint {\n \n \n \n+\n       // ???\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n@@ -1796,13 +1814,12 @@ fn occurs_check_fails(tcx: ctxt, sp: option::t<span>, vid: int, rt: t) ->\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n-            tcx.sess.span_fatal(s,\n-                                \"Type inference failed because I \\\n-                 could not find a type\\n that's both of the form \"\n-                                    + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n-                                    \" and of the form \" + ty_to_str(tcx, rt) +\n-                                \". Such a type would have to be infinitely \\\n-                 large.\");\n+            tcx.sess.span_fatal\n+                (s, \"Type inference failed because I \\\n+                     could not find a type\\n that's both of the form \"\n+                 + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n+                 \" and of the form \" + ty_to_str(tcx, rt) +\n+                 \". Such a type would have to be infinitely large.\");\n           }\n           _ { ret true; }\n         }\n@@ -1994,8 +2011,9 @@ mod unify {\n \n             let result_mode;\n             if expected_input.mode != actual_input.mode {\n-       ret fn_common_res_err(ures_err(terr_mode_mismatch(expected_input.mode,\n-                                                        actual_input.mode)));\n+                ret fn_common_res_err\n+                    (ures_err(terr_mode_mismatch(expected_input.mode,\n+                                                 actual_input.mode)));\n             } else { result_mode = expected_input.mode; }\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n@@ -2024,6 +2042,7 @@ mod unify {\n \n \n \n+\n           // ok\n           ast::noreturn. {\n             alt actual_cf {\n@@ -2138,6 +2157,7 @@ mod unify {\n \n \n \n+\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n@@ -2188,6 +2208,7 @@ mod unify {\n \n \n \n+\n           // _|_ unifies with anything\n           ty::ty_bot. {\n             ret ures_ok(actual);\n@@ -2841,7 +2862,7 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: @ast::constr_general<T>) ->\n       _ {\n         tcx.sess.span_fatal(c.span,\n                             \"Predicate \" + path_to_str(c.node.path) +\n-             \" is unbound or bound to a non-function or an \\\n+                            \" is unbound or bound to a non-function or an \\\n             impure function\");\n       }\n     }"}, {"sha": "25e87a0587f171eed8f57965b23d452dc613fcb4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -169,14 +169,14 @@ fn instantiate_path(fcx: @fn_ctxt, pth: ast::path, tpt: ty_param_kinds_and_ty,\n     if ty_substs_len > 0u {\n         let param_var_len = vec::len(ty_param_vars);\n         if param_var_len == 0u {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                    \"this item does not take type parameters\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"this item does not take type parameters\");\n         } else if ty_substs_len > param_var_len {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                 \"too many type parameter provided for this item\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"too many type parameter provided for this item\");\n         } else if ty_substs_len < param_var_len {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                \"not enough type parameters provided for this item\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"not enough type parameters provided for this item\");\n         }\n         let ty_substs: [ty::t] = [];\n         let i = 0u;\n@@ -211,8 +211,8 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n       fix_ok(typ_s) { ret typ_s; }\n       fix_err(_) {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-              \"the type of this value must be known in this context\");\n+        fcx.ccx.tcx.sess.span_fatal\n+            (sp, \"the type of this value must be known in this context\");\n       }\n     }\n }\n@@ -845,8 +845,8 @@ mod collect {\n             visit::mk_simple_visitor(@{visit_item: bind convert(cx, abi, _),\n                                        visit_native_item:\n                                            bind convert_native(cx, abi, _)\n-                                          with\n-                               *visit::default_simple_visitor()});\n+                                       with\n+                                          *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n     }\n }\n@@ -1364,8 +1364,9 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n                 }\n             } else if subpats_len > 0u {\n                 // TODO: note definition of tag variant\n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                       #fmt[\"this pattern has %u field%s, \\\n+                fcx.ccx.tcx.sess.span_fatal\n+                    (pat.span,\n+                     #fmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n                                                  subpats_len,\n@@ -1378,10 +1379,10 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                       #fmt[\"mismatched types: expected %s, found tag\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span,\n+                 #fmt[\"mismatched types: expected %s, found tag\",\n+                      ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1391,20 +1392,19 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                    #fmt[\"mismatched types: expected %s, found record\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected %s, found record\",\n+                                ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                   #fmt[\"mismatched types: expected a record \\\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                                             ex_f_count, f_count]);\n+                                ex_f_count, f_count]);\n         }\n         fn matches(name: str, f: ty::field) -> bool {\n             ret str::eq(name, f.ident);\n@@ -1427,19 +1427,17 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                #fmt[\"mismatched types: expected %s, found tuple\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected %s, found tuple\",\n+                                ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                  #fmt[\"mismatched types: expected a tuple \\\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n-                      fields\",\n-                                             vec::len(ex_elts), e_count]);\n+                      fields\", vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n         for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n@@ -1479,8 +1477,8 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n         alt ccx.tcx.def_map.find(callee.id) {\n           some(ast::def_fn(_, ast::pure_fn.)) { ret; }\n           _ {\n-            ccx.tcx.sess.span_fatal(sp,\n-         \"Pure function calls function not known to be pure\");\n+            ccx.tcx.sess.span_fatal\n+                (sp, \"pure function calls function not known to be pure\");\n           }\n         }\n       }\n@@ -1528,14 +1526,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt sty {\n           ty::ty_fn(ast::proto_iter., _, _, _, _) {\n             if call_kind != kind_for_each {\n-                fcx.ccx.tcx.sess.span_err(sp,\n-                       \"calling iter outside of for each loop\");\n+                fcx.ccx.tcx.sess.span_err\n+                    (sp, \"calling iter outside of for each loop\");\n             }\n           }\n           _ {\n             if call_kind == kind_for_each {\n-                fcx.ccx.tcx.sess.span_err(sp,\n-                   \"calling non-iter as sequence of for each loop\");\n+                fcx.ccx.tcx.sess.span_err\n+                    (sp, \"calling non-iter as sequence of for each loop\");\n             }\n           }\n         }\n@@ -1921,8 +1919,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n-                     \"mismatched types: expected vector or string but \"\n-                                    + \"found \" + ty_to_str(tcx, ety));\n+                                \"mismatched types: expected vector or string \"\n+                                + \"but found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -2022,6 +2020,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let proto, arg_tys, rt, cf, constrs;\n         alt structure_of(fcx, expr.span, expr_ty(tcx, f)) {\n \n+\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n           // for any bound args\n@@ -2313,9 +2312,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                       ty::ty_obj(ms) { inner_obj_methods = ms; }\n                       _ {\n                         // The user is trying to extend a non-object.\n-                        tcx.sess.span_fatal(e.span,\n-                                   syntax::print::pprust::expr_to_str(e) +\n-                                   \" does not have object type\");\n+                        tcx.sess.span_fatal\n+                            (e.span, syntax::print::pprust::expr_to_str(e)\n+                             + \" does not have object type\");\n                       }\n                     }\n                   }\n@@ -2340,10 +2339,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx, om);\n                         if new_type != m {\n-                            ccx.tcx.sess.span_fatal(om.span,\n-                                         \"Attempted to override method \"\n-                                                    + m.ident +\n-                                         \" with one of a different type\");\n+                            ccx.tcx.sess.span_fatal\n+                                (om.span, \"attempted to override method \"\n+                                 + m.ident + \" with one of a different type\");\n                         }\n                         ret none;\n                     }\n@@ -2518,8 +2516,9 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_call(operator, operands) {\n         if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n-            fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                      \"Operator in constraint has non-boolean return type\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (operator.span,\n+                 \"operator in constraint has non-boolean return type\");\n         }\n \n         alt operator.node {\n@@ -2592,9 +2591,10 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n                                types: []};\n                           let arg_occ_node_id =\n                               fcx.ccx.tcx.sess.next_node_id();\n-                          fcx.ccx.tcx.def_map.insert(arg_occ_node_id,\n-                                           ast::def_arg(local_def(args[i].id),\n-                                                               args[i].mode));\n+                          fcx.ccx.tcx.def_map.insert\n+                              (arg_occ_node_id,\n+                               ast::def_arg(local_def(args[i].id),\n+                                            args[i].mode));\n                           {id: arg_occ_node_id,\n                            node: ast::expr_path(respan(a.span, p)),\n                            span: a.span}"}, {"sha": "2be624b7d1c018120ad68e47753db99f7af9dd8e", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -294,6 +294,7 @@ tag ty_ {\n \n \n \n+\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n@@ -383,6 +384,7 @@ tag controlflow {\n \n \n \n+\n     return; // everything else\n }\n "}, {"sha": "d9995cd445186a3cef1ffb60b5286cba2ea0ca58", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -334,8 +334,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if expected_nargs < nargs {\n-        cx.span_fatal(sp,\n-       #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n+        cx.span_fatal\n+            (sp, #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n                            nargs, expected_nargs]);\n     }\n     ret tmp_expr;"}, {"sha": "9ac710356949e11fd9785431facde01d8e40b5b9", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -431,6 +431,7 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n \n \n \n+\n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n                 match_error(cx, m, \"a block\")\n@@ -480,6 +481,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n \n \n+\n           /* TODO: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);"}, {"sha": "d525425dda7dd958ce25f1b99135e6e66b592c5a", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -26,8 +26,8 @@ type ctx =\n       cfg: ast::crate_cfg};\n \n fn eval_crate_directives(cx: ctx, cdirs: [@ast::crate_directive], prefix: str,\n-                         view_items: &mutable [@ast::view_item],\n-                         items: &mutable [@ast::item]) {\n+                         &view_items: [@ast::view_item],\n+                         &items: [@ast::item]) {\n     for sub_cdir: @ast::crate_directive in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n@@ -42,8 +42,8 @@ fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive],\n }\n \n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n-                        view_items: &mutable [@ast::view_item],\n-                        items: &mutable [@ast::item]) {\n+                        &view_items: [@ast::view_item],\n+                        &items: [@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, file_opt, attrs) {\n         let file_path = id + \".rs\";"}, {"sha": "287b7fc1d3982e2240ab427644fdd3488bf1e9c2", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -363,6 +363,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n \n \n \n+\n       // One-byte tokens.\n       '?' {\n         rdr.bump();\n@@ -404,6 +405,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n \n \n \n+\n       // Multi-byte tokens.\n       '=' {\n         rdr.bump();\n@@ -579,14 +581,13 @@ fn consume_non_eol_whitespace(rdr: reader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: reader, comments: &mutable [cmnt]) {\n+fn push_blank_line_comment(rdr: reader, &comments: [cmnt]) {\n     log \">>> blank-line comment\";\n     let v: [str] = [];\n     comments += [{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: reader,\n-                                           comments: &mutable [cmnt]) {\n+fn consume_whitespace_counting_blank_lines(rdr: reader, &comments: [cmnt]) {\n     while is_whitespace(rdr.curr()) && !rdr.is_eof() {\n         if rdr.get_col() == 0u && rdr.curr() == '\\n' {\n             push_blank_line_comment(rdr, comments);\n@@ -617,8 +618,7 @@ fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: str,\n-                                        col: uint) {\n+fn trim_whitespace_prefix_and_push_line(&lines: [str], s: str, col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n         if col < str::byte_len(s) {\n@@ -679,8 +679,7 @@ fn peeking_at_comment(rdr: reader) -> bool {\n             rdr.curr() == '/' && rdr.next() == '*';\n }\n \n-fn consume_comment(rdr: reader, code_to_the_left: bool,\n-                   comments: &mutable [cmnt]) {\n+fn consume_comment(rdr: reader, code_to_the_left: bool, &comments: [cmnt]) {\n     log \">>> consume comment\";\n     if rdr.curr() == '/' && rdr.next() == '/' {\n         comments += [read_line_comments(rdr, code_to_the_left)];"}, {"sha": "1b3126e833a0f1449227d291dd7f61b40fd9dfd3", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -323,7 +323,7 @@ fn parse_proto(p: parser) -> ast::proto {\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_ty_obj(p: parser, hi: &mutable uint) -> ast::ty_ {\n+fn parse_ty_obj(p: parser, &hi: uint) -> ast::ty_ {\n     fn parse_method_sig(p: parser) -> ast::ty_method {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_proto(p);\n@@ -585,9 +585,7 @@ fn parse_arg_mode(p: parser) -> ast::mode {\n         ret ast::by_mut_ref;\n     } else if eat(p, token::BINOP(token::MINUS)) {\n         ret ast::by_move;\n-    } else {\n-        ret ast::by_ref;\n-    }\n+    } else { ret ast::by_ref; }\n }\n \n fn parse_arg(p: parser) -> ast::arg {\n@@ -827,7 +825,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n             expect(p, token::RBRACE);\n             ex = ast::expr_rec(fields, base);\n         } else if p.peek() == token::BINOP(token::OR) ||\n-                  p.peek() == token::OROR {\n+                      p.peek() == token::OROR {\n             ret parse_fn_block_expr(p);\n         } else {\n             let blk = parse_block_tail(p, lo, ast::checked);\n@@ -1380,6 +1378,7 @@ fn parse_initializer(p: parser) -> option::t<ast::initializer> {\n \n \n \n+\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n@@ -1642,6 +1641,7 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n \n \n \n+\n       // We should not be calling this on a cdir.\n       ast::stmt_crate_directive(cdir) {\n         fail;\n@@ -1773,12 +1773,14 @@ fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n }\n \n fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n-    let inputs = if p.peek() == token::OROR {\n-        p.bump(); []\n-    } else {\n-        parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),\n-                  some(token::COMMA), parse_fn_block_arg, p).node\n-    };\n+    let inputs =\n+        if p.peek() == token::OROR {\n+            p.bump();;\n+            []\n+        } else {\n+            parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),\n+                      some(token::COMMA), parse_fn_block_arg, p).node\n+        };\n     ret {inputs: inputs,\n          output: @spanned(p.get_lo_pos(), p.get_hi_pos(), ast::ty_infer),\n          purity: ast::impure_fn,\n@@ -2269,6 +2271,7 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n \n \n \n+\n           //the lexer can't tell the different kinds of stars apart ) :\n           token::BINOP(token::STAR.) {\n             glob = true;\n@@ -2278,6 +2281,7 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n \n \n \n+\n           token::LBRACE. {\n             fn parse_import_ident(p: parser) -> ast::import_ident {\n                 let lo = p.get_lo_pos();\n@@ -2297,6 +2301,7 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n \n \n \n+\n           _ {\n             p.fatal(\"expecting an identifier, or '*'\");\n           }\n@@ -2460,6 +2465,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n \n \n \n+\n           // mod x = \"foo.rs\";\n           token::SEMI. {\n             let hi = p.get_hi_pos();\n@@ -2470,6 +2476,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n \n \n \n+\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE. {\n             p.bump();"}, {"sha": "7e7f7e2652c1888180b5633b72c6d2a9bdf12c09", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -119,6 +119,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Structural symbols */\n       AT. {\n         ret \"@\";\n@@ -146,6 +147,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Literals */\n       LIT_INT(i) {\n         ret int::to_str(i, 10u);\n@@ -174,6 +176,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Name components */\n       IDENT(s, _) {\n         ret interner::get::<str>(*r.get_interner(), s);"}, {"sha": "61b0d0644a1deb0bbe44d2df00a647eb740b25f4", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -364,6 +364,7 @@ fn print_native_item(s: ps, item: @ast::native_item) {\n \n \n \n+\n       ast::native_item_fn(lname, decl, typarams) {\n         print_fn(s, decl, ast::proto_fn, item.ident, typarams,\n                  decl.constraints);\n@@ -717,6 +718,7 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n \n \n \n+\n               // \"another else-if\"\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n@@ -731,6 +733,7 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n \n \n \n+\n               // \"final else\"\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n@@ -1362,6 +1365,7 @@ fn need_parens(expr: @ast::expr, outer_prec: int) -> bool {\n \n \n \n+\n       // This may be too conservative in some cases\n       ast::expr_assign(_, _) {\n         true"}, {"sha": "fad5b0ebb31e968c12ea3e2a1b4ae677954f3e92", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -35,7 +35,7 @@ fn contains(haystack: str, needle: str) -> bool {\n     str::find(haystack, needle) != -1\n }\n \n-fn find_rust_files(files: &[str], path: str) {\n+fn find_rust_files(&files: [str], path: str) {\n     if str::ends_with(path, \".rs\") {\n         if file_contains(path, \"xfail-test\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";"}, {"sha": "dfd8587e36be058de2414a2dcc0940eddb38b5c7", "filename": "src/lib/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -13,7 +13,7 @@ native \"rust\" mod rustrt {\n     type rust_port;\n \n     fn chan_id_send<~T>(target_task: task::task, target_port: port_id,\n-                        data: -T);\n+                        -data: T);\n \n     fn new_port(unit_sz: uint) -> *rust_port;\n     fn del_port(po: *rust_port);\n@@ -38,7 +38,7 @@ resource port_ptr(po: *rustrt::rust_port) {\n \n tag port<~T> { port_t(@port_ptr); }\n \n-fn send<~T>(ch: chan<T>, data: -T) {\n+fn send<~T>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     rustrt::chan_id_send(t, p, data);\n }"}, {"sha": "134d0090be20284966a10e660b575ac1f07c4f5b", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -29,6 +29,7 @@ fn create<@T>() -> t<T> {\n \n \n \n+\n     fn grow<@T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));"}, {"sha": "e7fd1603ef07e24dae33614878529126f97120a7", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -74,7 +74,7 @@ mod ct {\n         let pieces: [piece] = [];\n         let lim = str::byte_len(s);\n         let buf = \"\";\n-        fn flush_buf(buf: str, pieces: &mutable [piece]) -> str {\n+        fn flush_buf(buf: str, &pieces: [piece]) -> str {\n             if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];"}, {"sha": "e179aa1f92c28682e621224bcaf7fa449105efb4", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -56,15 +56,12 @@ fn getenv(n: str) -> option::t<str> {\n fn setenv(n: str, v: str) {\n     // FIXME (868)\n     let _: () =\n-        str::as_buf(n,\n-                    {|nbuf|\n-                        let _: () =\n-                            str::as_buf(v,\n-                                        {|vbuf|\n-                      os::kernel32::SetEnvironmentVariableA(nbuf,\n-                                                            vbuf);\n-                                        });\n-                    });\n+        str::as_buf(n, {|nbuf|\n+            let _: () =\n+                str::as_buf(v, {|vbuf|\n+                    os::kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n+                });\n+        });\n }\n \n // Local Variables:"}, {"sha": "7ce8c05b09517881cf9767771b4a5998c2e10c92", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -27,7 +27,7 @@ native \"cdecl\" mod libc = \"\" {\n     fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n     fn unsetenv(n: str::sbuf) -> int;\n     fn pipe(buf: *mutable int) -> int;\n-    fn waitpid(pid: int, status: &mutable int, options: int) -> int;\n+    fn waitpid(pid: int, &status: int, options: int) -> int;\n }\n \n mod libc_constants {"}, {"sha": "2897551d80a0b232d7a4ca8ec1b4fd683fd9e59b", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -24,7 +24,7 @@ native \"cdecl\" mod libc = \"\" {\n     fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n     fn unsetenv(n: str::sbuf) -> int;\n     fn pipe(buf: *mutable int) -> int;\n-    fn waitpid(pid: int, status: &mutable int, options: int) -> int;\n+    fn waitpid(pid: int, &status: int, options: int) -> int;\n }\n \n mod libc_constants {"}, {"sha": "ef10ca20ffc1c1a81845dbfdcdbc2c4fdf0e52b4", "filename": "src/lib/str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -7,7 +7,7 @@ export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len, index,\n        str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice;\n \n native \"rust\" mod rustrt {\n-    fn rust_str_push(s: &mutable str, ch: u8);\n+    fn rust_str_push(&s: str, ch: u8);\n }\n \n fn eq(a: str, b: str) -> bool { a == b }\n@@ -101,7 +101,7 @@ fn unsafe_from_bytes(v: [mutable? u8]) -> str {\n \n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n-fn push_utf8_bytes(s: &mutable str, ch: char) {\n+fn push_utf8_bytes(&s: str, ch: char) {\n     let code = ch as uint;\n     let bytes =\n         if code < max_one_b {\n@@ -206,9 +206,9 @@ fn to_chars(s: str) -> [char] {\n     ret buf;\n }\n \n-fn push_char(s: &mutable str, ch: char) { s += from_char(ch); }\n+fn push_char(&s: str, ch: char) { s += from_char(ch); }\n \n-fn pop_char(s: &mutable str) -> char {\n+fn pop_char(&s: str) -> char {\n     let end = byte_len(s);\n     while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n     assert (end > 0u);\n@@ -217,13 +217,13 @@ fn pop_char(s: &mutable str) -> char {\n     ret ch;\n }\n \n-fn shift_char(s: &mutable str) -> char {\n+fn shift_char(&s: str) -> char {\n     let r = char_range_at(s, 0u);\n     s = substr(s, r.next, byte_len(s) - r.next);\n     ret r.ch;\n }\n \n-fn unshift_char(s: &mutable str, ch: char) { s = from_char(ch) + s; }\n+fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n fn index(s: str, c: u8) -> int {\n     let i: int = 0;\n@@ -299,25 +299,25 @@ fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n     ret slice(s, begin, end);\n }\n \n-fn shift_byte(s: &mutable str) -> u8 {\n+fn shift_byte(&s: str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[0];\n     s = substr(s, 1u, len - 1u);\n     ret b;\n }\n \n-fn pop_byte(s: &mutable str) -> u8 {\n+fn pop_byte(&s: str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[len - 1u];\n     s = substr(s, 0u, len - 1u);\n     ret b;\n }\n \n-fn push_byte(s: &mutable str, b: u8) { rustrt::rust_str_push(s, b); }\n+fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n \n-fn push_bytes(s: &mutable str, bytes: [u8]) {\n+fn push_bytes(&s: str, bytes: [u8]) {\n     for byte in bytes { rustrt::rust_str_push(s, byte); }\n }\n "}, {"sha": "4b78f883debe63461cc9ab5e5291001eb917fd11", "filename": "src/lib/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -95,20 +95,20 @@ fn unpin() { rustrt::unpin_task(); }\n \n fn set_min_stack(stack_size: uint) { rustrt::set_min_stack(stack_size); }\n \n-fn spawn(thunk: -fn()) -> task { spawn_inner(thunk, none) }\n+fn spawn(-thunk: fn()) -> task { spawn_inner(thunk, none) }\n \n-fn spawn_notify(thunk: -fn(), notify: comm::chan<task_notification>) -> task {\n+fn spawn_notify(-thunk: fn(), notify: comm::chan<task_notification>) -> task {\n     spawn_inner(thunk, some(notify))\n }\n \n-fn spawn_joinable(thunk: -fn()) -> joinable_task {\n+fn spawn_joinable(-thunk: fn()) -> joinable_task {\n     let p = comm::port::<task_notification>();\n     let id = spawn_notify(thunk, comm::chan::<task_notification>(p));\n     ret (id, p);\n }\n \n // FIXME: make this a fn~ once those are supported.\n-fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n+fn spawn_inner(-thunk: fn(), notify: option<comm::chan<task_notification>>) ->\n    task_id {\n     let id = rustrt::new_task();\n "}, {"sha": "974224061cfe9dc888dcc380a7b1fd71c9854ba1", "filename": "src/lib/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,8 +1,8 @@\n \n \n native \"rust\" mod rustrt {\n-    fn get_time(sec: &mutable u32, usec: &mutable u32);\n-    fn nano_time(ns: &mutable u64);\n+    fn get_time(&sec: u32, &usec: u32);\n+    fn nano_time(&ns: u64);\n }\n \n type timeval = {sec: u32, usec: u32};"}, {"sha": "1190903482029cb73b9c383a65e9049b9a253378", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -5,10 +5,10 @@ native \"rust-intrinsic\" mod rusti {\n }\n \n native \"rust\" mod rustrt {\n-    fn leak<@T>(thing: -T);\n+    fn leak<@T>(-thing: T);\n }\n \n // Casts the value at `src` to U. The two types must have the same length.\n fn reinterpret_cast<T, @U>(src: T) -> U { ret rusti::cast(src); }\n \n-fn leak<@T>(thing: -T) { rustrt::leak(thing); }\n+fn leak<@T>(-thing: T) { rustrt::leak(thing); }"}, {"sha": "c9d3a6cecf446e2c3da988767fadd8c0597ef962", "filename": "src/lib/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -10,12 +10,12 @@ native \"rust-intrinsic\" mod rusti {\n }\n \n native \"rust\" mod rustrt {\n-    fn vec_reserve_shared<T>(v: &mutable [mutable? T], n: uint);\n+    fn vec_reserve_shared<T>(&v: [mutable? T], n: uint);\n     fn vec_from_buf_shared<T>(ptr: *T, count: uint) -> [T];\n }\n \n /// Reserves space for `n` elements in the given vector.\n-fn reserve<@T>(v: &mutable [mutable? T], n: uint) {\n+fn reserve<@T>(&v: [mutable? T], n: uint) {\n     rustrt::vec_reserve_shared(v, n);\n }\n \n@@ -127,7 +127,7 @@ fn slice_mut<@T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n \n // Mutators\n \n-fn shift<@T>(v: &mutable [mutable? T]) -> T {\n+fn shift<@T>(&v: [mutable? T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n     let e = v[0];\n@@ -136,7 +136,7 @@ fn shift<@T>(v: &mutable [mutable? T]) -> T {\n }\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n-fn pop<@T>(v: &mutable [mutable? T]) -> T {\n+fn pop<@T>(&v: [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -151,22 +151,22 @@ fn pop<@T>(v: &mutable [mutable? T]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow<@T>(v: &mutable [T], n: uint, initval: T) {\n+fn grow<@T>(&v: [T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut<@T>(v: &mutable [mutable T], n: uint, initval: T) {\n+fn grow_mut<@T>(&v: [mutable T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T) {\n+fn grow_fn<@T>(&v: [T], n: uint, init_fn: fn(uint) -> T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [init_fn(i)]; i += 1u; }\n@@ -175,7 +175,7 @@ fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set<@T>(v: &mutable [mutable T], index: uint, initval: T, val: T) {\n+fn grow_set<@T>(&v: [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n@@ -337,7 +337,7 @@ mod unsafe {\n         ret rustrt::vec_from_buf_shared(ptr, elts);\n     }\n \n-    fn set_len<T>(v: &mutable [T], new_len: uint) {\n+    fn set_len<T>(&v: [T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }"}, {"sha": "0ed1f94e59f3d16fcd53dfb5385c5c27d1de5d29", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -83,8 +83,8 @@ mod map_reduce {\n     }\n \n     fn map_task<~K1, ~K2,\n-                ~V>(map: -mapper<K1, K2, V>, ctrl: -chan<ctrl_proto<K2, V>>,\n-                    input: -K1) {\n+                ~V>(-map: mapper<K1, K2, V>, -ctrl: chan<ctrl_proto<K2, V>>,\n+                    -input: K1) {\n         // log_err \"map_task \" + input;\n         let intermediates = treemap::init();\n \n@@ -115,17 +115,17 @@ mod map_reduce {\n     }\n \n     fn reduce_task<~K,\n-                   ~V>(reduce: -reducer<K, V>, key: -K,\n-                       out: -chan<chan<reduce_proto<V>>>) {\n+                   ~V>(-reduce: reducer<K, V>, -key: K,\n+                       -out: chan<chan<reduce_proto<V>>>) {\n         let p = port();\n \n         send(out, chan(p));\n \n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get<~V>(p: port<reduce_proto<V>>, ref_count: &mutable int,\n-                   is_done: &mutable bool) -> option<V> {\n+        fn get<~V>(p: port<reduce_proto<V>>, &ref_count: int, &is_done: bool)\n+           -> option<V> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {"}, {"sha": "81d97adc9170737583df494475faad82b4c51e23", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -117,8 +117,8 @@ mod map_reduce {\n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get(p: port<reduce_proto>, ref_count: &mutable int,\n-               is_done: &mutable bool) -> option<int> {\n+        fn get(p: port<reduce_proto>, &ref_count: int, &is_done: bool) ->\n+           option<int> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {"}, {"sha": "4b7faaa0280e95d3f66ce6a93df6d5bd9e0ebbdb", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern: Pure function calls function not known to be pure\n+// error-pattern: pure function calls function not known to be pure\n \n fn g() { }\n "}, {"sha": "d8d4c1926ddca048797e2146c3fcc1d9f53f1b36", "filename": "src/test/compile-fail/move-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: Unsatisfied precondition constraint\n-fn test(foo: -int) { assert (foo == 10); }\n+fn test(-foo: int) { assert (foo == 10); }\n \n fn main() { let x = 10; test(x); log x; }"}, {"sha": "3bac354fb246a8b174553038a1db0e5f26a26205", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -10,4 +10,5 @@ fn main() {\n \n \n \n+\n }"}, {"sha": "142e90a46a88e9db378d862e46877acfe8c8121d", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:mutable alias to a variable that roots another alias\n \n-fn f(a: {mutable x: int}, b: &mutable {mutable x: int}) -> int {\n+fn f(a: {mutable x: int}, &b: {mutable x: int}) -> int {\n     b.x += 1;\n     ret a.x + b.x;\n }"}, {"sha": "c879bdef1a9736190d213688f9f8f963c7118cef", "filename": "src/test/compile-fail/use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: Unsatisfied precondition constraint\n-fn send<~T>(ch: _chan<T>, data: -T) { log ch; log data; fail; }\n+fn send<~T>(ch: _chan<T>, -data: T) { log ch; log data; fail; }\n type _chan<T> = int;\n \n // Tests that \"log message;\" is flagged as using"}, {"sha": "03bc0e72cc77d40af8f1fd4e310251c32f5b76e8", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -235,11 +235,11 @@ fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: fn()) ->\n     ret task::spawn_joinable(testthunk);\n }\n \n-fn run_test_task(compile_lib_path: -str, run_lib_path: -str, rustc_path: -str,\n-                 src_base: -str, build_base: -str, stage_id: -str, mode: -str,\n-                 run_ignored: -bool, opt_filter: -str, opt_runtool: -str,\n-                 opt_rustcflags: -str, verbose: -bool,\n-                 procsrv_chan: -procsrv::reqchan, testfile: -[u8]) {\n+fn run_test_task(-compile_lib_path: str, -run_lib_path: str, -rustc_path: str,\n+                 -src_base: str, -build_base: str, -stage_id: str, -mode: str,\n+                 -run_ignored: bool, -opt_filter: str, -opt_runtool: str,\n+                 -opt_rustcflags: str, -verbose: bool,\n+                 -procsrv_chan: procsrv::reqchan, -testfile: [u8]) {\n \n     test::configure_test_task();\n "}, {"sha": "8ed938094c9da6593074f084dfa82ddbebc01669", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -18,7 +18,7 @@ import util::logv;\n \n export run;\n \n-fn run(cx: cx, _testfile: -[u8]) {\n+fn run(cx: cx, -_testfile: [u8]) {\n     let testfile = str::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line."}, {"sha": "f83667ccf87f614e44bf3d9346ed81f3d05dcfbc", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -6,6 +6,6 @@ type port_id = int;\n \n type chan_t<~T> = {task: task_id, port: port_id};\n \n-fn send<~T>(ch: chan_t<T>, data: -T) { fail; }\n+fn send<~T>(ch: chan_t<T>, -data: T) { fail; }\n \n fn main() { fail \"quux\"; }"}, {"sha": "9c301ae2ac235260721deac8a33e08d3ab54e431", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,4 +1,4 @@\n-fn f1(a: {mutable x: int}, b: &mutable int, c: -int) -> int {\n+fn f1(a: {mutable x: int}, &b: int, -c: int) -> int {\n     let r = a.x + b + c;\n     a.x = 0;\n     b = 10;"}, {"sha": "01d01fce2ad371eade4b8e548c015d810063efdf", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -3,6 +3,6 @@\n use std;\n import std::task;\n \n-fn child2(s: -str) { }\n+fn child2(-s: str) { }\n \n fn main() { let x = task::spawn(bind child2(\"hi\")); }"}, {"sha": "9560503fd67dfb6ef6bcd831fca36c25d1e85767", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -36,7 +36,7 @@ mod map_reduce {\n         for i: str in inputs { task::spawn(bind map_task(ctrl, i)); }\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: -str) {\n+    fn map_task(ctrl: chan<ctrl_proto>, -input: str) {\n \n         let intermediates = map::new_str_hash();\n "}, {"sha": "0fa03511e340c090d3ef2fb5e3f53710d11e4454", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn incr(x: &mutable int) -> bool { x += 1; assert (false); ret false; }\n+fn incr(&x: int) -> bool { x += 1; assert (false); ret false; }\n \n fn main() {\n     let x = 1 == 2 || 3 == 3;"}, {"sha": "65a3913132c1ca5c736739d71d73800bea613378", "filename": "src/test/run-pass/move-arg-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,4 +1,4 @@\n-fn test(foo: -@[int]) { assert (foo[0] == 10); }\n+fn test(-foo: @[int]) { assert (foo[0] == 10); }\n \n fn main() {\n     let x = @[10];"}, {"sha": "286b7c6cb6dbc9f71ac809762c4abe1155368196", "filename": "src/test/run-pass/move-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,3 +1,3 @@\n-fn test(foo: -int) { assert (foo == 10); }\n+fn test(-foo: int) { assert (foo == 10); }\n \n fn main() { let x = 10; test(x); }"}, {"sha": "334c8baed4fb3fac3ed9a73795d3e1ebb64e5fb8", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n use std;\n \n-fn grow(v: &mutable [int]) { v += [1]; }\n+fn grow(&v: [int]) { v += [1]; }\n \n fn main() {\n     let v: [int] = [];"}, {"sha": "019df905956638e9d0c33ffb9057e7616c77eab3", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -4,7 +4,7 @@ use std;\n import std::task::yield;\n import std::task;\n \n-fn x(s: -str, n: int) { log s; log n; }\n+fn x(-s: str, n: int) { log s; log n; }\n \n fn main() {\n     task::spawn(bind x(\"hello from first spawned fn\", 65));"}, {"sha": "9407379c10b1f4e6bab339ac65339ecfd8b02b48", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -12,7 +12,7 @@ import std::task;\n \n type ctx = comm::chan<int>;\n \n-fn iotask(cx: ctx, ip: -str) { assert (str::eq(ip, \"localhost\")); }\n+fn iotask(cx: ctx, -ip: str) { assert (str::eq(ip, \"localhost\")); }\n \n fn main() {\n     let p = comm::port::<int>();"}, {"sha": "0d4bfbc5d3b83564e379abc171c8fb5b8e820440", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -2,6 +2,6 @@ use std;\n import std::task;\n fn main() { task::spawn(bind child(\"Hello\")); }\n \n-fn child(s: -str) {\n+fn child(-s: str) {\n \n }"}, {"sha": "0e0d828bf63d1981002cb787efcce43f2e39eeab", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn push<T>(v: &mutable [mutable? T], t: T) { v += [t]; }\n+fn push<T>(&v: [mutable? T], t: T) { v += [t]; }\n \n fn main() { let v = [1, 2, 3]; push(v, 1); }"}, {"sha": "fff85460ee17f4451a23198023c853e86987e271", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type point = {x: int, y: int, mutable z: int};\n \n-fn f(p: &mutable point) { p.z = 13; }\n+fn f(&p: point) { p.z = 13; }\n \n fn main() {\n     let x: point = {x: 10, y: 11, mutable z: 12};"}, {"sha": "498a511dfc4a88e3e59dcc082cab7ba9ed550d9c", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -67,7 +67,7 @@ fn test_join_convenient() {\n \n #[test]\n fn spawn_polymorphic() {\n-    fn foo<~T>(x: -T) { log_err x; }\n+    fn foo<~T>(-x: T) { log_err x; }\n \n     let fb = bind foo(true);\n "}, {"sha": "05598be3069ef6d5b1b30429ed19d75d44952fad", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1df2b111584be938c870a9805ed148e068d824/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=ca1df2b111584be938c870a9805ed148e068d824", "patch": "@@ -40,7 +40,7 @@ fn traverse_in_order() {\n     insert(m, 1, ());\n \n     let n = 0;\n-    fn t(n: &mutable int, k: int, v: ()) { assert (n == k); n += 1; }\n+    fn t(&n: int, k: int, v: ()) { assert (n == k); n += 1; }\n     traverse(m, bind t(n, _, _));\n }\n "}]}