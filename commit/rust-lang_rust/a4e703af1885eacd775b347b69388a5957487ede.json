{"sha": "a4e703af1885eacd775b347b69388a5957487ede", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZTcwM2FmMTg4NWVhY2Q3NzViMzQ3YjY5Mzg4YTU5NTc0ODdlZGU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-08-22T17:24:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-22T17:24:46Z"}, "message": "Merge pull request #1076 from CohenArthur/use-codegencx-in-functioncx\n\nUse CodegenCx in FunctionCx", "tree": {"sha": "d8e7759b686e847f0781bd950d1ea4ab2c6b478e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8e7759b686e847f0781bd950d1ea4ab2c6b478e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4e703af1885eacd775b347b69388a5957487ede", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQVTeCRBK7hj4Ov3rIwAAdHIIADiJIQezXtsQP8IihwQuF7m+\nnXnIDFtbVEMSY2QFKTPgFunCrcfzGf/18uD28FJ05CPqtB+OVtntvD4MFus/txVq\n1K5d6EpIoQBCEg0M5DnXdVBiQmymWtZmmLz79ClUZidnA6mOwIiaFSR+zv8M1KkM\nLCHj2mMajQZfTGBpuV0076lD0+CTGQmpCk+aa2g+lZTZGv7JlOMVhNPpc63AQt4h\n98axHs0jKFZ2sKNTkF3gt4dKNNuEKBSDRZE36Ycodlj3PdjTLfXUOLIFS+Oj2uZL\nevla7fqhSm8A19sGD82LZFuWq02TJcipX5PY8Aw/TI91d1QZui/jmx9tcu52TOs=\n=MiEU\n-----END PGP SIGNATURE-----\n", "payload": "tree d8e7759b686e847f0781bd950d1ea4ab2c6b478e\nparent 42c41740d4a607ba336d72c0beb7c8ab4667959e\nparent 7b994595da74e1855a58395da4ad2f7a169c8f34\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1598117086 +0200\ncommitter GitHub <noreply@github.com> 1598117086 +0200\n\nMerge pull request #1076 from CohenArthur/use-codegencx-in-functioncx\n\nUse CodegenCx in FunctionCx"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e703af1885eacd775b347b69388a5957487ede", "html_url": "https://github.com/rust-lang/rust/commit/a4e703af1885eacd775b347b69388a5957487ede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4e703af1885eacd775b347b69388a5957487ede/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c41740d4a607ba336d72c0beb7c8ab4667959e", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c41740d4a607ba336d72c0beb7c8ab4667959e", "html_url": "https://github.com/rust-lang/rust/commit/42c41740d4a607ba336d72c0beb7c8ab4667959e"}, {"sha": "7b994595da74e1855a58395da4ad2f7a169c8f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b994595da74e1855a58395da4ad2f7a169c8f34", "html_url": "https://github.com/rust-lang/rust/commit/7b994595da74e1855a58395da4ad2f7a169c8f34"}], "stats": {"total": 150, "additions": 74, "deletions": 76}, "files": [{"sha": "6007c83787f4b3f7d53f4117df831440ca60eaa0", "filename": "src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -226,9 +226,9 @@ pub(crate) fn import_function<'tcx>(\n impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, self.module, inst);\n+        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n         let func_ref = self\n-            .module\n+            .cx.module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n@@ -250,11 +250,11 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n-            .module\n+            .cx.module\n             .declare_function(&name, Linkage::Import, &sig)\n             .unwrap();\n         let func_ref = self\n-            .module\n+            .cx.module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]"}, {"sha": "2cacef77d173351f71b781bdb3752b36bb6ba6be", "filename": "src/atomic_shim.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -81,51 +81,51 @@ pub(crate) fn init_global_lock_constructor(\n }\n \n pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fx.module.declare_data(\n+    let atomic_mutex = fx.cx.module.declare_data(\n         \"__cg_clif_global_atomic_mutex\",\n         Linkage::Import,\n         true,\n         false,\n         None,\n     ).unwrap();\n \n-    let pthread_mutex_lock = fx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fx.module.target_config().default_call_conv,\n+    let pthread_mutex_lock = fx.cx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.cx.module.target_config().default_call_conv,\n         params: vec![\n-            AbiParam::new(fx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+            AbiParam::new(fx.cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n         ],\n         returns: vec![AbiParam::new(types::I32 /* c_int */)],\n     }).unwrap();\n \n-    let pthread_mutex_lock = fx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n+    let pthread_mutex_lock = fx.cx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n \n-    let atomic_mutex = fx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n }\n \n pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fx.module.declare_data(\n+    let atomic_mutex = fx.cx.module.declare_data(\n         \"__cg_clif_global_atomic_mutex\",\n         Linkage::Import,\n         true,\n         false,\n         None,\n     ).unwrap();\n \n-    let pthread_mutex_unlock = fx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fx.module.target_config().default_call_conv,\n+    let pthread_mutex_unlock = fx.cx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.cx.module.target_config().default_call_conv,\n         params: vec![\n-            AbiParam::new(fx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+            AbiParam::new(fx.cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n         ],\n         returns: vec![AbiParam::new(types::I32 /* c_int */)],\n     }).unwrap();\n \n-    let pthread_mutex_unlock = fx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n+    let pthread_mutex_unlock = fx.cx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n \n-    let atomic_mutex = fx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n }"}, {"sha": "42068dde05d951fc6bedd820b817f2080f314d22", "filename": "src/base.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -16,14 +16,16 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let (name, sig) = get_function_name_and_sig(tcx, cx.module.isa().triple(), instance, false);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n \n-    // Make FunctionBuilder\n-    let context = &mut cx.cached_context;\n-    context.clear();\n-    context.func.name = ExternalName::user(0, func_id.as_u32());\n-    context.func.signature = sig;\n-    context.func.collect_debug_info();\n+    cx.cached_context.clear();\n+\n+    // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut bcx = FunctionBuilder::new(&mut context.func, &mut func_ctx);\n+    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    func.name = ExternalName::user(0, func_id.as_u32());\n+    func.signature = sig;\n+    func.collect_debug_info();\n+\n+    let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n@@ -34,9 +36,8 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n+        cx,\n         tcx,\n-        module: &mut cx.module,\n-        global_asm: &mut cx.global_asm,\n         pointer_type,\n \n         instance,\n@@ -49,8 +50,6 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n         cold_blocks: EntitySet::new(),\n \n         clif_comments,\n-        constants_cx: &mut cx.constants_cx,\n-        vtables: &mut cx.vtables,\n         source_info_set: indexmap::IndexSet::new(),\n         next_ssa_var: 0,\n \n@@ -77,8 +76,12 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let local_map = fx.local_map;\n     let cold_blocks = fx.cold_blocks;\n \n+    // Store function in context\n+    let context = &mut cx.cached_context;\n+    context.func = func;\n+\n     crate::pretty_clif::write_clif_file(\n-        cx.tcx,\n+        tcx,\n         \"unopt\",\n         None,\n         instance,\n@@ -113,7 +116,7 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n \n     // Write optimized function to file for debugging\n     crate::pretty_clif::write_clif_file(\n-        cx.tcx,\n+        tcx,\n         \"opt\",\n         Some(cx.module.isa()),\n         instance,"}, {"sha": "c8062e493ddb91ce9b5c439176daa70de80ae564", "filename": "src/common.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -265,10 +265,8 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'clif, 'tcx, B: Backend + 'static> {\n-    // FIXME use a reference to `CodegenCx` instead of `tcx`, `module` and `constants` and `caches`\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, B>,\n     pub(crate) tcx: TyCtxt<'tcx>,\n-    pub(crate) module: &'clif mut Module<B>,\n-    pub(crate) global_asm: &'clif mut String,\n     pub(crate) pointer_type: Type, // Cached from module\n \n     pub(crate) instance: Instance<'tcx>,\n@@ -285,9 +283,6 @@ pub(crate) struct FunctionCx<'clif, 'tcx, B: Backend + 'static> {\n     pub(crate) cold_blocks: EntitySet<Block>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) constants_cx: &'clif mut crate::constant::ConstantCx,\n-    pub(crate) vtables: &'clif mut FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n-\n     pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n@@ -398,7 +393,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.module.isa().triple()\n+        self.cx.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -411,7 +406,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .module\n+            .cx.module\n             .declare_data(\n                 &format!(\"__{}_{:08x}\", prefix, msg_hash),\n                 Linkage::Local,\n@@ -422,9 +417,9 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = self.module.define_data(msg_id, &data_ctx);\n+        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = self.module.declare_data_in_func(msg_id, self.bcx.func);\n+        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n         #[cfg(debug_assertions)]\n         {\n             self.add_comment(local_msg_id, msg);"}, {"sha": "8b0d3b913cb013f7c5000ad682f700bcf6818943", "filename": "src/constant.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -67,8 +67,8 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n@@ -80,8 +80,8 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n@@ -167,22 +167,22 @@ pub(crate) fn trans_const_value<'tcx>(\n                     let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            fx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(fx.module, ptr.alloc_id, alloc.align, alloc.mutability);\n-                            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(&mut fx.cx.module, ptr.alloc_id, alloc.align, alloc.mutability);\n+                            let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n-                            let local_func_id = fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                            let func_id = crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                            let local_func_id = fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-                            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n@@ -216,10 +216,10 @@ fn pointer_for_allocation<'tcx>(\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n-    fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align, alloc.mutability);\n+    fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n+    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.align, alloc.mutability);\n \n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);"}, {"sha": "96cfa3edbe08ba11fb8296d2332c253d77422f17", "filename": "src/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -85,7 +85,7 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n                 }\n             });\n \n-            cx.tcx.sess.time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n+            tcx.sess.time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n         }\n         MonoItem::Static(def_id) => {\n             crate::constant::codegen_static(&mut cx.constants_cx, def_id);"}, {"sha": "d1783d621e55bc6e1dd0a9b6e19af1e9ae845930", "filename": "src/inline_asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let asm_name = format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(&asm_name, InlineAsmArch::X86_64, options, template, clobbered_regs, &inputs, &outputs);\n-    fx.global_asm.push_str(&generated_asm);\n+    fx.cx.global_asm.push_str(&generated_asm);\n \n     call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n }\n@@ -169,12 +169,12 @@ fn call_inline_asm<'tcx>(\n     #[cfg(debug_assertions)]\n     fx.add_comment(stack_slot, \"inline asm scratch slot\");\n \n-    let inline_asm_func = fx.module.declare_function(asm_name, Linkage::Import, &Signature {\n+    let inline_asm_func = fx.cx.module.declare_function(asm_name, Linkage::Import, &Signature {\n         call_conv: CallConv::SystemV,\n         params: vec![AbiParam::new(fx.pointer_type)],\n         returns: vec![],\n     }).unwrap();\n-    let inline_asm_func = fx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n "}, {"sha": "b0d5988a6e433b242d9308e057760c06f9607bac", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -494,10 +494,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -513,10 +513,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         discriminant_value, (c ptr) {\n@@ -680,7 +680,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg."}, {"sha": "05be1d1706b7d6137635927594e766e97aa6ccce", "filename": "src/trap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -2,7 +2,7 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: &str) {\n     let puts = fx\n-        .module\n+        .cx.module\n         .declare_function(\n             \"puts\",\n             Linkage::Import,\n@@ -13,7 +13,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n             },\n         )\n         .unwrap();\n-    let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     {\n         fx.add_comment(puts, \"puts\");"}, {"sha": "4b03860c17a9d168128c3adc5b863a8b16334233", "filename": "src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -595,7 +595,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.module.target_config(),\n+                    fx.cx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,"}, {"sha": "686d23c5d4be7fde2a11f1d80d80914f866af493", "filename": "src/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4e703af1885eacd775b347b69388a5957487ede/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e703af1885eacd775b347b69388a5957487ede/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=a4e703af1885eacd775b347b69388a5957487ede", "patch": "@@ -72,15 +72,15 @@ pub(crate) fn get_vtable<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n+    let data_id = if let Some(data_id) = fx.cx.vtables.get(&(layout.ty, trait_ref)) {\n         *data_id\n     } else {\n         let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.vtables.insert((layout.ty, trait_ref), data_id);\n+        fx.cx.vtables.insert((layout.ty, trait_ref), data_id);\n         data_id\n     };\n \n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -93,7 +93,7 @@ fn build_vtable<'tcx>(\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n \n     let drop_in_place_fn =\n-        import_function(tcx, fx.module, Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx));\n+        import_function(tcx, &mut fx.cx.module, Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx));\n \n     let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n \n@@ -108,7 +108,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map_or(None, |(def_id, substs)| {\n             Some(import_function(\n                 tcx,\n-                fx.module,\n+                &mut fx.cx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs).unwrap().polymorphize(fx.tcx),\n             ))\n         })\n@@ -127,13 +127,13 @@ fn build_vtable<'tcx>(\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     let data_id = fx\n-        .module\n+        .cx.module\n         .declare_data(\n             &format!(\n                 \"__vtable.{}.for.{:?}.{}\",\n@@ -142,7 +142,7 @@ fn build_vtable<'tcx>(\n                     .map(|trait_ref| format!(\"{:?}\", trait_ref.skip_binder()).into())\n                     .unwrap_or(std::borrow::Cow::Borrowed(\"???\")),\n                 layout.ty,\n-                fx.vtables.len(),\n+                fx.cx.vtables.len(),\n             ),\n             Linkage::Local,\n             false,\n@@ -159,7 +159,7 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fx.module.define_data(data_id, &data_ctx).unwrap();\n+    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}]}