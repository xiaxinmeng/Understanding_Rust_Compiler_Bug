{"sha": "80b381e041d12259f24b1282e10e0a224bc6ec0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYjM4MWUwNDFkMTIyNTlmMjRiMTI4MmUxMGUwYTIyNGJjNmVjMGU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-27T00:43:03Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:21:24Z"}, "message": "Remove all traces of lifetimes() and types() methods", "tree": {"sha": "8adbe6cac76a8c202210e0cf432ef027b17b0969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8adbe6cac76a8c202210e0cf432ef027b17b0969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80b381e041d12259f24b1282e10e0a224bc6ec0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80b381e041d12259f24b1282e10e0a224bc6ec0e", "html_url": "https://github.com/rust-lang/rust/commit/80b381e041d12259f24b1282e10e0a224bc6ec0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80b381e041d12259f24b1282e10e0a224bc6ec0e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10229fd9d5701179e2148a1d4bbfda0062a2225f", "url": "https://api.github.com/repos/rust-lang/rust/commits/10229fd9d5701179e2148a1d4bbfda0062a2225f", "html_url": "https://github.com/rust-lang/rust/commit/10229fd9d5701179e2148a1d4bbfda0062a2225f"}], "stats": {"total": 765, "additions": 419, "deletions": 346}, "files": [{"sha": "1c62e5813ff361a407940040b0f4abcef2a9ef6b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -1731,7 +1731,11 @@ impl<'a> LoweringContext<'a> {\n             self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n         };\n \n-        if !generic_args.parenthesized && generic_args.lifetimes().count() == 0 {\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        if !generic_args.parenthesized && !has_lifetimes {\n             generic_args.args =\n                 self.elided_path_lifetimes(path_span, expected_lifetimes)\n                     .into_iter()\n@@ -1763,7 +1767,7 @@ impl<'a> LoweringContext<'a> {\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx)).collect(),\n             parenthesized: false,\n         },\n-        has_types && param_mode == ParamMode::Optional)\n+        !has_types && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data("}, {"sha": "bb830a042e3917a5707371cc3d370748abccf4ea", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -400,34 +400,20 @@ impl GenericArgs {\n \n     pub fn inputs(&self) -> &[P<Ty>] {\n         if self.parenthesized {\n-            if let Some(ref ty) = self.types().next() {\n-                if let TyTup(ref tys) = ty.node {\n-                    return tys;\n+            for arg in &self.args {\n+                match arg {\n+                    GenericArg::Lifetime(_) => {}\n+                    GenericArg::Type(ref ty) => {\n+                        if let TyTup(ref tys) = ty.node {\n+                            return tys;\n+                        }\n+                        break;\n+                    }\n                 }\n             }\n         }\n         bug!(\"GenericArgs::inputs: not a `Fn(T) -> U`\");\n     }\n-\n-    pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &Lifetime> {\n-        self.args.iter().filter_map(|p| {\n-            if let GenericArg::Lifetime(lt) = p {\n-                Some(lt)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    pub fn types(&self) -> impl DoubleEndedIterator<Item = &P<Ty>> {\n-        self.args.iter().filter_map(|p| {\n-            if let GenericArg::Type(ty) = p {\n-                Some(ty)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n }\n \n /// The AST represents all type param bounds as types."}, {"sha": "dc5d9749227dcf6146c0a0feabeb75e10062d0ca", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -1731,20 +1731,31 @@ impl<'a> State<'a> {\n                 }\n             };\n \n-            let elide_lifetimes = generic_args.lifetimes().all(|lt| lt.is_elided());\n+            let mut types = vec![];\n+            let mut elide_lifetimes = true;\n+            for arg in &generic_args.args {\n+                match arg {\n+                    GenericArg::Lifetime(lt) => {\n+                        if !lt.is_elided() {\n+                            elide_lifetimes = false;\n+                        }\n+                    }\n+                    GenericArg::Type(ty) => {\n+                        types.push(ty);\n+                    }\n+                }\n+            }\n             if !elide_lifetimes {\n                 start_or_comma(self)?;\n                 self.commasep(Inconsistent, &generic_args.args, |s, generic_arg| {\n                     match generic_arg {\n                         GenericArg::Lifetime(lt) => s.print_lifetime(lt),\n                         GenericArg::Type(ty) => s.print_type(ty),\n-                }\n+                    }\n                 })?;\n-            } else if generic_args.types().count() != 0 {\n+            } else if !types.is_empty() {\n                 start_or_comma(self)?;\n-                self.commasep(Inconsistent,\n-                              &generic_args.types().collect::<Vec<_>>(),\n-                              |s, ty| s.print_type(&ty))?;\n+                self.commasep(Inconsistent, &types, |s, ty| s.print_type(&ty))?;\n             }\n \n             // FIXME(eddyb) This would leak into error messages, e.g.:"}, {"sha": "358df3a1733c9519c17f2da4029e298fd9c36e3a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 155, "deletions": 162, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -18,8 +18,7 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::ItemLocalId;\n-use hir::LifetimeName;\n+use hir::{GenericArg, ItemLocalId, LifetimeName};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n@@ -533,15 +532,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     0\n                 };\n                 let mut type_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } => {\n-                            type_count += 1;\n-                            None\n-                        }\n+                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        type_count += 1;\n+                        None\n                     }\n                 }).collect();\n                 let scope = Scope::Binder {\n@@ -585,13 +582,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes: c.generic_params\n                                 .iter()\n-                                .filter_map(|param| {\n-                                    match param.kind {\n-                                        GenericParamKind::Lifetime { .. } => {\n-                                            Some(Region::late(&self.tcx.hir, param))\n-                                        }\n-                                        _ => None,\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => {\n+                                        Some(Region::late(&self.tcx.hir, param))\n                                     }\n+                                    _ => None,\n                                 })\n                                 .collect(),\n                     s: self.scope,\n@@ -777,15 +772,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut type_count = 0;\n                 let lifetimes = generics.params\n                     .iter()\n-                    .filter_map(|param| {\n-                        match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::early(&self.tcx.hir, &mut index, param))\n-                            }\n-                            GenericParamKind::Type { .. } => {\n-                                type_count += 1;\n-                                None\n-                            }\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                            None\n                         }\n                     })\n                     .collect();\n@@ -834,15 +827,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 debug!(\"visit_ty: index = {}\", index);\n                 let lifetimes = generics.params\n                     .iter()\n-                    .filter_map(|param| {\n-                        match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::early(&self.tcx.hir, &mut index, param))\n-                            }\n-                            GenericParamKind::Type { .. } => {\n-                                next_early_index += 1;\n-                                None\n-                            }\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n                         }\n                     })\n                     .collect();\n@@ -899,11 +890,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         check_mixed_explicit_and_in_band_defs(\n             self.tcx,\n-            &generics.params.iter().filter_map(|param| {\n-                match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param.clone()),\n-                    _ => None,\n-                }\n+            &generics.params.iter().filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(param.clone()),\n+                _ => None,\n             }).collect::<Vec<_>>()\n         );\n         for param in &generics.params {\n@@ -926,13 +915,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ..\n                 }) => {\n                     let lifetimes: FxHashMap<_, _> = bound_generic_params.iter()\n-                        .filter_map(|param| {\n-                            match param.kind {\n-                                GenericParamKind::Lifetime { .. } => {\n-                                    Some(Region::late(&self.tcx.hir, param))\n-                                }\n-                                _ => None,\n+                        .filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::late(&self.tcx.hir, param))\n                             }\n+                            _ => None,\n                         })\n                         .collect();\n                     if !lifetimes.is_empty() {\n@@ -990,11 +977,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             || trait_ref\n                 .bound_generic_params\n                 .iter()\n-                .any(|param| {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => true,\n-                        _ => false,\n-                    }\n+                .any(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => true,\n+                    _ => false,\n                 })\n         {\n             if self.trait_ref_hack {\n@@ -1010,13 +995,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 lifetimes: trait_ref\n                     .bound_generic_params\n                     .iter()\n-                    .filter_map(|param| {\n-                        match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir, param))\n-                            }\n-                            _ => None,\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::late(&self.tcx.hir, param))\n                         }\n+                        _ => None,\n                     })\n                     .collect(),\n                 s: self.scope,\n@@ -1087,11 +1070,9 @@ fn check_mixed_explicit_and_in_band_defs(\n     tcx: TyCtxt<'_, '_, '_>,\n     params: &[hir::GenericParam],\n ) {\n-    let in_bands: Vec<_> = params.iter().map(|param| {\n-        match param.kind {\n-            GenericParamKind::Lifetime { in_band, .. } => (in_band, param.span),\n-            _ => bug!(\"expected lifetime param\"),\n-        }\n+    let in_bands: Vec<_> = params.iter().map(|param| match param.kind {\n+        GenericParamKind::Lifetime { in_band, .. } => (in_band, param.span),\n+        _ => bug!(\"expected lifetime param\"),\n     }).collect();\n     let out_of_band = in_bands.iter().find(|(in_band, _)| !in_band);\n     let in_band = in_bands.iter().find(|(in_band, _)| *in_band);\n@@ -1262,18 +1243,16 @@ fn compute_object_lifetime_defaults(\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n                             Set1::One(Region::EarlyBound(i, _, _)) => {\n                                 let mut j = 0;\n-                                generics.params.iter().find(|param| {\n-                                    match param.kind {\n+                                generics.params.iter().find(|param| match param.kind {\n                                         GenericParamKind::Lifetime { .. } => {\n                                             if i == j {\n                                                 return true;\n                                             }\n                                             j += 1;\n+                                            false\n                                         }\n-                                        _ => {}\n-                                    }\n-                                    false\n-                                }).unwrap()\n+                                        _ => false,\n+                                    }).unwrap()\n                                   .name()\n                                   .to_string()\n                             }\n@@ -1308,64 +1287,60 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics.params.iter().filter_map(|param| {\n-        match param.kind {\n-            GenericParamKind::Lifetime { .. } => None,\n-            GenericParamKind::Type { ref bounds, .. } => {\n-                let mut set = Set1::Empty;\n-\n-                add_bounds(&mut set, &bounds);\n-\n-                let param_def_id = tcx.hir.local_def_id(param.id);\n-                for predicate in &generics.where_clause.predicates {\n-                    // Look for `type: ...` where clauses.\n-                    let data = match *predicate {\n-                        hir::WherePredicate::BoundPredicate(ref data) => data,\n-                        _ => continue,\n-                    };\n+    generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Lifetime { .. } => None,\n+        GenericParamKind::Type { ref bounds, .. } => {\n+            let mut set = Set1::Empty;\n \n-                    // Ignore `for<'a> type: ...` as they can change what\n-                    // lifetimes mean (although we could \"just\" handle it).\n-                    if !data.bound_generic_params.is_empty() {\n-                        continue;\n-                    }\n+            add_bounds(&mut set, &bounds);\n \n-                    let def = match data.bounded_ty.node {\n-                        hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n-                        _ => continue,\n-                    };\n+            let param_def_id = tcx.hir.local_def_id(param.id);\n+            for predicate in &generics.where_clause.predicates {\n+                // Look for `type: ...` where clauses.\n+                let data = match *predicate {\n+                    hir::WherePredicate::BoundPredicate(ref data) => data,\n+                    _ => continue,\n+                };\n \n-                    if def == Def::TyParam(param_def_id) {\n-                        add_bounds(&mut set, &data.bounds);\n-                    }\n+                // Ignore `for<'a> type: ...` as they can change what\n+                // lifetimes mean (although we could \"just\" handle it).\n+                if !data.bound_generic_params.is_empty() {\n+                    continue;\n                 }\n \n-                Some(match set {\n-                    Set1::Empty => Set1::Empty,\n-                    Set1::One(name) => {\n-                        if name == hir::LifetimeName::Static {\n-                            Set1::One(Region::Static)\n-                        } else {\n-                            generics.params.iter().filter_map(|param| {\n-                                match param.kind {\n-                                    GenericParamKind::Lifetime { name, in_band, .. } => {\n-                                       Some((param.id, name, in_band))\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .enumerate()\n-                            .find(|&(_, (_, lt_name, _))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (id, _, in_band))| {\n-                                let def_id = tcx.hir.local_def_id(id);\n-                                let origin = LifetimeDefOrigin::from_is_in_band(in_band);\n-                                Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                            })\n-                        }\n-                    }\n-                    Set1::Many => Set1::Many,\n-                })\n+                let def = match data.bounded_ty.node {\n+                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    _ => continue,\n+                };\n+\n+                if def == Def::TyParam(param_def_id) {\n+                    add_bounds(&mut set, &data.bounds);\n+                }\n             }\n+\n+            Some(match set {\n+                Set1::Empty => Set1::Empty,\n+                Set1::One(name) => {\n+                    if name == hir::LifetimeName::Static {\n+                        Set1::One(Region::Static)\n+                    } else {\n+                        generics.params.iter().filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { name, in_band, .. } => {\n+                                Some((param.id, name, in_band))\n+                            }\n+                            _ => None,\n+                        })\n+                        .enumerate()\n+                        .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                        .map_or(Set1::Many, |(i, (id, _, in_band))| {\n+                            let def_id = tcx.hir.local_def_id(id);\n+                            let origin = LifetimeDefOrigin::from_is_in_band(in_band);\n+                            Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                        })\n+                    }\n+                }\n+                Set1::Many => Set1::Many,\n+            })\n         }\n     })\n     .collect()\n@@ -1541,20 +1516,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         let mut type_count = 0;\n-        let lifetimes = generics.params.iter().filter_map(|param| {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if self.map.late_bound.contains(&param.id) {\n-                        Some(Region::late(&self.tcx.hir, param))\n-                    } else {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                }\n-                GenericParamKind::Type { .. } => {\n-                    type_count += 1;\n-                    None\n+        let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                if self.map.late_bound.contains(&param.id) {\n+                    Some(Region::late(&self.tcx.hir, param))\n+                } else {\n+                    Some(Region::early(&self.tcx.hir, &mut index, param))\n                 }\n             }\n+            GenericParamKind::Type { .. } => {\n+                type_count += 1;\n+                None\n+            }\n         }).collect();\n         let next_early_index = index + type_count;\n \n@@ -1721,11 +1694,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             return;\n         }\n \n-        if generic_args.lifetimes().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(generic_args.lifetimes().collect(), true);\n+        let mut elide_lifetimes = true;\n+        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+            hir::GenericArg::Lifetime(lt) => {\n+                if !lt.is_elided() {\n+                    elide_lifetimes = false;\n+                }\n+                Some(lt)\n+            }\n+            _ => None,\n+        }).collect();\n+        if elide_lifetimes {\n+            self.resolve_elided_lifetimes(lifetimes, true);\n         } else {\n-            for l in generic_args.lifetimes() {\n-                self.visit_lifetime(l);\n+            for lt in lifetimes {\n+                self.visit_lifetime(lt);\n             }\n         }\n \n@@ -1788,29 +1771,41 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }).collect()\n                     })\n             };\n-            unsubst\n-                .iter()\n-                .map(|set| match *set {\n-                    Set1::Empty => if in_body {\n-                        None\n-                    } else {\n-                        Some(Region::Static)\n-                    },\n-                    Set1::One(r) => r.subst(generic_args.lifetimes(), map),\n-                    Set1::Many => None,\n-                })\n-                .collect()\n+            unsubst.iter()\n+                   .map(|set| match *set {\n+                       Set1::Empty => if in_body {\n+                           None\n+                       } else {\n+                           Some(Region::Static)\n+                       },\n+                       Set1::One(r) => {\n+                           let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+                               GenericArg::Lifetime(lt) => Some(lt),\n+                               _ => None,\n+                           });\n+                           r.subst(lifetimes, map)\n+                       }\n+                       Set1::Many => None,\n+                   })\n+                   .collect()\n         });\n \n-        for (i, ty) in generic_args.types().enumerate() {\n-            if let Some(&lt) = object_lifetime_defaults.get(i) {\n-                let scope = Scope::ObjectLifetimeDefault {\n-                    lifetime: lt,\n-                    s: self.scope,\n-                };\n-                self.with(scope, |_, this| this.visit_ty(ty));\n-            } else {\n-                self.visit_ty(ty);\n+        let mut i = 0;\n+        for arg in &generic_args.args {\n+            match arg {\n+                GenericArg::Lifetime(_) => {}\n+                GenericArg::Type(ty) => {\n+                    if let Some(&lt) = object_lifetime_defaults.get(i) {\n+                        let scope = Scope::ObjectLifetimeDefault {\n+                            lifetime: lt,\n+                            s: self.scope,\n+                        };\n+                        self.with(scope, |_, this| this.visit_ty(ty));\n+                    } else {\n+                        self.visit_ty(ty);\n+                    }\n+                    i += 1;\n+                }\n             }\n         }\n \n@@ -2269,11 +2264,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_params(&mut self, old_scope: ScopeRef, params: &'tcx [hir::GenericParam]) {\n-        let lifetimes: Vec<_> = params.iter().filter_map(|param| {\n-            match param.kind {\n-                GenericParamKind::Lifetime { name, .. } => Some((param, name)),\n-                _ => None,\n-            }\n+        let lifetimes: Vec<_> = params.iter().filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { name, .. } => Some((param, name)),\n+            _ => None,\n         }).collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             match lifetime_i_name {"}, {"sha": "f48739799203fb9c41453c7a2f7592f42daf72a6", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -224,11 +224,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let names_map: FxHashSet<String> = generics\n                 .params\n                 .iter()\n-                .filter_map(|param| {\n-                    match param.kind {\n-                        ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                        _ => None\n-                    }\n+                .filter_map(|param| match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n+                    _ => None\n                 })\n                 .collect();\n "}, {"sha": "bd19a575c798e17dc66200688c0071f858d7881a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -336,13 +336,11 @@ impl PrintContext {\n \n             if !verbose {\n                 let mut type_params =\n-                    generics.params.iter().rev().filter_map(|param| {\n-                        match param.kind {\n-                            GenericParamDefKind::Type { has_default, .. } => {\n-                                Some((param.def_id, has_default))\n-                            }\n-                            GenericParamDefKind::Lifetime => None,\n+                    generics.params.iter().rev().filter_map(|param| match param.kind {\n+                        GenericParamDefKind::Type { has_default, .. } => {\n+                            Some((param.def_id, has_default))\n                         }\n+                        GenericParamDefKind::Lifetime => None,\n                     }).peekable();\n                 let has_default = {\n                     let has_default = type_params.peek().map(|(_, has_default)| has_default);"}, {"sha": "e105c9cd3c2d8ca71039f221d8117dd248fd4fa9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -1236,12 +1236,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                    let has_types = generics.params.iter().find(|param| {\n-                        match param.kind {\n-                            hir::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        }\n-                    }).is_some();\n+                    let has_types = generics.params.iter().any(|param| match param.kind {\n+                        hir::GenericParamKind::Type { .. } => true,\n+                        _ => false,\n+                    });\n                     let needs_inline =\n                         (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();"}, {"sha": "32c0dbbea69354a35efc7a1b234e83d5ce3d46e6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -13,7 +13,7 @@\n //! is parameterized by an instance of `AstConv`.\n \n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use hir;\n+use hir::{self, GenericArg};\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n@@ -213,10 +213,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = tcx.generics_of(def_id);\n-        let ty_provided = generic_args.types().count();\n-        let lt_provided = generic_args.lifetimes().count();\n+        let mut lt_provided = 0;\n+        let mut ty_provided = 0;\n+        for arg in &generic_args.args {\n+            match arg {\n+                GenericArg::Lifetime(_) => lt_provided += 1,\n+                GenericArg::Type(_) => ty_provided += 1,\n+            }\n+        }\n \n+        let decl_generics = tcx.generics_of(def_id);\n         let mut lt_accepted = 0;\n         let mut ty_params = ParamRange { required: 0, accepted: 0 };\n         for param in &decl_generics.params {\n@@ -269,11 +275,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n                     let i = param.index as usize - own_self;\n-                    if let Some(lifetime) = generic_args.lifetimes().nth(i) {\n-                        self.ast_region_to_region(lifetime, Some(param)).into()\n-                    } else {\n-                        tcx.types.re_static.into()\n+                    let mut j = 0;\n+                    for arg in &generic_args.args {\n+                        match arg {\n+                            GenericArg::Lifetime(lt) => {\n+                                if i == j {\n+                                    return self.ast_region_to_region(lt, Some(param)).into();\n+                                }\n+                                j += 1;\n+                            }\n+                            _ => {}\n+                        }\n                     }\n+                    tcx.types.re_static.into()\n                 }\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     let i = param.index as usize;\n@@ -286,7 +300,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let i = i - (lt_accepted + own_self);\n                     if i < ty_provided {\n                         // A provided type parameter.\n-                        self.ast_ty_to_ty(&generic_args.types().nth(i).unwrap()).into()\n+                        let mut j = 0;\n+                        for arg in &generic_args.args {\n+                            match arg {\n+                                GenericArg::Type(ty) => {\n+                                    if i == j {\n+                                        return self.ast_ty_to_ty(ty).into();\n+                                    }\n+                                    j += 1;\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                        bug!()\n                     } else if infer_types {\n                         // No type parameters were provided, we can infer all.\n                         if !default_needs_object_self(param) {"}, {"sha": "8a64e4a5367852b3ade3fe9fb7aad23617347d02", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -728,11 +728,9 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut error_found = false;\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| {\n-        match param.kind {\n-            GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n-            GenericParamDefKind::Lifetime => None,\n-        }\n+    let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n+        GenericParamDefKind::Lifetime => None,\n     });\n     let trait_m_type_params = trait_m_generics.params.iter().filter_map(|param| {\n         match param.kind {"}, {"sha": "4cf05a4891b397df2748484428677953128182af", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -12,6 +12,7 @@ use super::{probe, MethodCallee};\n \n use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n+use hir::GenericArg;\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -330,16 +331,40 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             } else {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        if let Some(lifetime) = provided.as_ref().and_then(|p| {\n-                            p.lifetimes().nth(i - parent_substs.len())\n+                        if let Some(lifetime) = provided.as_ref().and_then(|data| {\n+                            let mut j = 0;\n+                            for arg in &data.args {\n+                                match arg {\n+                                    GenericArg::Lifetime(lt) => {\n+                                        if i - parent_substs.len() == j {\n+                                            return Some(lt);\n+                                        }\n+                                        j += 1;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None\n                         }) {\n                             return AstConv::ast_region_to_region(\n                                 self.fcx, lifetime, Some(param)).into();\n                         }\n                     }\n                     GenericParamDefKind::Type {..} => {\n-                        if let Some(ast_ty) = provided.as_ref().and_then(|p| {\n-                            p.types().nth(i - parent_substs.len() - own_counts.lifetimes)\n+                        if let Some(ast_ty) = provided.as_ref().and_then(|data| {\n+                            let mut j = 0;\n+                            for arg in &data.args {\n+                                match arg {\n+                                    GenericArg::Type(ty) => {\n+                                        if i - parent_substs.len() - own_counts.lifetimes == j {\n+                                            return Some(ty);\n+                                        }\n+                                        j += 1;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None\n                         }) {\n                             return self.to_ty(ast_ty).into();\n                         }"}, {"sha": "4b731d5b883b1fc54dade1d0fd675e2e2b1023b0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -85,6 +85,7 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n+use hir::GenericArg;\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n@@ -4834,7 +4835,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n                     let lifetimes = segment.map_or(vec![], |(s, _)| {\n-                        s.args.as_ref().map_or(vec![], |arg| arg.lifetimes().collect())\n+                        s.args.as_ref().map_or(vec![], |data| {\n+                            data.args.iter().filter_map(|arg| match arg {\n+                                GenericArg::Lifetime(lt) => Some(lt),\n+                                _ => None,\n+                            }).collect()\n+                        })\n                     });\n \n                     if let Some(lifetime) = lifetimes.get(i) {\n@@ -4845,8 +4851,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 GenericParamDefKind::Type {..} => {\n                     let (types, infer_types) = segment.map_or((vec![], true), |(s, _)| {\n-                        (s.args.as_ref().map_or(vec![], |arg| {\n-                            arg.types().collect()\n+                        (s.args.as_ref().map_or(vec![], |data| {\n+                            data.args.iter().filter_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                _ => None,\n+                            }).collect()\n                         }), s.infer_types)\n                     });\n \n@@ -4967,11 +4976,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |(s, _)| {\n                 s.args.as_ref().map_or(\n                     (vec![], vec![], s.infer_types, &[][..]),\n-                    |arg| {\n-                        (arg.lifetimes().collect(),\n-                         arg.types().collect(),\n-                         s.infer_types,\n-                         &arg.bindings[..])\n+                    |data| {\n+                        let mut lifetimes = vec![];\n+                        let mut types = vec![];\n+                        for arg in &data.args {\n+                            match arg {\n+                                GenericArg::Lifetime(lt) => lifetimes.push(lt),\n+                                GenericArg::Type(ty) => types.push(ty),\n+                            }\n+                        }\n+                        (lifetimes, types, s.infer_types, &data.bindings[..])\n                     }\n                 )\n             });\n@@ -5097,13 +5111,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         -> bool {\n         let segment = segment.map(|(path_segment, generics)| {\n             let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.params.iter().any(|param| {\n-                match param.kind {\n-                    ty::GenericParamDefKind::Type {\n-                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n-                    } => true,\n-                    _ => false,\n-                }\n+            let impl_trait = generics.params.iter().any(|param| match param.kind {\n+                ty::GenericParamDefKind::Type {\n+                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n+                } => true,\n+                _ => false,\n             });\n \n             if explicit && impl_trait {\n@@ -5187,11 +5199,9 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let types = generics.params.iter().filter(|param| {\n-        match param.kind {\n-            hir::GenericParamKind::Type { .. } => true,\n-            _ => false,\n-        }\n+    let types = generics.params.iter().filter(|param| match param.kind {\n+        hir::GenericParamKind::Type { .. } => true,\n+        _ => false,\n     });\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {"}, {"sha": "05d390b8dae9ee322b575dcba3b7340219af4bb0", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -662,11 +662,9 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> =\n         parent.params.iter()\n-                     .flat_map(|param| {\n-                         match param.kind {\n-                             GenericParamDefKind::Lifetime => None,\n-                             GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n-                         }\n+                     .flat_map(|param| match param.kind {\n+                         GenericParamDefKind::Lifetime => None,\n+                         GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n                      })\n                      .collect();\n "}, {"sha": "0a6edd8d0ce704fc11672e3e7da60a150bb9b78c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -315,17 +315,14 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     {\n         let from_ty_params =\n             ast_generics.params.iter()\n-                .filter_map(|param| {\n-                    match param.kind {\n-                        GenericParamKind::Type { ref bounds, .. } => {\n-                            if param.id == param_id {\n-                                Some(bounds)\n-                            } else {\n-                                None\n-                            }\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Type { ref bounds, .. } => {\n+                        if param.id == param_id {\n+                            return Some(bounds);\n                         }\n-                        _ => None\n+                        None\n                     }\n+                    _ => None\n                 })\n                 .flat_map(|bounds| bounds.iter())\n                 .flat_map(|b| predicates_from_bound(self, ty, b));\n@@ -921,42 +918,40 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Now create the real type parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n-    params.extend(ast_generics.params.iter().filter_map(|param| {\n-        match param.kind {\n-            GenericParamKind::Type { ref default, synthetic, .. } => {\n-                if param.name() == keywords::SelfType.name() {\n-                    span_bug!(param.span,\n-                              \"`Self` should not be the name of a regular parameter\");\n-                }\n+    params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Type { ref default, synthetic, .. } => {\n+            if param.name() == keywords::SelfType.name() {\n+                span_bug!(param.span,\n+                            \"`Self` should not be the name of a regular parameter\");\n+            }\n \n-                if !allow_defaults && default.is_some() {\n-                    if !tcx.features().default_type_parameter_fallback {\n-                        tcx.lint_node(\n-                            lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                            param.id,\n-                            param.span,\n-                            &format!(\"defaults for type parameters are only allowed in \\\n-                                      `struct`, `enum`, `type`, or `trait` definitions.\"));\n-                    }\n+            if !allow_defaults && default.is_some() {\n+                if !tcx.features().default_type_parameter_fallback {\n+                    tcx.lint_node(\n+                        lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                        param.id,\n+                        param.span,\n+                        &format!(\"defaults for type parameters are only allowed in \\\n+                                    `struct`, `enum`, `type`, or `trait` definitions.\"));\n                 }\n-\n-                let ty_param = ty::GenericParamDef {\n-                    index: type_start + i as u32,\n-                    name: param.name().as_interned_str(),\n-                    def_id: tcx.hir.local_def_id(param.id),\n-                    pure_wrt_drop: param.pure_wrt_drop,\n-                    kind: ty::GenericParamDefKind::Type {\n-                        has_default: default.is_some(),\n-                        object_lifetime_default:\n-                            object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n-                        synthetic,\n-                    },\n-                };\n-                i += 1;\n-                Some(ty_param)\n             }\n-            _ => None,\n+\n+            let ty_param = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name().as_interned_str(),\n+                def_id: tcx.hir.local_def_id(param.id),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind: ty::GenericParamDefKind::Type {\n+                    has_default: default.is_some(),\n+                    object_lifetime_default:\n+                        object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n+                    synthetic,\n+                },\n+            };\n+            i += 1;\n+            Some(ty_param)\n         }\n+        _ => None,\n     }));\n \n     // provide junk type parameter defs - the only place that\n@@ -1313,14 +1308,12 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     generics: &'a hir::Generics)\n     -> impl Iterator<Item=&'a hir::GenericParam> + Captures<'tcx>\n {\n-    generics.params.iter().filter(move |param| {\n-        match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                let hir_id = tcx.hir.node_to_hir_id(param.id);\n-                !tcx.is_late_bound(hir_id)\n-            }\n-            _ => false,\n+    generics.params.iter().filter(move |param| match param.kind {\n+        GenericParamKind::Lifetime { .. } => {\n+            let hir_id = tcx.hir.node_to_hir_id(param.id);\n+            !tcx.is_late_bound(hir_id)\n         }\n+        _ => false,\n     })\n }\n "}, {"sha": "a2ae7afbc83865c315bab37f519f801bd075ae62", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -36,7 +36,7 @@ use rustc::middle::resolve_lifetime as rl;\n use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n-use rustc::hir::{self, HirVec};\n+use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n@@ -1979,16 +1979,14 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.params.iter().filter_map(|param| {\n-            if let ty::GenericParamDefKind::Type {..} = param.kind {\n+        let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { .. } => {\n                 if param.name == keywords::SelfType.name().as_str() {\n                     assert_eq!(param.index, 0);\n-                    None\n-                } else {\n-                    Some(param.clean(cx))\n+                    return None;\n                 }\n-            } else {\n-                None\n+                Some(param.clean(cx))\n             }\n         }).collect::<Vec<TyParam>>();\n \n@@ -2034,12 +2032,11 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         Generics {\n             params: gens.params\n                         .iter()\n-                        .flat_map(|param| {\n-                            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                        .flat_map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => {\n                                 Some(GenericParamDef::Lifetime(param.clean(cx)))\n-                            } else {\n-                                None\n                             }\n+                            ty::GenericParamDefKind::Type { .. } => None,\n                         }).chain(\n                             simplify::ty_params(stripped_typarams)\n                                 .into_iter()\n@@ -2870,8 +2867,20 @@ impl Clean<Type> for hir::Ty {\n                         for param in generics.params.iter() {\n                             match param.kind {\n                                 hir::GenericParamKind::Lifetime { .. } => {\n-                                    if let Some(lt) = generic_args.lifetimes()\n-                                        .nth(indices.lifetimes).cloned() {\n+                                    let mut j = 0;\n+                                    let lifetime = generic_args.args.iter().find_map(|arg| {\n+                                        match arg {\n+                                            GenericArg::Lifetime(lt) => {\n+                                                if indices.lifetimes == j {\n+                                                    return Some(lt);\n+                                                }\n+                                                j += 1;\n+                                                None\n+                                            }\n+                                            _ => None,\n+                                        }\n+                                    });\n+                                    if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n                                                 cx.tcx.hir.local_def_id(param.id);\n@@ -2883,8 +2892,20 @@ impl Clean<Type> for hir::Ty {\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n                                         Def::TyParam(cx.tcx.hir.local_def_id(param.id));\n-                                    if let Some(ty) = generic_args.types()\n-                                        .nth(indices.types).cloned() {\n+                                    let mut j = 0;\n+                                    let type_ = generic_args.args.iter().find_map(|arg| {\n+                                        match arg {\n+                                            GenericArg::Type(ty) => {\n+                                                if indices.types == j {\n+                                                    return Some(ty);\n+                                                }\n+                                                j += 1;\n+                                                None\n+                                            }\n+                                            _ => None,\n+                                        }\n+                                    });\n+                                    if let Some(ty) = type_.cloned() {\n                                         ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n                                     } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def,\n@@ -3504,13 +3525,28 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n         } else {\n+            let mut lifetimes = vec![];\n+            let mut types = vec![];\n+            let mut elided_lifetimes = true;\n+            for arg in &self.args {\n+                match arg {\n+                    GenericArg::Lifetime(lt) if elided_lifetimes => {\n+                        if lt.is_elided() {\n+                            elided_lifetimes = false;\n+                            lifetimes = vec![];\n+                            continue;\n+                        }\n+                        lifetimes.push(lt.clean(cx));\n+                    }\n+                    GenericArg::Lifetime(_) => {}\n+                    GenericArg::Type(ty) => {\n+                        types.push(ty.clean(cx));\n+                    }\n+                }\n+            }\n             GenericArgs::AngleBracketed {\n-                lifetimes: if self.lifetimes().all(|lt| lt.is_elided()) {\n-                    vec![]\n-                } else {\n-                    self.lifetimes().map(|lt| lt.clean(cx)).collect()\n-                },\n-                types: self.types().map(|ty| ty.clean(cx)).collect(),\n+                lifetimes,\n+                types,\n                 bindings: self.bindings.clean(cx),\n             }\n         }"}, {"sha": "8e691049d3395101e68f0429af93a08e1585e57b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -18,6 +18,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(fs_read_write)]\n+#![feature(iterator_find_map)]\n #![feature(set_stdio)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(test)]"}, {"sha": "fc244f67bb653e8f51e9472a79011a82d70b6677", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b381e041d12259f24b1282e10e0a224bc6ec0e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=80b381e041d12259f24b1282e10e0a224bc6ec0e", "patch": "@@ -549,30 +549,28 @@ impl<'a> TraitDef<'a> {\n             .to_generics(cx, self.span, type_ident, generics);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| {\n-            match param.kind {\n-                GenericParamKindAST::Lifetime { .. } => param.clone(),\n-                GenericParamKindAST::Type { bounds: ref ty_bounds, .. } => {\n-                    // I don't think this can be moved out of the loop, since\n-                    // a TyParamBound requires an ast id\n-                    let mut bounds: Vec<_> =\n-                        // extra restrictions on the generics parameters to the\n-                        // type being derived upon\n-                        self.additional_bounds.iter().map(|p| {\n-                            cx.typarambound(p.to_path(cx, self.span,\n-                                                        type_ident, generics))\n-                        }).collect();\n-\n-                    // require the current trait\n-                    bounds.push(cx.typarambound(trait_path.clone()));\n-\n-                    // also add in any bounds from the declaration\n-                    for declared_bound in ty_bounds {\n-                        bounds.push((*declared_bound).clone());\n-                    }\n-\n-                    cx.typaram(self.span, param.ident, vec![], bounds, None)\n+        params.extend(generics.params.iter().map(|param| match param.kind {\n+            GenericParamKindAST::Lifetime { .. } => param.clone(),\n+            GenericParamKindAST::Type { bounds: ref ty_bounds, .. } => {\n+                // I don't think this can be moved out of the loop, since\n+                // a TyParamBound requires an ast id\n+                let mut bounds: Vec<_> =\n+                    // extra restrictions on the generics parameters to the\n+                    // type being derived upon\n+                    self.additional_bounds.iter().map(|p| {\n+                        cx.typarambound(p.to_path(cx, self.span,\n+                                                    type_ident, generics))\n+                    }).collect();\n+\n+                // require the current trait\n+                bounds.push(cx.typarambound(trait_path.clone()));\n+\n+                // also add in any bounds from the declaration\n+                for declared_bound in ty_bounds {\n+                    bounds.push((*declared_bound).clone());\n                 }\n+\n+                cx.typaram(self.span, param.ident, vec![], bounds, None)\n             }\n         }));\n "}]}