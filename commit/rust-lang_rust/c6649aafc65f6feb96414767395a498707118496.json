{"sha": "c6649aafc65f6feb96414767395a498707118496", "node_id": "C_kwDOAAsO6NoAKGM2NjQ5YWFmYzY1ZjZmZWI5NjQxNDc2NzM5NWE0OTg3MDcxMTg0OTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T08:15:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T08:15:47Z"}, "message": "Auto merge of #2665 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "47f9f8e45099d7e907fb1d2a649efade7cc54280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47f9f8e45099d7e907fb1d2a649efade7cc54280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6649aafc65f6feb96414767395a498707118496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6649aafc65f6feb96414767395a498707118496", "html_url": "https://github.com/rust-lang/rust/commit/c6649aafc65f6feb96414767395a498707118496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6649aafc65f6feb96414767395a498707118496/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ef0de98152024986dceb52d68f4511dfa344571", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef0de98152024986dceb52d68f4511dfa344571", "html_url": "https://github.com/rust-lang/rust/commit/9ef0de98152024986dceb52d68f4511dfa344571"}, {"sha": "8d7f257f0c31d4aee2655eb8f23d09a3154c8f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7f257f0c31d4aee2655eb8f23d09a3154c8f49", "html_url": "https://github.com/rust-lang/rust/commit/8d7f257f0c31d4aee2655eb8f23d09a3154c8f49"}], "stats": {"total": 21130, "additions": 13057, "deletions": 8073}, "files": [{"sha": "b40066d05d355ec05aef4c9c018aa56586bea2bd", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -4,3 +4,5 @@ a06baa56b95674fc626b3c3fd680d6a65357fe60\n 95e00bfed801e264e9c4ac817004153ca0f19eb6\n # reformat with new rustfmt\n 971c549ca334b7b7406e61e958efcca9c4152822\n+# refactor infcx building\n+283abbf0e7d20176f76006825b5c52e9a4234e4c"}, {"sha": "f887d29096e038fe5eab11d838095fe916dfa97c", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -217,7 +217,7 @@ Hsiang-Cheng Yang <rick68@users.noreply.github.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ian.jackson@citrix.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ijackson+github@slimy.greenend.org.uk>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <iwj@xenproject.org>\n-Ibraheem Ahmed <ibrah1440@gmail.com>\n+Ibraheem Ahmed <ibraheem@ibraheem.ca> <ibrah1440@gmail.com>\n Ilyong Cho <ilyoan@gmail.com>\n inquisitivecrystal <22333129+inquisitivecrystal@users.noreply.github.com>\n Irina Popa <irinagpopa@gmail.com>"}, {"sha": "5135f92a9d82ef47d0c4650c0f295b51dd80a3fc", "filename": ".reuse/dep5", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -6,11 +6,6 @@ Files: *\n Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n License: MIT or Apache-2.0\n \n-Files: library/std/src/sync/mpsc/mpsc_queue.rs\n-       library/std/src/sync/mpsc/spsc_queue.rs\n-Copyright: 2010-2011 Dmitry Vyukov\n-License: BSD-2-Clause\n-\n Files: src/librustdoc/html/static/fonts/FiraSans*\n Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n License: OFL-1.1"}, {"sha": "9f64aa44314db553a78cacab3826a95a45e66f22", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -273,7 +273,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.67.0\"\n+version = \"0.68.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -473,9 +473,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.73\"\n+version = \"1.0.76\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+checksum = \"76a284da2e6fe2092f2353e51713435363112dfd60030e22add80be333fb928f\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -502,9 +502,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d0001adf0cf12361e08b65e1898ea138f8f77d8f5177cbf29b6b3b3532252bd6\"\n+checksum = \"d552b2fa341f5fc35c6b917b1d289d3c3a34d0b74e579390ea6192d6152a8cdb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -514,9 +514,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c44ee96f2d67cb5193d1503f185db1abad9933a1c6e6b4169c176f90baecd393\"\n+checksum = \"7e54ac43048cb31c470d7b3e3acd409090ef4a5abddfe02455187aebc3d6879f\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -527,9 +527,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"92d8a95548f23618fda86426e4304e563ec2bb7ba0216139f0748d63c107b5f1\"\n+checksum = \"43aa55deff4e7fbdb09fa014543372f2c95a06835ac487b9ce57b5099b950838\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -538,9 +538,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f37f492dacfafe2e21319b80827da2779932909bb392f0cc86b2bd5c07c1b4e1\"\n+checksum = \"61213deefc36ba265ad01c4d997e18bcddf7922862a4594a47ca4575afb3dab4\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,9 +0,0 @@\n-Copyright (c) <year> <owner> \n-\n-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n-\n-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n-\n-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "c999b06b0ab2d5b3cc247bb63c94f1596bc061b9", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1208,7 +1208,7 @@ impl Expr {\n             ExprKind::Tup(_) => ExprPrecedence::Tup,\n             ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n-            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Lit(_) | ExprKind::IncludedBytes(..) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::Let(..) => ExprPrecedence::Let,\n             ExprKind::If(..) => ExprPrecedence::If,\n@@ -1446,6 +1446,12 @@ pub enum ExprKind {\n     /// with an optional value to be returned.\n     Yeet(Option<P<Expr>>),\n \n+    /// Bytes included via `include_bytes!`\n+    /// Added for optimization purposes to avoid the need to escape\n+    /// large binary blobs - should always behave like [`ExprKind::Lit`]\n+    /// with a `ByteStr` literal.\n+    IncludedBytes(Lrc<[u8]>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }"}, {"sha": "9c1dfeb1a61428920e20e4ac69f61e9913701094", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -29,6 +29,7 @@ extern crate rustc_macros;\n extern crate tracing;\n \n pub mod util {\n+    pub mod case;\n     pub mod classify;\n     pub mod comments;\n     pub mod literal;"}, {"sha": "3ab8267263d116506ba99ab75cc0e7096675dfc6", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1428,7 +1428,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::Try(expr) => vis.visit_expr(expr),\n         ExprKind::TryBlock(body) => vis.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);"}, {"sha": "f6aac0b55f1ab56c391159e517f3dc92f6aa45f0", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -5,6 +5,7 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n+use crate::util::case::Case;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -615,6 +616,15 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n+    /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {\n+        self.is_keyword(kw)\n+            || (case == Case::Insensitive\n+                && self.is_non_raw_ident_where(|id| {\n+                    id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n+                }))\n+    }\n+\n     pub fn is_path_segment_keyword(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }"}, {"sha": "1afd7dea7408ecb9c247e101ac7f4f951c636cf3", "filename": "compiler/rustc_ast/src/util/case.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,6 @@\n+/// Whatever to ignore case (`fn` vs `Fn` vs `FN`) or not. Used for recovering.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Case {\n+    Sensitive,\n+    Insensitive,\n+}"}, {"sha": "e267f8cd10027d349f8dacb4a8d808cc88df76f9", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2,6 +2,7 @@\n \n use crate::ast::{self, Lit, LitKind};\n use crate::token::{self, Token};\n+use rustc_data_structures::sync::Lrc;\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -231,6 +232,13 @@ impl Lit {\n         Lit { token_lit: kind.to_token_lit(), kind, span }\n     }\n \n+    /// Recovers an AST literal from a string of bytes produced by `include_bytes!`.\n+    /// This requires ASCII-escaping the string, which can result in poor performance\n+    /// for very large strings of bytes.\n+    pub fn from_included_bytes(bytes: &Lrc<[u8]>, span: Span) -> Lit {\n+        Self::from_lit_kind(LitKind::ByteStr(bytes.clone()), span)\n+    }\n+\n     /// Losslessly convert an AST literal into a token.\n     pub fn to_token(&self) -> Token {\n         let kind = match self.token_lit.kind {"}, {"sha": "da0545ce80c373f3e94ddd4c4a6c08b70333b2db", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -251,7 +251,7 @@ pub trait Visitor<'ast>: Sized {\n macro_rules! walk_list {\n     ($visitor: expr, $method: ident, $list: expr $(, $($extra_args: expr),* )?) => {\n         {\n-            #[cfg_attr(not(bootstrap), allow(for_loops_over_fallibles))]\n+            #[allow(for_loops_over_fallibles)]\n             for elem in $list {\n                 $visitor.$method(elem $(, $($extra_args,)* )?)\n             }\n@@ -901,7 +901,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "a4ae493af86bf6a23fc3b0df42d6138c6454e85d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -87,6 +87,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Lit(ref l) => {\n                     hir::ExprKind::Lit(respan(self.lower_span(l.span), l.kind.clone()))\n                 }\n+                ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n+                    self.lower_span(e.span),\n+                    LitKind::ByteStr(bytes.clone()),\n+                )),\n                 ExprKind::Cast(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty ="}, {"sha": "7fdfc79164b48fba2142824f1b829ace1af07094", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -323,7 +323,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // ```\n     fn lower_expr_within_pat(&mut self, expr: &Expr, allow_paths: bool) -> &'hir hir::Expr<'hir> {\n         match expr.kind {\n-            ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Err => {}\n+            ExprKind::Lit(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::IncludedBytes(..)\n+            | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {"}, {"sha": "930276242c3c361f9e72f525348ff09335ba5031", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -322,6 +322,10 @@ impl<'a> State<'a> {\n             ast::ExprKind::Lit(ref lit) => {\n                 self.print_literal(lit);\n             }\n+            ast::ExprKind::IncludedBytes(ref bytes) => {\n+                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n+                self.print_literal(&lit)\n+            }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);"}, {"sha": "563ff056ae467245b67f5bacee32f7c2b5817ff0", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;"}, {"sha": "01be379120dc7483c088daa4005b744bb386dfb8", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -8,9 +8,18 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     pub(crate) fn cannot_move_when_borrowed(\n         &self,\n         span: Span,\n-        desc: &str,\n+        borrow_span: Span,\n+        place: &str,\n+        borrow_place: &str,\n+        value_place: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n+        self.infcx.tcx.sess.create_err(crate::session_diagnostics::MoveBorrow {\n+            place,\n+            span,\n+            borrow_place,\n+            value_place,\n+            borrow_span,\n+        })\n     }\n \n     pub(crate) fn cannot_use_when_mutably_borrowed("}, {"sha": "11b31c3f14028e72dbe20df6d6e3db3a6ec21f1a", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::visit::TyContext;\n use rustc_middle::mir::visit::Visitor;"}, {"sha": "84a93e5f72e9dd3b508782306ea15fc46d653995", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;"}, {"sha": "86da767f322738fae52365b52cc0366d1b6fe311", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;"}, {"sha": "8070c0e6710ee0e1288cb9a0284fab5d47f8617f", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, Place};"}, {"sha": "8e62a0198be46987733c4ad7c0608aff65cc84bf", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_middle::mir::visit::{\n     MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext,\n };"}, {"sha": "b99bfda1a51fe661c6366505486bca5d9c8f76b8", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;"}, {"sha": "9e0aa57b2553fba87dfbab9ef2f19689da0a12ce", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -224,10 +224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            use_spans.var_span_label_path_only(\n-                &mut err,\n-                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-            );\n+            use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n             if !is_loop_move {\n                 err.span_label(\n@@ -404,10 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let used = desired_action.as_general_verb_in_past_tense();\n         let mut err =\n             struct_span_err!(self, span, E0381, \"{used} binding {desc}{isnt_initialized}\");\n-        use_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-        );\n+        use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n         if let InitializationRequiringAction::PartialAssignment\n         | InitializationRequiringAction::Assignment = desired_action\n@@ -673,16 +667,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let move_spans = self.move_spans(place.as_ref(), location);\n         let span = move_spans.args_or_use();\n \n-        let mut err =\n-            self.cannot_move_when_borrowed(span, &self.describe_any_place(place.as_ref()));\n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n-        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n-\n-        borrow_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", borrow_spans.describe()),\n+        let mut err = self.cannot_move_when_borrowed(\n+            span,\n+            borrow_span,\n+            &self.describe_any_place(place.as_ref()),\n+            &borrow_msg,\n+            &value_msg,\n         );\n \n+        borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n+\n         move_spans.var_span_label(\n             &mut err,\n             format!(\"move occurs due to use{}\", move_spans.describe()),\n@@ -724,22 +718,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-        borrow_spans.var_subdiag(\n-            &mut err,\n-            |var_span| {\n-                use crate::session_diagnostics::CaptureVarCause::*;\n-                let place = &borrow.borrowed_place;\n-                let desc_place = self.describe_any_place(place.as_ref());\n-                match borrow_spans {\n-                    UseSpans::ClosureUse { generator_kind, .. } => match generator_kind {\n-                        Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n-                        None => BorrowUsePlaceClosure { place: desc_place, var_span },\n-                    },\n-                    _ => BorrowUsePlace { place: desc_place, var_span },\n-                }\n-            },\n-            \"mutable\",\n-        );\n+        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_any_place(place.as_ref());\n+            match kind {\n+                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic("}, {"sha": "498e9834354b7ff851da549230f7b2707ef43c28", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::BTreeSet;\n \n use rustc_middle::mir::visit::{PlaceContext, Visitor};"}, {"sha": "15f42e26cbf4a7aeca1bac947ac0b58b4836c3aa", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::VecDeque;\n use std::rc::Rc;\n "}, {"sha": "7f26af67c71b214485777b90ea0e97029650bafb", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -595,11 +595,34 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the use of the captured variable, if it exists.\n-    // only adds label to the `path_span`\n-    pub(super) fn var_span_label_path_only(self, err: &mut Diagnostic, message: impl Into<String>) {\n-        if let UseSpans::ClosureUse { path_span, .. } = self {\n-            err.span_label(path_span, message);\n+    /// Add a span label to the use of the captured variable, if it exists.\n+    /// only adds label to the `path_span`\n+    pub(super) fn var_path_only_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        action: crate::InitializationRequiringAction,\n+    ) {\n+        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n+        use crate::InitializationRequiringAction::*;\n+        if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n+            match generator_kind {\n+                Some(_) => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInGenerator { path_span },\n+                        MatchOn | Use => UseInGenerator { path_span },\n+                        Assignment => AssignInGenerator { path_span },\n+                        PartialAssignment => AssignPartInGenerator { path_span },\n+                    });\n+                }\n+                None => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInClosure { path_span },\n+                        MatchOn | Use => UseInClosure { path_span },\n+                        Assignment => AssignInClosure { path_span },\n+                        PartialAssignment => AssignPartInClosure { path_span },\n+                    });\n+                }\n+            }\n         }\n     }\n \n@@ -627,19 +650,28 @@ impl UseSpans<'_> {\n     pub(super) fn var_subdiag(\n         self,\n         err: &mut Diagnostic,\n-        f: impl Fn(Span) -> crate::session_diagnostics::CaptureVarCause,\n-        kind_desc: impl Into<String>,\n+        kind: Option<rustc_middle::mir::BorrowKind>,\n+        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n     ) {\n-        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n-            if capture_kind_span == path_span {\n-                err.subdiagnostic(f(capture_kind_span));\n-            } else {\n-                err.subdiagnostic(crate::session_diagnostics::CaptureVarKind {\n-                    kind_desc: kind_desc.into(),\n-                    kind_span: capture_kind_span,\n+        use crate::session_diagnostics::CaptureVarKind::*;\n+        if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n+            if capture_kind_span != path_span {\n+                err.subdiagnostic(match kind {\n+                    Some(kd) => match kd {\n+                        rustc_middle::mir::BorrowKind::Shared\n+                        | rustc_middle::mir::BorrowKind::Shallow\n+                        | rustc_middle::mir::BorrowKind::Unique => {\n+                            Immute { kind_span: capture_kind_span }\n+                        }\n+\n+                        rustc_middle::mir::BorrowKind::Mut { .. } => {\n+                            Mut { kind_span: capture_kind_span }\n+                        }\n+                    },\n+                    None => Move { kind_span: capture_kind_span },\n                 });\n-                err.subdiagnostic(f(path_span));\n-            }\n+            };\n+            err.subdiagnostic(f(generator_kind, path_span));\n         }\n     }\n "}, {"sha": "7457369aa58cb42bad748f68492f6d9c79462e88", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,6 +1,4 @@\n-use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -629,25 +627,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         self.buffer_error(err);\n     }\n \n-    fn suggest_map_index_mut_alternatives(\n-        &self,\n-        ty: Ty<'_>,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n-        span: Span,\n-    ) {\n+    fn suggest_map_index_mut_alternatives(&self, ty: Ty<'tcx>, err: &mut Diagnostic, span: Span) {\n         let Some(adt) = ty.ty_adt_def() else { return };\n         let did = adt.did();\n         if self.infcx.tcx.is_diagnostic_item(sym::HashMap, did)\n             || self.infcx.tcx.is_diagnostic_item(sym::BTreeMap, did)\n         {\n-            struct V<'a, 'b, 'tcx, G: EmissionGuarantee> {\n+            struct V<'a, 'tcx> {\n                 assign_span: Span,\n-                err: &'a mut DiagnosticBuilder<'b, G>,\n+                err: &'a mut Diagnostic,\n                 ty: Ty<'tcx>,\n                 suggested: bool,\n             }\n-            impl<'a, 'b: 'a, 'hir, 'tcx, G: EmissionGuarantee> Visitor<'hir> for V<'a, 'b, 'tcx, G> {\n-                fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'hir>) {\n+            impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+                fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n                     hir::intravisit::walk_stmt(self, stmt);\n                     let expr = match stmt.kind {\n                         hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n@@ -705,7 +698,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     ),\n                                     (rv.span.shrink_to_hi(), \")\".to_string()),\n                                 ],\n-                            ].into_iter(),\n+                            ],\n                             Applicability::MachineApplicable,\n                         );\n                         self.suggested = true;"}, {"sha": "b385f95b67c6f992a12841c02b77b7bed01b8f35", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use crate::Upvar;\n use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexVec};"}, {"sha": "51ed27c167d3844971e445036bb0a4584524e210", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::location::{LocationIndex, LocationTable};\n use crate::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusFacts;"}, {"sha": "f5317a143aed7157d0801da0e688c7bd7a090246", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, NonDivergingIntrinsic, Place, Rvalue};"}, {"sha": "9fa7e218b1b6f65ceb09a92420043f5f823f41f1", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{BasicBlock, Body, Location};\n "}, {"sha": "b48f9f97daad8d76dc07b541f445206f55fa7e8c", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;"}, {"sha": "f8856b56d140bae139a7d069159b8bb813b28dd6", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n use rustc_data_structures::vec_map::VecMap;"}, {"sha": "f8a99a2699e6ff0cf3c89c3c62ab576f6278e72c", "filename": "compiler/rustc_borrowck/src/path_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::places_conflict;\n use crate::AccessDepth;"}, {"sha": "9f6b1fdfcb54085853bb49c34a070b95c3358ec7", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::LocalsStateAtExit;\n use rustc_hir as hir;\n use rustc_middle::mir::ProjectionElem;"}, {"sha": "8a87d1972ebf35613c8673285a0e43880112a666", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::ArtificialField;\n use crate::Overlap;\n use crate::{AccessDepth, Deep, Shallow};"}, {"sha": "6f281349863763f0cbb578f0a93102ef6ec19b81", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n //! place are formed by stripping away fields and derefs, except that\n //! we stop when we reach the deref of a shared reference. [...] \""}, {"sha": "6524b594e44dc02083d629688966c151ae0965c5", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! As part of generating the regions, if you enable `-Zdump-mir=nll`,\n //! we will generate an annotated copy of the MIR that includes the\n //! state of region inference. This code handles emitting the region"}, {"sha": "2e15586e03b3bb49ec35331d11cdeaa9d9026b25", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This module provides linkage between RegionInferenceContext and\n //! `rustc_graphviz` traits, specialized to attaching borrowck analysis\n //! data to rendered labels."}, {"sha": "167f664609698e8b26011e134c887d85855f7e79", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::constraints::ConstraintSccIndex;\n use crate::RegionInferenceContext;\n use itertools::Itertools;"}, {"sha": "7498ddccf196a1fc136f07cac6e20768c606ce60", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::SparseBitMatrix;\n use rustc_index::interval::IntervalSet;"}, {"sha": "084754830bdbfa8dda894e2f0621e6dd7ebe575d", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};"}, {"sha": "577332c0744b84dd8447af7ab3519a33ef18abe0", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -150,21 +150,70 @@ pub(crate) enum RequireStaticErr {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(borrowck_capture_kind_label)]\n-pub(crate) struct CaptureVarKind {\n-    pub kind_desc: String,\n-    #[primary_span]\n-    pub kind_span: Span,\n+pub(crate) enum CaptureVarPathUseCause {\n+    #[label(borrowck_borrow_due_to_use_generator)]\n+    BorrowInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_generator)]\n+    UseInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_generator)]\n+    AssignInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_generator)]\n+    AssignPartInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_borrow_due_to_use_closure)]\n+    BorrowInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_closure)]\n+    UseInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_closure)]\n+    AssignInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_closure)]\n+    AssignPartInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n }\n \n #[derive(Subdiagnostic)]\n-pub(crate) enum CaptureVarCause {\n-    #[label(borrowck_var_borrow_by_use_place)]\n-    BorrowUsePlace {\n-        place: String,\n+pub(crate) enum CaptureVarKind {\n+    #[label(borrowck_capture_immute)]\n+    Immute {\n         #[primary_span]\n-        var_span: Span,\n+        kind_span: Span,\n+    },\n+    #[label(borrowck_capture_mut)]\n+    Mut {\n+        #[primary_span]\n+        kind_span: Span,\n     },\n+    #[label(borrowck_capture_move)]\n+    Move {\n+        #[primary_span]\n+        kind_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarCause {\n     #[label(borrowck_var_borrow_by_use_place_in_generator)]\n     BorrowUsePlaceGenerator {\n         place: String,\n@@ -178,3 +227,16 @@ pub(crate) enum CaptureVarCause {\n         var_span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck_cannot_move_when_borrowed, code = \"E0505\")]\n+pub(crate) struct MoveBorrow<'a> {\n+    pub place: &'a str,\n+    pub borrow_place: &'a str,\n+    pub value_place: &'a str,\n+    #[primary_span]\n+    #[label(move_label)]\n+    pub span: Span,\n+    #[label]\n+    pub borrow_span: Span,\n+}"}, {"sha": "6ccc29b09c0a5d9646acb03f130f29ec579530a0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This pass type-checks the MIR to ensure it is not broken.\n \n use std::rc::Rc;"}, {"sha": "e297b1230ea0c58b2bf273cc8dbf886c9e495cb4", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{"}, {"sha": "f72cd14bea0436e574a7a0f90ee26af58552fe72", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -303,6 +303,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Field(_, _)\n             | ExprKind::ForLoop(_, _, _, _)\n             | ExprKind::If(_, _, _)\n+            | ExprKind::IncludedBytes(..)\n             | ExprKind::InlineAsm(_)\n             | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)"}, {"sha": "86df3c44eb334e7b51aa65ad268417f170162c4b", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -34,6 +34,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());"}, {"sha": "01454d0e98e699cc14096654cc5c50ebd780f0d9", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -43,6 +43,9 @@ pub fn expand_concat(\n                     has_errors = true;\n                 }\n             },\n+            ast::ExprKind::IncludedBytes(..) => {\n+                cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n+            }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n             }"}, {"sha": "4886ca786a588bc5de61de819a1f49e4884bb25e", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -108,6 +108,16 @@ fn handle_array_element(\n                 None\n             }\n         },\n+        ast::ExprKind::IncludedBytes(..) => {\n+            if !*has_errors {\n+                cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n+                    .note(\"byte strings are treated as arrays of bytes\")\n+                    .help(\"try flattening the array\")\n+                    .emit();\n+            }\n+            *has_errors = true;\n+            None\n+        }\n         _ => {\n             missing_literals.push(expr.span);\n             None\n@@ -167,6 +177,9 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n+            ast::ExprKind::IncludedBytes(ref bytes) => {\n+                accumulator.extend_from_slice(bytes);\n+            }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n             }"}, {"sha": "01f237e6ab5fa3d085a9b1e09ab103bc31e97dc9", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n-pub(crate) struct Expander;\n+pub(crate) struct Expander(pub bool);\n \n impl MultiItemModifier for Expander {\n     fn expand(\n@@ -19,6 +19,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let sess = ecx.sess;\n         if report_bad_target(sess, &item, span) {\n@@ -58,20 +59,20 @@ impl MultiItemModifier for Expander {\n                         report_path_args(sess, &meta);\n                         meta.path\n                     })\n-                    .map(|path| (path, dummy_annotatable(), None))\n+                    .map(|path| (path, dummy_annotatable(), None, self.0))\n                     .collect();\n \n                 // Do not configure or clone items unless necessary.\n                 match &mut resolutions[..] {\n                     [] => {}\n-                    [(_, first_item, _), others @ ..] => {\n+                    [(_, first_item, ..), others @ ..] => {\n                         *first_item = cfg_eval(\n                             sess,\n                             features,\n                             item.clone(),\n                             ecx.current_expansion.lint_node_id,\n                         );\n-                        for (_, item, _) in others {\n+                        for (_, item, _, _) in others {\n                             *item = first_item.clone();\n                         }\n                     }"}, {"sha": "345db700298a81813d544b00197b4a89b1daba3f", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -12,6 +12,7 @@ pub fn expand_deriving_copy(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let trait_def = TraitDef {\n         span,\n@@ -22,6 +23,7 @@ pub fn expand_deriving_copy(\n         supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push);"}, {"sha": "55cbb65472328bd88554fb009226f98cb14a8829", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_clone(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // The simple form is `fn clone(&self) -> Self { *self }`, possibly with\n     // some additional `AssertParamIsClone` assertions.\n@@ -87,6 +88,7 @@ pub fn expand_deriving_clone(\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand_ext(cx, mitem, item, push, is_simple)"}, {"sha": "6190b7a8c779eb385bc4db2b7c05b4b8bd815c03", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -15,6 +15,7 @@ pub fn expand_deriving_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n     let inline = cx.meta_word(span, sym::inline);\n@@ -42,6 +43,7 @@ pub fn expand_deriving_eq(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     super::inject_impl_of_structural_trait(cx, span, item, path_std!(marker::StructuralEq), push);"}, {"sha": "d2412b20a09c80d251d1aeaf90cd2b39a62bd2ed", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n     let attrs = thin_vec![cx.attribute(inline)];\n@@ -34,6 +35,7 @@ pub fn expand_deriving_ord(\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "353f28fc45fb70f59cebb83084b7e1e02e5443eb", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_partial_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         let base = true;\n@@ -89,6 +90,7 @@ pub fn expand_deriving_partial_eq(\n         supports_unions: false,\n         methods,\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "e7458b23ef3879e62332d938ee655b2da0d5c75f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_partial_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let ordering_ty = Path(path_std!(cmp::Ordering));\n     let ret_ty =\n@@ -43,6 +44,7 @@ pub fn expand_deriving_partial_ord(\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "e6d5759bb5210dd99ef6aecf2eba1d71f6a6bad4", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_debug(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ref(Box::new(Path(path_std!(fmt::Formatter))), ast::Mutability::Mut);\n@@ -37,6 +38,7 @@ pub fn expand_deriving_debug(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "37aa665e5c607e26ed86b9440fc8b31720d1551d", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_rustc_decodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__D;\n@@ -55,6 +56,7 @@ pub fn expand_deriving_rustc_decodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "234957ab8a16b7ea1e76ef2b7f8fa4849db5db8a", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_default(\n     mitem: &ast::MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n@@ -47,6 +48,7 @@ pub fn expand_deriving_default(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "baacaa8b979e184906b2f0f593266ca4c2e7fac6", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -100,6 +100,7 @@ pub fn expand_deriving_rustc_encodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__S;\n@@ -139,6 +140,7 @@ pub fn expand_deriving_rustc_encodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "3972c3b493410b277991d12cea7fa45c16de51ff", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -171,7 +171,7 @@ use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use std::cell::RefCell;\n use std::iter;\n use std::ops::Not;\n@@ -204,6 +204,8 @@ pub struct TraitDef<'a> {\n     pub methods: Vec<MethodDef<'a>>,\n \n     pub associated_types: Vec<(Ident, Ty)>,\n+\n+    pub is_const: bool,\n }\n \n pub struct MethodDef<'a> {\n@@ -730,7 +732,7 @@ impl<'a> TraitDef<'a> {\n                 unsafety: ast::Unsafe::No,\n                 polarity: ast::ImplPolarity::Positive,\n                 defaultness: ast::Defaultness::Final,\n-                constness: ast::Const::No,\n+                constness: if self.is_const { ast::Const::Yes(DUMMY_SP) } else { ast::Const::No },\n                 generics: trait_generics,\n                 of_trait: opt_trait_ref,\n                 self_ty: self_type,"}, {"sha": "8fb1a4ba262abda904460b7bf5b290d86c99c105", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_hash(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let path = Path::new_(pathvec_std!(hash::Hash), vec![], PathKind::Std);\n \n@@ -39,6 +40,7 @@ pub fn expand_deriving_hash(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);"}, {"sha": "73a1df5d426d264fdb5ad7a1d008c2a575418449", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -38,9 +38,10 @@ pub mod partial_ord;\n \n pub mod generic;\n \n-pub(crate) struct BuiltinDerive(\n-    pub(crate) fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n-);\n+pub(crate) type BuiltinDeriveFn =\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable), bool);\n+\n+pub(crate) struct BuiltinDerive(pub(crate) BuiltinDeriveFn);\n \n impl MultiItemModifier for BuiltinDerive {\n     fn expand(\n@@ -49,6 +50,7 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n@@ -57,21 +59,28 @@ impl MultiItemModifier for BuiltinDerive {\n         match item {\n             Annotatable::Stmt(stmt) => {\n                 if let ast::StmtKind::Item(item) = stmt.into_inner().kind {\n-                    (self.0)(ecx, span, meta_item, &Annotatable::Item(item), &mut |a| {\n-                        // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n-                        // to the function\n-                        items.push(Annotatable::Stmt(P(ast::Stmt {\n-                            id: ast::DUMMY_NODE_ID,\n-                            kind: ast::StmtKind::Item(a.expect_item()),\n-                            span,\n-                        })));\n-                    });\n+                    (self.0)(\n+                        ecx,\n+                        span,\n+                        meta_item,\n+                        &Annotatable::Item(item),\n+                        &mut |a| {\n+                            // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n+                            // to the function\n+                            items.push(Annotatable::Stmt(P(ast::Stmt {\n+                                id: ast::DUMMY_NODE_ID,\n+                                kind: ast::StmtKind::Item(a.expect_item()),\n+                                span,\n+                            })));\n+                        },\n+                        is_derive_const,\n+                    );\n                 } else {\n                     unreachable!(\"should have already errored on non-item statement\")\n                 }\n             }\n             _ => {\n-                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a), is_derive_const);\n             }\n         }\n         ExpandResult::Ready(items)"}, {"sha": "1cbbfb432647cebca15bfa72ac207eac463fb1da", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -99,7 +99,8 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,\n-        derive: derive::Expander,\n+        derive: derive::Expander(false),\n+        derive_const: derive::Expander(true),\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "3411bd40c9de553ec6e192aafb8350f0d55f6282", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -216,7 +216,10 @@ pub fn expand_include_bytes(\n         }\n     };\n     match cx.source_map().load_binary_file(&file) {\n-        Ok(bytes) => base::MacEager::expr(cx.expr_byte_str(sp, bytes)),\n+        Ok(bytes) => {\n+            let expr = cx.expr(sp, ast::ExprKind::IncludedBytes(bytes.into()));\n+            base::MacEager::expr(expr)\n+        }\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n             DummyResult::any(sp)"}, {"sha": "b62840d4bc8221d72d4a45d5d5e3144a3a050d01", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -112,7 +112,7 @@ pub fn expand_test_or_bench(\n     };\n \n     // Note: non-associated fn items are already handled by `expand_test_or_bench`\n-    if !matches!(item.kind, ast::ItemKind::Fn(_)) {\n+    let ast::ItemKind::Fn(fn_) = &item.kind else {\n         let diag = &cx.sess.parse_sess.span_diagnostic;\n         let msg = \"the `#[test]` attribute may only be used on a non-associated function\";\n         let mut err = match item.kind {\n@@ -130,7 +130,7 @@ pub fn expand_test_or_bench(\n             .emit();\n \n         return vec![Annotatable::Item(item)];\n-    }\n+    };\n \n     // has_*_signature will report any errors in the type so compilation\n     // will fail. We shouldn't try to expand in this case because the errors\n@@ -141,12 +141,14 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n+    let sp = cx.with_def_site_ctxt(item.span);\n+    let ret_ty_sp = cx.with_def_site_ctxt(fn_.sig.decl.output.span());\n+    let attr_sp = cx.with_def_site_ctxt(attr_sp);\n \n     let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n-    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n+    let test_path = |name| cx.path(ret_ty_sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n \n     // creates test::ShouldPanic::$name\n     let should_panic_path = |name| {\n@@ -192,7 +194,7 @@ pub fn expand_test_or_bench(\n                         vec![\n                             // super::$test_fn(b)\n                             cx.expr_call(\n-                                sp,\n+                                ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n                                 vec![cx.expr_ident(sp, b)],\n                             ),\n@@ -216,7 +218,11 @@ pub fn expand_test_or_bench(\n                         cx.expr_path(test_path(\"assert_test_result\")),\n                         vec![\n                             // $test_fn()\n-                            cx.expr_call(sp, cx.expr_path(cx.path(sp, vec![item.ident])), vec![]), // )\n+                            cx.expr_call(\n+                                ret_ty_sp,\n+                                cx.expr_path(cx.path(sp, vec![item.ident])),\n+                                vec![],\n+                            ), // )\n                         ],\n                     ), // }\n                 ), // )"}, {"sha": "df1150ec0b8ce266e610de2a0a52052ebd9dc992", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -128,7 +128,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     let layout = fx.layout_of(ty);\n-    assert!(!layout.is_unsized(), \"sized const value\");\n+    assert!(layout.is_sized(), \"unsized const value\");\n \n     if layout.is_zst() {\n         return CValue::by_ref(crate::Pointer::dangling(layout.align.pref), layout);"}, {"sha": "c5bd574623df68d2644ce5908d136d696b12e979", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -19,7 +19,7 @@ fn codegen_field<'tcx>(\n     };\n \n     if let Some(extra) = extra {\n-        if !field_layout.is_unsized() {\n+        if field_layout.is_sized() {\n             return simple(fx);\n         }\n         match field_layout.ty.kind() {\n@@ -364,7 +364,7 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         if layout.size.bytes() == 0 {\n             return CPlace {\n                 inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n@@ -825,7 +825,7 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n-        assert!(!self.layout().is_unsized());\n+        assert!(self.layout().is_sized());\n         let layout = self.layout().for_variant(fx, variant);\n         CPlace { inner: self.inner, layout }\n     }"}, {"sha": "bdf7318ce48c9505887b2287c0201bf66742bc54", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -277,7 +277,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }\n-    if !layout.is_unsized() && field_count > 0 {\n+    if layout.is_sized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }"}, {"sha": "97d0de47b3a6e7fbff4484c5e74c393bea3891a2", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -765,11 +765,21 @@ pub(crate) unsafe fn codegen(\n         drop(handlers);\n     }\n \n+    // `.dwo` files are only emitted if:\n+    //\n+    // - Object files are being emitted (i.e. bitcode only or metadata only compilations will not\n+    //   produce dwarf objects, even if otherwise enabled)\n+    // - Target supports Split DWARF\n+    // - Split debuginfo is enabled\n+    // - Split DWARF kind is `split` (i.e. debuginfo is split into `.dwo` files, not different\n+    //   sections in the `.o` files).\n+    let dwarf_object_emitted = matches!(config.emit_obj, EmitObj::ObjectCode(_))\n+        && cgcx.target_can_use_split_dwarf\n+        && cgcx.split_debuginfo != SplitDebuginfo::Off\n+        && cgcx.split_dwarf_kind == SplitDwarfKind::Split;\n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n-        cgcx.target_can_use_split_dwarf\n-            && cgcx.split_debuginfo != SplitDebuginfo::Off\n-            && cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n+        dwarf_object_emitted,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "5cd0e1cb63ae1b6b2c602272ba506cbf45dc1c45", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -72,7 +72,7 @@ pub(crate) fn fat_pointer_kind<'ll, 'tcx>(\n         layout.is_unsized()\n     );\n \n-    if !layout.is_unsized() {\n+    if layout.is_sized() {\n         return None;\n     }\n "}, {"sha": "cf590a43826e53407aab00b691ad66fe0744a3cd", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -340,17 +340,26 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n \n             sym::black_box => {\n                 args[0].val.store(self, result);\n-\n+                let result_val_span = [result.llval];\n                 // We need to \"use\" the argument in some way LLVM can't introspect, and on\n                 // targets that support it we can typically leverage inline assembly to do\n                 // this. LLVM's interpretation of inline assembly is that it's, well, a black\n                 // box. This isn't the greatest implementation since it probably deoptimizes\n                 // more than we want, but it's so far good enough.\n+                //\n+                // For zero-sized types, the location pointed to by the result may be\n+                // uninitialized. Do not \"use\" the result in this case; instead just clobber\n+                // the memory.\n+                let (constraint, inputs): (&str, &[_]) = if result.layout.is_zst() {\n+                    (\"~{memory}\", &[])\n+                } else {\n+                    (\"r,~{memory}\", &result_val_span)\n+                };\n                 crate::asm::inline_asm_call(\n                     self,\n                     \"\",\n-                    \"r,~{memory}\",\n-                    &[result.llval],\n+                    constraint,\n+                    inputs,\n                     self.type_void(),\n                     true,\n                     false,"}, {"sha": "182adf81785716fe5abea7b91e0571dc6bda7a8b", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -140,7 +140,7 @@ fn struct_llfields<'a, 'tcx>(\n         prev_effective_align = effective_field_align;\n     }\n     let padding_used = result.len() > field_count;\n-    if !layout.is_unsized() && field_count > 0 {\n+    if layout.is_sized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }"}, {"sha": "2b1b06d1644c9062656d3cc52ce816dc2bb72eff", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -4,8 +4,11 @@ use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n+use super::metadata::search_for_section;\n+\n use object::read::archive::ArchiveFile;\n \n+use std::error::Error;\n use std::fs::File;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -56,6 +59,9 @@ pub trait ArchiveBuilderBuilder {\n             if !bundled_lib_file_names.contains(&Symbol::intern(name)) {\n                 continue; // We need to extract only native libraries.\n             }\n+            let data = search_for_section(rlib, data, \".bundled_lib\").map_err(|e| {\n+                ExtractBundledLibsError::ExtractSection { rlib, error: Box::<dyn Error>::from(e) }\n+            })?;\n             std::fs::write(&outdir.join(&name), data)\n                 .map_err(|e| ExtractBundledLibsError::WriteFile { rlib, error: Box::new(e) })?;\n         }"}, {"sha": "4445e5f6c3a64e3d24c0d9379f15cfd74337eda1", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 346, "deletions": 388, "changes": 734, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_hir::def_id::CrateNum;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_metadata::find_native_static_library;\n-use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n+use rustc_metadata::fs::{emit_wrapper_file, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Lto, Strip};\n@@ -24,12 +24,12 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, Target};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo};\n \n use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n-use super::metadata::{create_rmeta_file, MetadataPosition};\n+use super::metadata::{create_wrapper_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n use crate::{\n     errors, looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n@@ -44,7 +44,7 @@ use std::borrow::Borrow;\n use std::cell::OnceCell;\n use std::collections::BTreeSet;\n use std::ffi::OsString;\n-use std::fs::{File, OpenOptions};\n+use std::fs::{read, File, OpenOptions};\n use std::io::{BufWriter, Write};\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n@@ -292,8 +292,8 @@ fn link_rlib<'a>(\n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n             let (metadata, metadata_position) =\n-                create_rmeta_file(sess, codegen_results.metadata.raw_data());\n-            let metadata = emit_metadata(sess, &metadata, tmpdir);\n+                create_wrapper_file(sess, b\".rmeta\".to_vec(), codegen_results.metadata.raw_data());\n+            let metadata = emit_wrapper_file(sess, &metadata, tmpdir, METADATA_FILENAME);\n             match metadata_position {\n                 MetadataPosition::First => {\n                     // Most of the time metadata in rlib files is wrapped in a \"dummy\" object\n@@ -376,12 +376,18 @@ fn link_rlib<'a>(\n             let location =\n                 find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n-                packed_bundled_libs.push(find_native_static_library(\n-                    lib.filename.unwrap().as_str(),\n+                let filename = lib.filename.unwrap();\n+                let lib_path = find_native_static_library(\n+                    filename.as_str(),\n                     Some(true),\n                     &lib_search_paths,\n                     sess,\n-                ));\n+                );\n+                let src = read(lib_path)\n+                    .map_err(|e| sess.emit_fatal(errors::ReadFileError { message: e }))?;\n+                let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n+                let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n+                packed_bundled_libs.push(wrapper_file);\n                 continue;\n             }\n             ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n@@ -2007,15 +2013,9 @@ fn linker_with_args<'a>(\n     cmd.add_as_needed();\n \n     // Local native libraries of all kinds.\n-    //\n-    // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_local_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n-    // Upstream rust libraries and their (possibly bundled) static native libraries.\n+    // Upstream rust crates and their non-dynamic native libraries.\n     add_upstream_rust_crates(\n         cmd,\n         sess,\n@@ -2026,13 +2026,7 @@ fn linker_with_args<'a>(\n     );\n \n     // Dynamic native libraries from upstream crates.\n-    //\n-    // FIXME: Merge this to `add_upstream_rust_crates` so that all native libraries are linked\n-    // together with their respective upstream crates, and in their originally specified order.\n-    // This may be slightly breaking due to our use of `--as-needed` and needs a crater run.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_upstream_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_upstream_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n     // Link with the import library generated for any raw-dylib functions.\n     for (raw_dylib_name, raw_dylib_imports) in\n@@ -2276,42 +2270,46 @@ fn collect_natvis_visualizers(\n     visualizer_paths\n }\n \n-/// # Native library linking\n-///\n-/// User-supplied library search paths (-L on the command line). These are the same paths used to\n-/// find Rust crates, so some of them may have been added already by the previous crate linking\n-/// code. This only allows them to be found at compile time so it is still entirely up to outside\n-/// forces to make sure that library can be found at runtime.\n-///\n-/// Also note that the native libraries linked here are only the ones located in the current crate.\n-/// Upstream crates with native library dependencies may have their native library pulled in above.\n-fn add_local_native_libraries(\n+fn add_native_libs_from_crate(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    search_paths: &OnceCell<Vec<PathBuf>>,\n+    bundled_libs: &FxHashSet<Symbol>,\n+    cnum: CrateNum,\n+    link_static: bool,\n+    link_dynamic: bool,\n ) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => {\n-                cmd.framework_path(&search_path.dir);\n-            }\n-            _ => {\n-                cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir));\n-            }\n-        }\n+    if !sess.opts.unstable_opts.link_native_libraries {\n+        // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n+        // external build system already has the native dependencies defined, and it\n+        // will provide them to the linker itself.\n+        return;\n     }\n \n-    let relevant_libs =\n-        codegen_results.crate_info.used_libraries.iter().filter(|l| relevant_lib(sess, l));\n+    if link_static && cnum != LOCAL_CRATE && !bundled_libs.is_empty() {\n+        // If rlib contains native libs as archives, unpack them to tmpdir.\n+        let rlib = &codegen_results.crate_info.used_crate_source[&cnum].rlib.as_ref().unwrap().0;\n+        archive_builder_builder\n+            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n+            .unwrap_or_else(|e| sess.emit_fatal(e));\n+    }\n+\n+    let native_libs = match cnum {\n+        LOCAL_CRATE => &codegen_results.crate_info.used_libraries,\n+        _ => &codegen_results.crate_info.native_libraries[&cnum],\n+    };\n \n-    let search_path = OnceCell::new();\n     let mut last = (None, NativeLibKind::Unspecified, None);\n-    for lib in relevant_libs {\n+    for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n         };\n-        let name = name.as_str();\n+        if !relevant_lib(sess, lib) {\n+            continue;\n+        }\n \n         // Skip if this library is the same as the last.\n         last = if (lib.name, lib.kind, lib.verbatim) == last {\n@@ -2320,46 +2318,119 @@ fn add_local_native_libraries(\n             (lib.name, lib.kind, lib.verbatim)\n         };\n \n+        let name = name.as_str();\n         let verbatim = lib.verbatim.unwrap_or(false);\n         match lib.kind {\n+            NativeLibKind::Static { bundle, whole_archive } => {\n+                if link_static {\n+                    let bundle = bundle.unwrap_or(true);\n+                    let whole_archive = whole_archive == Some(true)\n+                        // Backward compatibility case: this can be a rlib (so `+whole-archive`\n+                        // cannot be added explicitly if necessary, see the error in `fn link_rlib`)\n+                        // compiled as an executable due to `--test`. Use whole-archive implicitly,\n+                        // like before the introduction of native lib modifiers.\n+                        || (whole_archive == None\n+                            && bundle\n+                            && cnum == LOCAL_CRATE\n+                            && sess.opts.test);\n+\n+                    if bundle && cnum != LOCAL_CRATE {\n+                        if let Some(filename) = lib.filename {\n+                            // If rlib contains native libs as archives, they are unpacked to tmpdir.\n+                            let path = tmpdir.join(filename.as_str());\n+                            if whole_archive {\n+                                cmd.link_whole_rlib(&path);\n+                            } else {\n+                                cmd.link_rlib(&path);\n+                            }\n+                        }\n+                    } else {\n+                        if whole_archive {\n+                            cmd.link_whole_staticlib(\n+                                name,\n+                                verbatim,\n+                                &search_paths.get_or_init(|| archive_search_paths(sess)),\n+                            );\n+                        } else {\n+                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n+                            // with glibc. This logic should be moved to the libc crate.\n+                            if cnum != LOCAL_CRATE\n+                                && sess.target.os == \"linux\"\n+                                && sess.target.env == \"gnu\"\n+                                && name == \"c\"\n+                            {\n+                                cmd.link_staticlib(\"gcc\", false);\n+                            }\n+                            cmd.link_staticlib(name, verbatim)\n+                        }\n+                    }\n+                }\n+            }\n             NativeLibKind::Dylib { as_needed } => {\n-                cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                }\n             }\n-            NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-            NativeLibKind::Framework { as_needed } => {\n-                cmd.link_framework(name, as_needed.unwrap_or(true))\n+            NativeLibKind::Unspecified => {\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, true);\n+                }\n             }\n-            NativeLibKind::Static { whole_archive, bundle, .. } => {\n-                if whole_archive == Some(true)\n-                    // Backward compatibility case: this can be a rlib (so `+whole-archive` cannot\n-                    // be added explicitly if necessary, see the error in `fn link_rlib`) compiled\n-                    // as an executable due to `--test`. Use whole-archive implicitly, like before\n-                    // the introduction of native lib modifiers.\n-                    || (whole_archive == None && bundle != Some(false) && sess.opts.test)\n-                {\n-                    cmd.link_whole_staticlib(\n-                        name,\n-                        verbatim,\n-                        &search_path.get_or_init(|| archive_search_paths(sess)),\n-                    );\n-                } else {\n-                    cmd.link_staticlib(name, verbatim)\n+            NativeLibKind::Framework { as_needed } => {\n+                if link_dynamic {\n+                    cmd.link_framework(name, as_needed.unwrap_or(true))\n                 }\n             }\n             NativeLibKind::RawDylib => {\n-                // Ignore RawDylib here, they are handled separately in linker_with_args().\n+                // Handled separately in `linker_with_args`.\n             }\n             NativeLibKind::LinkArg => {\n-                cmd.arg(name);\n+                if link_static {\n+                    cmd.arg(name);\n+                }\n             }\n         }\n     }\n }\n \n-/// # Linking Rust crates and their non-bundled static libraries\n-///\n-/// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n-/// linked when producing the final output (instead of the intermediate rlib version).\n+fn add_local_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    if sess.opts.unstable_opts.link_native_libraries {\n+        // User-supplied library search paths (-L on the command line). These are the same paths\n+        // used to find Rust crates, so some of them may have been added already by the previous\n+        // crate linking code. This only allows them to be found at compile time so it is still\n+        // entirely up to outside forces to make sure that library can be found at runtime.\n+        for search_path in sess.target_filesearch(PathKind::All).search_paths() {\n+            match search_path.kind {\n+                PathKind::Framework => cmd.framework_path(&search_path.dir),\n+                _ => cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)),\n+            }\n+        }\n+    }\n+\n+    let search_paths = OnceCell::new();\n+    // All static and dynamic native library dependencies are linked to the local crate.\n+    let link_static = true;\n+    let link_dynamic = true;\n+    add_native_libs_from_crate(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        tmpdir,\n+        &search_paths,\n+        &Default::default(),\n+        LOCAL_CRATE,\n+        link_static,\n+        link_dynamic,\n+    );\n+}\n+\n fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n@@ -2375,354 +2446,241 @@ fn add_upstream_rust_crates<'a>(\n     // Linking to a rlib involves just passing it to the linker (the linker\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n-\n     let (_, data) = codegen_results\n         .crate_info\n         .dependency_formats\n         .iter()\n         .find(|(ty, _)| *ty == crate_type)\n         .expect(\"failed to find crate type in dependency format list\");\n \n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates;\n-\n-    let mut compiler_builtins = None;\n-    let search_path = OnceCell::new();\n-\n-    for &cnum in deps.iter() {\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &Default::default(),\n-                );\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                let bundled_libs = if sess.opts.unstable_opts.packed_bundled_libs {\n-                    codegen_results.crate_info.native_libraries[&cnum]\n+    let search_paths = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // We may not pass all crates through to the linker. Some crates may appear statically in\n+        // an existing dylib, meaning we'll pick up all the symbols from the dylib.\n+        // We must always link crates `compiler_builtins` and `profiler_builtins` statically.\n+        // Even if they were already included into a dylib\n+        // (e.g. `libstd` when `-C prefer-dynamic` is used).\n+        // FIXME: `dependency_formats` can report `profiler_builtins` as `NotLinked` for some\n+        // reason, it shouldn't do that because `profiler_builtins` should indeed be linked.\n+        let linkage = data[cnum.as_usize() - 1];\n+        let link_static_crate = linkage == Linkage::Static\n+            || (linkage == Linkage::IncludedFromDylib || linkage == Linkage::NotLinked)\n+                && (codegen_results.crate_info.compiler_builtins == Some(cnum)\n+                    || codegen_results.crate_info.profiler_runtime == Some(cnum));\n+\n+        let mut bundled_libs = Default::default();\n+        match linkage {\n+            Linkage::Static | Linkage::IncludedFromDylib | Linkage::NotLinked => {\n+                if link_static_crate {\n+                    bundled_libs = codegen_results.crate_info.native_libraries[&cnum]\n                         .iter()\n                         .filter_map(|lib| lib.filename)\n-                        .collect::<FxHashSet<_>>()\n-                } else {\n-                    Default::default()\n-                };\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &bundled_libs,\n-                );\n-\n-                // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n-                // is being linked statically to the current crate.  If it's linked dynamically\n-                // or is an rlib already included via some other dylib crate, the symbols from\n-                // native libs will have already been included in that dylib.\n-                //\n-                // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-                // external build system already has the native dependencies defined, and it\n-                // will provide them to the linker itself.\n-                if sess.opts.unstable_opts.link_native_libraries {\n-                    if sess.opts.unstable_opts.packed_bundled_libs {\n-                        // If rlib contains native libs as archives, unpack them to tmpdir.\n-                        let rlib = &src.rlib.as_ref().unwrap().0;\n-                        archive_builder_builder\n-                            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.emit_fatal(e));\n-                    }\n-\n-                    let mut last = (None, NativeLibKind::Unspecified, None);\n-                    for lib in &codegen_results.crate_info.native_libraries[&cnum] {\n-                        let Some(name) = lib.name else {\n-                            continue;\n-                        };\n-                        let name = name.as_str();\n-                        if !relevant_lib(sess, lib) {\n-                            continue;\n-                        }\n-\n-                        // Skip if this library is the same as the last.\n-                        last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                            continue;\n-                        } else {\n-                            (lib.name, lib.kind, lib.verbatim)\n-                        };\n-\n-                        match lib.kind {\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(true),\n-                            } => {\n-                                cmd.link_whole_staticlib(\n-                                    name,\n-                                    lib.verbatim.unwrap_or(false),\n-                                    search_path.get_or_init(|| archive_search_paths(sess)),\n-                                );\n-                            }\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(false) | None,\n-                            } => {\n-                                // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                                // with glibc. This logic should be moved to the libc crate.\n-                                if sess.target.os == \"linux\"\n-                                    && sess.target.env == \"gnu\"\n-                                    && name == \"c\"\n-                                {\n-                                    cmd.link_staticlib(\"gcc\", false);\n-                                }\n-                                cmd.link_staticlib(name, lib.verbatim.unwrap_or(false));\n-                            }\n-                            NativeLibKind::LinkArg => {\n-                                cmd.arg(name);\n-                            }\n-                            NativeLibKind::Dylib { .. }\n-                            | NativeLibKind::Framework { .. }\n-                            | NativeLibKind::Unspecified\n-                            | NativeLibKind::RawDylib => {}\n-                            NativeLibKind::Static { bundle: Some(true) | None, whole_archive } => {\n-                                if sess.opts.unstable_opts.packed_bundled_libs {\n-                                    // If rlib contains native libs as archives, they are unpacked to tmpdir.\n-                                    let path = tmpdir.join(lib.filename.unwrap().as_str());\n-                                    if whole_archive == Some(true) {\n-                                        cmd.link_whole_rlib(&path);\n-                                    } else {\n-                                        cmd.link_rlib(&path);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n+                        .collect();\n+                    add_static_crate(\n+                        cmd,\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        tmpdir,\n+                        cnum,\n+                        &bundled_libs,\n+                    );\n                 }\n             }\n-            Linkage::Dynamic => add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0),\n+            Linkage::Dynamic => {\n+                let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0);\n+            }\n         }\n-    }\n \n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate(\n+        // Static libraries are linked for a subset of linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we do not link\n+        // the native library because it is already linked into the dylib, and even if\n+        // inline/const/generic functions from the dylib can refer to symbols from the native\n+        // library, those symbols should be exported and available from the dylib anyway.\n+        // 3. Libraries bundled into `(compiler,profiler)_builtins` are special, see above.\n+        let link_static = link_static_crate;\n+        // Dynamic libraries are not linked here, see the FIXME in `add_upstream_native_libraries`.\n+        let link_dynamic = false;\n+        add_native_libs_from_crate(\n             cmd,\n             sess,\n             archive_builder_builder,\n             codegen_results,\n             tmpdir,\n+            &search_paths,\n+            &bundled_libs,\n             cnum,\n-            &Default::default(),\n+            link_static,\n+            link_dynamic,\n         );\n     }\n+}\n \n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(target: &Target, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !target.is_like_windows { &stem[3..] } else { stem }\n+fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    let search_path = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // Static libraries are not linked here, they are linked in `add_upstream_rust_crates`.\n+        // FIXME: Merge this function to `add_upstream_rust_crates` so that all native libraries\n+        // are linked together with their respective upstream crates, and in their originally\n+        // specified order. This is slightly breaking due to our use of `--as-needed` (see crater\n+        // results in https://github.com/rust-lang/rust/pull/102832#issuecomment-1279772306).\n+        let link_static = false;\n+        // Dynamic libraries are linked for all linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we have to link\n+        // the native library too because inline/const/generic functions from the dylib can refer\n+        // to symbols from the native library, so the native library providing those symbols should\n+        // be available when linking our final binary.\n+        let link_dynamic = true;\n+        add_native_libs_from_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            &search_path,\n+            &Default::default(),\n+            cnum,\n+            link_static,\n+            link_dynamic,\n+        );\n     }\n+}\n \n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO,\n-    // namely that we remove upstream object files.\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // Note, however, that if we're not doing LTO we can just pass the rlib\n-    // blindly to the linker (fast) because it's fine if it's not actually\n-    // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a>(\n-        cmd: &mut dyn Linker,\n-        sess: &'a Session,\n-        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n-        codegen_results: &CodegenResults,\n-        tmpdir: &Path,\n-        cnum: CrateNum,\n-        bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        let mut link_upstream = |path: &Path| {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n-        };\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess)\n-            || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && !skip_native\n-        {\n-            link_upstream(cratepath);\n-            return;\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-        let bundled_lib_file_names = bundled_lib_file_names.clone();\n-\n-        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n-            let canonical_name = name.replace('-', \"_\");\n-            let upstream_rust_objects_already_included =\n-                are_upstream_rust_objects_already_included(sess);\n-            let is_builtins = sess.target.no_builtins\n-                || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n-\n-            let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(error) = archive.add_archive(\n-                cratepath,\n-                Box::new(move |f| {\n-                    if f == METADATA_FILENAME {\n-                        return true;\n-                    }\n+// Adds the static \"rlib\" versions of all crates to the command line.\n+// There's a bit of magic which happens here specifically related to LTO,\n+// namely that we remove upstream object files.\n+//\n+// When performing LTO, almost(*) all of the bytecode from the upstream\n+// libraries has already been included in our object file output. As a\n+// result we need to remove the object files in the upstream libraries so\n+// the linker doesn't try to include them twice (or whine about duplicate\n+// symbols). We must continue to include the rest of the rlib, however, as\n+// it may contain static native libraries which must be linked in.\n+//\n+// (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+// their bytecode wasn't included. The object files in those libraries must\n+// still be passed to the linker.\n+//\n+// Note, however, that if we're not doing LTO we can just pass the rlib\n+// blindly to the linker (fast) because it's fine if it's not actually\n+// included as we're at the end of the dependency chain.\n+fn add_static_crate<'a>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    cnum: CrateNum,\n+    bundled_lib_file_names: &FxHashSet<Symbol>,\n+) {\n+    let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+    let cratepath = &src.rlib.as_ref().unwrap().0;\n \n-                    let canonical = f.replace('-', \"_\");\n-\n-                    let is_rust_object =\n-                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n-\n-                    // If we've been requested to skip all native object files\n-                    // (those not generated by the rust compiler) then we can skip\n-                    // this file. See above for why we may want to do this.\n-                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                    // If we're performing LTO and this is a rust-generated object\n-                    // file, then we don't need the object file as it's part of the\n-                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                    // though, so we let that object file slide.\n-                    let skip_because_lto =\n-                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n-\n-                    // We skip native libraries because:\n-                    // 1. This native libraries won't be used from the generated rlib,\n-                    //    so we can throw them away to avoid the copying work.\n-                    // 2. We can't allow it to be a single remaining entry in archive\n-                    //    as some linkers may complain on that.\n-                    if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n-                        return true;\n-                    }\n+    let mut link_upstream = |path: &Path| {\n+        cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n+    };\n \n-                    if skip_because_cfg_say_so || skip_because_lto {\n-                        return true;\n-                    }\n+    // See the comment above in `link_staticlib` and `link_rlib` for why if\n+    // there's a static library that's not relevant we skip all object\n+    // files.\n+    let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+    let skip_native = native_libs.iter().any(|lib| {\n+        matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+            && !relevant_lib(sess, lib)\n+    });\n \n-                    false\n-                }),\n-            ) {\n-                sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n-            }\n-            if archive.build(&dst) {\n-                link_upstream(&dst);\n-            }\n-        });\n+    if (!are_upstream_rust_objects_already_included(sess)\n+        || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n+        && !skip_native\n+    {\n+        link_upstream(cratepath);\n+        return;\n     }\n \n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(\n-            &unlib(&sess.target, filestem),\n-            parent.unwrap_or_else(|| Path::new(\"\")),\n-        );\n-    }\n-}\n+    let dst = tmpdir.join(cratepath.file_name().unwrap());\n+    let name = cratepath.file_name().unwrap().to_str().unwrap();\n+    let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+    let bundled_lib_file_names = bundled_lib_file_names.clone();\n \n-/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n-/// native dependencies are all non-static dependencies. We've got two cases then:\n-///\n-/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n-/// the rlib is just an archive.\n-///\n-/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n-/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n-/// dynamic dependency to this crate as well.\n-///\n-/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n-/// purely an implementation detail of the crate itself, but the problem arises with generic and\n-/// inlined functions. If a generic function calls a native function, then the generic function\n-/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n-/// in the target crate.\n-fn add_upstream_native_libraries(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n-    let mut last = (None, NativeLibKind::Unspecified, None);\n-    for &cnum in &codegen_results.crate_info.used_crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let Some(name) = lib.name else {\n-                continue;\n-            };\n-            let name = name.as_str();\n-            if !relevant_lib(sess, &lib) {\n-                continue;\n-            }\n+    sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n+        let canonical_name = name.replace('-', \"_\");\n+        let upstream_rust_objects_already_included =\n+            are_upstream_rust_objects_already_included(sess);\n+        let is_builtins =\n+            sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            // Skip if this library is the same as the last.\n-            last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                continue;\n-            } else {\n-                (lib.name, lib.kind, lib.verbatim)\n-            };\n+        let mut archive = archive_builder_builder.new_archive_builder(sess);\n+        if let Err(e) = archive.add_archive(\n+            cratepath,\n+            Box::new(move |f| {\n+                if f == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            let verbatim = lib.verbatim.unwrap_or(false);\n-            match lib.kind {\n-                NativeLibKind::Dylib { as_needed } => {\n-                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                let canonical = f.replace('-', \"_\");\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto =\n+                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+\n+                // We skip native libraries because:\n+                // 1. This native libraries won't be used from the generated rlib,\n+                //    so we can throw them away to avoid the copying work.\n+                // 2. We can't allow it to be a single remaining entry in archive\n+                //    as some linkers may complain on that.\n+                if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n+                    return true;\n                 }\n-                NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-                NativeLibKind::Framework { as_needed } => {\n-                    cmd.link_framework(name, as_needed.unwrap_or(true))\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    return true;\n                 }\n-                // ignore static native libraries here as we've\n-                // already included them in add_local_native_libraries and\n-                // add_upstream_rust_crates\n-                NativeLibKind::Static { .. } => {}\n-                NativeLibKind::RawDylib | NativeLibKind::LinkArg => {}\n-            }\n+\n+                false\n+            }),\n+        ) {\n+            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n         }\n-    }\n+        if archive.build(&dst) {\n+            link_upstream(&dst);\n+        }\n+    });\n+}\n+\n+// Same thing as above, but for dynamic crates instead of static crates.\n+fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+    // Just need to tell the linker about where the library lives and\n+    // what its name is\n+    let parent = cratepath.parent();\n+    if let Some(dir) = parent {\n+        cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+    }\n+    let stem = cratepath.file_stem().unwrap().to_str().unwrap();\n+    // Convert library file-stem into a cc -l argument.\n+    let prefix = if stem.starts_with(\"lib\") && !sess.target.is_like_windows { 3 } else { 0 };\n+    cmd.link_rust_dylib(&stem[prefix..], parent.unwrap_or_else(|| Path::new(\"\")));\n }\n \n fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {"}, {"sha": "7f0c2861f7e29014de16da9d8817dc50a7c8c6c6", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1260,11 +1260,11 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: &str, _verbatim: bool, _search_path: &[PathBuf]) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(\"-l\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n-        self.cmd.arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn gc_sections(&mut self, _keep_metadata: bool) {"}, {"sha": "780a3850036816c00f50dcb623b89cc47d3bc8de", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -60,7 +60,7 @@ impl MetadataLoader for DefaultMetadataLoader {\n                     let data = entry\n                         .data(data)\n                         .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n-                    return search_for_metadata(path, data, \".rmeta\");\n+                    return search_for_section(path, data, \".rmeta\");\n                 }\n             }\n \n@@ -69,11 +69,11 @@ impl MetadataLoader for DefaultMetadataLoader {\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        load_metadata_with(path, |data| search_for_metadata(path, data, \".rustc\"))\n+        load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n     }\n }\n \n-fn search_for_metadata<'a>(\n+pub(super) fn search_for_section<'a>(\n     path: &Path,\n     bytes: &'a [u8],\n     section: &str,\n@@ -223,7 +223,11 @@ pub enum MetadataPosition {\n // * ELF - All other targets are similar to Windows in that there's a\n //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n //   automatically removed from the final output.\n-pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataPosition) {\n+pub fn create_wrapper_file(\n+    sess: &Session,\n+    section_name: Vec<u8>,\n+    data: &[u8],\n+) -> (Vec<u8>, MetadataPosition) {\n     let Some(mut file) = create_object_file(sess) else {\n         // This is used to handle all \"other\" targets. This includes targets\n         // in two categories:\n@@ -241,11 +245,11 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataP\n         // WebAssembly and for targets not supported by the `object` crate\n         // yet it means that work will need to be done in the `object` crate\n         // to add a case above.\n-        return (metadata.to_vec(), MetadataPosition::Last);\n+        return (data.to_vec(), MetadataPosition::Last);\n     };\n     let section = file.add_section(\n         file.segment_name(StandardSegment::Debug).to_vec(),\n-        b\".rmeta\".to_vec(),\n+        section_name,\n         SectionKind::Debug,\n     );\n     match file.format() {\n@@ -259,7 +263,7 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataP\n         }\n         _ => {}\n     };\n-    file.append_section_data(section, metadata, 1);\n+    file.append_section_data(section, data, 1);\n     (file.write().unwrap(), MetadataPosition::First)\n }\n "}, {"sha": "4f396e970ad70969228cae3756eec5273af4a483", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -833,20 +833,30 @@ impl CrateInfo {\n         //\n         // In order to get this left-to-right dependency ordering, we use the reverse\n         // postorder of all crates putting the leaves at the right-most positions.\n-        let used_crates = tcx\n+        let mut compiler_builtins = None;\n+        let mut used_crates: Vec<_> = tcx\n             .postorder_cnums(())\n             .iter()\n             .rev()\n             .copied()\n-            .filter(|&cnum| !tcx.dep_kind(cnum).macros_only())\n+            .filter(|&cnum| {\n+                let link = !tcx.dep_kind(cnum).macros_only();\n+                if link && tcx.is_compiler_builtins(cnum) {\n+                    compiler_builtins = Some(cnum);\n+                    return false;\n+                }\n+                link\n+            })\n             .collect();\n+        // `compiler_builtins` are always placed last to ensure that they're linked correctly.\n+        used_crates.extend(compiler_builtins);\n \n         let mut info = CrateInfo {\n             target_cpu,\n             exported_symbols,\n             linked_symbols,\n             local_crate_name,\n-            compiler_builtins: None,\n+            compiler_builtins,\n             profiler_runtime: None,\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n@@ -872,9 +882,6 @@ impl CrateInfo {\n \n             let used_crate_source = tcx.used_crate_source(cnum);\n             info.used_crate_source.insert(cnum, used_crate_source.clone());\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n             if tcx.is_profiler_runtime(cnum) {\n                 info.profiler_runtime = Some(cnum);\n             }"}, {"sha": "bfc4515de0984405ecb640911b802296ab1a109a", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -507,6 +507,9 @@ pub enum ExtractBundledLibsError<'a> {\n \n     #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n     WriteFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n+    ExtractSection { rlib: &'a Path, error: Box<dyn std::error::Error> },\n }\n \n #[derive(Diagnostic)]\n@@ -521,3 +524,9 @@ pub enum AppleSdkRootError<'a> {\n     #[diag(codegen_ssa_apple_sdk_error_sdk_path)]\n     SdkPath { sdk_name: &'a str, error: Error },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_read_file)]\n+pub struct ReadFileError {\n+    pub message: std::io::Error,\n+}"}, {"sha": "6015d48decae930ac7cfc764663680d25d830c8b", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -15,7 +15,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) -> (Bx::Value, Bx::Value) {\n     let layout = bx.layout_of(t);\n     debug!(\"size_and_align_of_dst(ty={}, info={:?}): layout: {:?}\", t, info, layout);\n-    if !layout.is_unsized() {\n+    if layout.is_sized() {\n         let size = bx.const_usize(layout.size.bytes());\n         let align = bx.const_usize(layout.align.abi.bytes());\n         return (size, align);"}, {"sha": "908555385891d85417e4710ad4b860b790e43676", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 149, "deletions": 53, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -29,7 +29,7 @@ pub struct PlaceRef<'tcx, V> {\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(llval: V, layout: TyAndLayout<'tcx>) -> PlaceRef<'tcx, V> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n@@ -38,7 +38,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         layout: TyAndLayout<'tcx>,\n         align: Align,\n     ) -> PlaceRef<'tcx, V> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n \n@@ -48,7 +48,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         layout: TyAndLayout<'tcx>,\n     ) -> Self {\n-        assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n+        assert!(layout.is_sized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n@@ -145,7 +145,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 );\n                 return simple();\n             }\n-            _ if !field.is_unsized() => return simple(),\n+            _ if field.is_sized() => return simple(),\n             ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(),\n             ty::Adt(def, _) => {\n                 if def.repr().packed() {\n@@ -209,7 +209,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n-        let cast_to = bx.cx().immediate_backend_type(bx.cx().layout_of(cast_to));\n+        let cast_to_layout = bx.cx().layout_of(cast_to);\n+        let cast_to_size = cast_to_layout.layout.size();\n+        let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n@@ -229,7 +231,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Read the tag/niche-encoded discriminant from memory.\n         let tag = self.project_field(bx, tag_field);\n-        let tag = bx.load_operand(tag);\n+        let tag_op = bx.load_operand(tag);\n+        let tag_imm = tag_op.immediate();\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n         match *tag_encoding {\n@@ -242,68 +245,161 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(tag.immediate(), cast_to, signed)\n+                bx.intcast(tag_imm, cast_to, signed)\n             }\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                // Rebase from niche values to discriminants, and check\n-                // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n-                let tag = tag.immediate();\n-\n-                // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-                // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-                // we remap `niche_start..=niche_start + n` (which may wrap around)\n-                // to (non-wrap-around) `0..=n`, to be able to check whether the\n-                // discriminant corresponds to a niche variant with one comparison.\n-                // We also can't go directly to the (variant index) discriminant\n-                // and check that it is in the range `niche_variants`, because\n-                // that might not fit in the same type, on top of needing an extra\n-                // comparison (see also the comment on `let niche_discr`).\n-                let relative_discr = if niche_start == 0 {\n-                    // Avoid subtracting `0`, which wouldn't work for pointers.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    tag\n+                // Cast to an integer so we don't have to treat a pointer as a\n+                // special case.\n+                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n+                    let t = bx.type_isize();\n+                    let tag = bx.ptrtoint(tag_imm, t);\n+                    (tag, t)\n                 } else {\n-                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n                 };\n+\n+                let tag_size = tag_scalar.size(bx.cx());\n+                let max_unsigned = tag_size.unsigned_int_max();\n+                let max_signed = tag_size.signed_int_max() as u128;\n+                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let is_niche = if relative_max == 0 {\n-                    // Avoid calling `const_uint`, which wouldn't work for pointers.\n-                    // Also use canonical == 0 instead of non-canonical u<= 0.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    bx.icmp(IntPredicate::IntEQ, relative_discr, bx.cx().const_null(niche_llty))\n+                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+                let range = tag_scalar.valid_range(bx.cx());\n+\n+                let sle = |lhs: u128, rhs: u128| -> bool {\n+                    // Signed and unsigned comparisons give the same results,\n+                    // except that in signed comparisons an integer with the\n+                    // sign bit set is less than one with the sign bit clear.\n+                    // Toggle the sign bit to do a signed comparison.\n+                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n+                };\n+\n+                // We have a subrange `niche_start..=niche_end` inside `range`.\n+                // If the value of the tag is inside this subrange, it's a\n+                // \"niche value\", an increment of the discriminant. Otherwise it\n+                // indicates the untagged variant.\n+                // A general algorithm to extract the discriminant from the tag\n+                // is:\n+                // relative_tag = tag - niche_start\n+                // is_niche = relative_tag <= (ule) relative_max\n+                // discr = if is_niche {\n+                //     cast(relative_tag) + niche_variants.start()\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // However, we will likely be able to emit simpler code.\n+\n+                // Find the least and greatest values in `range`, considered\n+                // both as signed and unsigned.\n+                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n+                    (range.start, range.end)\n+                } else {\n+                    (0, max_unsigned)\n+                };\n+                let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                    (range.start, range.end)\n                 } else {\n-                    let relative_max = bx.cx().const_uint(niche_llty, relative_max as u64);\n-                    bx.icmp(IntPredicate::IntULE, relative_discr, relative_max)\n+                    (min_signed, max_signed)\n+                };\n+\n+                let niches_ule = niche_start <= niche_end;\n+                let niches_sle = sle(niche_start, niche_end);\n+                let cast_smaller = cast_to_size <= tag_size;\n+\n+                // In the algorithm above, we can change\n+                // cast(relative_tag) + niche_variants.start()\n+                // into\n+                // cast(tag) + (niche_variants.start() - niche_start)\n+                // if either the casted type is no larger than the original\n+                // type, or if the niche values are contiguous (in either the\n+                // signed or unsigned sense).\n+                let can_incr_after_cast = cast_smaller || niches_ule || niches_sle;\n+\n+                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n+                    if !can_incr_after_cast {\n+                        None\n+                    } else if niche_start == low_unsigned {\n+                        Some((IntPredicate::IntULE, niche_end))\n+                    } else if niche_end == high_unsigned {\n+                        Some((IntPredicate::IntUGE, niche_start))\n+                    } else if niche_start == low_signed {\n+                        Some((IntPredicate::IntSLE, niche_end))\n+                    } else if niche_end == high_signed {\n+                        Some((IntPredicate::IntSGE, niche_start))\n+                    } else {\n+                        None\n+                    }\n                 };\n \n-                // NOTE(eddyb) this addition needs to be performed on the final\n-                // type, in case the niche itself can't represent all variant\n-                // indices (e.g. `u8` niche with more than `256` variants,\n-                // but enough uninhabited variants so that the remaining variants\n-                // fit in the niche).\n-                // In other words, `niche_variants.end - niche_variants.start`\n-                // is representable in the niche, but `niche_variants.end`\n-                // might not be, in extreme cases.\n-                let niche_discr = {\n-                    let relative_discr = if relative_max == 0 {\n-                        // HACK(eddyb) since we have only one niche, we know which\n-                        // one it is, and we can avoid having a dynamic value here.\n-                        bx.cx().const_uint(cast_to, 0)\n+                let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                    // Best case scenario: only one tagged variant. This will\n+                    // likely become just a comparison and a jump.\n+                    // The algorithm is:\n+                    // is_niche = tag == niche_start\n+                    // discr = if is_niche {\n+                    //     niche_start\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    let niche_start = bx.cx().const_uint_big(tag_llty, niche_start);\n+                    let is_niche = bx.icmp(IntPredicate::IntEQ, tag, niche_start);\n+                    let tagged_discr =\n+                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n+                    (is_niche, tagged_discr, 0)\n+                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                    // The niche values are either the lowest or the highest in\n+                    // `range`. We can avoid the first subtraction in the\n+                    // algorithm.\n+                    // The algorithm is now this:\n+                    // is_niche = tag <= niche_end\n+                    // discr = if is_niche {\n+                    //     cast(tag) + (niche_variants.start() - niche_start)\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    // (the first line may instead be tag >= niche_start,\n+                    // and may be a signed or unsigned comparison)\n+                    let is_niche =\n+                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n+                    let cast_tag = if cast_smaller {\n+                        bx.intcast(tag, cast_to, false)\n+                    } else if niches_ule {\n+                        bx.zext(tag, cast_to)\n                     } else {\n-                        bx.intcast(relative_discr, cast_to, false)\n+                        bx.sext(tag, cast_to)\n                     };\n-                    bx.add(\n+\n+                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                    (is_niche, cast_tag, delta)\n+                } else {\n+                    // The special cases don't apply, so we'll have to go with\n+                    // the general algorithm.\n+                    let relative_discr = bx.sub(tag, bx.cx().const_uint_big(tag_llty, niche_start));\n+                    let cast_tag = bx.intcast(relative_discr, cast_to, false);\n+                    let is_niche = bx.icmp(\n+                        IntPredicate::IntULE,\n                         relative_discr,\n-                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                    )\n+                        bx.cx().const_uint(tag_llty, relative_max as u64),\n+                    );\n+                    (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n                 };\n \n-                bx.select(\n+                let tagged_discr = if delta == 0 {\n+                    tagged_discr\n+                } else {\n+                    bx.add(tagged_discr, bx.cx().const_uint_big(cast_to, delta))\n+                };\n+\n+                let discr = bx.select(\n                     is_niche,\n-                    niche_discr,\n+                    tagged_discr,\n                     bx.cx().const_uint(cast_to, untagged_variant.as_u32() as u64),\n-                )\n+                );\n+\n+                // In principle we could insert assumes on the possible range of `discr`, but\n+                // currently in LLVM this seems to be a pessimization.\n+\n+                discr\n             }\n         }\n     }"}, {"sha": "8f5e503d659dad30b1d16c7199bfcb7dc7276bfd", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -46,7 +46,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         ecx.tcx.def_kind(cid.instance.def_id())\n     );\n     let layout = ecx.layout_of(body.bound_return_ty().subst(tcx, cid.instance.substs))?;\n-    assert!(!layout.is_unsized());\n+    assert!(layout.is_sized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n \n     trace!("}, {"sha": "ab82268dde3ab5898bce8cb11ccda94b43ec7bf9", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -572,7 +572,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         metadata: &MemPlaceMeta<M::Provenance>,\n         layout: &TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n-        if !layout.is_unsized() {\n+        if layout.is_sized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n         }\n         match layout.ty.kind() {"}, {"sha": "e68456a1d731a2989ceace8449d42c7bdc406982", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -713,7 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n     ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n \n         let get_bytes = |this: &InterpCx<'mir, 'tcx, M>,\n                          op: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,"}, {"sha": "a529972db9d6fec739332ae5b9ad2ee8f1dc5dda", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -683,7 +683,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(def_id);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                assert!(!layout.is_unsized());\n+                assert!(layout.is_sized());\n                 (layout.size, layout.align.abi, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {"}, {"sha": "f0a83b7a02689d4607e545b325e8a0ae803878e3", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -280,7 +280,7 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n     }\n }\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Read an immediate from a place, asserting that that is possible with the given layout.\n     ///\n-    /// If this suceeds, the `ImmTy` is never `Uninit`.\n+    /// If this succeeds, the `ImmTy` is never `Uninit`.\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,"}, {"sha": "29d2312612ea9fb8fa5d5dc7e5de03b54baa5320", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -201,7 +201,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n     }\n \n@@ -316,8 +316,7 @@ where\n         Ok(MPlaceTy { mplace, layout, align })\n     }\n \n-    /// Take an operand, representing a pointer, and dereference it to a place -- that\n-    /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    /// Take an operand, representing a pointer, and dereference it to a place.\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn deref_operand(\n         &self,\n@@ -331,7 +330,7 @@ where\n         }\n \n         let mplace = self.ref_to_mplace(&val)?;\n-        self.check_mplace_access(mplace, CheckInAllocMsg::DerefTest)?;\n+        self.check_mplace(mplace)?;\n         Ok(mplace)\n     }\n \n@@ -340,7 +339,7 @@ where\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        assert!(!place.layout.is_unsized());\n+        assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n         self.get_ptr_alloc(place.ptr, size, place.align)\n@@ -351,24 +350,25 @@ where\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        assert!(!place.layout.is_unsized());\n+        assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n         self.get_ptr_alloc_mut(place.ptr, size, place.align)\n     }\n \n     /// Check if this mplace is dereferenceable and sufficiently aligned.\n-    fn check_mplace_access(\n-        &self,\n-        mplace: MPlaceTy<'tcx, M::Provenance>,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n+    pub fn check_mplace(&self, mplace: MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         let (size, align) = self\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         let align = M::enforce_alignment(self).then_some(align);\n-        self.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n+        self.check_ptr_access_align(\n+            mplace.ptr,\n+            size,\n+            align.unwrap_or(Align::ONE),\n+            CheckInAllocMsg::DerefTest,\n+        )?;\n         Ok(())\n     }\n \n@@ -485,7 +485,7 @@ where\n         src: Immediate<M::Provenance>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n-        assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n+        assert!(dest.layout.is_sized(), \"Cannot write unsized data\");\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n@@ -746,7 +746,7 @@ where\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }"}, {"sha": "3c286fa61bec5c9cb1a9501924ceded45ab5d13b", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -209,7 +209,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Repeat(ref operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n-                assert!(!src.layout.is_unsized());\n+                assert!(src.layout.is_sized());\n                 let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n "}, {"sha": "fa15d466ac125cf910f3e2cbd13e27c362ee6154", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let (ty, _trait_ref) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"there are no vtables for unsized types\");\n+        assert!(layout.is_sized(), \"there are no vtables for unsized types\");\n         Ok((layout.size, layout.align.abi))\n     }\n }"}, {"sha": "11cbff8ea6a84ef7d27adf4a266866a3409848ec", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -110,11 +110,6 @@ where\n     }\n }\n \n-/// A helper trait so that `Interned` things can cache stable hashes reproducibly.\n-pub trait InternedHashingContext {\n-    fn with_def_path_and_no_spans(&mut self, f: impl FnOnce(&mut Self));\n-}\n-\n /// A helper type that you can wrap round your own type in order to automatically\n /// cache the stable hash on creation and not recompute it whenever the stable hash\n /// of the type is computed.\n@@ -161,11 +156,15 @@ impl<T> Deref for WithStableHash<T> {\n impl<T: Hash> Hash for WithStableHash<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.internee.hash(s)\n+        if self.stable_hash != Fingerprint::ZERO {\n+            self.stable_hash.hash(s)\n+        } else {\n+            self.internee.hash(s)\n+        }\n     }\n }\n \n-impl<T: HashStable<CTX>, CTX: InternedHashingContext> HashStable<CTX> for WithStableHash<T> {\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithStableHash<T> {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n             // No cached hash available. This can only mean that incremental is disabled.\n@@ -176,7 +175,7 @@ impl<T: HashStable<CTX>, CTX: InternedHashingContext> HashStable<CTX> for WithSt\n             // otherwise the hashes will differ between cached and non-cached mode.\n             let stable_hash: Fingerprint = {\n                 let mut hasher = StableHasher::new();\n-                hcx.with_def_path_and_no_spans(|hcx| self.internee.hash_stable(hcx, &mut hasher));\n+                self.internee.hash_stable(hcx, &mut hasher);\n                 hasher.finish()\n             };\n             if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {"}, {"sha": "fabd855a222f0f3e1aa97d96e580c9107737ec97", "filename": "compiler/rustc_error_codes/src/error_codes/E0706.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -56,4 +56,4 @@ You might be interested in visiting the [async book] for further information.\n [`async-trait` crate]: https://crates.io/crates/async-trait\n [async-is-hard]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\n [Generic Associated Types]: https://github.com/rust-lang/rust/issues/44265\n-[async book]: https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html\n+[async book]: https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html"}, {"sha": "de47ada826444e00644e0edfc357973969a21f20", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -70,3 +70,56 @@ borrowck_var_borrow_by_use_place_in_closure =\n \n borrowck_var_borrow_by_use_place =\n     borrow occurs due to use of {$place}\n+\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_assign_due_to_use_generator =\n+    assign occurs due to use in generator\n+\n+borrowck_assign_part_due_to_use_generator =\n+    assign to part occurs due to use in generator\n+\n+borrowck_borrow_due_to_use_closure =\n+    borrow occurs due to use in closure\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_assign_due_to_use_closure =\n+    assign occurs due to use in closure\n+\n+borrowck_assign_part_due_to_use_closure =\n+    assign to part occurs due to use in closure\n+\n+borrowck_capture_immute =\n+    capture is immutable because of use here\n+\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n+\n+borrowck_capture_move =\n+    capture is moved because of use here\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here"}, {"sha": "eb6b403d00e88943e8eddd6f32d66bce672b0bc4", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -182,3 +182,5 @@ codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$\n codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n \n codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {error}\n+\n+codegen_ssa_read_file = failed to read file: {message}"}, {"sha": "d27edd47470e83a60c74dd527f9317c1bbad4b7b", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -150,3 +150,6 @@ hir_analysis_const_bound_for_non_const_trait =\n hir_analysis_self_in_impl_self =\n     `Self` is not valid in the self type of an impl block\n     .note = replace `Self` with a different type\n+\n+hir_analysis_op_trait_generic_params =\n+    `{$method_name}` must not have any generic parameters"}, {"sha": "c9d83746d5454debb5f9e21fb847cc1a3cd863bb", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -126,10 +126,10 @@ infer_data_lifetime_flow = ...but data with one lifetime flows into the other he\n infer_declared_multiple = this type is declared with multiple lifetimes...\n infer_types_declared_different = these two types are declared with different lifetimes...\n infer_data_flows = ...but data{$label_var1_exists ->\n-    [true] -> {\" \"}from `{$label_var1}`\n+    [true] {\" \"}from `{$label_var1}`\n     *[false] -> {\"\"}\n } flows{$label_var2_exists ->\n-    [true] -> {\" \"}into `{$label_var2}`\n+    [true] {\" \"}into `{$label_var2}`\n     *[false] -> {\"\"}\n } here\n "}, {"sha": "815e8f4d3567e6beee5c908fa23e3a8f7c672eb6", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -375,3 +375,12 @@ parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n \n parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n     .suggestion = use single colon\n+\n+parser_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list"}, {"sha": "0b1b75471a661cefaa5d530e0534cb85ea868ea7", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -30,7 +30,8 @@ use intl_memoizer::concurrent::IntlLangMemoizer;\n #[cfg(not(parallel_compiler))]\n use intl_memoizer::IntlLangMemoizer;\n \n-pub use fluent_bundle::{FluentArgs, FluentError, FluentValue};\n+pub use fluent_bundle::{self, FluentArgs, FluentError, FluentValue};\n+\n pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module."}, {"sha": "66c986977eccb78c1ad58e2c9adc9c22a69f93e4", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -64,8 +64,7 @@ impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n-#[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n+#[rustc_diagnostic_item = \"AddToDiagnostic\"]\n pub trait AddToDiagnostic\n where\n     Self: Sized,\n@@ -742,7 +741,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = String>,\n+        suggestions: impl IntoIterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestions_with_style(\n@@ -759,11 +758,11 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = String>,\n+        suggestions: impl IntoIterator<Item = String>,\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n-        let mut suggestions: Vec<_> = suggestions.collect();\n+        let mut suggestions: Vec<_> = suggestions.into_iter().collect();\n         suggestions.sort();\n \n         debug_assert!(\n@@ -790,10 +789,10 @@ impl Diagnostic {\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n+        suggestions: impl IntoIterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        let suggestions: Vec<_> = suggestions.collect();\n+        let suggestions: Vec<_> = suggestions.into_iter().collect();\n         debug_assert!(\n             !(suggestions\n                 .iter()"}, {"sha": "a2ed988643ff2a4ef2589ba99046d045725e250f", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -16,8 +16,7 @@ use std::thread::panicking;\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Diagnostic)]` -- see [rustc_macros::Diagnostic].\n-#[cfg_attr(bootstrap, rustc_diagnostic_item = \"SessionDiagnostic\")]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"IntoDiagnostic\")]\n+#[rustc_diagnostic_item = \"IntoDiagnostic\"]\n pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     /// Write out as a diagnostic out of `Handler`.\n     #[must_use]\n@@ -599,13 +598,13 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         &mut self,\n         sp: Span,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = String>,\n+        suggestions: impl IntoIterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n+        suggestions: impl IntoIterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_short("}, {"sha": "170d4341ae71b4a3356a12a7c6d03b60d9021f4f", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1254,6 +1254,10 @@ impl HandlerInner {\n         }\n \n         if diagnostic.has_future_breakage() {\n+            // Future breakages aren't emitted if they're Level::Allowed,\n+            // but they still need to be constructed and stashed below,\n+            // so they'll trigger the good-path bug check.\n+            self.suppressed_expected_diag = true;\n             self.future_breakage_diagnostics.push(diagnostic.clone());\n         }\n "}, {"sha": "a452fac074787348a0bf5666d5b7b55cfa00421f", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,7 +1,10 @@\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::FluentArgs;\n+use rustc_error_messages::{\n+    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n+    FluentArgs, FluentError,\n+};\n use std::borrow::Cow;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n@@ -102,14 +105,31 @@ pub trait Translate {\n             .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n             .map(|(translated, errs)| {\n                 // Always bail out for errors with the fallback bundle.\n-                assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n+\n+                let mut help_messages = vec![];\n+\n+                if !errs.is_empty() {\n+                    for error in &errs {\n+                        match error {\n+                            FluentError::ResolverError(ResolverError::Reference(\n+                                ReferenceKind::Message { id, .. },\n+                            )) if args.iter().any(|(arg_id, _)| arg_id == id) => {\n+                                help_messages.push(format!(\"Argument `{id}` exists but was not referenced correctly. Try using `{{${id}}}` instead\"));\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    panic!(\n+                        \"Encountered errors while formatting message for `{identifier}`\\n\\\n+                        help: {}\\n\\\n+                        attr: `{attr:?}`\\n\\\n+                        args: `{args:?}`\\n\\\n+                        errors: `{errs:?}`\",\n+                        help_messages.join(\"\\nhelp: \")\n+                    );\n+                }\n+\n                 translated\n             })\n             .expect(\"failed to find message in primary or fallback fluent bundles\")"}, {"sha": "1294f1e17d412a7469cf564760f1df89a2f68583", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -250,6 +250,7 @@ pub trait MultiItemModifier {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n@@ -263,6 +264,7 @@ where\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n@@ -873,7 +875,7 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n-pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>)>;\n+pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>, bool)>;\n \n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;"}, {"sha": "3d37e2c6568518cf5a5615a350c4a22241e175ac", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -337,6 +337,7 @@ pub enum InvocationKind {\n     },\n     Derive {\n         path: ast::Path,\n+        is_const: bool,\n         item: Annotatable,\n     },\n }\n@@ -478,13 +479,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(path, item, _exts)| {\n+                                .map(|(path, item, _exts, is_const)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = LocalExpnId::fresh_empty();\n                                     derive_invocations.push((\n                                         Invocation {\n-                                            kind: InvocationKind::Derive { path, item },\n+                                            kind: InvocationKind::Derive { path, item, is_const },\n                                             fragment_kind,\n                                             expansion_data: ExpansionData {\n                                                 id: expn_id,\n@@ -717,7 +718,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(&self.cx.sess.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                            let items = match expander.expand(self.cx, span, &meta, item, false) {\n                                 ExpandResult::Ready(items) => items,\n                                 ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n@@ -749,19 +750,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Derive { path, item } => match ext {\n+            InvocationKind::Derive { path, item, is_const } => match ext {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n-                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                    let items = match expander.expand(self.cx, span, &meta, item, is_const) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n                             return ExpandResult::Retry(Invocation {\n-                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                kind: InvocationKind::Derive { path: meta.path, item, is_const },\n                                 ..invoc\n                             });\n                         }"}, {"sha": "63bafd7b046fb173275548d333b098ddfd4ab06a", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -52,7 +52,7 @@ impl KleeneToken {\n /// A Kleene-style [repetition operator](https://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-enum KleeneOp {\n+pub(crate) enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions"}, {"sha": "95cec8d7ae29992455c0e1ee9638ff941d5c71cc", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -73,17 +73,17 @@\n pub(crate) use NamedMatch::*;\n pub(crate) use ParseResult::*;\n \n-use crate::mbe::{KleeneOp, TokenTree};\n+use crate::mbe::{macro_rules::Tracker, KleeneOp, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_lint_defs::pluralize;\n use rustc_parse::parser::{NtOrTt, Parser};\n+use rustc_span::symbol::Ident;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n@@ -96,7 +96,8 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n ///\n /// This means a matcher can be represented by `&[MatcherLoc]`, and traversal mostly involves\n /// simply incrementing the current matcher position index by one.\n-pub(super) enum MatcherLoc {\n+#[derive(Debug)]\n+pub(crate) enum MatcherLoc {\n     Token {\n         token: Token,\n     },\n@@ -270,13 +271,17 @@ pub(crate) enum ParseResult<T> {\n     Failure(Token, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n-    ErrorReported,\n+    ErrorReported(ErrorGuaranteed),\n }\n \n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-pub(crate) type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n+pub(crate) type NamedParseResult = ParseResult<NamedMatches>;\n+\n+/// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.\n+/// This represents the mapping of metavars to the token trees they bind to.\n+pub(crate) type NamedMatches = FxHashMap<MacroRulesNormalizedIdent, NamedMatch>;\n \n /// Count how many metavars declarations are in `matcher`.\n pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n@@ -400,17 +405,21 @@ impl TtParser {\n     ///\n     /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept\n     /// track of through the mps generated.\n-    fn parse_tt_inner(\n+    fn parse_tt_inner<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            match &matcher[mp.idx] {\n+            let matcher_loc = &matcher[mp.idx];\n+            track.before_match_loc(self, matcher_loc);\n+\n+            match matcher_loc {\n                 MatcherLoc::Token { token: t } => {\n                     // If it's a doc comment, we just ignore it and move on to the next tt in the\n                     // matcher. This is a bug, but #95267 showed that existing programs rely on\n@@ -450,7 +459,7 @@ impl TtParser {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,\n-                            matches: mp.matches.clone(), // a cheap clone\n+                            matches: Lrc::clone(&mp.matches),\n                         });\n                     }\n \n@@ -463,8 +472,8 @@ impl TtParser {\n                     // sequence. If that's not possible, `ending_mp` will fail quietly when it is\n                     // processed next time around the loop.\n                     let ending_mp = MatcherPos {\n-                        idx: mp.idx + 1,             // +1 skips the Kleene op\n-                        matches: mp.matches.clone(), // a cheap clone\n+                        idx: mp.idx + 1, // +1 skips the Kleene op\n+                        matches: Lrc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -479,8 +488,8 @@ impl TtParser {\n                     // separator yet. Try ending the sequence. If that's not possible, `ending_mp`\n                     // will fail quietly when it is processed next time around the loop.\n                     let ending_mp = MatcherPos {\n-                        idx: mp.idx + 2,             // +2 skips the separator and the Kleene op\n-                        matches: mp.matches.clone(), // a cheap clone\n+                        idx: mp.idx + 2, // +2 skips the separator and the Kleene op\n+                        matches: Lrc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -552,10 +561,11 @@ impl TtParser {\n     }\n \n     /// Match the token stream from `parser` against `matcher`.\n-    pub(super) fn parse_tt(\n+    pub(super) fn parse_tt<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n         parser: &mut Cow<'_, Parser<'_>>,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n+        track: &mut T,\n     ) -> NamedParseResult {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n@@ -571,7 +581,8 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(matcher, &parser.token) {\n+            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            if let Some(res) = res {\n                 return res;\n             }\n \n@@ -612,14 +623,14 @@ impl TtParser {\n                         // edition-specific matching behavior for non-terminals.\n                         let nt = match parser.to_mut().parse_nonterminal(kind) {\n                             Err(mut err) => {\n-                                err.span_label(\n+                                let guarantee = err.span_label(\n                                     span,\n                                     format!(\n                                         \"while parsing argument for this `{kind}` macro fragment\"\n                                     ),\n                                 )\n                                 .emit();\n-                                return ErrorReported;\n+                                return ErrorReported(guarantee);\n                             }\n                             Ok(nt) => nt,\n                         };"}, {"sha": "5e17d8a021e96cf82fe1089ab864c33221a5cf1f", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 256, "deletions": 121, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -14,7 +14,9 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n+};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -33,6 +35,8 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::macro_parser::{NamedMatches, NamedParseResult};\n+\n pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -205,8 +209,32 @@ fn trace_macros_note(cx_expansions: &mut FxIndexMap<Span, Vec<String>>, sp: Span\n     cx_expansions.entry(sp).or_default().push(message);\n }\n \n+pub(super) trait Tracker<'matcher> {\n+    /// This is called before trying to match next MatcherLoc on the current token.\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc);\n+\n+    /// This is called after an arm has been parsed, either successfully or unsuccessfully. When this is called,\n+    /// `before_match_loc` was called at least once (with a `MatcherLoc::Eof`).\n+    fn after_arm(&mut self, result: &NamedParseResult);\n+\n+    /// For tracing.\n+    fn description() -> &'static str;\n+}\n+\n+/// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n+struct NoopTracker;\n+\n+impl<'matcher> Tracker<'matcher> for NoopTracker {\n+    fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n+    fn after_arm(&mut self, _: &NamedParseResult) {}\n+    fn description() -> &'static str {\n+        \"none\"\n+    }\n+}\n+\n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n /// input `arg`.\n+#[instrument(skip(cx, transparency, arg, lhses, rhses))]\n fn expand_macro<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -228,9 +256,188 @@ fn expand_macro<'cx>(\n         trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n-    // Which arm's failure should we report? (the one furthest along)\n-    let mut best_failure: Option<(Token, &str)> = None;\n+    // Track nothing for the best performance.\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut NoopTracker);\n+\n+    match try_success_result {\n+        Ok((i, named_matches)) => {\n+            let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n+                mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n+                _ => cx.span_bug(sp, \"malformed macro rhs\"),\n+            };\n+            let arm_span = rhses[i].span();\n+\n+            let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n+            // rhs has holes ( `$id` and `$(...)` that need filled)\n+            let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n+                Ok(tts) => tts,\n+                Err(mut err) => {\n+                    err.emit();\n+                    return DummyResult::any(arm_span);\n+                }\n+            };\n+\n+            // Replace all the tokens for the corresponding positions in the macro, to maintain\n+            // proper positions in error reporting, while maintaining the macro_backtrace.\n+            if rhs_spans.len() == tts.len() {\n+                tts = tts.map_enumerated(|i, tt| {\n+                    let mut tt = tt.clone();\n+                    let mut sp = rhs_spans[i];\n+                    sp = sp.with_ctxt(tt.span().ctxt());\n+                    tt.set_span(sp);\n+                    tt\n+                });\n+            }\n+\n+            if cx.trace_macros() {\n+                let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n+                trace_macros_note(&mut cx.expansions, sp, msg);\n+            }\n+\n+            let mut p = Parser::new(sess, tts, false, None);\n+            p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+\n+            if is_local {\n+                cx.resolver.record_macro_rule_usage(node_id, i);\n+            }\n+\n+            // Let the context choose how to interpret the result.\n+            // Weird, but useful for X-macros.\n+            return Box::new(ParserAnyMacro {\n+                parser: p,\n+\n+                // Pass along the original expansion site and the name of the macro\n+                // so we can print a useful error message if the parse of the expanded\n+                // macro leaves unparsed tokens.\n+                site_span: sp,\n+                macro_ident: name,\n+                lint_node_id: cx.current_expansion.lint_node_id,\n+                is_trailing_mac: cx.current_expansion.is_trailing_mac,\n+                arm_span,\n+                is_local,\n+            });\n+        }\n+        Err(CanRetry::No(_)) => {\n+            debug!(\"Will not retry matching as an error was emitted already\");\n+            return DummyResult::any(sp);\n+        }\n+        Err(CanRetry::Yes) => {\n+            // Retry and emit a better error below.\n+        }\n+    }\n+\n+    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+    assert!(try_success_result.is_err(), \"Macro matching returned a success on the second try\");\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occurred and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label)) = tracker.best_failure else {\n+        return tracker.result.expect(\"must have encountered Error or ErrorReported\");\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n+    }\n+\n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone());\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n+    DummyResult::any(sp)\n+}\n+\n+/// The tracker used for the slow error path that collects useful info for diagnostics.\n+struct CollectTrackerAndEmitter<'a, 'cx> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx> {\n+    fn before_match_loc(&mut self, _parser: &TtParser, _matcher: &'matcher MatcherLoc) {\n+        // Empty for now.\n+    }\n+\n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                unreachable!(\"should not collect detailed info for successful macro match\");\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => self.best_failure = Some((token.clone(), msg)),\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+enum CanRetry {\n+    Yes,\n+    /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n+    No(ErrorGuaranteed),\n+}\n \n+/// Try expanding the macro. Returns the index of the successful arm and its named_matches if it was successful,\n+/// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n+/// correctly.\n+#[instrument(level = \"debug\", skip(sess, arg, lhses, track), fields(tracking = %T::description()))]\n+fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+    sess: &ParseSess,\n+    name: Ident,\n+    arg: &TokenStream,\n+    lhses: &'matcher [Vec<MatcherLoc>],\n+    track: &mut T,\n+) -> Result<(usize, NamedMatches), CanRetry> {\n     // We create a base parser that can be used for the \"black box\" parts.\n     // Every iteration needs a fresh copy of that parser. However, the parser\n     // is not mutated on many of the iterations, particularly when dealing with\n@@ -252,125 +459,52 @@ fn expand_macro<'cx>(\n     // this situation.)\n     // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n-\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n+        let _tracing_span = trace_span!(\"Matching arm\", %i);\n+\n         // Take a snapshot of the state of pre-expansion gating at this point.\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n+        let result = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, track);\n+\n+        track.after_arm(&result);\n+\n+        match result {\n             Success(named_matches) => {\n+                debug!(\"Parsed arm successfully\");\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n-                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n-                };\n-                let arm_span = rhses[i].span();\n-\n-                let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n-                // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n-                    Ok(tts) => tts,\n-                    Err(mut err) => {\n-                        err.emit();\n-                        return DummyResult::any(arm_span);\n-                    }\n-                };\n-\n-                // Replace all the tokens for the corresponding positions in the macro, to maintain\n-                // proper positions in error reporting, while maintaining the macro_backtrace.\n-                if rhs_spans.len() == tts.len() {\n-                    tts = tts.map_enumerated(|i, tt| {\n-                        let mut tt = tt.clone();\n-                        let mut sp = rhs_spans[i];\n-                        sp = sp.with_ctxt(tt.span().ctxt());\n-                        tt.set_span(sp);\n-                        tt\n-                    });\n-                }\n-\n-                if cx.trace_macros() {\n-                    let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n-                    trace_macros_note(&mut cx.expansions, sp, msg);\n-                }\n-\n-                let mut p = Parser::new(sess, tts, false, None);\n-                p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n-\n-                if is_local {\n-                    cx.resolver.record_macro_rule_usage(node_id, i);\n-                }\n-\n-                // Let the context choose how to interpret the result.\n-                // Weird, but useful for X-macros.\n-                return Box::new(ParserAnyMacro {\n-                    parser: p,\n-\n-                    // Pass along the original expansion site and the name of the macro\n-                    // so we can print a useful error message if the parse of the expanded\n-                    // macro leaves unparsed tokens.\n-                    site_span: sp,\n-                    macro_ident: name,\n-                    lint_node_id: cx.current_expansion.lint_node_id,\n-                    is_trailing_mac: cx.current_expansion.is_trailing_mac,\n-                    arm_span,\n-                    is_local,\n-                });\n+                return Ok((i, named_matches));\n             }\n-            Failure(token, msg) => match best_failure {\n-                Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => best_failure = Some((token, msg)),\n-            },\n-            Error(err_sp, ref msg) => {\n-                let span = err_sp.substitute_dummy(sp);\n-                cx.struct_span_err(span, &msg).emit();\n-                return DummyResult::any(span);\n+            Failure(_, _) => {\n+                trace!(\"Failed to match arm, trying the next one\");\n+                // Try the next arm.\n+            }\n+            Error(_, _) => {\n+                debug!(\"Fatal error occurred during matching\");\n+                // We haven't emitted an error yet, so we can retry.\n+                return Err(CanRetry::Yes);\n+            }\n+            ErrorReported(guarantee) => {\n+                debug!(\"Fatal error occurred and was reported during matching\");\n+                // An error has been reported already, we cannot retry as that would cause duplicate errors.\n+                return Err(CanRetry::No(guarantee));\n             }\n-            ErrorReported => return DummyResult::any(sp),\n         }\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(parser);\n \n-    let (token, label) = best_failure.expect(\"ran no matchers\");\n-    let span = token.span.substitute_dummy(sp);\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone());\n-            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+    Err(CanRetry::Yes)\n }\n \n // Note that macro-by-example's input is also matched against a token tree:\n@@ -452,28 +586,29 @@ pub fn compile_declarative_macro(\n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n-    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n-        Success(m) => m,\n-        Failure(token, msg) => {\n-            let s = parse_failure_msg(&token);\n-            let sp = token.span.substitute_dummy(def.span);\n-            let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n-            err.span_label(sp, msg);\n-            annotate_doc_comment(&mut err, sess.source_map(), sp);\n-            err.emit();\n-            return dummy_syn_ext();\n-        }\n-        Error(sp, msg) => {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n-                .emit();\n-            return dummy_syn_ext();\n-        }\n-        ErrorReported => {\n-            return dummy_syn_ext();\n-        }\n-    };\n+    let argument_map =\n+        match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n+            Success(m) => m,\n+            Failure(token, msg) => {\n+                let s = parse_failure_msg(&token);\n+                let sp = token.span.substitute_dummy(def.span);\n+                let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n+                err.span_label(sp, msg);\n+                annotate_doc_comment(&mut err, sess.source_map(), sp);\n+                err.emit();\n+                return dummy_syn_ext();\n+            }\n+            Error(sp, msg) => {\n+                sess.parse_sess\n+                    .span_diagnostic\n+                    .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                    .emit();\n+                return dummy_syn_ext();\n+            }\n+            ErrorReported(_) => {\n+                return dummy_syn_ext();\n+            }\n+        };\n \n     let mut valid = true;\n "}, {"sha": "e9a69192068941167386c97429d4ec96bbd217b1", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -112,6 +112,7 @@ impl MultiItemModifier for DeriveProcMacro {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // We need special handling for statement items\n         // (e.g. `fn foo() { #[derive(Debug)] struct Bar; }`)"}, {"sha": "a929f6cb0a5df6d6db89b433c8f133412711e260", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -525,6 +525,13 @@ impl server::TokenStream for Rustc<'_, '_> {\n             ast::ExprKind::Lit(l) => {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(l.token_lit), l.span))\n             }\n+            ast::ExprKind::IncludedBytes(bytes) => {\n+                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n+                Ok(tokenstream::TokenStream::token_alone(\n+                    token::TokenKind::Literal(lit.token_lit),\n+                    expr.span,\n+                ))\n+            }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n                 ast::ExprKind::Lit(l) => match l.token_lit {\n                     token::Lit { kind: token::Integer | token::Float, .. } => {"}, {"sha": "1646727a1c85f9b72f14f01596b72d8a42929184", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -54,9 +54,9 @@ declare_features! (\n     /// Allows using ADX intrinsics from `core::arch::{x86, x86_64}`.\n     (accepted, adx_target_feature, \"1.61.0\", Some(44839), None),\n     /// Allows explicit discriminants on non-unit enum variants.\n-    (accepted, arbitrary_enum_discriminant, \"CURRENT_RUSTC_VERSION\", Some(60553), None),\n+    (accepted, arbitrary_enum_discriminant, \"1.66.0\", Some(60553), None),\n     /// Allows using `sym` operands in inline assembly.\n-    (accepted, asm_sym, \"CURRENT_RUSTC_VERSION\", Some(93333), None),\n+    (accepted, asm_sym, \"1.66.0\", Some(93333), None),\n     /// Allows the definition of associated constants in `trait` or `impl` blocks.\n     (accepted, associated_consts, \"1.20.0\", Some(29646), None),\n     /// Allows using associated `type`s in `trait`s.\n@@ -174,7 +174,7 @@ declare_features! (\n     // FIXME: explain `globs`.\n     (accepted, globs, \"1.0.0\", None, None),\n     /// Allows using `..=X` as a pattern.\n-    (accepted, half_open_range_patterns, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n+    (accepted, half_open_range_patterns, \"1.66.0\", Some(67264), None),\n     /// Allows using the `u128` and `i128` types.\n     (accepted, i128_type, \"1.26.0\", Some(35118), None),\n     /// Allows the use of `if let` expressions."}, {"sha": "5cf2fdde392547979af15534f35bf10917cd814f", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -311,7 +311,7 @@ declare_features! (\n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Alows async functions to be declared, implemented, and used in traits.\n-    (incomplete, async_fn_in_trait, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n+    (incomplete, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n@@ -414,7 +414,7 @@ declare_features! (\n     /// Allows non-trivial generic constants which have to have wfness manually propagated to callers\n     (incomplete, generic_const_exprs, \"1.56.0\", Some(76560), None),\n     /// Allows using `..=X` as a patterns in slices.\n-    (active, half_open_range_patterns_in_slices, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n+    (active, half_open_range_patterns_in_slices, \"1.66.0\", Some(67264), None),\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n@@ -512,9 +512,9 @@ declare_features! (\n     (active, thread_local, \"1.0.0\", Some(29594), None),\n     /// Allows defining `trait X = A + B;` alias items.\n     (active, trait_alias, \"1.24.0\", Some(41517), None),\n-    /// Allows upcasting trait objects via supertraits.\n-    /// Trait upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n-    (incomplete, trait_upcasting, \"1.56.0\", Some(65991), None),\n+    /// Allows dyn upcasting trait objects via supertraits.\n+    /// Dyn upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n+    (active, trait_upcasting, \"1.56.0\", Some(65991), None),\n     /// Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n     /// Allows inconsistent bounds in where clauses."}, {"sha": "01477265f6175529dc07027e19467841c1ff72cd", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -147,7 +147,7 @@ pub enum AttributeDuplicates {\n     FutureWarnPreceding,\n }\n \n-/// A conveniece macro to deal with `$($expr)?`.\n+/// A convenience macro to deal with `$($expr)?`.\n macro_rules! or_default {\n     ($default:expr,) => {\n         $default"}, {"sha": "7c99896b4571427d08543e8031e4ab20b99e30b8", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 142, "deletions": 105, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -9,14 +9,15 @@ use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{self, TyCtxtInferExt};\n+use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n+use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -303,102 +304,19 @@ fn compare_predicate_entailment<'tcx>(\n     }\n \n     if let Err(terr) = result {\n-        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+        debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-        let (impl_err_span, trait_err_span) =\n-            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n-\n-        cause.span = impl_err_span;\n-\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            cause.span(),\n-            E0053,\n-            \"method `{}` has an incompatible type for trait\",\n-            trait_m.name\n-        );\n-        match &terr {\n-            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                if trait_m.fn_has_self_parameter =>\n-            {\n-                let ty = trait_sig.inputs()[0];\n-                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n-                    ExplicitSelf::ByValue => \"self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                    _ => format!(\"self: {ty}\"),\n-                };\n-\n-                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                // span points only at the type `Box<Self`>, but we want to cover the whole\n-                // argument pattern and type.\n-                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, body) => tcx\n-                        .hir()\n-                        .body_param_names(body)\n-                        .zip(sig.decl.inputs.iter())\n-                        .map(|(param, ty)| param.span.to(ty.span))\n-                        .next()\n-                        .unwrap_or(impl_err_span),\n-                    _ => bug!(\"{:?} is not a method\", impl_m),\n-                };\n-\n-                diag.span_suggestion(\n-                    span,\n-                    \"change the self-receiver type to match the trait\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                if trait_sig.inputs().len() == *i {\n-                    // Suggestion to change output type. We do not suggest in `async` functions\n-                    // to avoid complex logic or incorrect output.\n-                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, _)\n-                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                        {\n-                            let msg = \"change the output type to match the trait\";\n-                            let ap = Applicability::MachineApplicable;\n-                            match sig.decl.output {\n-                                hir::FnRetTy::DefaultReturn(sp) => {\n-                                    let sugg = format!(\"-> {} \", trait_sig.output());\n-                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                }\n-                                hir::FnRetTy::Return(hir_ty) => {\n-                                    let sugg = trait_sig.output();\n-                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                }\n-                            };\n-                        }\n-                        _ => {}\n-                    };\n-                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                    diag.span_suggestion(\n-                        impl_err_span,\n-                        \"change the parameter type to match the trait\",\n-                        trait_ty,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        infcx.err_ctxt().note_type_err(\n-            &mut diag,\n-            &cause,\n-            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-            Some(infer::ValuePairs::Terms(ExpectedFound {\n-                expected: trait_fty.into(),\n-                found: impl_fty.into(),\n-            })),\n+        let emitted = report_trait_method_mismatch(\n+            tcx,\n+            &mut cause,\n+            &infcx,\n             terr,\n-            false,\n-            false,\n+            (trait_m, trait_fty),\n+            (impl_m, impl_fty),\n+            &trait_sig,\n+            &impl_trait_ref,\n         );\n-\n-        return Err(diag.emit());\n+        return Err(emitted);\n     }\n \n     // Check that all obligations are satisfied by the implementation's\n@@ -424,6 +342,7 @@ fn compare_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn collect_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n@@ -437,7 +356,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let cause = ObligationCause::new(\n+    let mut cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -514,23 +433,35 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         }\n     }\n \n+    debug!(?trait_sig, ?impl_sig, \"equating function signatures\");\n+\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx\n-        .at(&cause, param_env)\n-        .eq(tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig)), tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig)))\n-    {\n+    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n         Ok(infer::InferOk { value: (), obligations }) => {\n             ocx.register_obligations(obligations);\n         }\n         Err(terr) => {\n-            let guar = tcx.sess.delay_span_bug(\n-                return_span,\n-                format!(\"could not unify `{trait_sig}` and `{impl_sig}`: {terr:?}\"),\n+            // This function gets called during `compare_predicate_entailment` when normalizing a\n+            // signature that contains RPITIT. When the method signatures don't match, we have to\n+            // emit an error now because `compare_predicate_entailment` will not report the error\n+            // when normalization fails.\n+            let emitted = report_trait_method_mismatch(\n+                tcx,\n+                &mut cause,\n+                infcx,\n+                terr,\n+                (trait_m, trait_fty),\n+                (impl_m, impl_fty),\n+                &trait_sig,\n+                &impl_trait_ref,\n             );\n-            return Err(guar);\n+            return Err(emitted);\n         }\n     }\n \n@@ -690,6 +621,112 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n }\n \n+fn report_trait_method_mismatch<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cause: &mut ObligationCause<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    terr: TypeError<'tcx>,\n+    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n+    trait_sig: &FnSig<'tcx>,\n+    impl_trait_ref: &TraitRef<'tcx>,\n+) -> ErrorGuaranteed {\n+    let (impl_err_span, trait_err_span) =\n+        extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+    cause.span = impl_err_span;\n+\n+    let mut diag = struct_span_err!(\n+        tcx.sess,\n+        cause.span(),\n+        E0053,\n+        \"method `{}` has an incompatible type for trait\",\n+        trait_m.name\n+    );\n+    match &terr {\n+        TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+            if trait_m.fn_has_self_parameter =>\n+        {\n+            let ty = trait_sig.inputs()[0];\n+            let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                _ => format!(\"self: {ty}\"),\n+            };\n+\n+            // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+            // span points only at the type `Box<Self`>, but we want to cover the whole\n+            // argument pattern and type.\n+            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                ImplItemKind::Fn(ref sig, body) => tcx\n+                    .hir()\n+                    .body_param_names(body)\n+                    .zip(sig.decl.inputs.iter())\n+                    .map(|(param, ty)| param.span.to(ty.span))\n+                    .next()\n+                    .unwrap_or(impl_err_span),\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n+            };\n+\n+            diag.span_suggestion(\n+                span,\n+                \"change the self-receiver type to match the trait\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+            if trait_sig.inputs().len() == *i {\n+                // Suggestion to change output type. We do not suggest in `async` functions\n+                // to avoid complex logic or incorrect output.\n+                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, _)\n+                        if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                    {\n+                        let msg = \"change the output type to match the trait\";\n+                        let ap = Applicability::MachineApplicable;\n+                        match sig.decl.output {\n+                            hir::FnRetTy::DefaultReturn(sp) => {\n+                                let sugg = format!(\"-> {} \", trait_sig.output());\n+                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                            }\n+                            hir::FnRetTy::Return(hir_ty) => {\n+                                let sugg = trait_sig.output();\n+                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                            }\n+                        };\n+                    }\n+                    _ => {}\n+                };\n+            } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n+                diag.span_suggestion(\n+                    impl_err_span,\n+                    \"change the parameter type to match the trait\",\n+                    trait_ty,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    infcx.err_ctxt().note_type_err(\n+        &mut diag,\n+        &cause,\n+        trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+        Some(infer::ValuePairs::Terms(ExpectedFound {\n+            expected: trait_fty.into(),\n+            found: impl_fty.into(),\n+        })),\n+        terr,\n+        false,\n+        false,\n+    );\n+\n+    return diag.emit();\n+}\n+\n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,"}, {"sha": "837ff0bdf3e35401f38db801d96d286d0b67874a", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -117,7 +117,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n-    let node = tcx.hir().expect_owner(def_id);\n+    let node = tcx.hir().owner(def_id);\n     match node {\n         hir::OwnerNode::Crate(_) => {}\n         hir::OwnerNode::Item(item) => check_item(tcx, item),"}, {"sha": "0e7a5ebf5ab6245e205951a36c1d8765212f3ec3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -644,40 +644,39 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n         }\n \n-        // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-            origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-            ..\n-        }) => {}\n-\n         // Don't call `type_of` on opaque types, since that depends on type\n         // checking function bodies. `check_item_type` ensures that it's called\n         // instead.\n         hir::ItemKind::OpaqueTy(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n             tcx.ensure().explicit_item_bounds(def_id);\n+            tcx.ensure().item_bounds(def_id);\n         }\n-        hir::ItemKind::TyAlias(..)\n-        | hir::ItemKind::Static(..)\n-        | hir::ItemKind::Const(..)\n-        | hir::ItemKind::Fn(..) => {\n+\n+        hir::ItemKind::TyAlias(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            match it.kind {\n-                hir::ItemKind::Fn(..) => tcx.ensure().fn_sig(def_id),\n-                hir::ItemKind::OpaqueTy(..) => tcx.ensure().item_bounds(def_id),\n-                hir::ItemKind::Const(ty, ..) | hir::ItemKind::Static(ty, ..) => {\n-                    if !is_suggestable_infer_ty(ty) {\n-                        let mut visitor = HirPlaceholderCollector::default();\n-                        visitor.visit_item(it);\n-                        placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n-                    }\n-                }\n-                _ => (),\n+        }\n+\n+        hir::ItemKind::Static(ty, ..) | hir::ItemKind::Const(ty, ..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            if !is_suggestable_infer_ty(ty) {\n+                let mut visitor = HirPlaceholderCollector::default();\n+                visitor.visit_item(it);\n+                placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n             }\n         }\n+\n+        hir::ItemKind::Fn(..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            tcx.ensure().fn_sig(def_id);\n+        }\n     }\n }\n "}, {"sha": "6ee7aa9cdac6b8ebc65b56a45732131aedc85768", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 103, "deletions": 216, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -94,11 +94,6 @@ struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n-\n-    /// Indicates that we only care about the definition of a trait. This should\n-    /// be false if the `Item` we are resolving lifetimes for is not a trait or\n-    /// we eventually need lifetimes resolve for trait items.\n-    trait_definition_only: bool,\n }\n \n #[derive(Debug)]\n@@ -166,7 +161,9 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    Root,\n+    Root {\n+        opt_parent_item: Option<LocalDefId>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -214,95 +211,58 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n-            Scope::Root => f.debug_struct(\"Root\").finish(),\n+            Scope::Root { opt_parent_item } => {\n+                f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n+            }\n         }\n     }\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n-const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n-\n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes_trait_definition,\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n+        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n-/// Also does not generate any diagnostics.\n-///\n-/// This is ultimately a subset of the `resolve_lifetimes` work. It effectively\n-/// resolves lifetimes only within the trait \"header\" -- that is, the trait\n-/// and supertrait list. In contrast, `resolve_lifetimes` resolves all the\n-/// lifetimes within the trait and its items. There is room to refactor this,\n-/// for example to resolve lifetimes for each trait item in separate queries,\n-/// but it's convenient to do the entire trait at once because the lifetimes\n-/// from the trait definition are in scope within the trait items as well.\n-///\n-/// The reason for this separate call is to resolve what would otherwise\n-/// be a cycle. Consider this example:\n-///\n-/// ```ignore UNSOLVED (maybe @jackh726 knows what lifetime parameter to give Sub)\n-/// trait Base<'a> {\n-///     type BaseItem;\n-/// }\n-/// trait Sub<'b>: for<'a> Base<'a> {\n-///    type SubItem: Sub<BaseItem = &'b u32>;\n-/// }\n-/// ```\n-///\n-/// When we resolve `Sub` and all its items, we also have to resolve `Sub<BaseItem = &'b u32>`.\n-/// To figure out the index of `'b`, we have to know about the supertraits\n-/// of `Sub` so that we can determine that the `for<'a>` will be in scope.\n-/// (This is because we -- currently at least -- flatten all the late-bound\n-/// lifetimes into a single binder.) This requires us to resolve the\n-/// *trait definition* of `Sub`; basically just enough lifetime information\n-/// to look at the supertraits.\n-#[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes_trait_definition(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n-}\n-\n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n-}\n-\n-fn do_resolve(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-    trait_definition_only: bool,\n-) -> NamedRegionMap {\n-    let item = tcx.hir().expect_item(local_def_id);\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n     let mut named_region_map =\n         NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n-        scope: ROOT_SCOPE,\n-        trait_definition_only,\n+        scope: &Scope::Root { opt_parent_item: None },\n     };\n-    visitor.visit_item(item);\n-\n-    named_region_map\n-}\n+    match tcx.hir().owner(local_def_id) {\n+        hir::OwnerNode::Item(item) => visitor.visit_item(item),\n+        hir::OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n+        hir::OwnerNode::TraitItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_trait_item(item)\n+        }\n+        hir::OwnerNode::ImplItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_impl_item(item)\n+        }\n+        hir::OwnerNode::Crate(_) => {}\n+    }\n \n-fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n@@ -319,53 +279,6 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n     rl\n }\n \n-/// Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution.\n-/// There are two important things this does.\n-/// First, we have to resolve lifetimes for\n-/// the entire *`Item`* that contains this owner, because that's the largest \"scope\"\n-/// where we can have relevant lifetimes.\n-/// Second, if we are asking for lifetimes in a trait *definition*, we use `resolve_lifetimes_trait_definition`\n-/// instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics.\n-/// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n-/// other than the trait itself (like the trait methods or associated types), then we just use the regular\n-/// `resolve_lifetimes`.\n-fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n-    let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.owner_id.def_id;\n-    if item_id.owner_id == def_id {\n-        let item = tcx.hir().item(item_id);\n-        match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n-            _ => tcx.resolve_lifetimes(local_def_id),\n-        }\n-    } else {\n-        tcx.resolve_lifetimes(local_def_id)\n-    }\n-}\n-\n-/// Finds the `Item` that contains the given `LocalDefId`\n-fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> hir::ItemId {\n-    match tcx.hir().find_by_def_id(local_def_id) {\n-        Some(Node::Item(item)) => {\n-            return item.item_id();\n-        }\n-        _ => {}\n-    }\n-    let item = {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        let mut parent_iter = tcx.hir().parent_iter(hir_id);\n-        loop {\n-            let node = parent_iter.next().map(|n| n.1);\n-            match node {\n-                Some(hir::Node::Item(item)) => break item.item_id(),\n-                Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n-                _ => {}\n-            }\n-        }\n-    };\n-    item\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -383,7 +296,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut supertrait_lifetimes = vec![];\n         loop {\n             match scope {\n-                Scope::Body { .. } | Scope::Root => {\n+                Scope::Body { .. } | Scope::Root { .. } => {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n@@ -414,21 +327,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n+    type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n         self.tcx.hir()\n     }\n \n-    // We want to nest trait/impl items in their parent, but nothing else.\n-    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n-\n-    fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n-        if !self.trait_definition_only {\n-            intravisit::walk_trait_item_ref(self, ii)\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let body = self.tcx.hir().body(body);\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |this| {\n@@ -548,7 +452,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item)\n                 });\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::TyAlias, ..\n+            }) => {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n                 // their parent opaque_ty in scope.\n@@ -557,34 +463,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.owner_id.into()) {\n-                    match node {\n-                        hir::Node::Item(parent_item) => {\n-                            let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.owner_id.def_id).owner_id.def_id,\n-                            );\n-                            // We need to add *all* deps, since opaque tys may want them from *us*\n-                            for (&owner, defs) in resolved_lifetimes.defs.iter() {\n-                                defs.iter().for_each(|(&local_id, region)| {\n-                                    self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n-                                });\n-                            }\n-                            for (&owner, late_bound_vars) in\n-                                resolved_lifetimes.late_bound_vars.iter()\n-                            {\n-                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n-                                    self.record_late_bound_vars(\n-                                        hir::HirId { owner, local_id },\n-                                        late_bound_vars.clone(),\n-                                    );\n-                                });\n-                            }\n-                            break;\n+                let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n+                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                // We need to add *all* deps, since opaque tys may want them from *us*\n+                for (&owner, defs) in resolved_lifetimes.defs.iter() {\n+                    defs.iter().for_each(|(&local_id, region)| {\n+                        self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n+                    });\n+                }\n+                for (&owner, late_bound_vars) in resolved_lifetimes.late_bound_vars.iter() {\n+                    late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                        self.record_late_bound_vars(\n+                            hir::HirId { owner, local_id },\n+                            late_bound_vars.clone(),\n+                        );\n+                    });\n+                }\n+            }\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                generics,\n+                ..\n+            }) => {\n+                // We want to start our early-bound indices at the end of the parent scope,\n+                // not including any parent `impl Trait`s.\n+                let mut lifetimes = FxIndexMap::default();\n+                debug!(?generics.params);\n+                for param in generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n+                            lifetimes.insert(def_id, reg);\n                         }\n-                        hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n-                        _ => {}\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n+\n+                let scope = Scope::Binder {\n+                    hir_id: item.hir_id(),\n+                    lifetimes,\n+                    s: self.scope,\n+                    scope_type: BinderScopeType::Normal,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| intravisit::walk_item(this, item))\n+                });\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -609,7 +534,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n                     scope_type: BinderScopeType::Normal,\n-                    s: ROOT_SCOPE,\n+                    s: self.scope,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -712,7 +637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                let (generics, bounds) = match opaque_ty.kind {\n+                match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -733,10 +658,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-                        ref generics,\n-                        bounds,\n                         ..\n-                    }) => (generics, bounds),\n+                    }) => {}\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -766,65 +689,28 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // Ensure that the parent of the def is an item, not HRTB\n                     let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                     if !parent_id.is_owner() {\n-                        if !self.trait_definition_only {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                lifetime.span,\n-                                E0657,\n-                                \"`impl Trait` can only capture lifetimes \\\n-                                    bound at the fn or impl level\"\n-                            )\n-                            .emit();\n-                        }\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime.span,\n+                            E0657,\n+                            \"`impl Trait` can only capture lifetimes bound at the fn or impl level\"\n+                        )\n+                        .emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                     if let hir::Node::Item(hir::Item {\n                         kind: hir::ItemKind::OpaqueTy { .. }, ..\n                     }) = self.tcx.hir().get(parent_id)\n                     {\n-                        if !self.trait_definition_only {\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                lifetime.span,\n-                                \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n-                            );\n-                            err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n-                            err.emit();\n-                        }\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            lifetime.span,\n+                            \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n+                        );\n+                        err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n+                        err.emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                 }\n-\n-                // We want to start our early-bound indices at the end of the parent scope,\n-                // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n-                debug!(?generics.params);\n-                for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n-                }\n-                self.record_late_bound_vars(ty.hir_id, vec![]);\n-\n-                let scope = Scope::Binder {\n-                    hir_id: ty.hir_id,\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n-                self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n-                    })\n-                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1193,12 +1079,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext {\n-            tcx: *tcx,\n-            map,\n-            scope: &wrap_scope,\n-            trait_definition_only: self.trait_definition_only,\n-        };\n+        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1303,7 +1184,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root => {\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                    {\n+                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                    }\n                     break None;\n                 }\n \n@@ -1417,7 +1304,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     err.emit();\n                     return;\n                 }\n-                Scope::Root => break,\n+                Scope::Root { .. } => break,\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n@@ -1495,7 +1382,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let mut scope = self.scope;\n                 loop {\n                     match *scope {\n-                        Scope::Root => break false,\n+                        Scope::Root { .. } => break false,\n \n                         Scope::Body { .. } => break true,\n \n@@ -1732,7 +1619,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n "}, {"sha": "55cca0cd2d7b540b2a3edad210ada95d39fc6d67", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 98, "deletions": 22, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -69,6 +69,7 @@ use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -80,6 +81,7 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n+use tracing::instrument;\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -103,13 +105,11 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n }\n \n /// Check that `impl1` is a sound specialization\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n     if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n-        debug!(\n-            \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n-            impl1_def_id, impl2_def_id, impl2_substs\n-        );\n+        debug!(?impl2_def_id, ?impl2_substs);\n \n         let parent_substs = if impl2_node.is_from_trait() {\n             impl2_substs.to_vec()\n@@ -118,12 +118,33 @@ fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node\n         };\n \n         let span = tcx.def_span(impl1_def_id);\n+        check_constness(tcx, impl1_def_id, impl2_node, span);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n         check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n+/// Check that the specializing impl `impl1` is at least as const as the base\n+/// impl `impl2`\n+fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n+    if impl2_node.is_from_trait() {\n+        // This isn't a specialization\n+        return;\n+    }\n+\n+    let impl1_constness = tcx.constness(impl1_def_id.to_def_id());\n+    let impl2_constness = tcx.constness(impl2_node.def_id());\n+\n+    if let hir::Constness::Const = impl2_constness {\n+        if let hir::Constness::NotConst = impl1_constness {\n+            tcx.sess\n+                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n+                .emit();\n+        }\n+    }\n+}\n+\n /// Given a specializing impl `impl1`, and the base impl `impl2`, returns two\n /// substitutions `(S1, S2)` that equate their trait references. The returned\n /// types are expressed in terms of the generics of `impl1`.\n@@ -278,15 +299,15 @@ fn check_static_lifetimes<'tcx>(\n \n /// Check whether predicates on the specializing impl (`impl1`) are allowed.\n ///\n-/// Each predicate `P` must be:\n+/// Each predicate `P` must be one of:\n ///\n-/// * global (not reference any parameters)\n-/// * `T: Tr` predicate where `Tr` is an always-applicable trait\n-/// * on the base `impl impl2`\n-///     * Currently this check is done using syntactic equality, which is\n-///       conservative but generally sufficient.\n-/// * a well-formed predicate of a type argument of the trait being implemented,\n+/// * Global (not reference any parameters).\n+/// * A `T: Tr` predicate where `Tr` is an always-applicable trait.\n+/// * Present on the base impl `impl2`.\n+///     * This check is done using the `trait_predicates_eq` function below.\n+/// * A well-formed predicate of a type argument of the trait being implemented,\n ///   including the `Self`-type.\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl1_def_id: LocalDefId,\n@@ -322,10 +343,7 @@ fn check_predicates<'tcx>(\n         .map(|obligation| obligation.predicate)\n         .collect()\n     };\n-    debug!(\n-        \"check_always_applicable(\\nimpl1_predicates={:?},\\nimpl2_predicates={:?}\\n)\",\n-        impl1_predicates, impl2_predicates,\n-    );\n+    debug!(?impl1_predicates, ?impl2_predicates);\n \n     // Since impls of always applicable traits don't get to assume anything, we\n     // can also assume their supertraits apply.\n@@ -373,25 +391,83 @@ fn check_predicates<'tcx>(\n     );\n \n     for (predicate, span) in impl1_predicates {\n-        if !impl2_predicates.contains(&predicate) {\n+        if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {\n             check_specialization_on(tcx, predicate, span)\n         }\n     }\n }\n \n+/// Checks if some predicate on the specializing impl (`predicate1`) is the same\n+/// as some predicate on the base impl (`predicate2`).\n+///\n+/// This basically just checks syntactic equivalence, but is a little more\n+/// forgiving since we want to equate `T: Tr` with `T: ~const Tr` so this can work:\n+///\n+/// ```ignore (illustrative)\n+/// #[rustc_specialization_trait]\n+/// trait Specialize { }\n+///\n+/// impl<T: Bound> Tr for T { }\n+/// impl<T: ~const Bound + Specialize> const Tr for T { }\n+/// ```\n+///\n+/// However, we *don't* want to allow the reverse, i.e., when the bound on the\n+/// specializing impl is not as const as the bound on the base impl:\n+///\n+/// ```ignore (illustrative)\n+/// impl<T: ~const Bound> const Tr for T { }\n+/// impl<T: Bound + Specialize> const Tr for T { } // should be T: ~const Bound\n+/// ```\n+///\n+/// So we make that check in this function and try to raise a helpful error message.\n+fn trait_predicates_eq<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate1: ty::Predicate<'tcx>,\n+    predicate2: ty::Predicate<'tcx>,\n+    span: Span,\n+) -> bool {\n+    let pred1_kind = predicate1.kind().skip_binder();\n+    let pred2_kind = predicate2.kind().skip_binder();\n+    let (trait_pred1, trait_pred2) = match (pred1_kind, pred2_kind) {\n+        (ty::PredicateKind::Trait(pred1), ty::PredicateKind::Trait(pred2)) => (pred1, pred2),\n+        // Just use plain syntactic equivalence if either of the predicates aren't\n+        // trait predicates or have bound vars.\n+        _ => return predicate1 == predicate2,\n+    };\n+\n+    let predicates_equal_modulo_constness = {\n+        let pred1_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred1 };\n+        let pred2_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred2 };\n+        pred1_unconsted == pred2_unconsted\n+    };\n+\n+    if !predicates_equal_modulo_constness {\n+        return false;\n+    }\n+\n+    // Check that the predicate on the specializing impl is at least as const as\n+    // the one on the base.\n+    match (trait_pred2.constness, trait_pred1.constness) {\n+        (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n+            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+        }\n+        _ => {}\n+    }\n+\n+    true\n+}\n+\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n-    debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n     match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(ty::TraitPredicate {\n-            trait_ref,\n-            constness: ty::BoundConstness::NotConst,\n-            polarity: _,\n-        }) => {\n+        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)"}, {"sha": "8d3acee48884d11aeced9a66eb442c4338176986", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -35,7 +35,7 @@ struct ClosureSignatures<'tcx> {\n     bound_sig: ty::PolyFnSig<'tcx>,\n     /// The signature within the function body.\n     /// This mostly differs in the sense that lifetimes are now early bound and any\n-    /// opaque types from the signature expectation are overriden in case there are\n+    /// opaque types from the signature expectation are overridden in case there are\n     /// explicit hidden types written by the user in the closure signature.\n     liberated_sig: ty::FnSig<'tcx>,\n }"}, {"sha": "71949b4211819b79d08c09b5b32872504294a3a7", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -62,6 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -1038,7 +1039,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = traits::FulfillmentContext::new_in_snapshot();\n+            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n             fcx.register_predicate_obligations(self, ok.obligations);\n             fcx.select_where_possible(&self).is_empty()\n         })"}, {"sha": "9ca7730daa68d3ee71d2b7db1b03a951841c4be1", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -30,6 +30,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         error: Option<TypeError<'tcx>>,\n     ) {\n+        if expr_ty == expected {\n+            return;\n+        }\n+\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n@@ -42,7 +46,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n-            || self.suggest_into(err, expr, expr_ty, expected);\n+            || self.suggest_into(err, expr, expr_ty, expected)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n+            || self.suggest_floating_point_literal(err, expr, expected);\n \n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);"}, {"sha": "afac6e7d94a8116ca0ef9916c61c569d1f24dbfb", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -125,3 +125,11 @@ pub struct AddMissingParenthesesInRange {\n     #[suggestion_part(code = \")\")]\n     pub right: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_op_trait_generic_params)]\n+pub struct OpMethodGenericParams {\n+    #[primary_span]\n+    pub span: Span,\n+    pub method_name: String,\n+}"}, {"sha": "e948d832e3280997fd134daf86d38b42712ce606", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -103,8 +103,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n+            // FIXME(compiler-errors): We probably should fold some of the\n+            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n+            // since some of those aren't necessarily just coerce suggestions.\n+            let _ = self.suggest_deref_ref_or_into(\n+                &mut err,\n+                expr.peel_drop_temps(),\n+                expected_ty,\n+                ty,\n+                None,\n+            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n             extend_err(&mut err);\n             err.emit();\n         }"}, {"sha": "c6bd771fad2568e4b8578316c80013836f845e38", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryRespons\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n@@ -32,9 +33,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -766,34 +765,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        let errors = self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        });\n-\n-                        if !errors.is_empty() {\n-                            return Err(());\n-                        }\n-                    }\n-                    Err(_) => return Err(()),\n+                ocx.sup(&origin, self.param_env, ret_ty, formal_ret)?;\n+                if !ocx.select_where_possible().is_empty() {\n+                    return Err(TypeError::Mismatch);\n                 }\n \n                 // Record all the argument types, with the substitutions"}, {"sha": "8cf70eb5431a8c4ec2d6fd1a11455ffb4d771158", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -597,6 +597,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let mk_trace = |span, (formal_ty, expected_ty), provided_ty| {\n+            let mismatched_ty = if expected_ty == provided_ty {\n+                // If expected == provided, then we must have failed to sup\n+                // the formal type. Avoid printing out \"expected Ty, found Ty\"\n+                // in that case.\n+                formal_ty\n+            } else {\n+                expected_ty\n+            };\n+            TypeTrace::types(&self.misc(span), true, mismatched_ty, provided_ty)\n+        };\n+\n         // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n         // We'll try to detect 4 different types of mistakes:\n         // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n@@ -661,10 +673,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // A tuple wrap suggestion actually occurs within,\n                         // so don't do anything special here.\n                         err = self.err_ctxt().report_and_explain_type_error(\n-                            TypeTrace::types(\n-                                &self.misc(*lo),\n-                                true,\n-                                formal_and_expected_inputs[mismatch_idx.into()].1,\n+                            mk_trace(\n+                                *lo,\n+                                formal_and_expected_inputs[mismatch_idx.into()],\n                                 provided_arg_tys[mismatch_idx.into()].0,\n                             ),\n                             terr,\n@@ -748,9 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors.drain_filter(|error| {\n                 let Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(Some(e))) = error else { return false };\n                 let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n-                let (expected_ty, _) = formal_and_expected_inputs[*expected_idx];\n-                let cause = &self.misc(provided_span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                let trace = mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n                 if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n                     self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                     return true;\n@@ -774,8 +783,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             let (formal_ty, expected_ty) = formal_and_expected_inputs[*expected_idx];\n             let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n-            let cause = &self.misc(provided_arg_span);\n-            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+            let trace = mk_trace(provided_arg_span, (formal_ty, expected_ty), provided_ty);\n             let mut err = self.err_ctxt().report_and_explain_type_error(trace, *err);\n             self.emit_coerce_suggestions(\n                 &mut err,\n@@ -847,8 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (formal_ty, expected_ty) = formal_and_expected_inputs[expected_idx];\n                     let (provided_ty, provided_span) = provided_arg_tys[provided_idx];\n                     if let Compatibility::Incompatible(error) = compatibility {\n-                        let cause = &self.misc(provided_span);\n-                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        let trace = mk_trace(provided_span, (formal_ty, expected_ty), provided_ty);\n                         if let Some(e) = error {\n                             self.err_ctxt().note_type_err(\n                                 &mut err,"}, {"sha": "06e6e4350fcbcb9271aac6bb5b8a850692a211b6", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -13,7 +13,7 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let annotation_span = ty.span;\n                                 err.span_suggestion(\n                                     annotation_span.with_hi(annotation_span.lo()),\n-                                    format!(\"alternatively, consider changing the type annotation\"),\n+                                    \"alternatively, consider changing the type annotation\",\n                                     suggest_annotation,\n                                     Applicability::MaybeIncorrect,\n                                 );\n@@ -1116,6 +1116,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// When expecting a `bool` and finding an `Option`, suggests using `let Some(..)` or `.is_some()`\n+    pub(crate) fn suggest_option_to_bool(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if !expected_ty.is_bool() {\n+            return false;\n+        }\n+\n+        let ty::Adt(def, _) = expr_ty.peel_refs().kind() else { return false; };\n+        if !self.tcx.is_diagnostic_item(sym::Option, def.did()) {\n+            return false;\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let cond_parent = hir.parent_iter(expr.hir_id).skip_while(|(_, node)| {\n+            matches!(node, hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, _, _), .. }) if op.node == hir::BinOpKind::And)\n+        }).next();\n+        // Don't suggest:\n+        //     `let Some(_) = a.is_some() && b`\n+        //                     ++++++++++\n+        // since the user probably just misunderstood how `let else`\n+        // and `&&` work together.\n+        if let Some((_, hir::Node::Local(local))) = cond_parent\n+            && let hir::PatKind::Path(qpath) | hir::PatKind::TupleStruct(qpath, _, _) = &local.pat.kind\n+            && let hir::QPath::Resolved(None, path) = qpath\n+            && let Some(did) = path.res.opt_def_id()\n+                .and_then(|did| self.tcx.opt_parent(did))\n+                .and_then(|did| self.tcx.opt_parent(did))\n+            && self.tcx.is_diagnostic_item(sym::Option, did)\n+        {\n+            return false;\n+        }\n+\n+        diag.span_suggestion(\n+            expr.span.shrink_to_hi(),\n+            \"use `Option::is_some` to test if the `Option` has a value\",\n+            \".is_some()\",\n+            Applicability::MachineApplicable,\n+        );\n+\n+        true\n+    }\n+\n     /// Suggest wrapping the block in square brackets instead of curly braces\n     /// in case the block was mistaken array syntax, e.g. `{ 1 }` -> `[ 1 ]`.\n     pub(crate) fn suggest_block_to_brackets(\n@@ -1157,6 +1204,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, err))]\n+    pub(crate) fn suggest_floating_point_literal(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if !expected_ty.is_floating_point() {\n+            return false;\n+        }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::LangItem(LangItem::Range, ..), [start, end], _) => {\n+                err.span_suggestion_verbose(\n+                    start.span.shrink_to_hi().with_hi(end.span.lo()),\n+                    \"remove the unnecessary `.` operator for a floating point literal\",\n+                    '.',\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::Struct(QPath::LangItem(LangItem::RangeFrom, ..), [start], _) => {\n+                err.span_suggestion_verbose(\n+                    expr.span.with_lo(start.span.hi()),\n+                    \"remove the unnecessary `.` operator for a floating point literal\",\n+                    '.',\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::Struct(QPath::LangItem(LangItem::RangeTo, ..), [end], _) => {\n+                err.span_suggestion_verbose(\n+                    expr.span.until(end.span),\n+                    \"remove the unnecessary `.` operator and add an integer part for a floating point literal\",\n+                    \"0.\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "4a8b774936543698c07c7f9bba395e96792b2a0b", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -10,6 +10,7 @@ mod suggest;\n pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n+use crate::errors::OpMethodGenericParams;\n use crate::{Expectation, FnCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -443,7 +444,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n-        assert_eq!(generics.params.len(), 0);\n+\n+        if generics.params.len() != 0 {\n+            tcx.sess.emit_fatal(OpMethodGenericParams {\n+                span: tcx.def_span(method_item.def_id),\n+                method_name: m_name.to_string(),\n+            });\n+        }\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n         let mut obligations = vec![];"}, {"sha": "43a5145b7e74d6bb974c9dd03d4e3b9df4b0c7fd", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1900,6 +1900,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Str\n                         | ty::Projection(_)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n+                        // we need to test something like  <&[_]>::len\n+                        // and Vec::function();\n+                        // <&[_]>::len doesn't need an extra \"<>\" between\n+                        // but for Adt type like Vec::function()\n+                        // we would suggest <[_]>::function();\n+                        _ if self.tcx.sess.source_map().span_wrapped_by_angle_bracket(ty.span)  => format!(\"{deref_ty}\"),\n                         _ => format!(\"<{deref_ty}>\"),\n                     };\n                     err.span_suggestion_verbose("}, {"sha": "fd3b3e4d59fa699d7570a708814025e0519e7e3e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -778,32 +778,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n \n-    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    /// then restore the flag to its original value. This flag is a\n-    /// debugging measure designed to detect cases where we start a\n-    /// snapshot, create type variables, and register obligations\n-    /// which may involve those type variables in the fulfillment cx,\n-    /// potentially leaving \"dangling type variables\" behind.\n-    /// In such cases, an assertion will fail when attempting to\n-    /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n-    ///\n-    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    /// obligations. As long as this fulfillment cx is fully drained\n-    /// before we return, this is not a problem, as there won't be any\n-    /// escaping obligations in the main cx. In those cases, you can\n-    /// use this function.\n-    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-    where\n-        F: FnOnce(&Self) -> R,\n-    {\n-        let flag = self.in_snapshot.replace(false);\n-        let result = func(self);\n-        self.in_snapshot.set(flag);\n-        result\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot<'tcx> {\n         debug!(\"start_snapshot()\");\n "}, {"sha": "efae2669006347a639c77c7243dddf9453d09e6c", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -163,7 +163,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n         // Otherwise, we need to visit the attributes in source code order, so we fetch HIR and do\n         // a standard visit.\n         // FIXME(#102522) Just iterate on attrs once that iteration order matches HIR's.\n-        _ => match tcx.hir().expect_owner(owner) {\n+        _ => match tcx.hir().owner(owner) {\n             hir::OwnerNode::Item(item) => levels.visit_item(item),\n             hir::OwnerNode::ForeignItem(item) => levels.visit_foreign_item(item),\n             hir::OwnerNode::TraitItem(item) => levels.visit_trait_item(item),"}, {"sha": "3e2efb7d3610d23a54afdef59b37a1ce543ffd5d", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -360,7 +360,7 @@ fn lint_int_literal<'tcx>(\n         }\n \n         if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n-            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n+            // The overflowing literal lint was emitted by `lint_overflowing_range_endpoint`.\n             return;\n         }\n \n@@ -429,7 +429,7 @@ fn lint_uint_literal<'tcx>(\n             }\n         }\n         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n-            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n+            // The overflowing literal lint was emitted by `lint_overflowing_range_endpoint`.\n             return;\n         }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {"}, {"sha": "ff0fb9bae923229ba85cd50d758aafe5eddbab02", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::util::elaborate_predicates_with_span;\n use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};\n@@ -87,17 +87,33 @@ declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n-        let expr = match s.kind {\n-            hir::StmtKind::Semi(ref expr) => &**expr,\n-            _ => return,\n-        };\n+        let hir::StmtKind::Semi(expr) = s.kind else { return; };\n \n         if let hir::ExprKind::Ret(..) = expr.kind {\n             return;\n         }\n \n+        if let hir::ExprKind::Match(await_expr, _arms, hir::MatchSource::AwaitDesugar) = expr.kind\n+            && let ty = cx.typeck_results().expr_ty(&await_expr)\n+            && let ty::Opaque(future_def_id, _) = ty.kind()\n+            && cx.tcx.ty_is_opaque_future(ty)\n+            // FIXME: This also includes non-async fns that return `impl Future`.\n+            && let async_fn_def_id = cx.tcx.parent(*future_def_id)\n+            && check_must_use_def(\n+                cx,\n+                async_fn_def_id,\n+                expr.span,\n+                \"output of future returned by \",\n+                \"\",\n+            )\n+        {\n+            // We have a bare `foo().await;` on an opaque type from an async function that was\n+            // annotated with `#[must_use]`.\n+            return;\n+        }\n+\n         let ty = cx.typeck_results().expr_ty(&expr);\n-        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, s.span, \"\", \"\", 1);\n+        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, expr.span, \"\", \"\", 1);\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n@@ -119,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             _ => None,\n         };\n         if let Some(def_id) = maybe_def_id {\n-            fn_warned = check_must_use_def(cx, def_id, s.span, \"return value of \", \"\");\n+            fn_warned = check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\");\n         } else if type_permits_lack_of_use {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n@@ -565,10 +581,24 @@ trait UnusedDelimLint {\n             lint.set_arg(\"delim\", Self::DELIM_STR);\n             lint.set_arg(\"item\", msg);\n             if let Some((lo, hi)) = spans {\n-                let replacement = vec![\n-                    (lo, if keep_space.0 { \" \".into() } else { \"\".into() }),\n-                    (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n-                ];\n+                let sm = cx.sess().source_map();\n+                let lo_replace =\n+                    if keep_space.0 &&\n+                        let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(\" \") {\n+                        \" \".to_string()\n+                        } else {\n+                            \"\".to_string()\n+                        };\n+\n+                let hi_replace =\n+                    if keep_space.1 &&\n+                        let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(\" \") {\n+                        \" \".to_string()\n+                        } else {\n+                            \"\".to_string()\n+                        };\n+\n+                let replacement = vec![(lo, lo_replace), (hi, hi_replace)];\n                 lint.multipart_suggestion(\n                     fluent::suggestion,\n                     replacement,\n@@ -765,6 +795,7 @@ impl UnusedParens {\n         value: &ast::Pat,\n         avoid_or: bool,\n         avoid_mut: bool,\n+        keep_space: (bool, bool),\n     ) {\n         use ast::{BindingAnnotation, PatKind};\n \n@@ -789,7 +820,7 @@ impl UnusedParens {\n             } else {\n                 None\n             };\n-            self.emit_unused_delims(cx, value.span, spans, \"pattern\", (false, false));\n+            self.emit_unused_delims(cx, value.span, spans, \"pattern\", keep_space);\n         }\n     }\n }\n@@ -798,7 +829,7 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         match e.kind {\n             ExprKind::Let(ref pat, _, _) | ExprKind::ForLoop(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n+                self.check_unused_parens_pat(cx, pat, false, false, (true, true));\n             }\n             // We ignore parens in cases like `if (((let Some(0) = Some(1))))` because we already\n             // handle a hard error for them during AST lowering in `lower_expr_mut`, but we still\n@@ -842,40 +873,41 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n         use ast::{Mutability, PatKind::*};\n+        let keep_space = (false, false);\n         match &p.kind {\n             // Do not lint on `(..)` as that will result in the other arms being useless.\n             Paren(_)\n             // The other cases do not contain sub-patterns.\n             | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => {},\n             // These are list-like patterns; parens can always be removed.\n             TupleStruct(_, _, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n-                self.check_unused_parens_pat(cx, p, false, false);\n+                self.check_unused_parens_pat(cx, p, false, false, keep_space);\n             },\n             Struct(_, _, fps, _) => for f in fps {\n-                self.check_unused_parens_pat(cx, &f.pat, false, false);\n+                self.check_unused_parens_pat(cx, &f.pat, false, false, keep_space);\n             },\n             // Avoid linting on `i @ (p0 | .. | pn)` and `box (p0 | .. | pn)`, #64106.\n-            Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false),\n+            Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false, keep_space),\n             // Avoid linting on `&(mut x)` as `&mut x` has a different meaning, #55342.\n             // Also avoid linting on `& mut? (p0 | .. | pn)`, #64106.\n-            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not),\n+            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not, keep_space),\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let StmtKind::Local(ref local) = s.kind {\n-            self.check_unused_parens_pat(cx, &local.pat, true, false);\n+            self.check_unused_parens_pat(cx, &local.pat, true, false, (false, false));\n         }\n \n         <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n-        self.check_unused_parens_pat(cx, &param.pat, true, false);\n+        self.check_unused_parens_pat(cx, &param.pat, true, false, (false, false));\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false, (false, false));\n     }\n \n     fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {"}, {"sha": "d35e4191cc0b1dfc1ae36d59caf4e74556a6997c", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -334,7 +334,7 @@ fn main() {\n         \"c++\"\n     } else if target.contains(\"netbsd\") && llvm_static_stdcpp.is_some() {\n         // NetBSD uses a separate library when relocation is required\n-        \"stdc++_pic\"\n+        \"stdc++_p\"\n     } else if llvm_use_libcxx.is_some() {\n         \"c++\"\n     } else {"}, {"sha": "c41ae8d55cdad6d3dcd2a9205cfd26541f62418a", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -22,9 +22,14 @@ pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) -> PathBuf {\n-    let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, metadata);\n+pub fn emit_wrapper_file(\n+    sess: &Session,\n+    data: &[u8],\n+    tmpdir: &MaybeTempDir,\n+    name: &str,\n+) -> PathBuf {\n+    let out_filename = tmpdir.as_ref().join(name);\n+    let result = fs::write(&out_filename, data);\n \n     if let Err(err) = result {\n         sess.emit_fatal(FailedWriteError { filename: out_filename, err });"}, {"sha": "1987f88e6b8cc9c10d6e6be53c2f216ef8304b2b", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -41,6 +41,6 @@ pub mod errors;\n pub mod fs;\n pub mod locator;\n \n-pub use fs::{emit_metadata, METADATA_FILENAME};\n+pub use fs::{emit_wrapper_file, METADATA_FILENAME};\n pub use native_libs::find_native_static_library;\n pub use rmeta::{encode_metadata, EncodedMetadata, METADATA_HEADER};"}, {"sha": "5f6e498dbeaa23bb0c8811f4be9d9605955c5edd", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -8,7 +8,7 @@ doctest = false\n \n [dependencies]\n bitflags = \"1.2.1\"\n-chalk-ir = \"0.80.0\"\n+chalk-ir = \"0.87.0\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n polonius-engine = \"0.13.0\""}, {"sha": "14f50ae87de0639fc4c58f88dfbc5c89c6ec9e21", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -353,6 +353,10 @@ impl<'hir> Map<'hir> {\n         node.node.generics()\n     }\n \n+    pub fn owner(self, id: OwnerId) -> OwnerNode<'hir> {\n+        self.tcx.hir_owner(id).unwrap_or_else(|| bug!(\"expected owner for {:?}\", id)).node\n+    }\n+\n     pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n         self.tcx.hir_owner(id.owner_id).unwrap().node.expect_item()\n     }\n@@ -822,8 +826,11 @@ impl<'hir> Map<'hir> {\n         )\n     }\n \n-    pub fn expect_owner(self, id: OwnerId) -> OwnerNode<'hir> {\n-        self.tcx.hir_owner(id).unwrap_or_else(|| bug!(\"expected owner for {:?}\", id)).node\n+    pub fn expect_owner(self, def_id: LocalDefId) -> OwnerNode<'hir> {\n+        self.tcx\n+            .hir_owner(OwnerId { def_id })\n+            .unwrap_or_else(|| bug!(\"expected owner for {:?}\", def_id))\n+            .node\n     }\n \n     pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {"}, {"sha": "6bdf591fdd79208632a82b19e051e7976da5f446", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -43,7 +43,6 @@\n #![feature(type_alias_impl_trait)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n-#![cfg_attr(bootstrap, feature(half_open_range_patterns))]\n #![feature(control_flow_enum)]\n #![feature(associated_type_defaults)]\n #![feature(trusted_step)]"}, {"sha": "32ec585576920948dbdd5438039f934005d315ac", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -106,6 +106,7 @@ use rustc_ast::LitKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock};\n use rustc_data_structures::tiny_list::TinyList;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -176,7 +177,7 @@ pub enum LitToConstError {\n     /// This is used for graceful error handling (`delay_span_bug`) in\n     /// type checking (`Const::from_anon_const`).\n     TypeError,\n-    Reported,\n+    Reported(ErrorGuaranteed),\n }\n \n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]"}, {"sha": "4781651071d38a6207e873b8573576af6a5936e7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1541,7 +1541,7 @@ impl<'tcx> Place<'tcx> {\n     /// If MirPhase >= Derefered and if projection contains Deref,\n     /// It's guaranteed to be in the first place\n     pub fn has_deref(&self) -> bool {\n-        // To make sure this is not accidently used in wrong mir phase\n+        // To make sure this is not accidentally used in wrong mir phase\n         debug_assert!(\n             self.projection.is_empty() || !self.projection[1..].contains(&PlaceElem::Deref)\n         );\n@@ -1957,6 +1957,7 @@ impl BorrowKind {\n         }\n     }\n \n+    // FIXME: won't be used after diagnostic migration\n     pub fn describe_mutability(&self) -> &str {\n         match *self {\n             BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => \"immutable\",\n@@ -2251,7 +2252,9 @@ impl<'tcx> ConstantKind<'tcx> {\n                 match tcx.const_eval_resolve(param_env, uneval, None) {\n                     Ok(val) => Self::Val(val, ty),\n                     Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => self,\n-                    Err(_) => Self::Ty(tcx.const_error(ty)),\n+                    Err(ErrorHandled::Reported(guar)) => {\n+                        Self::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n                 }\n             }\n         }"}, {"sha": "fed943169dfb542b2b2913270df4bc4bd4599da9", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -85,7 +85,7 @@ pub enum MirPhase {\n     ///\n     /// Also note that the lint pass which reports eg `200_u8 + 200_u8` as an error is run as a part\n     /// of analysis to runtime MIR lowering. To ensure lints are reported reliably, this means that\n-    /// transformations which may supress such errors should not run on analysis MIR.\n+    /// transformations which may suppress such errors should not run on analysis MIR.\n     Runtime(RuntimePhase),\n }\n "}, {"sha": "1564cf414bd251bda3ccd4f26b815986b8aa8141", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1614,19 +1614,10 @@ rustc_queries! {\n         desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n \n-    /// Does lifetime resolution, but does not descend into trait items. This\n-    /// should only be used for resolving lifetimes of on trait definitions,\n-    /// and is used to avoid cycles. Importantly, `resolve_lifetimes` still visits\n-    /// the same lifetimes and is responsible for diagnostics.\n-    /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n-        arena_cache\n-        desc { \"resolving lifetimes for a trait definition\" }\n-    }\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n+    query resolve_lifetimes(_: hir::OwnerId) -> ResolveLifetimes {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }"}, {"sha": "e2e2761501b48c5cf0e544e9befbf8100c18d940", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2,7 +2,6 @@ use crate::mir::interpret::LitToConstInput;\n use crate::mir::ConstantKind;\n use crate::ty::{self, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n@@ -225,7 +224,7 @@ impl<'tcx> Const<'tcx> {\n         if let Some(val) = self.kind().try_eval_for_typeck(tcx, param_env) {\n             match val {\n                 Ok(val) => Const::from_value(tcx, val, self.ty()),\n-                Err(ErrorGuaranteed { .. }) => tcx.const_error(self.ty()),\n+                Err(guar) => tcx.const_error_with_guaranteed(self.ty(), guar),\n             }\n         } else {\n             // Either the constant isn't evaluatable or ValTree creation failed.\n@@ -240,7 +239,7 @@ impl<'tcx> Const<'tcx> {\n         if let Some(val) = self.kind().try_eval_for_mir(tcx, param_env) {\n             match val {\n                 Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n-                Err(ErrorGuaranteed { .. }) => ConstantKind::Ty(tcx.const_error(self.ty())),\n+                Err(guar) => ConstantKind::Ty(tcx.const_error_with_guaranteed(self.ty(), guar)),\n             }\n         } else {\n             ConstantKind::Ty(self)"}, {"sha": "8f96f5a9eb3e99b3e8db919853a31c4c5aff0b0b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -198,12 +198,8 @@ impl<'tcx> CtxtInterners<'tcx> {\n                         Fingerprint::ZERO\n                     } else {\n                         let mut hasher = StableHasher::new();\n-                        let mut hcx = StableHashingContext::ignore_spans(\n-                            sess,\n-                            definitions,\n-                            cstore,\n-                            source_span,\n-                        );\n+                        let mut hcx =\n+                            StableHashingContext::new(sess, definitions, cstore, source_span);\n                         kind.hash_stable(&mut hcx, &mut hasher);\n                         hasher.finish()\n                     };"}, {"sha": "18eb06b83c9dfa87f54fbdf56fed2f0e014dd8f5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2506,6 +2506,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n+        self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n+    }\n+\n     /// Returns layout of a generator. Layout might be unavailable if the\n     /// generator is tainted by errors.\n     pub fn generator_layout(self, def_id: DefId) -> Option<&'tcx GeneratorLayout<'tcx>> {"}, {"sha": "48e803597b02e1aaa9666d709128abc301debf78", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2225,46 +2225,12 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n         let (new_value, map) = if self.should_print_verbose() {\n-            let regions: Vec<_> = value\n-                .bound_vars()\n-                .into_iter()\n-                .map(|var| {\n-                    let ty::BoundVariableKind::Region(var) = var else {\n-                    // This doesn't really matter because it doesn't get used,\n-                    // it's just an empty value\n-                    return ty::BrAnon(0, None);\n-                };\n-                    match var {\n-                        ty::BrAnon(..) | ty::BrEnv => {\n-                            start_or_continue(&mut self, \"for<\", \", \");\n-                            let name = next_name(&self);\n-                            debug!(?name);\n-                            do_continue(&mut self, name);\n-                            ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                        }\n-                        ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n-                            start_or_continue(&mut self, \"for<\", \", \");\n-                            let name = next_name(&self);\n-                            do_continue(&mut self, name);\n-                            ty::BrNamed(def_id, name)\n-                        }\n-                        ty::BrNamed(def_id, name) => {\n-                            start_or_continue(&mut self, \"for<\", \", \");\n-                            do_continue(&mut self, name);\n-                            ty::BrNamed(def_id, name)\n-                        }\n-                    }\n-                })\n-                .collect();\n+            for var in value.bound_vars().iter() {\n+                start_or_continue(&mut self, \"for<\", \", \");\n+                write!(self, \"{:?}\", var)?;\n+            }\n             start_or_continue(&mut self, \"\", \"> \");\n-\n-            self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-                let kind = regions[br.var.as_usize()];\n-                self.tcx.mk_region(ty::ReLateBound(\n-                    ty::INNERMOST,\n-                    ty::BoundRegion { var: br.var, kind },\n-                ))\n-            })\n+            (value.clone().skip_binder(), BTreeMap::default())\n         } else {\n             let tcx = self.tcx;\n "}, {"sha": "2bcb2d824842efc5e1a0683a89c8aad6cead84bd", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -506,6 +506,9 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &'tcx ty::List<T> {\n     }\n }\n \n+/// Similar to [`super::Binder`] except that it tracks early bound generics, i.e. `struct Foo<T>(T)`\n+/// needs `T` substituted immediately. This type primarily exists to avoid forgetting to call\n+/// `subst`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable)]\n pub struct EarlyBinder<T>(pub T);"}, {"sha": "6eae94511e4d63c05f1a508da14027ac07cf0399", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -66,7 +66,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n     let layout = tcx\n         .layout_of(ty::ParamEnv::reveal_all().and(ty))\n         .expect(\"failed to build vtable representation\");\n-    assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+    assert!(layout.is_sized(), \"can't create a vtable for an unsized type\");\n     let size = layout.size.bytes();\n     let align = layout.align.abi.bytes();\n "}, {"sha": "f4562cdfb88dcfdfa07c488896a761f3fef5872f", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -185,7 +185,8 @@ fn find_item_ty_spans(\n                 });\n                 if check_params && let Some(args) = path.segments.last().unwrap().args {\n                     let params_in_repr = tcx.params_in_repr(def_id);\n-                    for (i, arg) in args.args.iter().enumerate() {\n+                    // the domain size check is needed because the HIR may not be well-formed at this point\n+                    for (i, arg) in args.args.iter().enumerate().take(params_in_repr.domain_size()) {\n                         if let hir::GenericArg::Type(ty) = arg && params_in_repr.contains(i as u32) {\n                             find_item_ty_spans(tcx, ty, needle, spans, seen_representable);\n                         }"}, {"sha": "db05592ed0ea5fa27a24a8b0f1bce32545c5987a", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     else_block: Some(else_block),\n                 } => {\n                     // When lowering the statement `let <pat> = <expr> else { <else> };`,\n-                    // the `<else>` block is nested in the parent scope enclosing this statment.\n+                    // the `<else>` block is nested in the parent scope enclosing this statement.\n                     // That scope is usually either the enclosing block scope,\n                     // or the remainder scope of the last statement.\n                     // This is to make sure that temporaries instantiated in `<expr>` are dropped"}, {"sha": "7d8a940bde5cefc78c9d5988c364f90bff270786", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, TyCtxt};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -26,7 +27,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let literal =\n                     match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n                         Ok(c) => c,\n-                        Err(LitToConstError::Reported) => ConstantKind::Ty(tcx.const_error(ty)),\n+                        Err(LitToConstError::Reported(guar)) => {\n+                            ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                        }\n                         Err(LitToConstError::TypeError) => {\n                             bug!(\"encountered type error in `lit_to_mir_constant\")\n                         }\n@@ -105,7 +108,15 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n     let LitToConstInput { lit, ty, neg } = lit_input;\n     let trunc = |n| {\n         let param_ty = ty::ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        let width = tcx\n+            .layout_of(param_ty)\n+            .map_err(|_| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't compute width of literal: {:?}\", lit_input.lit),\n+                ))\n+            })?\n+            .size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n@@ -136,12 +147,20 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n             trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n         }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float_into_constval(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n-        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => parse_float_into_constval(*n, *fty, neg)\n+            .ok_or_else(|| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't parse float literal: {:?}\", lit_input.lit),\n+                ))\n+            })?,\n         (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n         (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => {\n+            return Err(LitToConstError::Reported(\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"encountered LitKind::Err during mir build\"),\n+            ));\n+        }\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "85e8801bda3ec929453c3473eaf01d2ce06dcbe1", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast as ast;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n+use rustc_span::DUMMY_SP;\n \n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -10,7 +11,15 @@ pub(crate) fn lit_to_const<'tcx>(\n \n     let trunc = |n| {\n         let param_ty = ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        let width = tcx\n+            .layout_of(param_ty)\n+            .map_err(|_| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't compute width of literal: {:?}\", lit_input.lit),\n+                ))\n+            })?\n+            .size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n@@ -44,7 +53,11 @@ pub(crate) fn lit_to_const<'tcx>(\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n         (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n-        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => {\n+            return Err(LitToConstError::Reported(\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"encountered LitKind::Err during mir build\"),\n+            ));\n+        }\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "80b532aec6c1a8a5c51ec1d3a41628987abfbb3d", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -577,6 +577,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     self.errors.push(PatternError::ConstParamInPattern(span));\n                     return PatKind::Wild;\n                 }\n+                ConstKind::Error(_) => {\n+                    return PatKind::Wild;\n+                }\n                 _ => bug!(\"Expected ConstKind::Param\"),\n             },\n             mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n@@ -614,7 +617,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n         match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n             Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n-            Err(LitToConstError::Reported) => PatKind::Wild,\n+            Err(LitToConstError::Reported(_)) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n     }"}, {"sha": "4f30e8a0be03ef3cda925f60540da06bb4111d56", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -385,7 +385,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // I don't know how return types can seem to be unsized but this happens in the\n             // `type/type-unsatisfiable.rs` test.\n             .filter(|ret_layout| {\n-                !ret_layout.is_unsized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n+                ret_layout.is_sized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n             })\n             .unwrap_or_else(|| ecx.layout_of(tcx.types.unit).unwrap());\n "}, {"sha": "163446c52e4c28112ad4d90681c3f01d5a365c21", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -199,7 +199,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // I don't know how return types can seem to be unsized but this happens in the\n             // `type/type-unsatisfiable.rs` test.\n             .filter(|ret_layout| {\n-                !ret_layout.is_unsized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n+                ret_layout.is_sized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n             })\n             .unwrap_or_else(|| ecx.layout_of(tcx.types.unit).unwrap());\n "}, {"sha": "0ea8f2ba93fd8a1c621338441d08255aab439e21", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n         let literal = constant.literal;\n         match literal {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) => {}\n+                ConstKind::Param(_) | ConstKind::Error(_) => {}\n                 _ => bug!(\"only ConstKind::Param should be encountered here, got {:#?}\", c),\n             },\n             ConstantKind::Unevaluated(..) => self.required_consts.push(*constant),"}, {"sha": "a39398950a53352545dbc3916c1c2dc6eb11559f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1165,10 +1165,12 @@ pub(crate) struct ParenthesesInForHead {\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ParenthesesInForHeadSugg {\n-    #[suggestion_part(code = \"\")]\n+    #[suggestion_part(code = \"{left_snippet}\")]\n     pub left: Span,\n-    #[suggestion_part(code = \"\")]\n+    pub left_snippet: String,\n+    #[suggestion_part(code = \"{right_snippet}\")]\n     pub right: Span,\n+    pub right_snippet: String,\n }\n \n #[derive(Diagnostic)]\n@@ -1278,3 +1280,24 @@ pub(crate) struct DoubleColonInBound {\n     #[suggestion(code = \": \", applicability = \"machine-applicable\")]\n     pub between: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_fn_ptr_with_generics)]\n+pub(crate) struct FnPtrWithGenerics {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: Option<FnPtrWithGenericsSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n+pub(crate) struct FnPtrWithGenericsSugg {\n+    #[suggestion_part(code = \"{snippet}\")]\n+    pub left: Span,\n+    pub snippet: String,\n+    #[suggestion_part(code = \"\")]\n+    pub right: Span,\n+    pub arity: usize,\n+    pub for_param_list_exists: bool,\n+}"}, {"sha": "c78479b098ba000453afc83c2c27754d47af80aa", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,6 +3,7 @@\n #![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n+#![feature(iter_intersperse)]\n #![feature(let_chains)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]"}, {"sha": "c8160548763c88420c902f4f84f2af1ef00b069b", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -5,7 +5,8 @@ use rustc_ast::tokenstream::{AttrTokenTree, DelimSpan, LazyAttrTokenStream, Spac\n use rustc_ast::{self as ast};\n use rustc_ast::{AttrVec, Attribute, HasAttrs, HasTokens};\n use rustc_errors::PResult;\n-use rustc_span::{sym, Span};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::{sym, Span, DUMMY_SP};\n \n use std::convert::TryInto;\n use std::ops::Range;\n@@ -39,8 +40,13 @@ impl AttrWrapper {\n     pub fn empty() -> AttrWrapper {\n         AttrWrapper { attrs: AttrVec::new(), start_pos: usize::MAX }\n     }\n-    // FIXME: Delay span bug here?\n-    pub(crate) fn take_for_recovery(self) -> AttrVec {\n+\n+    pub(crate) fn take_for_recovery(self, sess: &ParseSess) -> AttrVec {\n+        sess.span_diagnostic.delay_span_bug(\n+            self.attrs.get(0).map(|attr| attr.span).unwrap_or(DUMMY_SP),\n+            \"AttrVec is taken for recovery but no error is produced\",\n+        );\n+\n         self.attrs\n     }\n "}, {"sha": "0bbe073fe2af4621c19f95e570bdd13367249e82", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1653,15 +1653,29 @@ impl<'a> Parser<'a> {\n             (token::CloseDelim(Delimiter::Parenthesis), Some(begin_par_sp)) => {\n                 self.bump();\n \n+                let sm = self.sess.source_map();\n+                let left = begin_par_sp;\n+                let right = self.prev_token.span;\n+                let left_snippet = if let Ok(snip) = sm.span_to_prev_source(left) &&\n+                        !snip.ends_with(\" \") {\n+                                \" \".to_string()\n+                            } else {\n+                                \"\".to_string()\n+                            };\n+\n+                let right_snippet = if let Ok(snip) = sm.span_to_next_source(right) &&\n+                        !snip.starts_with(\" \") {\n+                                \" \".to_string()\n+                            } else {\n+                                \"\".to_string()\n+                        };\n+\n                 self.sess.emit_err(ParenthesesInForHead {\n-                    span: vec![begin_par_sp, self.prev_token.span],\n+                    span: vec![left, right],\n                     // With e.g. `for (x) in y)` this would replace `(x) in y)`\n                     // with `x) in y)` which is syntactically invalid.\n                     // However, this is prevented before we get here.\n-                    sugg: ParenthesesInForHeadSugg {\n-                        left: begin_par_sp,\n-                        right: self.prev_token.span,\n-                    },\n+                    sugg: ParenthesesInForHeadSugg { left, right, left_snippet, right_snippet },\n                 });\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint."}, {"sha": "b072573af23f044e1e18d675984fc879697767fe", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -33,6 +33,7 @@ use core::mem;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n+use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n@@ -2090,7 +2091,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness = if self.token.uninterpolated_span().rust_2018() {\n-            self.parse_asyncness()\n+            self.parse_asyncness(Case::Sensitive)\n         } else {\n             Async::No\n         };\n@@ -2271,7 +2272,7 @@ impl<'a> Parser<'a> {\n                 self.mk_block_err(cond_span.shrink_to_hi())\n             }\n         } else {\n-            let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n+            let attrs = self.parse_outer_attributes()?; // For recovery.\n             let block = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 self.parse_block()?\n             } else {\n@@ -2288,7 +2289,7 @@ impl<'a> Parser<'a> {\n                     })?\n                 }\n             };\n-            self.error_on_if_block_attrs(lo, false, block.span, &attrs);\n+            self.error_on_if_block_attrs(lo, false, block.span, attrs);\n             block\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n@@ -2349,7 +2350,7 @@ impl<'a> Parser<'a> {\n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let else_span = self.prev_token.span; // `else`\n-        let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n+        let attrs = self.parse_outer_attributes()?; // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n             self.parse_if_expr()?\n         } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n@@ -2384,7 +2385,7 @@ impl<'a> Parser<'a> {\n                 },\n             }\n         };\n-        self.error_on_if_block_attrs(else_span, true, expr.span, &attrs);\n+        self.error_on_if_block_attrs(else_span, true, expr.span, attrs);\n         Ok(expr)\n     }\n \n@@ -2393,8 +2394,13 @@ impl<'a> Parser<'a> {\n         ctx_span: Span,\n         is_ctx_else: bool,\n         branch_span: Span,\n-        attrs: &[ast::Attribute],\n+        attrs: AttrWrapper,\n     ) {\n+        if attrs.is_empty() {\n+            return;\n+        }\n+\n+        let attrs: &[ast::Attribute] = &attrs.take_for_recovery(self.sess);\n         let (attributes, last) = match attrs {\n             [] => return,\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),"}, {"sha": "494f0cf56a80f6c82f8dc5fe408f5dde81b8c25d", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -8,6 +8,7 @@ use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n@@ -34,7 +35,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut AttrVec) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let mod_kind = if self.eat(&token::Semi) {\n@@ -143,8 +144,15 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let mut def = self.parse_defaultness();\n-        let kind =\n-            self.parse_item_kind(&mut attrs, mac_allowed, lo, &vis, &mut def, fn_parse_mode)?;\n+        let kind = self.parse_item_kind(\n+            &mut attrs,\n+            mac_allowed,\n+            lo,\n+            &vis,\n+            &mut def,\n+            fn_parse_mode,\n+            Case::Sensitive,\n+        )?;\n         if let Some((ident, kind)) = kind {\n             self.error_on_unconsumed_default(def, &kind);\n             let span = lo.to(self.prev_token.span);\n@@ -205,16 +213,17 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         def: &mut Defaultness,\n         fn_parse_mode: FnParseMode,\n+        case: Case,\n     ) -> PResult<'a, Option<ItemInfo>> {\n         let def_final = def == &Defaultness::Final;\n-        let mut def = || mem::replace(def, Defaultness::Final);\n+        let mut def_ = || mem::replace(def, Defaultness::Final);\n \n-        let info = if self.eat_keyword(kw::Use) {\n+        let info = if self.eat_keyword_case(kw::Use, case) {\n             self.parse_use_item()?\n-        } else if self.check_fn_front_matter(def_final) {\n+        } else if self.check_fn_front_matter(def_final, case) {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(attrs, fn_parse_mode, lo, vis)?;\n-            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def(), sig, generics, body })))\n+            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def_(), sig, generics, body })))\n         } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n@@ -225,7 +234,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.is_unsafe_foreign_mod() {\n             // EXTERN BLOCK\n-            let unsafety = self.parse_unsafety();\n+            let unsafety = self.parse_unsafety(Case::Sensitive);\n             self.expect_keyword(kw::Extern)?;\n             self.parse_item_foreign_mod(attrs, unsafety)?\n         } else if self.is_static_global() {\n@@ -234,15 +243,15 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let (ident, ty, expr) = self.parse_item_global(Some(m))?;\n             (ident, ItemKind::Static(ty, m, expr))\n-        } else if let Const::Yes(const_span) = self.parse_constness() {\n+        } else if let Const::Yes(const_span) = self.parse_constness(Case::Sensitive) {\n             // CONST ITEM\n             if self.token.is_keyword(kw::Impl) {\n                 // recover from `const impl`, suggest `impl const`\n-                self.recover_const_impl(const_span, attrs, def())?\n+                self.recover_const_impl(const_span, attrs, def_())?\n             } else {\n                 self.recover_const_mut(const_span);\n                 let (ident, ty, expr) = self.parse_item_global(None)?;\n-                (ident, ItemKind::Const(def(), ty, expr))\n+                (ident, ItemKind::Const(def_(), ty, expr))\n             }\n         } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n             // TRAIT ITEM\n@@ -251,15 +260,15 @@ impl<'a> Parser<'a> {\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n         {\n             // IMPL ITEM\n-            self.parse_item_impl(attrs, def())?\n+            self.parse_item_impl(attrs, def_())?\n         } else if self.check_keyword(kw::Mod)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Mod])\n         {\n             // MODULE ITEM\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n-            self.parse_type_alias(def())?\n+            self.parse_type_alias(def_())?\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n@@ -286,6 +295,19 @@ impl<'a> Parser<'a> {\n         } else if self.isnt_macro_invocation() && vis.kind.is_pub() {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n+        } else if self.isnt_macro_invocation() && case == Case::Sensitive {\n+            _ = def_;\n+\n+            // Recover wrong cased keywords\n+            return self.parse_item_kind(\n+                attrs,\n+                macros_allowed,\n+                lo,\n+                vis,\n+                def,\n+                fn_parse_mode,\n+                Case::Insensitive,\n+            );\n         } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::empty(), ItemKind::MacCall(P(self.parse_item_macro(vis)?)))\n@@ -538,7 +560,7 @@ impl<'a> Parser<'a> {\n         attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Impl)?;\n \n         // First, parse generic parameters if necessary.\n@@ -552,7 +574,7 @@ impl<'a> Parser<'a> {\n             generics\n         };\n \n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(Case::Sensitive);\n         if let Const::Yes(span) = constness {\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n         }\n@@ -796,7 +818,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, attrs: &mut AttrVec, lo: Span) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -971,6 +993,23 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::ModSep) {\n                 self.parse_use_tree_glob_or_nested()?\n             } else {\n+                // Recover from using a colon as path separator.\n+                while self.eat_noexpect(&token::Colon) {\n+                    self.struct_span_err(self.prev_token.span, \"expected `::`, found `:`\")\n+                        .span_suggestion_short(\n+                            self.prev_token.span,\n+                            \"use double colon\",\n+                            \"::\",\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .note_once(\"import paths are delimited using `::`\")\n+                        .emit();\n+\n+                    // We parse the rest of the path and append it to the original prefix.\n+                    self.parse_path_segments(&mut prefix.segments, PathStyle::Mod, None)?;\n+                    prefix.span = lo.to(self.prev_token.span);\n+                }\n+\n                 UseTreeKind::Simple(self.parse_rename()?, DUMMY_NODE_ID, DUMMY_NODE_ID)\n             }\n         };\n@@ -1745,7 +1784,7 @@ impl<'a> Parser<'a> {\n         let (ident, is_raw) = self.ident_or_err()?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n-            let err = if self.check_fn_front_matter(false) {\n+            let err = if self.check_fn_front_matter(false, Case::Sensitive) {\n                 let inherited_vis = Visibility {\n                     span: rustc_span::DUMMY_SP,\n                     kind: VisibilityKind::Inherited,\n@@ -2155,7 +2194,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// `check_pub` adds additional `pub` to the checks in case users place it\n     /// wrongly, can be used to ensure `pub` never comes after `default`.\n-    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool) -> bool {\n+    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool, case: Case) -> bool {\n         // We use an over-approximation here.\n         // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n         // `pub` is added in case users got confused with the ordering like `async pub fn`,\n@@ -2165,23 +2204,30 @@ impl<'a> Parser<'a> {\n         } else {\n             &[kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n         };\n-        self.check_keyword(kw::Fn) // Definitely an `fn`.\n+        self.check_keyword_case(kw::Fn, case) // Definitely an `fn`.\n             // `$qual fn` or `$qual $qual`:\n-            || quals.iter().any(|&kw| self.check_keyword(kw))\n+            || quals.iter().any(|&kw| self.check_keyword_case(kw, case))\n                 && self.look_ahead(1, |t| {\n                     // `$qual fn`, e.g. `const fn` or `async fn`.\n-                    t.is_keyword(kw::Fn)\n+                    t.is_keyword_case(kw::Fn, case)\n                     // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n-                    || t.is_non_raw_ident_where(|i| quals.contains(&i.name)\n-                        // Rule out 2015 `const async: T = val`.\n-                        && i.is_reserved()\n+                    || (\n+                        (\n+                            t.is_non_raw_ident_where(|i|\n+                                quals.contains(&i.name)\n+                                    // Rule out 2015 `const async: T = val`.\n+                                    && i.is_reserved()\n+                            )\n+                            || case == Case::Insensitive\n+                                && t.is_non_raw_ident_where(|i| quals.iter().any(|qual| qual.as_str() == i.name.as_str().to_lowercase()))\n+                        )\n                         // Rule out unsafe extern block.\n                         && !self.is_unsafe_foreign_mod())\n                 })\n             // `extern ABI fn`\n-            || self.check_keyword(kw::Extern)\n+            || self.check_keyword_case(kw::Extern, case)\n                 && self.look_ahead(1, |t| t.can_begin_literal_maybe_minus())\n-                && self.look_ahead(2, |t| t.is_keyword(kw::Fn))\n+                && self.look_ahead(2, |t| t.is_keyword_case(kw::Fn, case))\n     }\n \n     /// Parses all the \"front matter\" (or \"qualifiers\") for a `fn` declaration,\n@@ -2197,22 +2243,22 @@ impl<'a> Parser<'a> {\n     /// `Visibility::Inherited` when no visibility is known.\n     pub(super) fn parse_fn_front_matter(&mut self, orig_vis: &Visibility) -> PResult<'a, FnHeader> {\n         let sp_start = self.token.span;\n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(Case::Insensitive);\n \n         let async_start_sp = self.token.span;\n-        let asyncness = self.parse_asyncness();\n+        let asyncness = self.parse_asyncness(Case::Insensitive);\n \n         let unsafe_start_sp = self.token.span;\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Insensitive);\n \n         let ext_start_sp = self.token.span;\n-        let ext = self.parse_extern();\n+        let ext = self.parse_extern(Case::Insensitive);\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n \n-        if !self.eat_keyword(kw::Fn) {\n+        if !self.eat_keyword_case(kw::Fn, Case::Insensitive) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this."}, {"sha": "14dc490fb0232615d377f4ef975264648a3bca8f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -22,6 +22,7 @@ use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::AttributesData;\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, Extern};\n@@ -636,6 +637,20 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw)\n     }\n \n+    fn check_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n+        if self.check_keyword(kw) {\n+            return true;\n+        }\n+\n+        if case == Case::Insensitive\n+        && let Some((ident, /* is_raw */ false)) = self.token.ident()\n+        && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// If the next token is the given keyword, eats it and returns `true`.\n     /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n     // Public for rustfmt usage.\n@@ -648,6 +663,33 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Eats a keyword, optionally ignoring the case.\n+    /// If the case differs (and is ignored) an error is issued.\n+    /// This is useful for recovery.\n+    fn eat_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n+        if self.eat_keyword(kw) {\n+            return true;\n+        }\n+\n+        if case == Case::Insensitive\n+        && let Some((ident, /* is_raw */ false)) = self.token.ident()\n+        && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n+            self\n+                .struct_span_err(ident.span, format!(\"keyword `{kw}` is written in a wrong case\"))\n+                .span_suggestion(\n+                    ident.span,\n+                    \"write it in the correct case\",\n+                    kw,\n+                    Applicability::MachineApplicable\n+                ).emit();\n+\n+            self.bump();\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n     fn eat_keyword_noexpect(&mut self, kw: Symbol) -> bool {\n         if self.token.is_keyword(kw) {\n             self.bump();\n@@ -1127,8 +1169,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses asyncness: `async` or nothing.\n-    fn parse_asyncness(&mut self) -> Async {\n-        if self.eat_keyword(kw::Async) {\n+    fn parse_asyncness(&mut self, case: Case) -> Async {\n+        if self.eat_keyword_case(kw::Async, case) {\n             let span = self.prev_token.uninterpolated_span();\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n@@ -1137,19 +1179,19 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses unsafety: `unsafe` or nothing.\n-    fn parse_unsafety(&mut self) -> Unsafe {\n-        if self.eat_keyword(kw::Unsafe) {\n+    fn parse_unsafety(&mut self, case: Case) -> Unsafe {\n+        if self.eat_keyword_case(kw::Unsafe, case) {\n             Unsafe::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Unsafe::No\n         }\n     }\n \n     /// Parses constness: `const` or nothing.\n-    fn parse_constness(&mut self) -> Const {\n+    fn parse_constness(&mut self, case: Case) -> Const {\n         // Avoid const blocks to be parsed as const items\n         if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n-            && self.eat_keyword(kw::Const)\n+            && self.eat_keyword_case(kw::Const, case)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n@@ -1404,8 +1446,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    fn parse_extern(&mut self) -> Extern {\n-        if self.eat_keyword(kw::Extern) {\n+    fn parse_extern(&mut self, case: Case) -> Extern {\n+        if self.eat_keyword_case(kw::Extern, case) {\n             let mut extern_span = self.prev_token.span;\n             let abi = self.parse_abi();\n             if let Some(abi) = abi {"}, {"sha": "d46565dea893119d48736a56d5ac8190ac79285a", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -631,7 +631,9 @@ impl<'a> Parser<'a> {\n     /// - A single-segment path.\n     pub(super) fn expr_is_valid_const_arg(&self, expr: &P<rustc_ast::Expr>) -> bool {\n         match &expr.kind {\n-            ast::ExprKind::Block(_, _) | ast::ExprKind::Lit(_) => true,\n+            ast::ExprKind::Block(_, _)\n+            | ast::ExprKind::Lit(_)\n+            | ast::ExprKind::IncludedBytes(..) => true,\n             ast::ExprKind::Unary(ast::UnOp::Neg, expr) => {\n                 matches!(expr.kind, ast::ExprKind::Lit(_))\n             }"}, {"sha": "9684145ad99482cf16b0e0b39485f63b8e37be7d", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -19,7 +19,7 @@ use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::util::classify;\n-use rustc_ast::{AttrStyle, AttrVec, Attribute, LocalKind, MacCall, MacCallStmt, MacStmtStyle};\n+use rustc_ast::{AttrStyle, AttrVec, LocalKind, MacCall, MacCallStmt, MacStmtStyle};\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, HasAttrs, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -101,7 +101,7 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n         } else if self.eat(&token::Semi) {\n             // Do not attempt to parse an expression if we're done here.\n-            self.error_outer_attrs(&attrs.take_for_recovery());\n+            self.error_outer_attrs(attrs);\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(Delimiter::Brace) {\n             // Remainder are line-expr stmts.\n@@ -120,7 +120,7 @@ impl<'a> Parser<'a> {\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n-            self.error_outer_attrs(&attrs.take_for_recovery());\n+            self.error_outer_attrs(attrs);\n             return Ok(None);\n         }))\n     }\n@@ -199,8 +199,10 @@ impl<'a> Parser<'a> {\n \n     /// Error on outer attributes in this context.\n     /// Also error if the previous token was a doc comment.\n-    fn error_outer_attrs(&self, attrs: &[Attribute]) {\n-        if let [.., last] = attrs {\n+    fn error_outer_attrs(&self, attrs: AttrWrapper) {\n+        if !attrs.is_empty()\n+        && let attrs = attrs.take_for_recovery(self.sess)\n+        && let attrs @ [.., last] = &*attrs {\n             if last.is_doc_comment() {\n                 self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n                     span: last.span,"}, {"sha": "d6854f0702518dac028e26b78483dbbf46c3560e", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,9 +1,11 @@\n use super::{Parser, PathStyle, TokenType};\n \n+use crate::errors::{FnPtrWithGenerics, FnPtrWithGenericsSugg};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n@@ -267,16 +269,21 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.check_fn_front_matter(false) {\n+        } else if self.check_fn_front_matter(false, Case::Sensitive) {\n             // Function pointer type\n-            self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n+            self.parse_ty_bare_fn(lo, Vec::new(), None, recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.check_fn_front_matter(false) {\n-                self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n+            if self.check_fn_front_matter(false, Case::Sensitive) {\n+                self.parse_ty_bare_fn(\n+                    lo,\n+                    lifetime_defs,\n+                    Some(self.prev_token.span.shrink_to_lo()),\n+                    recover_return_sign,\n+                )?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n                 let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n@@ -401,7 +408,7 @@ impl<'a> Parser<'a> {\n                 .span_suggestions(\n                     span.shrink_to_hi(),\n                     \"add `mut` or `const` here\",\n-                    [\"mut \".to_string(), \"const \".to_string()].into_iter(),\n+                    [\"mut \".to_string(), \"const \".to_string()],\n                     Applicability::HasPlaceholders,\n                 )\n                 .emit();\n@@ -518,7 +525,8 @@ impl<'a> Parser<'a> {\n     fn parse_ty_bare_fn(\n         &mut self,\n         lo: Span,\n-        params: Vec<GenericParam>,\n+        mut params: Vec<GenericParam>,\n+        param_insertion_point: Option<Span>,\n         recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, TyKind> {\n         let inherited_vis = rustc_ast::Visibility {\n@@ -529,6 +537,9 @@ impl<'a> Parser<'a> {\n         let span_start = self.token.span;\n         let ast::FnHeader { ext, unsafety, constness, asyncness } =\n             self.parse_fn_front_matter(&inherited_vis)?;\n+        if self.may_recover() && self.token.kind == TokenKind::Lt {\n+            self.recover_fn_ptr_with_generics(lo, &mut params, param_insertion_point)?;\n+        }\n         let decl = self.parse_fn_decl(|_| false, AllowPlus::No, recover_return_sign)?;\n         let whole_span = lo.to(self.prev_token.span);\n         if let ast::Const::Yes(span) = constness {\n@@ -544,6 +555,48 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params: params, decl, decl_span })))\n     }\n \n+    /// Recover from function pointer types with a generic parameter list (e.g. `fn<'a>(&'a str)`).\n+    fn recover_fn_ptr_with_generics(\n+        &mut self,\n+        lo: Span,\n+        params: &mut Vec<GenericParam>,\n+        param_insertion_point: Option<Span>,\n+    ) -> PResult<'a, ()> {\n+        let generics = self.parse_generics()?;\n+        let arity = generics.params.len();\n+\n+        let mut lifetimes: Vec<_> = generics\n+            .params\n+            .into_iter()\n+            .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime))\n+            .collect();\n+\n+        let sugg = if !lifetimes.is_empty() {\n+            let snippet =\n+                lifetimes.iter().map(|param| param.ident.as_str()).intersperse(\", \").collect();\n+\n+            let (left, snippet) = if let Some(span) = param_insertion_point {\n+                (span, if params.is_empty() { snippet } else { format!(\", {snippet}\") })\n+            } else {\n+                (lo.shrink_to_lo(), format!(\"for<{snippet}> \"))\n+            };\n+\n+            Some(FnPtrWithGenericsSugg {\n+                left,\n+                snippet,\n+                right: generics.span,\n+                arity,\n+                for_param_list_exists: param_insertion_point.is_some(),\n+            })\n+        } else {\n+            None\n+        };\n+\n+        self.sess.emit_err(FnPtrWithGenerics { span: generics.span, sugg });\n+        params.append(&mut lifetimes);\n+        Ok(())\n+    }\n+\n     /// Emit an error for the given bad function pointer qualifier.\n     fn error_fn_ptr_bad_qualifier(&self, span: Span, qual_span: Span, qual: &str) {\n         self.struct_span_err(span, &format!(\"an `fn` pointer type cannot be `{}`\", qual))"}, {"sha": "2b6ff0a5cb9d38ce25a35bbbd871e27dc904cbfc", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -141,7 +141,7 @@ impl CheckAttrVisitor<'_> {\n                 sym::collapse_debuginfo => self.check_collapse_debuginfo(attr, span, target),\n                 sym::const_trait => self.check_const_trait(attr, span, target),\n                 sym::must_not_suspend => self.check_must_not_suspend(&attr, span, target),\n-                sym::must_use => self.check_must_use(hir_id, &attr, span, target),\n+                sym::must_use => self.check_must_use(hir_id, &attr, target),\n                 sym::rustc_pass_by_value => self.check_pass_by_value(&attr, span, target),\n                 sym::rustc_allow_incoherent_impl => {\n                     self.check_allow_incoherent_impl(&attr, span, target)\n@@ -1176,17 +1176,7 @@ impl CheckAttrVisitor<'_> {\n     }\n \n     /// Warns against some misuses of `#[must_use]`\n-    fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n-        let node = self.tcx.hir().get(hir_id);\n-        if let Some(kind) = node.fn_kind() && let rustc_hir::IsAsync::Async = kind.asyncness() {\n-            self.tcx.emit_spanned_lint(\n-                UNUSED_ATTRIBUTES,\n-                hir_id,\n-                attr.span,\n-                errors::MustUseAsync { span }\n-            );\n-        }\n-\n+    fn check_must_use(&self, hir_id: HirId, attr: &Attribute, target: Target) -> bool {\n         if !matches!(\n             target,\n             Target::Fn"}, {"sha": "140f02c046a66c3b48d82f9a3f28acc42b3e24a5", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -560,13 +560,14 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_expr(&mut self, e: &'v ast::Expr) {\n+        #[rustfmt::skip]\n         record_variants!(\n             (self, e, e.kind, Id::None, ast, Expr, ExprKind),\n             [\n                 Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n                 If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n                 AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n-                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, Err\n+                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err\n             ]\n         );\n         ast_visit::walk_expr(self, e)"}, {"sha": "c181de48a9ad8fb9b0053e1a38347f06c8104aa4", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -87,6 +87,7 @@ use self::VarKind::*;\n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -1690,7 +1691,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         &self,\n         name: &str,\n         opt_body: Option<&hir::Body<'_>>,\n-        err: &mut rustc_errors::DiagnosticBuilder<'_, ()>,\n+        err: &mut Diagnostic,\n     ) -> bool {\n         let mut has_litstring = false;\n         let Some(opt_body) = opt_body else {return false;};"}, {"sha": "af49d438a22cb7918e9fde85d1f9b42dca2dfe6f", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -536,6 +536,14 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             return;\n         }\n \n+        // if the const impl is derived using the `derive_const` attribute,\n+        // then it would be \"stable\" at least for the impl.\n+        // We gate usages of it using `feature(const_trait_impl)` anyways\n+        // so there is no unstable leakage\n+        if self.tcx.is_builtin_derive(def_id.to_def_id()) {\n+            return;\n+        }\n+\n         let is_const = self.tcx.is_const_fn(def_id.to_def_id())\n             || self.tcx.is_const_trait_impl_raw(def_id.to_def_id());\n         let is_stable = self"}, {"sha": "eaed9aeb85020c9be8e4261c12c5b693e77e7ae6", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -119,12 +119,11 @@ pub type EncodedDepNodeIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n struct SourceFileIndex(u32);\n \n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, Encodable, Decodable)]\n-pub struct AbsoluteBytePos(u32);\n+pub struct AbsoluteBytePos(u64);\n \n impl AbsoluteBytePos {\n     fn new(pos: usize) -> AbsoluteBytePos {\n-        debug_assert!(pos <= u32::MAX as usize);\n-        AbsoluteBytePos(pos as u32)\n+        AbsoluteBytePos(pos.try_into().expect(\"Incremental cache file size overflowed u64.\"))\n     }\n \n     fn to_usize(self) -> usize {"}, {"sha": "6378ec10875d038e087236d195810b573ff6c48b", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -49,15 +49,13 @@ pub(super) enum BodyResolver<'tcx> {\n \n impl<'a> StableHashingContext<'a> {\n     #[inline]\n-    fn new_with_or_without_spans(\n+    pub fn new(\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n         source_span: &'a IndexVec<LocalDefId, Span>,\n-        always_ignore_spans: bool,\n     ) -> Self {\n-        let hash_spans_initial =\n-            !always_ignore_spans && !sess.opts.unstable_opts.incremental_ignore_spans;\n+        let hash_spans_initial = !sess.opts.unstable_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             body_resolver: BodyResolver::Forbidden,\n@@ -71,33 +69,6 @@ impl<'a> StableHashingContext<'a> {\n         }\n     }\n \n-    #[inline]\n-    pub fn new(\n-        sess: &'a Session,\n-        definitions: &'a Definitions,\n-        cstore: &'a dyn CrateStore,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n-    ) -> Self {\n-        Self::new_with_or_without_spans(\n-            sess,\n-            definitions,\n-            cstore,\n-            source_span,\n-            /*always_ignore_spans=*/ false,\n-        )\n-    }\n-\n-    #[inline]\n-    pub fn ignore_spans(\n-        sess: &'a Session,\n-        definitions: &'a Definitions,\n-        cstore: &'a dyn CrateStore,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n-    ) -> Self {\n-        let always_ignore_spans = true;\n-        Self::new_with_or_without_spans(sess, definitions, cstore, source_span, always_ignore_spans)\n-    }\n-\n     #[inline]\n     pub fn without_hir_bodies(&mut self, f: impl FnOnce(&mut StableHashingContext<'_>)) {\n         f(&mut StableHashingContext { body_resolver: BodyResolver::Ignore, ..self.clone() });\n@@ -202,10 +173,4 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> rustc_data_structures::intern::InternedHashingContext for StableHashingContext<'a> {\n-    fn with_def_path_and_no_spans(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.while_hashing_spans(false, f);\n-    }\n-}\n-\n impl<'a> rustc_session::HashStableContext for StableHashingContext<'a> {}"}, {"sha": "e7e419c9b4238207d0c75fc8fc1931d779395765", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -469,9 +469,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n \n                         // Replace `use foo::{ self };` with `use foo;`\n+                        let self_span = source.ident.span;\n                         source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = source.ident;\n+                            // Keep the span of `self`, but the name of `foo`\n+                            ident = Ident { name: source.ident.name, span: self_span };\n                         }\n                     }\n                 } else {"}, {"sha": "82dcc7efb1bafce5082b07f045342b366ae07bb6", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -72,7 +72,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 update(node_id);\n                 if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n                     // In theory all the single import IDs have individual visibilities and\n-                    // effective visibilities, but in practice these IDs go straigth to HIR\n+                    // effective visibilities, but in practice these IDs go straight to HIR\n                     // where all their few uses assume that their (effective) visibility\n                     // applies to the whole syntactic `use` item. So they all get the same\n                     // value which is the maximum of all bindings. Maybe HIR for imports"}, {"sha": "ede67813883d6b2643464e886c8f769156b6c7e8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -527,6 +527,7 @@ struct DiagnosticMetadata<'ast> {\n \n     /// Used to detect possible new binding written without `let` and to provide structured suggestion.\n     in_assignment: Option<&'ast Expr>,\n+    is_assign_rhs: bool,\n \n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n@@ -3963,10 +3964,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.resolve_expr(elem, Some(expr));\n                 self.visit_expr(idx);\n             }\n-            ExprKind::Assign(..) => {\n-                let old = self.diagnostic_metadata.in_assignment.replace(expr);\n-                visit::walk_expr(self, expr);\n-                self.diagnostic_metadata.in_assignment = old;\n+            ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                if !self.diagnostic_metadata.is_assign_rhs {\n+                    self.diagnostic_metadata.in_assignment = Some(expr);\n+                }\n+                self.visit_expr(lhs);\n+                self.diagnostic_metadata.is_assign_rhs = true;\n+                self.diagnostic_metadata.in_assignment = None;\n+                self.visit_expr(rhs);\n+                self.diagnostic_metadata.is_assign_rhs = false;\n             }\n             _ => {\n                 visit::walk_expr(self, expr);"}, {"sha": "95eff92ef5e2471775f13aa5fa13cd2e84eb5532", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -219,26 +219,26 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let (mod_prefix, mod_str, suggestion) = if path.len() == 1 {\n                 debug!(?self.diagnostic_metadata.current_impl_items);\n                 debug!(?self.diagnostic_metadata.current_function);\n-                let suggestion = if let Some(items) = self.diagnostic_metadata.current_impl_items\n+                let suggestion = if self.current_trait_ref.is_none()\n                     && let Some((fn_kind, _)) = self.diagnostic_metadata.current_function\n-                    && self.current_trait_ref.is_none()\n                     && let Some(FnCtxt::Assoc(_)) = fn_kind.ctxt()\n+                    && let Some(items) = self.diagnostic_metadata.current_impl_items\n                     && let Some(item) = items.iter().find(|i| {\n-                        if let AssocItemKind::Fn(fn_) = &i.kind\n-                            && !fn_.sig.decl.has_self()\n-                            && i.ident.name == item_str.name\n+                        if let AssocItemKind::Fn(_) = &i.kind && i.ident.name == item_str.name\n                         {\n                             debug!(?item_str.name);\n-                            debug!(?fn_.sig.decl.inputs);\n                             return true\n                         }\n                         false\n                     })\n+                    && let AssocItemKind::Fn(fn_) = &item.kind\n                 {\n+                    debug!(?fn_);\n+                    let self_sugg = if fn_.sig.decl.has_self() { \"self.\" } else { \"Self::\" };\n                     Some((\n-                        item_span,\n+                        item_span.shrink_to_lo(),\n                         \"consider using the associated function\",\n-                        format!(\"Self::{}\", item.ident)\n+                        self_sugg.to_string()\n                     ))\n                 } else {\n                     None\n@@ -396,11 +396,13 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n \n     fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n-        let is_assoc_fn = self.self_type_is_available();\n+        if !self.self_type_is_available() {\n+            return;\n+        }\n         let Some(path_last_segment) = path.last() else { return };\n         let item_str = path_last_segment.ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n+        if [\"this\", \"my\"].contains(&item_str.as_str()) {\n             err.span_suggestion_short(\n                 span,\n                 \"you might have meant to use `self` here instead\",\n@@ -437,7 +439,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn try_lookup_name_relaxed(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: PathSource<'_>,\n         path: &[Segment],\n         span: Span,\n@@ -451,7 +453,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n         let path_str = Segment::names_to_string(path);\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-\n         let mut candidates = self\n             .r\n             .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n@@ -497,7 +498,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         .contains(span)\n                     {\n                         // Already reported this issue on the lhs of the type ascription.\n-                        err.delay_as_bug();\n+                        err.downgrade_to_delayed_bug();\n                         return (true, candidates);\n                     }\n                 }\n@@ -616,7 +617,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn suggest_trait_and_bounds(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: PathSource<'_>,\n         res: Option<Res>,\n         span: Span,\n@@ -691,7 +692,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn suggest_typo(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: PathSource<'_>,\n         path: &[Segment],\n         span: Span,\n@@ -750,7 +751,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn err_code_special_cases(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: PathSource<'_>,\n         path: &[Segment],\n         span: Span,\n@@ -1544,7 +1545,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 _ => None,\n             }\n         }\n-\n         // Fields are generally expected in the same contexts as locals.\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) =\n@@ -1812,29 +1812,22 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         false\n     }\n \n-    fn let_binding_suggestion(&self, err: &mut Diagnostic, ident_span: Span) -> bool {\n-        // try to give a suggestion for this pattern: `name = 1`, which is common in other languages\n-        let mut added_suggestion = false;\n-        if let Some(Expr { kind: ExprKind::Assign(lhs, _rhs, _), .. }) = self.diagnostic_metadata.in_assignment &&\n+    // try to give a suggestion for this pattern: `name = blah`, which is common in other languages\n+    // suggest `let name = blah` to introduce a new binding\n+    fn let_binding_suggestion(&mut self, err: &mut Diagnostic, ident_span: Span) -> bool {\n+        if let Some(Expr { kind: ExprKind::Assign(lhs, .. ), .. }) = self.diagnostic_metadata.in_assignment &&\n             let ast::ExprKind::Path(None, _) = lhs.kind {\n-                let sm = self.r.session.source_map();\n-                let line_span = sm.span_extend_to_line(ident_span);\n-                let ident_name = sm.span_to_snippet(ident_span).unwrap();\n-                // HACK(chenyukang): make sure ident_name is at the starting of the line to protect against macros\n-                if sm\n-                    .span_to_snippet(line_span)\n-                    .map_or(false, |s| s.trim().starts_with(&ident_name))\n-                {\n+                if !ident_span.from_expansion() {\n                     err.span_suggestion_verbose(\n                         ident_span.shrink_to_lo(),\n                         \"you might have meant to introduce a new binding\",\n                         \"let \".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n-                    added_suggestion = true;\n+                    return true;\n                 }\n             }\n-        added_suggestion\n+        false\n     }\n \n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n@@ -1943,7 +1936,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 err.span_suggestions(\n                     span,\n                     &msg,\n-                    suggestable_variants.into_iter(),\n+                    suggestable_variants,\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -1997,7 +1990,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 err.span_suggestions(\n                     span,\n                     msg,\n-                    suggestable_variants.into_iter(),\n+                    suggestable_variants,\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -2027,7 +2020,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 err.span_suggestions(\n                     span,\n                     msg,\n-                    suggestable_variants_with_placeholders.into_iter(),\n+                    suggestable_variants_with_placeholders,\n                     Applicability::HasPlaceholders,\n                 );\n             }"}, {"sha": "9ca3588fff4510e4c2d43c3e16ae17a9cd0144fe", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1932,6 +1932,11 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// For rustdoc.\n+    pub fn get_partial_res(&self, node_id: NodeId) -> Option<PartialRes> {\n+        self.partial_res_map.get(&node_id).copied()\n+    }\n+\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {"}, {"sha": "8c7972f8eebb92f09698ad625382f0a49f4bfd91", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -356,7 +356,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             has_derive_copy: false,\n         });\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n-        for (i, (path, _, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n+        for (i, (path, _, opt_ext, _)) in entry.resolutions.iter_mut().enumerate() {\n             if opt_ext.is_none() {\n                 *opt_ext = Some(\n                     match self.resolve_macro_path("}, {"sha": "7ea028b12efc41f40fe19250c427ddd5608e68bf", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -753,6 +753,50 @@ impl SourceMap {\n         }\n     }\n \n+    /// Given a 'Span', tries to tell if the next character is '>'\n+    /// and the previous charactoer is '<' after skipping white space\n+    /// return true if wrapped by '<>'\n+    pub fn span_wrapped_by_angle_bracket(&self, span: Span) -> bool {\n+        self.span_to_source(span, |src, start_index, end_index| {\n+            if src.get(start_index..end_index).is_none() {\n+                return Ok(false);\n+            }\n+            // test the right side to match '>' after skipping white space\n+            let end_src = &src[end_index..];\n+            let mut i = 0;\n+            while let Some(cc) = end_src.chars().nth(i) {\n+                if cc == ' ' {\n+                    i = i + 1;\n+                } else if cc == '>' {\n+                    // found > in the right;\n+                    break;\n+                } else {\n+                    // failed to find '>' return false immediately\n+                    return Ok(false);\n+                }\n+            }\n+            // test the left side to match '<' after skipping white space\n+            i = start_index;\n+            let start_src = &src[0..start_index];\n+            while let Some(cc) = start_src.chars().nth(i) {\n+                if cc == ' ' {\n+                    if i == 0 {\n+                        return Ok(false);\n+                    }\n+                    i = i - 1;\n+                } else if cc == '<' {\n+                    // found < in the left\n+                    break;\n+                } else {\n+                    // failed to find '<' return false immediately\n+                    return Ok(false);\n+                }\n+            }\n+            return Ok(true);\n+        })\n+        .map_or(false, |is_accessible| is_accessible)\n+    }\n+\n     /// Given a `Span`, tries to get a shorter span ending just after the first occurrence of `char`\n     /// `c`.\n     pub fn span_through_char(&self, sp: Span, c: char) -> Span {"}, {"sha": "b48db73618b0b9278bbc9aad5abd6b399da076d2", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -620,6 +620,7 @@ symbols! {\n         deref_mut,\n         deref_target,\n         derive,\n+        derive_const,\n         derive_default_enum,\n         destruct,\n         destructuring_assignment,"}, {"sha": "d29b479de5da6e4497ae96030eb83bb0e0013829", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,342 @@\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::{self, Abi, FieldsShape, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n+use crate::spec::HasTargetSpec;\n+\n+#[derive(Copy, Clone)]\n+enum RegPassKind {\n+    Float(Reg),\n+    Integer(Reg),\n+    Unknown,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FloatConv {\n+    FloatPair(Reg, Reg),\n+    Float(Reg),\n+    MixedPair(Reg, Reg),\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CannotUseFpConv;\n+\n+fn is_loongarch_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+    match arg.layout.abi {\n+        Abi::Vector { .. } => true,\n+        _ => arg.layout.is_aggregate(),\n+    }\n+}\n+\n+fn should_use_fp_conv_helper<'a, Ty, C>(\n+    cx: &C,\n+    arg_layout: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    field1_kind: &mut RegPassKind,\n+    field2_kind: &mut RegPassKind,\n+) -> Result<(), CannotUseFpConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    match arg_layout.abi {\n+        Abi::Scalar(scalar) => match scalar.primitive() {\n+            abi::Int(..) | abi::Pointer => {\n+                if arg_layout.size.bits() > xlen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {\n+                        *field2_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+            abi::F32 | abi::F64 => {\n+                if arg_layout.size.bits() > flen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    (_, RegPassKind::Unknown) => {\n+                        *field2_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+        },\n+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"aggregates can't have `FieldsShape::Primitive`\")\n+            }\n+            FieldsShape::Union(_) => {\n+                if !arg_layout.is_zst() {\n+                    return Err(CannotUseFpConv);\n+                }\n+            }\n+            FieldsShape::Array { count, .. } => {\n+                for _ in 0..count {\n+                    let elem_layout = arg_layout.field(cx, 0);\n+                    should_use_fp_conv_helper(\n+                        cx,\n+                        &elem_layout,\n+                        xlen,\n+                        flen,\n+                        field1_kind,\n+                        field2_kind,\n+                    )?;\n+                }\n+            }\n+            FieldsShape::Arbitrary { .. } => {\n+                match arg_layout.variants {\n+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n+                    abi::Variants::Single { .. } => (),\n+                }\n+                for i in arg_layout.fields.index_by_increasing_offset() {\n+                    let field = arg_layout.field(cx, i);\n+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;\n+                }\n+            }\n+        },\n+    }\n+    Ok(())\n+}\n+\n+fn should_use_fp_conv<'a, Ty, C>(\n+    cx: &C,\n+    arg: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+) -> Option<FloatConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    let mut field1_kind = RegPassKind::Unknown;\n+    let mut field2_kind = RegPassKind::Unknown;\n+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {\n+        return None;\n+    }\n+    match (field1_kind, field2_kind) {\n+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),\n+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),\n+        _ => None,\n+    }\n+}\n+\n+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+        match conv {\n+            FloatConv::Float(f) => {\n+                arg.cast_to(f);\n+            }\n+            FloatConv::FloatPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+            FloatConv::MixedPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    let total = arg.layout.size;\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        return true;\n+    }\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+    if is_loongarch_aggregate(arg) {\n+        if total.bits() <= xlen {\n+            arg.cast_to(xlen_reg);\n+        } else {\n+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });\n+        }\n+        return false;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    extend_integer_width(arg, xlen);\n+    false\n+}\n+\n+fn classify_arg<'a, Ty, C>(\n+    cx: &C,\n+    arg: &mut ArgAbi<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    is_vararg: bool,\n+    avail_gprs: &mut u64,\n+    avail_fprs: &mut u64,\n+) where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if !is_vararg {\n+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {\n+                *avail_fprs -= 1;\n+                arg.cast_to(f);\n+                return;\n+            }\n+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {\n+                *avail_fprs -= 2;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {\n+                *avail_gprs -= 1;\n+                *avail_fprs -= 1;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    let total = arg.layout.size;\n+    let align = arg.layout.align.abi.bits();\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    let double_xlen_reg = match xlen {\n+        32 => Reg::i64(),\n+        64 => Reg::i128(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    if total.bits() > xlen {\n+        let align_regs = align > xlen;\n+        if is_loongarch_aggregate(arg) {\n+            arg.cast_to(Uniform {\n+                unit: if align_regs { double_xlen_reg } else { xlen_reg },\n+                total: Size::from_bits(xlen * 2),\n+            });\n+        }\n+        if align_regs && is_vararg {\n+            *avail_gprs -= *avail_gprs % 2;\n+        }\n+        if *avail_gprs >= 2 {\n+            *avail_gprs -= 2;\n+        } else {\n+            *avail_gprs = 0;\n+        }\n+        return;\n+    } else if is_loongarch_aggregate(arg) {\n+        arg.cast_to(xlen_reg);\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    if *avail_gprs >= 1 {\n+        extend_integer_width(arg, xlen);\n+        *avail_gprs -= 1;\n+    }\n+}\n+\n+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+    if let Abi::Scalar(scalar) = arg.layout.abi {\n+        if let abi::Int(i, _) = scalar.primitive() {\n+            // 32-bit integers are always sign-extended\n+            if i.size().bits() == 32 && xlen > 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.ext(ArgExtension::Sext);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(xlen);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n+{\n+    let xlen = cx.data_layout().pointer_size.bits();\n+    let flen = match &cx.target_spec().llvm_abiname[..] {\n+        \"ilp32f\" | \"lp64f\" => 32,\n+        \"ilp32d\" | \"lp64d\" => 64,\n+        _ => 0,\n+    };\n+\n+    let mut avail_gprs = 8;\n+    let mut avail_fprs = 8;\n+\n+    if !fn_abi.ret.is_ignore() && classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+        avail_gprs -= 1;\n+    }\n+\n+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg(\n+            cx,\n+            arg,\n+            xlen,\n+            flen,\n+            i >= fn_abi.fixed_count as usize,\n+            &mut avail_gprs,\n+            &mut avail_fprs,\n+        );\n+    }\n+}"}, {"sha": "c5a6f9893b6f9ec49a0a49123a2ae974bf3228d2", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -10,6 +10,7 @@ mod arm;\n mod avr;\n mod bpf;\n mod hexagon;\n+mod loongarch;\n mod m68k;\n mod mips;\n mod mips64;\n@@ -696,6 +697,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"amdgpu\" => amdgpu::compute_abi_info(cx, self),\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"avr\" => avr::compute_abi_info(self),\n+            \"loongarch64\" => loongarch::compute_abi_info(cx, self),\n             \"m68k\" => m68k::compute_abi_info(self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),"}, {"sha": "decbefc2f7c622b8a4d85a95b3b97bb4bdeb7616", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1083,6 +1083,11 @@ impl Abi {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_sized(&self) -> bool {\n+        !self.is_unsized()\n+    }\n+\n     /// Returns `true` if this is a single signed integer scalar\n     #[inline]\n     pub fn is_signed(&self) -> bool {\n@@ -1490,6 +1495,11 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         self.abi.is_unsized()\n     }\n \n+    #[inline]\n+    pub fn is_sized(&self) -> bool {\n+        self.abi.is_sized()\n+    }\n+\n     /// Returns `true` if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n         match self.abi {"}, {"sha": "916b6137b650a0a2a60f89a6d85db37d95257146", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_nto_qnx_710.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,28 @@\n+use super::nto_qnx_base;\n+use crate::spec::{Cc, LinkerFlavor, Lld, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"aarch64-unknown-unknown\".into(),\n+        pointer_width: 64,\n+        // from: https://llvm.org/docs/LangRef.html#data-layout\n+        // e         = little endian\n+        // m:e       = ELF mangling: Private symbols get a .L prefix\n+        // i8:8:32   = 8-bit-integer, minimum_alignment=8, preferred_alignment=32\n+        // i16:16:32 = 16-bit-integer, minimum_alignment=16, preferred_alignment=32\n+        // i64:64    = 64-bit-integer, minimum_alignment=64, preferred_alignment=64\n+        // i128:128  = 128-bit-integer, minimum_alignment=128, preferred_alignment=128\n+        // n32:64    = 32 and 64 are native integer widths; Elements of this set are considered to support most general arithmetic operations efficiently.\n+        // S128      = 128 bits are the natural alignment of the stack in bits.\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".into(),\n+        arch: \"aarch64\".into(),\n+        options: TargetOptions {\n+            max_atomic_width: Some(128),\n+            pre_link_args: TargetOptions::link_args(\n+                LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n+                &[\"-Vgcc_ntoaarch64le_cxx\"],\n+            ),\n+            ..nto_qnx_base::opts()\n+        },\n+    }\n+}"}, {"sha": "664592b02a12443cc34ebbd6b94f90498de57728", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -74,6 +74,7 @@ mod linux_musl_base;\n mod linux_uclibc_base;\n mod msvc_base;\n mod netbsd_base;\n+mod nto_qnx_base;\n mod openbsd_base;\n mod redox_base;\n mod solaris_base;\n@@ -113,7 +114,7 @@ pub enum Lld {\n /// relevant now.\n ///\n /// The second goal is to keep the number of flavors to the minimum if possible.\n-/// LLD somewhat forces our hand here because that linker is self-sufficent only if its executable\n+/// LLD somewhat forces our hand here because that linker is self-sufficient only if its executable\n /// (`argv[0]`) is named in specific way, otherwise it doesn't work and requires a\n /// `-flavor LLD_FLAVOR` argument to choose which logic to use. Our shipped `rust-lld` in\n /// particular is not named in such specific way, so it needs the flavor option, so we make our\n@@ -1242,6 +1243,9 @@ supported_targets! {\n     (\"x86_64-unknown-none\", x86_64_unknown_none),\n \n     (\"mips64-openwrt-linux-musl\", mips64_openwrt_linux_musl),\n+\n+    (\"aarch64-unknown-nto-qnx7.1.0\", aarch64_unknown_nto_qnx_710),\n+    (\"x86_64-pc-nto-qnx7.1.0\", x86_64_pc_nto_qnx710),\n }\n \n /// Cow-Vec-Str: Cow<'static, [Cow<'static, str>]>\n@@ -1911,6 +1915,7 @@ impl Target {\n                 Abi::Stdcall { unwind }\n             }\n             Abi::System { unwind } => Abi::C { unwind },\n+            Abi::EfiApi if self.arch == \"arm\" => Abi::Aapcs { unwind: false },\n             Abi::EfiApi if self.arch == \"x86_64\" => Abi::Win64 { unwind: false },\n             Abi::EfiApi => Abi::C { unwind: false },\n "}, {"sha": "6fb581ef5ce34195f5928910744355e43e5e9c19", "filename": "compiler/rustc_target/src/spec/nto_qnx_base.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,19 @@\n+use crate::spec::{cvs, RelroLevel, TargetOptions};\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        crt_static_respected: true,\n+        dynamic_linking: true,\n+        env: \"nto71\".into(),\n+        executables: true,\n+        families: cvs![\"unix\"],\n+        has_rpath: true,\n+        has_thread_local: false,\n+        linker: Some(\"qcc\".into()),\n+        os: \"nto\".into(),\n+        position_independent_executables: true,\n+        static_position_independent_executables: true,\n+        relro_level: RelroLevel::Full,\n+        ..Default::default()\n+    }\n+}"}, {"sha": "e9b3acee2e7f1e1ea79766b0b60e4ebe93e2be06", "filename": "compiler/rustc_target/src/spec/x86_64_pc_nto_qnx710.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,21 @@\n+use super::nto_qnx_base;\n+use crate::spec::{Cc, LinkerFlavor, Lld, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"x86_64-pc-unknown\".into(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+            .into(),\n+        arch: \"x86_64\".into(),\n+        options: TargetOptions {\n+            cpu: \"x86-64\".into(),\n+            max_atomic_width: Some(64),\n+            pre_link_args: TargetOptions::link_args(\n+                LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n+                &[\"-Vgcc_ntox86_64_cxx\"],\n+            ),\n+            ..nto_qnx_base::opts()\n+        },\n+    }\n+}"}, {"sha": "54c738d8389759859103ae149b82fe915934ca59", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::AutoDerefReachedRecursionLimit;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::{self, TraitEngine};\n+use crate::traits::{self, TraitEngine, TraitEngineExt};\n use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt};\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             return None;\n         }\n \n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let mut fulfillcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n         let normalized_ty = fulfillcx.normalize_projection_type(\n             &self.infcx,\n             self.param_env,"}, {"sha": "19f404cb5b78821894ca5b810ade1f1a92ede472", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -58,10 +58,10 @@ pub struct NoValueInOnUnimplemented {\n     pub span: Span,\n }\n \n-pub struct NegativePositiveConflict<'a> {\n+pub struct NegativePositiveConflict<'tcx> {\n     pub impl_span: Span,\n-    pub trait_desc: &'a str,\n-    pub self_desc: &'a Option<String>,\n+    pub trait_desc: ty::TraitRef<'tcx>,\n+    pub self_ty: Option<Ty<'tcx>>,\n     pub negative_impl_span: Result<Span, Symbol>,\n     pub positive_impl_span: Result<Span, Symbol>,\n }\n@@ -73,10 +73,10 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_err(fluent::trait_selection_negative_positive_conflict);\n-        diag.set_arg(\"trait_desc\", self.trait_desc);\n+        diag.set_arg(\"trait_desc\", self.trait_desc.print_only_trait_path().to_string());\n         diag.set_arg(\n             \"self_desc\",\n-            self.self_desc.clone().map_or_else(|| String::from(\"none\"), |ty| ty),\n+            self.self_ty.map_or_else(|| \"none\".to_string(), |ty| ty.to_string()),\n         );\n         diag.set_span(self.impl_span);\n         diag.code(rustc_errors::error_code!(E0751));"}, {"sha": "8f9d5eaac9d1d5ac9e35adb52ef62d7d9dfcc6b3", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -19,7 +19,7 @@ pub struct FulfillmentContext<'tcx> {\n }\n \n impl FulfillmentContext<'_> {\n-    pub(crate) fn new() -> Self {\n+    pub(super) fn new() -> Self {\n         FulfillmentContext {\n             obligations: FxIndexSet::default(),\n             relationships: FxHashMap::default(),"}, {"sha": "3cf2959a9ffc5e7d24c6219d413c05b7dcf5ad28", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -64,13 +64,13 @@ pub fn add_placeholder_note(err: &mut Diagnostic) {\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, returns `None`.\n #[instrument(skip(tcx, skip_leak_check), level = \"debug\")]\n-pub fn overlapping_impls(\n-    tcx: TyCtxt<'_>,\n+pub fn overlapping_impls<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     skip_leak_check: SkipLeakCheck,\n     overlap_mode: OverlapMode,\n-) -> Option<OverlapResult<'_>> {\n+) -> Option<OverlapResult<'tcx>> {\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify."}, {"sha": "98c13ffdafb029f12aa273587a287cc7f9c8977d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,13 +3,14 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OutputTypeParameterMismatch, Overflow,\n-    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n+    FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes, Obligation, ObligationCause,\n+    ObligationCauseCode, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n+    SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n@@ -352,7 +353,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     })\n                     .to_predicate(self.tcx),\n                 );\n-                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n+                let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n                 fulfill_cx.register_predicate_obligation(self, obligation);\n                 if fulfill_cx.select_all_or_error(self).is_empty() {\n                     return Ok(("}, {"sha": "22e7d3ea5dd5ba1ab468e6bf1faa2b2b1187f88f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1116,7 +1116,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         err.span_suggestions(\n                             span.shrink_to_lo(),\n                             \"consider borrowing here\",\n-                            [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n+                            [\"&\".to_string(), \"&mut \".to_string()],\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {"}, {"sha": "b486c07f354b93bbf26f57cf3e1f8ace88d89286", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -85,15 +85,15 @@ static_assert_size!(PendingPredicateObligation<'_>, 72);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n-    pub fn new() -> FulfillmentContext<'tcx> {\n+    pub(super) fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n             usable_in_snapshot: false,\n         }\n     }\n \n-    pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n+    pub(super) fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),"}, {"sha": "a12f67125bbc0f2afba2fe9b15af46572743bacf", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -959,7 +959,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_coinductive(data.def_id()),\n             ty::PredicateKind::WellFormed(_) => true,\n             _ => false,\n         };"}, {"sha": "7cc12eff20e8bb15d2f4ddc99f2bcf21311e39bb", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -10,16 +10,18 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, EmissionGuarantee};\n+use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::{self, ImplSubject, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n@@ -30,10 +32,10 @@ use super::SelectionContext;\n \n /// Information pertinent to an overlapping impl error.\n #[derive(Debug)]\n-pub struct OverlapError {\n+pub struct OverlapError<'tcx> {\n     pub with_impl: DefId,\n-    pub trait_desc: String,\n-    pub self_desc: Option<String>,\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+    pub self_ty: Option<Ty<'tcx>>,\n     pub intercrate_ambiguity_causes: FxIndexSet<IntercrateAmbiguityCause>,\n     pub involves_placeholder: bool,\n }\n@@ -200,36 +202,32 @@ fn fulfill_implication<'tcx>(\n         return Err(());\n     };\n \n+    // Needs to be `in_snapshot` because this function is used to rebase\n+    // substitutions, which may happen inside of a select within a probe.\n+    let mut engine = <dyn TraitEngine<'tcx>>::new_in_snapshot(infcx.tcx);\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n+    engine.register_predicate_obligations(infcx, obligations.chain(more_obligations));\n \n-    infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let errors = traits::fully_solve_obligations(&infcx, obligations.chain(more_obligations));\n-        match &errors[..] {\n-            [] => {\n-                debug!(\n-                    \"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                    source_trait, target_trait\n-                );\n+    let errors = engine.select_all_or_error(infcx);\n+    if !errors.is_empty() {\n+        // no dice!\n+        debug!(\n+            \"fulfill_implication: for impls on {:?} and {:?}, \\\n+                 could not fulfill: {:?} given {:?}\",\n+            source_trait,\n+            target_trait,\n+            errors,\n+            param_env.caller_bounds()\n+        );\n+        return Err(());\n+    }\n \n-                // Now resolve the *substitution* we built for the target earlier, replacing\n-                // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_vars_if_possible(target_substs))\n-            }\n-            errors => {\n-                // no dice!\n-                debug!(\n-                    \"fulfill_implication: for impls on {:?} and {:?}, \\\n-                     could not fulfill: {:?} given {:?}\",\n-                    source_trait,\n-                    target_trait,\n-                    errors,\n-                    param_env.caller_bounds()\n-                );\n-                Err(())\n-            }\n-        }\n-    })\n+    debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\", source_trait, target_trait);\n+\n+    // Now resolve the *substitution* we built for the target earlier, replacing\n+    // the inference variables inside with whatever we got from fulfillment.\n+    Ok(infcx.resolve_vars_if_possible(target_substs))\n }\n \n // Query provider for `specialization_graph_of`.\n@@ -277,9 +275,9 @@ pub(super) fn specialization_graph_provider(\n // it negatively impacts perf.\n #[cold]\n #[inline(never)]\n-fn report_overlap_conflict(\n-    tcx: TyCtxt<'_>,\n-    overlap: OverlapError,\n+fn report_overlap_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overlap: OverlapError<'tcx>,\n     impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n@@ -315,27 +313,27 @@ fn report_overlap_conflict(\n     }\n }\n \n-fn report_negative_positive_conflict(\n-    tcx: TyCtxt<'_>,\n-    overlap: &OverlapError,\n+fn report_negative_positive_conflict<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overlap: &OverlapError<'tcx>,\n     local_impl_def_id: LocalDefId,\n     negative_impl_def_id: DefId,\n     positive_impl_def_id: DefId,\n     sg: &mut specialization_graph::Graph,\n ) {\n     let mut err = tcx.sess.create_err(NegativePositiveConflict {\n         impl_span: tcx.def_span(local_impl_def_id),\n-        trait_desc: &overlap.trait_desc,\n-        self_desc: &overlap.self_desc,\n+        trait_desc: overlap.trait_ref,\n+        self_ty: overlap.self_ty,\n         negative_impl_span: tcx.span_of_impl(negative_impl_def_id),\n         positive_impl_span: tcx.span_of_impl(positive_impl_def_id),\n     });\n     sg.has_errored = Some(err.emit());\n }\n \n-fn report_conflicting_impls(\n-    tcx: TyCtxt<'_>,\n-    overlap: OverlapError,\n+fn report_conflicting_impls<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overlap: OverlapError<'tcx>,\n     impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n@@ -345,12 +343,12 @@ fn report_conflicting_impls(\n     // Work to be done after we've built the DiagnosticBuilder. We have to define it\n     // now because the struct_lint methods don't return back the DiagnosticBuilder\n     // that's passed in.\n-    fn decorate<'a, 'b, G: EmissionGuarantee>(\n-        tcx: TyCtxt<'_>,\n-        overlap: OverlapError,\n+    fn decorate<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        overlap: &OverlapError<'tcx>,\n         impl_span: Span,\n-        err: &'b mut DiagnosticBuilder<'a, G>,\n-    ) -> &'b mut DiagnosticBuilder<'a, G> {\n+        err: &mut Diagnostic,\n+    ) {\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n                 err.span_label(span, \"first implementation here\");\n@@ -359,7 +357,7 @@ fn report_conflicting_impls(\n                     impl_span,\n                     format!(\n                         \"conflicting implementation{}\",\n-                        overlap.self_desc.map_or_else(String::new, |ty| format!(\" for `{}`\", ty))\n+                        overlap.self_ty.map_or_else(String::new, |ty| format!(\" for `{}`\", ty))\n                     ),\n                 );\n             }\n@@ -381,26 +379,28 @@ fn report_conflicting_impls(\n         if overlap.involves_placeholder {\n             coherence::add_placeholder_note(err);\n         }\n-        err\n     }\n \n-    let msg = format!(\n-        \"conflicting implementations of trait `{}`{}{}\",\n-        overlap.trait_desc,\n-        overlap.self_desc.as_deref().map_or_else(String::new, |ty| format!(\" for type `{ty}`\")),\n-        match used_to_be_allowed {\n-            Some(FutureCompatOverlapErrorKind::Issue33140) => \": (E0119)\",\n-            _ => \"\",\n-        }\n-    );\n+    let msg = DelayDm(|| {\n+        format!(\n+            \"conflicting implementations of trait `{}`{}{}\",\n+            overlap.trait_ref.print_only_trait_path(),\n+            overlap.self_ty.map_or_else(String::new, |ty| format!(\" for type `{ty}`\")),\n+            match used_to_be_allowed {\n+                Some(FutureCompatOverlapErrorKind::Issue33140) => \": (E0119)\",\n+                _ => \"\",\n+            }\n+        )\n+    });\n \n     match used_to_be_allowed {\n         None => {\n             let reported = if overlap.with_impl.is_local()\n                 || tcx.orphan_check_impl(impl_def_id).is_ok()\n             {\n-                let mut err = struct_span_err!(tcx.sess, impl_span, E0119, \"{msg}\",);\n-                decorate(tcx, overlap, impl_span, &mut err);\n+                let mut err = tcx.sess.struct_span_err(impl_span, msg);\n+                err.code(error_code!(E0119));\n+                decorate(tcx, &overlap, impl_span, &mut err);\n                 Some(err.emit())\n             } else {\n                 Some(tcx.sess.delay_span_bug(impl_span, \"impl should have failed the orphan check\"))\n@@ -417,7 +417,10 @@ fn report_conflicting_impls(\n                 tcx.hir().local_def_id_to_hir_id(impl_def_id),\n                 impl_span,\n                 msg,\n-                |err| decorate(tcx, overlap, impl_span, err),\n+                |err| {\n+                    decorate(tcx, &overlap, impl_span, err);\n+                    err\n+                },\n             );\n         }\n     };"}, {"sha": "4546c9533930013b0e7cc5a557230968b1dc8767", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,7 +3,6 @@ use super::OverlapError;\n use crate::traits;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -15,15 +14,15 @@ pub enum FutureCompatOverlapErrorKind {\n }\n \n #[derive(Debug)]\n-pub struct FutureCompatOverlapError {\n-    pub error: OverlapError,\n+pub struct FutureCompatOverlapError<'tcx> {\n+    pub error: OverlapError<'tcx>,\n     pub kind: FutureCompatOverlapErrorKind,\n }\n \n /// The result of attempting to insert an impl into a group of children.\n-enum Inserted {\n+enum Inserted<'tcx> {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling(Option<FutureCompatOverlapError>),\n+    BecameNewSibling(Option<FutureCompatOverlapError<'tcx>>),\n \n     /// The impl should replace existing impls [X1, ..], because the impl specializes X1, X2, etc.\n     ReplaceChildren(Vec<DefId>),\n@@ -42,12 +41,12 @@ trait ChildrenExt<'tcx> {\n         impl_def_id: DefId,\n         simplified_self: Option<SimplifiedType>,\n         overlap_mode: OverlapMode,\n-    ) -> Result<Inserted, OverlapError>;\n+    ) -> Result<Inserted<'tcx>, OverlapError<'tcx>>;\n }\n \n-impl ChildrenExt<'_> for Children {\n+impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n-    fn insert_blindly(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n+    fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n@@ -62,7 +61,7 @@ impl ChildrenExt<'_> for Children {\n     /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n-    fn remove_existing(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n+    fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n@@ -82,11 +81,11 @@ impl ChildrenExt<'_> for Children {\n     /// specialization relationships.\n     fn insert(\n         &mut self,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n         simplified_self: Option<SimplifiedType>,\n         overlap_mode: OverlapMode,\n-    ) -> Result<Inserted, OverlapError> {\n+    ) -> Result<Inserted<'tcx>, OverlapError<'tcx>> {\n         let mut last_lint = None;\n         let mut replace_children = Vec::new();\n \n@@ -103,30 +102,23 @@ impl ChildrenExt<'_> for Children {\n                 impl_def_id, simplified_self, possible_sibling,\n             );\n \n-            let create_overlap_error = |overlap: traits::coherence::OverlapResult<'_>| {\n+            let create_overlap_error = |overlap: traits::coherence::OverlapResult<'tcx>| {\n                 let trait_ref = overlap.impl_header.trait_ref.unwrap();\n                 let self_ty = trait_ref.self_ty();\n \n-                // FIXME: should postpone string formatting until we decide to actually emit.\n-                with_no_trimmed_paths!({\n-                    OverlapError {\n-                        with_impl: possible_sibling,\n-                        trait_desc: trait_ref.print_only_trait_path().to_string(),\n-                        // Only report the `Self` type if it has at least\n-                        // some outer concrete shell; otherwise, it's\n-                        // not adding much information.\n-                        self_desc: if self_ty.has_concrete_skeleton() {\n-                            Some(self_ty.to_string())\n-                        } else {\n-                            None\n-                        },\n-                        intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n-                        involves_placeholder: overlap.involves_placeholder,\n-                    }\n-                })\n+                OverlapError {\n+                    with_impl: possible_sibling,\n+                    trait_ref,\n+                    // Only report the `Self` type if it has at least\n+                    // some outer concrete shell; otherwise, it's\n+                    // not adding much information.\n+                    self_ty: if self_ty.has_concrete_skeleton() { Some(self_ty) } else { None },\n+                    intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n+                    involves_placeholder: overlap.involves_placeholder,\n+                }\n             };\n \n-            let report_overlap_error = |overlap: traits::coherence::OverlapResult<'_>,\n+            let report_overlap_error = |overlap: traits::coherence::OverlapResult<'tcx>,\n                                         last_lint: &mut _| {\n                 // Found overlap, but no specialization; error out or report future-compat warning.\n \n@@ -255,31 +247,31 @@ where\n     }\n }\n \n-pub trait GraphExt {\n+pub trait GraphExt<'tcx> {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n     fn insert(\n         &mut self,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n         overlap_mode: OverlapMode,\n-    ) -> Result<Option<FutureCompatOverlapError>, OverlapError>;\n+    ) -> Result<Option<FutureCompatOverlapError<'tcx>>, OverlapError<'tcx>>;\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'_>, parent: DefId, child: DefId);\n+    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId);\n }\n \n-impl GraphExt for Graph {\n+impl<'tcx> GraphExt<'tcx> for Graph {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n     fn insert(\n         &mut self,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n         overlap_mode: OverlapMode,\n-    ) -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n+    ) -> Result<Option<FutureCompatOverlapError<'tcx>>, OverlapError<'tcx>> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -376,7 +368,7 @@ impl GraphExt for Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'_>, parent: DefId, child: DefId) {\n+    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\n                 \"When recording an impl from the crate store, information about its parent \\"}, {"sha": "9474e6df5677b9e4500eedaee7500d861eb569ea", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -12,9 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.80.0\"\n-chalk-engine = \"0.80.0\"\n-chalk-solve = \"0.80.0\"\n+chalk-ir = \"0.87.0\"\n+chalk-engine = \"0.87.0\"\n+chalk-solve = \"0.87.0\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "d15707e5ceddb694b16f2fc4aee5d90bbca99d7d", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -142,6 +142,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             Some(CoerceUnsized)\n         } else if lang_items.dispatch_from_dyn_trait() == Some(def_id) {\n             Some(DispatchFromDyn)\n+        } else if lang_items.tuple_trait() == Some(def_id) {\n+            Some(Tuple)\n         } else {\n             None\n         };\n@@ -570,6 +572,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             CoerceUnsized => lang_items.coerce_unsized_trait(),\n             DiscriminantKind => lang_items.discriminant_kind_trait(),\n             DispatchFromDyn => lang_items.dispatch_from_dyn_trait(),\n+            Tuple => lang_items.tuple_trait(),\n         };\n         def_id.map(chalk_ir::TraitId)\n     }"}, {"sha": "25cedefa26127b70d40f8be46b74877f57d4411c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -507,9 +507,6 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n                 name: ty::BoundRegionKind::BrAnon(p.idx as u32, None),\n             }),\n             chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n-            chalk_ir::LifetimeData::Empty(_) => {\n-                bug!(\"Chalk should not have been passed an empty lifetime.\")\n-            }\n             chalk_ir::LifetimeData::Erased => return interner.tcx.lifetimes.re_erased,\n             chalk_ir::LifetimeData::Phantom(void, _) => match *void {},\n         };"}, {"sha": "7b4ad9fea137a7bd30bf835c5a86f528b058f764", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 97, "deletions": 110, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2,20 +2,18 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n     DropckConstraint, DropckOutlivesResult,\n };\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{\n-    Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -27,120 +25,109 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    let (ref infcx, goal, canonical_inference_vars) =\n-        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-    let tcx = infcx.tcx;\n-    let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-    // A stack of types left to process. Each round, we pop\n-    // something from the stack and invoke\n-    // `dtorck_constraint_for_ty`. This may produce new types that\n-    // have to be pushed on the stack. This continues until we have explored\n-    // all the reachable types from the type `for_ty`.\n-    //\n-    // Example: Imagine that we have the following code:\n-    //\n-    // ```rust\n-    // struct A {\n-    //     value: B,\n-    //     children: Vec<A>,\n-    // }\n-    //\n-    // struct B {\n-    //     value: u32\n-    // }\n-    //\n-    // fn f() {\n-    //   let a: A = ...;\n-    //   ..\n-    // } // here, `a` is dropped\n-    // ```\n-    //\n-    // at the point where `a` is dropped, we need to figure out\n-    // which types inside of `a` contain region data that may be\n-    // accessed by any destructors in `a`. We begin by pushing `A`\n-    // onto the stack, as that is the type of `a`. We will then\n-    // invoke `dtorck_constraint_for_ty` which will expand `A`\n-    // into the types of its fields `(B, Vec<A>)`. These will get\n-    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-    // lead to us trying to push `A` a second time -- to prevent\n-    // infinite recursion, we notice that `A` was already pushed\n-    // once and stop.\n-    let mut ty_stack = vec![(for_ty, 0)];\n-\n-    // Set used to detect infinite recursion.\n-    let mut ty_set = FxHashSet::default();\n-\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-    let cause = ObligationCause::dummy();\n-    let mut constraints = DropckConstraint::empty();\n-    while let Some((ty, depth)) = ty_stack.pop() {\n-        debug!(\n-            \"{} kinds, {} overflows, {} ty_stack\",\n-            result.kinds.len(),\n-            result.overflows.len(),\n-            ty_stack.len()\n-        );\n-        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-        // \"outlives\" represent types/regions that may be touched\n-        // by a destructor.\n-        result.kinds.append(&mut constraints.outlives);\n-        result.overflows.append(&mut constraints.overflows);\n-\n-        // If we have even one overflow, we should stop trying to evaluate further --\n-        // chances are, the subsequent overflows for this evaluation won't provide useful\n-        // information and will just decrease the speed at which we can emit these errors\n-        // (since we'll be printing for just that much longer for the often enormous types\n-        // that result here).\n-        if !result.overflows.is_empty() {\n-            break;\n-        }\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n+        let tcx = ocx.infcx.tcx;\n+        let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recursion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet::default();\n+\n+        let cause = ObligationCause::dummy();\n+        let mut constraints = DropckConstraint::empty();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            debug!(\n+                \"{} kinds, {} overflows, {} ty_stack\",\n+                result.kinds.len(),\n+                result.overflows.len(),\n+                ty_stack.len()\n+            );\n+            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.append(&mut constraints.outlives);\n+            result.overflows.append(&mut constraints.overflows);\n+\n+            // If we have even one overflow, we should stop trying to evaluate further --\n+            // chances are, the subsequent overflows for this evaluation won't provide useful\n+            // information and will just decrease the speed at which we can emit these errors\n+            // (since we'll be printing for just that much longer for the often enormous types\n+            // that result here).\n+            if !result.overflows.is_empty() {\n+                break;\n+            }\n \n-        // dtorck types are \"types that will get dropped but which\n-        // do not themselves define a destructor\", more or less. We have\n-        // to push them onto the stack to be expanded.\n-        for ty in constraints.dtorck_types.drain(..) {\n-            match infcx.at(&cause, param_env).normalize(ty) {\n-                Ok(Normalized { value: ty, obligations }) => {\n-                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                    match ty.kind() {\n-                        // All parameters live for the duration of the\n-                        // function.\n-                        ty::Param(..) => {}\n-\n-                        // A projection that we couldn't resolve - it\n-                        // might have a destructor.\n-                        ty::Projection(..) | ty::Opaque(..) => {\n-                            result.kinds.push(ty.into());\n-                        }\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in constraints.dtorck_types.drain(..) {\n+                let Normalized { value: ty, obligations } =\n+                    ocx.infcx.at(&cause, param_env).normalize(ty)?;\n+                ocx.register_obligations(obligations);\n+\n+                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                match ty.kind() {\n+                    // All parameters live for the duration of the\n+                    // function.\n+                    ty::Param(..) => {}\n+\n+                    // A projection that we couldn't resolve - it\n+                    // might have a destructor.\n+                    ty::Projection(..) | ty::Opaque(..) => {\n+                        result.kinds.push(ty.into());\n+                    }\n \n-                        _ => {\n-                            if ty_set.insert(ty) {\n-                                ty_stack.push((ty, depth + 1));\n-                            }\n+                    _ => {\n+                        if ty_set.insert(ty) {\n+                            ty_stack.push((ty, depth + 1));\n                         }\n                     }\n                 }\n-\n-                // We don't actually expect to fail to normalize.\n-                // That implies a WF error somewhere else.\n-                Err(NoSolution) => {\n-                    return Err(NoSolution);\n-                }\n             }\n         }\n-    }\n-\n-    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+        Ok(result)\n+    })\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}, {"sha": "cb41c4f94e2e69b803caaba802a51c7fc06f2b25", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -235,7 +235,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     neg,\n                 }) {\n                     Ok(c) => c,\n-                    Err(LitToConstError::Reported) => self.tcx.const_error(node.ty),\n+                    Err(LitToConstError::Reported(guar)) => {\n+                        self.tcx.const_error_with_guaranteed(node.ty, guar)\n+                    }\n                     Err(LitToConstError::TypeError) => {\n                         bug!(\"encountered type error in lit_to_const\")\n                     }"}, {"sha": "b59be0a0ea7945d5907438b653215a5f6320c165", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -668,7 +668,7 @@ fn layout_of_uncached<'tcx>(\n                 let mut abi = Abi::Aggregate { sized: true };\n                 let index = VariantIdx::new(0);\n                 for field in &variants[index] {\n-                    assert!(!field.is_unsized());\n+                    assert!(field.is_sized());\n                     align = align.max(field.align);\n \n                     // If all non-ZST fields have the same ABI, forward this ABI"}, {"sha": "c94a27b12a3a73661f7295f57a79f152ba3b9c3c", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -87,9 +87,10 @@ changelog-seen = 2\n # this flag will indicate that this version check should not be done.\n #version-check = true\n \n-# Link libstdc++ statically into the rustc_llvm instead of relying on a\n-# dynamic version to be available.\n-#static-libstdcpp = true\n+# When true, link libstdc++ statically into the rustc_llvm.\n+# This is useful if you don't want to use the dynamic version of that\n+# library provided by LLVM.\n+#static-libstdcpp = false\n \n # Whether to use Ninja to build LLVM. This runs much faster than make.\n #ninja = true"}, {"sha": "e5fbfc55761f41302171b33cf17ac00acc1602bc", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -28,20 +28,16 @@ extern \"Rust\" {\n     // The rustc fork of LLVM 14 and earlier also special-cases these function names to be able to optimize them\n     // like `malloc`, `realloc`, and `free`, respectively.\n     #[rustc_allocator]\n-    #[cfg_attr(not(bootstrap), rustc_nounwind)]\n-    #[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+    #[rustc_nounwind]\n     fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n     #[rustc_deallocator]\n-    #[cfg_attr(not(bootstrap), rustc_nounwind)]\n-    #[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+    #[rustc_nounwind]\n     fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     #[rustc_reallocator]\n-    #[cfg_attr(not(bootstrap), rustc_nounwind)]\n-    #[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+    #[rustc_nounwind]\n     fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;\n     #[rustc_allocator_zeroed]\n-    #[cfg_attr(not(bootstrap), rustc_nounwind)]\n-    #[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+    #[rustc_nounwind]\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n "}, {"sha": "97186589a4f4c30f1f0d935e61dca057c9b9e634", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1661,7 +1661,7 @@ impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]> {\n }\n \n #[cfg(not(no_global_oom_handling))]\n-#[stable(feature = \"boxed_array_try_from_vec\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"boxed_array_try_from_vec\", since = \"1.66.0\")]\n impl<T, const N: usize> TryFrom<Vec<T>> for Box<[T; N]> {\n     type Error = Vec<T>;\n "}, {"sha": "8a77193471234fb7149e0ec2fc80f7cd18fd98c7", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -580,7 +580,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// map.insert(1, \"a\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_btree_new\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_btree_new\", since = \"1.66.0\")]\n     #[must_use]\n     pub const fn new() -> BTreeMap<K, V> {\n         BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(Global), _marker: PhantomData }\n@@ -711,7 +711,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// map.insert(2, \"a\");\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn first_key_value(&self) -> Option<(&K, &V)>\n     where\n         K: Ord,\n@@ -739,7 +739,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// assert_eq!(*map.get(&1).unwrap(), \"first\");\n     /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V, A>>\n     where\n         K: Ord,\n@@ -773,7 +773,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// }\n     /// assert!(map.is_empty());\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn pop_first(&mut self) -> Option<(K, V)>\n     where\n         K: Ord,\n@@ -796,7 +796,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// map.insert(2, \"a\");\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn last_key_value(&self) -> Option<(&K, &V)>\n     where\n         K: Ord,\n@@ -824,7 +824,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// assert_eq!(*map.get(&1).unwrap(), \"a\");\n     /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V, A>>\n     where\n         K: Ord,\n@@ -858,7 +858,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// }\n     /// assert!(map.is_empty());\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn pop_last(&mut self) -> Option<(K, V)>\n     where\n         K: Ord,"}, {"sha": "4ddb211925202f45b27248d46f0c0e5888d17b1f", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -343,7 +343,7 @@ impl<T> BTreeSet<T> {\n     /// let mut set: BTreeSet<i32> = BTreeSet::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_btree_new\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_btree_new\", since = \"1.66.0\")]\n     #[must_use]\n     pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n@@ -796,7 +796,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// assert_eq!(set.first(), Some(&1));\n     /// ```\n     #[must_use]\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn first(&self) -> Option<&T>\n     where\n         T: Ord,\n@@ -822,7 +822,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// assert_eq!(set.last(), Some(&2));\n     /// ```\n     #[must_use]\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn last(&self) -> Option<&T>\n     where\n         T: Ord,\n@@ -846,7 +846,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// }\n     /// assert!(set.is_empty());\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn pop_first(&mut self) -> Option<T>\n     where\n         T: Ord,\n@@ -870,7 +870,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// }\n     /// assert!(set.is_empty());\n     /// ```\n-    #[stable(feature = \"map_first_last\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"map_first_last\", since = \"1.66.0\")]\n     pub fn pop_last(&mut self) -> Option<T>\n     where\n         T: Ord,"}, {"sha": "f50d9a8e1bdf38cc94626ac35167613c0819dfe5", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -7,8 +7,8 @@\n use crate::cmp;\n use crate::error::Error;\n use crate::fmt;\n-use crate::mem::{self, ValidAlign};\n-use crate::ptr::NonNull;\n+use crate::mem;\n+use crate::ptr::{Alignment, NonNull};\n \n // While this function is used in one place and its implementation\n // could be inlined, the previous attempts to do so made rustc\n@@ -46,7 +46,7 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align: ValidAlign,\n+    align: Alignment,\n }\n \n impl Layout {\n@@ -71,11 +71,11 @@ impl Layout {\n         }\n \n         // SAFETY: just checked that align is a power of two.\n-        Layout::from_size_valid_align(size, unsafe { ValidAlign::new_unchecked(align) })\n+        Layout::from_size_alignment(size, unsafe { Alignment::new_unchecked(align) })\n     }\n \n     #[inline(always)]\n-    const fn max_size_for_align(align: ValidAlign) -> usize {\n+    const fn max_size_for_align(align: Alignment) -> usize {\n         // (power-of-two implies align != 0.)\n \n         // Rounded up size is:\n@@ -95,7 +95,7 @@ impl Layout {\n \n     /// Internal helper constructor to skip revalidating alignment validity.\n     #[inline]\n-    const fn from_size_valid_align(size: usize, align: ValidAlign) -> Result<Self, LayoutError> {\n+    const fn from_size_alignment(size: usize, align: Alignment) -> Result<Self, LayoutError> {\n         if size > Self::max_size_for_align(align) {\n             return Err(LayoutError);\n         }\n@@ -117,7 +117,7 @@ impl Layout {\n     #[rustc_allow_const_fn_unstable(ptr_alignment_type)]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         // SAFETY: the caller is required to uphold the preconditions.\n-        unsafe { Layout { size, align: ValidAlign::new_unchecked(align) } }\n+        unsafe { Layout { size, align: Alignment::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n@@ -321,7 +321,7 @@ impl Layout {\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;\n \n         // The safe constructor is called here to enforce the isize size limit.\n-        Layout::from_size_valid_align(alloc_size, self.align).map(|layout| (layout, padded_size))\n+        Layout::from_size_alignment(alloc_size, self.align).map(|layout| (layout, padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -379,7 +379,7 @@ impl Layout {\n         let new_size = offset.checked_add(next.size()).ok_or(LayoutError)?;\n \n         // The safe constructor is called here to enforce the isize size limit.\n-        let layout = Layout::from_size_valid_align(new_size, new_align)?;\n+        let layout = Layout::from_size_alignment(new_size, new_align)?;\n         Ok((layout, offset))\n     }\n \n@@ -400,7 +400,7 @@ impl Layout {\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n         let size = self.size().checked_mul(n).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n-        Layout::from_size_valid_align(size, self.align)\n+        Layout::from_size_alignment(size, self.align)\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -414,7 +414,7 @@ impl Layout {\n     pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n         let new_size = self.size().checked_add(next.size()).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n-        Layout::from_size_valid_align(new_size, self.align)\n+        Layout::from_size_alignment(new_size, self.align)\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n@@ -425,10 +425,10 @@ impl Layout {\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutError> {\n         // Reduce the amount of code we need to monomorphize per `T`.\n-        return inner(mem::size_of::<T>(), ValidAlign::of::<T>(), n);\n+        return inner(mem::size_of::<T>(), Alignment::of::<T>(), n);\n \n         #[inline]\n-        fn inner(element_size: usize, align: ValidAlign, n: usize) -> Result<Layout, LayoutError> {\n+        fn inner(element_size: usize, align: Alignment, n: usize) -> Result<Layout, LayoutError> {\n             // We need to check two things about the size:\n             //  - That the total size won't overflow a `usize`, and\n             //  - That the total size still fits in an `isize`.\n@@ -443,7 +443,7 @@ impl Layout {\n \n             // SAFETY: We just checked above that the `array_size` will not\n             // exceed `isize::MAX` even when rounded up to the alignment.\n-            // And `ValidAlign` guarantees it's a power of two.\n+            // And `Alignment` guarantees it's a power of two.\n             unsafe { Ok(Layout::from_size_align_unchecked(array_size, align.as_usize())) }\n         }\n     }"}, {"sha": "f1a51a550f5792216c8d723818e1a5f7ec38fd2c", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -18,7 +18,6 @@ pub(super) const fn from_u32(i: u32) -> Option<char> {\n }\n \n /// Converts a `u32` to a `char`, ignoring validity. See [`char::from_u32_unchecked`].\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n #[inline]\n #[must_use]\n pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {"}, {"sha": "c05b68e30bc90c88d2f78746ab8e99e0d9b44563", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -140,7 +140,7 @@ impl char {\n     /// assert_eq!(None, c);\n     /// ```\n     #[stable(feature = \"assoc_char_funcs\", since = \"1.52.0\")]\n-    #[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub const fn from_u32(i: u32) -> Option<char> {\n@@ -183,7 +183,7 @@ impl char {\n     /// assert_eq!('\u2764', c);\n     /// ```\n     #[stable(feature = \"assoc_char_funcs\", since = \"1.52.0\")]\n-    #[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+    #[rustc_const_unstable(feature = \"const_char_from_u32_unchecked\", issue = \"89259\")]\n     #[must_use]\n     #[inline]\n     pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n@@ -241,7 +241,7 @@ impl char {\n     /// let _c = char::from_digit(1, 37);\n     /// ```\n     #[stable(feature = \"assoc_char_funcs\", since = \"1.52.0\")]\n-    #[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n@@ -338,7 +338,7 @@ impl char {\n     /// let _ = '1'.to_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]"}, {"sha": "55552376280ab045a5ecbf0bfa64c3a72b298aae", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -110,7 +110,7 @@ pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::Into\n \n /// Converts a `u32` to a `char`. Use [`char::from_u32`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n #[must_use]\n #[inline]\n pub const fn from_u32(i: u32) -> Option<char> {\n@@ -120,7 +120,7 @@ pub const fn from_u32(i: u32) -> Option<char> {\n /// Converts a `u32` to a `char`, ignoring validity. Use [`char::from_u32_unchecked`].\n /// instead.\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[rustc_const_unstable(feature = \"const_char_from_u32_unchecked\", issue = \"89259\")]\n #[must_use]\n #[inline]\n pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n@@ -130,7 +130,7 @@ pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n \n /// Converts a digit in the given radix to a `char`. Use [`char::from_digit`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n #[must_use]\n #[inline]\n pub const fn from_digit(num: u32, radix: u32) -> Option<char> {"}, {"sha": "5db5cbfc3dfdde2c6349e3fc145c05f29f4d6fdb", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -24,6 +24,7 @@\n \n use crate::const_closure::ConstFnMutClosure;\n use crate::marker::Destruct;\n+#[cfg(bootstrap)]\n use crate::marker::StructuralPartialEq;\n \n use self::Ordering::*;\n@@ -331,6 +332,7 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// assert_eq!(Ordering::Greater, result);\n /// ```\n #[derive(Clone, Copy, Eq, Debug, Hash)]\n+#[cfg_attr(not(bootstrap), derive_const(PartialOrd, Ord, PartialEq))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(i8)]\n pub enum Ordering {\n@@ -877,10 +879,12 @@ pub macro Ord($item:item) {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(bootstrap)]\n impl StructuralPartialEq for Ordering {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+#[cfg(bootstrap)]\n impl const PartialEq for Ordering {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n@@ -890,6 +894,7 @@ impl const PartialEq for Ordering {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+#[cfg(bootstrap)]\n impl const Ord for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n@@ -899,6 +904,7 @@ impl const Ord for Ordering {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+#[cfg(bootstrap)]\n impl const PartialOrd for Ordering {\n     #[inline]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {"}, {"sha": "d96b53de0a338328fec822aa2a2bfa1e66de5e9f", "filename": "library/core/src/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -99,7 +99,7 @@\n /// ```\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Default\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(bootstrap), const_trait)]\n+#[const_trait]\n pub trait Default: Sized {\n     /// Returns the \"default value\" for a type.\n     ///"}, {"sha": "c9c7cdf4defc6d16e67b68a22f571eee4ab21d15", "filename": "library/core/src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -493,7 +493,7 @@ impl Error for crate::char::ParseCharError {\n     }\n }\n \n-#[stable(feature = \"duration_checked_float\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n impl Error for crate::time::TryFromFloatSecsError {}\n \n #[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]"}, {"sha": "c755afa39eb608de9ffffd576b0b4d5fa443b0f5", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -86,7 +86,8 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::marker;\n+use crate::intrinsics::const_eval_select;\n+use crate::marker::{self, Destruct};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -183,6 +184,7 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n+#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -234,13 +236,25 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n-        for piece in data {\n-            piece.hash(state);\n+        //FIXME(const_trait_impl): revert to only a for loop\n+        fn rt<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n+            for piece in data {\n+                piece.hash(state)\n+            }\n+        }\n+        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n+            let mut i = 0;\n+            while i < data.len() {\n+                data[i].hash(state);\n+                i += 1;\n+            }\n         }\n+        // SAFETY: same behavior, CT just uses while instead of for\n+        unsafe { const_eval_select((data, state), ct, rt) };\n     }\n }\n \n@@ -313,6 +327,7 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -558,7 +573,8 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<H: Hasher + ?Sized> Hasher for &mut H {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -638,6 +654,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n /// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+#[const_trait]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n@@ -698,9 +715,10 @@ pub trait BuildHasher {\n     /// );\n     /// ```\n     #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n-    fn hash_one<T: Hash>(&self, x: T) -> u64\n+    fn hash_one<T: ~const Hash + ~const Destruct>(&self, x: T) -> u64\n     where\n         Self: Sized,\n+        Self::Hasher: ~const Hasher + ~const Destruct,\n     {\n         let mut hasher = self.build_hasher();\n         x.hash(&mut hasher);\n@@ -764,7 +782,8 @@ impl<H> fmt::Debug for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Default + Hasher> const BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;\n \n     fn build_hasher(&self) -> H {\n@@ -806,14 +825,15 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for $ty {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for $ty {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, state: &mut H) {\n+                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = data.len() * mem::size_of::<$ty>();\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -842,54 +862,60 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for bool {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for bool {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for char {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for char {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for str {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for str {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    impl Hash for ! {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for ! {\n         #[inline]\n-        fn hash<H: Hasher>(&self, _: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for () {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for () {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -932,24 +958,27 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash> Hash for [T] {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ~const Hash> const Hash for [T] {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &T {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &mut T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);"}, {"sha": "7f8287bf56f645d40d4a3f4658641539d55bb765", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -118,7 +118,7 @@ macro_rules! load_int_le {\n /// Safety: this performs unchecked indexing of `buf` at `start..start+len`, so\n /// that must be in-bounds.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+const unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     debug_assert!(len < 8);\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n@@ -138,7 +138,8 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n         out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n-    debug_assert_eq!(i, len);\n+    //FIXME(fee1-dead): use debug_assert_eq\n+    debug_assert!(i == len);\n     out\n }\n \n@@ -150,8 +151,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> SipHasher {\n+    pub const fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n@@ -162,8 +164,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n@@ -176,7 +179,8 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new() -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n@@ -187,14 +191,15 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n impl<S: Sip> Hasher<S> {\n     #[inline]\n-    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n+    const fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n         let mut state = Hasher {\n             k0: key0,\n             k1: key1,\n@@ -209,7 +214,7 @@ impl<S: Sip> Hasher<S> {\n     }\n \n     #[inline]\n-    fn reset(&mut self) {\n+    const fn reset(&mut self) {\n         self.length = 0;\n         self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n@@ -220,7 +225,8 @@ impl<S: Sip> Hasher<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl super::Hasher for SipHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.hasher.write(msg)\n@@ -238,7 +244,8 @@ impl super::Hasher for SipHasher {\n }\n \n #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n-impl super::Hasher for SipHasher13 {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.hasher.write(msg)\n@@ -255,7 +262,7 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-impl<S: Sip> super::Hasher for Hasher<S> {\n+impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n     // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n     // for this type. We could add them, copy the `short_write` implementation\n     // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n@@ -335,7 +342,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n     }\n }\n \n-impl<S: Sip> Clone for Hasher<S> {\n+impl<S: Sip> const Clone for Hasher<S> {\n     #[inline]\n     fn clone(&self) -> Hasher<S> {\n         Hasher {\n@@ -359,6 +366,7 @@ impl<S: Sip> Default for Hasher<S> {\n }\n \n #[doc(hidden)]\n+#[const_trait]\n trait Sip {\n     fn c_rounds(_: &mut State);\n     fn d_rounds(_: &mut State);\n@@ -367,7 +375,7 @@ trait Sip {\n #[derive(Debug, Clone, Default)]\n struct Sip13Rounds;\n \n-impl Sip for Sip13Rounds {\n+impl const Sip for Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n@@ -384,7 +392,7 @@ impl Sip for Sip13Rounds {\n #[derive(Debug, Clone, Default)]\n struct Sip24Rounds;\n \n-impl Sip for Sip24Rounds {\n+impl const Sip for Sip24Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);"}, {"sha": "c53175ba4f3f0f7bb23c701eda24d79abfae5926", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -220,7 +220,7 @@ pub fn spin_loop() {\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n #[inline]\n-#[stable(feature = \"bench_black_box\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"bench_black_box\", since = \"1.66.0\")]\n #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n pub const fn black_box<T>(dummy: T) -> T {\n     crate::intrinsics::black_box(dummy)"}, {"sha": "819ccf5a3e9e70ed7a63165fcffbb70cb67acc3b", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -793,7 +793,7 @@ extern \"rust-intrinsic\" {\n     /// uninitialized at that point in the control flow.\n     ///\n     /// This intrinsic should not be used outside of the compiler.\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n@@ -811,7 +811,7 @@ extern \"rust-intrinsic\" {\n     /// On Unix, the\n     /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n     /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,\n@@ -850,7 +850,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -865,7 +865,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n@@ -885,7 +885,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn size_of<T>() -> usize;\n \n     /// The minimum alignment of a type.\n@@ -897,7 +897,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n     ///\n@@ -926,7 +926,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -940,31 +940,31 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n     /// This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_stable(feature = \"const_assert_type\", since = \"1.59.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n     /// zero-initialization: This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` has invalid\n     /// bit patterns: This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn assert_uninit_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n@@ -976,7 +976,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -989,7 +989,7 @@ extern \"rust-intrinsic\" {\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1269,7 +1269,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn needs_drop<T: ?Sized>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1314,7 +1314,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     ///\n     /// Consider using [`pointer::mask`] instead.\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn ptr_mask<T>(ptr: *const T, mask: usize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1506,7 +1506,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n@@ -1517,7 +1517,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n@@ -1528,7 +1528,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n@@ -1539,7 +1539,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n@@ -1660,7 +1660,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `count_ones` method. For example,\n     /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1698,7 +1698,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1755,7 +1755,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1788,7 +1788,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `swap_bytes` method. For example,\n     /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n@@ -1802,7 +1802,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `reverse_bits` method. For example,\n     /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n@@ -1816,7 +1816,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n@@ -1830,7 +1830,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n@@ -1844,7 +1844,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n@@ -1919,7 +1919,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `rotate_left` method. For example,\n     /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n@@ -1933,7 +1933,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `rotate_right` method. For example,\n     /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n@@ -1947,7 +1947,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1960,7 +1960,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1973,7 +1973,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, saturating at numeric bounds.\n@@ -1987,7 +1987,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `saturating_add` method. For example,\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n@@ -2000,7 +2000,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v';\n@@ -2013,7 +2013,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n@@ -2026,7 +2026,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn variant_count<T>() -> usize;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n@@ -2060,7 +2060,7 @@ extern \"rust-intrinsic\" {\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n \n     /// Allocates a block of memory at compile time.\n@@ -2111,7 +2111,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n-    #[cfg_attr(not(bootstrap), rustc_safe_intrinsic)]\n+    #[rustc_safe_intrinsic]\n     pub fn black_box<T>(dummy: T) -> T;\n \n     /// `ptr` must point to a vtable."}, {"sha": "2d12805270f93bed274ee92d93cc32b48cf19fb5", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -104,14 +104,15 @@\n #![feature(const_black_box)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n-#![feature(const_char_convert)]\n+#![feature(const_char_from_u32_unchecked)]\n #![feature(const_clone)]\n #![feature(const_cmp)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_float_bits_conv)]\n #![feature(const_float_classify)]\n #![feature(const_fmt_arguments_new)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_convert)]\n #![feature(const_index_range_slice_index)]\n@@ -184,6 +185,7 @@\n #![feature(const_refs_to_cell)]\n #![feature(decl_macro)]\n #![feature(deprecated_suggestion)]\n+#![cfg_attr(not(bootstrap), feature(derive_const))]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n #![feature(rustdoc_internals)]"}, {"sha": "32bdc26bc51adad308ff88f7fbbcde931af04230", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1464,6 +1464,19 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Attribute macro used to apply derive macros for implementing traits\n+    /// in a const context.\n+    ///\n+    /// See [the reference] for more info.\n+    ///\n+    /// [the reference]: ../../../reference/attributes/derive.html\n+    #[unstable(feature = \"derive_const\", issue = \"none\")]\n+    #[rustc_builtin_macro]\n+    #[cfg(not(bootstrap))]\n+    pub macro derive_const($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Attribute macro applied to a function to turn it into a unit test.\n     ///\n     /// See [the reference] for more info."}, {"sha": "3f491836551dc25e07cc4cd15a15402001b69506", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1172,7 +1172,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let val = 0x12345678i32;\n+    /// let val = 0x12345678_i32;\n     /// let uninit = MaybeUninit::new(val);\n     /// let uninit_bytes = uninit.as_bytes();\n     /// let bytes = unsafe { MaybeUninit::slice_assume_init_ref(uninit_bytes) };\n@@ -1198,7 +1198,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit_as_bytes)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let val = 0x12345678i32;\n+    /// let val = 0x12345678_i32;\n     /// let mut uninit = MaybeUninit::new(val);\n     /// let uninit_bytes = uninit.as_bytes_mut();\n     /// if cfg!(target_endian = \"little\") {"}, {"sha": "956a69eda8a57af9038d125b0ded989c79adb75b", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -21,11 +21,6 @@ mod maybe_uninit;\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n pub use maybe_uninit::MaybeUninit;\n \n-// FIXME: This is left here for now to avoid complications around pending reverts.\n-// Once <https://github.com/rust-lang/rust/issues/101899> is fully resolved,\n-// this should be removed and the references in `alloc::Layout` updated.\n-pub(crate) use ptr::Alignment as ValidAlign;\n-\n mod transmutability;\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n pub use transmutability::{Assume, BikeshedIntrinsicFrom};"}, {"sha": "e64eb1cf7aed8d5d47b9c327befbf0c9bbb1d817", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -107,6 +107,9 @@ macro_rules! int_impl {\n \n         /// Returns the number of leading zeros in the binary representation of `self`.\n         ///\n+        /// Depending on what you're doing with the value, you might also be interested in the\n+        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -116,6 +119,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.leading_zeros(), 0);\n         /// ```\n+        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -467,8 +471,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -535,8 +539,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -905,8 +909,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -951,8 +955,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1129,8 +1133,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -1169,8 +1173,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n         #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -1566,8 +1570,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1648,8 +1652,8 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2068,11 +2072,15 @@ macro_rules! int_impl {\n         pub const fn rem_euclid(self, rhs: Self) -> Self {\n             let r = self % rhs;\n             if r < 0 {\n-                if rhs < 0 {\n-                    r - rhs\n-                } else {\n-                    r + rhs\n-                }\n+                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n+                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n+                // and is clearly equivalent, because `r` is negative.\n+                // Otherwise, `rhs` is `Self::MIN`, then we have\n+                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n+                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n+                // `r - Self::MIN`, which is what we wanted (and will not overflow\n+                // for negative `r`).\n+                r.wrapping_add(rhs.wrapping_abs())\n             } else {\n                 r\n             }"}, {"sha": "741d7ec6f592d159e1e4ac6cf60cda9c39da4716", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -109,6 +109,9 @@ macro_rules! uint_impl {\n \n         /// Returns the number of leading zeros in the binary representation of `self`.\n         ///\n+        /// Depending on what you're doing with the value, you might also be interested in the\n+        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -118,6 +121,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.leading_zeros(), 2);\n         /// ```\n+        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -478,8 +482,8 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1028,8 +1032,8 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1168,8 +1172,8 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1537,8 +1541,8 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n         /// ```\n-        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "c67867f4436e4a46374987c4b730a7dc1520cac7", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -61,7 +61,7 @@\n #[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Deref\"]\n-#[cfg_attr(not(bootstrap), const_trait)]\n+#[const_trait]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "910a92ec0d996d7b373481a9608e384f99a687c3", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -75,6 +75,7 @@ use crate::marker::Tuple;\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n pub trait Fn<Args>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -244,6 +245,7 @@ pub trait Fn<Args: Tuple>: FnMut<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n pub trait FnMut<Args>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -413,6 +415,7 @@ pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     #[lang = \"fn_once_output\"]"}, {"sha": "5e3dc48b6ca1c1b8a8cc464162b7a598ebb767c8", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -55,7 +55,7 @@\n #[doc(alias = \"]\")]\n #[doc(alias = \"[\")]\n #[doc(alias = \"[]\")]\n-#[cfg_attr(not(bootstrap), const_trait)]\n+#[const_trait]\n pub trait Index<Idx: ?Sized> {\n     /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -164,7 +164,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n #[doc(alias = \"[\")]\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n-#[cfg_attr(not(bootstrap), const_trait)]\n+#[const_trait]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// Performs the mutable indexing (`container[index]`) operation.\n     ///"}, {"sha": "f284b43595576e837d3e3054e8959aa403d799ea", "filename": "library/core/src/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1720,7 +1720,7 @@ impl<T, U> Option<(T, U)> {\n     /// assert_eq!(y.unzip(), (None, None));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"unzip_option\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"unzip_option\", since = \"1.66.0\")]\n     #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     pub const fn unzip(self) -> (Option<T>, Option<U>)\n     where"}, {"sha": "4fd1eb234137fb56cbe1fa6d22343b0daacb3aff", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -70,8 +70,7 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n #[cold]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cfg_attr(not(bootstrap), rustc_nounwind)]\n-#[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+#[rustc_nounwind]\n pub fn panic_str_nounwind(msg: &'static str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         super::intrinsics::abort()\n@@ -158,8 +157,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n #[cold]\n #[inline(never)]\n #[lang = \"panic_no_unwind\"] // needed by codegen for panic in nounwind function\n-#[cfg_attr(not(bootstrap), rustc_nounwind)]\n-#[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+#[rustc_nounwind]\n fn panic_no_unwind() -> ! {\n     panic_str_nounwind(\"panic in a function that cannot unwind\")\n }"}, {"sha": "d3d255a802d7f626ec89be2d0d5f683ec5914254", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -81,6 +81,10 @@ pub use crate::macros::builtin::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n \n+#[unstable(feature = \"derive_const\", issue = \"none\")]\n+#[cfg(not(bootstrap))]\n+pub use crate::macros::builtin::derive_const;\n+\n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\","}, {"sha": "742fe4f3f633b1085392a8129f464cfeae168f25", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -35,7 +35,8 @@\n //!   be used for inter-thread synchronization.\n //! * The result of casting a reference to a pointer is valid for as long as the\n //!   underlying object is live and no reference (just raw pointers) is used to\n-//!   access the same memory.\n+//!   access the same memory. That is, reference and pointer accesses cannot be\n+//!   interleaved.\n //!\n //! These axioms, along with careful use of [`offset`] for pointer arithmetic,\n //! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n@@ -64,7 +65,6 @@\n //! separate allocated object), heap allocations (each allocation created by the global allocator is\n //! a separate allocated object), and `static` variables.\n //!\n-//!\n //! # Strict Provenance\n //!\n //! **The following text is non-normative, insufficiently formal, and is an extremely strict\n@@ -1862,7 +1862,6 @@ macro_rules! fnptr_impls_safety_abi {\n         fnptr_impls_safety_abi! { #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")] $FnTy, $($Arg),* }\n     };\n     (@c_unwind $FnTy: ty, $($Arg: ident),*) => {\n-        #[cfg(not(bootstrap))]\n         fnptr_impls_safety_abi! { #[unstable(feature = \"c_unwind\", issue = \"74990\")] $FnTy, $($Arg),* }\n     };\n     (#[$meta:meta] $FnTy: ty, $($Arg: ident),*) => {"}, {"sha": "ba1cb6efa04b6a2480b571584ac7d013d58b2132", "filename": "library/core/src/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1232,7 +1232,7 @@ impl fmt::Debug for Duration {\n /// }\n /// ```\n #[derive(Debug, Clone, PartialEq, Eq)]\n-#[stable(feature = \"duration_checked_float\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n pub struct TryFromFloatSecsError {\n     kind: TryFromFloatSecsErrorKind,\n }\n@@ -1250,7 +1250,7 @@ impl TryFromFloatSecsError {\n     }\n }\n \n-#[stable(feature = \"duration_checked_float\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n impl fmt::Display for TryFromFloatSecsError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.description().fmt(f)\n@@ -1401,7 +1401,7 @@ impl Duration {\n     /// let res = Duration::try_from_secs_f32(val);\n     /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n-    #[stable(feature = \"duration_checked_float\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     #[inline]\n     pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError> {\n@@ -1478,7 +1478,7 @@ impl Duration {\n     /// let res = Duration::try_from_secs_f64(val);\n     /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n-    #[stable(feature = \"duration_checked_float\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     #[inline]\n     pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError> {"}, {"sha": "267245f05dcd2203eb7c8d6a77d086c2c81f0720", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -9,16 +9,19 @@ struct MyHasher {\n     hash: u64,\n }\n \n-impl Default for MyHasher {\n+impl const Default for MyHasher {\n     fn default() -> MyHasher {\n         MyHasher { hash: 0 }\n     }\n }\n \n-impl Hasher for MyHasher {\n+impl const Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n-        for byte in buf {\n-            self.hash += *byte as u64;\n+        // FIXME(const_trait_impl): change to for loop\n+        let mut i = 0;\n+        while i < buf.len() {\n+            self.hash += buf[i] as u64;\n+            i += 1;\n         }\n     }\n     fn write_str(&mut self, s: &str) {\n@@ -32,12 +35,25 @@ impl Hasher for MyHasher {\n \n #[test]\n fn test_writer_hasher() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut s = MyHasher { hash: 0 };\n         t.hash(&mut s);\n         s.finish()\n     }\n \n+    const {\n+        // FIXME(fee1-dead): assert_eq\n+        assert!(hash(&()) == 0);\n+        assert!(hash(&5_u8) == 5);\n+        assert!(hash(&5_u16) == 5);\n+        assert!(hash(&5_u32) == 5);\n+\n+        assert!(hash(&'a') == 97);\n+\n+        let s: &str = \"a\";\n+        assert!(hash(&s) == 97 + 0xFF);\n+    };\n+\n     assert_eq!(hash(&()), 0);\n \n     assert_eq!(hash(&5_u8), 5);\n@@ -97,7 +113,7 @@ struct CustomHasher {\n     output: u64,\n }\n \n-impl Hasher for CustomHasher {\n+impl const Hasher for CustomHasher {\n     fn finish(&self) -> u64 {\n         self.output\n     }\n@@ -109,27 +125,29 @@ impl Hasher for CustomHasher {\n     }\n }\n \n-impl Default for CustomHasher {\n+impl const Default for CustomHasher {\n     fn default() -> CustomHasher {\n         CustomHasher { output: 0 }\n     }\n }\n \n-impl Hash for Custom {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n+impl const Hash for Custom {\n+    fn hash<H: ~const Hasher>(&self, state: &mut H) {\n         state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut c = CustomHasher { output: 0 };\n         t.hash(&mut c);\n         c.finish()\n     }\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n+\n+    const { assert!(hash(&Custom { hash: 6 }) == 6) };\n }\n \n // FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten."}, {"sha": "3abf6efcfa9ba842d312f4bc4deb1a29a5b61d9b", "filename": "library/core/tests/hash/sip.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fsip.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -8,7 +8,6 @@ use core::{mem, slice};\n struct Bytes<'a>(&'a [u8]);\n \n impl<'a> Hash for Bytes<'a> {\n-    #[allow(unused_must_use)]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n@@ -24,6 +23,20 @@ fn hash<T: Hash>(x: &T) -> u64 {\n     hash_with(SipHasher::new(), x)\n }\n \n+#[test]\n+const fn test_const_sip() {\n+    let val1 = 0x45;\n+    let val2 = 0xfeed;\n+\n+    const fn const_hash<T: ~const Hash>(x: &T) -> u64 {\n+        let mut st = SipHasher::new();\n+        x.hash(&mut st);\n+        st.finish()\n+    }\n+\n+    assert!(const_hash(&(val1)) != const_hash(&(val2)));\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_1_3() {"}, {"sha": "61d31b3448734349b7c5b06ba5bf68de895d18b3", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -11,6 +11,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_convert)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]"}, {"sha": "dca6321cf62fd6f3d9e0d242f9d7ac090fbaf983", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -57,7 +57,7 @@ fn test_get_resource() {\n }\n \n #[test]\n-#[cfg_attr(not(bootstrap), allow(for_loops_over_fallibles))]\n+#[allow(for_loops_over_fallibles)]\n fn test_option_dance() {\n     let x = Some(());\n     let mut y = Some(5);"}, {"sha": "704e6ed0159f84b7cf69fc858d6df62a0e016de0", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -103,7 +103,7 @@ extern \"platform-intrinsic\" {\n     /// val: vector of values to select if a lane is masked\n     /// ptr: vector of pointers to read from\n     /// mask: a \"wide\" mask of integers, selects as if simd_select(mask, read(ptr), val)\n-    /// note, the LLVM intrinsic accepts a mask vector of <N x i1>\n+    /// note, the LLVM intrinsic accepts a mask vector of `<N x i1>`\n     /// FIXME: review this if/when we fix up our mask story in general?\n     pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n     /// llvm.masked.scatter"}, {"sha": "fc1e0bc426df34db6cb384e73a612c783c40cfd1", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -40,7 +40,7 @@ macro_rules! unsafe_base {\n \n /// SAFETY: This macro should not be used for anything except Shl or Shr, and passed the appropriate shift intrinsic.\n /// It handles performing a bitand in addition to calling the shift operator, so that the result\n-/// is well-defined: LLVM can return a poison value if you shl, lshr, or ashr if rhs >= <Int>::BITS\n+/// is well-defined: LLVM can return a poison value if you shl, lshr, or ashr if `rhs >= <Int>::BITS`\n /// At worst, this will maybe add another instruction and cycle,\n /// at best, it may open up more optimization opportunities,\n /// or simply be elided entirely, especially for SIMD ISAs which default to this."}, {"sha": "0d3fc2c5244e03fe20af3b33a2814f4c020640db", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -546,7 +546,7 @@ impl Span {\n     /// Note: The observable result of a macro should only rely on the tokens and\n     /// not on this source text. The result of this function is a best effort to\n     /// be used for diagnostics only.\n-    #[stable(feature = \"proc_macro_source_text\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"proc_macro_source_text\", since = \"1.66.0\")]\n     pub fn source_text(&self) -> Option<String> {\n         self.0.source_text()\n     }"}, {"sha": "df490358827e7ae9c8fd777450dc776a19f66b10", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3161,14 +3161,16 @@ impl DefaultHasher {\n     #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n     #[inline]\n     #[allow(deprecated)]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> DefaultHasher {\n+    pub const fn new() -> DefaultHasher {\n         DefaultHasher(SipHasher13::new_with_keys(0, 0))\n     }\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Default for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Default for DefaultHasher {\n     /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n     ///\n@@ -3180,7 +3182,8 @@ impl Default for DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Hasher for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Hasher for DefaultHasher {\n     // The underlying `SipHasher13` doesn't override the other\n     // `write_*` methods, so it's ok not to forward them here.\n "}, {"sha": "9334c833bb6509c82e3fb2a4b3cfb55125740f33", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -352,6 +352,7 @@\n //\n // Only for const-ness:\n #![feature(const_collections_with_hasher)]\n+#![feature(const_hash)]\n #![feature(const_io_structs)]\n #![feature(const_ip)]\n #![feature(const_ipv4)]"}, {"sha": "7cecd1bbfaa95bf360b839c5dbfb2ae0584c40b2", "filename": "library/std/src/os/android/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,4 +1,9 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! Android-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-pub use crate::os::net::tcp::TcpStreamExt;\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "94081c8dd31c50773dec4d5dc160c5c945170928", "filename": "library/std/src/os/linux/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,4 +1,9 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! Linux-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-pub use crate::os::net::tcp::TcpStreamExt;\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "df3fc8e6a3b660cfa61f85ccc38fff7501a95f9c", "filename": "library/std/src/os/net/linux_ext/addr.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,64 @@\n+//! Linux and Android-specific extensions to socket addresses.\n+\n+use crate::os::unix::net::SocketAddr;\n+use crate::sealed::Sealed;\n+\n+/// Platform-specific extensions to [`SocketAddr`].\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub trait SocketAddrExt: Sealed {\n+    /// Creates a Unix socket address in the abstract namespace.\n+    ///\n+    /// The abstract namespace is a Linux-specific extension that allows Unix\n+    /// sockets to be bound without creating an entry in the filesystem.\n+    /// Abstract sockets are unaffected by filesystem layout or permissions,\n+    /// and no cleanup is necessary when the socket is closed.\n+    ///\n+    /// An abstract socket address name may contain any bytes, including zero.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns an error if the name is longer than `SUN_LEN - 1`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_name(b\"hidden\")?;\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {err:?}\");\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<SocketAddr>\n+    where\n+        N: AsRef<[u8]>;\n+\n+    /// Returns the contents of this address if it is in the abstract namespace.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let name = b\"hidden\";\n+    ///     let name_addr = SocketAddr::from_abstract_name(name)?;\n+    ///     let socket = UnixListener::bind_addr(&name_addr)?;\n+    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(local_addr.as_abstract_name(), Some(&name[..]));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn as_abstract_name(&self) -> Option<&[u8]>;\n+}"}, {"sha": "318ebacfd7a08d774d6e2a01f86807df45fde3de", "filename": "library/std/src/os/net/linux_ext/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,12 @@\n+//! Linux and Android-specific networking functionality.\n+\n+#![doc(cfg(any(target_os = \"linux\", target_os = \"android\")))]\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub(crate) mod addr;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub(crate) mod tcp;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "5e9ee65a4152e4ff6d38848facd984365084228c", "filename": "library/std/src/os/net/linux_ext/tcp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs?ref=c6649aafc65f6feb96414767395a498707118496", "previous_filename": "library/std/src/os/net/tcp.rs"}, {"sha": "2db4deed03630197c897eca5fd4c5e53611ea4a2", "filename": "library/std/src/os/net/linux_ext/tests.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,9 +1,8 @@\n-#[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n #[test]\n fn quickack() {\n     use crate::{\n         net::{test::next_test_ip4, TcpListener, TcpStream},\n-        os::net::tcp::TcpStreamExt,\n+        os::net::linux_ext::tcp::TcpStreamExt,\n     };\n \n     macro_rules! t {", "previous_filename": "library/std/src/os/net/tests.rs"}, {"sha": "5ec267c41e97ca77a5e3a920b30c918633e2fd77", "filename": "library/std/src/os/net/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,7 +1,4 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! OS-specific networking functionality.\n \n-#![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-#![doc(cfg(any(target_os = \"linux\", target_os = \"android\",)))]\n-pub mod tcp;\n-#[cfg(test)]\n-mod tests;\n+#[cfg(any(target_os = \"linux\", target_os = \"android\", doc))]\n+pub(super) mod linux_ext;"}, {"sha": "81ac829d21bc81164006a02f55a81a32b0ad35c7", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 25, "deletions": 68, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,6 +1,9 @@\n use crate::ffi::OsStr;\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+use crate::os::net::linux_ext;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n+use crate::sealed::Sealed;\n use crate::sys::cvt;\n use crate::{fmt, io, mem, ptr};\n \n@@ -224,31 +227,6 @@ impl SocketAddr {\n         if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n     }\n \n-    /// Returns the contents of this address if it is an abstract namespace\n-    /// without the leading null byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let namespace = b\"hidden\";\n-    ///     let namespace_addr = SocketAddr::from_abstract_namespace(&namespace[..])?;\n-    ///     let socket = UnixListener::bind_addr(&namespace_addr)?;\n-    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(local_addr.as_abstract_namespace(), Some(&namespace[..]));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn as_abstract_namespace(&self) -> Option<&[u8]> {\n-        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n-    }\n-\n     fn address(&self) -> AddressKind<'_> {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n@@ -265,62 +243,41 @@ impl SocketAddr {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n         }\n     }\n+}\n \n-    /// Creates an abstract domain socket address from a namespace\n-    ///\n-    /// An abstract address does not create a file unlike traditional path-based\n-    /// Unix sockets. The advantage of this is that the address will disappear when\n-    /// the socket bound to it is closed, so no filesystem clean up is required.\n-    ///\n-    /// The leading null byte for the abstract namespace is automatically added.\n-    ///\n-    /// This is a Linux-specific extension. See more at [`unix(7)`].\n-    ///\n-    /// [`unix(7)`]: https://man7.org/linux/man-pages/man7/unix.7.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// This will return an error if the given namespace is too long\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n-    ///     let listener = match UnixListener::bind_addr(&addr) {\n-    ///         Ok(sock) => sock,\n-    ///         Err(err) => {\n-    ///             println!(\"Couldn't bind: {err:?}\");\n-    ///             return Err(err);\n-    ///         }\n-    ///     };\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn from_abstract_namespace(namespace: &[u8]) -> io::Result<SocketAddr> {\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl Sealed for SocketAddr {}\n+\n+#[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl linux_ext::addr::SocketAddrExt for SocketAddr {\n+    fn as_abstract_name(&self) -> Option<&[u8]> {\n+        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n+    }\n+\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<Self>\n+    where\n+        N: AsRef<[u8]>,\n+    {\n+        let name = name.as_ref();\n         unsafe {\n             let mut addr: libc::sockaddr_un = mem::zeroed();\n             addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n-            if namespace.len() + 1 > addr.sun_path.len() {\n+            if name.len() + 1 > addr.sun_path.len() {\n                 return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    \"namespace must be shorter than SUN_LEN\",\n+                    \"abstract socket name must be shorter than SUN_LEN\",\n                 ));\n             }\n \n             crate::ptr::copy_nonoverlapping(\n-                namespace.as_ptr(),\n+                name.as_ptr(),\n                 addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n-                namespace.len(),\n+                name.len(),\n             );\n-            let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;\n+            let len = (sun_path_offset(&addr) + 1 + name.len()) as libc::socklen_t;\n             SocketAddr::from_parts(addr, len)\n         }\n     }"}, {"sha": "37fcfa8446b0e00ebcb8b6a530bce8f1b854107f", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -7,6 +7,12 @@ use crate::sys_common::io::test::tmpdir;\n use crate::thread;\n use crate::time::Duration;\n \n+#[cfg(target_os = \"android\")]\n+use crate::os::android::net::SocketAddrExt;\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::os::linux::net::SocketAddrExt;\n+\n macro_rules! or_panic {\n     ($e:expr) => {\n         match $e {\n@@ -404,7 +410,7 @@ fn test_abstract_stream_connect() {\n     let msg1 = b\"hello\";\n     let msg2 = b\"world\";\n \n-    let socket_addr = or_panic!(SocketAddr::from_abstract_namespace(b\"namespace\"));\n+    let socket_addr = or_panic!(SocketAddr::from_abstract_name(b\"name\"));\n     let listener = or_panic!(UnixListener::bind_addr(&socket_addr));\n \n     let thread = thread::spawn(move || {\n@@ -418,7 +424,7 @@ fn test_abstract_stream_connect() {\n     let mut stream = or_panic!(UnixStream::connect_addr(&socket_addr));\n \n     let peer = or_panic!(stream.peer_addr());\n-    assert_eq!(peer.as_abstract_namespace().unwrap(), b\"namespace\");\n+    assert_eq!(peer.as_abstract_name().unwrap(), b\"name\");\n \n     or_panic!(stream.write_all(msg1));\n     let mut buf = vec![];\n@@ -432,7 +438,7 @@ fn test_abstract_stream_connect() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_stream_iter() {\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(b\"hidden\"));\n+    let addr = or_panic!(SocketAddr::from_abstract_name(b\"hidden\"));\n     let listener = or_panic!(UnixListener::bind_addr(&addr));\n \n     let thread = thread::spawn(move || {\n@@ -454,13 +460,13 @@ fn test_abstract_stream_iter() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_bind_send_to_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns1\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns1\"));\n     let sock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let local = or_panic!(sock1.local_addr());\n-    assert_eq!(local.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(local.as_abstract_name().unwrap(), b\"ns1\");\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns2\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns2\"));\n     let sock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     let msg = b\"hello world\";\n@@ -469,13 +475,13 @@ fn test_abstract_datagram_bind_send_to_addr() {\n     let (len, addr) = or_panic!(sock2.recv_from(&mut buf));\n     assert_eq!(msg, &buf[..]);\n     assert_eq!(len, 11);\n-    assert_eq!(addr.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(addr.as_abstract_name().unwrap(), b\"ns1\");\n }\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_connect_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns3\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns3\"));\n     let bsock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let sock = or_panic!(UnixDatagram::unbound());\n@@ -489,7 +495,7 @@ fn test_abstract_datagram_connect_addr() {\n     assert_eq!(addr.is_unnamed(), true);\n     assert_eq!(msg, &buf[..]);\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns4\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns4\"));\n     let bsock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     or_panic!(sock.connect_addr(&addr2));\n@@ -499,8 +505,8 @@ fn test_abstract_datagram_connect_addr() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_too_long() {\n-    match SocketAddr::from_abstract_namespace(\n+fn test_abstract_name_too_long() {\n+    match SocketAddr::from_abstract_name(\n         b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\\\n         opqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\\\n         jklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\",\n@@ -513,11 +519,11 @@ fn test_abstract_namespace_too_long() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_no_pathname_and_not_unnamed() {\n-    let namespace = b\"local\";\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(&namespace[..]));\n+fn test_abstract_no_pathname_and_not_unnamed() {\n+    let name = b\"local\";\n+    let addr = or_panic!(SocketAddr::from_abstract_name(name));\n     assert_eq!(addr.as_pathname(), None);\n-    assert_eq!(addr.as_abstract_namespace(), Some(&namespace[..]));\n+    assert_eq!(addr.as_abstract_name(), Some(&name[..]));\n     assert_eq!(addr.is_unnamed(), false);\n }\n "}, {"sha": "af88b9070c189dc31033414d49f6e69753a6d1dc", "filename": "library/std/src/path.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -2142,7 +2142,10 @@ impl Path {\n \n     /// Returns the `Path` without its final component, if there is one.\n     ///\n-    /// Returns [`None`] if the path terminates in a root or prefix.\n+    /// This means it returns `Some(\"\")` for relative paths with one component.\n+    ///\n+    /// Returns [`None`] if the path terminates in a root or prefix, or if it's\n+    /// the empty string.\n     ///\n     /// # Examples\n     ///\n@@ -2156,6 +2159,14 @@ impl Path {\n     /// let grand_parent = parent.parent().unwrap();\n     /// assert_eq!(grand_parent, Path::new(\"/\"));\n     /// assert_eq!(grand_parent.parent(), None);\n+    ///\n+    /// let relative_path = Path::new(\"foo/bar\");\n+    /// let parent = relative_path.parent();\n+    /// assert_eq!(parent, Some(Path::new(\"foo\")));\n+    /// let grand_parent = parent.and_then(Path::parent);\n+    /// assert_eq!(grand_parent, Some(Path::new(\"\")));\n+    /// let great_grand_parent = grand_parent.and_then(Path::parent);\n+    /// assert_eq!(great_grand_parent, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[doc(alias = \"dirname\")]"}, {"sha": "5fc1b91a1c35780fda47ef22f7722a94b9966e22", "filename": "library/std/src/personality/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -219,7 +219,7 @@ cfg_if::cfg_if! {\n         }\n \n         cfg_if::cfg_if! {\n-            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+            if #[cfg(all(windows, any(target_arch = \"aarch64\", target_arch = \"x86_64\"), target_env = \"gnu\"))] {\n                 // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n                 // handler data (aka LSDA) uses GCC-compatible encoding.\n                 #[lang = \"eh_personality\"]"}, {"sha": "d5ac16e6b94e27a6f80b83c475e4500f4128e615", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -65,6 +65,10 @@ pub use core::prelude::v1::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n \n+#[unstable(feature = \"derive_const\", issue = \"none\")]\n+#[cfg(not(bootstrap))]\n+pub use core::prelude::v1::derive_const;\n+\n // Do not `doc(no_inline)` either.\n #[unstable(\n     feature = \"cfg_accessible\","}, {"sha": "76a1b4a2a86cd461679f1ec152f49f7375a4ee66", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,7 +3,7 @@ mod tests;\n \n use crate::fmt;\n use crate::sync::{mutex, poison, LockResult, MutexGuard, PoisonError};\n-use crate::sys_common::condvar as sys;\n+use crate::sys::locks as sys;\n use crate::time::{Duration, Instant};\n \n /// A type indicating whether a timed wait on a condition variable returned"}, {"sha": "4fee8d3e92fc84b58ee1747d095f0bbbcf128d6e", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -182,6 +182,7 @@ pub mod mpsc;\n mod barrier;\n mod condvar;\n mod lazy_lock;\n+mod mpmc;\n mod mutex;\n mod once;\n mod once_lock;"}, {"sha": "4db7b4990b97d7465b01952334d082e2a56bf6b6", "filename": "library/std/src/sync/mpmc/array.rs", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,513 @@\n+//! Bounded channel based on a preallocated array.\n+//!\n+//! This flavor has a fixed, positive capacity.\n+//!\n+//! The implementation is based on Dmitry Vyukov's bounded MPMC queue.\n+//!\n+//! Source:\n+//!   - <http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue>\n+//!   - <https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub>\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+/// A slot in a channel.\n+struct Slot<T> {\n+    /// The current stamp.\n+    stamp: AtomicUsize,\n+\n+    /// The message in this slot.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+/// The token type for the array flavor.\n+#[derive(Debug)]\n+pub(crate) struct ArrayToken {\n+    /// Slot to read from or write to.\n+    slot: *const u8,\n+\n+    /// Stamp to store into the slot after reading or writing.\n+    stamp: usize,\n+}\n+\n+impl Default for ArrayToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ArrayToken { slot: ptr::null(), stamp: 0 }\n+    }\n+}\n+\n+/// Bounded channel based on a preallocated array.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit in the head is always zero.\n+    ///\n+    /// Messages are popped from the head of the channel.\n+    head: CachePadded<AtomicUsize>,\n+\n+    /// The tail of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit indicates that the channel is disconnected.\n+    ///\n+    /// Messages are pushed into the tail of the channel.\n+    tail: CachePadded<AtomicUsize>,\n+\n+    /// The buffer holding slots.\n+    buffer: Box<[Slot<T>]>,\n+\n+    /// The channel capacity.\n+    cap: usize,\n+\n+    /// A stamp with the value of `{ lap: 1, mark: 0, index: 0 }`.\n+    one_lap: usize,\n+\n+    /// If this bit is set in the tail, that means the channel is disconnected.\n+    mark_bit: usize,\n+\n+    /// Senders waiting while the channel is full.\n+    senders: SyncWaker,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a bounded channel of capacity `cap`.\n+    pub(crate) fn with_capacity(cap: usize) -> Self {\n+        assert!(cap > 0, \"capacity must be positive\");\n+\n+        // Compute constants `mark_bit` and `one_lap`.\n+        let mark_bit = (cap + 1).next_power_of_two();\n+        let one_lap = mark_bit * 2;\n+\n+        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let head = 0;\n+        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let tail = 0;\n+\n+        // Allocate a buffer of `cap` slots initialized\n+        // with stamps.\n+        let buffer: Box<[Slot<T>]> = (0..cap)\n+            .map(|i| {\n+                // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n+                Slot { stamp: AtomicUsize::new(i), msg: UnsafeCell::new(MaybeUninit::uninit()) }\n+            })\n+            .collect();\n+\n+        Channel {\n+            buffer,\n+            cap,\n+            one_lap,\n+            mark_bit,\n+            head: CachePadded::new(AtomicUsize::new(head)),\n+            tail: CachePadded::new(AtomicUsize::new(tail)),\n+            senders: SyncWaker::new(),\n+            receivers: SyncWaker::new(),\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & self.mark_bit != 0 {\n+                token.array.slot = ptr::null();\n+                token.array.stamp = 0;\n+                return true;\n+            }\n+\n+            // Deconstruct the tail.\n+            let index = tail & (self.mark_bit - 1);\n+            let lap = tail & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the tail and the stamp match, we may attempt to push.\n+            if tail == stamp {\n+                let new_tail = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    tail + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the tail.\n+                match self.tail.compare_exchange_weak(\n+                    tail,\n+                    new_tail,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `write`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = tail + 1;\n+                        return true;\n+                    }\n+                    Err(_) => {\n+                        backoff.spin();\n+                        tail = self.tail.load(Ordering::Relaxed);\n+                    }\n+                }\n+            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n+                atomic::fence(Ordering::SeqCst);\n+                let head = self.head.load(Ordering::Relaxed);\n+\n+                // If the head lags one lap behind the tail as well...\n+                if head.wrapping_add(self.one_lap) == tail {\n+                    // ...then the channel is full.\n+                    return false;\n+                }\n+\n+                backoff.spin();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.array.slot.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Write the message into the slot and update the stamp.\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n+            if head + 1 == stamp {\n+                let new = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the head.\n+                match self.head.compare_exchange_weak(\n+                    head,\n+                    new,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `read`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = head.wrapping_add(self.one_lap);\n+                        return true;\n+                    }\n+                    Err(_) => {\n+                        backoff.spin();\n+                        head = self.head.load(Ordering::Relaxed);\n+                    }\n+                }\n+            } else if stamp == head {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if (tail & !self.mark_bit) == head {\n+                    // If the channel is disconnected...\n+                    if tail & self.mark_bit != 0 {\n+                        // ...then receive an error.\n+                        token.array.slot = ptr::null();\n+                        token.array.stamp = 0;\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                backoff.spin();\n+                head = self.head.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                head = self.head.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.array.slot.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Read the message from the slot and update the stamp.\n+        let msg = slot.msg.get().read().assume_init();\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping sender.\n+        self.senders.notify();\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        if self.start_send(token) {\n+            unsafe { self.write(token, msg).map_err(TrySendError::Disconnected) }\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        loop {\n+            // Try sending a message several times.\n+            let backoff = Backoff::new();\n+            loop {\n+                if self.start_send(token) {\n+                    let res = unsafe { self.write(token, msg) };\n+                    return res.map_err(SendTimeoutError::Disconnected);\n+                }\n+\n+                if backoff.is_completed() {\n+                    break;\n+                } else {\n+                    backoff.spin();\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(SendTimeoutError::Timeout(msg));\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a receiver wakes us up.\n+                let oper = Operation::hook(token);\n+                self.senders.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_full() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.senders.unregister(oper).unwrap();\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            if self.start_recv(token) {\n+                let res = unsafe { self.read(token) };\n+                return res.map_err(|_| RecvTimeoutError::Disconnected);\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a sender wakes us up.\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail, then load the head.\n+            let tail = self.tail.load(Ordering::SeqCst);\n+            let head = self.head.load(Ordering::SeqCst);\n+\n+            // If the tail didn't change, we've got consistent values to work with.\n+            if self.tail.load(Ordering::SeqCst) == tail {\n+                let hix = head & (self.mark_bit - 1);\n+                let tix = tail & (self.mark_bit - 1);\n+\n+                return if hix < tix {\n+                    tix - hix\n+                } else if hix > tix {\n+                    self.cap - hix + tix\n+                } else if (tail & !self.mark_bit) == head {\n+                    0\n+                } else {\n+                    self.cap\n+                };\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(self.cap)\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+\n+        if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.load(Ordering::SeqCst);\n+        let tail = self.tail.load(Ordering::SeqCst);\n+\n+        // Is the tail equal to the head?\n+        //\n+        // Note: If the head changes just before we load the tail, that means there was a moment\n+        // when the channel was not empty, so it is safe to just return `false`.\n+        (tail & !self.mark_bit) == head\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        let tail = self.tail.load(Ordering::SeqCst);\n+        let head = self.head.load(Ordering::SeqCst);\n+\n+        // Is the head lagging one lap behind tail?\n+        //\n+        // Note: If the tail changes just before we load the head, that means there was a moment\n+        // when the channel was not full, so it is safe to just return `false`.\n+        head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        // Get the index of the head.\n+        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n+\n+        // Loop over all slots that hold a message and drop them.\n+        for i in 0..self.len() {\n+            // Compute the index of the next slot holding a message.\n+            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n+\n+            unsafe {\n+                debug_assert!(index < self.buffer.len());\n+                let slot = self.buffer.get_unchecked_mut(index);\n+                let msg = &mut *slot.msg.get();\n+                msg.as_mut_ptr().drop_in_place();\n+            }\n+        }\n+    }\n+}"}, {"sha": "bbfc6ce00ffc2144da81a115f905b4f7c580a087", "filename": "library/std/src/sync/mpmc/context.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,155 @@\n+//! Thread-local channel context.\n+\n+use super::select::Selected;\n+use super::waker::current_thread_id;\n+\n+use crate::cell::Cell;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n+use crate::thread::{self, Thread};\n+use crate::time::Instant;\n+\n+/// Thread-local context.\n+#[derive(Debug, Clone)]\n+pub struct Context {\n+    inner: Arc<Inner>,\n+}\n+\n+/// Inner representation of `Context`.\n+#[derive(Debug)]\n+struct Inner {\n+    /// Selected operation.\n+    select: AtomicUsize,\n+\n+    /// A slot into which another thread may store a pointer to its `Packet`.\n+    packet: AtomicPtr<()>,\n+\n+    /// Thread handle.\n+    thread: Thread,\n+\n+    /// Thread id.\n+    thread_id: usize,\n+}\n+\n+impl Context {\n+    /// Creates a new context for the duration of the closure.\n+    #[inline]\n+    pub fn with<F, R>(f: F) -> R\n+    where\n+        F: FnOnce(&Context) -> R,\n+    {\n+        thread_local! {\n+            /// Cached thread-local context.\n+            static CONTEXT: Cell<Option<Context>> = Cell::new(Some(Context::new()));\n+        }\n+\n+        let mut f = Some(f);\n+        let mut f = |cx: &Context| -> R {\n+            let f = f.take().unwrap();\n+            f(cx)\n+        };\n+\n+        CONTEXT\n+            .try_with(|cell| match cell.take() {\n+                None => f(&Context::new()),\n+                Some(cx) => {\n+                    cx.reset();\n+                    let res = f(&cx);\n+                    cell.set(Some(cx));\n+                    res\n+                }\n+            })\n+            .unwrap_or_else(|_| f(&Context::new()))\n+    }\n+\n+    /// Creates a new `Context`.\n+    #[cold]\n+    fn new() -> Context {\n+        Context {\n+            inner: Arc::new(Inner {\n+                select: AtomicUsize::new(Selected::Waiting.into()),\n+                packet: AtomicPtr::new(ptr::null_mut()),\n+                thread: thread::current(),\n+                thread_id: current_thread_id(),\n+            }),\n+        }\n+    }\n+\n+    /// Resets `select` and `packet`.\n+    #[inline]\n+    fn reset(&self) {\n+        self.inner.select.store(Selected::Waiting.into(), Ordering::Release);\n+        self.inner.packet.store(ptr::null_mut(), Ordering::Release);\n+    }\n+\n+    /// Attempts to select an operation.\n+    ///\n+    /// On failure, the previously selected operation is returned.\n+    #[inline]\n+    pub fn try_select(&self, select: Selected) -> Result<(), Selected> {\n+        self.inner\n+            .select\n+            .compare_exchange(\n+                Selected::Waiting.into(),\n+                select.into(),\n+                Ordering::AcqRel,\n+                Ordering::Acquire,\n+            )\n+            .map(|_| ())\n+            .map_err(|e| e.into())\n+    }\n+\n+    /// Stores a packet.\n+    ///\n+    /// This method must be called after `try_select` succeeds and there is a packet to provide.\n+    #[inline]\n+    pub fn store_packet(&self, packet: *mut ()) {\n+        if !packet.is_null() {\n+            self.inner.packet.store(packet, Ordering::Release);\n+        }\n+    }\n+\n+    /// Waits until an operation is selected and returns it.\n+    ///\n+    /// If the deadline is reached, `Selected::Aborted` will be selected.\n+    #[inline]\n+    pub fn wait_until(&self, deadline: Option<Instant>) -> Selected {\n+        loop {\n+            // Check whether an operation has been selected.\n+            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n+            if sel != Selected::Waiting {\n+                return sel;\n+            }\n+\n+            // If there's a deadline, park the current thread until the deadline is reached.\n+            if let Some(end) = deadline {\n+                let now = Instant::now();\n+\n+                if now < end {\n+                    thread::park_timeout(end - now);\n+                } else {\n+                    // The deadline has been reached. Try aborting select.\n+                    return match self.try_select(Selected::Aborted) {\n+                        Ok(()) => Selected::Aborted,\n+                        Err(s) => s,\n+                    };\n+                }\n+            } else {\n+                thread::park();\n+            }\n+        }\n+    }\n+\n+    /// Unparks the thread this context belongs to.\n+    #[inline]\n+    pub fn unpark(&self) {\n+        self.inner.thread.unpark();\n+    }\n+\n+    /// Returns the id of the thread this context belongs to.\n+    #[inline]\n+    pub fn thread_id(&self) -> usize {\n+        self.inner.thread_id\n+    }\n+}"}, {"sha": "a5a6bdc67f13fd0f97fa150bd6582f59827e15f0", "filename": "library/std/src/sync/mpmc/counter.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,137 @@\n+use crate::ops;\n+use crate::process;\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+\n+/// Reference counter internals.\n+struct Counter<C> {\n+    /// The number of senders associated with the channel.\n+    senders: AtomicUsize,\n+\n+    /// The number of receivers associated with the channel.\n+    receivers: AtomicUsize,\n+\n+    /// Set to `true` if the last sender or the last receiver reference deallocates the channel.\n+    destroy: AtomicBool,\n+\n+    /// The internal channel.\n+    chan: C,\n+}\n+\n+/// Wraps a channel into the reference counter.\n+pub(crate) fn new<C>(chan: C) -> (Sender<C>, Receiver<C>) {\n+    let counter = Box::into_raw(Box::new(Counter {\n+        senders: AtomicUsize::new(1),\n+        receivers: AtomicUsize::new(1),\n+        destroy: AtomicBool::new(false),\n+        chan,\n+    }));\n+    let s = Sender { counter };\n+    let r = Receiver { counter };\n+    (s, r)\n+}\n+\n+/// The sending side.\n+pub(crate) struct Sender<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Sender<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another sender reference.\n+    pub(crate) fn acquire(&self) -> Sender<C> {\n+        let count = self.counter().senders.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning senders and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Sender { counter: self.counter }\n+    }\n+\n+    /// Releases the sender reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last sender reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().senders.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Sender<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Sender<C> {\n+    fn eq(&self, other: &Sender<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}\n+\n+/// The receiving side.\n+pub(crate) struct Receiver<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Receiver<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another receiver reference.\n+    pub(crate) fn acquire(&self) -> Receiver<C> {\n+        let count = self.counter().receivers.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning receivers and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Receiver { counter: self.counter }\n+    }\n+\n+    /// Releases the receiver reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last receiver reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().receivers.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Receiver<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Receiver<C> {\n+    fn eq(&self, other: &Receiver<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}"}, {"sha": "1b8a1f387974d9152173315ad77e2b4262903a8c", "filename": "library/std/src/sync/mpmc/error.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,46 @@\n+use crate::error;\n+use crate::fmt;\n+\n+pub use crate::sync::mpsc::{RecvError, RecvTimeoutError, SendError, TryRecvError, TrySendError};\n+\n+/// An error returned from the [`send_timeout`] method.\n+///\n+/// The error contains the message being sent so it can be recovered.\n+///\n+/// [`send_timeout`]: super::Sender::send_timeout\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum SendTimeoutError<T> {\n+    /// The message could not be sent because the channel is full and the operation timed out.\n+    ///\n+    /// If this is a zero-capacity channel, then the error indicates that there was no receiver\n+    /// available to receive the message and the operation timed out.\n+    Timeout(T),\n+\n+    /// The message could not be sent because the channel is disconnected.\n+    Disconnected(T),\n+}\n+\n+impl<T> fmt::Debug for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"SendTimeoutError(..)\".fmt(f)\n+    }\n+}\n+\n+impl<T> fmt::Display for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            SendTimeoutError::Timeout(..) => \"timed out waiting on send operation\".fmt(f),\n+            SendTimeoutError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl<T: Send> error::Error for SendTimeoutError<T> {}\n+\n+impl<T> From<SendError<T>> for SendTimeoutError<T> {\n+    fn from(err: SendError<T>) -> SendTimeoutError<T> {\n+        match err {\n+            SendError(e) => SendTimeoutError::Disconnected(e),\n+        }\n+    }\n+}"}, {"sha": "2d5b2fb3b231d35c6bc86c575ae58be990e885b2", "filename": "library/std/src/sync/mpmc/list.rs", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,638 @@\n+//! Unbounded channel implemented as a linked list.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+// Bits indicating the state of a slot:\n+// * If a message has been written into the slot, `WRITE` is set.\n+// * If a message has been read from the slot, `READ` is set.\n+// * If the block is being destroyed, `DESTROY` is set.\n+const WRITE: usize = 1;\n+const READ: usize = 2;\n+const DESTROY: usize = 4;\n+\n+// Each block covers one \"lap\" of indices.\n+const LAP: usize = 32;\n+// The maximum number of messages a block can hold.\n+const BLOCK_CAP: usize = LAP - 1;\n+// How many lower bits are reserved for metadata.\n+const SHIFT: usize = 1;\n+// Has two different purposes:\n+// * If set in head, indicates that the block is not the last one.\n+// * If set in tail, indicates that the channel is disconnected.\n+const MARK_BIT: usize = 1;\n+\n+/// A slot in a block.\n+struct Slot<T> {\n+    /// The message.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+\n+    /// The state of the slot.\n+    state: AtomicUsize,\n+}\n+\n+impl<T> Slot<T> {\n+    /// Waits until a message is written into the slot.\n+    fn wait_write(&self) {\n+        let backoff = Backoff::new();\n+        while self.state.load(Ordering::Acquire) & WRITE == 0 {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// A block in a linked list.\n+///\n+/// Each block in the list can hold up to `BLOCK_CAP` messages.\n+struct Block<T> {\n+    /// The next block in the linked list.\n+    next: AtomicPtr<Block<T>>,\n+\n+    /// Slots for messages.\n+    slots: [Slot<T>; BLOCK_CAP],\n+}\n+\n+impl<T> Block<T> {\n+    /// Creates an empty block.\n+    fn new() -> Block<T> {\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n+    }\n+\n+    /// Waits until the next pointer is set.\n+    fn wait_next(&self) -> *mut Block<T> {\n+        let backoff = Backoff::new();\n+        loop {\n+            let next = self.next.load(Ordering::Acquire);\n+            if !next.is_null() {\n+                return next;\n+            }\n+            backoff.snooze();\n+        }\n+    }\n+\n+    /// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.\n+    unsafe fn destroy(this: *mut Block<T>, start: usize) {\n+        // It is not necessary to set the `DESTROY` bit in the last slot because that slot has\n+        // begun destruction of the block.\n+        for i in start..BLOCK_CAP - 1 {\n+            let slot = (*this).slots.get_unchecked(i);\n+\n+            // Mark the `DESTROY` bit if a thread is still using the slot.\n+            if slot.state.load(Ordering::Acquire) & READ == 0\n+                && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0\n+            {\n+                // If a thread is still using the slot, it will continue destruction of the block.\n+                return;\n+            }\n+        }\n+\n+        // No thread is using the block, now it is safe to destroy it.\n+        drop(Box::from_raw(this));\n+    }\n+}\n+\n+/// A position in a channel.\n+#[derive(Debug)]\n+struct Position<T> {\n+    /// The index in the channel.\n+    index: AtomicUsize,\n+\n+    /// The block in the linked list.\n+    block: AtomicPtr<Block<T>>,\n+}\n+\n+/// The token type for the list flavor.\n+#[derive(Debug)]\n+pub(crate) struct ListToken {\n+    /// The block of slots.\n+    block: *const u8,\n+\n+    /// The offset into the block.\n+    offset: usize,\n+}\n+\n+impl Default for ListToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ListToken { block: ptr::null(), offset: 0 }\n+    }\n+}\n+\n+/// Unbounded channel implemented as a linked list.\n+///\n+/// Each message sent into the channel is assigned a sequence number, i.e. an index. Indices are\n+/// represented as numbers of type `usize` and wrap on overflow.\n+///\n+/// Consecutive messages are grouped into blocks in order to put less pressure on the allocator and\n+/// improve cache efficiency.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    head: CachePadded<Position<T>>,\n+\n+    /// The tail of the channel.\n+    tail: CachePadded<Position<T>>,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop messages of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a new unbounded channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            head: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            tail: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            receivers: SyncWaker::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        let mut block = self.tail.block.load(Ordering::Acquire);\n+        let mut next_block = None;\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & MARK_BIT != 0 {\n+                token.list.block = ptr::null();\n+                return true;\n+            }\n+\n+            // Calculate the offset of the index into the block.\n+            let offset = (tail >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                tail = self.tail.index.load(Ordering::Acquire);\n+                block = self.tail.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // If we're going to have to install the next block, allocate it in advance in order to\n+            // make the wait for other threads as short as possible.\n+            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n+                next_block = Some(Box::new(Block::<T>::new()));\n+            }\n+\n+            // If this is the first message to be sent into the channel, we need to allocate the\n+            // first block and install it.\n+            if block.is_null() {\n+                let new = Box::into_raw(Box::new(Block::<T>::new()));\n+\n+                if self\n+                    .tail\n+                    .block\n+                    .compare_exchange(block, new, Ordering::Release, Ordering::Relaxed)\n+                    .is_ok()\n+                {\n+                    self.head.block.store(new, Ordering::Release);\n+                    block = new;\n+                } else {\n+                    next_block = unsafe { Some(Box::from_raw(new)) };\n+                    tail = self.tail.index.load(Ordering::Acquire);\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                    continue;\n+                }\n+            }\n+\n+            let new_tail = tail + (1 << SHIFT);\n+\n+            // Try advancing the tail forward.\n+            match self.tail.index.compare_exchange_weak(\n+                tail,\n+                new_tail,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, install the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next_block = Box::into_raw(next_block.unwrap());\n+                        self.tail.block.store(next_block, Ordering::Release);\n+                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n+                        (*block).next.store(next_block, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(_) => {\n+                    backoff.spin();\n+                    tail = self.tail.index.load(Ordering::Acquire);\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.list.block.is_null() {\n+            return Err(msg);\n+        }\n+\n+        // Write the message into the slot.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.state.fetch_or(WRITE, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        loop {\n+            // Calculate the offset of the index into the block.\n+            let offset = (head >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            let mut new_head = head + (1 << SHIFT);\n+\n+            if new_head & MARK_BIT == 0 {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.index.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if head >> SHIFT == tail >> SHIFT {\n+                    // If the channel is disconnected...\n+                    if tail & MARK_BIT != 0 {\n+                        // ...then receive an error.\n+                        token.list.block = ptr::null();\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                // If head and tail are not in the same block, set `MARK_BIT` in head.\n+                if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {\n+                    new_head |= MARK_BIT;\n+                }\n+            }\n+\n+            // The block can be null here only if the first message is being sent into the channel.\n+            // In that case, just wait until it gets initialized.\n+            if block.is_null() {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // Try moving the head index forward.\n+            match self.head.index.compare_exchange_weak(\n+                head,\n+                new_head,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, move to the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next = (*block).wait_next();\n+                        let mut next_index = (new_head & !MARK_BIT).wrapping_add(1 << SHIFT);\n+                        if !(*next).next.load(Ordering::Relaxed).is_null() {\n+                            next_index |= MARK_BIT;\n+                        }\n+\n+                        self.head.block.store(next, Ordering::Release);\n+                        self.head.index.store(next_index, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(_) => {\n+                    backoff.spin();\n+                    head = self.head.index.load(Ordering::Acquire);\n+                    block = self.head.block.load(Ordering::Acquire);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.list.block.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        // Read the message.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.wait_write();\n+        let msg = slot.msg.get().read().assume_init();\n+\n+        // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n+        // couldn't because we were busy reading from the slot.\n+        if offset + 1 == BLOCK_CAP {\n+            Block::destroy(block, 0);\n+        } else if slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0 {\n+            Block::destroy(block, offset + 1);\n+        }\n+\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        self.send(msg, None).map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => TrySendError::Disconnected(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        _deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        assert!(self.start_send(token));\n+        unsafe { self.write(token, msg).map_err(SendTimeoutError::Disconnected) }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            if self.start_recv(token) {\n+                unsafe {\n+                    return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            // Prepare for blocking until a sender wakes us up.\n+            Context::with(|cx| {\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail index, then load the head index.\n+            let mut tail = self.tail.index.load(Ordering::SeqCst);\n+            let mut head = self.head.index.load(Ordering::SeqCst);\n+\n+            // If the tail index didn't change, we've got consistent indices to work with.\n+            if self.tail.index.load(Ordering::SeqCst) == tail {\n+                // Erase the lower bits.\n+                tail &= !((1 << SHIFT) - 1);\n+                head &= !((1 << SHIFT) - 1);\n+\n+                // Fix up indices if they fall onto block ends.\n+                if (tail >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    tail = tail.wrapping_add(1 << SHIFT);\n+                }\n+                if (head >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    head = head.wrapping_add(1 << SHIFT);\n+                }\n+\n+                // Rotate indices so that head falls into the first block.\n+                let lap = (head >> SHIFT) / LAP;\n+                tail = tail.wrapping_sub((lap * LAP) << SHIFT);\n+                head = head.wrapping_sub((lap * LAP) << SHIFT);\n+\n+                // Remove the lower bits.\n+                tail >>= SHIFT;\n+                head >>= SHIFT;\n+\n+                // Return the difference minus the number of blocks between tail and head.\n+                return tail - head - tail / LAP;\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        None\n+    }\n+\n+    /// Disconnects senders and wakes up all blocked receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Disconnects receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            // If receivers are dropped first, discard all messages to free\n+            // memory eagerly.\n+            self.discard_all_messages();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// This method should only be called when all receivers are dropped.\n+    fn discard_all_messages(&self) {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        loop {\n+            let offset = (tail >> SHIFT) % LAP;\n+            if offset != BLOCK_CAP {\n+                break;\n+            }\n+\n+            // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n+            // at boundary. We need to wait for the updates take affect otherwise there\n+            // can be memory leaks.\n+            backoff.snooze();\n+            tail = self.tail.index.load(Ordering::Acquire);\n+        }\n+\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head >> SHIFT != tail >> SHIFT {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    slot.wait_write();\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    (*block).wait_next();\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Acquire);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+        head &= !MARK_BIT;\n+        self.head.block.store(ptr::null_mut(), Ordering::Release);\n+        self.head.index.store(head, Ordering::Release);\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.index.load(Ordering::SeqCst) & MARK_BIT != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.index.load(Ordering::SeqCst);\n+        let tail = self.tail.index.load(Ordering::SeqCst);\n+        head >> SHIFT == tail >> SHIFT\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        let mut head = self.head.index.load(Ordering::Relaxed);\n+        let mut tail = self.tail.index.load(Ordering::Relaxed);\n+        let mut block = self.head.block.load(Ordering::Relaxed);\n+\n+        // Erase the lower bits.\n+        head &= !((1 << SHIFT) - 1);\n+        tail &= !((1 << SHIFT) - 1);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head != tail {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Relaxed);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+    }\n+}"}, {"sha": "cef99c58843009bda1d5ddbe5b02fd64c93f32e2", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,430 @@\n+//! Multi-producer multi-consumer channels.\n+\n+// This module is not currently exposed publicly, but is used\n+// as the implementation for the channels in `sync::mpsc`. The\n+// implementation comes from the crossbeam-channel crate:\n+//\n+// Copyright (c) 2019 The Crossbeam Project Developers\n+//\n+// Permission is hereby granted, free of charge, to any\n+// person obtaining a copy of this software and associated\n+// documentation files (the \"Software\"), to deal in the\n+// Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge,\n+// publish, distribute, sublicense, and/or sell copies of\n+// the Software, and to permit persons to whom the Software\n+// is furnished to do so, subject to the following\n+// conditions:\n+//\n+// The above copyright notice and this permission notice\n+// shall be included in all copies or substantial portions\n+// of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+mod array;\n+mod context;\n+mod counter;\n+mod error;\n+mod list;\n+mod select;\n+mod utils;\n+mod waker;\n+mod zero;\n+\n+use crate::fmt;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::time::{Duration, Instant};\n+use error::*;\n+\n+/// Creates a channel of unbounded capacity.\n+///\n+/// This channel has a growable buffer that can hold any number of messages at a time.\n+pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n+    let (s, r) = counter::new(list::Channel::new());\n+    let s = Sender { flavor: SenderFlavor::List(s) };\n+    let r = Receiver { flavor: ReceiverFlavor::List(r) };\n+    (s, r)\n+}\n+\n+/// Creates a channel of bounded capacity.\n+///\n+/// This channel has a buffer that can hold at most `cap` messages at a time.\n+///\n+/// A special case is zero-capacity channel, which cannot hold any messages. Instead, send and\n+/// receive operations must appear at the same time in order to pair up and pass the message over.\n+pub fn sync_channel<T>(cap: usize) -> (Sender<T>, Receiver<T>) {\n+    if cap == 0 {\n+        let (s, r) = counter::new(zero::Channel::new());\n+        let s = Sender { flavor: SenderFlavor::Zero(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Zero(r) };\n+        (s, r)\n+    } else {\n+        let (s, r) = counter::new(array::Channel::with_capacity(cap));\n+        let s = Sender { flavor: SenderFlavor::Array(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Array(r) };\n+        (s, r)\n+    }\n+}\n+\n+/// The sending side of a channel.\n+pub struct Sender<T> {\n+    flavor: SenderFlavor<T>,\n+}\n+\n+/// Sender flavors.\n+enum SenderFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Sender<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Sender<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Sender<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Sender<T> {}\n+unsafe impl<T: Send> Sync for Sender<T> {}\n+\n+impl<T> UnwindSafe for Sender<T> {}\n+impl<T> RefUnwindSafe for Sender<T> {}\n+\n+impl<T> Sender<T> {\n+    /// Attempts to send a message into the channel without blocking.\n+    ///\n+    /// This method will either send a message into the channel immediately or return an error if\n+    /// the channel is full or disconnected. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will send the message only if there\n+    /// happens to be a receive operation on the other side of the channel at the same time.\n+    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.try_send(msg),\n+            SenderFlavor::List(chan) => chan.try_send(msg),\n+            SenderFlavor::Zero(chan) => chan.try_send(msg),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is sent or the channel is disconnected.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed. If the channel becomes disconnected, this call will wake up and return an\n+    /// error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send(&self, msg: T) -> Result<(), SendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, None),\n+            SenderFlavor::List(chan) => chan.send(msg, None),\n+            SenderFlavor::Zero(chan) => chan.send(msg, None),\n+        }\n+        .map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => SendError(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Sender<T> {\n+    /// Waits for a message to be sent into the channel, but only for a limited time.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.send_deadline(msg, deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.send(msg).map_err(SendTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be sent into the channel, but only until a given deadline.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_deadline(&self, msg: T, deadline: Instant) -> Result<(), SendTimeoutError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::List(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::Zero(chan) => chan.send(msg, Some(deadline)),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_empty(),\n+            SenderFlavor::List(chan) => chan.is_empty(),\n+            SenderFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_full(),\n+            SenderFlavor::List(chan) => chan.is_full(),\n+            SenderFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.len(),\n+            SenderFlavor::List(chan) => chan.len(),\n+            SenderFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.capacity(),\n+            SenderFlavor::List(chan) => chan.capacity(),\n+            SenderFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if senders belong to the same channel.\n+    pub fn same_channel(&self, other: &Sender<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (SenderFlavor::Array(ref a), SenderFlavor::Array(ref b)) => a == b,\n+            (SenderFlavor::List(ref a), SenderFlavor::List(ref b)) => a == b,\n+            (SenderFlavor::Zero(ref a), SenderFlavor::Zero(ref b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Sender<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n+                SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Sender<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            SenderFlavor::Array(chan) => SenderFlavor::Array(chan.acquire()),\n+            SenderFlavor::List(chan) => SenderFlavor::List(chan.acquire()),\n+            SenderFlavor::Zero(chan) => SenderFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Sender { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Sender<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Sender { .. }\")\n+    }\n+}\n+\n+/// The receiving side of a channel.\n+pub struct Receiver<T> {\n+    flavor: ReceiverFlavor<T>,\n+}\n+\n+/// Receiver flavors.\n+enum ReceiverFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Receiver<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Receiver<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Receiver<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Receiver<T> {}\n+unsafe impl<T: Send> Sync for Receiver<T> {}\n+\n+impl<T> UnwindSafe for Receiver<T> {}\n+impl<T> RefUnwindSafe for Receiver<T> {}\n+\n+impl<T> Receiver<T> {\n+    /// Attempts to receive a message from the channel without blocking.\n+    ///\n+    /// This method will either receive a message from the channel immediately or return an error\n+    /// if the channel is empty.\n+    ///\n+    /// If called on a zero-capacity channel, this method will receive a message only if there\n+    /// happens to be a send operation on the other side of the channel at the same time.\n+    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.try_recv(),\n+            ReceiverFlavor::List(chan) => chan.try_recv(),\n+            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is received or the channel is empty and\n+    /// disconnected.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed. If the channel is empty and becomes disconnected, this call will\n+    /// wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv(&self) -> Result<T, RecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(None),\n+            ReceiverFlavor::List(chan) => chan.recv(None),\n+            ReceiverFlavor::Zero(chan) => chan.recv(None),\n+        }\n+        .map_err(|_| RecvError)\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.recv_deadline(deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.recv().map_err(RecvTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::List(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::Zero(chan) => chan.recv(Some(deadline)),\n+        }\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Receiver<T> {\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_empty(),\n+            ReceiverFlavor::List(chan) => chan.is_empty(),\n+            ReceiverFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_full(),\n+            ReceiverFlavor::List(chan) => chan.is_full(),\n+            ReceiverFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.len(),\n+            ReceiverFlavor::List(chan) => chan.len(),\n+            ReceiverFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.capacity(),\n+            ReceiverFlavor::List(chan) => chan.capacity(),\n+            ReceiverFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if receivers belong to the same channel.\n+    pub fn same_channel(&self, other: &Receiver<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (ReceiverFlavor::Array(a), ReceiverFlavor::Array(b)) => a == b,\n+            (ReceiverFlavor::List(a), ReceiverFlavor::List(b)) => a == b,\n+            (ReceiverFlavor::Zero(a), ReceiverFlavor::Zero(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Receiver<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n+                ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Receiver<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            ReceiverFlavor::Array(chan) => ReceiverFlavor::Array(chan.acquire()),\n+            ReceiverFlavor::List(chan) => ReceiverFlavor::List(chan.acquire()),\n+            ReceiverFlavor::Zero(chan) => ReceiverFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Receiver { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Receiver<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Receiver { .. }\")\n+    }\n+}"}, {"sha": "56a83fee2e119c3396c394b67ca99d8599f117a2", "filename": "library/std/src/sync/mpmc/select.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,71 @@\n+/// Temporary data that gets initialized during a blocking operation, and is consumed by\n+/// `read` or `write`.\n+///\n+/// Each field contains data associated with a specific channel flavor.\n+#[derive(Debug, Default)]\n+pub struct Token {\n+    pub(crate) array: super::array::ArrayToken,\n+    pub(crate) list: super::list::ListToken,\n+    #[allow(dead_code)]\n+    pub(crate) zero: super::zero::ZeroToken,\n+}\n+\n+/// Identifier associated with an operation by a specific thread on a specific channel.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct Operation(usize);\n+\n+impl Operation {\n+    /// Creates an operation identifier from a mutable reference.\n+    ///\n+    /// This function essentially just turns the address of the reference into a number. The\n+    /// reference should point to a variable that is specific to the thread and the operation,\n+    /// and is alive for the entire duration of a blocking operation.\n+    #[inline]\n+    pub fn hook<T>(r: &mut T) -> Operation {\n+        let val = r as *mut T as usize;\n+        // Make sure that the pointer address doesn't equal the numerical representation of\n+        // `Selected::{Waiting, Aborted, Disconnected}`.\n+        assert!(val > 2);\n+        Operation(val)\n+    }\n+}\n+\n+/// Current state of a blocking operation.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Selected {\n+    /// Still waiting for an operation.\n+    Waiting,\n+\n+    /// The attempt to block the current thread has been aborted.\n+    Aborted,\n+\n+    /// An operation became ready because a channel is disconnected.\n+    Disconnected,\n+\n+    /// An operation became ready because a message can be sent or received.\n+    Operation(Operation),\n+}\n+\n+impl From<usize> for Selected {\n+    #[inline]\n+    fn from(val: usize) -> Selected {\n+        match val {\n+            0 => Selected::Waiting,\n+            1 => Selected::Aborted,\n+            2 => Selected::Disconnected,\n+            oper => Selected::Operation(Operation(oper)),\n+        }\n+    }\n+}\n+\n+impl Into<usize> for Selected {\n+    #[inline]\n+    fn into(self) -> usize {\n+        match self {\n+            Selected::Waiting => 0,\n+            Selected::Aborted => 1,\n+            Selected::Disconnected => 2,\n+            Selected::Operation(Operation(val)) => val,\n+        }\n+    }\n+}"}, {"sha": "d0904b4b94cbcc09cb705eca3d42de6ada989ce2", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,144 @@\n+use crate::cell::Cell;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// Pads and aligns a value to the length of a cache line.\n+#[derive(Clone, Copy, Default, Hash, PartialEq, Eq)]\n+// Starting from Intel's Sandy Bridge, spatial prefetcher is now pulling pairs of 64-byte cache\n+// lines at a time, so we have to align to 128 bytes rather than 64.\n+//\n+// Sources:\n+// - https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf\n+// - https://github.com/facebook/folly/blob/1b5288e6eea6df074758f877c849b6e73bbb9fbb/folly/lang/Align.h#L107\n+//\n+// ARM's big.LITTLE architecture has asymmetric cores and \"big\" cores have 128-byte cache line size.\n+//\n+// Sources:\n+// - https://www.mono-project.com/news/2016/09/12/arm64-icache/\n+//\n+// powerpc64 has 128-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_ppc64x.go#L9\n+#[cfg_attr(\n+    any(target_arch = \"x86_64\", target_arch = \"aarch64\", target_arch = \"powerpc64\",),\n+    repr(align(128))\n+)]\n+// arm, mips, mips64, and riscv64 have 32-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_arm.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mipsle.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips64x.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_riscv64.go#L7\n+#[cfg_attr(\n+    any(\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+    ),\n+    repr(align(32))\n+)]\n+// s390x has 256-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_s390x.go#L7\n+#[cfg_attr(target_arch = \"s390x\", repr(align(256)))]\n+// x86 and wasm have 64-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/dda2991c2ea0c5914714469c4defc2562a907230/src/internal/cpu/cpu_x86.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_wasm.go#L7\n+//\n+// All others are assumed to have 64-byte cache line size.\n+#[cfg_attr(\n+    not(any(\n+        target_arch = \"x86_64\",\n+        target_arch = \"aarch64\",\n+        target_arch = \"powerpc64\",\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+        target_arch = \"s390x\",\n+    )),\n+    repr(align(64))\n+)]\n+pub struct CachePadded<T> {\n+    value: T,\n+}\n+\n+impl<T> CachePadded<T> {\n+    /// Pads and aligns a value to the length of a cache line.\n+    pub fn new(value: T) -> CachePadded<T> {\n+        CachePadded::<T> { value }\n+    }\n+}\n+\n+impl<T> Deref for CachePadded<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut for CachePadded<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}\n+\n+const SPIN_LIMIT: u32 = 6;\n+const YIELD_LIMIT: u32 = 10;\n+\n+/// Performs exponential backoff in spin loops.\n+pub struct Backoff {\n+    step: Cell<u32>,\n+}\n+\n+impl Backoff {\n+    /// Creates a new `Backoff`.\n+    pub fn new() -> Self {\n+        Backoff { step: Cell::new(0) }\n+    }\n+\n+    /// Backs off in a lock-free loop.\n+    ///\n+    /// This method should be used when we need to retry an operation because another thread made\n+    /// progress.\n+    #[inline]\n+    pub fn spin(&self) {\n+        let step = self.step.get().min(SPIN_LIMIT);\n+        for _ in 0..step.pow(2) {\n+            crate::hint::spin_loop();\n+        }\n+\n+        if self.step.get() <= SPIN_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Backs off in a blocking loop.\n+    #[inline]\n+    pub fn snooze(&self) {\n+        if self.step.get() <= SPIN_LIMIT {\n+            for _ in 0..self.step.get().pow(2) {\n+                crate::hint::spin_loop()\n+            }\n+        } else {\n+            crate::thread::yield_now();\n+        }\n+\n+        if self.step.get() <= YIELD_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Returns `true` if exponential backoff has completed and blocking the thread is advised.\n+    #[inline]\n+    pub fn is_completed(&self) -> bool {\n+        self.step.get() > YIELD_LIMIT\n+    }\n+}"}, {"sha": "4912ca4f8150bc8d3c1a56ecf6d07695015b475f", "filename": "library/std/src/sync/mpmc/waker.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,204 @@\n+//! Waking mechanism for threads blocked on channel operations.\n+\n+use super::context::Context;\n+use super::select::{Operation, Selected};\n+\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+\n+/// Represents a thread blocked on a specific channel operation.\n+pub(crate) struct Entry {\n+    /// The operation.\n+    pub(crate) oper: Operation,\n+\n+    /// Optional packet.\n+    pub(crate) packet: *mut (),\n+\n+    /// Context associated with the thread owning this operation.\n+    pub(crate) cx: Context,\n+}\n+\n+/// A queue of threads blocked on channel operations.\n+///\n+/// This data structure is used by threads to register blocking operations and get woken up once\n+/// an operation becomes ready.\n+pub(crate) struct Waker {\n+    /// A list of select operations.\n+    selectors: Vec<Entry>,\n+\n+    /// A list of operations waiting to be ready.\n+    observers: Vec<Entry>,\n+}\n+\n+impl Waker {\n+    /// Creates a new `Waker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        Waker { selectors: Vec::new(), observers: Vec::new() }\n+    }\n+\n+    /// Registers a select operation.\n+    #[inline]\n+    pub(crate) fn register(&mut self, oper: Operation, cx: &Context) {\n+        self.register_with_packet(oper, ptr::null_mut(), cx);\n+    }\n+\n+    /// Registers a select operation and a packet.\n+    #[inline]\n+    pub(crate) fn register_with_packet(&mut self, oper: Operation, packet: *mut (), cx: &Context) {\n+        self.selectors.push(Entry { oper, packet, cx: cx.clone() });\n+    }\n+\n+    /// Unregisters a select operation.\n+    #[inline]\n+    pub(crate) fn unregister(&mut self, oper: Operation) -> Option<Entry> {\n+        if let Some((i, _)) =\n+            self.selectors.iter().enumerate().find(|&(_, entry)| entry.oper == oper)\n+        {\n+            let entry = self.selectors.remove(i);\n+            Some(entry)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Attempts to find another thread's entry, select the operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn try_select(&mut self) -> Option<Entry> {\n+        self.selectors\n+            .iter()\n+            .position(|selector| {\n+                // Does the entry belong to a different thread?\n+                selector.cx.thread_id() != current_thread_id()\n+                    && selector // Try selecting this operation.\n+                        .cx\n+                        .try_select(Selected::Operation(selector.oper))\n+                        .is_ok()\n+                    && {\n+                        // Provide the packet.\n+                        selector.cx.store_packet(selector.packet);\n+                        // Wake the thread up.\n+                        selector.cx.unpark();\n+                        true\n+                    }\n+            })\n+            // Remove the entry from the queue to keep it clean and improve\n+            // performance.\n+            .map(|pos| self.selectors.remove(pos))\n+    }\n+\n+    /// Notifies all operations waiting to be ready.\n+    #[inline]\n+    pub(crate) fn notify(&mut self) {\n+        for entry in self.observers.drain(..) {\n+            if entry.cx.try_select(Selected::Operation(entry.oper)).is_ok() {\n+                entry.cx.unpark();\n+            }\n+        }\n+    }\n+\n+    /// Notifies all registered operations that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&mut self) {\n+        for entry in self.selectors.iter() {\n+            if entry.cx.try_select(Selected::Disconnected).is_ok() {\n+                // Wake the thread up.\n+                //\n+                // Here we don't remove the entry from the queue. Registered threads must\n+                // unregister from the waker by themselves. They might also want to recover the\n+                // packet value and destroy it, if necessary.\n+                entry.cx.unpark();\n+            }\n+        }\n+\n+        self.notify();\n+    }\n+}\n+\n+impl Drop for Waker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.selectors.len(), 0);\n+        debug_assert_eq!(self.observers.len(), 0);\n+    }\n+}\n+\n+/// A waker that can be shared among threads without locking.\n+///\n+/// This is a simple wrapper around `Waker` that internally uses a mutex for synchronization.\n+pub(crate) struct SyncWaker {\n+    /// The inner `Waker`.\n+    inner: Mutex<Waker>,\n+\n+    /// `true` if the waker is empty.\n+    is_empty: AtomicBool,\n+}\n+\n+impl SyncWaker {\n+    /// Creates a new `SyncWaker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        SyncWaker { inner: Mutex::new(Waker::new()), is_empty: AtomicBool::new(true) }\n+    }\n+\n+    /// Registers the current thread with an operation.\n+    #[inline]\n+    pub(crate) fn register(&self, oper: Operation, cx: &Context) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.register(oper, cx);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+\n+    /// Unregisters an operation previously registered by the current thread.\n+    #[inline]\n+    pub(crate) fn unregister(&self, oper: Operation) -> Option<Entry> {\n+        let mut inner = self.inner.lock().unwrap();\n+        let entry = inner.unregister(oper);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+        entry\n+    }\n+\n+    /// Attempts to find one thread (not the current one), select its operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn notify(&self) {\n+        if !self.is_empty.load(Ordering::SeqCst) {\n+            let mut inner = self.inner.lock().unwrap();\n+            if !self.is_empty.load(Ordering::SeqCst) {\n+                inner.try_select();\n+                inner.notify();\n+                self.is_empty.store(\n+                    inner.selectors.is_empty() && inner.observers.is_empty(),\n+                    Ordering::SeqCst,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Notifies all threads that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&self) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.disconnect();\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+}\n+\n+impl Drop for SyncWaker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert!(self.is_empty.load(Ordering::SeqCst));\n+    }\n+}\n+\n+/// Returns a unique id for the current thread.\n+#[inline]\n+pub fn current_thread_id() -> usize {\n+    // `u8` is not drop so this variable will be available during thread destruction,\n+    // whereas `thread::current()` would not be\n+    thread_local! { static DUMMY: u8 = 0 }\n+    DUMMY.with(|x| (x as *const u8).addr())\n+}"}, {"sha": "fccd6c29a7e462f5993bb30c72526d3fe44c0913", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -0,0 +1,318 @@\n+//! Zero-capacity channel.\n+//!\n+//! This kind of channel is also known as *rendezvous* channel.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::Backoff;\n+use super::waker::Waker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+use crate::time::Instant;\n+use crate::{fmt, ptr};\n+\n+/// A pointer to a packet.\n+pub(crate) struct ZeroToken(*mut ());\n+\n+impl Default for ZeroToken {\n+    fn default() -> Self {\n+        Self(ptr::null_mut())\n+    }\n+}\n+\n+impl fmt::Debug for ZeroToken {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&(self.0 as usize), f)\n+    }\n+}\n+\n+/// A slot for passing one message from a sender to a receiver.\n+struct Packet<T> {\n+    /// Equals `true` if the packet is allocated on the stack.\n+    on_stack: bool,\n+\n+    /// Equals `true` once the packet is ready for reading or writing.\n+    ready: AtomicBool,\n+\n+    /// The message.\n+    msg: UnsafeCell<Option<T>>,\n+}\n+\n+impl<T> Packet<T> {\n+    /// Creates an empty packet on the stack.\n+    fn empty_on_stack() -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(None) }\n+    }\n+\n+    /// Creates a packet on the stack, containing a message.\n+    fn message_on_stack(msg: T) -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(Some(msg)) }\n+    }\n+\n+    /// Waits until the packet becomes ready for reading or writing.\n+    fn wait_ready(&self) {\n+        let backoff = Backoff::new();\n+        while !self.ready.load(Ordering::Acquire) {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// Inner representation of a zero-capacity channel.\n+struct Inner {\n+    /// Senders waiting to pair up with a receive operation.\n+    senders: Waker,\n+\n+    /// Receivers waiting to pair up with a send operation.\n+    receivers: Waker,\n+\n+    /// Equals `true` when the channel is disconnected.\n+    is_disconnected: bool,\n+}\n+\n+/// Zero-capacity channel.\n+pub(crate) struct Channel<T> {\n+    /// Inner representation of the channel.\n+    inner: Mutex<Inner>,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop values of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Constructs a new zero-capacity channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            inner: Mutex::new(Inner {\n+                senders: Waker::new(),\n+                receivers: Waker::new(),\n+                is_disconnected: false,\n+            }),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Writes a message into the packet.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+        packet.msg.get().write(Some(msg));\n+        packet.ready.store(true, Ordering::Release);\n+        Ok(())\n+    }\n+\n+    /// Reads a message from the packet.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(());\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+\n+        if packet.on_stack {\n+            // The message has been in the packet from the beginning, so there is no need to wait\n+            // for it. However, after reading the message, we need to set `ready` to `true` in\n+            // order to signal that the packet can be destroyed.\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            packet.ready.store(true, Ordering::Release);\n+            Ok(msg)\n+        } else {\n+            // Wait until the message becomes available, then read it and destroy the\n+            // heap-allocated packet.\n+            packet.wait_ready();\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            drop(Box::from_raw(token.zero.0 as *mut Packet<T>));\n+            Ok(msg)\n+        }\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            Ok(())\n+        } else if inner.is_disconnected {\n+            Err(TrySendError::Disconnected(msg))\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            return Ok(());\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(SendTimeoutError::Disconnected(msg));\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a receiver wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::message_on_stack(msg);\n+            inner.senders.register_with_packet(oper, &mut packet as *mut Packet<T> as *mut (), cx);\n+            inner.receivers.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Timeout(msg))\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Disconnected(msg))\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is read, then drop the packet.\n+                    packet.wait_ready();\n+                    Ok(())\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else if inner.is_disconnected {\n+            Err(TryRecvError::Disconnected)\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+            }\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(RecvTimeoutError::Disconnected);\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a sender wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::empty_on_stack();\n+            inner.receivers.register_with_packet(\n+                oper,\n+                &mut packet as *mut Packet<T> as *mut (),\n+                cx,\n+            );\n+            inner.senders.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Timeout)\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Disconnected)\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is provided, then read it.\n+                    packet.wait_ready();\n+                    unsafe { Ok(packet.msg.get().replace(None).unwrap()) }\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        if !inner.is_disconnected {\n+            inner.is_disconnected = true;\n+            inner.senders.disconnect();\n+            inner.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        0\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        true\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        true\n+    }\n+}"}, {"sha": "021df7b096cbc0670155fa63fcc65d8798544147", "filename": "library/std/src/sync/mpsc/blocking.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,82 +0,0 @@\n-//! Generic support for building blocking abstractions.\n-\n-use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::Arc;\n-use crate::thread::{self, Thread};\n-use crate::time::Instant;\n-\n-struct Inner {\n-    thread: Thread,\n-    woken: AtomicBool,\n-}\n-\n-unsafe impl Send for Inner {}\n-unsafe impl Sync for Inner {}\n-\n-#[derive(Clone)]\n-pub struct SignalToken {\n-    inner: Arc<Inner>,\n-}\n-\n-pub struct WaitToken {\n-    inner: Arc<Inner>,\n-}\n-\n-impl !Send for WaitToken {}\n-\n-impl !Sync for WaitToken {}\n-\n-pub fn tokens() -> (WaitToken, SignalToken) {\n-    let inner = Arc::new(Inner { thread: thread::current(), woken: AtomicBool::new(false) });\n-    let wait_token = WaitToken { inner: inner.clone() };\n-    let signal_token = SignalToken { inner };\n-    (wait_token, signal_token)\n-}\n-\n-impl SignalToken {\n-    pub fn signal(&self) -> bool {\n-        let wake = self\n-            .inner\n-            .woken\n-            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok();\n-        if wake {\n-            self.inner.thread.unpark();\n-        }\n-        wake\n-    }\n-\n-    /// Converts to an unsafe raw pointer. Useful for storing in a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn to_raw(self) -> *mut u8 {\n-        Arc::into_raw(self.inner) as *mut u8\n-    }\n-\n-    /// Converts from an unsafe raw pointer. Useful for retrieving a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn from_raw(signal_ptr: *mut u8) -> SignalToken {\n-        SignalToken { inner: Arc::from_raw(signal_ptr as *mut Inner) }\n-    }\n-}\n-\n-impl WaitToken {\n-    pub fn wait(self) {\n-        while !self.inner.woken.load(Ordering::SeqCst) {\n-            thread::park()\n-        }\n-    }\n-\n-    /// Returns `true` if we wake up normally.\n-    pub fn wait_max_until(self, end: Instant) -> bool {\n-        while !self.inner.woken.load(Ordering::SeqCst) {\n-            let now = Instant::now();\n-            if now >= end {\n-                return false;\n-            }\n-            thread::park_timeout(end - now)\n-        }\n-        true\n-    }\n-}"}, {"sha": "9197f0d6e6c8c3a2f737096cc9f7fff29ef625fb", "filename": "library/std/src/sync/mpsc/cache_aligned.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,25 +0,0 @@\n-use crate::ops::{Deref, DerefMut};\n-\n-#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[cfg_attr(target_arch = \"aarch64\", repr(align(128)))]\n-#[cfg_attr(not(target_arch = \"aarch64\"), repr(align(64)))]\n-pub(super) struct CacheAligned<T>(pub T);\n-\n-impl<T> Deref for CacheAligned<T> {\n-    type Target = T;\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-impl<T> DerefMut for CacheAligned<T> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n-impl<T> CacheAligned<T> {\n-    pub(super) fn new(t: T) -> Self {\n-        CacheAligned(t)\n-    }\n-}"}, {"sha": "27fba761ada108c191ec9cbe9ddcea4c3b33ee95", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 24, "deletions": 434, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -143,175 +143,16 @@ mod tests;\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod sync_tests;\n \n-// A description of how Rust's channel implementation works\n-//\n-// Channels are supposed to be the basic building block for all other\n-// concurrent primitives that are used in Rust. As a result, the channel type\n-// needs to be highly optimized, flexible, and broad enough for use everywhere.\n-//\n-// The choice of implementation of all channels is to be built on lock-free data\n-// structures. The channels themselves are then consequently also lock-free data\n-// structures. As always with lock-free code, this is a very \"here be dragons\"\n-// territory, especially because I'm unaware of any academic papers that have\n-// gone into great length about channels of these flavors.\n-//\n-// ## Flavors of channels\n-//\n-// From the perspective of a consumer of this library, there is only one flavor\n-// of channel. This channel can be used as a stream and cloned to allow multiple\n-// senders. Under the hood, however, there are actually three flavors of\n-// channels in play.\n-//\n-// * Flavor::Oneshots - these channels are highly optimized for the one-send use\n-//                      case. They contain as few atomics as possible and\n-//                      involve one and exactly one allocation.\n-// * Streams - these channels are optimized for the non-shared use case. They\n-//             use a different concurrent queue that is more tailored for this\n-//             use case. The initial allocation of this flavor of channel is not\n-//             optimized.\n-// * Shared - this is the most general form of channel that this module offers,\n-//            a channel with multiple senders. This type is as optimized as it\n-//            can be, but the previous two types mentioned are much faster for\n-//            their use-cases.\n-//\n-// ## Concurrent queues\n-//\n-// The basic idea of Rust's Sender/Receiver types is that send() never blocks,\n-// but recv() obviously blocks. This means that under the hood there must be\n-// some shared and concurrent queue holding all of the actual data.\n-//\n-// With two flavors of channels, two flavors of queues are also used. We have\n-// chosen to use queues from a well-known author that are abbreviated as SPSC\n-// and MPSC (single producer, single consumer and multiple producer, single\n-// consumer). SPSC queues are used for streams while MPSC queues are used for\n-// shared channels.\n-//\n-// ### SPSC optimizations\n-//\n-// The SPSC queue found online is essentially a linked list of nodes where one\n-// half of the nodes are the \"queue of data\" and the other half of nodes are a\n-// cache of unused nodes. The unused nodes are used such that an allocation is\n-// not required on every push() and a free doesn't need to happen on every\n-// pop().\n-//\n-// As found online, however, the cache of nodes is of an infinite size. This\n-// means that if a channel at one point in its life had 50k items in the queue,\n-// then the queue will always have the capacity for 50k items. I believed that\n-// this was an unnecessary limitation of the implementation, so I have altered\n-// the queue to optionally have a bound on the cache size.\n-//\n-// By default, streams will have an unbounded SPSC queue with a small-ish cache\n-// size. The hope is that the cache is still large enough to have very fast\n-// send() operations while not too large such that millions of channels can\n-// coexist at once.\n-//\n-// ### MPSC optimizations\n-//\n-// Right now the MPSC queue has not been optimized. Like the SPSC queue, it uses\n-// a linked list under the hood to earn its unboundedness, but I have not put\n-// forth much effort into having a cache of nodes similar to the SPSC queue.\n-//\n-// For now, I believe that this is \"ok\" because shared channels are not the most\n-// common type, but soon we may wish to revisit this queue choice and determine\n-// another candidate for backend storage of shared channels.\n-//\n-// ## Overview of the Implementation\n-//\n-// Now that there's a little background on the concurrent queues used, it's\n-// worth going into much more detail about the channels themselves. The basic\n-// pseudocode for a send/recv are:\n-//\n-//\n-//      send(t)                             recv()\n-//        queue.push(t)                       return if queue.pop()\n-//        if increment() == -1                deschedule {\n-//          wakeup()                            if decrement() > 0\n-//                                                cancel_deschedule()\n-//                                            }\n-//                                            queue.pop()\n-//\n-// As mentioned before, there are no locks in this implementation, only atomic\n-// instructions are used.\n-//\n-// ### The internal atomic counter\n-//\n-// Every channel has a shared counter with each half to keep track of the size\n-// of the queue. This counter is used to abort descheduling by the receiver and\n-// to know when to wake up on the sending side.\n-//\n-// As seen in the pseudocode, senders will increment this count and receivers\n-// will decrement the count. The theory behind this is that if a sender sees a\n-// -1 count, it will wake up the receiver, and if the receiver sees a 1+ count,\n-// then it doesn't need to block.\n-//\n-// The recv() method has a beginning call to pop(), and if successful, it needs\n-// to decrement the count. It is a crucial implementation detail that this\n-// decrement does *not* happen to the shared counter. If this were the case,\n-// then it would be possible for the counter to be very negative when there were\n-// no receivers waiting, in which case the senders would have to determine when\n-// it was actually appropriate to wake up a receiver.\n-//\n-// Instead, the \"steal count\" is kept track of separately (not atomically\n-// because it's only used by receivers), and then the decrement() call when\n-// descheduling will lump in all of the recent steals into one large decrement.\n-//\n-// The implication of this is that if a sender sees a -1 count, then there's\n-// guaranteed to be a waiter waiting!\n-//\n-// ## Native Implementation\n-//\n-// A major goal of these channels is to work seamlessly on and off the runtime.\n-// All of the previous race conditions have been worded in terms of\n-// scheduler-isms (which is obviously not available without the runtime).\n-//\n-// For now, native usage of channels (off the runtime) will fall back onto\n-// mutexes/cond vars for descheduling/atomic decisions. The no-contention path\n-// is still entirely lock-free, the \"deschedule\" blocks above are surrounded by\n-// a mutex and the \"wakeup\" blocks involve grabbing a mutex and signaling on a\n-// condition variable.\n-//\n-// ## Select\n-//\n-// Being able to support selection over channels has greatly influenced this\n-// design, and not only does selection need to work inside the runtime, but also\n-// outside the runtime.\n-//\n-// The implementation is fairly straightforward. The goal of select() is not to\n-// return some data, but only to return which channel can receive data without\n-// blocking. The implementation is essentially the entire blocking procedure\n-// followed by an increment as soon as its woken up. The cancellation procedure\n-// involves an increment and swapping out of to_wake to acquire ownership of the\n-// thread to unblock.\n-//\n-// Sadly this current implementation requires multiple allocations, so I have\n-// seen the throughput of select() be much worse than it should be. I do not\n-// believe that there is anything fundamental that needs to change about these\n-// channels, however, in order to support a more efficient select().\n-//\n-// FIXME: Select is now removed, so these factors are ready to be cleaned up!\n-//\n-// # Conclusion\n-//\n-// And now that you've seen all the races that I found and attempted to fix,\n-// here's the code for you to find some more!\n-\n-use crate::cell::UnsafeCell;\n+// MPSC channels are built as a wrapper around MPMC channels, which\n+// were ported from the `crossbeam-channel` crate. MPMC channels are\n+// not exposed publicly, but if you are curious about the implementation,\n+// that's where everything is.\n+\n use crate::error;\n use crate::fmt;\n-use crate::mem;\n-use crate::sync::Arc;\n+use crate::sync::mpmc;\n use crate::time::{Duration, Instant};\n \n-mod blocking;\n-mod mpsc_queue;\n-mod oneshot;\n-mod shared;\n-mod spsc_queue;\n-mod stream;\n-mod sync;\n-\n-mod cache_aligned;\n-\n /// The receiving half of Rust's [`channel`] (or [`sync_channel`]) type.\n /// This half can only be owned by one thread.\n ///\n@@ -341,7 +182,7 @@ mod cache_aligned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Receiver\")]\n pub struct Receiver<T> {\n-    inner: UnsafeCell<Flavor<T>>,\n+    inner: mpmc::Receiver<T>,\n }\n \n // The receiver port can be sent from place to place, so long as it\n@@ -498,7 +339,7 @@ pub struct IntoIter<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n-    inner: UnsafeCell<Flavor<T>>,\n+    inner: mpmc::Sender<T>,\n }\n \n // The send port can be sent from place to place, so long as it\n@@ -557,7 +398,7 @@ impl<T> !Sync for Sender<T> {}\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n-    inner: Arc<sync::Packet<T>>,\n+    inner: mpmc::Sender<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -643,34 +484,6 @@ pub enum TrySendError<T> {\n     Disconnected(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n \n-enum Flavor<T> {\n-    Oneshot(Arc<oneshot::Packet<T>>),\n-    Stream(Arc<stream::Packet<T>>),\n-    Shared(Arc<shared::Packet<T>>),\n-    Sync(Arc<sync::Packet<T>>),\n-}\n-\n-#[doc(hidden)]\n-trait UnsafeFlavor<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;\n-    unsafe fn inner_mut(&self) -> &mut Flavor<T> {\n-        &mut *self.inner_unsafe().get()\n-    }\n-    unsafe fn inner(&self) -> &Flavor<T> {\n-        &*self.inner_unsafe().get()\n-    }\n-}\n-impl<T> UnsafeFlavor<T> for Sender<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n-        &self.inner\n-    }\n-}\n-impl<T> UnsafeFlavor<T> for Receiver<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n-        &self.inner\n-    }\n-}\n-\n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n /// All data sent on the [`Sender`] will become available on the [`Receiver`] in\n /// the same order as it was sent, and no [`send`] will block the calling thread\n@@ -711,8 +524,8 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(oneshot::Packet::new());\n-    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n+    let (tx, rx) = mpmc::channel();\n+    (Sender { inner: tx }, Receiver { inner: rx })\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -760,19 +573,15 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(sync::Packet::new(bound));\n-    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n+    let (tx, rx) = mpmc::sync_channel(bound);\n+    (SyncSender { inner: tx }, Receiver { inner: rx })\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Sender\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Sender<T> {\n-    fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender { inner: UnsafeCell::new(inner) }\n-    }\n-\n     /// Attempts to send a value on this channel, returning it back if it could\n     /// not be sent.\n     ///\n@@ -802,40 +611,7 @@ impl<T> Sender<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => {\n-                if !p.sent() {\n-                    return p.send(t).map_err(SendError);\n-                } else {\n-                    let a = Arc::new(stream::Packet::new());\n-                    let rx = Receiver::new(Flavor::Stream(a.clone()));\n-                    match p.upgrade(rx) {\n-                        oneshot::UpSuccess => {\n-                            let ret = a.send(t);\n-                            (a, ret)\n-                        }\n-                        oneshot::UpDisconnected => (a, Err(t)),\n-                        oneshot::UpWoke(token) => {\n-                            // This send cannot panic because the thread is\n-                            // asleep (we're looking at it), so the receiver\n-                            // can't go away.\n-                            a.send(t).ok().unwrap();\n-                            token.signal();\n-                            (a, Ok(()))\n-                        }\n-                    }\n-                }\n-            }\n-            Flavor::Stream(ref p) => return p.send(t).map_err(SendError),\n-            Flavor::Shared(ref p) => return p.send(t).map_err(SendError),\n-            Flavor::Sync(..) => unreachable!(),\n-        };\n-\n-        unsafe {\n-            let tmp = Sender::new(Flavor::Stream(new_inner));\n-            mem::swap(self.inner_mut(), tmp.inner_mut());\n-        }\n-        ret.map_err(SendError)\n+        self.inner.send(t)\n     }\n }\n \n@@ -847,57 +623,14 @@ impl<T> Clone for Sender<T> {\n     /// (including the original) need to be dropped in order for\n     /// [`Receiver::recv`] to stop blocking.\n     fn clone(&self) -> Sender<T> {\n-        let packet = match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => {\n-                let a = Arc::new(shared::Packet::new());\n-                {\n-                    let guard = a.postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    let sleeper = match p.upgrade(rx) {\n-                        oneshot::UpSuccess | oneshot::UpDisconnected => None,\n-                        oneshot::UpWoke(task) => Some(task),\n-                    };\n-                    a.inherit_blocker(sleeper, guard);\n-                }\n-                a\n-            }\n-            Flavor::Stream(ref p) => {\n-                let a = Arc::new(shared::Packet::new());\n-                {\n-                    let guard = a.postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    let sleeper = match p.upgrade(rx) {\n-                        stream::UpSuccess | stream::UpDisconnected => None,\n-                        stream::UpWoke(task) => Some(task),\n-                    };\n-                    a.inherit_blocker(sleeper, guard);\n-                }\n-                a\n-            }\n-            Flavor::Shared(ref p) => {\n-                p.clone_chan();\n-                return Sender::new(Flavor::Shared(p.clone()));\n-            }\n-            Flavor::Sync(..) => unreachable!(),\n-        };\n-\n-        unsafe {\n-            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n-            mem::swap(self.inner_mut(), tmp.inner_mut());\n-        }\n-        Sender::new(Flavor::Shared(packet))\n+        Sender { inner: self.inner.clone() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => p.drop_chan(),\n-            Flavor::Stream(ref p) => p.drop_chan(),\n-            Flavor::Shared(ref p) => p.drop_chan(),\n-            Flavor::Sync(..) => unreachable!(),\n-        }\n+        let _ = self.inner;\n     }\n }\n \n@@ -913,10 +646,6 @@ impl<T> fmt::Debug for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> SyncSender<T> {\n-    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> {\n-        SyncSender { inner }\n-    }\n-\n     /// Sends a value on this synchronous channel.\n     ///\n     /// This function will *block* until space in the internal buffer becomes\n@@ -955,7 +684,7 @@ impl<T> SyncSender<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        self.inner.send(t).map_err(SendError)\n+        self.inner.send(t)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n@@ -1016,15 +745,14 @@ impl<T> SyncSender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n-        self.inner.clone_chan();\n-        SyncSender::new(self.inner.clone())\n+        SyncSender { inner: self.inner.clone() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n-        self.inner.drop_chan();\n+        let _ = self.inner;\n     }\n }\n \n@@ -1040,10 +768,6 @@ impl<T> fmt::Debug for SyncSender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Receiver<T> {\n-    fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner) }\n-    }\n-\n     /// Attempts to return a pending value on this receiver without blocking.\n     ///\n     /// This method will never block the caller in order to wait for data to\n@@ -1069,35 +793,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n-                    Err(oneshot::Disconnected) => return Err(TryRecvError::Disconnected),\n-                    Err(oneshot::Upgraded(rx)) => rx,\n-                },\n-                Flavor::Stream(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Empty) => return Err(TryRecvError::Empty),\n-                    Err(stream::Disconnected) => return Err(TryRecvError::Disconnected),\n-                    Err(stream::Upgraded(rx)) => rx,\n-                },\n-                Flavor::Shared(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Empty) => return Err(TryRecvError::Empty),\n-                    Err(shared::Disconnected) => return Err(TryRecvError::Disconnected),\n-                },\n-                Flavor::Sync(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(sync::Empty) => return Err(TryRecvError::Empty),\n-                    Err(sync::Disconnected) => return Err(TryRecvError::Disconnected),\n-                },\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n+        self.inner.try_recv()\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1156,31 +852,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv(&self) -> Result<T, RecvError> {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Disconnected) => return Err(RecvError),\n-                    Err(oneshot::Upgraded(rx)) => rx,\n-                    Err(oneshot::Empty) => unreachable!(),\n-                },\n-                Flavor::Stream(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Disconnected) => return Err(RecvError),\n-                    Err(stream::Upgraded(rx)) => rx,\n-                    Err(stream::Empty) => unreachable!(),\n-                },\n-                Flavor::Shared(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Disconnected) => return Err(RecvError),\n-                    Err(shared::Empty) => unreachable!(),\n-                },\n-                Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n+        self.inner.recv()\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1198,34 +870,6 @@ impl<T> Receiver<T> {\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// # Known Issues\n-    ///\n-    /// There is currently a known issue (see [`#39364`]) that causes `recv_timeout`\n-    /// to panic unexpectedly with the following example:\n-    ///\n-    /// ```no_run\n-    /// use std::sync::mpsc::channel;\n-    /// use std::thread;\n-    /// use std::time::Duration;\n-    ///\n-    /// let (tx, rx) = channel::<String>();\n-    ///\n-    /// thread::spawn(move || {\n-    ///     let d = Duration::from_millis(10);\n-    ///     loop {\n-    ///         println!(\"recv\");\n-    ///         let _r = rx.recv_timeout(d);\n-    ///     }\n-    /// });\n-    ///\n-    /// thread::sleep(Duration::from_millis(100));\n-    /// let _c1 = tx.clone();\n-    ///\n-    /// thread::sleep(Duration::from_secs(1));\n-    /// ```\n-    ///\n-    /// [`#39364`]: https://github.com/rust-lang/rust/issues/39364\n-    ///\n     /// # Examples\n     ///\n     /// Successfully receiving value before encountering timeout:\n@@ -1268,17 +912,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n     pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n-        // Do an optimistic try_recv to avoid the performance impact of\n-        // Instant::now() in the full-channel case.\n-        match self.try_recv() {\n-            Ok(result) => Ok(result),\n-            Err(TryRecvError::Disconnected) => Err(RecvTimeoutError::Disconnected),\n-            Err(TryRecvError::Empty) => match Instant::now().checked_add(timeout) {\n-                Some(deadline) => self.recv_deadline(deadline),\n-                // So far in the future that it's practically the same as waiting indefinitely.\n-                None => self.recv().map_err(RecvTimeoutError::from),\n-            },\n-        }\n+        self.inner.recv_timeout(timeout)\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1339,46 +973,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[unstable(feature = \"deadline_api\", issue = \"46316\")]\n     pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n-        use self::RecvTimeoutError::*;\n-\n-        loop {\n-            let port_or_empty = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Disconnected) => return Err(Disconnected),\n-                    Err(oneshot::Upgraded(rx)) => Some(rx),\n-                    Err(oneshot::Empty) => None,\n-                },\n-                Flavor::Stream(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Disconnected) => return Err(Disconnected),\n-                    Err(stream::Upgraded(rx)) => Some(rx),\n-                    Err(stream::Empty) => None,\n-                },\n-                Flavor::Shared(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Disconnected) => return Err(Disconnected),\n-                    Err(shared::Empty) => None,\n-                },\n-                Flavor::Sync(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(sync::Disconnected) => return Err(Disconnected),\n-                    Err(sync::Empty) => None,\n-                },\n-            };\n-\n-            if let Some(new_port) = port_or_empty {\n-                unsafe {\n-                    mem::swap(self.inner_mut(), new_port.inner_mut());\n-                }\n-            }\n-\n-            // If we're already passed the deadline, and we're here without\n-            // data, return a timeout, else try again.\n-            if Instant::now() >= deadline {\n-                return Err(Timeout);\n-            }\n-        }\n+        self.inner.recv_deadline(deadline)\n     }\n \n     /// Returns an iterator that will block waiting for messages, but never\n@@ -1500,12 +1095,7 @@ impl<T> IntoIterator for Receiver<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => p.drop_port(),\n-            Flavor::Stream(ref p) => p.drop_port(),\n-            Flavor::Shared(ref p) => p.drop_port(),\n-            Flavor::Sync(ref p) => p.drop_port(),\n-        }\n+        let _ = self.inner;\n     }\n }\n "}, {"sha": "7322512e3b4585346b96d8b31bf29a94f673eb7c", "filename": "library/std/src/sync/mpsc/mpsc_queue.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,124 +0,0 @@\n-//! A mostly lock-free multi-producer, single consumer queue.\n-//!\n-//! This module contains an implementation of a concurrent MPSC queue. This\n-//! queue can be used to share data between threads, and is also used as the\n-//! building block of channels in rust.\n-//!\n-//! Note that the current implementation of this queue has a caveat of the `pop`\n-//! method, and see the method for more information about it. Due to this\n-//! caveat, this queue might not be appropriate for all use-cases.\n-\n-// The original implementation is based off:\n-// https://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue\n-//\n-// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n-// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n-// of today the license of this file is the same as the rest of the codebase:\n-// https://github.com/rust-lang/rust/pull/42149\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-pub use self::PopResult::*;\n-\n-use core::cell::UnsafeCell;\n-use core::ptr;\n-\n-use crate::boxed::Box;\n-use crate::sync::atomic::{AtomicPtr, Ordering};\n-\n-/// A result of the `pop` function.\n-pub enum PopResult<T> {\n-    /// Some data has been popped\n-    Data(T),\n-    /// The queue is empty\n-    Empty,\n-    /// The queue is in an inconsistent state. Popping data should succeed, but\n-    /// some pushers have yet to make enough progress in order allow a pop to\n-    /// succeed. It is recommended that a pop() occur \"in the near future\" in\n-    /// order to see if the sender has made progress or not\n-    Inconsistent,\n-}\n-\n-struct Node<T> {\n-    next: AtomicPtr<Node<T>>,\n-    value: Option<T>,\n-}\n-\n-/// The multi-producer single-consumer structure. This is not cloneable, but it\n-/// may be safely shared so long as it is guaranteed that there is only one\n-/// popper at a time (many pushers are allowed).\n-pub struct Queue<T> {\n-    head: AtomicPtr<Node<T>>,\n-    tail: UnsafeCell<*mut Node<T>>,\n-}\n-\n-unsafe impl<T: Send> Send for Queue<T> {}\n-unsafe impl<T: Send> Sync for Queue<T> {}\n-\n-impl<T> Node<T> {\n-    unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        Box::into_raw(box Node { next: AtomicPtr::new(ptr::null_mut()), value: v })\n-    }\n-}\n-\n-impl<T> Queue<T> {\n-    /// Creates a new queue that is safe to share among multiple producers and\n-    /// one consumer.\n-    pub fn new() -> Queue<T> {\n-        let stub = unsafe { Node::new(None) };\n-        Queue { head: AtomicPtr::new(stub), tail: UnsafeCell::new(stub) }\n-    }\n-\n-    /// Pushes a new value onto this queue.\n-    pub fn push(&self, t: T) {\n-        unsafe {\n-            let n = Node::new(Some(t));\n-            let prev = self.head.swap(n, Ordering::AcqRel);\n-            (*prev).next.store(n, Ordering::Release);\n-        }\n-    }\n-\n-    /// Pops some data from this queue.\n-    ///\n-    /// Note that the current implementation means that this function cannot\n-    /// return `Option<T>`. It is possible for this queue to be in an\n-    /// inconsistent state where many pushes have succeeded and completely\n-    /// finished, but pops cannot return `Some(t)`. This inconsistent state\n-    /// happens when a pusher is pre-empted at an inopportune moment.\n-    ///\n-    /// This inconsistent state means that this queue does indeed have data, but\n-    /// it does not currently have access to it at this time.\n-    pub fn pop(&self) -> PopResult<T> {\n-        unsafe {\n-            let tail = *self.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-\n-            if !next.is_null() {\n-                *self.tail.get() = next;\n-                assert!((*tail).value.is_none());\n-                assert!((*next).value.is_some());\n-                let ret = (*next).value.take().unwrap();\n-                let _: Box<Node<T>> = Box::from_raw(tail);\n-                return Data(ret);\n-            }\n-\n-            if self.head.load(Ordering::Acquire) == tail { Empty } else { Inconsistent }\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Queue<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let mut cur = *self.tail.get();\n-            while !cur.is_null() {\n-                let next = (*cur).next.load(Ordering::Relaxed);\n-                let _: Box<Node<T>> = Box::from_raw(cur);\n-                cur = next;\n-            }\n-        }\n-    }\n-}"}, {"sha": "34b2a9a98ac36fa523fc4435fc12db5a8fe99f23", "filename": "library/std/src/sync/mpsc/mpsc_queue/tests.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,47 +0,0 @@\n-use super::{Data, Empty, Inconsistent, Queue};\n-use crate::sync::mpsc::channel;\n-use crate::sync::Arc;\n-use crate::thread;\n-\n-#[test]\n-fn test_full() {\n-    let q: Queue<Box<_>> = Queue::new();\n-    q.push(Box::new(1));\n-    q.push(Box::new(2));\n-}\n-\n-#[test]\n-fn test() {\n-    let nthreads = 8;\n-    let nmsgs = if cfg!(miri) { 100 } else { 1000 };\n-    let q = Queue::new();\n-    match q.pop() {\n-        Empty => {}\n-        Inconsistent | Data(..) => panic!(),\n-    }\n-    let (tx, rx) = channel();\n-    let q = Arc::new(q);\n-\n-    for _ in 0..nthreads {\n-        let tx = tx.clone();\n-        let q = q.clone();\n-        thread::spawn(move || {\n-            for i in 0..nmsgs {\n-                q.push(i);\n-            }\n-            tx.send(()).unwrap();\n-        });\n-    }\n-\n-    let mut i = 0;\n-    while i < nthreads * nmsgs {\n-        match q.pop() {\n-            Empty | Inconsistent => {}\n-            Data(_) => i += 1,\n-        }\n-    }\n-    drop(tx);\n-    for _ in 0..nthreads {\n-        rx.recv().unwrap();\n-    }\n-}"}, {"sha": "0e259b8aecb9a35744ae9225ab33a41d4c7ac83d", "filename": "library/std/src/sync/mpsc/oneshot.rs", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,315 +0,0 @@\n-/// Oneshot channels/ports\n-///\n-/// This is the initial flavor of channels/ports used for comm module. This is\n-/// an optimization for the one-use case of a channel. The major optimization of\n-/// this type is to have one and exactly one allocation when the chan/port pair\n-/// is created.\n-///\n-/// Another possible optimization would be to not use an Arc box because\n-/// in theory we know when the shared packet can be deallocated (no real need\n-/// for the atomic reference counting), but I was having trouble how to destroy\n-/// the data early in a drop of a Port.\n-///\n-/// # Implementation\n-///\n-/// Oneshots are implemented around one atomic usize variable. This variable\n-/// indicates both the state of the port/chan but also contains any threads\n-/// blocked on the port. All atomic operations happen on this one word.\n-///\n-/// In order to upgrade a oneshot channel, an upgrade is considered a disconnect\n-/// on behalf of the channel side of things (it can be mentally thought of as\n-/// consuming the port). This upgrade is then also stored in the shared packet.\n-/// The one caveat to consider is that when a port sees a disconnected channel\n-/// it must check for data because there is no \"data plus upgrade\" state.\n-pub use self::Failure::*;\n-use self::MyUpgrade::*;\n-pub use self::UpgradeResult::*;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicPtr, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::Receiver;\n-use crate::time::Instant;\n-\n-// Various states you can find a port in.\n-const EMPTY: *mut u8 = ptr::invalid_mut::<u8>(0); // initial state: no data, no blocked receiver\n-const DATA: *mut u8 = ptr::invalid_mut::<u8>(1); // data ready for receiver to take\n-const DISCONNECTED: *mut u8 = ptr::invalid_mut::<u8>(2); // channel is disconnected OR upgraded\n-// Any other value represents a pointer to a SignalToken value. The\n-// protocol ensures that when the state moves *to* a pointer,\n-// ownership of the token is given to the packet, and when the state\n-// moves *from* a pointer, ownership of the token is transferred to\n-// whoever changed the state.\n-\n-pub struct Packet<T> {\n-    // Internal state of the chan/port pair (stores the blocked thread as well)\n-    state: AtomicPtr<u8>,\n-    // One-shot data slot location\n-    data: UnsafeCell<Option<T>>,\n-    // when used for the second time, a oneshot channel must be upgraded, and\n-    // this contains the slot for the upgrade\n-    upgrade: UnsafeCell<MyUpgrade<T>>,\n-}\n-\n-pub enum Failure<T> {\n-    Empty,\n-    Disconnected,\n-    Upgraded(Receiver<T>),\n-}\n-\n-pub enum UpgradeResult {\n-    UpSuccess,\n-    UpDisconnected,\n-    UpWoke(SignalToken),\n-}\n-\n-enum MyUpgrade<T> {\n-    NothingSent,\n-    SendUsed,\n-    GoUp(Receiver<T>),\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            data: UnsafeCell::new(None),\n-            upgrade: UnsafeCell::new(NothingSent),\n-            state: AtomicPtr::new(EMPTY),\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        unsafe {\n-            // Sanity check\n-            match *self.upgrade.get() {\n-                NothingSent => {}\n-                _ => panic!(\"sending on a oneshot that's already sent on \"),\n-            }\n-            assert!((*self.data.get()).is_none());\n-            ptr::write(self.data.get(), Some(t));\n-            ptr::write(self.upgrade.get(), SendUsed);\n-\n-            match self.state.swap(DATA, Ordering::SeqCst) {\n-                // Sent the data, no one was waiting\n-                EMPTY => Ok(()),\n-\n-                // Couldn't send the data, the port hung up first. Return the data\n-                // back up the stack.\n-                DISCONNECTED => {\n-                    self.state.swap(DISCONNECTED, Ordering::SeqCst);\n-                    ptr::write(self.upgrade.get(), NothingSent);\n-                    Err((&mut *self.data.get()).take().unwrap())\n-                }\n-\n-                // Not possible, these are one-use channels\n-                DATA => unreachable!(),\n-\n-                // There is a thread waiting on the other end. We leave the 'DATA'\n-                // state inside so it'll pick it up on the other end.\n-                ptr => {\n-                    SignalToken::from_raw(ptr).signal();\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n-\n-    // Just tests whether this channel has been sent on or not, this is only\n-    // safe to use from the sender.\n-    pub fn sent(&self) -> bool {\n-        unsafe { !matches!(*self.upgrade.get(), NothingSent) }\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n-        // Attempt to not block the thread (it's a little expensive). If it looks\n-        // like we're not empty, then immediately go through to `try_recv`.\n-        if self.state.load(Ordering::SeqCst) == EMPTY {\n-            let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.to_raw() };\n-\n-            // race with senders to enter the blocking state\n-            if self.state.compare_exchange(EMPTY, ptr, Ordering::SeqCst, Ordering::SeqCst).is_ok() {\n-                if let Some(deadline) = deadline {\n-                    let timed_out = !wait_token.wait_max_until(deadline);\n-                    // Try to reset the state\n-                    if timed_out {\n-                        self.abort_selection().map_err(Upgraded)?;\n-                    }\n-                } else {\n-                    wait_token.wait();\n-                    debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n-                }\n-            } else {\n-                // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::from_raw(ptr) });\n-            }\n-        }\n-\n-        self.try_recv()\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n-        unsafe {\n-            match self.state.load(Ordering::SeqCst) {\n-                EMPTY => Err(Empty),\n-\n-                // We saw some data on the channel, but the channel can be used\n-                // again to send us an upgrade. As a result, we need to re-insert\n-                // into the channel that there's no data available (otherwise we'll\n-                // just see DATA next time). This is done as a cmpxchg because if\n-                // the state changes under our feet we'd rather just see that state\n-                // change.\n-                DATA => {\n-                    let _ = self.state.compare_exchange(\n-                        DATA,\n-                        EMPTY,\n-                        Ordering::SeqCst,\n-                        Ordering::SeqCst,\n-                    );\n-                    match (&mut *self.data.get()).take() {\n-                        Some(data) => Ok(data),\n-                        None => unreachable!(),\n-                    }\n-                }\n-\n-                // There's no guarantee that we receive before an upgrade happens,\n-                // and an upgrade flags the channel as disconnected, so when we see\n-                // this we first need to check if there's data available and *then*\n-                // we go through and process the upgrade.\n-                DISCONNECTED => match (&mut *self.data.get()).take() {\n-                    Some(data) => Ok(data),\n-                    None => match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        SendUsed | NothingSent => Err(Disconnected),\n-                        GoUp(upgrade) => Err(Upgraded(upgrade)),\n-                    },\n-                },\n-\n-                // We are the sole receiver; there cannot be a blocking\n-                // receiver already.\n-                _ => unreachable!(),\n-            }\n-        }\n-    }\n-\n-    // Returns whether the upgrade was completed. If the upgrade wasn't\n-    // completed, then the port couldn't get sent to the other half (it will\n-    // never receive it).\n-    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n-        unsafe {\n-            let prev = match *self.upgrade.get() {\n-                NothingSent => NothingSent,\n-                SendUsed => SendUsed,\n-                _ => panic!(\"upgrading again\"),\n-            };\n-            ptr::write(self.upgrade.get(), GoUp(up));\n-\n-            match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-                // If the channel is empty or has data on it, then we're good to go.\n-                // Senders will check the data before the upgrade (in case we\n-                // plastered over the DATA state).\n-                DATA | EMPTY => UpSuccess,\n-\n-                // If the other end is already disconnected, then we failed the\n-                // upgrade. Be sure to trash the port we were given.\n-                DISCONNECTED => {\n-                    ptr::replace(self.upgrade.get(), prev);\n-                    UpDisconnected\n-                }\n-\n-                // If someone's waiting, we gotta wake them up\n-                ptr => UpWoke(SignalToken::from_raw(ptr)),\n-            }\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            DATA | DISCONNECTED | EMPTY => {}\n-\n-            // If someone's waiting, we gotta wake them up\n-            ptr => unsafe {\n-                SignalToken::from_raw(ptr).signal();\n-            },\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            // An empty channel has nothing to do, and a remotely disconnected\n-            // channel also has nothing to do b/c we're about to run the drop\n-            // glue\n-            DISCONNECTED | EMPTY => {}\n-\n-            // There's data on the channel, so make sure we destroy it promptly.\n-            // This is why not using an arc is a little difficult (need the box\n-            // to stay valid while we take the data).\n-            DATA => unsafe {\n-                (&mut *self.data.get()).take().unwrap();\n-            },\n-\n-            // We're the only ones that can block on this port\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // Remove a previous selecting thread from this port. This ensures that the\n-    // blocked thread will no longer be visible to any other threads.\n-    //\n-    // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> {\n-        let state = match self.state.load(Ordering::SeqCst) {\n-            // Each of these states means that no further activity will happen\n-            // with regard to abortion selection\n-            s @ (EMPTY | DATA | DISCONNECTED) => s,\n-\n-            // If we've got a blocked thread, then use an atomic to gain ownership\n-            // of it (may fail)\n-            ptr => self\n-                .state\n-                .compare_exchange(ptr, EMPTY, Ordering::SeqCst, Ordering::SeqCst)\n-                .unwrap_or_else(|x| x),\n-        };\n-\n-        // Now that we've got ownership of our state, figure out what to do\n-        // about it.\n-        match state {\n-            EMPTY => unreachable!(),\n-            // our thread used for select was stolen\n-            DATA => Ok(true),\n-\n-            // If the other end has hung up, then we have complete ownership\n-            // of the port. First, check if there was data waiting for us. This\n-            // is possible if the other end sent something and then hung up.\n-            //\n-            // We then need to check to see if there was an upgrade requested,\n-            // and if so, the upgraded port needs to have its selection aborted.\n-            DISCONNECTED => unsafe {\n-                if (*self.data.get()).is_some() {\n-                    Ok(true)\n-                } else {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        GoUp(port) => Err(port),\n-                        _ => Ok(true),\n-                    }\n-                }\n-            },\n-\n-            // We woke ourselves up from select.\n-            ptr => unsafe {\n-                drop(SignalToken::from_raw(ptr));\n-                Ok(false)\n-            },\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);\n-    }\n-}"}, {"sha": "51917bd96bd60a46bd7f1b96df4a0e0bbc0d9a34", "filename": "library/std/src/sync/mpsc/shared.rs", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,501 +0,0 @@\n-/// Shared channels.\n-///\n-/// This is the flavor of channels which are not necessarily optimized for any\n-/// particular use case, but are the most general in how they are used. Shared\n-/// channels are cloneable allowing for multiple senders.\n-///\n-/// High level implementation details can be found in the comment of the parent\n-/// module. You'll also note that the implementation of the shared and stream\n-/// channels are quite similar, and this is no coincidence!\n-pub use self::Failure::*;\n-use self::StartResult::*;\n-\n-use core::cmp;\n-use core::intrinsics::abort;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::mpsc_queue as mpsc;\n-use crate::sync::{Mutex, MutexGuard};\n-use crate::thread;\n-use crate::time::Instant;\n-\n-const DISCONNECTED: isize = isize::MIN;\n-const FUDGE: isize = 1024;\n-const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n-#[cfg(test)]\n-const MAX_STEALS: isize = 5;\n-#[cfg(not(test))]\n-const MAX_STEALS: isize = 1 << 20;\n-const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n-\n-pub struct Packet<T> {\n-    queue: mpsc::Queue<T>,\n-    cnt: AtomicIsize,          // How many items are on this channel\n-    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-    to_wake: AtomicPtr<u8>,    // SignalToken for wake up\n-\n-    // The number of channels which are currently using this packet.\n-    channels: AtomicUsize,\n-\n-    // See the discussion in Port::drop and the channel send methods for what\n-    // these are used for\n-    port_dropped: AtomicBool,\n-    sender_drain: AtomicIsize,\n-\n-    // this lock protects various portions of this implementation during\n-    // select()\n-    select_lock: Mutex<()>,\n-}\n-\n-pub enum Failure {\n-    Empty,\n-    Disconnected,\n-}\n-\n-#[derive(PartialEq, Eq)]\n-enum StartResult {\n-    Installed,\n-    Abort,\n-}\n-\n-impl<T> Packet<T> {\n-    // Creation of a packet *must* be followed by a call to postinit_lock\n-    // and later by inherit_blocker\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            queue: mpsc::Queue::new(),\n-            cnt: AtomicIsize::new(0),\n-            steals: UnsafeCell::new(0),\n-            to_wake: AtomicPtr::new(EMPTY),\n-            channels: AtomicUsize::new(2),\n-            port_dropped: AtomicBool::new(false),\n-            sender_drain: AtomicIsize::new(0),\n-            select_lock: Mutex::new(()),\n-        }\n-    }\n-\n-    // This function should be used after newly created Packet\n-    // was wrapped with an Arc\n-    // In other case mutex data will be duplicated while cloning\n-    // and that could cause problems on platforms where it is\n-    // represented by opaque data structure\n-    pub fn postinit_lock(&self) -> MutexGuard<'_, ()> {\n-        self.select_lock.lock().unwrap()\n-    }\n-\n-    // This function is used at the creation of a shared packet to inherit a\n-    // previously blocked thread. This is done to prevent spurious wakeups of\n-    // threads in select().\n-    //\n-    // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n-        if let Some(token) = token {\n-            assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-            self.to_wake.store(unsafe { token.to_raw() }, Ordering::SeqCst);\n-            self.cnt.store(-1, Ordering::SeqCst);\n-\n-            // This store is a little sketchy. What's happening here is that\n-            // we're transferring a blocker from a oneshot or stream channel to\n-            // this shared channel. In doing so, we never spuriously wake them\n-            // up and rather only wake them up at the appropriate time. This\n-            // implementation of shared channels assumes that any blocking\n-            // recv() will undo the increment of steals performed in try_recv()\n-            // once the recv is complete.  This thread that we're inheriting,\n-            // however, is not in the middle of recv. Hence, the first time we\n-            // wake them up, they're going to wake up from their old port, move\n-            // on to the upgraded port, and then call the block recv() function.\n-            //\n-            // When calling this function, they'll find there's data immediately\n-            // available, counting it as a steal. This in fact wasn't a steal\n-            // because we appropriately blocked them waiting for data.\n-            //\n-            // To offset this bad increment, we initially set the steal count to\n-            // -1. You'll find some special code in abort_selection() as well to\n-            // ensure that this -1 steal count doesn't escape too far.\n-            unsafe {\n-                *self.steals.get() = -1;\n-            }\n-        }\n-\n-        // When the shared packet is constructed, we grabbed this lock. The\n-        // purpose of this lock is to ensure that abort_selection() doesn't\n-        // interfere with this method. After we unlock this lock, we're\n-        // signifying that we're done modifying self.cnt and self.to_wake and\n-        // the port is ready for the world to continue using it.\n-        drop(guard);\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        // See Port::drop for what's going on\n-        if self.port_dropped.load(Ordering::SeqCst) {\n-            return Err(t);\n-        }\n-\n-        // Note that the multiple sender case is a little trickier\n-        // semantically than the single sender case. The logic for\n-        // incrementing is \"add and if disconnected store disconnected\".\n-        // This could end up leading some senders to believe that there\n-        // wasn't a disconnect if in fact there was a disconnect. This means\n-        // that while one thread is attempting to re-store the disconnected\n-        // states, other threads could walk through merrily incrementing\n-        // this very-negative disconnected count. To prevent senders from\n-        // spuriously attempting to send when the channels is actually\n-        // disconnected, the count has a ranged check here.\n-        //\n-        // This is also done for another reason. Remember that the return\n-        // value of this function is:\n-        //\n-        //  `true` == the data *may* be received, this essentially has no\n-        //            meaning\n-        //  `false` == the data will *never* be received, this has a lot of\n-        //             meaning\n-        //\n-        // In the SPSC case, we have a check of 'queue.is_empty()' to see\n-        // whether the data was actually received, but this same condition\n-        // means nothing in a multi-producer context. As a result, this\n-        // preflight check serves as the definitive \"this will never be\n-        // received\". Once we get beyond this check, we have permanently\n-        // entered the realm of \"this may be received\"\n-        if self.cnt.load(Ordering::SeqCst) < DISCONNECTED + FUDGE {\n-            return Err(t);\n-        }\n-\n-        self.queue.push(t);\n-        match self.cnt.fetch_add(1, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-\n-            // In this case, we have possibly failed to send our data, and\n-            // we need to consider re-popping the data in order to fully\n-            // destroy it. We must arbitrate among the multiple senders,\n-            // however, because the queues that we're using are\n-            // single-consumer queues. In order to do this, all exiting\n-            // pushers will use an atomic count in order to count those\n-            // flowing through. Pushers who see 0 are required to drain as\n-            // much as possible, and then can only exit when they are the\n-            // only pusher (otherwise they must try again).\n-            n if n < DISCONNECTED + FUDGE => {\n-                // see the comment in 'try' for a shared channel for why this\n-                // window of \"not disconnected\" is ok.\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-\n-                if self.sender_drain.fetch_add(1, Ordering::SeqCst) == 0 {\n-                    loop {\n-                        // drain the queue, for info on the thread yield see the\n-                        // discussion in try_recv\n-                        loop {\n-                            match self.queue.pop() {\n-                                mpsc::Data(..) => {}\n-                                mpsc::Empty => break,\n-                                mpsc::Inconsistent => thread::yield_now(),\n-                            }\n-                        }\n-                        // maybe we're done, if we're not the last ones\n-                        // here, then we need to go try again.\n-                        if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {\n-                            break;\n-                        }\n-                    }\n-\n-                    // At this point, there may still be data on the queue,\n-                    // but only if the count hasn't been incremented and\n-                    // some other sender hasn't finished pushing data just\n-                    // yet. That sender in question will drain its own data.\n-                }\n-            }\n-\n-            // Can't make any assumptions about this case like in the SPSC case.\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n-        // This code is essentially the exact same as that found in the stream\n-        // case (see stream.rs)\n-        match self.try_recv() {\n-            Err(Empty) => {}\n-            data => return data,\n-        }\n-\n-        let (wait_token, signal_token) = blocking::tokens();\n-        if self.decrement(signal_token) == Installed {\n-            if let Some(deadline) = deadline {\n-                let timed_out = !wait_token.wait_max_until(deadline);\n-                if timed_out {\n-                    self.abort_selection(false);\n-                }\n-            } else {\n-                wait_token.wait();\n-            }\n-        }\n-\n-        match self.try_recv() {\n-            data @ Ok(..) => unsafe {\n-                *self.steals.get() -= 1;\n-                data\n-            },\n-            data => data,\n-        }\n-    }\n-\n-    // Essentially the exact same thing as the stream decrement function.\n-    // Returns true if blocking should proceed.\n-    fn decrement(&self, token: SignalToken) -> StartResult {\n-        unsafe {\n-            assert_eq!(\n-                self.to_wake.load(Ordering::SeqCst),\n-                EMPTY,\n-                \"This is a known bug in the Rust standard library. See https://github.com/rust-lang/rust/issues/39364\"\n-            );\n-            let ptr = token.to_raw();\n-            self.to_wake.store(ptr, Ordering::SeqCst);\n-\n-            let steals = ptr::replace(self.steals.get(), 0);\n-\n-            match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-                DISCONNECTED => {\n-                    self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                }\n-                // If we factor in our steals and notice that the channel has no\n-                // data, we successfully sleep\n-                n => {\n-                    assert!(n >= 0);\n-                    if n - steals <= 0 {\n-                        return Installed;\n-                    }\n-                }\n-            }\n-\n-            self.to_wake.store(EMPTY, Ordering::SeqCst);\n-            drop(SignalToken::from_raw(ptr));\n-            Abort\n-        }\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure> {\n-        let ret = match self.queue.pop() {\n-            mpsc::Data(t) => Some(t),\n-            mpsc::Empty => None,\n-\n-            // This is a bit of an interesting case. The channel is reported as\n-            // having data available, but our pop() has failed due to the queue\n-            // being in an inconsistent state.  This means that there is some\n-            // pusher somewhere which has yet to complete, but we are guaranteed\n-            // that a pop will eventually succeed. In this case, we spin in a\n-            // yield loop because the remote sender should finish their enqueue\n-            // operation \"very quickly\".\n-            //\n-            // Avoiding this yield loop would require a different queue\n-            // abstraction which provides the guarantee that after M pushes have\n-            // succeeded, at least M pops will succeed. The current queues\n-            // guarantee that if there are N active pushes, you can pop N times\n-            // once all N have finished.\n-            mpsc::Inconsistent => {\n-                let data;\n-                loop {\n-                    thread::yield_now();\n-                    match self.queue.pop() {\n-                        mpsc::Data(t) => {\n-                            data = t;\n-                            break;\n-                        }\n-                        mpsc::Empty => panic!(\"inconsistent => empty\"),\n-                        mpsc::Inconsistent => {}\n-                    }\n-                }\n-                Some(data)\n-            }\n-        };\n-        match ret {\n-            // See the discussion in the stream implementation for why we\n-            // might decrement steals.\n-            Some(data) => unsafe {\n-                if *self.steals.get() > MAX_STEALS {\n-                    match self.cnt.swap(0, Ordering::SeqCst) {\n-                        DISCONNECTED => {\n-                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                        }\n-                        n => {\n-                            let m = cmp::min(n, *self.steals.get());\n-                            *self.steals.get() -= m;\n-                            self.bump(n - m);\n-                        }\n-                    }\n-                    assert!(*self.steals.get() >= 0);\n-                }\n-                *self.steals.get() += 1;\n-                Ok(data)\n-            },\n-\n-            // See the discussion in the stream implementation for why we try\n-            // again.\n-            None => {\n-                match self.cnt.load(Ordering::SeqCst) {\n-                    n if n != DISCONNECTED => Err(Empty),\n-                    _ => {\n-                        match self.queue.pop() {\n-                            mpsc::Data(t) => Ok(t),\n-                            mpsc::Empty => Err(Disconnected),\n-                            // with no senders, an inconsistency is impossible.\n-                            mpsc::Inconsistent => unreachable!(),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Prepares this shared packet for a channel clone, essentially just bumping\n-    // a refcount.\n-    pub fn clone_chan(&self) {\n-        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n-\n-        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n-        if old_count > MAX_REFCOUNT {\n-            abort();\n-        }\n-    }\n-\n-    // Decrement the reference count on a channel. This is called whenever a\n-    // Chan is dropped and may end up waking up a receiver. It's the receiver's\n-    // responsibility on the other end to figure out that we've disconnected.\n-    pub fn drop_chan(&self) {\n-        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n-            1 => {}\n-            n if n > 1 => return,\n-            n => panic!(\"bad number of channels left {n}\"),\n-        }\n-\n-        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-            DISCONNECTED => {}\n-            n => {\n-                assert!(n >= 0);\n-            }\n-        }\n-    }\n-\n-    // See the long discussion inside of stream.rs for why the queue is drained,\n-    // and why it is done in this fashion.\n-    pub fn drop_port(&self) {\n-        self.port_dropped.store(true, Ordering::SeqCst);\n-        let mut steals = unsafe { *self.steals.get() };\n-        while {\n-            match self.cnt.compare_exchange(\n-                steals,\n-                DISCONNECTED,\n-                Ordering::SeqCst,\n-                Ordering::SeqCst,\n-            ) {\n-                Ok(_) => false,\n-                Err(old) => old != DISCONNECTED,\n-            }\n-        } {\n-            // See the discussion in 'try_recv' for why we yield\n-            // control of this thread.\n-            loop {\n-                match self.queue.pop() {\n-                    mpsc::Data(..) => {\n-                        steals += 1;\n-                    }\n-                    mpsc::Empty | mpsc::Inconsistent => break,\n-                }\n-            }\n-        }\n-    }\n-\n-    // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&self) -> SignalToken {\n-        let ptr = self.to_wake.load(Ordering::SeqCst);\n-        self.to_wake.store(EMPTY, Ordering::SeqCst);\n-        assert!(ptr != EMPTY);\n-        unsafe { SignalToken::from_raw(ptr) }\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // increment the count on the channel (used for selection)\n-    fn bump(&self, amt: isize) -> isize {\n-        match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                DISCONNECTED\n-            }\n-            n => n,\n-        }\n-    }\n-\n-    // Cancels a previous thread waiting on this port, returning whether there's\n-    // data on the port.\n-    //\n-    // This is similar to the stream implementation (hence fewer comments), but\n-    // uses a different value for the \"steals\" variable.\n-    pub fn abort_selection(&self, _was_upgrade: bool) -> bool {\n-        // Before we do anything else, we bounce on this lock. The reason for\n-        // doing this is to ensure that any upgrade-in-progress is gone and\n-        // done with. Without this bounce, we can race with inherit_blocker\n-        // about looking at and dealing with to_wake. Once we have acquired the\n-        // lock, we are guaranteed that inherit_blocker is done.\n-        {\n-            let _guard = self.select_lock.lock().unwrap();\n-        }\n-\n-        // Like the stream implementation, we want to make sure that the count\n-        // on the channel goes non-negative. We don't know how negative the\n-        // stream currently is, so instead of using a steal value of 1, we load\n-        // the channel count and figure out what we should do to make it\n-        // positive.\n-        let steals = {\n-            let cnt = self.cnt.load(Ordering::SeqCst);\n-            if cnt < 0 && cnt != DISCONNECTED { -cnt } else { 0 }\n-        };\n-        let prev = self.bump(steals + 1);\n-\n-        if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-            true\n-        } else {\n-            let cur = prev + steals + 1;\n-            assert!(cur >= 0);\n-            if prev < 0 {\n-                drop(self.take_to_wake());\n-            } else {\n-                while self.to_wake.load(Ordering::SeqCst) != EMPTY {\n-                    thread::yield_now();\n-                }\n-            }\n-            unsafe {\n-                // if the number of steals is -1, it was the pre-emptive -1 steal\n-                // count from when we inherited a blocker. This is fine because\n-                // we're just going to overwrite it with a real value.\n-                let old = self.steals.get();\n-                assert!(*old == 0 || *old == -1);\n-                *old = steals;\n-                prev >= 0\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        // Note that this load is not only an assert for correctness about\n-        // disconnection, but also a proper fence before the read of\n-        // `to_wake`, so this assert cannot be removed with also removing\n-        // the `to_wake` assert.\n-        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n-    }\n-}"}, {"sha": "61f91313ea96d79f645c4cfee272826ee5947de3", "filename": "library/std/src/sync/mpsc/spsc_queue.rs", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,244 +0,0 @@\n-//! A single-producer single-consumer concurrent queue\n-//!\n-//! This module contains the implementation of an SPSC queue which can be used\n-//! concurrently between two threads. This data structure is safe to use and\n-//! enforces the semantics that there is one pusher and one popper.\n-\n-// The original implementation is based off:\n-// https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n-// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n-// of today the license of this file is the same as the rest of the codebase:\n-// https://github.com/rust-lang/rust/pull/42149\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-use core::cell::UnsafeCell;\n-use core::ptr;\n-\n-use crate::boxed::Box;\n-use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n-\n-use super::cache_aligned::CacheAligned;\n-\n-// Node within the linked list queue of messages to send\n-struct Node<T> {\n-    // FIXME: this could be an uninitialized T if we're careful enough, and\n-    //      that would reduce memory usage (and be a bit faster).\n-    //      is it worth it?\n-    value: Option<T>,         // nullable for re-use of nodes\n-    cached: bool,             // This node goes into the node cache\n-    next: AtomicPtr<Node<T>>, // next node in the queue\n-}\n-\n-/// The single-producer single-consumer queue. This structure is not cloneable,\n-/// but it can be safely shared in an Arc if it is guaranteed that there\n-/// is only one popper and one pusher touching the queue at any one point in\n-/// time.\n-pub struct Queue<T, ProducerAddition = (), ConsumerAddition = ()> {\n-    // consumer fields\n-    consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n-\n-    // producer fields\n-    producer: CacheAligned<Producer<T, ProducerAddition>>,\n-}\n-\n-struct Consumer<T, Addition> {\n-    tail: UnsafeCell<*mut Node<T>>, // where to pop from\n-    tail_prev: AtomicPtr<Node<T>>,  // where to pop from\n-    cache_bound: usize,             // maximum cache size\n-    cached_nodes: AtomicUsize,      // number of nodes marked as cacheable\n-    addition: Addition,\n-}\n-\n-struct Producer<T, Addition> {\n-    head: UnsafeCell<*mut Node<T>>,      // where to push to\n-    first: UnsafeCell<*mut Node<T>>,     // where to get new nodes from\n-    tail_copy: UnsafeCell<*mut Node<T>>, // between first/tail\n-    addition: Addition,\n-}\n-\n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> {}\n-\n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> {}\n-\n-impl<T> Node<T> {\n-    fn new() -> *mut Node<T> {\n-        Box::into_raw(box Node {\n-            value: None,\n-            cached: false,\n-            next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n-        })\n-    }\n-}\n-\n-impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n-    /// Creates a new queue. With given additional elements in the producer and\n-    /// consumer portions of the queue.\n-    ///\n-    /// Due to the performance implications of cache-contention,\n-    /// we wish to keep fields used mainly by the producer on a separate cache\n-    /// line than those used by the consumer.\n-    /// Since cache lines are usually 64 bytes, it is unreasonably expensive to\n-    /// allocate one for small fields, so we allow users to insert additional\n-    /// fields into the cache lines already allocated by this for the producer\n-    /// and consumer.\n-    ///\n-    /// This is unsafe as the type system doesn't enforce a single\n-    /// consumer-producer relationship. It also allows the consumer to `pop`\n-    /// items while there is a `peek` active due to all methods having a\n-    /// non-mutable receiver.\n-    ///\n-    /// # Arguments\n-    ///\n-    ///   * `bound` - This queue implementation is implemented with a linked\n-    ///               list, and this means that a push is always a malloc. In\n-    ///               order to amortize this cost, an internal cache of nodes is\n-    ///               maintained to prevent a malloc from always being\n-    ///               necessary. This bound is the limit on the size of the\n-    ///               cache (if desired). If the value is 0, then the cache has\n-    ///               no bound. Otherwise, the cache will never grow larger than\n-    ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn with_additions(\n-        bound: usize,\n-        producer_addition: ProducerAddition,\n-        consumer_addition: ConsumerAddition,\n-    ) -> Self {\n-        let n1 = Node::new();\n-        let n2 = Node::new();\n-        (*n1).next.store(n2, Ordering::Relaxed);\n-        Queue {\n-            consumer: CacheAligned::new(Consumer {\n-                tail: UnsafeCell::new(n2),\n-                tail_prev: AtomicPtr::new(n1),\n-                cache_bound: bound,\n-                cached_nodes: AtomicUsize::new(0),\n-                addition: consumer_addition,\n-            }),\n-            producer: CacheAligned::new(Producer {\n-                head: UnsafeCell::new(n2),\n-                first: UnsafeCell::new(n1),\n-                tail_copy: UnsafeCell::new(n1),\n-                addition: producer_addition,\n-            }),\n-        }\n-    }\n-\n-    /// Pushes a new value onto this queue. Note that to use this function\n-    /// safely, it must be externally guaranteed that there is only one pusher.\n-    pub fn push(&self, t: T) {\n-        unsafe {\n-            // Acquire a node (which either uses a cached one or allocates a new\n-            // one), and then append this to the 'head' node.\n-            let n = self.alloc();\n-            assert!((*n).value.is_none());\n-            (*n).value = Some(t);\n-            (*n).next.store(ptr::null_mut(), Ordering::Relaxed);\n-            (**self.producer.head.get()).next.store(n, Ordering::Release);\n-            *(&self.producer.head).get() = n;\n-        }\n-    }\n-\n-    unsafe fn alloc(&self) -> *mut Node<T> {\n-        // First try to see if we can consume the 'first' node for our uses.\n-        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n-            let ret = *self.producer.first.get();\n-            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n-            return ret;\n-        }\n-        // If the above fails, then update our copy of the tail and try\n-        // again.\n-        *self.producer.0.tail_copy.get() = self.consumer.tail_prev.load(Ordering::Acquire);\n-        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n-            let ret = *self.producer.first.get();\n-            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n-            return ret;\n-        }\n-        // If all of that fails, then we have to allocate a new node\n-        // (there's nothing in the node cache).\n-        Node::new()\n-    }\n-\n-    /// Attempts to pop a value from this queue. Remember that to use this type\n-    /// safely you must ensure that there is only one popper at a time.\n-    pub fn pop(&self) -> Option<T> {\n-        unsafe {\n-            // The `tail` node is not actually a used node, but rather a\n-            // sentinel from where we should start popping from. Hence, look at\n-            // tail's next field and see if we can use it. If we do a pop, then\n-            // the current tail node is a candidate for going into the cache.\n-            let tail = *self.consumer.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() {\n-                return None;\n-            }\n-            assert!((*next).value.is_some());\n-            let ret = (*next).value.take();\n-\n-            *self.consumer.0.tail.get() = next;\n-            if self.consumer.cache_bound == 0 {\n-                self.consumer.tail_prev.store(tail, Ordering::Release);\n-            } else {\n-                let cached_nodes = self.consumer.cached_nodes.load(Ordering::Relaxed);\n-                if cached_nodes < self.consumer.cache_bound && !(*tail).cached {\n-                    self.consumer.cached_nodes.store(cached_nodes, Ordering::Relaxed);\n-                    (*tail).cached = true;\n-                }\n-\n-                if (*tail).cached {\n-                    self.consumer.tail_prev.store(tail, Ordering::Release);\n-                } else {\n-                    (*self.consumer.tail_prev.load(Ordering::Relaxed))\n-                        .next\n-                        .store(next, Ordering::Relaxed);\n-                    // We have successfully erased all references to 'tail', so\n-                    // now we can safely drop it.\n-                    let _: Box<Node<T>> = Box::from_raw(tail);\n-                }\n-            }\n-            ret\n-        }\n-    }\n-\n-    /// Attempts to peek at the head of the queue, returning `None` if the queue\n-    /// has no data currently\n-    ///\n-    /// # Warning\n-    /// The reference returned is invalid if it is not used before the consumer\n-    /// pops the value off the queue. If the producer then pushes another value\n-    /// onto the queue, it will overwrite the value pointed to by the reference.\n-    pub fn peek(&self) -> Option<&mut T> {\n-        // This is essentially the same as above with all the popping bits\n-        // stripped out.\n-        unsafe {\n-            let tail = *self.consumer.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() { None } else { (*next).value.as_mut() }\n-        }\n-    }\n-\n-    pub fn producer_addition(&self) -> &ProducerAddition {\n-        &self.producer.addition\n-    }\n-\n-    pub fn consumer_addition(&self) -> &ConsumerAddition {\n-        &self.consumer.addition\n-    }\n-}\n-\n-impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition, ConsumerAddition> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let mut cur = *self.producer.first.get();\n-            while !cur.is_null() {\n-                let next = (*cur).next.load(Ordering::Relaxed);\n-                let _n: Box<Node<T>> = Box::from_raw(cur);\n-                cur = next;\n-            }\n-        }\n-    }\n-}"}, {"sha": "eb6d5c2cf66d8fc71a850d05646c1706916dfbbc", "filename": "library/std/src/sync/mpsc/spsc_queue/tests.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,102 +0,0 @@\n-use super::Queue;\n-use crate::sync::mpsc::channel;\n-use crate::sync::Arc;\n-use crate::thread;\n-\n-#[test]\n-fn smoke() {\n-    unsafe {\n-        let queue = Queue::with_additions(0, (), ());\n-        queue.push(1);\n-        queue.push(2);\n-        assert_eq!(queue.pop(), Some(1));\n-        assert_eq!(queue.pop(), Some(2));\n-        assert_eq!(queue.pop(), None);\n-        queue.push(3);\n-        queue.push(4);\n-        assert_eq!(queue.pop(), Some(3));\n-        assert_eq!(queue.pop(), Some(4));\n-        assert_eq!(queue.pop(), None);\n-    }\n-}\n-\n-#[test]\n-fn peek() {\n-    unsafe {\n-        let queue = Queue::with_additions(0, (), ());\n-        queue.push(vec![1]);\n-\n-        // Ensure the borrowchecker works\n-        match queue.peek() {\n-            Some(vec) => {\n-                assert_eq!(&*vec, &[1]);\n-            }\n-            None => unreachable!(),\n-        }\n-\n-        match queue.pop() {\n-            Some(vec) => {\n-                assert_eq!(&*vec, &[1]);\n-            }\n-            None => unreachable!(),\n-        }\n-    }\n-}\n-\n-#[test]\n-fn drop_full() {\n-    unsafe {\n-        let q: Queue<Box<_>> = Queue::with_additions(0, (), ());\n-        q.push(Box::new(1));\n-        q.push(Box::new(2));\n-    }\n-}\n-\n-#[test]\n-fn smoke_bound() {\n-    unsafe {\n-        let q = Queue::with_additions(0, (), ());\n-        q.push(1);\n-        q.push(2);\n-        assert_eq!(q.pop(), Some(1));\n-        assert_eq!(q.pop(), Some(2));\n-        assert_eq!(q.pop(), None);\n-        q.push(3);\n-        q.push(4);\n-        assert_eq!(q.pop(), Some(3));\n-        assert_eq!(q.pop(), Some(4));\n-        assert_eq!(q.pop(), None);\n-    }\n-}\n-\n-#[test]\n-fn stress() {\n-    unsafe {\n-        stress_bound(0);\n-        stress_bound(1);\n-    }\n-\n-    unsafe fn stress_bound(bound: usize) {\n-        let count = if cfg!(miri) { 1000 } else { 100000 };\n-        let q = Arc::new(Queue::with_additions(bound, (), ()));\n-\n-        let (tx, rx) = channel();\n-        let q2 = q.clone();\n-        let _t = thread::spawn(move || {\n-            for _ in 0..count {\n-                loop {\n-                    match q2.pop() {\n-                        Some(1) => break,\n-                        Some(_) => panic!(),\n-                        None => {}\n-                    }\n-                }\n-            }\n-            tx.send(()).unwrap();\n-        });\n-        for _ in 0..count {\n-            q.push(1);\n-        }\n-        rx.recv().unwrap();\n-    }\n-}"}, {"sha": "4592e9141600e600d876a07aabe2cb6d10e70114", "filename": "library/std/src/sync/mpsc/stream.rs", "status": "removed", "additions": 0, "deletions": 457, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,457 +0,0 @@\n-/// Stream channels\n-///\n-/// This is the flavor of channels which are optimized for one sender and one\n-/// receiver. The sender will be upgraded to a shared channel if the channel is\n-/// cloned.\n-///\n-/// High level implementation details can be found in the comment of the parent\n-/// module.\n-pub use self::Failure::*;\n-use self::Message::*;\n-pub use self::UpgradeResult::*;\n-\n-use core::cmp;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::thread;\n-use crate::time::Instant;\n-\n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::spsc_queue as spsc;\n-use crate::sync::mpsc::Receiver;\n-\n-const DISCONNECTED: isize = isize::MIN;\n-#[cfg(test)]\n-const MAX_STEALS: isize = 5;\n-#[cfg(not(test))]\n-const MAX_STEALS: isize = 1 << 20;\n-const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n-\n-pub struct Packet<T> {\n-    // internal queue for all messages\n-    queue: spsc::Queue<Message<T>, ProducerAddition, ConsumerAddition>,\n-}\n-\n-struct ProducerAddition {\n-    cnt: AtomicIsize,       // How many items are on this channel\n-    to_wake: AtomicPtr<u8>, // SignalToken for the blocked thread to wake up\n-\n-    port_dropped: AtomicBool, // flag if the channel has been destroyed.\n-}\n-\n-struct ConsumerAddition {\n-    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-}\n-\n-pub enum Failure<T> {\n-    Empty,\n-    Disconnected,\n-    Upgraded(Receiver<T>),\n-}\n-\n-pub enum UpgradeResult {\n-    UpSuccess,\n-    UpDisconnected,\n-    UpWoke(SignalToken),\n-}\n-\n-// Any message could contain an \"upgrade request\" to a new shared port, so the\n-// internal queue it's a queue of T, but rather Message<T>\n-enum Message<T> {\n-    Data(T),\n-    GoUp(Receiver<T>),\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            queue: unsafe {\n-                spsc::Queue::with_additions(\n-                    128,\n-                    ProducerAddition {\n-                        cnt: AtomicIsize::new(0),\n-                        to_wake: AtomicPtr::new(EMPTY),\n-\n-                        port_dropped: AtomicBool::new(false),\n-                    },\n-                    ConsumerAddition { steals: UnsafeCell::new(0) },\n-                )\n-            },\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        // If the other port has deterministically gone away, then definitely\n-        // must return the data back up the stack. Otherwise, the data is\n-        // considered as being sent.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return Err(t);\n-        }\n-\n-        match self.do_send(Data(t)) {\n-            UpSuccess | UpDisconnected => {}\n-            UpWoke(token) => {\n-                token.signal();\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n-        // If the port has gone away, then there's no need to proceed any\n-        // further.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return UpDisconnected;\n-        }\n-\n-        self.do_send(GoUp(up))\n-    }\n-\n-    fn do_send(&self, t: Message<T>) -> UpgradeResult {\n-        self.queue.push(t);\n-        match self.queue.producer_addition().cnt.fetch_add(1, Ordering::SeqCst) {\n-            // As described in the mod's doc comment, -1 == wakeup\n-            -1 => UpWoke(self.take_to_wake()),\n-            // As described before, SPSC queues must be >= -2\n-            -2 => UpSuccess,\n-\n-            // Be sure to preserve the disconnected state, and the return value\n-            // in this case is going to be whether our data was received or not.\n-            // This manifests itself on whether we have an empty queue or not.\n-            //\n-            // Primarily, are required to drain the queue here because the port\n-            // will never remove this data. We can only have at most one item to\n-            // drain (the port drains the rest).\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                let first = self.queue.pop();\n-                let second = self.queue.pop();\n-                assert!(second.is_none());\n-\n-                match first {\n-                    Some(..) => UpSuccess,  // we failed to send the data\n-                    None => UpDisconnected, // we successfully sent data\n-                }\n-            }\n-\n-            // Otherwise we just sent some data on a non-waiting queue, so just\n-            // make sure the world is sane and carry on!\n-            n => {\n-                assert!(n >= 0);\n-                UpSuccess\n-            }\n-        }\n-    }\n-\n-    // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&self) -> SignalToken {\n-        let ptr = self.queue.producer_addition().to_wake.load(Ordering::SeqCst);\n-        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n-        assert!(ptr != EMPTY);\n-        unsafe { SignalToken::from_raw(ptr) }\n-    }\n-\n-    // Decrements the count on the channel for a sleeper, returning the sleeper\n-    // back if it shouldn't sleep. Note that this is the location where we take\n-    // steals into account.\n-    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-        let ptr = unsafe { token.to_raw() };\n-        self.queue.producer_addition().to_wake.store(ptr, Ordering::SeqCst);\n-\n-        let steals = unsafe { ptr::replace(self.queue.consumer_addition().steals.get(), 0) };\n-\n-        match self.queue.producer_addition().cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-            }\n-            // If we factor in our steals and notice that the channel has no\n-            // data, we successfully sleep\n-            n => {\n-                assert!(n >= 0);\n-                if n - steals <= 0 {\n-                    return Ok(());\n-                }\n-            }\n-        }\n-\n-        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::from_raw(ptr) })\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n-        // Optimistic preflight check (scheduling is expensive).\n-        match self.try_recv() {\n-            Err(Empty) => {}\n-            data => return data,\n-        }\n-\n-        // Welp, our channel has no data. Deschedule the current thread and\n-        // initiate the blocking protocol.\n-        let (wait_token, signal_token) = blocking::tokens();\n-        if self.decrement(signal_token).is_ok() {\n-            if let Some(deadline) = deadline {\n-                let timed_out = !wait_token.wait_max_until(deadline);\n-                if timed_out {\n-                    self.abort_selection(/* was_upgrade = */ false).map_err(Upgraded)?;\n-                }\n-            } else {\n-                wait_token.wait();\n-            }\n-        }\n-\n-        match self.try_recv() {\n-            // Messages which actually popped from the queue shouldn't count as\n-            // a steal, so offset the decrement here (we already have our\n-            // \"steal\" factored into the channel count above).\n-            data @ (Ok(..) | Err(Upgraded(..))) => unsafe {\n-                *self.queue.consumer_addition().steals.get() -= 1;\n-                data\n-            },\n-\n-            data => data,\n-        }\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n-        match self.queue.pop() {\n-            // If we stole some data, record to that effect (this will be\n-            // factored into cnt later on).\n-            //\n-            // Note that we don't allow steals to grow without bound in order to\n-            // prevent eventual overflow of either steals or cnt as an overflow\n-            // would have catastrophic results. Sometimes, steals > cnt, but\n-            // other times cnt > steals, so we don't know the relation between\n-            // steals and cnt. This code path is executed only rarely, so we do\n-            // a pretty slow operation, of swapping 0 into cnt, taking steals\n-            // down as much as possible (without going negative), and then\n-            // adding back in whatever we couldn't factor into steals.\n-            Some(data) => unsafe {\n-                if *self.queue.consumer_addition().steals.get() > MAX_STEALS {\n-                    match self.queue.producer_addition().cnt.swap(0, Ordering::SeqCst) {\n-                        DISCONNECTED => {\n-                            self.queue\n-                                .producer_addition()\n-                                .cnt\n-                                .store(DISCONNECTED, Ordering::SeqCst);\n-                        }\n-                        n => {\n-                            let m = cmp::min(n, *self.queue.consumer_addition().steals.get());\n-                            *self.queue.consumer_addition().steals.get() -= m;\n-                            self.bump(n - m);\n-                        }\n-                    }\n-                    assert!(*self.queue.consumer_addition().steals.get() >= 0);\n-                }\n-                *self.queue.consumer_addition().steals.get() += 1;\n-                match data {\n-                    Data(t) => Ok(t),\n-                    GoUp(up) => Err(Upgraded(up)),\n-                }\n-            },\n-\n-            None => {\n-                match self.queue.producer_addition().cnt.load(Ordering::SeqCst) {\n-                    n if n != DISCONNECTED => Err(Empty),\n-\n-                    // This is a little bit of a tricky case. We failed to pop\n-                    // data above, and then we have viewed that the channel is\n-                    // disconnected. In this window more data could have been\n-                    // sent on the channel. It doesn't really make sense to\n-                    // return that the channel is disconnected when there's\n-                    // actually data on it, so be extra sure there's no data by\n-                    // popping one more time.\n-                    //\n-                    // We can ignore steals because the other end is\n-                    // disconnected and we'll never need to really factor in our\n-                    // steals again.\n-                    _ => match self.queue.pop() {\n-                        Some(Data(t)) => Ok(t),\n-                        Some(GoUp(up)) => Err(Upgraded(up)),\n-                        None => Err(Disconnected),\n-                    },\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        // Dropping a channel is pretty simple, we just flag it as disconnected\n-        // and then wakeup a blocker if there is one.\n-        match self.queue.producer_addition().cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-            DISCONNECTED => {}\n-            n => {\n-                assert!(n >= 0);\n-            }\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        // Dropping a port seems like a fairly trivial thing. In theory all we\n-        // need to do is flag that we're disconnected and then everything else\n-        // can take over (we don't have anyone to wake up).\n-        //\n-        // The catch for Ports is that we want to drop the entire contents of\n-        // the queue. There are multiple reasons for having this property, the\n-        // largest of which is that if another chan is waiting in this channel\n-        // (but not received yet), then waiting on that port will cause a\n-        // deadlock.\n-        //\n-        // So if we accept that we must now destroy the entire contents of the\n-        // queue, this code may make a bit more sense. The tricky part is that\n-        // we can't let any in-flight sends go un-dropped, we have to make sure\n-        // *everything* is dropped and nothing new will come onto the channel.\n-\n-        // The first thing we do is set a flag saying that we're done for. All\n-        // sends are gated on this flag, so we're immediately guaranteed that\n-        // there are a bounded number of active sends that we'll have to deal\n-        // with.\n-        self.queue.producer_addition().port_dropped.store(true, Ordering::SeqCst);\n-\n-        // Now that we're guaranteed to deal with a bounded number of senders,\n-        // we need to drain the queue. This draining process happens atomically\n-        // with respect to the \"count\" of the channel. If the count is nonzero\n-        // (with steals taken into account), then there must be data on the\n-        // channel. In this case we drain everything and then try again. We will\n-        // continue to fail while active senders send data while we're dropping\n-        // data, but eventually we're guaranteed to break out of this loop\n-        // (because there is a bounded number of senders).\n-        let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n-        while {\n-            match self.queue.producer_addition().cnt.compare_exchange(\n-                steals,\n-                DISCONNECTED,\n-                Ordering::SeqCst,\n-                Ordering::SeqCst,\n-            ) {\n-                Ok(_) => false,\n-                Err(old) => old != DISCONNECTED,\n-            }\n-        } {\n-            while self.queue.pop().is_some() {\n-                steals += 1;\n-            }\n-        }\n-\n-        // At this point in time, we have gated all future senders from sending,\n-        // and we have flagged the channel as being disconnected. The senders\n-        // still have some responsibility, however, because some sends might not\n-        // complete until after we flag the disconnection. There are more\n-        // details in the sending methods that see DISCONNECTED\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // increment the count on the channel (used for selection)\n-    fn bump(&self, amt: isize) -> isize {\n-        match self.queue.producer_addition().cnt.fetch_add(amt, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                DISCONNECTED\n-            }\n-            n => n,\n-        }\n-    }\n-\n-    // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&self, was_upgrade: bool) -> Result<bool, Receiver<T>> {\n-        // If we're aborting selection after upgrading from a oneshot, then\n-        // we're guarantee that no one is waiting. The only way that we could\n-        // have seen the upgrade is if data was actually sent on the channel\n-        // half again. For us, this means that there is guaranteed to be data on\n-        // this channel. Furthermore, we're guaranteed that there was no\n-        // start_selection previously, so there's no need to modify `self.cnt`\n-        // at all.\n-        //\n-        // Hence, because of these invariants, we immediately return `Ok(true)`.\n-        // Note that the data might not actually be sent on the channel just yet.\n-        // The other end could have flagged the upgrade but not sent data to\n-        // this end. This is fine because we know it's a small bounded windows\n-        // of time until the data is actually sent.\n-        if was_upgrade {\n-            assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-            return Ok(true);\n-        }\n-\n-        // We want to make sure that the count on the channel goes non-negative,\n-        // and in the stream case we can have at most one steal, so just assume\n-        // that we had one steal.\n-        let steals = 1;\n-        let prev = self.bump(steals + 1);\n-\n-        // If we were previously disconnected, then we know for sure that there\n-        // is no thread in to_wake, so just keep going\n-        let has_data = if prev == DISCONNECTED {\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-            true // there is data, that data is that we're disconnected\n-        } else {\n-            let cur = prev + steals + 1;\n-            assert!(cur >= 0);\n-\n-            // If the previous count was negative, then we just made things go\n-            // positive, hence we passed the -1 boundary and we're responsible\n-            // for removing the to_wake() field and trashing it.\n-            //\n-            // If the previous count was positive then we're in a tougher\n-            // situation. A possible race is that a sender just incremented\n-            // through -1 (meaning it's going to try to wake a thread up), but it\n-            // hasn't yet read the to_wake. In order to prevent a future recv()\n-            // from waking up too early (this sender picking up the plastered\n-            // over to_wake), we spin loop here waiting for to_wake to be 0.\n-            // Note that this entire select() implementation needs an overhaul,\n-            // and this is *not* the worst part of it, so this is not done as a\n-            // final solution but rather out of necessity for now to get\n-            // something working.\n-            if prev < 0 {\n-                drop(self.take_to_wake());\n-            } else {\n-                while self.queue.producer_addition().to_wake.load(Ordering::SeqCst) != EMPTY {\n-                    thread::yield_now();\n-                }\n-            }\n-            unsafe {\n-                assert_eq!(*self.queue.consumer_addition().steals.get(), 0);\n-                *self.queue.consumer_addition().steals.get() = steals;\n-            }\n-\n-            // if we were previously positive, then there's surely data to\n-            // receive\n-            prev >= 0\n-        };\n-\n-        // Now that we've determined that this queue \"has data\", we peek at the\n-        // queue to see if the data is an upgrade or not. If it's an upgrade,\n-        // then we need to destroy this port and abort selection on the\n-        // upgraded port.\n-        if has_data {\n-            match self.queue.peek() {\n-                Some(&mut GoUp(..)) => match self.queue.pop() {\n-                    Some(GoUp(port)) => Err(port),\n-                    _ => unreachable!(),\n-                },\n-                _ => Ok(true),\n-            }\n-        } else {\n-            Ok(false)\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        // Note that this load is not only an assert for correctness about\n-        // disconnection, but also a proper fence before the read of\n-        // `to_wake`, so this assert cannot be removed with also removing\n-        // the `to_wake` assert.\n-        assert_eq!(self.queue.producer_addition().cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-    }\n-}"}, {"sha": "733761671a041e75bffa361e8cc906a26559b4fb", "filename": "library/std/src/sync/mpsc/sync.rs", "status": "removed", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef0de98152024986dceb52d68f4511dfa344571/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs?ref=9ef0de98152024986dceb52d68f4511dfa344571", "patch": "@@ -1,495 +0,0 @@\n-use self::Blocker::*;\n-/// Synchronous channels/ports\n-///\n-/// This channel implementation differs significantly from the asynchronous\n-/// implementations found next to it (oneshot/stream/share). This is an\n-/// implementation of a synchronous, bounded buffer channel.\n-///\n-/// Each channel is created with some amount of backing buffer, and sends will\n-/// *block* until buffer space becomes available. A buffer size of 0 is valid,\n-/// which means that every successful send is paired with a successful recv.\n-///\n-/// This flavor of channels defines a new `send_opt` method for channels which\n-/// is the method by which a message is sent but the thread does not panic if it\n-/// cannot be delivered.\n-///\n-/// Another major difference is that send() will *always* return back the data\n-/// if it couldn't be sent. This is because it is deterministically known when\n-/// the data is received and when it is not received.\n-///\n-/// Implementation-wise, it can all be summed up with \"use a mutex plus some\n-/// logic\". The mutex used here is an OS native mutex, meaning that no user code\n-/// is run inside of the mutex (to prevent context switching). This\n-/// implementation shares almost all code for the buffered and unbuffered cases\n-/// of a synchronous channel. There are a few branches for the unbuffered case,\n-/// but they're mostly just relevant to blocking senders.\n-pub use self::Failure::*;\n-\n-use core::intrinsics::abort;\n-use core::mem;\n-use core::ptr;\n-\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken, WaitToken};\n-use crate::sync::{Mutex, MutexGuard};\n-use crate::time::Instant;\n-\n-const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n-\n-pub struct Packet<T> {\n-    /// Only field outside of the mutex. Just done for kicks, but mainly because\n-    /// the other shared channel already had the code implemented\n-    channels: AtomicUsize,\n-\n-    lock: Mutex<State<T>>,\n-}\n-\n-unsafe impl<T: Send> Send for Packet<T> {}\n-\n-unsafe impl<T: Send> Sync for Packet<T> {}\n-\n-struct State<T> {\n-    disconnected: bool, // Is the channel disconnected yet?\n-    queue: Queue,       // queue of senders waiting to send data\n-    blocker: Blocker,   // currently blocked thread on this channel\n-    buf: Buffer<T>,     // storage for buffered messages\n-    cap: usize,         // capacity of this channel\n-\n-    /// A curious flag used to indicate whether a sender failed or succeeded in\n-    /// blocking. This is used to transmit information back to the thread that it\n-    /// must dequeue its message from the buffer because it was not received.\n-    /// This is only relevant in the 0-buffer case. This obviously cannot be\n-    /// safely constructed, but it's guaranteed to always have a valid pointer\n-    /// value.\n-    canceled: Option<&'static mut bool>,\n-}\n-\n-unsafe impl<T: Send> Send for State<T> {}\n-\n-/// Possible flavors of threads who can be blocked on this channel.\n-enum Blocker {\n-    BlockedSender(SignalToken),\n-    BlockedReceiver(SignalToken),\n-    NoneBlocked,\n-}\n-\n-/// Simple queue for threading threads together. Nodes are stack-allocated, so\n-/// this structure is not safe at all\n-struct Queue {\n-    head: *mut Node,\n-    tail: *mut Node,\n-}\n-\n-struct Node {\n-    token: Option<SignalToken>,\n-    next: *mut Node,\n-}\n-\n-unsafe impl Send for Node {}\n-\n-/// A simple ring-buffer\n-struct Buffer<T> {\n-    buf: Vec<Option<T>>,\n-    start: usize,\n-    size: usize,\n-}\n-\n-#[derive(Debug)]\n-pub enum Failure {\n-    Empty,\n-    Disconnected,\n-}\n-\n-/// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n-/// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T>(\n-    lock: &'a Mutex<State<T>>,\n-    mut guard: MutexGuard<'b, State<T>>,\n-    f: fn(SignalToken) -> Blocker,\n-) -> MutexGuard<'a, State<T>> {\n-    let (wait_token, signal_token) = blocking::tokens();\n-    match mem::replace(&mut guard.blocker, f(signal_token)) {\n-        NoneBlocked => {}\n-        _ => unreachable!(),\n-    }\n-    drop(guard); // unlock\n-    wait_token.wait(); // block\n-    lock.lock().unwrap() // relock\n-}\n-\n-/// Same as wait, but waiting at most until `deadline`.\n-fn wait_timeout_receiver<'a, 'b, T>(\n-    lock: &'a Mutex<State<T>>,\n-    deadline: Instant,\n-    mut guard: MutexGuard<'b, State<T>>,\n-    success: &mut bool,\n-) -> MutexGuard<'a, State<T>> {\n-    let (wait_token, signal_token) = blocking::tokens();\n-    match mem::replace(&mut guard.blocker, BlockedReceiver(signal_token)) {\n-        NoneBlocked => {}\n-        _ => unreachable!(),\n-    }\n-    drop(guard); // unlock\n-    *success = wait_token.wait_max_until(deadline); // block\n-    let mut new_guard = lock.lock().unwrap(); // relock\n-    if !*success {\n-        abort_selection(&mut new_guard);\n-    }\n-    new_guard\n-}\n-\n-fn abort_selection<T>(guard: &mut MutexGuard<'_, State<T>>) -> bool {\n-    match mem::replace(&mut guard.blocker, NoneBlocked) {\n-        NoneBlocked => true,\n-        BlockedSender(token) => {\n-            guard.blocker = BlockedSender(token);\n-            true\n-        }\n-        BlockedReceiver(token) => {\n-            drop(token);\n-            false\n-        }\n-    }\n-}\n-\n-/// Wakes up a thread, dropping the lock at the correct time\n-fn wakeup<T>(token: SignalToken, guard: MutexGuard<'_, State<T>>) {\n-    // We need to be careful to wake up the waiting thread *outside* of the mutex\n-    // in case it incurs a context switch.\n-    drop(guard);\n-    token.signal();\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new(capacity: usize) -> Packet<T> {\n-        Packet {\n-            channels: AtomicUsize::new(1),\n-            lock: Mutex::new(State {\n-                disconnected: false,\n-                blocker: NoneBlocked,\n-                cap: capacity,\n-                canceled: None,\n-                queue: Queue { head: ptr::null_mut(), tail: ptr::null_mut() },\n-                buf: Buffer {\n-                    buf: (0..capacity + if capacity == 0 { 1 } else { 0 }).map(|_| None).collect(),\n-                    start: 0,\n-                    size: 0,\n-                },\n-            }),\n-        }\n-    }\n-\n-    // wait until a send slot is available, returning locked access to\n-    // the channel state.\n-    fn acquire_send_slot(&self) -> MutexGuard<'_, State<T>> {\n-        let mut node = Node { token: None, next: ptr::null_mut() };\n-        loop {\n-            let mut guard = self.lock.lock().unwrap();\n-            // are we ready to go?\n-            if guard.disconnected || guard.buf.size() < guard.buf.capacity() {\n-                return guard;\n-            }\n-            // no room; actually block\n-            let wait_token = guard.queue.enqueue(&mut node);\n-            drop(guard);\n-            wait_token.wait();\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        let mut guard = self.acquire_send_slot();\n-        if guard.disconnected {\n-            return Err(t);\n-        }\n-        guard.buf.enqueue(t);\n-\n-        match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            // if our capacity is 0, then we need to wait for a receiver to be\n-            // available to take our data. After waiting, we check again to make\n-            // sure the port didn't go away in the meantime. If it did, we need\n-            // to hand back our data.\n-            NoneBlocked if guard.cap == 0 => {\n-                let mut canceled = false;\n-                assert!(guard.canceled.is_none());\n-                guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n-                let mut guard = wait(&self.lock, guard, BlockedSender);\n-                if canceled { Err(guard.buf.dequeue()) } else { Ok(()) }\n-            }\n-\n-            // success, we buffered some data\n-            NoneBlocked => Ok(()),\n-\n-            // success, someone's about to receive our buffered data.\n-            BlockedReceiver(token) => {\n-                wakeup(token, guard);\n-                Ok(())\n-            }\n-\n-            BlockedSender(..) => panic!(\"lolwut\"),\n-        }\n-    }\n-\n-    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected {\n-            Err(super::TrySendError::Disconnected(t))\n-        } else if guard.buf.size() == guard.buf.capacity() {\n-            Err(super::TrySendError::Full(t))\n-        } else if guard.cap == 0 {\n-            // With capacity 0, even though we have buffer space we can't\n-            // transfer the data unless there's a receiver waiting.\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => Err(super::TrySendError::Full(t)),\n-                BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(token) => {\n-                    guard.buf.enqueue(t);\n-                    wakeup(token, guard);\n-                    Ok(())\n-                }\n-            }\n-        } else {\n-            // If the buffer has some space and the capacity isn't 0, then we\n-            // just enqueue the data for later retrieval, ensuring to wake up\n-            // any blocked receiver if there is one.\n-            assert!(guard.buf.size() < guard.buf.capacity());\n-            guard.buf.enqueue(t);\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                BlockedReceiver(token) => wakeup(token, guard),\n-                NoneBlocked => {}\n-                BlockedSender(..) => unreachable!(),\n-            }\n-            Ok(())\n-        }\n-    }\n-\n-    // Receives a message from this channel\n-    //\n-    // When reading this, remember that there can only ever be one receiver at\n-    // time.\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        let mut woke_up_after_waiting = false;\n-        // Wait for the buffer to have something in it. No need for a\n-        // while loop because we're the only receiver.\n-        if !guard.disconnected && guard.buf.size() == 0 {\n-            if let Some(deadline) = deadline {\n-                guard =\n-                    wait_timeout_receiver(&self.lock, deadline, guard, &mut woke_up_after_waiting);\n-            } else {\n-                guard = wait(&self.lock, guard, BlockedReceiver);\n-                woke_up_after_waiting = true;\n-            }\n-        }\n-\n-        // N.B., channel could be disconnected while waiting, so the order of\n-        // these conditionals is important.\n-        if guard.disconnected && guard.buf.size() == 0 {\n-            return Err(Disconnected);\n-        }\n-\n-        // Pick up the data, wake up our neighbors, and carry on\n-        assert!(guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting));\n-\n-        if guard.buf.size() == 0 {\n-            return Err(Empty);\n-        }\n-\n-        let ret = guard.buf.dequeue();\n-        self.wakeup_senders(woke_up_after_waiting, guard);\n-        Ok(ret)\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        // Easy cases first\n-        if guard.disconnected && guard.buf.size() == 0 {\n-            return Err(Disconnected);\n-        }\n-        if guard.buf.size() == 0 {\n-            return Err(Empty);\n-        }\n-\n-        // Be sure to wake up neighbors\n-        let ret = Ok(guard.buf.dequeue());\n-        self.wakeup_senders(false, guard);\n-        ret\n-    }\n-\n-    // Wake up pending senders after some data has been received\n-    //\n-    // * `waited` - flag if the receiver blocked to receive some data, or if it\n-    //              just picked up some data on the way out\n-    // * `guard` - the lock guard that is held over this channel's lock\n-    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<'_, State<T>>) {\n-        let pending_sender1: Option<SignalToken> = guard.queue.dequeue();\n-\n-        // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n-        // need to ACK the sender. If we waited, then the sender waking us up\n-        // was already the ACK.\n-        let pending_sender2 = if guard.cap == 0 && !waited {\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => None,\n-                BlockedReceiver(..) => unreachable!(),\n-                BlockedSender(token) => {\n-                    guard.canceled.take();\n-                    Some(token)\n-                }\n-            }\n-        } else {\n-            None\n-        };\n-        mem::drop(guard);\n-\n-        // only outside of the lock do we wake up the pending threads\n-        if let Some(token) = pending_sender1 {\n-            token.signal();\n-        }\n-        if let Some(token) = pending_sender2 {\n-            token.signal();\n-        }\n-    }\n-\n-    // Prepares this shared packet for a channel clone, essentially just bumping\n-    // a refcount.\n-    pub fn clone_chan(&self) {\n-        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n-\n-        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n-        if old_count > MAX_REFCOUNT {\n-            abort();\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        // Only flag the channel as disconnected if we're the last channel\n-        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n-            1 => {}\n-            _ => return,\n-        }\n-\n-        // Not much to do other than wake up a receiver if one's there\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected {\n-            return;\n-        }\n-        guard.disconnected = true;\n-        match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            NoneBlocked => {}\n-            BlockedSender(..) => unreachable!(),\n-            BlockedReceiver(token) => wakeup(token, guard),\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        if guard.disconnected {\n-            return;\n-        }\n-        guard.disconnected = true;\n-\n-        // If the capacity is 0, then the sender may want its data back after\n-        // we're disconnected. Otherwise it's now our responsibility to destroy\n-        // the buffered data. As with many other portions of this code, this\n-        // needs to be careful to destroy the data *outside* of the lock to\n-        // prevent deadlock.\n-        let _data = if guard.cap != 0 { mem::take(&mut guard.buf.buf) } else { Vec::new() };\n-        let mut queue =\n-            mem::replace(&mut guard.queue, Queue { head: ptr::null_mut(), tail: ptr::null_mut() });\n-\n-        let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            NoneBlocked => None,\n-            BlockedSender(token) => {\n-                *guard.canceled.take().unwrap() = true;\n-                Some(token)\n-            }\n-            BlockedReceiver(..) => unreachable!(),\n-        };\n-        mem::drop(guard);\n-\n-        while let Some(token) = queue.dequeue() {\n-            token.signal();\n-        }\n-        if let Some(token) = waiter {\n-            token.signal();\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n-        let mut guard = self.lock.lock().unwrap();\n-        assert!(guard.queue.dequeue().is_none());\n-        assert!(guard.canceled.is_none());\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Buffer, a simple ring buffer backed by Vec<T>\n-////////////////////////////////////////////////////////////////////////////////\n-\n-impl<T> Buffer<T> {\n-    fn enqueue(&mut self, t: T) {\n-        let pos = (self.start + self.size) % self.buf.len();\n-        self.size += 1;\n-        let prev = mem::replace(&mut self.buf[pos], Some(t));\n-        assert!(prev.is_none());\n-    }\n-\n-    fn dequeue(&mut self) -> T {\n-        let start = self.start;\n-        self.size -= 1;\n-        self.start = (self.start + 1) % self.buf.len();\n-        let result = &mut self.buf[start];\n-        result.take().unwrap()\n-    }\n-\n-    fn size(&self) -> usize {\n-        self.size\n-    }\n-    fn capacity(&self) -> usize {\n-        self.buf.len()\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Queue, a simple queue to enqueue threads with (stack-allocated nodes)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-impl Queue {\n-    fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n-        let (wait_token, signal_token) = blocking::tokens();\n-        node.token = Some(signal_token);\n-        node.next = ptr::null_mut();\n-\n-        if self.tail.is_null() {\n-            self.head = node as *mut Node;\n-            self.tail = node as *mut Node;\n-        } else {\n-            unsafe {\n-                (*self.tail).next = node as *mut Node;\n-                self.tail = node as *mut Node;\n-            }\n-        }\n-\n-        wait_token\n-    }\n-\n-    fn dequeue(&mut self) -> Option<SignalToken> {\n-        if self.head.is_null() {\n-            return None;\n-        }\n-        let node = self.head;\n-        self.head = unsafe { (*node).next };\n-        if self.head.is_null() {\n-            self.tail = ptr::null_mut();\n-        }\n-        unsafe {\n-            (*node).next = ptr::null_mut();\n-            Some((*node).token.take().unwrap())\n-        }\n-    }\n-}"}, {"sha": "82c52eb4fef45b6e2cc48bc4e893e2f08d50ee8d", "filename": "library/std/src/sync/mpsc/tests.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -706,3 +706,17 @@ fn issue_32114() {\n     let _ = tx.send(123);\n     assert_eq!(tx.send(123), Err(SendError(123)));\n }\n+\n+#[test]\n+fn issue_39364() {\n+    let (tx, rx) = channel::<()>();\n+    let t = thread::spawn(move || {\n+        thread::sleep(Duration::from_millis(300));\n+        let _ = tx.clone();\n+        crate::mem::forget(tx);\n+    });\n+\n+    let _ = rx.recv_timeout(Duration::from_millis(500));\n+    t.join().unwrap();\n+    let _ = rx.recv_timeout(Duration::from_millis(500));\n+}"}, {"sha": "065045f442069feaa75a5d6b46e7b5a707af2b33", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -5,7 +5,7 @@ use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::ops::{Deref, DerefMut};\n use crate::sync::{poison, LockResult, TryLockError, TryLockResult};\n-use crate::sys_common::mutex as sys;\n+use crate::sys::locks as sys;\n \n /// A mutual exclusion primitive useful for protecting shared data\n ///\n@@ -163,7 +163,7 @@ use crate::sys_common::mutex as sys;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Mutex\")]\n pub struct Mutex<T: ?Sized> {\n-    inner: sys::MovableMutex,\n+    inner: sys::Mutex,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -217,11 +217,7 @@ impl<T> Mutex<T> {\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n     #[inline]\n     pub const fn new(t: T) -> Mutex<T> {\n-        Mutex {\n-            inner: sys::MovableMutex::new(),\n-            poison: poison::Flag::new(),\n-            data: UnsafeCell::new(t),\n-        }\n+        Mutex { inner: sys::Mutex::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }\n     }\n }\n \n@@ -264,7 +260,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {\n         unsafe {\n-            self.inner.raw_lock();\n+            self.inner.lock();\n             MutexGuard::new(self)\n         }\n     }\n@@ -526,7 +522,7 @@ impl<T: ?Sized> Drop for MutexGuard<'_, T> {\n     fn drop(&mut self) {\n         unsafe {\n             self.lock.poison.done(&self.poison);\n-            self.lock.inner.raw_unlock();\n+            self.lock.inner.unlock();\n         }\n     }\n }\n@@ -545,7 +541,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::MovableMutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.lock.inner\n }\n "}, {"sha": "7c409cb3e9776e62aab48049f830d81105ff707d", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -6,7 +6,7 @@ use crate::fmt;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr::NonNull;\n use crate::sync::{poison, LockResult, TryLockError, TryLockResult};\n-use crate::sys_common::rwlock as sys;\n+use crate::sys::locks as sys;\n \n /// A reader-writer lock\n ///\n@@ -78,7 +78,7 @@ use crate::sys_common::rwlock as sys;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"RwLock\")]\n pub struct RwLock<T: ?Sized> {\n-    inner: sys::MovableRwLock,\n+    inner: sys::RwLock,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -109,7 +109,7 @@ pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     // `NonNull` is also covariant over `T`, just like we would have with `&T`. `NonNull`\n     // is preferable over `const* T` to allow for niche optimization.\n     data: NonNull<T>,\n-    inner_lock: &'a sys::MovableRwLock,\n+    inner_lock: &'a sys::RwLock,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -158,11 +158,7 @@ impl<T> RwLock<T> {\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n     #[inline]\n     pub const fn new(t: T) -> RwLock<T> {\n-        RwLock {\n-            inner: sys::MovableRwLock::new(),\n-            poison: poison::Flag::new(),\n-            data: UnsafeCell::new(t),\n-        }\n+        RwLock { inner: sys::RwLock::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }\n     }\n }\n "}, {"sha": "6811fadb0188cd5d922e67803262f7676ce81c8a", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -51,9 +51,9 @@ pub mod locks {\n     mod futex_condvar;\n     mod futex_mutex;\n     mod futex_rwlock;\n-    pub(crate) use futex_condvar::MovableCondvar;\n-    pub(crate) use futex_mutex::{MovableMutex, Mutex};\n-    pub(crate) use futex_rwlock::{MovableRwLock, RwLock};\n+    pub(crate) use futex_condvar::Condvar;\n+    pub(crate) use futex_mutex::Mutex;\n+    pub(crate) use futex_rwlock::RwLock;\n }\n \n use crate::io::ErrorKind;"}, {"sha": "f70aa434e48348b3b5289a52cdbc632d2f625b2e", "filename": "library/std/src/sys/itron/condvar.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -12,18 +12,13 @@ pub struct Condvar {\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub type MovableCondvar = Condvar;\n-\n impl Condvar {\n     #[inline]\n     pub const fn new() -> Condvar {\n         Condvar { waiters: SpinMutex::new(waiter_queue::WaiterQueue::new()) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n-    pub unsafe fn notify_one(&self) {\n+    pub fn notify_one(&self) {\n         self.waiters.with_locked(|waiters| {\n             if let Some(task) = waiters.pop_front() {\n                 // Unpark the task\n@@ -39,7 +34,7 @@ impl Condvar {\n         });\n     }\n \n-    pub unsafe fn notify_all(&self) {\n+    pub fn notify_all(&self) {\n         self.waiters.with_locked(|waiters| {\n             while let Some(task) = waiters.pop_front() {\n                 // Unpark the task"}, {"sha": "f2eed8e771c40ece6fd04b090ae918c3843f694b", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -11,8 +11,6 @@ pub struct Mutex {\n     mtx: SpinIdOnceCell<()>,\n }\n \n-pub type MovableMutex = Mutex;\n-\n /// Create a mutex object. This function never panics.\n fn new_mtx() -> Result<abi::ID, ItronError> {\n     ItronError::err_if_negative(unsafe {\n@@ -39,7 +37,7 @@ impl Mutex {\n         }\n     }\n \n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         let mtx = self.raw();\n         expect_success(unsafe { abi::loc_mtx(mtx) }, &\"loc_mtx\");\n     }\n@@ -49,7 +47,7 @@ impl Mutex {\n         expect_success_aborting(unsafe { abi::unl_mtx(mtx) }, &\"unl_mtx\");\n     }\n \n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         let mtx = self.raw();\n         match unsafe { abi::ploc_mtx(mtx) } {\n             abi::E_TMOUT => false,"}, {"sha": "aa1174664aeb0966deae0b3343ee063f01e0e6ab", "filename": "library/std/src/sys/sgx/condvar.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -4,42 +4,43 @@ use crate::time::Duration;\n \n use super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n \n+/// FIXME: `UnsafeList` is not movable.\n+struct AllocatedCondvar(SpinMutex<WaitVariable<()>>);\n+\n pub struct Condvar {\n-    inner: SpinMutex<WaitVariable<()>>,\n+    inner: LazyBox<AllocatedCondvar>,\n }\n \n-pub(crate) type MovableCondvar = LazyBox<Condvar>;\n-\n-impl LazyInit for Condvar {\n+impl LazyInit for AllocatedCondvar {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedCondvar(SpinMutex::new(WaitVariable::new(()))))\n     }\n }\n \n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n+        Condvar { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let _ = WaitQueue::notify_one(self.inner.lock());\n+    pub fn notify_one(&self) {\n+        let _ = WaitQueue::notify_one(self.inner.0.lock());\n     }\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let _ = WaitQueue::notify_all(self.inner.lock());\n+    pub fn notify_all(&self) {\n+        let _ = WaitQueue::notify_all(self.inner.0.lock());\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let guard = self.inner.lock();\n+        let guard = self.inner.0.lock();\n         WaitQueue::wait(guard, || unsafe { mutex.unlock() });\n-        unsafe { mutex.lock() }\n+        mutex.lock()\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let success = WaitQueue::wait_timeout(&self.inner, dur, || unsafe { mutex.unlock() });\n-        unsafe { mutex.lock() };\n+        let success = WaitQueue::wait_timeout(&self.inner.0, dur, || unsafe { mutex.unlock() });\n+        mutex.lock();\n         success\n     }\n }"}, {"sha": "0dbf020ebe06af53bd12e53de14d655aa89001a4", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,28 +1,28 @@\n use super::waitqueue::{try_lock_or_false, SpinMutex, WaitQueue, WaitVariable};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n+/// FIXME: `UnsafeList` is not movable.\n+struct AllocatedMutex(SpinMutex<WaitVariable<bool>>);\n+\n pub struct Mutex {\n-    inner: SpinMutex<WaitVariable<bool>>,\n+    inner: LazyBox<AllocatedMutex>,\n }\n \n-// not movable: see UnsafeList implementation\n-pub(crate) type MovableMutex = LazyBox<Mutex>;\n-\n-impl LazyInit for Mutex {\n+impl LazyInit for AllocatedMutex {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedMutex(SpinMutex::new(WaitVariable::new(false))))\n     }\n }\n \n // Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n+        Mutex { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n-        let mut guard = self.inner.lock();\n+    pub fn lock(&self) {\n+        let mut guard = self.inner.0.lock();\n         if *guard.lock_var() {\n             // Another thread has the lock, wait\n             WaitQueue::wait(guard, || {})\n@@ -35,7 +35,7 @@ impl Mutex {\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let guard = self.inner.lock();\n+        let guard = self.inner.0.lock();\n         if let Err(mut guard) = WaitQueue::notify_one(guard) {\n             // No other waiters, unlock\n             *guard.lock_var_mut() = false;\n@@ -45,8 +45,8 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let mut guard = try_lock_or_false!(self.inner);\n+    pub fn try_lock(&self) -> bool {\n+        let mut guard = try_lock_or_false!(self.inner.0);\n         if *guard.lock_var() {\n             // Another thread has the lock\n             false"}, {"sha": "d89de18ca5ff8f8295c5e958a655091b3a5aaf1a", "filename": "library/std/src/sys/sgx/rwlock.rs", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -7,42 +7,45 @@ use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use super::waitqueue::{\n     try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n };\n-use crate::mem;\n+use crate::alloc::Layout;\n \n-pub struct RwLock {\n+struct AllocatedRwLock {\n     readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n     writer: SpinMutex<WaitVariable<bool>>,\n }\n \n-pub(crate) type MovableRwLock = LazyBox<RwLock>;\n+pub struct RwLock {\n+    inner: LazyBox<AllocatedRwLock>,\n+}\n \n-impl LazyInit for RwLock {\n+impl LazyInit for AllocatedRwLock {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedRwLock {\n+            readers: SpinMutex::new(WaitVariable::new(None)),\n+            writer: SpinMutex::new(WaitVariable::new(false)),\n+        })\n     }\n }\n \n-// Check at compile time that RwLock size matches C definition (see test_c_rwlock_initializer below)\n-//\n-// # Safety\n-// Never called, as it is a compile time check.\n-#[allow(dead_code)]\n-unsafe fn rw_lock_size_assert(r: RwLock) {\n-    unsafe { mem::transmute::<RwLock, [u8; 144]>(r) };\n-}\n+// Check at compile time that RwLock's size and alignment matches the C definition\n+// in libunwind (see also `test_c_rwlock_initializer` in `tests`).\n+const _: () = {\n+    let rust = Layout::new::<RwLock>();\n+    let c = Layout::new::<*mut ()>();\n+    assert!(rust.size() == c.size());\n+    assert!(rust.align() == c.align());\n+};\n \n impl RwLock {\n     pub const fn new() -> RwLock {\n-        RwLock {\n-            readers: SpinMutex::new(WaitVariable::new(None)),\n-            writer: SpinMutex::new(WaitVariable::new(false)),\n-        }\n+        RwLock { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n-        let mut rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+    pub fn read(&self) {\n+        let lock = &*self.inner;\n+        let mut rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock, wait\n             drop(wguard);\n@@ -57,8 +60,9 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        let mut rguard = try_lock_or_false!(self.readers);\n-        let wguard = try_lock_or_false!(self.writer);\n+        let lock = &*self.inner;\n+        let mut rguard = try_lock_or_false!(lock.readers);\n+        let wguard = try_lock_or_false!(lock.writer);\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock\n             false\n@@ -71,9 +75,10 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n-        let rguard = self.readers.lock();\n-        let mut wguard = self.writer.lock();\n+    pub fn write(&self) {\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let mut wguard = lock.writer.lock();\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock, wait\n             drop(rguard);\n@@ -86,9 +91,10 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        let rguard = try_lock_or_false!(self.readers);\n-        let mut wguard = try_lock_or_false!(self.writer);\n+    pub fn try_write(&self) -> bool {\n+        let lock = &*self.inner;\n+        let rguard = try_lock_or_false!(lock.readers);\n+        let mut wguard = try_lock_or_false!(lock.writer);\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock\n             false\n@@ -122,8 +128,9 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         unsafe { self.__read_unlock(rguard, wguard) };\n     }\n \n@@ -158,17 +165,19 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         unsafe { self.__write_unlock(rguard, wguard) };\n     }\n \n     // only used by __rust_rwlock_unlock below\n     #[inline]\n     #[cfg_attr(test, allow(dead_code))]\n     unsafe fn unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         if *wguard.lock_var() == true {\n             unsafe { self.__write_unlock(rguard, wguard) };\n         } else {\n@@ -201,6 +210,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RwLock) -> i32 {\n     unsafe { (*p).write() };\n     return 0;\n }\n+\n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RwLock) -> i32 {"}, {"sha": "5fd6670afd4356db2de86376bbd38a00d5d54850", "filename": "library/std/src/sys/sgx/rwlock/tests.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,22 +1,12 @@\n use super::*;\n+use crate::ptr;\n \n // Verify that the byte pattern libunwind uses to initialize an RwLock is\n // equivalent to the value of RwLock::new(). If the value changes,\n // `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n #[test]\n fn test_c_rwlock_initializer() {\n-    #[rustfmt::skip]\n-    const C_RWLOCK_INIT: &[u8] = &[\n-        /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x40 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x50 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x60 */ 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x70 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-    ];\n+    const C_RWLOCK_INIT: *mut () = ptr::null_mut();\n \n     // For the test to work, we need the padding/unused bytes in RwLock to be\n     // initialized as 0. In practice, this is the case with statics.\n@@ -26,6 +16,6 @@ fn test_c_rwlock_initializer() {\n         // If the assertion fails, that not necessarily an issue with the value\n         // of C_RWLOCK_INIT. It might just be an issue with the way padding\n         // bytes are initialized in the test code.\n-        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n+        assert_eq!(crate::mem::transmute_copy::<_, *mut ()>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n     };\n }"}, {"sha": "ecb4eb83b9b05efa66e40fe48f3e98c9af930585", "filename": "library/std/src/sys/solid/rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -12,8 +12,6 @@ pub struct RwLock {\n     rwl: SpinIdOnceCell<()>,\n }\n \n-pub type MovableRwLock = RwLock;\n-\n // Safety: `num_readers` is protected by `mtx_num_readers`\n unsafe impl Send for RwLock {}\n unsafe impl Sync for RwLock {}\n@@ -37,13 +35,13 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let rwl = self.raw();\n         expect_success(unsafe { abi::rwl_loc_rdl(rwl) }, &\"rwl_loc_rdl\");\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         let rwl = self.raw();\n         match unsafe { abi::rwl_ploc_rdl(rwl) } {\n             abi::E_TMOUT => false,\n@@ -55,13 +53,13 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         let rwl = self.raw();\n         expect_success(unsafe { abi::rwl_loc_wrl(rwl) }, &\"rwl_loc_wrl\");\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         let rwl = self.raw();\n         match unsafe { abi::rwl_ploc_wrl(rwl) } {\n             abi::E_TMOUT => false,"}, {"sha": "5d89e5a13fd366fec28cd38e7d02c3c1b7ec0720", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -53,8 +53,6 @@ const CONTESTED_BIT: u32 = 1;\n // This can never be a valid `zx_handle_t`.\n const UNLOCKED: u32 = 0;\n \n-pub type MovableMutex = Mutex;\n-\n pub struct Mutex {\n     futex: AtomicU32,\n }\n@@ -86,23 +84,27 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let thread_self = zx_thread_self();\n+    pub fn try_lock(&self) -> bool {\n+        let thread_self = unsafe { zx_thread_self() };\n         self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed).is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n-        let thread_self = zx_thread_self();\n+    pub fn lock(&self) {\n+        let thread_self = unsafe { zx_thread_self() };\n         if let Err(state) =\n             self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed)\n         {\n-            self.lock_contested(state, thread_self);\n+            unsafe {\n+                self.lock_contested(state, thread_self);\n+            }\n         }\n     }\n \n+    /// # Safety\n+    /// `thread_self` must be the handle for the current thread.\n     #[cold]\n-    fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n+    unsafe fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n         let owned_state = mark_contested(to_state(thread_self));\n         loop {\n             // Mark the mutex as contested if it is not already."}, {"sha": "4bd65dd25c2921c5a91a05013b3ce99346f247f6", "filename": "library/std/src/sys/unix/locks/futex_condvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,8 +3,6 @@ use crate::sync::atomic::{AtomicU32, Ordering::Relaxed};\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n use crate::time::Duration;\n \n-pub type MovableCondvar = Condvar;\n-\n pub struct Condvar {\n     // The value of this atomic is simply incremented on every notification.\n     // This is used by `.wait()` to not miss any notifications after\n@@ -21,12 +19,12 @@ impl Condvar {\n     // All the memory orderings here are `Relaxed`,\n     // because synchronization is done by unlocking and locking the mutex.\n \n-    pub unsafe fn notify_one(&self) {\n+    pub fn notify_one(&self) {\n         self.futex.fetch_add(1, Relaxed);\n         futex_wake(&self.futex);\n     }\n \n-    pub unsafe fn notify_all(&self) {\n+    pub fn notify_all(&self) {\n         self.futex.fetch_add(1, Relaxed);\n         futex_wake_all(&self.futex);\n     }"}, {"sha": "c01229586c30201c51cad01cbd328f1986f330f2", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -4,8 +4,6 @@ use crate::sync::atomic::{\n };\n use crate::sys::futex::{futex_wait, futex_wake};\n \n-pub type MovableMutex = Mutex;\n-\n pub struct Mutex {\n     /// 0: unlocked\n     /// 1: locked, no other threads waiting\n@@ -20,12 +18,12 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         if self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_err() {\n             self.lock_contended();\n         }"}, {"sha": "aa0de900238f5466bb664ada645da0b066982779", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -4,8 +4,6 @@ use crate::sync::atomic::{\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n \n-pub type MovableRwLock = RwLock;\n-\n pub struct RwLock {\n     // The state consists of a 30-bit reader counter, a 'readers waiting' flag, and a 'writers waiting' flag.\n     // Bits 0..30:\n@@ -70,14 +68,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         self.state\n             .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))\n             .is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let state = self.state.load(Relaxed);\n         if !is_read_lockable(state)\n             || self\n@@ -144,14 +142,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         self.state\n             .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n             .is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         if self.state.compare_exchange_weak(0, WRITE_LOCKED, Acquire, Relaxed).is_err() {\n             self.write_contended();\n         }"}, {"sha": "b2e0e49ad736d6e00a3e394d998d9c6a8e59e547", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -10,22 +10,22 @@ cfg_if::cfg_if! {\n         mod futex_mutex;\n         mod futex_rwlock;\n         mod futex_condvar;\n-        pub(crate) use futex_mutex::{Mutex, MovableMutex};\n-        pub(crate) use futex_rwlock::MovableRwLock;\n-        pub(crate) use futex_condvar::MovableCondvar;\n+        pub(crate) use futex_mutex::Mutex;\n+        pub(crate) use futex_rwlock::RwLock;\n+        pub(crate) use futex_condvar::Condvar;\n     } else if #[cfg(target_os = \"fuchsia\")] {\n         mod fuchsia_mutex;\n         mod futex_rwlock;\n         mod futex_condvar;\n-        pub(crate) use fuchsia_mutex::{Mutex, MovableMutex};\n-        pub(crate) use futex_rwlock::MovableRwLock;\n-        pub(crate) use futex_condvar::MovableCondvar;\n+        pub(crate) use fuchsia_mutex::Mutex;\n+        pub(crate) use futex_rwlock::RwLock;\n+        pub(crate) use futex_condvar::Condvar;\n     } else {\n         mod pthread_mutex;\n         mod pthread_rwlock;\n         mod pthread_condvar;\n-        pub(crate) use pthread_mutex::{Mutex, MovableMutex};\n-        pub(crate) use pthread_rwlock::MovableRwLock;\n-        pub(crate) use pthread_condvar::MovableCondvar;\n+        pub(crate) use pthread_mutex::Mutex;\n+        pub(crate) use pthread_rwlock::RwLock;\n+        pub(crate) use pthread_condvar::Condvar;\n     }\n }"}, {"sha": "1ddb09905db2cfa0f3002535eb8729c3400310b9", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 91, "deletions": 88, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,99 +1,122 @@\n use crate::cell::UnsafeCell;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n+struct AllocatedCondvar(UnsafeCell<libc::pthread_cond_t>);\n+\n pub struct Condvar {\n-    inner: UnsafeCell<libc::pthread_cond_t>,\n+    inner: LazyBox<AllocatedCondvar>,\n+    mutex: AtomicPtr<libc::pthread_mutex_t>,\n }\n \n-pub(crate) type MovableCondvar = LazyBox<Condvar>;\n-\n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n const TIMESPEC_MAX: libc::timespec =\n     libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n     if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n }\n \n-impl LazyInit for Condvar {\n+#[inline]\n+fn raw(c: &Condvar) -> *mut libc::pthread_cond_t {\n+    c.inner.0.get()\n+}\n+\n+unsafe impl Send for AllocatedCondvar {}\n+unsafe impl Sync for AllocatedCondvar {}\n+\n+impl LazyInit for AllocatedCondvar {\n     fn init() -> Box<Self> {\n-        let mut condvar = Box::new(Self::new());\n-        unsafe { condvar.init() };\n+        let condvar = Box::new(AllocatedCondvar(UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER)));\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+                target_os = \"watchos\",\n+                target_os = \"l4re\",\n+                target_os = \"android\",\n+                target_os = \"redox\"\n+            ))] {\n+                // `pthread_condattr_setclock` is unfortunately not supported on these platforms.\n+            } else if #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))] {\n+                // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n+                // So on that platform, init() should always be called\n+                // Moreover, that platform does not have pthread_condattr_setclock support,\n+                // hence that initialization should be skipped as well\n+                //\n+                // Similar story for the 3DS (horizon).\n+                let r = unsafe { libc::pthread_cond_init(condvar.0.get(), crate::ptr::null()) };\n+                assert_eq!(r, 0);\n+            } else {\n+                use crate::mem::MaybeUninit;\n+                let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+                let r = unsafe { libc::pthread_condattr_init(attr.as_mut_ptr()) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_cond_init(condvar.0.get(), attr.as_ptr()) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_condattr_destroy(attr.as_mut_ptr()) };\n+                assert_eq!(r, 0);\n+            }\n+        }\n+\n         condvar\n     }\n }\n \n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n-        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n+impl Drop for AllocatedCondvar {\n+    #[inline]\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_cond_destroy(self.0.get()) };\n+        if cfg!(target_os = \"dragonfly\") {\n+            // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n+            // a condvar that was just initialized with\n+            // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n+            // pthread_cond_init() is called, this behaviour no longer occurs.\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n+}\n \n-    #[cfg(any(\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"watchos\",\n-        target_os = \"l4re\",\n-        target_os = \"android\",\n-        target_os = \"redox\"\n-    ))]\n-    unsafe fn init(&mut self) {}\n-\n-    // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n-    // So on that platform, init() should always be called\n-    // Moreover, that platform does not have pthread_condattr_setclock support,\n-    // hence that initialization should be skipped as well\n-    //\n-    // Similar story for the 3DS (horizon).\n-    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n-    unsafe fn init(&mut self) {\n-        let r = libc::pthread_cond_init(self.inner.get(), crate::ptr::null());\n-        assert_eq!(r, 0);\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { inner: LazyBox::new(), mutex: AtomicPtr::new(ptr::null_mut()) }\n     }\n \n-    #[cfg(not(any(\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"watchos\",\n-        target_os = \"l4re\",\n-        target_os = \"android\",\n-        target_os = \"redox\",\n-        target_os = \"espidf\",\n-        target_os = \"horizon\"\n-    )))]\n-    unsafe fn init(&mut self) {\n-        use crate::mem::MaybeUninit;\n-        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n-        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n+    #[inline]\n+    fn verify(&self, mutex: *mut libc::pthread_mutex_t) {\n+        // Relaxed is okay here because we never read through `self.addr`, and only use it to\n+        // compare addresses.\n+        match self.mutex.compare_exchange(ptr::null_mut(), mutex, Relaxed, Relaxed) {\n+            Ok(_) => {}                // Stored the address\n+            Err(n) if n == mutex => {} // Lost a race to store the same address\n+            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n+        }\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let r = libc::pthread_cond_signal(self.inner.get());\n+    pub fn notify_one(&self) {\n+        let r = unsafe { libc::pthread_cond_signal(raw(self)) };\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let r = libc::pthread_cond_broadcast(self.inner.get());\n+    pub fn notify_all(&self) {\n+        let r = unsafe { libc::pthread_cond_broadcast(raw(self)) };\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = libc::pthread_cond_wait(self.inner.get(), pthread_mutex::raw(mutex));\n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+        let r = libc::pthread_cond_wait(raw(self), mutex);\n         debug_assert_eq!(r, 0);\n     }\n \n@@ -112,6 +135,9 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+\n         let mut now: libc::timespec = mem::zeroed();\n         let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n         assert_eq!(r, 0);\n@@ -127,7 +153,7 @@ impl Condvar {\n         let timeout =\n             sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n \n-        let r = libc::pthread_cond_timedwait(self.inner.get(), pthread_mutex::raw(mutex), &timeout);\n+        let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n     }\n@@ -144,9 +170,11 @@ impl Condvar {\n         target_os = \"horizon\"\n     ))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n-        use crate::ptr;\n         use crate::time::Instant;\n \n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+\n         // 1000 years\n         let max_dur = Duration::from_secs(1000 * 365 * 86400);\n \n@@ -187,36 +215,11 @@ impl Condvar {\n             .unwrap_or(TIMESPEC_MAX);\n \n         // And wait!\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), pthread_mutex::raw(mutex), &timeout);\n+        let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n         stable_now.elapsed() < dur\n     }\n-\n-    #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n-        // a condvar that was just initialized with\n-        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n-        // pthread_cond_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n-    }\n-}\n-\n-impl Drop for Condvar {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n-    }\n }"}, {"sha": "8a78bc1fd739904141deda9cafaba58b91a8f624", "filename": "library/std/src/sys/unix/locks/pthread_mutex.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,56 +3,24 @@ use crate::mem::{forget, MaybeUninit};\n use crate::sys::cvt_nz;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n+struct AllocatedMutex(UnsafeCell<libc::pthread_mutex_t>);\n+\n pub struct Mutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n+    inner: LazyBox<AllocatedMutex>,\n }\n \n-pub(crate) type MovableMutex = LazyBox<Mutex>;\n-\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n-    m.inner.get()\n+    m.inner.0.get()\n }\n \n-unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {}\n+unsafe impl Send for AllocatedMutex {}\n+unsafe impl Sync for AllocatedMutex {}\n \n-impl LazyInit for Mutex {\n+impl LazyInit for AllocatedMutex {\n     fn init() -> Box<Self> {\n-        let mut mutex = Box::new(Self::new());\n-        unsafe { mutex.init() };\n-        mutex\n-    }\n-\n-    fn destroy(mutex: Box<Self>) {\n-        // We're not allowed to pthread_mutex_destroy a locked mutex,\n-        // so check first if it's unlocked.\n-        if unsafe { mutex.try_lock() } {\n-            unsafe { mutex.unlock() };\n-            drop(mutex);\n-        } else {\n-            // The mutex is locked. This happens if a MutexGuard is leaked.\n-            // In this case, we just leak the Mutex too.\n-            forget(mutex);\n-        }\n-    }\n-\n-    fn cancel_init(_: Box<Self>) {\n-        // In this case, we can just drop it without any checks,\n-        // since it cannot have been locked yet.\n-    }\n-}\n+        let mutex = Box::new(AllocatedMutex(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER)));\n \n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        // Might be moved to a different address, so it is better to avoid\n-        // initialization of potentially opaque OS data before it landed.\n-        // Be very careful using this newly constructed `Mutex`, reentrant\n-        // locking is undefined behavior until `init` is called!\n-        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n-    }\n-    #[inline]\n-    unsafe fn init(&mut self) {\n         // Issue #33770\n         //\n         // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n@@ -77,49 +45,77 @@ impl Mutex {\n         // references, we instead create the mutex with type\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n-        let attr = PthreadMutexAttr(&mut attr);\n-        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n+        unsafe {\n+            let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+            cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+            let attr = PthreadMutexAttr(&mut attr);\n+            cvt_nz(libc::pthread_mutexattr_settype(\n+                attr.0.as_mut_ptr(),\n+                libc::PTHREAD_MUTEX_NORMAL,\n+            ))\n             .unwrap();\n-        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n+            cvt_nz(libc::pthread_mutex_init(mutex.0.get(), attr.0.as_ptr())).unwrap();\n+        }\n+\n+        mutex\n     }\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let r = libc::pthread_mutex_lock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+\n+    fn destroy(mutex: Box<Self>) {\n+        // We're not allowed to pthread_mutex_destroy a locked mutex,\n+        // so check first if it's unlocked.\n+        if unsafe { libc::pthread_mutex_trylock(mutex.0.get()) == 0 } {\n+            unsafe { libc::pthread_mutex_unlock(mutex.0.get()) };\n+            drop(mutex);\n+        } else {\n+            // The mutex is locked. This happens if a MutexGuard is leaked.\n+            // In this case, we just leak the Mutex too.\n+            forget(mutex);\n+        }\n     }\n+\n+    fn cancel_init(_: Box<Self>) {\n+        // In this case, we can just drop it without any checks,\n+        // since it cannot have been locked yet.\n+    }\n+}\n+\n+impl Drop for AllocatedMutex {\n     #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let r = libc::pthread_mutex_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_mutex_destroy(self.0.get()) };\n+        if cfg!(target_os = \"dragonfly\") {\n+            // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n+            // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n+            // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n+            // this behaviour no longer occurs.\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n+}\n+\n+impl Mutex {\n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        libc::pthread_mutex_trylock(self.inner.get()) == 0\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: LazyBox::new() }\n     }\n+\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n+    pub unsafe fn lock(&self) {\n+        let r = libc::pthread_mutex_lock(raw(self));\n         debug_assert_eq!(r, 0);\n     }\n+\n     #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n-        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n-        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n-        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n-        // this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n+    pub unsafe fn unlock(&self) {\n+        let r = libc::pthread_mutex_unlock(raw(self));\n+        debug_assert_eq!(r, 0);\n     }\n-}\n \n-impl Drop for Mutex {\n     #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n+    pub unsafe fn try_lock(&self) -> bool {\n+        libc::pthread_mutex_trylock(raw(self)) == 0\n     }\n }\n "}, {"sha": "04662be9d8275e514d61cf7126e17bfdda1a9b20", "filename": "library/std/src/sys/unix/locks/pthread_rwlock.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,20 +3,26 @@ use crate::mem::forget;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n-pub struct RwLock {\n+struct AllocatedRwLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n     write_locked: UnsafeCell<bool>, // guarded by the `inner` RwLock\n     num_readers: AtomicUsize,\n }\n \n-pub(crate) type MovableRwLock = LazyBox<RwLock>;\n+unsafe impl Send for AllocatedRwLock {}\n+unsafe impl Sync for AllocatedRwLock {}\n \n-unsafe impl Send for RwLock {}\n-unsafe impl Sync for RwLock {}\n+pub struct RwLock {\n+    inner: LazyBox<AllocatedRwLock>,\n+}\n \n-impl LazyInit for RwLock {\n+impl LazyInit for AllocatedRwLock {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedRwLock {\n+            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n+            write_locked: UnsafeCell::new(false),\n+            num_readers: AtomicUsize::new(0),\n+        })\n     }\n \n     fn destroy(mut rwlock: Box<Self>) {\n@@ -35,17 +41,39 @@ impl LazyInit for RwLock {\n     }\n }\n \n+impl AllocatedRwLock {\n+    #[inline]\n+    unsafe fn raw_unlock(&self) {\n+        let r = libc::pthread_rwlock_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}\n+\n+impl Drop for AllocatedRwLock {\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_rwlock_destroy(self.inner.get()) };\n+        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n+        // rwlock that was just initialized with\n+        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n+        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n+        if cfg!(target_os = \"dragonfly\") {\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n+    }\n+}\n+\n impl RwLock {\n+    #[inline]\n     pub const fn new() -> RwLock {\n-        RwLock {\n-            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n-            write_locked: UnsafeCell::new(false),\n-            num_readers: AtomicUsize::new(0),\n-        }\n+        RwLock { inner: LazyBox::new() }\n     }\n+\n     #[inline]\n-    pub unsafe fn read(&self) {\n-        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n+    pub fn read(&self) {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_rdlock(lock.inner.get()) };\n \n         // According to POSIX, when a thread tries to acquire this read lock\n         // while it already holds the write lock\n@@ -62,112 +90,106 @@ impl RwLock {\n         // got the write lock more than once, or got a read and a write lock.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n-        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n+        } else if r == libc::EDEADLK || (r == 0 && unsafe { *lock.write_locked.get() }) {\n             // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n             // data races.\n             if r == 0 {\n                 // `pthread_rwlock_rdlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             // POSIX does not make guarantees about all the errors that may be returned.\n             // See issue #94705 for more details.\n             assert_eq!(r, 0, \"unexpected error during rwlock read lock: {:?}\", r);\n-            self.num_readers.fetch_add(1, Ordering::Relaxed);\n+            lock.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n+\n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n+    pub fn try_read(&self) -> bool {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_tryrdlock(lock.inner.get()) };\n         if r == 0 {\n-            if *self.write_locked.get() {\n+            if unsafe { *lock.write_locked.get() } {\n                 // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n                 false\n             } else {\n-                self.num_readers.fetch_add(1, Ordering::Relaxed);\n+                lock.num_readers.fetch_add(1, Ordering::Relaxed);\n                 true\n             }\n         } else {\n             false\n         }\n     }\n+\n     #[inline]\n-    pub unsafe fn write(&self) {\n-        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n+    pub fn write(&self) {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_wrlock(lock.inner.get()) };\n         // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n         // we also need to check that there are no readers (tracked in `num_readers`).\n         if r == libc::EDEADLK\n-            || (r == 0 && *self.write_locked.get())\n-            || self.num_readers.load(Ordering::Relaxed) != 0\n+            || (r == 0 && unsafe { *lock.write_locked.get() })\n+            || lock.num_readers.load(Ordering::Relaxed) != 0\n         {\n             // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n             // data races.\n             if r == 0 {\n                 // `pthread_rwlock_wrlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n             }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             // According to POSIX, for a properly initialized rwlock this can only\n             // return EDEADLK or 0. We rely on that.\n             debug_assert_eq!(r, 0);\n         }\n-        *self.write_locked.get() = true;\n+\n+        unsafe {\n+            *lock.write_locked.get() = true;\n+        }\n     }\n+\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n+        let lock = &*self.inner;\n+        let r = libc::pthread_rwlock_trywrlock(lock.inner.get());\n         if r == 0 {\n-            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+            if *lock.write_locked.get() || lock.num_readers.load(Ordering::Relaxed) != 0 {\n                 // `pthread_rwlock_trywrlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                lock.raw_unlock();\n                 false\n             } else {\n-                *self.write_locked.get() = true;\n+                *lock.write_locked.get() = true;\n                 true\n             }\n         } else {\n             false\n         }\n     }\n-    #[inline]\n-    unsafe fn raw_unlock(&self) {\n-        let r = libc::pthread_rwlock_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n+\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        debug_assert!(!*self.write_locked.get());\n-        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n-        self.raw_unlock();\n-    }\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n-        debug_assert!(*self.write_locked.get());\n-        *self.write_locked.get() = false;\n-        self.raw_unlock();\n+        let lock = &*self.inner;\n+        debug_assert!(!*lock.write_locked.get());\n+        lock.num_readers.fetch_sub(1, Ordering::Relaxed);\n+        lock.raw_unlock();\n     }\n-    #[inline]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_rwlock_destroy(self.inner.get());\n-        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n-        // rwlock that was just initialized with\n-        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n-        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n-        if cfg!(target_os = \"dragonfly\") {\n-            debug_assert!(r == 0 || r == libc::EINVAL);\n-        } else {\n-            debug_assert_eq!(r, 0);\n-        }\n-    }\n-}\n \n-impl Drop for RwLock {\n     #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n+    pub unsafe fn write_unlock(&self) {\n+        let lock = &*self.inner;\n+        debug_assert_eq!(lock.num_readers.load(Ordering::Relaxed), 0);\n+        debug_assert!(*lock.write_locked.get());\n+        *lock.write_locked.get() = false;\n+        lock.raw_unlock();\n     }\n }"}, {"sha": "3f0943b50ee4d98160947d7f85baa6f9a449c73f", "filename": "library/std/src/sys/unsupported/locks/condvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -3,8 +3,6 @@ use crate::time::Duration;\n \n pub struct Condvar {}\n \n-pub type MovableCondvar = Condvar;\n-\n impl Condvar {\n     #[inline]\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n@@ -13,10 +11,10 @@ impl Condvar {\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {}\n+    pub fn notify_one(&self) {}\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {}\n+    pub fn notify_all(&self) {}\n \n     pub unsafe fn wait(&self, _mutex: &Mutex) {\n         panic!(\"condvar wait not supported\")"}, {"sha": "0e0f9eccb213704b10f8766eaa434c1b82d49eb5", "filename": "library/std/src/sys/unsupported/locks/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -1,6 +1,6 @@\n mod condvar;\n mod mutex;\n mod rwlock;\n-pub use condvar::{Condvar, MovableCondvar};\n-pub use mutex::{MovableMutex, Mutex};\n-pub use rwlock::MovableRwLock;\n+pub use condvar::Condvar;\n+pub use mutex::Mutex;\n+pub use rwlock::RwLock;"}, {"sha": "4a13c55fb8bec01e47ec413bbc2f1f8af97ddbd9", "filename": "library/std/src/sys/unsupported/locks/mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -5,8 +5,6 @@ pub struct Mutex {\n     locked: Cell<bool>,\n }\n \n-pub type MovableMutex = Mutex;\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {} // no threads on this platform\n \n@@ -18,7 +16,7 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         assert_eq!(self.locked.replace(true), false, \"cannot recursively acquire mutex\");\n     }\n \n@@ -28,7 +26,7 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         self.locked.replace(true) == false\n     }\n }"}, {"sha": "789ef9b29e52a3dc55a9c809dfc294db78530c32", "filename": "library/std/src/sys/unsupported/locks/rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -5,8 +5,6 @@ pub struct RwLock {\n     mode: Cell<isize>,\n }\n \n-pub type MovableRwLock = RwLock;\n-\n unsafe impl Send for RwLock {}\n unsafe impl Sync for RwLock {} // no threads on this platform\n \n@@ -18,7 +16,7 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let m = self.mode.get();\n         if m >= 0 {\n             self.mode.set(m + 1);\n@@ -28,7 +26,7 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         let m = self.mode.get();\n         if m >= 0 {\n             self.mode.set(m + 1);\n@@ -39,14 +37,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         if self.mode.replace(-1) != 0 {\n             rtabort!(\"rwlock locked for reading\")\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         if self.mode.get() == 0 {\n             self.mode.set(-1);\n             true"}, {"sha": "d68c3e5f1dfbfaf281d0139c40bc2d337672b661", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6649aafc65f6feb96414767395a498707118496/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=c6649aafc65f6feb96414767395a498707118496", "patch": "@@ -55,9 +55,9 @@ cfg_if::cfg_if! {\n             mod futex_condvar;\n             mod futex_mutex;\n             mod futex_rwlock;\n-            pub(crate) use futex_condvar::{Condvar, MovableCondvar};\n-            pub(crate) use futex_mutex::{Mutex, MovableMutex};\n-            pub(crate) use futex_rwlock::MovableRwLock;\n+            pub(crate) use futex_condvar::Condvar;\n+            pub(crate) use futex_mutex::Mutex;\n+            pub(crate) use futex_rwlock::RwLock;\n         }\n         #[path = \"atomics/futex.rs\"]\n         pub mod futex;"}]}