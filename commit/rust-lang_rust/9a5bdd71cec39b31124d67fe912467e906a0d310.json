{"sha": "9a5bdd71cec39b31124d67fe912467e906a0d310", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNWJkZDcxY2VjMzliMzExMjRkNjdmZTkxMjQ2N2U5MDZhMGQzMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T17:40:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T17:40:21Z"}, "message": "auto merge of #7202 : pcwalton/rust/resolve-speed, r=pcwalton\n\nI'm pretty sure this got adequately reviewed by a combination of @nikomatsakis and @graydon so I'm rubber stamping it because I really want this in (it makes it much less likely for me to swap, allowing me to get more work done).", "tree": {"sha": "f568146420649632efa1de3c82ed77c67e8d98d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f568146420649632efa1de3c82ed77c67e8d98d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a5bdd71cec39b31124d67fe912467e906a0d310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5bdd71cec39b31124d67fe912467e906a0d310", "html_url": "https://github.com/rust-lang/rust/commit/9a5bdd71cec39b31124d67fe912467e906a0d310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a5bdd71cec39b31124d67fe912467e906a0d310/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17eec6289be4a5b9f940c7381f087fb0ea2efd22", "url": "https://api.github.com/repos/rust-lang/rust/commits/17eec6289be4a5b9f940c7381f087fb0ea2efd22", "html_url": "https://github.com/rust-lang/rust/commit/17eec6289be4a5b9f940c7381f087fb0ea2efd22"}, {"sha": "6914ff9d0142a4b1e82f809ebb8de805d8319698", "url": "https://api.github.com/repos/rust-lang/rust/commits/6914ff9d0142a4b1e82f809ebb8de805d8319698", "html_url": "https://github.com/rust-lang/rust/commit/6914ff9d0142a4b1e82f809ebb8de805d8319698"}], "stats": {"total": 99, "additions": 75, "deletions": 24}, "files": [{"sha": "be87beba7784b25213d98f46f86c6d761fe81bdb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=9a5bdd71cec39b31124d67fe912467e906a0d310", "patch": "@@ -82,7 +82,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        for self.dfcx_loans.each_bit_on_entry(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             if !op(loan) {\n                 return false;\n@@ -134,7 +134,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        for self.dfcx_loans.each_gen_bit(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n             result.push(loan_index);\n         }\n         return result;"}, {"sha": "d19afd0f5fc982de76a834f3a9ba9fccc378870b", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=9a5bdd71cec39b31124d67fe912467e906a0d310", "patch": "@@ -504,7 +504,7 @@ impl FlowedMoveData {\n \n         let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n \n-        for self.dfcx_moves.each_bit_on_entry(id) |index| {\n+        for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             if base_indices.contains(&moved_path) {\n@@ -560,7 +560,7 @@ impl FlowedMoveData {\n             }\n         };\n \n-        for self.dfcx_assign.each_bit_on_entry(id) |index| {\n+        for self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n             let assignment = &self.move_data.var_assignments[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 return false;"}, {"sha": "8403b1616f41e72648152f3c3fbc46bcd56eff23", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5bdd71cec39b31124d67fe912467e906a0d310/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9a5bdd71cec39b31124d67fe912467e906a0d310", "patch": "@@ -22,6 +22,7 @@ use core::cast;\n use core::io;\n use core::uint;\n use core::vec;\n+use core::hashmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::id_range;\n@@ -37,16 +38,16 @@ pub struct DataFlowContext<O> {\n     /// the data flow operator\n     priv oper: O,\n \n-    /// range of ids that appear within the item in question\n-    priv id_range: id_range,\n-\n     /// number of bits to propagate per id\n     priv bits_per_id: uint,\n \n     /// number of words we will use to store bits_per_id.\n     /// equal to bits_per_id/uint::bits rounded up.\n     priv words_per_id: uint,\n \n+    // mapping from node to bitset index.\n+    priv nodeid_to_bitset: HashMap<ast::node_id,uint>,\n+\n     // Bit sets per id.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n     // `id_range`, there is a range of words equal to `words_per_id`.\n@@ -108,19 +109,17 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n                id_range, bits_per_id, words_per_id);\n \n-        let len = (id_range.max - id_range.min) as uint * words_per_id;\n-        let gens = vec::from_elem(len, 0);\n-        let kills = vec::from_elem(len, 0);\n-        let elem = if oper.initial_value() {uint::max_value} else {0};\n-        let on_entry = vec::from_elem(len, elem);\n+        let gens = ~[];\n+        let kills = ~[];\n+        let on_entry = ~[];\n \n         DataFlowContext {\n             tcx: tcx,\n             method_map: method_map,\n             words_per_id: words_per_id,\n+            nodeid_to_bitset: HashMap::new(),\n             bits_per_id: bits_per_id,\n             oper: oper,\n-            id_range: id_range,\n             gens: gens,\n             kills: kills,\n             on_entry: on_entry\n@@ -149,7 +148,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n     }\n \n-    fn apply_gen_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_gen_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n         debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n@@ -164,7 +163,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn apply_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n         debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n@@ -174,18 +173,56 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn compute_id_range(&self, absolute_id: ast::node_id) -> (uint, uint) {\n-        assert!(absolute_id >= self.id_range.min);\n-        assert!(absolute_id < self.id_range.max);\n+    fn compute_id_range_frozen(&self, id: ast::node_id) -> (uint, uint) {\n+        let n = *self.nodeid_to_bitset.get(&id);\n+        let start = n * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        (start, end)\n+    }\n \n-        let relative_id = absolute_id - self.id_range.min;\n-        let start = (relative_id as uint) * self.words_per_id;\n+    fn compute_id_range(&mut self, id: ast::node_id) -> (uint, uint) {\n+        let mut expanded = false;\n+        let len = self.nodeid_to_bitset.len();\n+        let n = do self.nodeid_to_bitset.find_or_insert_with(id) |_| {\n+            expanded = true;\n+            len\n+        };\n+        if expanded {\n+            let entry = if self.oper.initial_value() { uint::max_value } else {0};\n+            for self.words_per_id.times {\n+                self.gens.push(0);\n+                self.kills.push(0);\n+                self.on_entry.push(entry);\n+            }\n+        }\n+        let start = *n * self.words_per_id;\n         let end = start + self.words_per_id;\n+\n+        assert!(start < self.gens.len());\n+        assert!(end <= self.gens.len());\n+        assert!(self.gens.len() == self.kills.len());\n+        assert!(self.gens.len() == self.on_entry.len());\n+\n         (start, end)\n     }\n \n \n-    pub fn each_bit_on_entry(&self,\n+    pub fn each_bit_on_entry_frozen(&self,\n+                                    id: ast::node_id,\n+                                    f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+        if !self.nodeid_to_bitset.contains_key(&id) {\n+            return true;\n+        }\n+        let (start, end) = self.compute_id_range_frozen(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f)\n+    }\n+\n+    pub fn each_bit_on_entry(&mut self,\n                              id: ast::node_id,\n                              f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n@@ -198,7 +235,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    pub fn each_gen_bit(&self,\n+    pub fn each_gen_bit(&mut self,\n                         id: ast::node_id,\n                         f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n@@ -210,6 +247,20 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n+    pub fn each_gen_bit_frozen(&self,\n+                               id: ast::node_id,\n+                               f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit in the gen set for `id`.\n+        if !self.nodeid_to_bitset.contains_key(&id) {\n+            return true;\n+        }\n+        let (start, end) = self.compute_id_range_frozen(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n     fn each_bit(&self,\n                 words: &[uint],\n                 f: &fn(uint) -> bool) -> bool {\n@@ -285,8 +336,8 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n                 pprust::node_pat(ps, pat) => (ps, pat.id)\n             };\n \n-            if id >= self.id_range.min || id < self.id_range.max {\n-                let (start, end) = self.compute_id_range(id);\n+            if self.nodeid_to_bitset.contains_key(&id) {\n+                let (start, end) = self.compute_id_range_frozen(id);\n                 let on_entry = vec::slice(self.on_entry, start, end);\n                 let entry_str = bits_to_str(on_entry);\n "}]}