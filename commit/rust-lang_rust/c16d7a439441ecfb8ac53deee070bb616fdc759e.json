{"sha": "c16d7a439441ecfb8ac53deee070bb616fdc759e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNmQ3YTQzOTQ0MWVjZmI4YWM1M2RlZWUwNzBiYjYxNmZkYzc1OWU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-09-26T06:19:30Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:11Z"}, "message": "path2: Rename Path::new() to Path::from_vec()", "tree": {"sha": "a860c838e4a93054dedbda1156c7c9e0afb2f19c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a860c838e4a93054dedbda1156c7c9e0afb2f19c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c16d7a439441ecfb8ac53deee070bb616fdc759e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c16d7a439441ecfb8ac53deee070bb616fdc759e", "html_url": "https://github.com/rust-lang/rust/commit/c16d7a439441ecfb8ac53deee070bb616fdc759e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c16d7a439441ecfb8ac53deee070bb616fdc759e/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f25835c2210295bed25096807eed201e4d3b206e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f25835c2210295bed25096807eed201e4d3b206e", "html_url": "https://github.com/rust-lang/rust/commit/f25835c2210295bed25096807eed201e4d3b206e"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "66b4a6fb32672a696aa83d721c4108053f039bd3", "filename": "src/libstd/path2/posix.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c16d7a439441ecfb8ac53deee070bb616fdc759e/src%2Flibstd%2Fpath2%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16d7a439441ecfb8ac53deee070bb616fdc759e/src%2Flibstd%2Fpath2%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fposix.rs?ref=c16d7a439441ecfb8ac53deee070bb616fdc759e", "patch": "@@ -271,7 +271,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&sep)))\n+            Some(Path::from_vec(comps.connect_vec(&sep)))\n         }\n     }\n }\n@@ -283,7 +283,7 @@ impl Path {\n     ///\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     #[inline]\n-    pub fn new(v: &[u8]) -> Path {\n+    pub fn from_vec(v: &[u8]) -> Path {\n         GenericPath::from_vec(v)\n     }\n \n@@ -433,12 +433,12 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        t!(v: Path::new([]), b!(\".\"));\n-        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n-        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = Path::new(b!(\"a/b/c\", 0xff));\n+        t!(v: Path::from_vec([]), b!(\".\"));\n+        t!(v: Path::from_vec(b!(\"/\")), b!(\"/\"));\n+        t!(v: Path::from_vec(b!(\"a/b/c\")), b!(\"a/b/c\"));\n+        t!(v: Path::from_vec(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n+        t!(v: Path::from_vec(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n+        let p = Path::from_vec(b!(\"a/b/c\", 0xff));\n         assert_eq!(p.as_str(), None);\n \n         t!(s: Path::from_str(\"\"), \".\");\n@@ -464,15 +464,15 @@ mod tests {\n         t!(s: Path::from_str(\"foo/../../..\"), \"../..\");\n         t!(s: Path::from_str(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n-        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec(),\n+        assert_eq!(Path::from_vec(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n+        assert_eq!(Path::from_vec(b!(\"/foo/../../bar\")).into_vec(),\n                    b!(\"/bar\").to_owned());\n         assert_eq!(Path::from_str(\"foo/bar\").into_str(), Some(~\"foo/bar\"));\n         assert_eq!(Path::from_str(\"/foo/../../bar\").into_str(), Some(~\"/bar\"));\n \n-        let p = Path::new(b!(\"foo/bar\", 0x80));\n+        let p = Path::from_vec(b!(\"foo/bar\", 0x80));\n         assert_eq!(p.as_str(), None);\n-        assert_eq!(Path::new(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n+        assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n     }\n \n     #[test]\n@@ -485,7 +485,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n             (b!(\"/bar\").to_owned())\n         }).inside {\n-            Path::new(b!(\"foo/bar\", 0))\n+            Path::from_vec(b!(\"foo/bar\", 0))\n         };\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/bar\"));\n@@ -541,16 +541,16 @@ mod tests {\n             )\n         )\n \n-        t!(~\"new() w/nul\" => {\n+        t!(~\"from_vec() w/nul\" => {\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n-                Path::new(b!(\"foo/bar\", 0))\n+                Path::from_vec(b!(\"foo/bar\", 0))\n             };\n         })\n \n         t!(~\"set_filename w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n+            let mut p = Path::from_vec(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -559,7 +559,7 @@ mod tests {\n         })\n \n         t!(~\"set_dirname w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n+            let mut p = Path::from_vec(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -568,7 +568,7 @@ mod tests {\n         })\n \n         t!(~\"push w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n+            let mut p = Path::from_vec(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -595,7 +595,7 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n+                    let path = Path::from_vec($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             )\n@@ -715,15 +715,15 @@ mod tests {\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::from_vec(b!($($path),+));\n                     let file = p.pop_opt();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::from_vec(b!($($path),+));\n                     let file = p.pop_opt();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n@@ -746,15 +746,15 @@ mod tests {\n         t!(s: \"/a\", \"/\", Some(\"a\"));\n         t!(s: \"/\", \"/\", None);\n \n-        assert_eq!(Path::new(b!(\"foo/bar\", 0x80)).pop_opt_str(), None);\n-        assert_eq!(Path::new(b!(\"foo\", 0x80, \"/bar\")).pop_opt_str(), Some(~\"bar\"));\n+        assert_eq!(Path::from_vec(b!(\"foo/bar\", 0x80)).pop_opt_str(), None);\n+        assert_eq!(Path::from_vec(b!(\"foo\", 0x80, \"/bar\")).pop_opt_str(), Some(~\"bar\"));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(v: Path::from_vec(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n+        t!(v: Path::from_vec(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n+        t!(v: Path::from_vec(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n         t!(s: Path::from_str(\"a/b/c\").join_str(\"..\"), \"a/b\");\n         t!(s: Path::from_str(\"/a/b/c\").join_str(\"d\"), \"/a/b/c/d\");\n         t!(s: Path::from_str(\"a/b\").join_str(\"c/d\"), \"a/b/c/d\");\n@@ -786,10 +786,10 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n-        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n-        t!(v: Path::new(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n-        t!(v: Path::new(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n+        t!(v: Path::from_vec(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n+        t!(v: Path::from_vec(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n+        t!(v: Path::from_vec(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n+        t!(v: Path::from_vec(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n               b!(\"/\", 0xcd, \"/\", 0x80));\n         t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d\"), \"d/c\");\n         t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d/e\"), \"d/e/c\");\n@@ -807,9 +807,9 @@ mod tests {\n         t!(s: Path::from_str(\"foo\").with_dirname_str(\"..\"), \"../foo\");\n         t!(s: Path::from_str(\"foo\").with_dirname_str(\"../..\"), \"../../foo\");\n \n-        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n+        t!(v: Path::from_vec(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n+        t!(v: Path::from_vec(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n+        t!(v: Path::from_vec(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n               b!(\"/\", 0xff, \"/\", 0xcd));\n         t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"d\"), \"a/b/d\");\n         t!(s: Path::from_str(\".\").with_filename_str(\"foo\"), \"foo\");\n@@ -831,12 +831,12 @@ mod tests {\n         t!(s: Path::from_str(\"..\").with_filename_str(\"\"), \"..\");\n         t!(s: Path::from_str(\"../..\").with_filename_str(\"\"), \"../..\");\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n               b!(\"hi/\", 0xff, \".txt\"));\n-        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n+        t!(v: Path::from_vec(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n               b!(\"hi/\", 0xff, \".txt\", 0x80));\n-        t!(v: Path::new(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n-        t!(v: Path::new(b!(\"hi\", 0x80, \"/there\")).with_filestem([]), b!(\"hi\", 0x80));\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n+        t!(v: Path::from_vec(b!(\"hi\", 0x80, \"/there\")).with_filestem([]), b!(\"hi\", 0x80));\n         t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n         t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"\"), \"hi/.txt\");\n         t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\".\"), \"hi/..txt\");\n@@ -859,13 +859,13 @@ mod tests {\n         t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"here\"), \"hi/here.\");\n         t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"\"), \"hi\");\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n               b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::from_vec(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there.\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension([]), b!(\"hi/there\"));\n+        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)).with_extension([]), b!(\"hi/there\"));\n         t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"exe\"), \"hi/there.exe\");\n         t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"\"), \"hi/there\");\n         t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\".\"), \"hi/there..\");\n@@ -899,9 +899,9 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::new(path);\n+                    let mut p1 = Path::from_vec(path);\n                     p1.$set(arg);\n-                    let p2 = Path::new(path);\n+                    let p2 = Path::from_vec(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n@@ -968,9 +968,9 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a/b/c\")), b!(\"c\"), b!(\"a/b\"), b!(\"c\"), None);\n-        t!(v: Path::new(b!(\"a/b/\", 0xff)), b!(0xff), b!(\"a/b\"), b!(0xff), None);\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)), b!(\"there.\", 0xff), b!(\"hi\"),\n+        t!(v: Path::from_vec(b!(\"a/b/c\")), b!(\"c\"), b!(\"a/b\"), b!(\"c\"), None);\n+        t!(v: Path::from_vec(b!(\"a/b/\", 0xff)), b!(0xff), b!(\"a/b\"), b!(0xff), None);\n+        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)), b!(\"there.\", 0xff), b!(\"hi\"),\n               b!(\"there\"), Some(b!(0xff)));\n         t!(s: Path::from_str(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n         t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n@@ -985,16 +985,16 @@ mod tests {\n         t!(s: Path::from_str(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::from_str(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::from_vec(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::from_vec(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::from_vec(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::from_vec(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_file_path() {\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n+        t!(v: Path::from_vec(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n         t!(s: Path::from_str(\"hi/there\").dir_path(), \"hi\");\n         t!(s: Path::from_str(\"hi\").dir_path(), \".\");\n         t!(s: Path::from_str(\"/hi\").dir_path(), \"/\");\n@@ -1019,8 +1019,8 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n-        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n+        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n+        t!(v: Path::from_vec(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n         t!(s: Path::from_str(\"hi/there\").file_path(), Some(\"there\"));\n         t!(s: Path::from_str(\"hi\").file_path(), Some(\"hi\"));\n         t!(s: Path::from_str(\".\").file_path(), None);\n@@ -1134,7 +1134,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::from_vec(b!($($arg),+));\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n                     assert_eq!(comps.as_slice(), exp);"}, {"sha": "e4c194ba6caea233cec57ea82704fe0cdf68c427", "filename": "src/libstd/path2/windows.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c16d7a439441ecfb8ac53deee070bb616fdc759e/src%2Flibstd%2Fpath2%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16d7a439441ecfb8ac53deee070bb616fdc759e/src%2Flibstd%2Fpath2%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fwindows.rs?ref=c16d7a439441ecfb8ac53deee070bb616fdc759e", "patch": "@@ -579,7 +579,7 @@ impl Path {\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     /// Raises the `str::not_utf8` condition if invalid UTF-8.\n     #[inline]\n-    pub fn new(v: &[u8]) -> Path {\n+    pub fn from_vec(v: &[u8]) -> Path {\n         GenericPath::from_vec(v)\n     }\n \n@@ -1112,9 +1112,9 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        t!(v: Path::new([]), b!(\".\"));\n-        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+        t!(v: Path::from_vec([]), b!(\".\"));\n+        t!(v: Path::from_vec(b!(\"\\\\\")), b!(\"\\\\\"));\n+        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n \n         t!(s: Path::from_str(\"\"), \".\");\n         t!(s: Path::from_str(\"\\\\\"), \"\\\\\");\n@@ -1146,8 +1146,8 @@ mod tests {\n         t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n-        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n+        assert_eq!(Path::from_vec(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n+        assert_eq!(Path::from_vec(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n                    b!(\"\\\\bar\").to_owned());\n         assert_eq!(Path::from_str(\"foo\\\\bar\").into_str(), Some(~\"foo\\\\bar\"));\n         assert_eq!(Path::from_str(\"\\\\foo\\\\..\\\\..\\\\bar\").into_str(), Some(~\"\\\\bar\"));\n@@ -1211,7 +1211,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n             (b!(\"\\\\bar\").to_owned())\n         }).inside {\n-            Path::new(b!(\"foo\\\\bar\", 0))\n+            Path::from_vec(b!(\"foo\\\\bar\", 0))\n         };\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n@@ -1267,16 +1267,16 @@ mod tests {\n             )\n         )\n \n-        t!(~\"new() w\\\\nul\" => {\n+        t!(~\"from_vec() w\\\\nul\" => {\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n-                Path::new(b!(\"foo\\\\bar\", 0))\n+                Path::from_vec(b!(\"foo\\\\bar\", 0))\n             };\n         })\n \n         t!(~\"set_filename w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1285,7 +1285,7 @@ mod tests {\n         })\n \n         t!(~\"set_dirname w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1294,7 +1294,7 @@ mod tests {\n         })\n \n         t!(~\"push w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1306,7 +1306,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_not_utf8_fail() {\n-        Path::new(b!(\"hello\", 0x80, \".txt\"));\n+        Path::from_vec(b!(\"hello\", 0x80, \".txt\"));\n     }\n \n     #[test]\n@@ -1327,7 +1327,7 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n+                    let path = Path::from_vec($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             )\n@@ -1534,15 +1534,15 @@ mod tests {\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::from_vec(b!($($path),+));\n                     let file = p.pop_opt();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::from_vec(b!($($path),+));\n                     let file = p.pop_opt();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n@@ -1594,8 +1594,8 @@ mod tests {\n         t!(s: Path::from_str(\"a\\\\b\").join_str(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n         t!(s: Path::from_str(\".\").join_str(\"a\\\\b\"), \"a\\\\b\");\n         t!(s: Path::from_str(\"\\\\\").join_str(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n-        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n+        t!(v: Path::from_vec(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1790,9 +1790,9 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::new(path);\n+                    let mut p1 = Path::from_vec(path);\n                     p1.$set(arg);\n-                    let p2 = Path::new(path);\n+                    let p2 = Path::from_vec(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n@@ -1858,7 +1858,7 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"c\"), b!(\"a\\\\b\"), b!(\"c\"), None);\n+        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), b!(\"c\"), b!(\"a\\\\b\"), b!(\"c\"), None);\n         t!(s: Path::from_str(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n         t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n         t!(s: Path::from_str(\"\\\\\"), Some(\"\"), Some(\"\\\\\"), Some(\"\"), None);\n@@ -2193,7 +2193,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::from_vec(b!($($arg),+));\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert_eq!(comps.as_slice(), exp);"}]}