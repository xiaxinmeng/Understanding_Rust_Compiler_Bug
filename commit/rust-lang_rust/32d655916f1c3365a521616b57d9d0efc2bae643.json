{"sha": "32d655916f1c3365a521616b57d9d0efc2bae643", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZDY1NTkxNmYxYzMzNjVhNTIxNjE2YjU3ZDlkMGVmYzJiYWU2NDM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T14:40:47Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T14:40:47Z"}, "message": "Convert vec::{reserve, reserve_at_least, capacity} to methods.", "tree": {"sha": "b993301c462300e714f0d905ea8a8ada9e5676aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b993301c462300e714f0d905ea8a8ada9e5676aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32d655916f1c3365a521616b57d9d0efc2bae643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32d655916f1c3365a521616b57d9d0efc2bae643", "html_url": "https://github.com/rust-lang/rust/commit/32d655916f1c3365a521616b57d9d0efc2bae643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32d655916f1c3365a521616b57d9d0efc2bae643/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae2f1853491540b9e70be2209b235f6c920706a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2f1853491540b9e70be2209b235f6c920706a8", "html_url": "https://github.com/rust-lang/rust/commit/ae2f1853491540b9e70be2209b235f6c920706a8"}], "stats": {"total": 178, "additions": 88, "deletions": 90}, "files": [{"sha": "c70c87b6ea13b332e0482c52d0a8c4c14336486b", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -137,7 +137,7 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve(&mut self, n: uint) {\n-        vec::reserve(&mut self.elts, n);\n+        self.elts.reserve(n);\n     }\n \n     /// Reserve capacity for at least `n` elements in the given deque,\n@@ -151,7 +151,7 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.elts, n);\n+        self.elts.reserve_at_least(n);\n     }\n \n     /// Front-to-back iterator.\n@@ -256,7 +256,6 @@ mod tests {\n     use super::*;\n     use core::cmp::Eq;\n     use core::kinds::Copy;\n-    use core::vec::capacity;\n     use core;\n \n     #[test]\n@@ -442,23 +441,23 @@ mod tests {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n     fn test_reserve_at_least() {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n     }\n \n     #[test]"}, {"sha": "fbb4be0febb3d45f5953cbfde85180e93f6b0b6c", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -52,12 +52,12 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    pub fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    pub fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+    pub fn reserve(&mut self, n: uint) { self.data.reserve(n) }\n \n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.data, n)\n+        self.data.reserve_at_least(n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty"}, {"sha": "36920bd248879e3951eb45e9ad5ab37f9c8f87a3", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -1658,7 +1658,7 @@ impl Writer for BytesWriter {\n \n         let bytes = &mut *self.bytes;\n         let count = uint::max(bytes.len(), *self.pos + v_len);\n-        vec::reserve(bytes, count);\n+        bytes.reserve(count);\n \n         unsafe {\n             vec::raw::set_len(bytes, count);"}, {"sha": "1f82a9cd963356b82b8ddc630671654b6cb84628", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -292,7 +292,7 @@ impl<T: Reader> ReaderUtil for T {\n             let start_len = buf.len();\n             let mut total_read = 0;\n \n-            vec::reserve_at_least(buf, start_len + len);\n+            buf.reserve_at_least(start_len + len);\n             vec::raw::set_len(buf, start_len + len);\n \n             do (|| {"}, {"sha": "58cdc6631f0b54543d6c26d82e6ea745441dcfc6", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -2081,7 +2081,7 @@ impl OwnedStr for ~str {\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n             let v: *mut ~[u8] = cast::transmute(self);\n-            vec::reserve(&mut *v, n + 1);\n+            (*v).reserve(n + 1);\n         }\n     }\n \n@@ -2115,8 +2115,8 @@ impl OwnedStr for ~str {\n      * reallocating\n      */\n     fn capacity(&self) -> uint {\n-        let buf: &const ~[u8] = unsafe { cast::transmute(self) };\n-        let vcap = vec::capacity(buf);\n+        let buf: &~[u8] = unsafe { cast::transmute(self) };\n+        let vcap = buf.capacity();\n         assert!(vcap > 0u);\n         vcap - 1u\n     }"}, {"sha": "5dfea811c233197d88a46f675e33fdd5dcb98d20", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -68,63 +68,6 @@ pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n     xs.len() == ys.len()\n }\n \n-/**\n- * Reserves capacity for exactly `n` elements in the given vector.\n- *\n- * If the capacity for `v` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * v - A vector\n- * * n - The number of elements to reserve space for\n- */\n-#[inline]\n-pub fn reserve<T>(v: &mut ~[T], n: uint) {\n-    // Only make the (slow) call into the runtime if we have to\n-    use managed;\n-    if capacity(v) < n {\n-        unsafe {\n-            let ptr: **raw::VecRepr = cast::transmute(v);\n-            let td = get_tydesc::<T>();\n-            if ((**ptr).box_header.ref_count ==\n-                managed::raw::RC_MANAGED_UNIQUE) {\n-                rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n-            } else {\n-                rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Reserves capacity for at least `n` elements in the given vector.\n- *\n- * This function will over-allocate in order to amortize the allocation costs\n- * in scenarios where the caller may need to repeatedly reserve additional\n- * space.\n- *\n- * If the capacity for `v` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * v - A vector\n- * * n - The number of elements to reserve space for\n- */\n-pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n-    reserve(v, uint::next_power_of_two(n));\n-}\n-\n-/// Returns the number of elements the vector can hold without reallocating\n-#[inline]\n-pub fn capacity<T>(v: &const ~[T]) -> uint {\n-    unsafe {\n-        let repr: **raw::VecRepr = transmute(v);\n-        (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n-    }\n-}\n-\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -179,7 +122,7 @@ pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n /// Creates a new vector with a capacity of `capacity`\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n-    reserve(&mut vec, capacity);\n+    vec.reserve(capacity);\n     vec\n }\n \n@@ -466,7 +409,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  */\n pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     let new_len = v.len() + n;\n-    reserve_at_least(&mut *v, new_len);\n+    v.reserve_at_least(new_len);\n     let mut i: uint = 0u;\n \n     while i < n {\n@@ -490,7 +433,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  */\n pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: &fn(uint) -> T) {\n     let new_len = v.len() + n;\n-    reserve_at_least(&mut *v, new_len);\n+    v.reserve_at_least(new_len);\n     let mut i: uint = 0u;\n     while i < n {\n         v.push(op(i));\n@@ -1298,13 +1241,11 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n-        let mut result = ~[];\n-        reserve(&mut result, self.len());\n+        let mut result = with_capacity(self.len());\n         for self.iter().advance |e| {\n             result.push(copy *e);\n         }\n         result\n-\n     }\n }\n \n@@ -1555,6 +1496,10 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n+    fn reserve(&mut self, n: uint);\n+    fn reserve_at_least(&mut self, n: uint);\n+    fn capacity(&self) -> uint;\n+\n     fn push(&mut self, t: T);\n     unsafe fn push_fast(&mut self, t: T);\n \n@@ -1575,6 +1520,61 @@ pub trait OwnedVector<T> {\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n+    /**\n+     * Reserves capacity for exactly `n` elements in the given vector.\n+     *\n+     * If the capacity for `self` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to reserve space for\n+     */\n+    #[inline]\n+    fn reserve(&mut self, n: uint) {\n+        // Only make the (slow) call into the runtime if we have to\n+        use managed;\n+        if self.capacity() < n {\n+            unsafe {\n+                let ptr: **raw::VecRepr = cast::transmute(self);\n+                let td = get_tydesc::<T>();\n+                if ((**ptr).box_header.ref_count ==\n+                    managed::raw::RC_MANAGED_UNIQUE) {\n+                    rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n+                } else {\n+                    rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reserves capacity for at least `n` elements in the given vector.\n+     *\n+     * This function will over-allocate in order to amortize the allocation costs\n+     * in scenarios where the caller may need to repeatedly reserve additional\n+     * space.\n+     *\n+     * If the capacity for `self` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to reserve space for\n+     */\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.reserve(uint::next_power_of_two(n));\n+    }\n+\n+    /// Returns the number of elements the vector can hold without reallocating.\n+    #[inline]\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            let repr: **raw::VecRepr = transmute(self);\n+            (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n+        }\n+    }\n+\n     /// Append an element to a vector\n     #[inline]\n     fn push(&mut self, t: T) {\n@@ -1595,7 +1595,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         #[inline(never)]\n         fn reserve_no_inline<T>(v: &mut ~[T]) {\n             let new_len = v.len() + 1;\n-            reserve_at_least(v, new_len);\n+            v.reserve_at_least(new_len);\n         }\n     }\n \n@@ -1625,7 +1625,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn push_all_move(&mut self, mut rhs: ~[T]) {\n         let new_len = self.len() + rhs.len();\n-        reserve(self, new_len);\n+        self.reserve(new_len);\n         unsafe {\n             do as_mut_buf(rhs) |p, len| {\n                 for uint::range(0, len) |i| {\n@@ -1672,7 +1672,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             // Save the last element. We're going to overwrite its position\n             let work_elt = self.pop();\n             // We still should have room to work where what last element was\n-            assert!(capacity(self) >= ln);\n+            assert!(self.capacity() >= ln);\n             // Pretend like we have the original length so we can use\n             // the vector copy_memory to overwrite the hole we just made\n             raw::set_len(self, ln);\n@@ -1859,7 +1859,7 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     #[inline]\n     fn push_all(&mut self, rhs: &const [T]) {\n         let new_len = self.len() + rhs.len();\n-        reserve(self, new_len);\n+        self.reserve(new_len);\n \n         for uint::range(0u, rhs.len()) |i| {\n             self.push(unsafe { raw::get(rhs, i) })\n@@ -3333,11 +3333,11 @@ mod tests {\n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n-        reserve(&mut v, 10u);\n-        assert_eq!(capacity(&v), 10u);\n+        v.reserve(10u);\n+        assert_eq!(v.capacity(), 10u);\n         let mut v = ~[0u32];\n-        reserve(&mut v, 10u);\n-        assert_eq!(capacity(&v), 10u);\n+        v.reserve(10u);\n+        assert_eq!(v.capacity(), 10u);\n     }\n \n     #[test]"}, {"sha": "e57dee06c75bdc33077eaacac78b3176a1bf271d", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d655916f1c3365a521616b57d9d0efc2bae643/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=32d655916f1c3365a521616b57d9d0efc2bae643", "patch": "@@ -5,7 +5,6 @@ use std::cast::transmute;\n use std::libc::{STDOUT_FILENO, c_int, fdopen, fgets, fopen, fputc, fwrite};\n use std::libc::{size_t};\n use std::ptr::null;\n-use std::vec::{capacity, reserve, reserve_at_least};\n use std::vec::raw::set_len;\n \n static LINE_LEN: u32 = 80;\n@@ -103,13 +102,13 @@ fn main() {\n         let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n \n         let mut out: ~[u8] = ~[];\n-        reserve(&mut out, 12777888);\n+        out.reserve(12777888);\n         let mut pos = 0;\n \n         loop {\n             let needed = pos + (LINE_LEN as uint) + 1;\n-            if capacity(&out) < needed {\n-                reserve_at_least(&mut out, needed);\n+            if out.capacity() < needed {\n+                out.reserve_at_least(needed);\n             }\n \n             let mut ptr = out.unsafe_mut_ref(pos);"}]}