{"sha": "1b4defd2409d6a6120b40a0730e9822a819e971d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNGRlZmQyNDA5ZDZhNjEyMGI0MGEwNzMwZTk4MjJhODE5ZTk3MWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-24T11:39:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-24T11:39:50Z"}, "message": "Merge #8647\n\n8647: internal: Split out merge_imports module from helpers::insert_use r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "558c6d18d829a5a0b954654df5b232772839c86f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/558c6d18d829a5a0b954654df5b232772839c86f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b4defd2409d6a6120b40a0730e9822a819e971d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJghAOGCRBK7hj4Ov3rIwAAuD8IAKHmgMR8TV923VbXrZMx8yi8\nBvEiy+Wf1SszL35QkHN8ikd3m7TMCSl9A6RB17FsX1ZS7APqBzJJIiAZgrU0AV51\nGSRXw4YiXTPsrOUB33VmX3XRGFMtjXX4dPBoJr8SocOuBApitGmD9qeAcdv1ra33\naXu8gb5yTN+agb8AFQUKcVvRRRQTGy8V3l1oio6PfUETuqeIvmEvqXWgs4suiACb\ndIoyJ8z4jDBMVUsWWXmrDUu8IgTJyifx/hPrdnFU88WZn3aJpgQBZEs5x9LEpbix\n0gYGv79pxiFS8rP25DTLAWv4F5v7WlsQMCLc4vPqQOGNRuYMoFcCn1Dgx730adc=\n=Nbqz\n-----END PGP SIGNATURE-----\n", "payload": "tree 558c6d18d829a5a0b954654df5b232772839c86f\nparent 4d110dd118e42a355ca8db41c7fdbf4371c45105\nparent 050c69c19dd8004c8dfc92dbff86a42fac022e6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1619264390 +0000\ncommitter GitHub <noreply@github.com> 1619264390 +0000\n\nMerge #8647\n\n8647: internal: Split out merge_imports module from helpers::insert_use r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b4defd2409d6a6120b40a0730e9822a819e971d", "html_url": "https://github.com/rust-lang/rust/commit/1b4defd2409d6a6120b40a0730e9822a819e971d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b4defd2409d6a6120b40a0730e9822a819e971d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d110dd118e42a355ca8db41c7fdbf4371c45105", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d110dd118e42a355ca8db41c7fdbf4371c45105", "html_url": "https://github.com/rust-lang/rust/commit/4d110dd118e42a355ca8db41c7fdbf4371c45105"}, {"sha": "050c69c19dd8004c8dfc92dbff86a42fac022e6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/050c69c19dd8004c8dfc92dbff86a42fac022e6e", "html_url": "https://github.com/rust-lang/rust/commit/050c69c19dd8004c8dfc92dbff86a42fac022e6e"}], "stats": {"total": 673, "additions": 344, "deletions": 329}, "files": [{"sha": "add7b8e37af059d8ec7438c15be4be1213172c1c", "filename": "crates/ide_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -1,4 +1,4 @@\n-use ide_db::helpers::insert_use::{try_merge_imports, try_merge_trees, MergeBehavior};\n+use ide_db::helpers::merge_imports::{try_merge_imports, try_merge_trees, MergeBehavior};\n use syntax::{algo::neighbor, ast, ted, AstNode};\n \n use crate::{"}, {"sha": "6f4f97361d7b0eae8f79e7b90db1e8ad3dc0a971", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -4,10 +4,7 @@ use expect_test::expect;\n use hir::Semantics;\n use ide_db::{\n     base_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt},\n-    helpers::{\n-        insert_use::{InsertUseConfig, MergeBehavior},\n-        SnippetCap,\n-    },\n+    helpers::{insert_use::InsertUseConfig, merge_imports::MergeBehavior, SnippetCap},\n     source_change::FileSystemEdit,\n     RootDatabase,\n };"}, {"sha": "c9857ec5ff49d32dae9e6e5c07a6ee216961dc08", "filename": "crates/ide_completion/src/test_utils.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -3,10 +3,7 @@\n use hir::{PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n-    helpers::{\n-        insert_use::{InsertUseConfig, MergeBehavior},\n-        SnippetCap,\n-    },\n+    helpers::{insert_use::InsertUseConfig, merge_imports::MergeBehavior, SnippetCap},\n     RootDatabase,\n };\n use itertools::Itertools;"}, {"sha": "21b48237ae7d1511893b1c6c3029f13159c4f6eb", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -1,6 +1,7 @@\n //! A module with ide helpers for high-level ide features.\n-pub mod insert_use;\n pub mod import_assets;\n+pub mod insert_use;\n+pub mod merge_imports;\n pub mod rust_doc;\n \n use std::collections::VecDeque;"}, {"sha": "55cdc4da3f0f31b75895b9c1e725c96135a3e358", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 7, "deletions": 317, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -1,15 +1,17 @@\n //! Handle syntactic aspects of inserting a new `use`.\n-use std::{cmp::Ordering, iter::successors};\n+use std::cmp::Ordering;\n \n use hir::Semantics;\n-use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n     algo,\n-    ast::{self, edit::AstNodeEdit, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner},\n+    ast::{self, make, AstNode, PathSegmentKind},\n     ted, AstToken, Direction, NodeOrToken, SyntaxNode, SyntaxToken,\n };\n \n-use crate::RootDatabase;\n+use crate::{\n+    helpers::merge_imports::{try_merge_imports, use_tree_path_cmp, MergeBehavior},\n+    RootDatabase,\n+};\n \n pub use hir::PrefixKind;\n \n@@ -85,318 +87,6 @@ pub fn insert_use<'a>(scope: &ImportScope, path: ast::Path, cfg: InsertUseConfig\n     insert_use_(scope, path, cfg.group, use_item);\n }\n \n-fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n-    match (vis0, vis1) {\n-        (None, None) => true,\n-        // FIXME: Don't use the string representation to check for equality\n-        // spaces inside of the node would break this comparison\n-        (Some(vis0), Some(vis1)) => vis0.to_string() == vis1.to_string(),\n-        _ => false,\n-    }\n-}\n-\n-fn eq_attrs(\n-    attrs0: impl Iterator<Item = ast::Attr>,\n-    attrs1: impl Iterator<Item = ast::Attr>,\n-) -> bool {\n-    let attrs0 = attrs0.map(|attr| attr.to_string());\n-    let attrs1 = attrs1.map(|attr| attr.to_string());\n-    attrs0.eq(attrs1)\n-}\n-\n-pub fn try_merge_imports(\n-    lhs: &ast::Use,\n-    rhs: &ast::Use,\n-    merge_behavior: MergeBehavior,\n-) -> Option<ast::Use> {\n-    // don't merge imports with different visibilities\n-    if !eq_visibility(lhs.visibility(), rhs.visibility()) {\n-        return None;\n-    }\n-    if !eq_attrs(lhs.attrs(), rhs.attrs()) {\n-        return None;\n-    }\n-\n-    let lhs_tree = lhs.use_tree()?;\n-    let rhs_tree = rhs.use_tree()?;\n-    let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behavior)?;\n-    Some(lhs.with_use_tree(merged).clone_for_update())\n-}\n-\n-pub fn try_merge_trees(\n-    lhs: &ast::UseTree,\n-    rhs: &ast::UseTree,\n-    merge: MergeBehavior,\n-) -> Option<ast::UseTree> {\n-    let lhs_path = lhs.path()?;\n-    let rhs_path = rhs.path()?;\n-\n-    let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-    let (lhs, rhs) = if is_simple_path(lhs)\n-        && is_simple_path(rhs)\n-        && lhs_path == lhs_prefix\n-        && rhs_path == rhs_prefix\n-    {\n-        (lhs.clone(), rhs.clone())\n-    } else {\n-        (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n-    };\n-    recursive_merge(&lhs, &rhs, merge)\n-}\n-\n-/// Recursively \"zips\" together lhs and rhs.\n-fn recursive_merge(\n-    lhs: &ast::UseTree,\n-    rhs: &ast::UseTree,\n-    merge: MergeBehavior,\n-) -> Option<ast::UseTree> {\n-    let mut use_trees = lhs\n-        .use_tree_list()\n-        .into_iter()\n-        .flat_map(|list| list.use_trees())\n-        // we use Option here to early return from this function(this is not the same as a `filter` op)\n-        .map(|tree| match merge.is_tree_allowed(&tree) {\n-            true => Some(tree),\n-            false => None,\n-        })\n-        .collect::<Option<Vec<_>>>()?;\n-    use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n-    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n-        if !merge.is_tree_allowed(&rhs_t) {\n-            return None;\n-        }\n-        let rhs_path = rhs_t.path();\n-        match use_trees.binary_search_by(|lhs_t| {\n-            let (lhs_t, rhs_t) = match lhs_t\n-                .path()\n-                .zip(rhs_path.clone())\n-                .and_then(|(lhs, rhs)| common_prefix(&lhs, &rhs))\n-            {\n-                Some((lhs_p, rhs_p)) => (lhs_t.split_prefix(&lhs_p), rhs_t.split_prefix(&rhs_p)),\n-                None => (lhs_t.clone(), rhs_t.clone()),\n-            };\n-\n-            path_cmp_bin_search(lhs_t.path(), rhs_t.path())\n-        }) {\n-            Ok(idx) => {\n-                let lhs_t = &mut use_trees[idx];\n-                let lhs_path = lhs_t.path()?;\n-                let rhs_path = rhs_path?;\n-                let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-                if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n-                    let tree_is_self = |tree: ast::UseTree| {\n-                        tree.path().as_ref().map(path_is_self).unwrap_or(false)\n-                    };\n-                    // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n-                    // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n-                    let tree_contains_self = |tree: &ast::UseTree| {\n-                        tree.use_tree_list()\n-                            .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n-                            .unwrap_or(false)\n-                    };\n-                    match (tree_contains_self(&lhs_t), tree_contains_self(&rhs_t)) {\n-                        (true, false) => continue,\n-                        (false, true) => {\n-                            *lhs_t = rhs_t;\n-                            continue;\n-                        }\n-                        _ => (),\n-                    }\n-\n-                    // glob imports arent part of the use-tree lists so we need to special handle them here as well\n-                    // this special handling is only required for when we merge a module import into a glob import of said module\n-                    // see the `merge_self_glob` or `merge_mod_into_glob` tests\n-                    if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n-                        *lhs_t = make::use_tree(\n-                            make::path_unqualified(make::path_segment_self()),\n-                            None,\n-                            None,\n-                            false,\n-                        );\n-                        use_trees.insert(idx, make::glob_use_tree());\n-                        continue;\n-                    }\n-\n-                    if lhs_t.use_tree_list().is_none() && rhs_t.use_tree_list().is_none() {\n-                        continue;\n-                    }\n-                }\n-                let lhs = lhs_t.split_prefix(&lhs_prefix);\n-                let rhs = rhs_t.split_prefix(&rhs_prefix);\n-                match recursive_merge(&lhs, &rhs, merge) {\n-                    Some(use_tree) => use_trees[idx] = use_tree,\n-                    None => return None,\n-                }\n-            }\n-            Err(_)\n-                if merge == MergeBehavior::Last\n-                    && use_trees.len() > 0\n-                    && rhs_t.use_tree_list().is_some() =>\n-            {\n-                return None\n-            }\n-            Err(idx) => {\n-                use_trees.insert(idx, rhs_t);\n-            }\n-        }\n-    }\n-\n-    Some(if let Some(old) = lhs.use_tree_list() {\n-        lhs.replace_descendant(old, make::use_tree_list(use_trees)).clone_for_update()\n-    } else {\n-        lhs.clone()\n-    })\n-}\n-\n-/// Traverses both paths until they differ, returning the common prefix of both.\n-fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {\n-    let mut res = None;\n-    let mut lhs_curr = first_path(&lhs);\n-    let mut rhs_curr = first_path(&rhs);\n-    loop {\n-        match (lhs_curr.segment(), rhs_curr.segment()) {\n-            (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n-            _ => break res,\n-        }\n-        res = Some((lhs_curr.clone(), rhs_curr.clone()));\n-\n-        match lhs_curr.parent_path().zip(rhs_curr.parent_path()) {\n-            Some((lhs, rhs)) => {\n-                lhs_curr = lhs;\n-                rhs_curr = rhs;\n-            }\n-            _ => break res,\n-        }\n-    }\n-}\n-\n-fn is_simple_path(use_tree: &ast::UseTree) -> bool {\n-    use_tree.use_tree_list().is_none() && use_tree.star_token().is_none()\n-}\n-\n-fn path_is_self(path: &ast::Path) -> bool {\n-    path.segment().and_then(|seg| seg.self_token()).is_some() && path.qualifier().is_none()\n-}\n-\n-#[inline]\n-fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n-    first_path(path).segment()\n-}\n-\n-fn first_path(path: &ast::Path) -> ast::Path {\n-    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n-}\n-\n-fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n-    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n-    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n-}\n-\n-fn path_len(path: ast::Path) -> usize {\n-    segment_iter(&path).count()\n-}\n-\n-/// Orders paths in the following way:\n-/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n-// FIXME: rustfmt sorts lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n-// which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n-// Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n-fn path_cmp_for_sort(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n-    match (a, b) {\n-        (None, None) => Ordering::Equal,\n-        (None, Some(_)) => Ordering::Less,\n-        (Some(_), None) => Ordering::Greater,\n-        (Some(ref a), Some(ref b)) => match (path_is_self(a), path_is_self(b)) {\n-            (true, true) => Ordering::Equal,\n-            (true, false) => Ordering::Less,\n-            (false, true) => Ordering::Greater,\n-            (false, false) => path_cmp_short(a, b),\n-        },\n-    }\n-}\n-\n-/// Path comparison func for binary searching for merging.\n-fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<ast::Path>) -> Ordering {\n-    match (lhs.as_ref().and_then(first_segment), rhs.as_ref().and_then(first_segment)) {\n-        (None, None) => Ordering::Equal,\n-        (None, Some(_)) => Ordering::Less,\n-        (Some(_), None) => Ordering::Greater,\n-        (Some(ref a), Some(ref b)) => path_segment_cmp(a, b),\n-    }\n-}\n-\n-/// Short circuiting comparison, if both paths are equal until one of them ends they are considered\n-/// equal\n-fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    let a = segment_iter(a);\n-    let b = segment_iter(b);\n-    // cmp_by would be useful for us here but that is currently unstable\n-    // cmp doesnt work due the lifetimes on text's return type\n-    a.zip(b)\n-        .find_map(|(a, b)| match path_segment_cmp(&a, &b) {\n-            Ordering::Equal => None,\n-            ord => Some(ord),\n-        })\n-        .unwrap_or(Ordering::Equal)\n-}\n-\n-/// Compares to paths, if one ends earlier than the other the has_tl parameters decide which is\n-/// greater as a a path that has a tree list should be greater, while one that just ends without\n-/// a tree list should be considered less.\n-fn use_tree_path_cmp(a: &ast::Path, a_has_tl: bool, b: &ast::Path, b_has_tl: bool) -> Ordering {\n-    let a_segments = segment_iter(a);\n-    let b_segments = segment_iter(b);\n-    // cmp_by would be useful for us here but that is currently unstable\n-    // cmp doesnt work due the lifetimes on text's return type\n-    a_segments\n-        .zip_longest(b_segments)\n-        .find_map(|zipped| match zipped {\n-            EitherOrBoth::Both(ref a, ref b) => match path_segment_cmp(a, b) {\n-                Ordering::Equal => None,\n-                ord => Some(ord),\n-            },\n-            EitherOrBoth::Left(_) if !b_has_tl => Some(Ordering::Greater),\n-            EitherOrBoth::Left(_) => Some(Ordering::Less),\n-            EitherOrBoth::Right(_) if !a_has_tl => Some(Ordering::Less),\n-            EitherOrBoth::Right(_) => Some(Ordering::Greater),\n-        })\n-        .unwrap_or(Ordering::Equal)\n-}\n-\n-fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    let a = a.kind().and_then(|kind| match kind {\n-        PathSegmentKind::Name(name_ref) => Some(name_ref),\n-        _ => None,\n-    });\n-    let b = b.kind().and_then(|kind| match kind {\n-        PathSegmentKind::Name(name_ref) => Some(name_ref),\n-        _ => None,\n-    });\n-    a.as_ref().map(ast::NameRef::text).cmp(&b.as_ref().map(ast::NameRef::text))\n-}\n-\n-/// What type of merges are allowed.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum MergeBehavior {\n-    /// Merge everything together creating deeply nested imports.\n-    Full,\n-    /// Only merge the last import level, doesn't allow import nesting.\n-    Last,\n-}\n-\n-impl MergeBehavior {\n-    #[inline]\n-    fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {\n-        match self {\n-            MergeBehavior::Full => true,\n-            // only simple single segment paths are allowed\n-            MergeBehavior::Last => {\n-                tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Eq, PartialEq, PartialOrd, Ord)]\n enum ImportGroup {\n     // the order here defines the order of new group inserts\n@@ -411,7 +101,7 @@ impl ImportGroup {\n     fn new(path: &ast::Path) -> ImportGroup {\n         let default = ImportGroup::ExternCrate;\n \n-        let first_segment = match first_segment(path) {\n+        let first_segment = match path.first_segment() {\n             Some(it) => it,\n             None => return default,\n         };"}, {"sha": "3f5bbef7fb97b4eb49ad819212aff8e305b153cb", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -0,0 +1,309 @@\n+//! Handle syntactic aspects of merging UseTrees.\n+use std::cmp::Ordering;\n+\n+use itertools::{EitherOrBoth, Itertools};\n+use syntax::ast::{\n+    self, edit::AstNodeEdit, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner,\n+};\n+\n+/// What type of merges are allowed.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum MergeBehavior {\n+    /// Merge everything together creating deeply nested imports.\n+    Full,\n+    /// Only merge the last import level, doesn't allow import nesting.\n+    Last,\n+}\n+\n+impl MergeBehavior {\n+    #[inline]\n+    fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {\n+        match self {\n+            MergeBehavior::Full => true,\n+            // only simple single segment paths are allowed\n+            MergeBehavior::Last => {\n+                tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn try_merge_imports(\n+    lhs: &ast::Use,\n+    rhs: &ast::Use,\n+    merge_behavior: MergeBehavior,\n+) -> Option<ast::Use> {\n+    // don't merge imports with different visibilities\n+    if !eq_visibility(lhs.visibility(), rhs.visibility()) {\n+        return None;\n+    }\n+    if !eq_attrs(lhs.attrs(), rhs.attrs()) {\n+        return None;\n+    }\n+\n+    let lhs_tree = lhs.use_tree()?;\n+    let rhs_tree = rhs.use_tree()?;\n+    let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behavior)?;\n+    Some(lhs.with_use_tree(merged).clone_for_update())\n+}\n+\n+pub fn try_merge_trees(\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n+    merge: MergeBehavior,\n+) -> Option<ast::UseTree> {\n+    let lhs_path = lhs.path()?;\n+    let rhs_path = rhs.path()?;\n+\n+    let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+    let (lhs, rhs) = if lhs.is_simple_path()\n+        && rhs.is_simple_path()\n+        && lhs_path == lhs_prefix\n+        && rhs_path == rhs_prefix\n+    {\n+        (lhs.clone(), rhs.clone())\n+    } else {\n+        (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n+    };\n+    recursive_merge(&lhs, &rhs, merge)\n+}\n+\n+/// Recursively \"zips\" together lhs and rhs.\n+fn recursive_merge(\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n+    merge: MergeBehavior,\n+) -> Option<ast::UseTree> {\n+    let mut use_trees = lhs\n+        .use_tree_list()\n+        .into_iter()\n+        .flat_map(|list| list.use_trees())\n+        // we use Option here to early return from this function(this is not the same as a `filter` op)\n+        .map(|tree| match merge.is_tree_allowed(&tree) {\n+            true => Some(tree),\n+            false => None,\n+        })\n+        .collect::<Option<Vec<_>>>()?;\n+    use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n+        if !merge.is_tree_allowed(&rhs_t) {\n+            return None;\n+        }\n+        let rhs_path = rhs_t.path();\n+        match use_trees.binary_search_by(|lhs_t| {\n+            let (lhs_t, rhs_t) = match lhs_t\n+                .path()\n+                .zip(rhs_path.clone())\n+                .and_then(|(lhs, rhs)| common_prefix(&lhs, &rhs))\n+            {\n+                Some((lhs_p, rhs_p)) => (lhs_t.split_prefix(&lhs_p), rhs_t.split_prefix(&rhs_p)),\n+                None => (lhs_t.clone(), rhs_t.clone()),\n+            };\n+\n+            path_cmp_bin_search(lhs_t.path(), rhs_t.path())\n+        }) {\n+            Ok(idx) => {\n+                let lhs_t = &mut use_trees[idx];\n+                let lhs_path = lhs_t.path()?;\n+                let rhs_path = rhs_path?;\n+                let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+                if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n+                    let tree_is_self = |tree: ast::UseTree| {\n+                        tree.path().as_ref().map(path_is_self).unwrap_or(false)\n+                    };\n+                    // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n+                    // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n+                    let tree_contains_self = |tree: &ast::UseTree| {\n+                        tree.use_tree_list()\n+                            .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n+                            .unwrap_or(false)\n+                    };\n+                    match (tree_contains_self(&lhs_t), tree_contains_self(&rhs_t)) {\n+                        (true, false) => continue,\n+                        (false, true) => {\n+                            *lhs_t = rhs_t;\n+                            continue;\n+                        }\n+                        _ => (),\n+                    }\n+\n+                    // glob imports arent part of the use-tree lists so we need to special handle them here as well\n+                    // this special handling is only required for when we merge a module import into a glob import of said module\n+                    // see the `merge_self_glob` or `merge_mod_into_glob` tests\n+                    if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n+                        *lhs_t = make::use_tree(\n+                            make::path_unqualified(make::path_segment_self()),\n+                            None,\n+                            None,\n+                            false,\n+                        );\n+                        use_trees.insert(idx, make::glob_use_tree());\n+                        continue;\n+                    }\n+\n+                    if lhs_t.use_tree_list().is_none() && rhs_t.use_tree_list().is_none() {\n+                        continue;\n+                    }\n+                }\n+                let lhs = lhs_t.split_prefix(&lhs_prefix);\n+                let rhs = rhs_t.split_prefix(&rhs_prefix);\n+                match recursive_merge(&lhs, &rhs, merge) {\n+                    Some(use_tree) => use_trees[idx] = use_tree,\n+                    None => return None,\n+                }\n+            }\n+            Err(_)\n+                if merge == MergeBehavior::Last\n+                    && use_trees.len() > 0\n+                    && rhs_t.use_tree_list().is_some() =>\n+            {\n+                return None\n+            }\n+            Err(idx) => {\n+                use_trees.insert(idx, rhs_t);\n+            }\n+        }\n+    }\n+\n+    Some(if let Some(old) = lhs.use_tree_list() {\n+        lhs.replace_descendant(old, make::use_tree_list(use_trees)).clone_for_update()\n+    } else {\n+        lhs.clone()\n+    })\n+}\n+\n+/// Traverses both paths until they differ, returning the common prefix of both.\n+fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {\n+    let mut res = None;\n+    let mut lhs_curr = lhs.first_qualifier_or_self();\n+    let mut rhs_curr = rhs.first_qualifier_or_self();\n+    loop {\n+        match (lhs_curr.segment(), rhs_curr.segment()) {\n+            (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n+            _ => break res,\n+        }\n+        res = Some((lhs_curr.clone(), rhs_curr.clone()));\n+\n+        match lhs_curr.parent_path().zip(rhs_curr.parent_path()) {\n+            Some((lhs, rhs)) => {\n+                lhs_curr = lhs;\n+                rhs_curr = rhs;\n+            }\n+            _ => break res,\n+        }\n+    }\n+}\n+\n+/// Orders paths in the following way:\n+/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n+// FIXME: rustfmt sorts lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n+// which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n+// Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n+fn path_cmp_for_sort(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(ref a), Some(ref b)) => match (path_is_self(a), path_is_self(b)) {\n+            (true, true) => Ordering::Equal,\n+            (true, false) => Ordering::Less,\n+            (false, true) => Ordering::Greater,\n+            (false, false) => path_cmp_short(a, b),\n+        },\n+    }\n+}\n+\n+/// Path comparison func for binary searching for merging.\n+fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<ast::Path>) -> Ordering {\n+    match (\n+        lhs.as_ref().and_then(ast::Path::first_segment),\n+        rhs.as_ref().and_then(ast::Path::first_segment),\n+    ) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(ref a), Some(ref b)) => path_segment_cmp(a, b),\n+    }\n+}\n+\n+/// Short circuiting comparison, if both paths are equal until one of them ends they are considered\n+/// equal\n+fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    let a = a.segments();\n+    let b = b.segments();\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesn't work due the lifetimes on text's return type\n+    a.zip(b)\n+        .find_map(|(a, b)| match path_segment_cmp(&a, &b) {\n+            Ordering::Equal => None,\n+            ord => Some(ord),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+/// Compares two paths, if one ends earlier than the other the has_tl parameters decide which is\n+/// greater as a a path that has a tree list should be greater, while one that just ends without\n+/// a tree list should be considered less.\n+pub(super) fn use_tree_path_cmp(\n+    a: &ast::Path,\n+    a_has_tl: bool,\n+    b: &ast::Path,\n+    b_has_tl: bool,\n+) -> Ordering {\n+    let a_segments = a.segments();\n+    let b_segments = b.segments();\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesn't work due the lifetimes on text's return type\n+    a_segments\n+        .zip_longest(b_segments)\n+        .find_map(|zipped| match zipped {\n+            EitherOrBoth::Both(ref a, ref b) => match path_segment_cmp(a, b) {\n+                Ordering::Equal => None,\n+                ord => Some(ord),\n+            },\n+            EitherOrBoth::Left(_) if !b_has_tl => Some(Ordering::Greater),\n+            EitherOrBoth::Left(_) => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) if !a_has_tl => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) => Some(Ordering::Greater),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    let a = a.kind().and_then(|kind| match kind {\n+        PathSegmentKind::Name(name_ref) => Some(name_ref),\n+        _ => None,\n+    });\n+    let b = b.kind().and_then(|kind| match kind {\n+        PathSegmentKind::Name(name_ref) => Some(name_ref),\n+        _ => None,\n+    });\n+    a.as_ref().map(ast::NameRef::text).cmp(&b.as_ref().map(ast::NameRef::text))\n+}\n+\n+fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n+    match (vis0, vis1) {\n+        (None, None) => true,\n+        // FIXME: Don't use the string representation to check for equality\n+        // spaces inside of the node would break this comparison\n+        (Some(vis0), Some(vis1)) => vis0.to_string() == vis1.to_string(),\n+        _ => false,\n+    }\n+}\n+\n+fn eq_attrs(\n+    attrs0: impl Iterator<Item = ast::Attr>,\n+    attrs1: impl Iterator<Item = ast::Attr>,\n+) -> bool {\n+    let attrs0 = attrs0.map(|attr| attr.to_string());\n+    let attrs1 = attrs1.map(|attr| attr.to_string());\n+    attrs0.eq(attrs1)\n+}\n+\n+fn path_is_self(path: &ast::Path) -> bool {\n+    path.segment().and_then(|seg| seg.self_token()).is_some() && path.qualifier().is_none()\n+}\n+\n+fn path_len(path: ast::Path) -> usize {\n+    path.segments().count()\n+}"}, {"sha": "d81ee94ee4f60f5133460a3fc0fb1877d0f71eac", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -12,7 +12,8 @@ use std::{ffi::OsString, iter, path::PathBuf};\n use flycheck::FlycheckConfig;\n use ide::{AssistConfig, CompletionConfig, DiagnosticsConfig, HoverConfig, InlayHintsConfig};\n use ide_db::helpers::{\n-    insert_use::{InsertUseConfig, MergeBehavior, PrefixKind},\n+    insert_use::{InsertUseConfig, PrefixKind},\n+    merge_imports::MergeBehavior,\n     SnippetCap,\n };\n use lsp_types::{ClientCapabilities, MarkupKind};"}, {"sha": "492fbc4a0fba5492674e7b6a93187084a84de2d1", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4defd2409d6a6120b40a0730e9822a819e971d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=1b4defd2409d6a6120b40a0730e9822a819e971d", "patch": "@@ -1,7 +1,7 @@\n //! Various extension methods to ast Nodes, which are hard to code-generate.\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n \n-use std::fmt;\n+use std::{fmt, iter::successors};\n \n use itertools::Itertools;\n use parser::SyntaxKind;\n@@ -237,6 +237,26 @@ impl ast::Path {\n             None => self.segment(),\n         }\n     }\n+\n+    pub fn first_qualifier_or_self(&self) -> ast::Path {\n+        successors(Some(self.clone()), ast::Path::qualifier).last().unwrap()\n+    }\n+\n+    pub fn first_segment(&self) -> Option<ast::PathSegment> {\n+        self.first_qualifier_or_self().segment()\n+    }\n+\n+    pub fn segments(&self) -> impl Iterator<Item = ast::PathSegment> + Clone {\n+        // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n+        successors(self.first_segment(), |p| {\n+            p.parent_path().parent_path().and_then(|p| p.segment())\n+        })\n+    }\n+}\n+impl ast::UseTree {\n+    pub fn is_simple_path(&self) -> bool {\n+        self.use_tree_list().is_none() && self.star_token().is_none()\n+    }\n }\n \n impl ast::UseTreeList {"}]}