{"sha": "95fdaf237575e44ecf16f9fb13ab60058909f281", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZmRhZjIzNzU3NWU0NGVjZjE2ZjlmYjEzYWI2MDA1ODkwOWYyODE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-18T17:00:19Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-18T17:00:19Z"}, "message": "Require exact type equality + add tests\n\n+ Rebase fixes", "tree": {"sha": "d5c2379977294b5bf5a0b51adb413f34851d958d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c2379977294b5bf5a0b51adb413f34851d958d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95fdaf237575e44ecf16f9fb13ab60058909f281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95fdaf237575e44ecf16f9fb13ab60058909f281", "html_url": "https://github.com/rust-lang/rust/commit/95fdaf237575e44ecf16f9fb13ab60058909f281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95fdaf237575e44ecf16f9fb13ab60058909f281/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ceef5a9e9224baf1f108ede1d1033e5e7fef08", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ceef5a9e9224baf1f108ede1d1033e5e7fef08", "html_url": "https://github.com/rust-lang/rust/commit/e0ceef5a9e9224baf1f108ede1d1033e5e7fef08"}], "stats": {"total": 231, "additions": 188, "deletions": 43}, "files": [{"sha": "1033ce0df57ae0e331c50b992e684e6ea2ec5cdc", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -2392,6 +2392,8 @@ The currently implemented features of the reference compiler are:\n \n * - `deprecated` - Allows using the `#[deprecated]` attribute.\n \n+* - `type_ascription` - Allows type ascription expressions `expr: Type`.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "d4778dc165acb78aef96bf75c416c0dcfe22f55f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -2671,6 +2671,14 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n+fn check_expr_eq_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                expr: &'tcx hir::Expr,\n+                                expected: Ty<'tcx>) {\n+    check_expr_with_unifier(\n+        fcx, expr, ExpectHasType(expected), NoPreference,\n+        || demand::eqtype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n+}\n+\n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      expected: Ty<'tcx>) {\n@@ -3527,7 +3535,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       hir::ExprType(ref e, ref t) => {\n         let typ = fcx.to_ty(&**t);\n-        check_expr_coercable_to_type(fcx, &**e, typ);\n+        check_expr_eq_type(fcx, &**e, typ);\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprVec(ref args) => {"}, {"sha": "075360b96230985bcb94285be57c5dce51559fdf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -2791,7 +2791,8 @@ impl<'a> Parser<'a> {\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprType(lhs, rhs));\n+                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                   ExprType(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise"}, {"sha": "e5c6a17c78ba25191f25e50a4375dfd8487fb9b6", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -19,7 +19,7 @@ use syntax::codemap::Span;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n-use syntax::parse::token::{intern, InternedString};\n+use syntax::parse::token::intern;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n use syntax::ast::AsmDialect;"}, {"sha": "ef65927fc5d419eb1b922bb81e9c271323340347", "filename": "src/test/compile-fail/coerce-expect-unsized-ascribed.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Fcoerce-expect-unsized-ascribed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Fcoerce-expect-unsized-ascribed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-expect-unsized-ascribed.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A version of coerce-expect-unsized that uses type ascription.\n+// Doesn't work so far, but supposed to work eventually\n+\n+#![feature(box_syntax, type_ascription)]\n+\n+use std::fmt::Debug;\n+\n+pub fn main() {\n+    let _ = box { [1, 2, 3] }: Box<[i32]>; //~ ERROR mismatched types\n+    let _ = box if true { [1, 2, 3] } else { [1, 3, 4] }: Box<[i32]>; //~ ERROR mismatched types\n+    let _ = box match true { true => [1, 2, 3], false => [1, 3, 4] }: Box<[i32]>;\n+    //~^ ERROR mismatched types\n+    let _ = box { |x| (x as u8) }: Box<Fn(i32) -> _>; //~ ERROR mismatched types\n+    let _ = box if true { false } else { true }: Box<Debug>; //~ ERROR mismatched types\n+    let _ = box match true { true => 'a', false => 'b' }: Box<Debug>; //~ ERROR mismatched types\n+\n+    let _ = &{ [1, 2, 3] }: &[i32]; //~ ERROR mismatched types\n+    let _ = &if true { [1, 2, 3] } else { [1, 3, 4] }: &[i32]; //~ ERROR mismatched types\n+    let _ = &match true { true => [1, 2, 3], false => [1, 3, 4] }: &[i32];\n+    //~^ ERROR mismatched types\n+    let _ = &{ |x| (x as u8) }: &Fn(i32) -> _; //~ ERROR mismatched types\n+    let _ = &if true { false } else { true }: &Debug; //~ ERROR mismatched types\n+    let _ = &match true { true => 'a', false => 'b' }: &Debug; //~ ERROR mismatched types\n+\n+    let _ = Box::new([1, 2, 3]): Box<[i32]>; //~ ERROR mismatched types\n+    let _ = Box::new(|x| (x as u8)): Box<Fn(i32) -> _>; //~ ERROR mismatched types\n+\n+    let _ = vec![\n+        Box::new(|x| (x as u8)),\n+        box |x| (x as i16 as u8),\n+    ]: Vec<Box<Fn(i32) -> _>>;\n+}"}, {"sha": "bb7a8bc3ddf9899bbbadd83e410f7e9d2a70f115", "filename": "src/test/compile-fail/type-ascription-precedence.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Ftype-ascription-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Ftype-ascription-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-ascription-precedence.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Operator precedence of type ascription\n+// Type ascription has very high precedence, the same as operator `as`\n+\n+#![feature(type_ascription)]\n+\n+use std::ops::*;\n+\n+struct S;\n+struct Z;\n+\n+impl Add<Z> for S {\n+    type Output = S;\n+    fn add(self, _rhs: Z) -> S { panic!() }\n+}\n+impl Mul<Z> for S {\n+    type Output = S;\n+    fn mul(self, _rhs: Z) -> S { panic!() }\n+}\n+impl Neg for S {\n+    type Output = Z;\n+    fn neg(self) -> Z { panic!() }\n+}\n+impl Deref for S {\n+    type Target = Z;\n+    fn deref(&self) -> &Z { panic!() }\n+}\n+\n+fn main() {\n+    &S: &S; // OK\n+    (&S): &S; // OK\n+    &(S: &S); //~ ERROR mismatched types\n+\n+    *S: Z; // OK\n+    (*S): Z; // OK\n+    *(S: Z); //~ ERROR mismatched types\n+    //~^ ERROR type `Z` cannot be dereferenced\n+\n+    -S: Z; // OK\n+    (-S): Z; // OK\n+    -(S: Z); //~ ERROR mismatched types\n+    //~^ ERROR cannot apply unary operator `-` to type `Z`\n+\n+    S + Z: Z; // OK\n+    S + (Z: Z); // OK\n+    (S + Z): Z; //~ ERROR mismatched types\n+\n+    S * Z: Z; // OK\n+    S * (Z: Z); // OK\n+    (S * Z): Z; //~ ERROR mismatched types\n+\n+    S .. S: S; // OK\n+    S .. (S: S); // OK\n+    (S .. S): S; //~ ERROR mismatched types\n+}"}, {"sha": "2d882e87ab8eab60cbc24114ec5c2e2a2085ac6b", "filename": "src/test/compile-fail/type-ascription-soundness.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Ftype-ascription-soundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Fcompile-fail%2Ftype-ascription-soundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-ascription-soundness.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type ascription doesn't lead to unsoundness\n+\n+#![feature(type_ascription)]\n+\n+fn main() {\n+    let arr = &[1u8, 2, 3];\n+    let ref x = arr: &[u8]; //~ ERROR mismatched types\n+    let ref mut x = arr: &[u8]; //~ ERROR mismatched types\n+    match arr: &[u8] { //~ ERROR mismatched types\n+        ref x => {}\n+    }\n+    let _len = (arr: &[u8]).len(); //~ ERROR mismatched types\n+}"}, {"sha": "33e9b424fea6d22258b3a81d46748a9c13a7365a", "filename": "src/test/run-pass/coerce-expect-unsized-ascribed.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0ceef5a9e9224baf1f108ede1d1033e5e7fef08/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized-ascribed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ceef5a9e9224baf1f108ede1d1033e5e7fef08/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized-ascribed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized-ascribed.rs?ref=e0ceef5a9e9224baf1f108ede1d1033e5e7fef08", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unknown_features)]\n-#![feature(box_syntax)]\n-\n-use std::fmt::Debug;\n-\n-// A version of coerce-expect-unsized that uses type ascription.\n-\n-pub fn main() {\n-    let _ = box { [1, 2, 3] }: Box<[i32]>;\n-    let _ = box if true { [1, 2, 3] } else { [1, 3, 4] }: Box<[i32]>;\n-    let _ = box match true { true => [1, 2, 3], false => [1, 3, 4] }: Box<[i32]>;\n-    let _ = box { |x| (x as u8) }: Box<Fn(i32) -> _>;\n-    let _ = box if true { false } else { true }: Box<Debug>;\n-    let _ = box match true { true => 'a', false => 'b' }: Box<Debug>;\n-\n-    let _ = &{ [1, 2, 3] }: &[i32];\n-    let _ = &if true { [1, 2, 3] } else { [1, 3, 4] }: &[i32];\n-    let _ = &match true { true => [1, 2, 3], false => [1, 3, 4] }: &[i32];\n-    let _ = &{ |x| (x as u8) }: &Fn(i32) -> _;\n-    let _ = &if true { false } else { true }: &Debug;\n-    let _ = &match true { true => 'a', false => 'b' }: &Debug;\n-\n-    let _ = Box::new([1, 2, 3]): Box<[i32]>;\n-    let _ = Box::new(|x| (x as u8)): Box<Fn(i32) -> _>;\n-\n-    let _ = vec![\n-        Box::new(|x| (x as u8)),\n-        box |x| (x as i16 as u8),\n-    ]: Vec<Box<Fn(i32) -> _>>;\n-}"}, {"sha": "bca384c64712f299dbed42df9e04ee766748fec0", "filename": "src/test/run-pass/type-ascription.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Frun-pass%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fdaf237575e44ecf16f9fb13ab60058909f281/src%2Ftest%2Frun-pass%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-ascription.rs?ref=95fdaf237575e44ecf16f9fb13ab60058909f281", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type ascription doesn't lead to unsoundness\n+\n+#![feature(type_ascription)]\n+\n+use std::mem;\n+\n+const C1: u8 = 10: u8;\n+const C2: [u8; 1: usize] = [1];\n+\n+struct S {\n+    a: u8\n+}\n+\n+fn main() {\n+    assert_eq!(C1.into(): i32, 10);\n+    assert_eq!(C2[0], 1);\n+\n+    let s = S { a: 10: u8 };\n+    let arr = &[1u8, 2, 3];\n+\n+    let mut v = arr.iter().cloned().collect(): Vec<_>;\n+    v.push(4);\n+    assert_eq!(v, [1, 2, 3, 4]);\n+\n+    let a = 1: u8;\n+    let b = a.into(): u16;\n+    assert_eq!(v[a.into(): usize], 2);\n+    assert_eq!(mem::size_of_val(&a), 1);\n+    assert_eq!(mem::size_of_val(&b), 2);\n+    assert_eq!(b, 1: u16);\n+\n+    let mut v = Vec::new();\n+    v: Vec<u8> = vec![1, 2, 3]; // Lvalue type ascription\n+    assert_eq!(v, [1u8, 2, 3]);\n+}"}]}