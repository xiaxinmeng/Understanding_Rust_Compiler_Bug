{"sha": "8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYzEwNmIyOWQzZDJlZTM4MmY2ZGM0YTJlOWQ2ZWVjZjUzNGM2ZWQ=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-05-10T13:06:33Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:33Z"}, "message": "fix some of the review, rename, fmt, refactor", "tree": {"sha": "2b7f2aa67ba3b3b15ccca2b9823e652d10591b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b7f2aa67ba3b3b15ccca2b9823e652d10591b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "html_url": "https://github.com/rust-lang/rust/commit/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d9e80ad7b5b69caa8b9f9c44d47f26c4bbc4c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9e80ad7b5b69caa8b9f9c44d47f26c4bbc4c7b", "html_url": "https://github.com/rust-lang/rust/commit/1d9e80ad7b5b69caa8b9f9c44d47f26c4bbc4c7b"}], "stats": {"total": 135, "additions": 60, "deletions": 75}, "files": [{"sha": "021fbe932d895916e7198b2a3792416bd217c60a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "patch": "@@ -1060,7 +1060,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let max_struct_bools = conf.max_struct_bools;\n     store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n     store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n-    store.register_late_pass(|| box wildcard_imports::WildcardImports);\n+    let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n+    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);"}, {"sha": "9c8035f54a923f0083ccc45edb0d5d1d9684abc6", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 57, "deletions": 73, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "patch": "@@ -38,8 +38,8 @@ pub struct MacroRefData {\n }\n \n impl MacroRefData {\n-    pub fn new(name: &str, span: Span, ecx: &LateContext<'_, '_>) -> Self {\n-        let mut path = ecx.sess().source_map().span_to_filename(span).to_string();\n+    pub fn new(name: &str, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n+        let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n \n         // std lib paths are <::std::module::file type>\n         // so remove brackets, space and type.\n@@ -63,142 +63,126 @@ pub struct MacroUseImports {\n     imports: Vec<(String, Span)>,\n     /// the span of the macro reference, kept to ensure only one reference is used per macro call.\n     collected: FxHashSet<Span>,\n-    mac_refs: Vec<(Span, MacroRefData)>,\n+    mac_refs: Vec<MacroRefData>,\n }\n \n impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n \n+impl MacroUseImports {\n+    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, name: &str, call_site: Span, callee: Span) {\n+        if !self.collected.contains(&call_site) {\n+            let name = if name.contains(\"::\") {\n+                name.split(\"::\").last().unwrap().to_string()\n+            } else {\n+                name.to_string()\n+            };\n+\n+            self.mac_refs.push(MacroRefData::new(&name, callee, cx));\n+            self.collected.insert(call_site);\n+        }\n+    }\n+\n+    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, name: &str, call_site: Span, callee: Span) {\n+        if !self.collected.contains(&call_site) {\n+            self.mac_refs.push(MacroRefData::new(&name, callee, cx));\n+            self.collected.insert(call_site);\n+        }\n+    }\n+}\n+\n impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n-    fn check_item(&mut self, lcx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-                if lcx.sess().opts.edition == Edition::Edition2018;\n+                if cx.sess().opts.edition == Edition::Edition2018;\n                 if let hir::ItemKind::Use(path, _kind) = &item.kind;\n                 if let Some(mac_attr) = item\n                     .attrs\n                     .iter()\n                     .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n                 if let Res::Def(DefKind::Mod, id) = path.res;\n                 then {\n-                    for kid in lcx.tcx.item_children(id).iter() {\n+                    for kid in cx.tcx.item_children(id).iter() {\n                         if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n                             let span = mac_attr.span;\n-                            self.imports.push((lcx.tcx.def_path_str(mac_id), span));\n+                            self.imports.push((cx.tcx.def_path_str(mac_id), span));\n                         }\n                     }\n                 } else {\n-                if in_macro(item.span) {\n-                    let call_site = item.span.source_callsite();\n-                    let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-                    if let Some(callee) = item.span.source_callee() {\n-                        if !self.collected.contains(&call_site) {\n-                            self.mac_refs.push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                            self.collected.insert(call_site);\n+                    if in_macro(item.span) {\n+                        let call_site = item.span.source_callsite();\n+                        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+                        if let Some(callee) = item.span.source_callee() {\n+                            if !self.collected.contains(&call_site) {\n+                                self.mac_refs.push(MacroRefData::new(&name, callee.def_site, cx));\n+                                self.collected.insert(call_site);\n+                            }\n                         }\n                     }\n-                }\n             }\n         }\n     }\n-    fn check_attribute(&mut self, lcx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n         if in_macro(attr.span) {\n             let call_site = attr.span.source_callsite();\n-            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = attr.span.source_callee() {\n-                if !self.collected.contains(&call_site) {\n-                    let name = if name.contains(\"::\") {\n-                        name.split(\"::\").last().unwrap().to_string()\n-                    } else {\n-                        name.to_string()\n-                    };\n-\n-                    self.mac_refs\n-                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                    self.collected.insert(call_site);\n-                }\n+                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n             }\n         }\n     }\n-    fn check_expr(&mut self, lcx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             let call_site = expr.span.source_callsite();\n-            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = expr.span.source_callee() {\n-                if !self.collected.contains(&call_site) {\n-                    let name = if name.contains(\"::\") {\n-                        name.split(\"::\").last().unwrap().to_string()\n-                    } else {\n-                        name.to_string()\n-                    };\n-\n-                    self.mac_refs\n-                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                    self.collected.insert(call_site);\n-                }\n+                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n             }\n         }\n     }\n-    fn check_stmt(&mut self, lcx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n         if in_macro(stmt.span) {\n             let call_site = stmt.span.source_callsite();\n-            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = stmt.span.source_callee() {\n-                if !self.collected.contains(&call_site) {\n-                    let name = if name.contains(\"::\") {\n-                        name.split(\"::\").last().unwrap().to_string()\n-                    } else {\n-                        name.to_string()\n-                    };\n-\n-                    self.mac_refs\n-                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                    self.collected.insert(call_site);\n-                }\n+                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n             }\n         }\n     }\n-    fn check_pat(&mut self, lcx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n         if in_macro(pat.span) {\n             let call_site = pat.span.source_callsite();\n-            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = pat.span.source_callee() {\n-                if !self.collected.contains(&call_site) {\n-                    self.mac_refs\n-                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                    self.collected.insert(call_site);\n-                }\n+                self.push_unique_macro_pat_ty(cx, &name, call_site, callee.def_site);\n             }\n         }\n     }\n-    fn check_ty(&mut self, lcx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n         if in_macro(ty.span) {\n             let call_site = ty.span.source_callsite();\n-            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = ty.span.source_callee() {\n-                if !self.collected.contains(&call_site) {\n-                    self.mac_refs\n-                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n-                    self.collected.insert(call_site);\n-                }\n+                self.push_unique_macro_pat_ty(cx, &name, call_site, callee.def_site);\n             }\n         }\n     }\n \n-    fn check_crate_post(&mut self, lcx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n         for (import, span) in &self.imports {\n-            let matched = self.mac_refs.iter().any(|(_span, mac)| import.ends_with(&mac.name));\n+            let matched = self.mac_refs.iter().any(|mac| import.ends_with(&mac.name));\n \n             if matched {\n-                self.mac_refs.retain(|(_span, mac)| !import.ends_with(&mac.name));\n+                self.mac_refs.retain(|mac| !import.ends_with(&mac.name));\n                 let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n                 let help = format!(\"use {}\", import);\n                 span_lint_and_sugg(\n-                    lcx,\n+                    cx,\n                     MACRO_USE_IMPORTS,\n                     *span,\n                     msg,\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n-                    Applicability::HasPlaceholders,\n+                    Applicability::MaybeIncorrect,\n                 )\n             }\n         }"}, {"sha": "2d4f71e5d5329308ebce70022fbd3e554a45bf56", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "patch": "@@ -22,7 +22,7 @@ mod a {\n     #[derive(ClippyMiniMacroTest)]\n     struct Test;\n \n-    fn main() {\n+    fn test() {\n         pub_macro!();\n         inner_mod_macro!();\n         pub_in_private_macro!(_var);"}]}