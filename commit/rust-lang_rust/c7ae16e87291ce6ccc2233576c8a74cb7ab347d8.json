{"sha": "c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YWUxNmU4NzI5MWNlNmNjYzIyMzM1NzZjOGE3NGNiN2FiMzQ3ZDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-21T14:48:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-21T14:48:03Z"}, "message": "Merge #8611\n\n8611: Add support for fill match arms of boolean values r=flodiebold a=komonad\n\n- Add support for boolean inside tuple\r\n\r\ncloses #8593\n\nCo-authored-by: Comonad <comonad@foxmail.com>", "tree": {"sha": "bc0b13766f35ee23cf4bdd8603d24d83ebdc7231", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc0b13766f35ee23cf4bdd8603d24d83ebdc7231"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJggDsjCRBK7hj4Ov3rIwAAYEIIAG7V7InpeUufxrMDdvnxbLRI\nQIgpksaZzMjN67fbU5kCDBmzquEd96s9tgUPo0SbKpKRazvjDymg5Q1nqdXcaWiA\nuXF56VcWKCEb8dcKSTHbbxwV2ZpCd2rlbC5d2Q/EWAjWjma3ZMxdq++E5+4KHC4z\n0gMFr9o0hATNq+x+kgcM3lxonXjvRD/v5/U0b/x42Zf2eWWXBVfhqfz3PBzcN2vS\ntnUjtYlaDY9u9wSjRcDZviFQCKoAW1RuTrFwNbFRcnfiIR7rD10Zb5+C3FC56ttl\nq1ek2u3sRCd/bVttfjyRenBwjOPyo5UrVZGheISKYTYppZCRD+DHLln8Oej2+w4=\n=Out+\n-----END PGP SIGNATURE-----\n", "payload": "tree bc0b13766f35ee23cf4bdd8603d24d83ebdc7231\nparent 7ae0bc1bd40286200f5e5b7a4d3b086312055ed5\nparent 09147c3303f0ffe607c0decb2979980f9a296a5c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1619016483 +0000\ncommitter GitHub <noreply@github.com> 1619016483 +0000\n\nMerge #8611\n\n8611: Add support for fill match arms of boolean values r=flodiebold a=komonad\n\n- Add support for boolean inside tuple\r\n\r\ncloses #8593\n\nCo-authored-by: Comonad <comonad@foxmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "html_url": "https://github.com/rust-lang/rust/commit/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ae0bc1bd40286200f5e5b7a4d3b086312055ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae0bc1bd40286200f5e5b7a4d3b086312055ed5", "html_url": "https://github.com/rust-lang/rust/commit/7ae0bc1bd40286200f5e5b7a4d3b086312055ed5"}, {"sha": "09147c3303f0ffe607c0decb2979980f9a296a5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/09147c3303f0ffe607c0decb2979980f9a296a5c", "html_url": "https://github.com/rust-lang/rust/commit/09147c3303f0ffe607c0decb2979980f9a296a5c"}], "stats": {"total": 230, "additions": 207, "deletions": 23}, "files": [{"sha": "be927cc1c4728b6d006fb3ce5e40f810f5ea0f53", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 199, "deletions": 23, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         .iter()\n         .filter_map(ast::MatchArm::pat)\n         .flat_map(|pat| match pat {\n-            // Special casee OrPat as separate top-level pats\n+            // Special case OrPat as separate top-level pats\n             Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n             _ => Either::Right(iter::once(pat)),\n         })\n@@ -72,7 +72,11 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect::<Vec<_>>();\n-        if Some(enum_def) == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option() {\n+        if Some(enum_def)\n+            == FamousDefs(&ctx.sema, Some(module.krate()))\n+                .core_option_Option()\n+                .map(|x| lift_enum(x))\n+        {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);\n             variants.reverse()\n@@ -151,49 +155,99 @@ fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     }\n }\n \n-fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n+#[derive(Eq, PartialEq, Clone)]\n+enum ExtendedEnum {\n+    Bool,\n+    Enum(hir::Enum),\n+}\n+\n+#[derive(Eq, PartialEq, Clone)]\n+enum ExtendedVariant {\n+    True,\n+    False,\n+    Variant(hir::Variant),\n+}\n+\n+fn lift_enum(e: hir::Enum) -> ExtendedEnum {\n+    ExtendedEnum::Enum(e)\n+}\n+\n+impl ExtendedEnum {\n+    fn variants(&self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n+        match self {\n+            ExtendedEnum::Enum(e) => {\n+                e.variants(db).into_iter().map(|x| ExtendedVariant::Variant(x)).collect::<Vec<_>>()\n+            }\n+            ExtendedEnum::Bool => {\n+                Vec::<ExtendedVariant>::from([ExtendedVariant::True, ExtendedVariant::False])\n+            }\n+        }\n+    }\n+}\n+\n+fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n     sema.type_of_expr(&expr)?.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-        Some(Adt::Enum(e)) => Some(e),\n-        _ => None,\n+        Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n+        _ => {\n+            if ty.is_bool() {\n+                Some(ExtendedEnum::Bool)\n+            } else {\n+                None\n+            }\n+        }\n     })\n }\n \n fn resolve_tuple_of_enum_def(\n     sema: &Semantics<RootDatabase>,\n     expr: &ast::Expr,\n-) -> Option<Vec<hir::Enum>> {\n+) -> Option<Vec<ExtendedEnum>> {\n     sema.type_of_expr(&expr)?\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {\n             ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-                Some(Adt::Enum(e)) => Some(e),\n+                Some(Adt::Enum(e)) => Some(lift_enum(e)),\n                 // For now we only handle expansion for a tuple of enums. Here\n                 // we map non-enum items to None and rely on `collect` to\n                 // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => None,\n+                _ => {\n+                    if ty.is_bool() {\n+                        Some(ExtendedEnum::Bool)\n+                    } else {\n+                        None\n+                    }\n+                }\n             })\n         })\n         .collect()\n }\n \n-fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::Variant) -> Option<ast::Pat> {\n-    let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Option<ast::Pat> {\n+    match var {\n+        ExtendedVariant::Variant(var) => {\n+            let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+\n+            // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n+            let pat: ast::Pat = match var.source(db)?.value.kind() {\n+                ast::StructKind::Tuple(field_list) => {\n+                    let pats =\n+                        iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n+                    make::tuple_struct_pat(path, pats).into()\n+                }\n+                ast::StructKind::Record(field_list) => {\n+                    let pats =\n+                        field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n+                    make::record_pat(path, pats).into()\n+                }\n+                ast::StructKind::Unit => make::path_pat(path),\n+            };\n \n-    // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n-    let pat: ast::Pat = match var.source(db)?.value.kind() {\n-        ast::StructKind::Tuple(field_list) => {\n-            let pats = iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n-            make::tuple_struct_pat(path, pats).into()\n-        }\n-        ast::StructKind::Record(field_list) => {\n-            let pats = field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n-            make::record_pat(path, pats).into()\n+            Some(pat)\n         }\n-        ast::StructKind::Unit => make::path_pat(path),\n-    };\n-\n-    Some(pat)\n+        ExtendedVariant::True => Some(ast::Pat::from(make::literal_pat(\"true\"))),\n+        ExtendedVariant::False => Some(ast::Pat::from(make::literal_pat(\"false\"))),\n+    }\n }\n \n #[cfg(test)]\n@@ -225,6 +279,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn all_boolean_match_arms_provided() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                    true => {}\n+                    false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn tuple_of_non_enum() {\n         // for now this case is not handled, although it potentially could be\n@@ -240,6 +309,113 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_boolean() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a {\n+                    $0true => {}\n+                    false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn partial_fill_boolean() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                    true => {}\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a {\n+                    true => {}\n+                    $0false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn all_boolean_tuple_arms_provided() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                    (true, true) => {}\n+                    (true, false) => {}\n+                    (false, true) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fill_boolean_tuple() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a) {\n+                    $0(true, true) => {}\n+                    (true, false) => {}\n+                    (false, true) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn partial_fill_boolean_tuple() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                    (false, true) => {}\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a) {\n+                    (false, true) => {}\n+                    $0(true, true) => {}\n+                    (true, false) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn partial_fill_record_tuple() {\n         check_assist("}, {"sha": "4cf6f871e2c92a9cc3cd7001bea8654da9ef41b7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae16e87291ce6ccc2233576c8a74cb7ab347d8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=c7ae16e87291ce6ccc2233576c8a74cb7ab347d8", "patch": "@@ -294,6 +294,14 @@ pub fn wildcard_pat() -> ast::WildcardPat {\n     }\n }\n \n+pub fn literal_pat(lit: &str) -> ast::LiteralPat {\n+    return from_text(lit);\n+\n+    fn from_text(text: &str) -> ast::LiteralPat {\n+        ast_from_text(&format!(\"fn f() {{ match x {{ {} => {{}} }} }}\", text))\n+    }\n+}\n+\n /// Creates a tuple of patterns from an iterator of patterns.\n ///\n /// Invariant: `pats` must be length > 0"}]}