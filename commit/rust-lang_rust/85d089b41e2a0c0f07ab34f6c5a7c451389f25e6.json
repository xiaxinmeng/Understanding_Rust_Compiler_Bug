{"sha": "85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "node_id": "C_kwDOAAsO6NoAKDg1ZDA4OWI0MWUyYTBjMGYwN2FiMzRmNmM1YTdjNDUxMzg5ZjI1ZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T12:33:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T12:33:39Z"}, "message": "Auto merge of #103392 - RalfJung:miri, r=oli-obk\n\nupdate Miri\n\nI had to use a hacked version of josh to create this, so let's be careful with merging this and maybe wait a bit to see if the josh issue becomes more clear. But the history looks good to me, we are not adding duplicates of rustc commits that were previously mirrored to Miri.\n\nAlso I want to add some cross-testing of Miri in x.py.", "tree": {"sha": "4fcf5a59fd4068337f77931db8e64d211ccc3d9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fcf5a59fd4068337f77931db8e64d211ccc3d9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "html_url": "https://github.com/rust-lang/rust/commit/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6bd7e21c6239f4bcc3892ead298641ec1422f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bd7e21c6239f4bcc3892ead298641ec1422f20", "html_url": "https://github.com/rust-lang/rust/commit/c6bd7e21c6239f4bcc3892ead298641ec1422f20"}, {"sha": "a157e0e88f08fd7f5a5a61412f04043480cddb17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a157e0e88f08fd7f5a5a61412f04043480cddb17", "html_url": "https://github.com/rust-lang/rust/commit/a157e0e88f08fd7f5a5a61412f04043480cddb17"}], "stats": {"total": 1992, "additions": 1522, "deletions": 470}, "files": [{"sha": "dab693419a95d7ac1c634b892c13bc2635256dd7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -2262,6 +2262,7 @@ dependencies = [\n  \"rand 0.8.5\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n+ \"rustc_version\",\n  \"shell-escape\",\n  \"smallvec\",\n  \"ui_test\","}, {"sha": "ebac73d8aad207d45a2e9cf18d8864b1997109c6", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -461,24 +461,30 @@ impl Step for RustDemangler {\n pub struct Miri {\n     stage: u32,\n     host: TargetSelection,\n+    target: TargetSelection,\n }\n \n impl Step for Miri {\n     type Output = ();\n-    const ONLY_HOSTS: bool = true;\n+    const ONLY_HOSTS: bool = false;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/miri\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Miri { stage: run.builder.top_stage, host: run.target });\n+        run.builder.ensure(Miri {\n+            stage: run.builder.top_stage,\n+            host: run.build_triple(),\n+            target: run.target,\n+        });\n     }\n \n     /// Runs `cargo test` for miri.\n     fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n+        let target = self.target;\n         let compiler = builder.compiler(stage, host);\n         // We need the stdlib for the *next* stage, as it was built with this compiler that also built Miri.\n         // Except if we are at stage 2, the bootstrap loop is complete and we can stick with our current stage.\n@@ -495,7 +501,7 @@ impl Step for Miri {\n         builder.ensure(compile::Std::new(compiler_std, host));\n         let sysroot = builder.sysroot(compiler_std);\n \n-        // # Run `cargo miri setup`.\n+        // # Run `cargo miri setup` for the given target.\n         let mut cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n@@ -508,6 +514,7 @@ impl Step for Miri {\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n         cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n+        cargo.arg(\"--target\").arg(target.rustc_target_arg());\n \n         // Tell `cargo miri setup` where to find the sources.\n         cargo.env(\"MIRI_LIB_SRC\", builder.src.join(\"library\"));\n@@ -556,17 +563,54 @@ impl Step for Miri {\n         cargo.add_rustc_lib_path(builder, compiler);\n \n         // miri tests need to know about the stage sysroot\n-        cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n+        cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n         cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-        cargo.env(\"MIRI\", miri);\n+        cargo.env(\"MIRI\", &miri);\n         // propagate --bless\n         if builder.config.cmd.bless() {\n             cargo.env(\"MIRI_BLESS\", \"Gesundheit\");\n         }\n \n+        // Set the target.\n+        cargo.env(\"MIRI_TEST_TARGET\", target.rustc_target_arg());\n+        // Forward test filters.\n+        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n+\n+        let mut cargo = Command::from(cargo);\n+        builder.run(&mut cargo);\n+\n+        // # Run `cargo miri test`.\n+        // This is just a smoke test (Miri's own CI invokes this in a bunch of different ways and ensures\n+        // that we get the desired output), but that is sufficient to make sure that the libtest harness\n+        // itself executes properly under Miri.\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            host,\n+            \"run\",\n+            \"src/tools/miri/cargo-miri\",\n+            SourceType::Submodule,\n+            &[],\n+        );\n+        cargo.add_rustc_lib_path(builder, compiler);\n+        cargo.arg(\"--\").arg(\"miri\").arg(\"test\");\n+        cargo\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(\"src/tools/miri/test-cargo-miri/Cargo.toml\"));\n+        cargo.arg(\"--target\").arg(target.rustc_target_arg());\n+        cargo.arg(\"--tests\"); // don't run doctests, they are too confused by the staging\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n+        // Tell `cargo miri` where to find things.\n+        cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n+        cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n+        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+        cargo.env(\"MIRI\", &miri);\n+        // Debug things.\n+        cargo.env(\"RUST_BACKTRACE\", \"1\");\n+\n         let mut cargo = Command::from(cargo);\n         builder.run(&mut cargo);\n     }"}, {"sha": "80a066cac298ab09c3a53731d8465d6f5069f848", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -25,3 +25,8 @@ python3 \"$X_PY\" test --stage 2 check-tools\n python3 \"$X_PY\" test --stage 2 src/tools/clippy\n python3 \"$X_PY\" test --stage 2 src/tools/rustfmt\n python3 \"$X_PY\" test --stage 2 src/tools/miri\n+# We natively run this script on x86_64-unknown-linux-gnu and x86_64-pc-windows-msvc.\n+# Also cover some other targets (on both of these hosts) via cross-testing.\n+python3 \"$X_PY\" test --stage 2 src/tools/miri --target i686-pc-windows-msvc\n+#FIXME(https://github.com/rust-lang/rust/issues/103519): macOS testing is currently disabled\n+# python3 \"$X_PY\" test --stage 2 src/tools/miri --target aarch64-apple-darwin"}, {"sha": "659c51f77e6ab450be2d91cfef3a3274160367f8", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -22,6 +22,7 @@ jobs:\n       RUST_BACKTRACE: 1\n       HOST_TARGET: ${{ matrix.host_target }}\n     strategy:\n+      fail-fast: false\n       matrix:\n         build: [linux64, macos, win32]\n         include:\n@@ -61,7 +62,7 @@ jobs:\n           restore-keys: ${{ runner.os }}-cargo\n \n       - name: Install rustup-toolchain-install-master\n-        if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}\n+        if: ${{ steps.cache.outputs.cache-hit != 'true' }}\n         shell: bash\n         run: |\n           cargo install -f rustup-toolchain-install-master\n@@ -89,11 +90,46 @@ jobs:\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n-      - name: Install required toolchain\n-        # We need a toolchain that can actually build Miri, just a nightly won't do.\n+\n+      # This is exactly duplicated from above. GHA is pretty terrible when it comes\n+      # to avoiding code duplication.\n+\n+      # Cache the global cargo directory, but NOT the local `target` directory which\n+      # we cannot reuse anyway when the nightly changes (and it grows quite large\n+      # over time).\n+      - name: Add cache for cargo\n+        id: cache\n+        uses: actions/cache@v3\n+        with:\n+          path: |\n+            # Taken from <https://doc.rust-lang.org/nightly/cargo/guide/cargo-home.html#caching-the-cargo-home-in-ci>.\n+            ~/.cargo/bin\n+            ~/.cargo/registry/index\n+            ~/.cargo/registry/cache\n+            ~/.cargo/git/db\n+            # contains package information of crates installed via `cargo install`.\n+            ~/.cargo/.crates.toml\n+            ~/.cargo/.crates2.json\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+          restore-keys: ${{ runner.os }}-cargo\n+\n+      - name: Install rustup-toolchain-install-master\n+        if: ${{ steps.cache.outputs.cache-hit != 'true' }}\n+        shell: bash\n+        run: |\n+          cargo install -f rustup-toolchain-install-master\n+\n+      - name: Install \"master\" toolchain\n+        shell: bash\n         run: |\n-          cargo install rustup-toolchain-install-master # TODO: cache this?\n           ./rustup-toolchain \"\" -c clippy\n+\n+      - name: Show Rust version\n+        run: |\n+          rustup show\n+          rustc -Vv\n+          cargo -V\n+\n       - name: rustfmt\n         run: ./miri fmt --check\n       - name: clippy"}, {"sha": "b1e6b9c69d390846500fd6c4eaf5708fc76b697f", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -104,7 +104,7 @@ MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows ./miri run tests/pass/v\n In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n evaluation error was originally raised.\n \n-#### UI testing\n+### UI testing\n \n We use ui-testing in Miri, meaning we generate `.stderr` and `.stdout` files for the output\n produced by Miri. You can use `./miri bless` to automatically (re)generate these files when\n@@ -257,7 +257,7 @@ Note: When you are working with a locally built rustc or any other toolchain tha\n is not the same as the one in `rust-version`, you should not have `.auto-everything` or\n `.auto-toolchain` as that will keep resetting your toolchain.\n \n-```\n+```sh\n rm -f .auto-everything .auto-toolchain\n ```\n \n@@ -275,3 +275,51 @@ see <https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html>.\n \n With this, you should now have a working development setup! See\n [above](#building-and-testing-miri) for how to proceed working on Miri.\n+\n+## Advanced topic: Syncing with the rustc repo\n+\n+We use the [`josh` proxy](https://github.com/josh-project/josh) to transmit\n+changes between the rustc and Miri repositories. For now, a fork of josh needs to be built\n+from source. This downloads and runs josh:\n+\n+```sh\n+git clone https://github.com/RalfJung/josh\n+cd josh\n+cargo run --release -p josh-proxy -- --local=$(pwd)/local --remote=https://github.com --no-background\n+```\n+\n+### Importing changes from the rustc repo\n+\n+We assume we start on an up-to-date master branch in the Miri repo.\n+\n+```sh\n+# Fetch rustc side of the history. Takes ca 5 min the first time.\n+# Do NOT change that commit ID, it needs to be exactly this!\n+git fetch http://localhost:8000/rust-lang/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git master\n+# Include that history into ours.\n+git merge FETCH_HEAD -m \"merge rustc history\"\n+# Update toolchain reference and apply formatting.\n+./rustup-toolchain HEAD && ./miri fmt\n+git commit -am \"rustup\"\n+```\n+\n+Now push this to a new branch in your Miri fork, and create a PR. It is worth\n+running `./miri test` locally in parallel, since the test suite in the Miri repo\n+is stricter than the one on the rustc side, so some small tweaks might be\n+needed.\n+\n+### Exporting changes to the rustc repo\n+\n+We will use the josh proxy to push to your fork of rustc. You need to make sure\n+that the master branch of your fork is up-to-date. Also make sure that there\n+exists no branch called `miri` in your fork. Then run the following in the Miri\n+repo, assuming we are on an up-to-date master branch:\n+\n+```sh\n+# Push the Miri changes to your rustc fork (substitute your github handle for YOUR_NAME).\n+# Do NOT change that commit ID, it needs to be exactly this!\n+git push http://localhost:8000/YOUR_NAME/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git -o base=master HEAD:miri\n+```\n+\n+This will create a new branch in your fork, and the output should include a link\n+to create a rustc PR that will integrate those changes into the main repository."}, {"sha": "343cf0eaba251909ece7027622096f321492a61f", "filename": "src/tools/miri/Cargo.lock", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -320,9 +320,9 @@ dependencies = [\n \n [[package]]\n name = \"libffi-sys\"\n-version = \"2.0.0\"\n+version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab4106b7f09d7b87d021334d5618fac1dfcfb824d4c5fe111ff0074dfd242e15\"\n+checksum = \"84e78d02e5a8eae9c24c38ce6e6026f80e16dff76adcdae4bc5c6c52c2de4a60\"\n dependencies = [\n  \"cc\",\n ]\n@@ -419,6 +419,7 @@ dependencies = [\n  \"rand\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n+ \"rustc_version\",\n  \"shell-escape\",\n  \"smallvec\",\n  \"ui_test\","}, {"sha": "02485dab74c5b87cc59b7a0c7da96783f8b0502d", "filename": "src/tools/miri/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -31,14 +31,17 @@ smallvec = \"1.7\"\n rustc-workspace-hack = \"1.0.0\"\n measureme = \"10.0.0\"\n \n-[target.\"cfg(unix)\".dependencies]\n+[target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n+\n+[target.'cfg(target_os = \"linux\")'.dependencies]\n libffi = \"3.0.0\"\n libloading = \"0.7\"\n \n [dev-dependencies]\n colored = \"2\"\n ui_test = \"0.3.1\"\n+rustc_version = \"0.4\"\n # Features chosen to match those required by env_logger, to avoid rebuilds\n regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }\n lazy_static = \"1.4.0\""}, {"sha": "81c4f5ffef4ecaa733e2fb602c43b9448608769a", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -377,6 +377,11 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n   This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n   and in particular, they are protected when passed as function arguments.\n+* `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n+  fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n+  recurses (the default), `scalar` means it only recurses for types where we would also emit\n+  `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n+  scalars).\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to\n   `0` disables the garbage collector, which causes some programs to have explosive memory usage\n@@ -435,11 +440,10 @@ Moreover, Miri recognizes some environment variables:\n   purpose.\n * `MIRI_NO_STD` (recognized by `cargo miri` and the test suite) makes sure that the target's\n   sysroot is built without libstd. This allows testing and running no_std programs.\n-* `MIRI_BLESS` (recognized by the test suite) overwrite all `stderr` and `stdout` files\n-  instead of checking whether the output matches.\n-* `MIRI_SKIP_UI_CHECKS` (recognized by the test suite) don't check whether the\n-  `stderr` or `stdout` files match the actual output. Useful for the rustc test suite\n-  which has subtle differences that we don't care about.\n+* `MIRI_BLESS` (recognized by the test suite and `cargo-miri-test/run-test.py`): overwrite all\n+  `stderr` and `stdout` files instead of checking whether the output matches.\n+* `MIRI_SKIP_UI_CHECKS` (recognized by the test suite): don't check whether the\n+  `stderr` or `stdout` files match the actual output.\n \n The following environment variables are *internal* and must not be used by\n anyone but Miri itself. They are used to communicate between different Miri\n@@ -532,6 +536,27 @@ extern \"Rust\" {\n     /// This is internal and unstable and should not be used; we give it here\n     /// just to be complete.\n     fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Miri-provided extern function to get the internal unique identifier for the allocation that a pointer\n+    /// points to. This is only useful as an input to `miri_print_stacks`, and it is a separate call because\n+    /// getting a pointer to an allocation at runtime can change the borrow stacks in the allocation.\n+    fn miri_get_alloc_id(ptr: *const ()) -> u64;\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the program) the contents of all\n+    /// borrow stacks in an allocation. The format of what this emits is unstable and may change at any time.\n+    /// In particular, users should be aware that Miri will periodically attempt to garbage collect the\n+    /// contents of all stacks. Callers of this function may wish to pass `-Zmiri-tag-gc=0` to disable the GC.\n+    fn miri_print_stacks(alloc_id: u64);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stdout.\n+    fn miri_write_to_stdout(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stderr.\n+    fn miri_write_to_stderr(bytes: &[u8]);\n }\n ```\n "}, {"sha": "83c04b9dd5f57997e538267464f1f3e80e64318c", "filename": "src/tools/miri/bench-cargo-miri/serde2/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -5,6 +5,7 @@ use serde::Deserialize;\n use std::thread;\n \n #[derive(Deserialize)]\n+#[allow(unused)]\n struct DeriveStruct {\n     buffer: Vec<i16>,\n }"}, {"sha": "eb0301bee2ac64f25a8f564fe8c479a03d434d4e", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1 +1 @@\n-acb8934fd57b3c2740c4abac0a5728c2c9b1423b\n+b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84"}, {"sha": "2e114c71d662aa86adc5ef14135cb24ae7d6b2b3", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::{\n };\n use rustc_session::{config::CrateType, search_paths::PathKind, CtfeBacktrace};\n \n-use miri::{BacktraceStyle, ProvenanceMode};\n+use miri::{BacktraceStyle, ProvenanceMode, RetagFields};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n@@ -426,7 +426,14 @@ fn main() {\n         } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n             miri_config.mute_stdout_stderr = true;\n         } else if arg == \"-Zmiri-retag-fields\" {\n-            miri_config.retag_fields = true;\n+            miri_config.retag_fields = RetagFields::Yes;\n+        } else if let Some(retag_fields) = arg.strip_prefix(\"-Zmiri-retag-fields=\") {\n+            miri_config.retag_fields = match retag_fields {\n+                \"all\" => RetagFields::Yes,\n+                \"none\" => RetagFields::No,\n+                \"scalar\" => RetagFields::OnlyScalar,\n+                _ => show_error!(\"`-Zmiri-retag-fields` can only be `all`, `none`, or `scalar`\"),\n+            };\n         } else if arg == \"-Zmiri-track-raw-pointers\" {\n             eprintln!(\n                 \"WARNING: `-Zmiri-track-raw-pointers` has no effect; it is enabled by default\""}, {"sha": "791931901e2a96765ba3ca11f8cce9cf33cfe03e", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,204 @@\n+use std::collections::VecDeque;\n+use std::num::NonZeroU32;\n+\n+use rustc_index::vec::Idx;\n+\n+use super::sync::EvalContextExtPriv;\n+use super::thread::MachineCallback;\n+use super::vector_clock::VClock;\n+use crate::*;\n+\n+declare_id!(InitOnceId);\n+\n+/// A thread waiting on an InitOnce object.\n+struct InitOnceWaiter<'mir, 'tcx> {\n+    /// The thread that is waiting.\n+    thread: ThreadId,\n+    /// The callback that should be executed, after the thread has been woken up.\n+    callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"InitOnce\")\n+            .field(\"thread\", &self.thread)\n+            .field(\"callback\", &\"dyn MachineCallback\")\n+            .finish()\n+    }\n+}\n+\n+#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\n+/// The current status of a one time initialization.\n+pub enum InitOnceStatus {\n+    #[default]\n+    Uninitialized,\n+    Begun,\n+    Complete,\n+}\n+\n+/// The one time initialization state.\n+#[derive(Default, Debug)]\n+pub(super) struct InitOnce<'mir, 'tcx> {\n+    status: InitOnceStatus,\n+    waiters: VecDeque<InitOnceWaiter<'mir, 'tcx>>,\n+    data_race: VClock,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for waiter in self.waiters.iter() {\n+            waiter.callback.visit_tags(visit);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn init_once_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, InitOnceId> {\n+        let this = self.eval_context_mut();\n+        this.init_once_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    /// Provides the closure with the next InitOnceId. Creates that InitOnce if the closure returns None,\n+    /// otherwise returns the value from the closure.\n+    #[inline]\n+    fn init_once_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, InitOnceId>\n+    where\n+        F: FnOnce(\n+            &mut MiriInterpCx<'mir, 'tcx>,\n+            InitOnceId,\n+        ) -> InterpResult<'tcx, Option<InitOnceId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.init_onces.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.init_onces.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_status(&mut self, id: InitOnceId) -> InitOnceStatus {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.init_onces[id].status\n+    }\n+\n+    /// Put the thread into the queue waiting for the initialization.\n+    #[inline]\n+    fn init_once_enqueue_and_block(\n+        &mut self,\n+        id: InitOnceId,\n+        thread: ThreadId,\n+        callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+    ) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_ne!(init_once.status, InitOnceStatus::Complete, \"queueing on complete init once\");\n+        init_once.waiters.push_back(InitOnceWaiter { thread, callback });\n+        this.block_thread(thread);\n+    }\n+\n+    /// Begin initializing this InitOnce. Must only be called after checking that it is currently\n+    /// uninitialized.\n+    #[inline]\n+    fn init_once_begin(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Uninitialized,\n+            \"begining already begun or complete init once\"\n+        );\n+        init_once.status = InitOnceStatus::Begun;\n+    }\n+\n+    #[inline]\n+    fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"completing already complete or uninit init once\"\n+        );\n+\n+        init_once.status = InitOnceStatus::Complete;\n+\n+        // Each complete happens-before the end of the wait\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up everyone.\n+        // need to take the queue to avoid having `this` be borrowed multiple times\n+        for waiter in std::mem::take(&mut init_once.waiters) {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"failing already completed or uninit init once\"\n+        );\n+\n+        // Each complete happens-before the end of the wait\n+        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n+        // but the docs don't talk about such details.\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up one waiting thread, so they can go ahead and try to init this.\n+        if let Some(waiter) = init_once.waiters.pop_front() {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        } else {\n+            // Nobody there to take this, so go back to 'uninit'\n+            init_once.status = InitOnceStatus::Uninitialized;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "45903107f17104d86585317e4b803d3c9bbd1014", "filename": "src/tools/miri/src/concurrency/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,6 +1,8 @@\n pub mod data_race;\n mod range_object_map;\n+#[macro_use]\n pub mod sync;\n+pub mod init_once;\n pub mod thread;\n mod vector_clock;\n pub mod weak_memory;"}, {"sha": "e76610e7302804c76478e49f9389df4473863ee7", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -7,9 +7,15 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n \n+use super::init_once::InitOnce;\n use super::vector_clock::VClock;\n use crate::*;\n \n+pub trait SyncId {\n+    fn from_u32(id: u32) -> Self;\n+    fn to_u32(&self) -> u32;\n+}\n+\n /// We cannot use the `newtype_index!` macro because we have to use 0 as a\n /// sentinel value meaning that the identifier is not assigned. This is because\n /// the pthreads static initializers initialize memory with zeros (see the\n@@ -21,11 +27,14 @@ macro_rules! declare_id {\n         #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n         pub struct $name(NonZeroU32);\n \n-        impl $name {\n+        impl SyncId for $name {\n             // Panics if `id == 0`.\n-            pub fn from_u32(id: u32) -> Self {\n+            fn from_u32(id: u32) -> Self {\n                 Self(NonZeroU32::new(id).unwrap())\n             }\n+            fn to_u32(&self) -> u32 {\n+                self.0.get()\n+            }\n         }\n \n         impl Idx for $name {\n@@ -151,16 +160,58 @@ struct FutexWaiter {\n \n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n-pub(crate) struct SynchronizationState {\n+pub(crate) struct SynchronizationState<'mir, 'tcx> {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n     futexes: FxHashMap<u64, Futex>,\n+    pub(super) init_onces: IndexVec<InitOnceId, InitOnce<'mir, 'tcx>>,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for init_once in self.init_onces.iter() {\n+            init_once.visit_tags(visit);\n+        }\n+    }\n }\n \n // Private extension trait for local helper methods\n impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n+    crate::MiriInterpCxExt<'mir, 'tcx>\n+{\n+    #[inline]\n+    // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n+    fn get_or_create_id<Id: SyncId>(\n+        &mut self,\n+        next_id: Id,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, Option<Id>> {\n+        let this = self.eval_context_mut();\n+        let value_place =\n+            this.deref_operand_and_offset(lock_op, offset, this.machine.layouts.u32)?;\n+\n+        let (old, success) = this\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n+                Scalar::from_u32(next_id.to_u32()),\n+                AtomicRwOrd::Relaxed, // deliberately *no* synchronization\n+                AtomicReadOrd::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair();\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(Id::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    }\n+\n     /// Take a reader out of the queue waiting for the lock.\n     /// Returns `true` if some thread got the rwlock.\n     #[inline]\n@@ -210,11 +261,31 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n // situations.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    #[inline]\n-    /// Create state for a new mutex.\n-    fn mutex_create(&mut self) -> MutexId {\n+    fn mutex_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, MutexId> {\n+        let this = self.eval_context_mut();\n+        this.mutex_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    fn rwlock_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, RwLockId> {\n+        let this = self.eval_context_mut();\n+        this.rwlock_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    fn condvar_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, CondvarId> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.mutexes.push(Default::default())\n+        this.condvar_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n     }\n \n     #[inline]\n@@ -301,25 +372,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the thread into the queue waiting for the mutex.\n+    #[inline]\n     fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n         this.block_thread(thread);\n     }\n \n-    #[inline]\n-    /// Create state for a new read write lock.\n-    fn rwlock_create(&mut self) -> RwLockId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n     where\n         F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, RwLockId) -> InterpResult<'tcx, Option<RwLockId>>,\n@@ -349,8 +413,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         rwlock.writer.is_some() || rwlock.readers.is_empty().not()\n     }\n \n-    #[inline]\n     /// Check if write locked.\n+    #[inline]\n     fn rwlock_is_write_locked(&self, id: RwLockId) -> bool {\n         let this = self.eval_context_ref();\n         let rwlock = &this.machine.threads.sync.rwlocks[id];\n@@ -407,17 +471,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         true\n     }\n \n-    #[inline]\n     /// Put the reader in the queue waiting for the lock and block it.\n+    #[inline]\n     fn rwlock_enqueue_and_block_reader(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n         this.block_thread(reader);\n     }\n \n-    #[inline]\n     /// Lock by setting the writer that owns the lock.\n+    #[inline]\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n@@ -429,8 +493,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Try to unlock by removing the writer.\n+    #[inline]\n     fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n@@ -467,25 +531,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the writer in the queue waiting for the lock.\n+    #[inline]\n     fn rwlock_enqueue_and_block_writer(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n         this.block_thread(writer);\n     }\n \n-    #[inline]\n-    /// Create state for a new conditional variable.\n-    fn condvar_create(&mut self) -> CondvarId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.condvars.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n     where\n         F: FnOnce(\n@@ -504,8 +561,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Is the conditional variable awaited?\n+    #[inline]\n     fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {\n         let this = self.eval_context_mut();\n         !this.machine.threads.sync.condvars[id].waiters.is_empty()"}, {"sha": "3432f10f7a925fc58e3605f5be93dca7f9cc0852", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -30,8 +30,7 @@ pub enum SchedulingAction {\n     Stop,\n }\n \n-/// Timeout callbacks can be created by synchronization primitives to tell the\n-/// scheduler that they should be called once some period of time passes.\n+/// Trait for callbacks that can be executed when some event happens, such as after a timeout.\n pub trait MachineCallback<'mir, 'tcx>: VisitTags {\n     fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n }\n@@ -269,7 +268,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n     /// This field is pub(crate) because the synchronization primitives\n     /// (`crate::sync`) need a way to access it.\n-    pub(crate) sync: SynchronizationState,\n+    pub(crate) sync: SynchronizationState<'mir, 'tcx>,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n     thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Provenance>>>,\n@@ -303,7 +302,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n             timeout_callbacks,\n             active_thread: _,\n             yield_active_thread: _,\n-            sync: _,\n+            sync,\n         } = self;\n \n         for thread in threads {\n@@ -315,6 +314,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n         for callback in timeout_callbacks.values() {\n             callback.callback.visit_tags(visit);\n         }\n+        sync.visit_tags(visit);\n     }\n }\n "}, {"sha": "f2a36572954948d4b888ac05e0b38fecf263bac3", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -17,7 +17,7 @@\n //! load to the first, as a result of C++20's coherence-ordered before rules.\n //!\n //! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n-//! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n+//! `std::atomic<T>` API). It is therefore possible for this implementation to generate behaviours never observable when the\n //! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n //! an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n //! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (<https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf>)"}, {"sha": "a3fc343f8b67ce5c24554760c1135876260d6e50", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -126,7 +126,7 @@ pub struct MiriConfig {\n     /// Report the current instruction being executed every N basic blocks.\n     pub report_progress: Option<u32>,\n     /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n-    pub retag_fields: bool,\n+    pub retag_fields: RetagFields,\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n@@ -163,7 +163,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n-            retag_fields: false,\n+            retag_fields: RetagFields::No,\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,"}, {"sha": "21e65bb1b706e1d2c4d97065c149f9f1ea84f15e", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -9,6 +9,7 @@\n #![feature(is_some_and)]\n #![feature(nonzero_ops)]\n #![feature(local_key_cell_methods)]\n+#![feature(is_terminal)]\n // Configure clippy and other lints\n #![allow(\n     clippy::collapsible_else_if,\n@@ -26,6 +27,7 @@\n     clippy::type_complexity,\n     clippy::single_element_loop,\n     clippy::needless_return,\n+    clippy::bool_to_int_with_if,\n     // We are not implementing queries here so it's fine\n     rustc::potential_query_instability\n )]\n@@ -82,34 +84,28 @@ pub use crate::shims::EvalContextExt as _;\n \n pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n-    data_race::{\n-        AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n-        EvalContextExt as DataRaceEvalContextExt,\n-    },\n-    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n-    thread::{\n-        EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n-        ThreadState, Time,\n-    },\n+    data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n+    init_once::{EvalContextExt as _, InitOnceId},\n+    sync::{CondvarId, EvalContextExt as _, MutexId, RwLockId, SyncId},\n+    thread::{EvalContextExt as _, SchedulingAction, ThreadId, ThreadManager, ThreadState, Time},\n };\n pub use crate::diagnostics::{\n-    report_error, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n-    TerminationInfo,\n+    report_error, EvalContextExt as _, NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n+pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n     ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n-pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n+pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n+    CallId, EvalContextExt as _, Item, Permission, RetagFields, SbTag, Stack, Stacks,\n };\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n "}, {"sha": "fc9a1170d2942fa6d7a0004012b56774f9d7ff22", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -421,8 +421,10 @@ pub struct MiriMachine<'mir, 'tcx> {\n     pub(crate) basic_block_count: u64,\n \n     /// Handle of the optional shared object file for external functions.\n-    #[cfg(unix)]\n+    #[cfg(target_os = \"linux\")]\n     pub external_so_lib: Option<(libloading::Library, std::path::PathBuf)>,\n+    #[cfg(not(target_os = \"linux\"))]\n+    pub external_so_lib: Option<!>,\n \n     /// Run a garbage collector for SbTags every N basic blocks.\n     pub(crate) gc_interval: u32,\n@@ -485,7 +487,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             report_progress: config.report_progress,\n             basic_block_count: 0,\n             clock: Clock::new(config.isolated_op == IsolatedOp::Allow),\n-            #[cfg(unix)]\n+            #[cfg(target_os = \"linux\")]\n             external_so_lib: config.external_so_file.as_ref().map(|lib_file_path| {\n                 let target_triple = layout_cx.tcx.sess.opts.target_triple.triple();\n                 // Check if host target == the session target.\n@@ -507,6 +509,10 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n                     lib_file_path.clone(),\n                 )\n             }),\n+            #[cfg(not(target_os = \"linux\"))]\n+            external_so_lib: config.external_so_file.as_ref().map(|_| {\n+                panic!(\"loading external .so files is only supported on Linux\")\n+            }),\n             gc_interval: config.gc_interval,\n             since_gc: 0,\n             num_cpus: config.num_cpus,\n@@ -648,7 +654,6 @@ impl VisitTags for MiriMachine<'_, '_> {\n             preemption_rate: _,\n             report_progress: _,\n             basic_block_count: _,\n-            #[cfg(unix)]\n             external_so_lib: _,\n             gc_interval: _,\n             since_gc: _,"}, {"sha": "4742a365ec38bc3dd205411ef1c957a9735381ad", "filename": "src/tools/miri/src/range_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -91,6 +91,10 @@ impl<T> RangeMap<T> {\n         self.v.iter_mut().map(|elem| &mut elem.data)\n     }\n \n+    pub fn iter_all(&self) -> impl Iterator<Item = (ops::Range<u64>, &T)> {\n+        self.v.iter().map(|elem| (elem.range.clone(), &elem.data))\n+    }\n+\n     // Splits the element situated at the given `index`, such that the 2nd one starts at offset\n     // `split_offset`. Do nothing if the element already starts there.\n     // Returns whether a split was necessary."}, {"sha": "bf6c1f8756290528017b55b3204fc546f99479d1", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -144,7 +144,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         name_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n         buf_op: &OpTy<'tcx, Provenance>,  // LPWSTR\n         size_op: &OpTy<'tcx, Provenance>, // DWORD\n-    ) -> InterpResult<'tcx, u32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         // ^ Returns DWORD (u32 on Windows)\n \n         let this = self.eval_context_mut();\n@@ -165,12 +165,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let buf_ptr = this.read_pointer(buf_op)?;\n                 // `buf_size` represents the size in characters.\n                 let buf_size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n-                windows_check_buffer_size(this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?)\n+                Scalar::from_u32(windows_check_buffer_size(\n+                    this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?,\n+                ))\n             }\n             None => {\n                 let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\")?;\n                 this.set_last_error(envvar_not_found)?;\n-                0 // return zero upon failure\n+                Scalar::from_u32(0) // return zero upon failure\n             }\n         })\n     }\n@@ -200,14 +202,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn FreeEnvironmentStringsW(\n         &mut self,\n         env_block_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n         let env_block_ptr = this.read_pointer(env_block_op)?;\n         let result = this.deallocate_ptr(env_block_ptr, None, MiriMemoryKind::Runtime.into());\n         // If the function succeeds, the return value is nonzero.\n-        Ok(i32::from(result.is_ok()))\n+        Ok(Scalar::from_i32(i32::from(result.is_ok())))\n     }\n \n     fn setenv(\n@@ -249,7 +251,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         &mut self,\n         name_op: &OpTy<'tcx, Provenance>,  // LPCWSTR\n         value_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n \n@@ -272,15 +274,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n-            Ok(1) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n-            Ok(1) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         }\n     }\n \n@@ -347,7 +349,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         &mut self,\n         size_op: &OpTy<'tcx, Provenance>, // DWORD\n         buf_op: &OpTy<'tcx, Provenance>,  // LPTSTR\n-    ) -> InterpResult<'tcx, u32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n \n@@ -357,16 +359,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`GetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n-            return Ok(0);\n+            return Ok(Scalar::from_u32(0));\n         }\n \n         // If we cannot get the current directory, we return 0\n         match env::current_dir() {\n             Ok(cwd) =>\n-                return Ok(windows_check_buffer_size(this.write_path_to_wide_str(&cwd, buf, size)?)),\n+                return Ok(Scalar::from_u32(windows_check_buffer_size(\n+                    this.write_path_to_wide_str(&cwd, buf, size)?,\n+                ))),\n             Err(e) => this.set_last_error_from_io_error(e.kind())?,\n         }\n-        Ok(0)\n+        Ok(Scalar::from_u32(0))\n     }\n \n     fn chdir(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n@@ -395,7 +399,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn SetCurrentDirectoryW(\n         &mut self,\n         path_op: &OpTy<'tcx, Provenance>, // LPCTSTR\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         // ^ Returns BOOL (i32 on Windows)\n \n         let this = self.eval_context_mut();\n@@ -407,14 +411,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n-            return Ok(0);\n+            return this.eval_windows(\"c\", \"FALSE\");\n         }\n \n         match env::set_current_dir(path) {\n-            Ok(()) => Ok(1),\n+            Ok(()) => this.eval_windows(\"c\", \"TRUE\"),\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(0)\n+                this.eval_windows(\"c\", \"FALSE\")\n             }\n         }\n     }"}, {"sha": "c5db868cdc7c5879931e6af33913291760a0b052", "filename": "src/tools/miri/src/shims/ffi_support.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -183,9 +183,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // from: https://docs.rs/libloading/0.7.3/src/libloading/os/unix/mod.rs.html#411\n         // using the `libc` crate where this interface is public.\n         // No `libc::dladdr` on windows.\n-        #[cfg(unix)]\n         let mut info = std::mem::MaybeUninit::<libc::Dl_info>::uninit();\n-        #[cfg(unix)]\n         unsafe {\n             if libc::dladdr(*func.deref() as *const _, info.as_mut_ptr()) != 0 {\n                 if std::ffi::CStr::from_ptr(info.assume_init().dli_fname).to_str().unwrap()"}, {"sha": "a49e6ba4ce386911a66146346048781df6df349b", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,4 +1,4 @@\n-use std::{collections::hash_map::Entry, iter};\n+use std::{collections::hash_map::Entry, io::Write, iter};\n \n use log::trace;\n \n@@ -23,8 +23,6 @@ use rustc_target::{\n \n use super::backtrace::EvalContextExt as _;\n use crate::helpers::{convert::Truncate, target_os_is_unix};\n-#[cfg(unix)]\n-use crate::shims::ffi_support::EvalContextExt as _;\n use crate::*;\n \n /// Returned by `emulate_foreign_item_by_name`.\n@@ -372,8 +370,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // First deal with any external C functions in linked .so file.\n-        #[cfg(unix)]\n+        #[cfg(target_os = \"linux\")]\n         if this.machine.external_so_lib.as_ref().is_some() {\n+            use crate::shims::ffi_support::EvalContextExt as _;\n             // An Ok(false) here means that the function being called was not exported\n             // by the specified `.so` file; we should continue and check if it corresponds to\n             // a provided shim.\n@@ -418,6 +417,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // shim, add it to the corresponding submodule.\n         match link_name.as_str() {\n             // Miri-specific extern functions\n+            \"miri_get_alloc_id\" => {\n+                let [ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let (alloc_id, _, _) = this.ptr_get_alloc_id(ptr)?;\n+                this.write_scalar(Scalar::from_u64(alloc_id.0.get()), dest)?;\n+            }\n+            \"miri_print_stacks\" => {\n+                let [id] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let id = this.read_scalar(id)?.to_u64()?;\n+                if let Some(id) = std::num::NonZeroU64::new(id) {\n+                    this.print_stacks(AllocId(id))?;\n+                }\n+            }\n             \"miri_static_root\" => {\n                 let [ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n@@ -450,6 +462,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.handle_miri_resolve_frame_names(abi, link_name, args)?;\n             }\n \n+            // Writes some bytes to the interpreter's stdout/stderr. See the\n+            // README for details.\n+            \"miri_write_to_stdout\" | \"miri_write_to_stderr\" => {\n+                let [bytes] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let (ptr, len) = this.read_immediate(bytes)?.to_scalar_pair();\n+                let ptr = ptr.to_pointer(this)?;\n+                let len = len.to_machine_usize(this)?;\n+                let msg = this.read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(len))?;\n+\n+                // Note: we're ignoring errors writing to host stdout/stderr.\n+                let _ignore = match link_name.as_str() {\n+                    \"miri_write_to_stdout\" => std::io::stdout().write_all(msg),\n+                    \"miri_write_to_stderr\" => std::io::stderr().write_all(msg),\n+                    _ => unreachable!(),\n+                };\n+            }\n+\n             // Standard C allocation\n             \"malloc\" => {\n                 let [size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "dcb99a27668261dc35553f411e5437374bbe9f2a", "filename": "src/tools/miri/src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,7 +1,7 @@\n #![warn(clippy::integer_arithmetic)]\n \n mod backtrace;\n-#[cfg(unix)]\n+#[cfg(target_os = \"linux\")]\n pub mod ffi_support;\n pub mod foreign_items;\n pub mod intrinsics;"}, {"sha": "617f90dfaa59fb602a7940a03c2c1069a9c667b0", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -119,7 +119,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn QueryPerformanceCounter(\n         &mut self,\n         lpPerformanceCount_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceCounter\");\n@@ -134,14 +134,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Scalar::from_i64(qpc),\n             &this.deref_operand(lpPerformanceCount_op)?.into(),\n         )?;\n-        Ok(-1) // return non-zero on success\n+        Ok(Scalar::from_i32(-1)) // return non-zero on success\n     }\n \n     #[allow(non_snake_case)]\n     fn QueryPerformanceFrequency(\n         &mut self,\n         lpFrequency_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceFrequency\");\n@@ -155,7 +155,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Scalar::from_i64(1_000_000_000),\n             &this.deref_operand(lpFrequency_op)?.into(),\n         )?;\n-        Ok(-1) // Return non-zero on success\n+        Ok(Scalar::from_i32(-1)) // Return non-zero on success\n     }\n \n     fn mach_absolute_time(&self) -> InterpResult<'tcx, Scalar<Provenance>> {"}, {"sha": "b0c9d729c9d907b9b153e62363281095a6896535", "filename": "src/tools/miri/src/shims/unix/android/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -42,7 +42,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     );\n                 }\n \n-                let &[ref _sig, ref _func] = check_arg_count(args)?;\n+                let [_sig, _func] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n         }"}, {"sha": "44a433df1e9c0d45f08c11304d8375a7468fa414", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -452,7 +452,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"isatty\" => {\n                 let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.isatty(fd)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"pthread_atfork\" => {\n                 let [prepare, parent, child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "0610f65db113f8f690396bdb5ed4fd82f9b39d36", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -4,7 +4,7 @@ use std::convert::TryInto;\n use std::fs::{\n     read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n };\n-use std::io::{self, ErrorKind, Read, Seek, SeekFrom, Write};\n+use std::io::{self, ErrorKind, IsTerminal, Read, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n use std::time::SystemTime;\n \n@@ -65,6 +65,8 @@ trait FileDescriptor: std::fmt::Debug {\n \n     fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>>;\n \n+    fn is_tty(&self) -> bool;\n+\n     #[cfg(unix)]\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         None\n@@ -143,6 +145,10 @@ impl FileDescriptor for FileHandle {\n         use std::os::unix::io::AsRawFd;\n         Some(self.file.as_raw_fd())\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.file.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stdin {\n@@ -170,6 +176,10 @@ impl FileDescriptor for io::Stdin {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDIN_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stdout {\n@@ -202,6 +212,10 @@ impl FileDescriptor for io::Stdout {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDOUT_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stderr {\n@@ -227,12 +241,16 @@ impl FileDescriptor for io::Stderr {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDERR_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n #[derive(Debug)]\n-struct DummyOutput;\n+struct NullOutput;\n \n-impl FileDescriptor for DummyOutput {\n+impl FileDescriptor for NullOutput {\n     fn name(&self) -> &'static str {\n         \"stderr and stdout\"\n     }\n@@ -247,7 +265,11 @@ impl FileDescriptor for DummyOutput {\n     }\n \n     fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n-        Ok(Box::new(DummyOutput))\n+        Ok(Box::new(NullOutput))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n     }\n }\n \n@@ -267,8 +289,8 @@ impl FileHandler {\n         let mut handles: BTreeMap<_, Box<dyn FileDescriptor>> = BTreeMap::new();\n         handles.insert(0i32, Box::new(io::stdin()));\n         if mute_stdout_stderr {\n-            handles.insert(1i32, Box::new(DummyOutput));\n-            handles.insert(2i32, Box::new(DummyOutput));\n+            handles.insert(1i32, Box::new(NullOutput));\n+            handles.insert(2i32, Box::new(NullOutput));\n         } else {\n             handles.insert(1i32, Box::new(io::stdout()));\n             handles.insert(2i32, Box::new(io::stderr()));\n@@ -1073,23 +1095,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n                 InterpResult::Ok(tup)\n             })\n-            .unwrap_or(Ok((0, 0)))?;\n+            .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (created_sec, created_nsec) = metadata\n             .created\n             .map(|tup| {\n                 mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n                 InterpResult::Ok(tup)\n             })\n-            .unwrap_or(Ok((0, 0)))?;\n+            .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (modified_sec, modified_nsec) = metadata\n             .modified\n             .map(|tup| {\n                 mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n                 InterpResult::Ok(tup)\n             })\n-            .unwrap_or(Ok((0, 0)))?;\n+            .unwrap_or_else(|| Ok((0, 0)))?;\n \n         // Now we write everything to `statxbuf`. We write a zero for the unavailable fields.\n         this.write_int_fields_named(\n@@ -1662,35 +1684,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     #[cfg_attr(not(unix), allow(unused))]\n-    fn isatty(&mut self, miri_fd: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+    fn isatty(\n+        &mut self,\n+        miri_fd: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        #[cfg(unix)]\n+        // \"returns 1 if fd is an open file descriptor referring to a terminal;\n+        // otherwise 0 is returned, and errno is set to indicate the error\"\n         if matches!(this.machine.isolated_op, IsolatedOp::Allow) {\n-            let miri_fd = this.read_scalar(miri_fd)?.to_i32()?;\n-            if let Some(host_fd) =\n-                this.machine.file_handler.handles.get(&miri_fd).and_then(|fd| fd.as_unix_host_fd())\n-            {\n-                // \"returns 1 if fd is an open file descriptor referring to a terminal;\n-                // otherwise 0 is returned, and errno is set to indicate the error\"\n-                // SAFETY: isatty has no preconditions\n-                let is_tty = unsafe { libc::isatty(host_fd) };\n-                if is_tty == 0 {\n-                    let errno = std::io::Error::last_os_error()\n-                        .raw_os_error()\n-                        .map(Scalar::from_i32)\n-                        .unwrap();\n-                    this.set_last_error(errno)?;\n-                }\n-                return Ok(is_tty);\n+            let fd = this.read_scalar(miri_fd)?.to_i32()?;\n+            if this.machine.file_handler.handles.get(&fd).map(|fd| fd.is_tty()) == Some(true) {\n+                return Ok(Scalar::from_i32(1));\n             }\n         }\n-        // We are attemping to use a Unix interface on a non-Unix platform, or we are on a Unix\n-        // platform and the passed file descriptor is not open, or isolation is enabled\n-        // FIXME: It should be possible to emulate this at least on Windows by using\n-        // GetConsoleMode.\n+        // Fallback when the FD was not found or isolation is enabled.\n         let enotty = this.eval_libc(\"ENOTTY\")?;\n         this.set_last_error(enotty)?;\n-        Ok(0)\n+        Ok(Scalar::from_i32(0))\n     }\n \n     fn realpath("}, {"sha": "3e1e34c5dbe7bd3921114afea8fdaed10a1728e6", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 21, "deletions": 98, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -19,6 +19,10 @@ use crate::*;\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n+const MUTEX_ID_OFFSET: u64 = 4;\n+const RWLOCK_ID_OFFSET: u64 = 4;\n+const CONDVAR_ID_OFFSET: u64 = 4;\n+\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: Scalar<Provenance>,\n@@ -108,33 +112,6 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, MutexId> {\n-    let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.mutex_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n \n // Our chosen memory layout for the emulated rwlock (does not have to match the platform layout!):\n@@ -149,33 +126,6 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n-fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_condattr_t\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -232,33 +182,6 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, CondvarId> {\n-    let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.condvar_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n@@ -435,7 +358,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -475,7 +398,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -511,7 +434,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -545,7 +468,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -568,7 +491,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -586,7 +509,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -603,7 +526,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -633,7 +556,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -650,7 +573,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -669,7 +592,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -772,7 +695,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n         }\n@@ -785,7 +708,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n@@ -801,8 +724,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -822,8 +745,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n@@ -899,7 +822,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }"}, {"sha": "184ba997fc861d59beba59b08a0e573dda19193f", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -37,13 +37,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [name, buf, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n-                this.write_scalar(Scalar::from_u32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n                 let [name, value] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n@@ -54,19 +54,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [env_block] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n                 let [size, buf] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n-                this.write_scalar(Scalar::from_u32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n                 let [path] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Allocation\n@@ -218,14 +218,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [lpPerformanceCount] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n                 #[allow(non_snake_case)]\n                 let [lpFrequency] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"Sleep\" => {\n                 let [timeout] =\n@@ -246,7 +246,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"TryAcquireSRWLockExclusive\" => {\n                 let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n-                this.write_scalar(Scalar::from_u8(ret), dest)?;\n+                this.write_scalar(ret, dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n                 let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n@@ -259,7 +259,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"TryAcquireSRWLockShared\" => {\n                 let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n-                this.write_scalar(Scalar::from_u8(ret), dest)?;\n+                this.write_scalar(ret, dest)?;\n+            }\n+            \"InitOnceBeginInitialize\" => {\n+                let [ptr, flags, pending, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceBeginInitialize(ptr, flags, pending, context)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"InitOnceComplete\" => {\n+                let [ptr, flags, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceComplete(ptr, flags, context)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Dynamic symbol loading\n@@ -331,16 +343,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n-            \"GetConsoleMode\" => {\n-                // Windows \"isatty\" (in libtest) needs this, so we fake it.\n-                let [console, mode] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_scalar(console)?.to_machine_isize(this)?;\n-                this.deref_operand(mode)?;\n-                // Indicate an error.\n-                // FIXME: we should set last_error, but to what?\n-                this.write_null(dest)?;\n-            }\n             \"GetStdHandle\" => {\n                 let [which] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n@@ -392,14 +394,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Just fake a HANDLE\n                 // It's fine to not use the Handle type here because its a stub\n-                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n+                this.write_int(1, dest)?;\n             }\n             \"GetModuleHandleA\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n                 let [_lpModuleName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // We need to return something non-null here to make `compat_fn!` work.\n-                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n+                this.write_int(1, dest)?;\n             }\n             \"SetConsoleTextAttribute\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n@@ -408,24 +410,46 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n+            \"GetConsoleMode\" if this.frame_in_std() => {\n+                let [console, mode] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                this.read_scalar(console)?.to_machine_isize(this)?;\n+                this.deref_operand(mode)?;\n+                // Indicate an error.\n+                this.write_null(dest)?;\n+            }\n+            \"GetFileInformationByHandleEx\" if this.frame_in_std() => {\n+                #[allow(non_snake_case)]\n+                let [_hFile, _FileInformationClass, _lpFileInformation, _dwBufferSize] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                // Just make it fail.\n+                this.write_null(dest)?;\n+            }\n+            \"GetFileType\" if this.frame_in_std() => {\n+                #[allow(non_snake_case)]\n+                let [_hFile] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                // Return unknown file type.\n+                this.write_null(dest)?;\n+            }\n             \"AddVectoredExceptionHandler\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n                 let [_First, _Handler] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n-                this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n+                this.write_int(1, dest)?;\n             }\n             \"SetThreadStackGuarantee\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n                 let [_StackSizeInBytes] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n-                this.write_scalar(Scalar::from_u32(1), dest)?;\n+                this.write_int(1, dest)?;\n             }\n             \"GetCurrentProcessId\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentProcessId()?;\n-                this.write_scalar(Scalar::from_u32(result), dest)?;\n+                this.write_int(result, dest)?;\n             }\n             // this is only callable from std because we know that std ignores the return value\n             \"SwitchToThread\" if this.frame_in_std() => {"}, {"sha": "8064ca566755cc9bbc4c219d7563bf5d77e6a3de", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 133, "deletions": 47, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,41 +1,17 @@\n+use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n-// Locks are pointer-sized pieces of data, initialized to 0.\n-// We use the first 4 bytes to store the RwLockId.\n-\n-fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    lock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n-\n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n+const SRWLOCK_ID_OFFSET: u64 = 0;\n+const INIT_ONCE_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -54,28 +30,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockExclusive(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, u8> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n             // Lock is already held.\n-            Ok(0)\n+            Ok(Scalar::from_u8(0))\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n-            Ok(1)\n+            Ok(Scalar::from_u8(1))\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n@@ -88,10 +62,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -103,27 +76,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockShared(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, u8> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n-            Ok(0)\n+            Ok(Scalar::from_u8(0))\n         } else {\n             this.rwlock_reader_lock(id, active_thread);\n-            Ok(1)\n+            Ok(Scalar::from_u8(1))\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n@@ -135,4 +106,119 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn InitOnceBeginInitialize(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        pending_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let pending_place = this.deref_operand(pending_op)?.into();\n+        let context = this.read_pointer(context_op)?;\n+\n+        if flags != 0 {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        match this.init_once_status(id) {\n+            InitOnceStatus::Uninitialized => {\n+                this.init_once_begin(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n+            }\n+            InitOnceStatus::Begun => {\n+                // Someone else is already on it.\n+                // Block this thread until they are done.\n+                // When we are woken up, set the `pending` flag accordingly.\n+                struct Callback<'tcx> {\n+                    init_once_id: InitOnceId,\n+                    pending_place: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { init_once_id: _, pending_place } = self;\n+                        pending_place.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        let pending = match this.init_once_status(self.init_once_id) {\n+                            InitOnceStatus::Uninitialized =>\n+                                unreachable!(\n+                                    \"status should have either been set to begun or complete\"\n+                                ),\n+                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n+                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                        };\n+\n+                        this.write_scalar(pending, &self.pending_place)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n+                this.init_once_enqueue_and_block(\n+                    id,\n+                    active_thread,\n+                    Box::new(Callback { init_once_id: id, pending_place }),\n+                )\n+            }\n+            InitOnceStatus::Complete =>\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+        }\n+\n+        // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn InitOnceComplete(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let context = this.read_pointer(context_op)?;\n+\n+        let success = if flags == 0 {\n+            true\n+        } else if flags == this.eval_windows(\"c\", \"INIT_ONCE_INIT_FAILED\")?.to_u32()? {\n+            false\n+        } else {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        };\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if this.init_once_status(id) != InitOnceStatus::Begun {\n+            // The docs do not say anything about this case, but it seems better to not allow it.\n+            throw_ub_format!(\n+                \"calling InitOnceComplete on a one time initialization that has not begun or is already completed\"\n+            );\n+        }\n+\n+        if success {\n+            this.init_once_complete(id)?;\n+        } else {\n+            this.init_once_fail(id)?;\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n }"}, {"sha": "959e351d1a145b2abc7563d1227d47d0a5d45514", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::ty::{\n     Ty,\n };\n use rustc_span::DUMMY_SP;\n+use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n use smallvec::SmallVec;\n \n@@ -45,6 +46,7 @@ impl SbTag {\n     }\n \n     // The default to be used when SB is disabled\n+    #[allow(clippy::should_implement_trait)]\n     pub fn default() -> Self {\n         Self::new(1).unwrap()\n     }\n@@ -113,7 +115,18 @@ pub struct GlobalStateInner {\n     /// The call ids to trace\n     tracked_call_ids: FxHashSet<CallId>,\n     /// Whether to recurse into datatypes when searching for pointers to retag.\n-    retag_fields: bool,\n+    retag_fields: RetagFields,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum RetagFields {\n+    /// Don't retag any fields.\n+    No,\n+    /// Retag all fields.\n+    Yes,\n+    /// Only retag fields of types with Scalar and ScalarPair layout,\n+    /// to match the LLVM `noalias` we generate.\n+    OnlyScalar,\n }\n \n impl VisitTags for GlobalStateInner {\n@@ -172,7 +185,7 @@ impl GlobalStateInner {\n     pub fn new(\n         tracked_pointer_tags: FxHashSet<SbTag>,\n         tracked_call_ids: FxHashSet<CallId>,\n-        retag_fields: bool,\n+        retag_fields: RetagFields,\n     ) -> Self {\n         GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n@@ -998,7 +1011,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n             kind: RetagKind,\n             retag_cause: RetagCause,\n-            retag_fields: bool,\n+            retag_fields: RetagFields,\n         }\n         impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n             #[inline(always)] // yes this helps in our benchmarks\n@@ -1045,6 +1058,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     return Ok(());\n                 }\n \n+                let recurse_for_fields = || {\n+                    match self.retag_fields {\n+                        RetagFields::No => false,\n+                        RetagFields::Yes => true,\n+                        RetagFields::OnlyScalar => {\n+                            // Matching `ArgAbi::new` at the time of writing, only fields of\n+                            // `Scalar` and `ScalarPair` ABI are considered.\n+                            matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                        }\n+                    }\n+                };\n+\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n                     self.retag_place(place, ref_kind, self.retag_cause, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n@@ -1053,7 +1078,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     // Do *not* recurse into them.\n                     // (No need to worry about wide references, those always \"qualify\". And Boxes\n                     // are handles specially by the visitor anyway.)\n-                } else if self.retag_fields\n+                } else if recurse_for_fields()\n                     || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n                 {\n                     // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`.\n@@ -1122,4 +1147,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n         Ok(())\n     }\n+\n+    fn print_stacks(&mut self, alloc_id: AllocId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let stacks = alloc_extra.stacked_borrows.as_ref().unwrap().borrow();\n+        for (range, stack) in stacks.stacks.iter_all() {\n+            print!(\"{:?}: [\", range);\n+            for i in 0..stack.len() {\n+                let item = stack.get(i).unwrap();\n+                print!(\" {:?}{:?}\", item.perm(), item.tag());\n+            }\n+            println!(\" ]\");\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "aa549e34c5f65cf5d07421c820731a96b9617d76", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -43,10 +43,14 @@ impl Stack {\n     pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n         let mut first_removed = None;\n \n-        // For stacks with a known bottom, we never consider removing the bottom-most tag, because\n-        // that is the base tag which exists whether or not there are any pointers to the\n-        // allocation.\n-        let mut read_idx = if self.unknown_bottom.is_some() { 0 } else { 1 };\n+        // We never consider removing the bottom-most tag. For stacks without an unknown\n+        // bottom this preserves the base tag.\n+        // Note that the algorithm below is based on considering the tag at read_idx - 1,\n+        // so precisely considering the tag at index 0 for removal when we have an unknown\n+        // bottom would complicate the implementation. The simplification of not considering\n+        // it does not have a significant impact on the degree to which the GC mititages\n+        // memory growth.\n+        let mut read_idx = 1;\n         let mut write_idx = read_idx;\n         while read_idx < self.borrows.len() {\n             let left = self.borrows[read_idx - 1];"}, {"sha": "c611b9c44be9df792b13dede1a94fe61d262d680", "filename": "src/tools/miri/test-cargo-miri/run-test.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -33,10 +33,13 @@ def normalize_stderr(str):\n     return str\n \n def check_output(actual, path, name):\n+    if 'MIRI_BLESS' in os.environ:\n+        open(path, mode='w').write(actual)\n+        return True\n     expected = open(path).read()\n     if expected == actual:\n         return True\n-    print(f\"{path} did not match reference!\")\n+    print(f\"{name} output did not match reference in {path}!\")\n     print(f\"--- BEGIN diff {name} ---\")\n     for text in difflib.unified_diff(expected.split(\"\\n\"), actual.split(\"\\n\")):\n         print(text)"}, {"sha": "65fd7c2eccb53a8ade87ed7e54a63e080dd1c75d", "filename": "src/tools/miri/tests/compiletest.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -8,6 +8,12 @@ fn miri_path() -> PathBuf {\n     PathBuf::from(option_env!(\"MIRI\").unwrap_or(env!(\"CARGO_BIN_EXE_miri\")))\n }\n \n+fn get_host() -> String {\n+    rustc_version::VersionMeta::for_command(std::process::Command::new(miri_path()))\n+        .expect(\"failed to parse rustc version info\")\n+        .host\n+}\n+\n // Build the shared object file for testing external C function calls.\n fn build_so_for_c_ffi_tests() -> PathBuf {\n     let cc = option_env!(\"CC\").unwrap_or(\"cc\");\n@@ -37,14 +43,9 @@ fn build_so_for_c_ffi_tests() -> PathBuf {\n     so_file_path\n }\n \n-fn run_tests(\n-    mode: Mode,\n-    path: &str,\n-    target: Option<String>,\n-    with_dependencies: bool,\n-) -> Result<()> {\n+fn run_tests(mode: Mode, path: &str, target: &str, with_dependencies: bool) -> Result<()> {\n     let mut config = Config {\n-        target,\n+        target: Some(target.to_owned()),\n         stderr_filters: STDERR.clone(),\n         stdout_filters: STDOUT.clone(),\n         root_dir: PathBuf::from(path),\n@@ -138,6 +139,8 @@ regexes! {\n     STDOUT:\n     // Windows file paths\n     r\"\\\\\"                           => \"/\",\n+    // erase Stacked Borrows tags\n+    \"<[0-9]+>\"                      => \"<TAG>\",\n }\n \n regexes! {\n@@ -179,13 +182,8 @@ enum Dependencies {\n \n use Dependencies::*;\n \n-fn ui(mode: Mode, path: &str, with_dependencies: Dependencies) -> Result<()> {\n-    let target = get_target();\n-\n-    let msg = format!(\n-        \"## Running ui tests in {path} against miri for {}\",\n-        target.as_deref().unwrap_or(\"host\")\n-    );\n+fn ui(mode: Mode, path: &str, target: &str, with_dependencies: Dependencies) -> Result<()> {\n+    let msg = format!(\"## Running ui tests in {path} against miri for {target}\");\n     eprintln!(\"{}\", msg.green().bold());\n \n     let with_dependencies = match with_dependencies {\n@@ -195,25 +193,31 @@ fn ui(mode: Mode, path: &str, with_dependencies: Dependencies) -> Result<()> {\n     run_tests(mode, path, target, with_dependencies)\n }\n \n-fn get_target() -> Option<String> {\n-    env::var(\"MIRI_TEST_TARGET\").ok()\n+fn get_target() -> String {\n+    env::var(\"MIRI_TEST_TARGET\").ok().unwrap_or_else(get_host)\n }\n \n fn main() -> Result<()> {\n     ui_test::color_eyre::install()?;\n+    let target = get_target();\n \n     // Add a test env var to do environment communication tests.\n     env::set_var(\"MIRI_ENV_VAR_TEST\", \"0\");\n     // Let the tests know where to store temp files (they might run for a different target, which can make this hard to find).\n     env::set_var(\"MIRI_TEMP\", env::temp_dir());\n \n-    ui(Mode::Pass, \"tests/pass\", WithoutDependencies)?;\n-    ui(Mode::Pass, \"tests/pass-dep\", WithDependencies)?;\n-    ui(Mode::Panic, \"tests/panic\", WithDependencies)?;\n-    ui(Mode::Fail { require_patterns: true }, \"tests/fail\", WithDependencies)?;\n+    ui(Mode::Pass, \"tests/pass\", &target, WithoutDependencies)?;\n+    ui(Mode::Pass, \"tests/pass-dep\", &target, WithDependencies)?;\n+    ui(Mode::Panic, \"tests/panic\", &target, WithDependencies)?;\n+    ui(Mode::Fail { require_patterns: true }, \"tests/fail\", &target, WithDependencies)?;\n     if cfg!(target_os = \"linux\") {\n-        ui(Mode::Pass, \"tests/extern-so/pass\", WithoutDependencies)?;\n-        ui(Mode::Fail { require_patterns: true }, \"tests/extern-so/fail\", WithoutDependencies)?;\n+        ui(Mode::Pass, \"tests/extern-so/pass\", &target, WithoutDependencies)?;\n+        ui(\n+            Mode::Fail { require_patterns: true },\n+            \"tests/extern-so/fail\",\n+            &target,\n+            WithoutDependencies,\n+        )?;\n     }\n \n     Ok(())"}, {"sha": "fe9bb3bed7f013e7167668d25db31864a9127ff0", "filename": "src/tools/miri/tests/fail/invalid_bool.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -2,7 +2,6 @@\n // Make sure we find these even with many checks disabled.\n //@compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation\n \n-\n fn main() {\n     let b = unsafe { std::mem::transmute::<u8, bool>(2) };\n     let _x = b == std::hint::black_box(true); //~ ERROR: interpreting an invalid 8-bit value as a bool"}, {"sha": "b6a5c0755701e9388e3cd55f0ed56454b1ffe44a", "filename": "src/tools/miri/tests/fail/panic/no_std.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,41 @@\n+#![feature(lang_items, start, core_intrinsics)]\n+#![no_std]\n+// windows tls dtors go through libstd right now, thus this test\n+// cannot pass. When windows tls dtors go through the special magic\n+// windows linker section, we can run this test on windows again.\n+//@ignore-target-windows\n+\n+// Plumbing to let us use `writeln!` to host stderr:\n+\n+extern \"Rust\" {\n+    fn miri_write_to_stderr(bytes: &[u8]);\n+}\n+\n+struct HostErr;\n+\n+use core::fmt::Write;\n+\n+impl Write for HostErr {\n+    fn write_str(&mut self, s: &str) -> core::fmt::Result {\n+        unsafe {\n+            miri_write_to_stderr(s.as_bytes());\n+        }\n+        Ok(())\n+    }\n+}\n+\n+// Aaaand the test:\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    panic!(\"blarg I am dead\")\n+}\n+\n+#[panic_handler]\n+fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! {\n+    writeln!(HostErr, \"{panic_info}\").ok();\n+    core::intrinsics::abort(); //~ ERROR: the program aborted execution\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {}"}, {"sha": "568b286e1d3bf5733984e3273f00801d74b8282a", "filename": "src/tools/miri/tests/fail/panic/no_std.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.stderr?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,19 @@\n+panicked at 'blarg I am dead', $DIR/no_std.rs:LL:CC\n+error: abnormal termination: the program aborted execution\n+  --> $DIR/no_std.rs:LL:CC\n+   |\n+LL |     core::intrinsics::abort();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the program aborted execution\n+   |\n+   = note: inside `panic_handler` at $DIR/no_std.rs:LL:CC\n+note: inside `start` at RUSTLIB/core/src/panic.rs:LL:CC\n+  --> $DIR/no_std.rs:LL:CC\n+   |\n+LL |     panic!(\"blarg I am dead\")\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "5cefdb08e7879d6816a0d06c5ad0b9a7d2a18a7b", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=scalar\n+//@error-pattern: which is protected\n+struct Newtype<'a>(&'a mut i32, i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we protect references inside structs that are passed as ScalarPair.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr, 0),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "60a8b2a6260ba5c2cdadb53670f5357ce6e81d47", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,44 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+  --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   |\n+LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |     let ptr = Box::into_raw(Box::new(0i32));\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL | fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+   |                          ^^\n+   = note: BACKTRACE:\n+   = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside closure at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |             || drop(Box::from_raw(ptr)),\n+   |                     ^^^^^^^^^^^^^^^^^^\n+note: inside `dealloc_while_running::<[closure@$DIR/newtype_pair_retagging.rs:LL:CC]>` at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |     dealloc();\n+   |     ^^^^^^^^^\n+note: inside `main` at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL | /         dealloc_while_running(\n+LL | |             Newtype(&mut *ptr, 0),\n+LL | |             || drop(Box::from_raw(ptr)),\n+LL | |         )\n+   | |_________^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "bc3883575c333381643c7c2f7eb5459cdd967cb1", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-retag-fields\n+//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n "}, {"sha": "ca8590cc6b3f47f31ebcf3c9125c921377daecf3", "filename": "src/tools/miri/tests/fail/unaligned_pointers/dyn_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -7,7 +7,7 @@ struct MuchAlign;\n \n fn main() {\n     // Try many times as this might work by chance.\n-    for _ in 0..10 {\n+    for _ in 0..20 {\n         let buf = [0u32; 256];\n         // `buf` is sufficiently aligned for `layout.align` on a `dyn Debug`, but not\n         // for the actual alignment required by `MuchAlign`."}, {"sha": "a807200771d62c087c51e9035a8fa5d50bc30f31", "filename": "src/tools/miri/tests/fail/unaligned_pointers/reference_to_packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -11,7 +11,7 @@ struct Foo {\n \n fn main() {\n     // Try many times as this might work by chance.\n-    for _ in 0..10 {\n+    for _ in 0..20 {\n         let foo = Foo { x: 42, y: 99 };\n         let p = &foo.x;\n         let i = *p; //~ERROR: alignment 4 is required"}, {"sha": "3aa8cb492a13c2e0ad920fa43138f26af5f4f2bb", "filename": "src/tools/miri/tests/fail/unaligned_pointers/unaligned_ptr3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -3,7 +3,7 @@\n \n fn main() {\n     // Try many times as this might work by chance.\n-    for _ in 0..10 {\n+    for _ in 0..20 {\n         let x = [2u16, 3, 4, 5]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const *const u8; // cast to ptr-to-ptr, so that we load a ptr\n         // This must fail because alignment is violated. Test specifically for loading pointers,"}, {"sha": "606316120d6e49629217543b9ce3c653e87d2ca5", "filename": "src/tools/miri/tests/fail/unaligned_pointers/unaligned_ptr4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     // (This would be missed if u8 allocations are *always* at odd addresses.)\n     //\n     // Try many times as this might work by chance.\n-    for _ in 0..10 {\n+    for _ in 0..20 {\n         let x = [0u8; 4];\n         let ptr = x.as_ptr().wrapping_offset(1).cast::<u16>();\n         let _val = unsafe { *ptr }; //~ERROR: but alignment"}, {"sha": "eff4237595600364b520087eb737788e872f9f9f", "filename": "src/tools/miri/tests/fail/unaligned_pointers/unaligned_ptr_zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -4,7 +4,7 @@\n \n fn main() {\n     // Try many times as this might work by chance.\n-    for i in 0..10 {\n+    for i in 0..20 {\n         let x = i as u8;\n         let x = &x as *const _ as *const [u32; 0];\n         // This must fail because alignment is violated. Test specifically for loading ZST."}, {"sha": "f1838cf64f7feefbf5d5b0a01f7e8c5e3fe7fd9a", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,28 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n+//@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n+\n+use std::ffi::CString;\n+use std::fs;\n+use std::io::{Error, ErrorKind};\n+\n+fn main() {\n+    // test `fcntl`\n+    unsafe {\n+        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n+    }\n+\n+    // test `readlink`\n+    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n+    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n+    unsafe {\n+        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    }\n+\n+    // test `stat`\n+    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    // check that it is the right kind of `PermissionDenied`\n+    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+}"}, {"sha": "21fcb65243e26160f321b44e3d2df0cad808ea17", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,6 @@\n+warning: `fcntl` was made to return an error due to isolation\n+\n+warning: `readlink` was made to return an error due to isolation\n+\n+warning: `$STAT` was made to return an error due to isolation\n+"}, {"sha": "acf16ecb7e06dff5c69ae9aa4624aa02f80c5d58", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,137 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(io_error_more)]\n+#![feature(io_error_uncategorized)]\n+\n+use std::convert::TryInto;\n+use std::ffi::CString;\n+use std::fs::{canonicalize, remove_file, File};\n+use std::io::{Error, ErrorKind, Write};\n+use std::os::unix::ffi::OsStrExt;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    test_dup_stdout_stderr();\n+    test_canonicalize_too_long();\n+    test_readlink();\n+    test_file_open_unix_allow_two_args();\n+    test_file_open_unix_needs_three_args();\n+    test_file_open_unix_extra_third_arg();\n+}\n+\n+fn tmp() -> PathBuf {\n+    std::env::var(\"MIRI_TEMP\")\n+        .map(|tmp| {\n+            // MIRI_TEMP is set outside of our emulated\n+            // program, so it may have path separators that don't\n+            // correspond to our target platform. We normalize them here\n+            // before constructing a `PathBuf`\n+\n+            #[cfg(windows)]\n+            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n+\n+            #[cfg(not(windows))]\n+            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n+        })\n+        .unwrap_or_else(|_| std::env::temp_dir())\n+}\n+\n+/// Prepare: compute filename and make sure the file does not exist.\n+fn prepare(filename: &str) -> PathBuf {\n+    let path = tmp().join(filename);\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+    path\n+}\n+\n+/// Prepare like above, and also write some initial content to the file.\n+fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n+    let path = prepare(filename);\n+    let mut file = File::create(&path).unwrap();\n+    file.write(content).unwrap();\n+    path\n+}\n+\n+fn test_file_open_unix_allow_two_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n+}\n+\n+fn test_file_open_unix_needs_three_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n+}\n+\n+fn test_file_open_unix_extra_third_arg() {\n+    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n+}\n+\n+fn test_dup_stdout_stderr() {\n+    let bytes = b\"hello dup fd\\n\";\n+    unsafe {\n+        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n+        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n+        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+    }\n+}\n+\n+fn test_canonicalize_too_long() {\n+    // Make sure we get an error for long paths.\n+    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n+    assert!(canonicalize(too_long).is_err());\n+}\n+\n+fn test_readlink() {\n+    let bytes = b\"Hello, World!\\n\";\n+    let path = prepare_with_content(\"miri_test_fs_link_target.txt\", bytes);\n+    let expected_path = path.as_os_str().as_bytes();\n+\n+    let symlink_path = prepare(\"miri_test_fs_symlink.txt\");\n+    std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n+\n+    // Test that the expected string gets written to a buffer of proper\n+    // length, and that a trailing null byte is not written.\n+    let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n+    let symlink_c_ptr = symlink_c_str.as_ptr();\n+\n+    // Make the buf one byte larger than it needs to be,\n+    // and check that the last byte is not overwritten.\n+    let mut large_buf = vec![0xFF; expected_path.len() + 1];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n+    // Check that the resovled path was properly written into the buf.\n+    assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n+    assert_eq!(large_buf.last(), Some(&0xFF));\n+    assert_eq!(res, large_buf.len() as isize - 1);\n+\n+    // Test that the resolved path is truncated if the provided buffer\n+    // is too small.\n+    let mut small_buf = [0u8; 2];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len()) };\n+    assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n+    assert_eq!(res, small_buf.len() as isize);\n+\n+    // Test that we report a proper error for a missing path.\n+    let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n+    let res = unsafe {\n+        libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n+    };\n+    assert_eq!(res, -1);\n+    assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n+}"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stderr"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stdout"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-rsfs.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1 @@\n+hello dup fd"}, {"sha": "2b6e83891d6eae684907f257158057ece130bdf2", "filename": "src/tools/miri/tests/pass/align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -22,7 +22,7 @@ fn align_to() {\n \n fn main() {\n     // Do this a couple times in a loop because it may work \"by chance\".\n-    for _ in 0..10 {\n+    for _ in 0..20 {\n         manual_alignment();\n         align_to();\n     }"}, {"sha": "d3c72c3d028cf70e6b4da81aaa88f3a0226e6169", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,138 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn InitOnceBeginInitialize(\n+        init: *mut *mut c_void,\n+        flags: u32,\n+        pending: *mut i32,\n+        context: *mut c_void,\n+    ) -> i32;\n+\n+    fn InitOnceComplete(init: *mut *mut c_void, flags: u32, context: *mut c_void) -> i32;\n+}\n+\n+const TRUE: i32 = 1;\n+const FALSE: i32 = 0;\n+\n+const INIT_ONCE_INIT_FAILED: u32 = 4;\n+\n+fn single_thread() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+\n+        assert_eq!(InitOnceComplete(&mut init_once, 0, null_mut()), TRUE);\n+\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+    }\n+\n+    let mut init_once = null_mut();\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+\n+        assert_eq!(InitOnceComplete(&mut init_once, INIT_ONCE_INIT_FAILED, null_mut()), TRUE);\n+\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+}\n+\n+fn block_until_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let waiter = move || unsafe {\n+        let mut pending = 0;\n+\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+\n+        println!(\"finished waiting for initialization\");\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on the main thread\n+    thread::yield_now();\n+\n+    println!(\"completing initialization\");\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}\n+\n+fn retry_on_fail() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let waiter = move || unsafe {\n+        let mut pending = 0;\n+\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+\n+        if pending == 1 {\n+            println!(\"retrying initialization\");\n+\n+            assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+        } else {\n+            println!(\"finished waiting for initialization\");\n+        }\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on the main thread\n+    thread::yield_now();\n+\n+    println!(\"failing initialization\");\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, INIT_ONCE_INIT_FAILED, null_mut()), TRUE);\n+    }\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}\n+\n+fn main() {\n+    single_thread();\n+    block_until_complete();\n+    retry_on_fail();\n+}"}, {"sha": "f3d5aad8edce24ea33735f11e88daf70663bdbfa", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,6 @@\n+completing initialization\n+finished waiting for initialization\n+finished waiting for initialization\n+failing initialization\n+retrying initialization\n+finished waiting for initialization"}, {"sha": "ce2114e760a32743f3e9c058a139d8ffadd1eff3", "filename": "src/tools/miri/tests/pass/issues/issue-miri-1909.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-1909.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-1909.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-1909.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,57 @@\n+//@compile-flags: -Zmiri-permissive-provenance\n+#![deny(unsafe_op_in_unsafe_fn)]\n+//! This does some tricky ptr-int-casting.\n+\n+use core::alloc::{GlobalAlloc, Layout};\n+use std::alloc::System;\n+\n+/// # Safety\n+/// `ptr` must be valid for writes of `len` bytes\n+unsafe fn volatile_write_zeroize_mem(ptr: *mut u8, len: usize) {\n+    for i in 0..len {\n+        // ptr as usize + i can't overlow because `ptr` is valid for writes of `len`\n+        let ptr_new: *mut u8 = ((ptr as usize) + i) as *mut u8;\n+        // SAFETY: `ptr` is valid for writes of `len` bytes, so `ptr_new` is valid for a\n+        // byte write\n+        unsafe {\n+            core::ptr::write_volatile(ptr_new, 0u8);\n+        }\n+    }\n+}\n+\n+pub struct ZeroizeAlloc;\n+\n+unsafe impl GlobalAlloc for ZeroizeAlloc {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: uphold by caller\n+        unsafe { System.alloc(layout) }\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        // securely wipe the deallocated memory\n+        // SAFETY: `ptr` is valid for writes of `layout.size()` bytes since it was\n+        // previously successfully allocated (by the safety assumption on this function)\n+        // and not yet deallocated\n+        unsafe {\n+            volatile_write_zeroize_mem(ptr, layout.size());\n+        }\n+        // SAFETY: uphold by caller\n+        unsafe { System.dealloc(ptr, layout) }\n+    }\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: uphold by caller\n+        unsafe { System.alloc_zeroed(layout) }\n+    }\n+}\n+\n+#[global_allocator]\n+static GLOBAL: ZeroizeAlloc = ZeroizeAlloc;\n+\n+fn main() {\n+    let layout = Layout::new::<[u8; 16]>();\n+    let ptr = unsafe { std::alloc::alloc_zeroed(layout) };\n+    unsafe {\n+        std::alloc::dealloc(ptr, layout);\n+    }\n+}"}, {"sha": "a8281d30bac4a61e827ac54dcaab121c44cbe934", "filename": "src/tools/miri/tests/pass/issues/issue-miri-2433.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2433.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,6 +1,8 @@\n #![feature(type_alias_impl_trait)]\n \n-trait T { type Item; }\n+trait T {\n+    type Item;\n+}\n \n type Alias<'a> = impl T<Item = &'a ()>;\n "}, {"sha": "0203edfe1818081962dabce6566d9b0e4d222b44", "filename": "src/tools/miri/tests/pass/no_std.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -5,10 +5,30 @@\n // windows linker section, we can run this test on windows again.\n //@ignore-target-windows\n \n+// Plumbing to let us use `writeln!` to host stdout:\n+\n+extern \"Rust\" {\n+    fn miri_write_to_stdout(bytes: &[u8]);\n+}\n+\n+struct Host;\n+\n+use core::fmt::Write;\n+\n+impl Write for Host {\n+    fn write_str(&mut self, s: &str) -> core::fmt::Result {\n+        unsafe {\n+            miri_write_to_stdout(s.as_bytes());\n+        }\n+        Ok(())\n+    }\n+}\n+\n+// Aaaand the test:\n+\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    for _ in 0..10 {}\n-\n+    writeln!(Host, \"hello, world!\").unwrap();\n     0\n }\n "}, {"sha": "270c611ee72c567bc1b2abec4cbc345bab9f15ba", "filename": "src/tools/miri/tests/pass/no_std.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.stdout?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1 @@\n+hello, world!"}, {"sha": "8fa683085b98bb6fc03cf65dd048a658082e2fb9", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.rs", "status": "renamed", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -2,21 +2,14 @@\n //@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n //@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n \n-use std::ffi::CString;\n use std::fs::{self, File};\n-use std::io::{Error, ErrorKind};\n+use std::io::ErrorKind;\n use std::os::unix;\n \n fn main() {\n     // test `open`\n     assert_eq!(File::create(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n-    // test `fcntl`\n-    unsafe {\n-        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n-    }\n-\n     // test `unlink`\n     assert_eq!(fs::remove_file(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n@@ -26,17 +19,8 @@ fn main() {\n         ErrorKind::PermissionDenied\n     );\n \n-    // test `readlink`\n-    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n-    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n-    unsafe {\n-        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n-    }\n-\n     // test `stat`\n     assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n \n     // test `rename`\n     assert_eq!(fs::rename(\"a.txt\", \"b.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n@@ -49,5 +33,4 @@ fn main() {\n \n     // test `opendir`\n     assert_eq!(fs::read_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n }", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.rs"}, {"sha": "452c5b9b772aa6ad3720957df9eb17dce9ca0849", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.stderr", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -1,13 +1,9 @@\n warning: `open` was made to return an error due to isolation\n \n-warning: `fcntl` was made to return an error due to isolation\n-\n warning: `unlink` was made to return an error due to isolation\n \n warning: `symlink` was made to return an error due to isolation\n \n-warning: `readlink` was made to return an error due to isolation\n-\n warning: `$STAT` was made to return an error due to isolation\n \n warning: `rename` was made to return an error due to isolation", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.stderr"}, {"sha": "65cf6fe66ba5ea4446e2ec72f9f690c849f67626", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "renamed", "additions": 7, "deletions": 99, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -3,14 +3,15 @@\n \n #![feature(io_error_more)]\n #![feature(io_error_uncategorized)]\n+#![feature(is_terminal)]\n \n use std::collections::HashMap;\n-use std::ffi::{CString, OsString};\n+use std::ffi::OsString;\n use std::fs::{\n-    create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename, File,\n-    OpenOptions,\n+    canonicalize, create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename,\n+    File, OpenOptions,\n };\n-use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n+use std::io::{Error, ErrorKind, IsTerminal, Read, Result, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n \n fn main() {\n@@ -26,13 +27,7 @@ fn main() {\n     test_rename();\n     test_directory();\n     test_canonicalize();\n-    test_dup_stdout_stderr();\n     test_from_raw_os_error();\n-\n-    // These all require unix, if the test is changed to no longer `ignore-windows`, move these to a unix test\n-    test_file_open_unix_allow_two_args();\n-    test_file_open_unix_needs_three_args();\n-    test_file_open_unix_extra_third_arg();\n }\n \n fn tmp() -> PathBuf {\n@@ -97,43 +92,12 @@ fn test_file() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    assert!(!file.is_terminal());\n+\n     // Removing file should succeed.\n     remove_file(&path).unwrap();\n }\n \n-fn test_file_open_unix_allow_two_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n-}\n-\n-fn test_file_open_unix_needs_three_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n-}\n-\n-fn test_file_open_unix_extra_third_arg() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n-}\n-\n fn test_file_clone() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare_with_content(\"miri_test_fs_file_clone.txt\", bytes);\n@@ -279,46 +243,6 @@ fn test_symlink() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n-    #[cfg(unix)]\n-    {\n-        use std::os::unix::ffi::OsStrExt;\n-\n-        let expected_path = path.as_os_str().as_bytes();\n-\n-        // Test that the expected string gets written to a buffer of proper\n-        // length, and that a trailing null byte is not written.\n-        let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n-        let symlink_c_ptr = symlink_c_str.as_ptr();\n-\n-        // Make the buf one byte larger than it needs to be,\n-        // and check that the last byte is not overwritten.\n-        let mut large_buf = vec![0xFF; expected_path.len() + 1];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len())\n-        };\n-        // Check that the resovled path was properly written into the buf.\n-        assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n-        assert_eq!(large_buf.last(), Some(&0xFF));\n-        assert_eq!(res, large_buf.len() as isize - 1);\n-\n-        // Test that the resolved path is truncated if the provided buffer\n-        // is too small.\n-        let mut small_buf = [0u8; 2];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n-        assert_eq!(res, small_buf.len() as isize);\n-\n-        // Test that we report a proper error for a missing path.\n-        let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n-        let res = unsafe {\n-            libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(res, -1);\n-        assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n-    }\n-\n     // Test that metadata of a symbolic link (i.e., the file it points to) is correct.\n     check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it.\n@@ -369,7 +293,6 @@ fn test_rename() {\n }\n \n fn test_canonicalize() {\n-    use std::fs::canonicalize;\n     let dir_path = prepare_dir(\"miri_test_fs_dir\");\n     create_dir(&dir_path).unwrap();\n     let path = dir_path.join(\"test_file\");\n@@ -379,11 +302,6 @@ fn test_canonicalize() {\n     assert_eq!(p.to_string_lossy().find('.'), None);\n \n     remove_dir_all(&dir_path).unwrap();\n-\n-    // Make sure we get an error for long paths.\n-    use std::convert::TryInto;\n-    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n-    assert!(canonicalize(too_long).is_err());\n }\n \n fn test_directory() {\n@@ -440,16 +358,6 @@ fn test_directory() {\n     remove_dir_all(&dir_path).unwrap();\n }\n \n-fn test_dup_stdout_stderr() {\n-    let bytes = b\"hello dup fd\\n\";\n-    unsafe {\n-        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n-        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n-        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-    }\n-}\n-\n fn test_from_raw_os_error() {\n     let code = 6; // not a code that std or Miri know\n     let error = Error::from_raw_os_error(code);", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.rs"}, {"sha": "4d43549a930beaf55ca804601075eed06c959011", "filename": "src/tools/miri/tests/pass/shims/io.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,9 @@\n+#![feature(is_terminal)]\n+\n+use std::io::IsTerminal;\n+\n+fn main() {\n+    // We can't really assume that this is truly a terminal, and anyway on Windows Miri will always\n+    // return `false` here, but we can check that the call succeeds.\n+    std::io::stdout().is_terminal();\n+}"}, {"sha": "ddedc19c99980300b5aa3541e7d7185508e77e9d", "filename": "src/tools/miri/tests/pass/stacked-borrows/non_scalar_field_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=scalar\n+\n+struct Newtype<'a>(&'a mut i32, i32, i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that with -Zmiri-retag-fields=scalar, we do *not* retag the fields of `Newtype`.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr, 0, 0),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "8d96a2e1ca9918720dc1cf8b935464e55febf19d", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,29 @@\n+use std::{\n+    alloc::{self, Layout},\n+    mem::ManuallyDrop,\n+};\n+\n+extern \"Rust\" {\n+    fn miri_get_alloc_id(ptr: *const u8) -> u64;\n+    fn miri_print_stacks(alloc_id: u64);\n+}\n+\n+fn main() {\n+    let ptr = unsafe { alloc::alloc(Layout::new::<u8>()) };\n+    let alloc_id = unsafe { miri_get_alloc_id(ptr) };\n+    unsafe { miri_print_stacks(alloc_id) };\n+\n+    assert!(!ptr.is_null());\n+    unsafe { miri_print_stacks(alloc_id) };\n+\n+    unsafe { *ptr = 42 };\n+    unsafe { miri_print_stacks(alloc_id) };\n+\n+    let _b = unsafe { ManuallyDrop::new(Box::from_raw(ptr)) };\n+    unsafe { miri_print_stacks(alloc_id) };\n+\n+    let _ptr = unsafe { &*ptr };\n+    unsafe { miri_print_stacks(alloc_id) };\n+\n+    unsafe { alloc::dealloc(ptr, Layout::new::<u8>()) };\n+}"}, {"sha": "660ee71e6f58bcf48bc60d322cd675bf8996d68b", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,5 @@\n+0..1: [ SharedReadWrite<TAG> ]\n+0..1: [ SharedReadWrite<TAG> ]\n+0..1: [ SharedReadWrite<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]"}, {"sha": "e62ee528686d82438588f8f17274e0a876811ca0", "filename": "src/tools/miri/tests/pass/stacked-borrows/unknown-bottom-gc.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Funknown-bottom-gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d089b41e2a0c0f07ab34f6c5a7c451389f25e6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Funknown-bottom-gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Funknown-bottom-gc.rs?ref=85d089b41e2a0c0f07ab34f6c5a7c451389f25e6", "patch": "@@ -0,0 +1,21 @@\n+//@compile-flags: -Zmiri-permissive-provenance\n+#![feature(strict_provenance)]\n+\n+use std::ptr;\n+\n+fn main() {\n+    let mut v = 1u8;\n+    let ptr = &mut v as *mut u8;\n+\n+    // Expose the allocation and use the exposed pointer, creating an unknown bottom\n+    unsafe {\n+        let p: *mut u8 = ptr::from_exposed_addr::<u8>(ptr.expose_addr()) as *mut u8;\n+        *p = 1;\n+    }\n+\n+    // Pile on a lot of SharedReadOnly at the top of the stack\n+    let r = &v;\n+    for _ in 0..1024 {\n+        let _x = &*r;\n+    }\n+}"}]}