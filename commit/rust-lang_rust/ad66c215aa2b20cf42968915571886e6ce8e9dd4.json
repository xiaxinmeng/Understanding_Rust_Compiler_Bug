{"sha": "ad66c215aa2b20cf42968915571886e6ce8e9dd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNjZjMjE1YWEyYjIwY2Y0Mjk2ODkxNTU3MTg4NmU2Y2U4ZTlkZDQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-25T20:42:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-26T04:34:57Z"}, "message": "rustc: switch most remaining middle::ty functions to methods.", "tree": {"sha": "fa125813ba0f6d61b25356bce1a6001f5a7c7177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa125813ba0f6d61b25356bce1a6001f5a7c7177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad66c215aa2b20cf42968915571886e6ce8e9dd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad66c215aa2b20cf42968915571886e6ce8e9dd4", "html_url": "https://github.com/rust-lang/rust/commit/ad66c215aa2b20cf42968915571886e6ce8e9dd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad66c215aa2b20cf42968915571886e6ce8e9dd4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cedd66a6c37ed04377aeea92db092f343bfe152", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cedd66a6c37ed04377aeea92db092f343bfe152", "html_url": "https://github.com/rust-lang/rust/commit/5cedd66a6c37ed04377aeea92db092f343bfe152"}], "stats": {"total": 7306, "additions": 3516, "deletions": 3790}, "files": [{"sha": "b844717e61388e14e8bfb16cb1526664c3c83f17", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -23,7 +23,6 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::def;\n-use middle::ty::lookup_item_type;\n use middle::ty::{self, Ty};\n use middle::stability;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -133,7 +132,7 @@ pub fn def_to_string(did: DefId) -> String {\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n+    let v = ecx.tcx.item_variances(ast_util::local_def(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -144,8 +143,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              id: ast::NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n-                           &ty::lookup_item_type(ecx.tcx, local_def(id)),\n-                           &ty::lookup_predicates(ecx.tcx, local_def(id)));\n+                           &ecx.tcx.lookup_item_type(local_def(id)),\n+                           &ecx.tcx.lookup_predicates(local_def(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -293,8 +292,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n     let mut disr_val = 0;\n     let mut i = 0;\n-    let vi = ty::enum_variants(ecx.tcx,\n-                               DefId { krate: ast::LOCAL_CRATE, node: id });\n+    let vi = ecx.tcx.enum_variants(local_def(id));\n     for variant in variants {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n@@ -319,7 +317,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         match variant.node.kind {\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n-                let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n+                let fields = ecx.tcx.lookup_struct_fields(def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n                                                  &fields[..],\n@@ -328,9 +326,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n-        if (*vi)[i].disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n-            disr_val = (*vi)[i].disr_val;\n+        let specified_disr_val = vi[i].disr_val;\n+        if specified_disr_val != disr_val {\n+            encode_disr_val(ecx, rbml_w, specified_disr_val);\n+            disr_val = specified_disr_val;\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n \n@@ -379,9 +378,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n                 for &method_did in impl_items.get(base_impl_did).unwrap() {\n-                    let impl_item = ty::impl_or_trait_item(\n-                        ecx.tcx,\n-                        method_did.def_id());\n+                    let impl_item = ecx.tcx.impl_or_trait_item(method_did.def_id());\n                     if let ty::MethodTraitItem(ref m) = impl_item {\n                         encode_reexported_static_method(rbml_w,\n                                                         exp,\n@@ -875,7 +872,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(impl_item) = impl_item_opt {\n         if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n-            let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n+            let scheme = ecx.tcx.lookup_item_type(m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n@@ -923,7 +920,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &ii.attrs);\n     } else {\n         encode_predicates(rbml_w, ecx,\n-                          &ty::lookup_predicates(ecx.tcx, associated_type.def_id),\n+                          &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n \n@@ -995,7 +992,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     assert!(ast_util::is_local(trait_def_id));\n-    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+    let def = ecx.tcx.lookup_trait_def(trait_def_id);\n \n     def.for_each_impl(ecx.tcx, |impl_def_id| {\n         rbml_w.start_tag(tag_items_data_item_extension_impl);\n@@ -1161,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n-        let fields = ty::lookup_struct_fields(tcx, def_id);\n+        let fields = tcx.lookup_struct_fields(def_id);\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n@@ -1220,7 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::impl_trait_ref(tcx, local_def(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(local_def(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1274,7 +1271,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = ty::impl_trait_ref(tcx, local_def(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(local_def(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1298,7 +1295,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n-            match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+            match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n@@ -1333,22 +1330,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        let trait_predicates = ty::lookup_predicates(tcx, def_id);\n+        let trait_def = tcx.lookup_trait_def(def_id);\n+        let trait_predicates = tcx.lookup_predicates(def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_defaulted(rbml_w, ty::trait_has_default_impl(tcx, def_id));\n+        encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n                         tag_item_generics);\n-        encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n+        encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n                 ty::ConstTraitItemId(const_def_id) => {\n@@ -1380,7 +1377,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n \n         // Now output the trait item info for each trait item.\n-        let r = ty::trait_item_def_ids(tcx, def_id);\n+        let r = tcx.trait_item_def_ids(def_id);\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, ast::LOCAL_CRATE);\n \n@@ -1397,7 +1394,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_stability(rbml_w, stab);\n \n             let trait_item_type =\n-                ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+                tcx.impl_or_trait_item(item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n                 ty::ConstTraitItem(associated_const) => {"}, {"sha": "801b3a721e40d614daa4eb5f5856aca01bcb2e89", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n         let fn_ty = match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n-            None => ty::expr_ty_adjusted(self.tcx, func_or_rcvr)\n+            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "62bf1648725cd4c122e523ef8a619a0f6d7b2081", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => ty::empty_parameter_environment(self.tcx)\n+            None => self.tcx.empty_parameter_environment()\n         };\n         f(&mut euv::ExprUseVisitor::new(self, &param_env))\n     }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                                       fn_like.id());\n             self.add_qualif(qualif);\n \n-            if ty::type_contents(self.tcx, ret_ty).interior_unsafe() {\n+            if ret_ty.type_contents(self.tcx).interior_unsafe() {\n                 self.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n \n@@ -266,8 +266,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_mut_type(&self, e: &ast::Expr) {\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-        let tcontents = ty::type_contents(self.tcx, node_ty);\n+        let node_ty = self.tcx.node_id_to_type(e.id);\n+        let tcontents = node_ty.type_contents(self.tcx);\n \n         let suffix = if tcontents.has_dtor() {\n             \"destructors\"\n@@ -282,12 +282,12 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n-        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let ty = self.tcx.node_id_to_type(e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment(self.tcx);\n+        let env = self.tcx.empty_parameter_environment();\n         match fulfill_cx.select_all_or_error(&infcx, &env) {\n             Ok(()) => { },\n             Err(ref errors) => {\n@@ -402,7 +402,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n+        let node_ty = self.tcx.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n \n         // Special-case some expressions to avoid certain flags bubbling up.\n@@ -479,7 +479,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // initializer values (very bad).\n                 // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n-                let tc = ty::type_contents(self.tcx, node_ty);\n+                let tc = node_ty.type_contents(self.tcx);\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n@@ -529,7 +529,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(did, _) |\n-        ty::TyEnum(did, _) if ty::has_dtor(v.tcx, did) => {\n+        ty::TyEnum(did, _) if v.tcx.has_dtor(did) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n@@ -560,7 +560,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprUnary(op, ref inner) => {\n-            match ty::node_id_to_type(v.tcx, inner.id).sty {\n+            match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == ast::UnDeref);\n \n@@ -574,7 +574,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprBinary(op, ref lhs, _) => {\n-            match ty::node_id_to_type(v.tcx, lhs.id).sty {\n+            match v.tcx.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == ast::BiEq || op.node == ast::BiNe ||\n                             op.node == ast::BiLe || op.node == ast::BiLt ||\n@@ -731,7 +731,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n                 v.add_qualif(ConstQualif::NOT_CONST);"}, {"sha": "d2b3b83e4f42f95bcd343ce00ce4e77b384213ad", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -20,7 +20,7 @@ use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::WriteAndRead;\n use middle::expr_use_visitor as euv;\n-use middle::mem_categorization::cmt;\n+use middle::mem_categorization::{cmt, Typer};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n@@ -149,7 +149,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut MatchCheckCtxt {\n         tcx: tcx,\n-        param_env: ty::empty_parameter_environment(tcx),\n+        param_env: tcx.empty_parameter_environment(),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n@@ -203,9 +203,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n+            let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !type_is_empty(cx.tcx, pat_ty) {\n+                if !pat_ty.is_empty(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n                               \"non-exhaustive patterns: type {} is non-empty\",\n@@ -231,11 +231,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n-                let pat_ty = ty::pat_ty(cx.tcx, p);\n+                let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(def_id, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n+                        if cx.tcx.enum_variants(def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n                                 && variant.args.is_empty()\n                         ) {\n@@ -509,12 +509,12 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n                 &Variant(vid) =>\n-                    (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n+                    (vid, cx.tcx.enum_variant_with_id(cid, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, !ty::is_tuple_struct(cx.tcx, cid))\n+                    (cid, !cx.tcx.is_tuple_struct(cid))\n             };\n             if is_structure {\n-                let fields = ty::lookup_struct_fields(cx.tcx, vid);\n+                let fields = cx.tcx.lookup_struct_fields(vid);\n                 let field_pats: Vec<_> = fields.into_iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n@@ -605,7 +605,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         },\n \n         ty::TyEnum(eid, _) =>\n-            ty::enum_variants(cx.tcx, eid)\n+            cx.tcx.enum_variants(eid)\n                 .iter()\n                 .map(|va| Variant(va.id))\n                 .collect(),\n@@ -653,7 +653,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n         cx.tcx.mk_nil()\n     } else {\n-        let left_ty = ty::pat_ty(cx.tcx, &*real_pat);\n+        let left_ty = cx.tcx.pat_ty(&*real_pat);\n \n         match real_pat.node {\n             ast::PatIdent(ast::BindByRef(..), _, _) => {\n@@ -817,11 +817,11 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n         },\n         ty::TyEnum(eid, _) => {\n             match *ctor {\n-                Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                Variant(id) => cx.tcx.enum_variant_with_id(eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n-        ty::TyStruct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+        ty::TyStruct(cid, _) => cx.tcx.lookup_struct_fields(cid).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }\n@@ -913,7 +913,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 },\n                 _ => {\n                     // Assume this is a struct.\n-                    match ty::ty_to_def_id(node_id_to_type(cx.tcx, pat_id)) {\n+                    match cx.tcx.node_id_to_type(pat_id).ty_to_def_id() {\n                         None => {\n                             cx.tcx.sess.span_bug(pat_span,\n                                                  \"struct pattern wasn't of a \\\n@@ -924,7 +924,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 }\n             };\n             class_id.map(|variant_id| {\n-                let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                let struct_fields = cx.tcx.lookup_struct_fields(variant_id);\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n@@ -1109,8 +1109,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n-                        let pat_ty = ty::node_id_to_type(tcx, p.id);\n-                        if ty::type_moves_by_default(&cx.param_env, pat.span, pat_ty) {\n+                        let pat_ty = tcx.node_id_to_type(p.id);\n+                        if cx.param_env.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }"}, {"sha": "1489e946fe2ce57f090612399c3c9114ad42ab4c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n+        if !cmt.ty.is_sized(self.param_env, span) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 cmt.ty);"}, {"sha": "1b1725dd15c851fea0cfddf49c22061177089fd2", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -126,9 +126,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         Some(ref_id) => {\n-                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                            let trait_id = tcx.trait_of_item(def_id)\n                                               .unwrap();\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs)\n@@ -176,7 +176,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs).map(|e| e.id)\n@@ -714,7 +714,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n     eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n-        ty::node_id_item_substs(tcx, id).substs\n+        tcx.node_id_item_substs(id).substs\n     })\n }\n \n@@ -725,7 +725,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n     fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n-    let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n+    let ety = ty_hint.or_else(|| tcx.expr_ty_opt(e));\n \n     // If type of expression itself is int or uint, normalize in these\n     // bindings so that isize/usize is mapped to a type with an\n@@ -882,7 +882,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         // FIXME (#23833): the type-hint can cause problems,\n         // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n         // type to the sum, and thus no overflow is signaled.\n-        let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n+        let base_hint = tcx.expr_ty_opt(&**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n@@ -1030,10 +1030,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let param_env = ty::empty_parameter_environment(tcx);\n+    let param_env = tcx.empty_parameter_environment();\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n@@ -1056,7 +1056,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n \n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n-            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+            match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.ident.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {"}, {"sha": "bd8b8afbdfe88de30b24c88deb6f623dc4c77b3e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Some(method) => {\n                 match method.origin {\n                     ty::MethodStatic(def_id) => {\n-                        match ty::provided_source(self.tcx, def_id) {\n+                        match self.tcx.provided_source(def_id) {\n                             Some(p_did) => self.check_def_id(p_did),\n                             None => self.check_def_id(def_id)\n                         }\n@@ -116,9 +116,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         method_num: index,\n                         ..\n                     }) => {\n-                        let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_ref.def_id,\n-                                                        index);\n+                        let trait_item = self.tcx.trait_item(trait_ref.def_id, index);\n                         self.check_def_id(trait_item.def_id());\n                     }\n                 }\n@@ -132,9 +130,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields.iter()\n                     .find(|field| field.name == name).unwrap().id;\n                 self.live_symbols.insert(field_id.node);\n@@ -144,9 +142,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields[idx].id;\n                 self.live_symbols.insert(field_id.node);\n             },\n@@ -159,8 +157,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n-                match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n-                                                           lhs.id)) {\n+                match self.tcx.node_id_to_type(lhs.id).ty_to_def_id() {\n                     None => {\n                         self.tcx.sess.span_bug(lhs.span,\n                                                \"struct pattern wasn't of a \\\n@@ -170,7 +167,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 }\n             }\n         };\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let fields = self.tcx.lookup_struct_fields(id);\n         for pat in pats {\n             if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n                 continue;\n@@ -480,8 +477,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n \n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n-        let field_type = ty::node_id_to_type(self.tcx, node.id);\n-        let is_marker_field = match ty::ty_to_def_id(field_type) {\n+        let field_type = self.tcx.node_id_to_type(node.id);\n+        let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n             _ => false\n         };"}, {"sha": "c48d5d5da40200bcc8d7b51b200722d00e9c1206", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n     fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n-            ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            ast::ExprIndex(ref base, _) => self.tcx.node_id_to_type(base.id),\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {:?}\",\n@@ -149,15 +149,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprCall(ref base, _) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -174,7 +174,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             ast::ExprPath(..) => {\n-                if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n+                if let def::DefStatic(_, true) = self.tcx.resolve_expr(expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }"}, {"sha": "a15d02ea29605903a4f9d083dcb0ef41b2a67658", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -229,7 +229,7 @@ impl OverloadedCallType {\n \n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n-        let method_descriptor = match ty::impl_or_trait_item(tcx, method_id) {\n+        let method_descriptor = match tcx.impl_or_trait_item(method_id) {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n@@ -244,7 +244,7 @@ impl OverloadedCallType {\n             }\n             ty::ImplContainer(impl_id) => impl_id,\n         };\n-        let trait_ref = match ty::impl_trait_ref(tcx, impl_id) {\n+        let trait_ref = match tcx.impl_trait_ref(impl_id) {\n             None => {\n                 tcx.sess.bug(\"statically resolved overloaded call impl \\\n                               didn't implement a trait?!\")\n@@ -502,9 +502,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n-                let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n-                let bk = ty::BorrowKind::from_mutbl(m);\n-                self.borrow_expr(&**base, r, bk, AddrOf);\n+                if let ty::TyRef(&r, _) = expr_ty.sty {\n+                    let bk = ty::BorrowKind::from_mutbl(m);\n+                    self.borrow_expr(&**base, r, bk, AddrOf);\n+                }\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n@@ -740,7 +741,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n             ty::TyStruct(did, substs) => {\n-                ty::struct_fields(self.tcx(), did, substs)\n+                self.tcx().struct_fields(did, substs)\n             }\n             _ => {\n                 // the base expression should always evaluate to a\n@@ -822,7 +823,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // the method call infrastructure should have\n                     // replaced all late-bound regions with variables:\n                     let self_ty = method_ty.fn_sig().input(0);\n-                    let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n+                    let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -922,10 +923,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // This is always an rvalue, since we are producing a new\n         // (temporary) indirection.\n \n-        let adj_ty =\n-            ty::adjust_ty_for_autoref(self.tcx(),\n-                                      cmt_base_ty,\n-                                      opt_autoref);\n+        let adj_ty = cmt_base_ty.adjust_for_autoref(self.tcx(), opt_autoref);\n \n         self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n@@ -1074,12 +1072,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n                     ast::PatIdent(ast::BindByRef(m), _, _) => {\n-                        let (r, bk) = {\n-                            (ty::ty_region(tcx, pat.span, pat_ty),\n-                             ty::BorrowKind::from_mutbl(m))\n-                        };\n-                        delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                             r, bk, RefBinding);\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                            r, bk, RefBinding);\n+                        }\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n@@ -1152,7 +1149,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                         Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n-                                if ty::enum_is_univariant(tcx, enum_did) {\n+                                if tcx.enum_is_univariant(enum_did) {\n                                     cmt_pat\n                                 } else {\n                                     let cmt_pat_ty = cmt_pat.ty;\n@@ -1238,7 +1235,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n+        self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n                 let id_var = freevar.def.def_id().node;\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n@@ -1283,7 +1280,7 @@ fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n                       move_reason: MoveReason)\n                       -> ConsumeMode\n {\n-    if typer.type_moves_by_default(cmt.span, cmt.ty) {\n+    if typer.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "d5fa885b16ab50cf08a08c41de13218967fe60cb", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n             ty::TyEnum(def_id, substs) |\n             ty::TyStruct(def_id, substs) => {\n-                let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n+                let item_scheme = self.tcx().lookup_item_type(def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                            substs: &Substs<'tcx>)\n     {\n         let predicates =\n-            ty::lookup_predicates(self.tcx(), def_id).instantiate(self.tcx(), substs);\n+            self.tcx().lookup_predicates(def_id).instantiate(self.tcx(), substs);\n         let predicates = match self.fully_normalize(&predicates) {\n             Ok(predicates) => predicates,\n             Err(ErrorReported) => { return; }\n@@ -250,15 +250,15 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 ty::Predicate::Equate(..) => { }\n                 ty::Predicate::Projection(..) => { }\n                 ty::Predicate::RegionOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                             self.push_sub_region_constraint(Some(ty), r_b, r_a);\n                         }\n                     }\n                 }\n                 ty::Predicate::TypeOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                             self.stack.push((r_b, Some(ty)));\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                                     .map(|pred| Implication::Predicate(def_id, pred));\n         self.out.extend(obligations);\n \n-        let variances = ty::item_variances(self.tcx(), def_id);\n+        let variances = self.tcx().item_variances(def_id);\n \n         for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                data);\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n-            match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+            match self.tcx().no_late_bound_regions(&poly_trait_ref) {\n                 Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n                 None => { }\n             }\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                trait_ref);\n \n         let trait_def_id = trait_ref.def_id;\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n         let assoc_type_projections: Vec<_> =\n             trait_def.associated_type_names\n                      .iter()\n@@ -447,5 +447,5 @@ pub fn object_region_bounds<'tcx>(\n     let mut predicates = others.to_predicates(tcx, open_ty);\n     predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n \n-    ty::required_region_bounds(tcx, open_ty, predicates)\n+    tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "d2268894b20a1d5cb2c06e5b4d2f9e2417317620", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n-        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let a1 = self.tcx().erase_late_bound_regions(a);\n+        let b1 = self.tcx().erase_late_bound_regions(b);\n         let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }"}, {"sha": "17075c0cba6cabe0f64ba18bd6a7f5b73f5ef1d2", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 150, "deletions": 187, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -91,123 +91,125 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn note_and_explain_region(tcx: &ty::ctxt,\n-                               prefix: &str,\n-                               region: ty::Region,\n-                               suffix: &str) {\n-    fn item_scope_tag(item: &ast::Item) -> &'static str {\n-        match item.node {\n-            ast::ItemImpl(..) => \"impl\",\n-            ast::ItemStruct(..) => \"struct\",\n-            ast::ItemEnum(..) => \"enum\",\n-            ast::ItemTrait(..) => \"trait\",\n-            ast::ItemFn(..) => \"function body\",\n-            _ => \"item\"\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn note_and_explain_region(&self,\n+                                   prefix: &str,\n+                                   region: ty::Region,\n+                                   suffix: &str) {\n+        fn item_scope_tag(item: &ast::Item) -> &'static str {\n+            match item.node {\n+                ast::ItemImpl(..) => \"impl\",\n+                ast::ItemStruct(..) => \"struct\",\n+                ast::ItemEnum(..) => \"enum\",\n+                ast::ItemTrait(..) => \"trait\",\n+                ast::ItemFn(..) => \"function body\",\n+                _ => \"item\"\n+            }\n         }\n-    }\n-\n-    fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n-                    -> (String, Option<Span>) {\n-        let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n-         Some(span))\n-    }\n \n-    let (description, span) = match region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope = || {\n-                format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                        prefix, scope, suffix)\n-            };\n-            let span = match scope.span(&tcx.map) {\n-                Some(s) => s,\n-                None => return tcx.sess.note(&unknown_scope())\n-            };\n-            let tag = match tcx.map.find(scope.node_id()) {\n-                Some(ast_map::NodeBlock(_)) => \"block\",\n-                Some(ast_map::NodeExpr(expr)) => match expr.node {\n-                    ast::ExprCall(..) => \"call\",\n-                    ast::ExprMethodCall(..) => \"method call\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-                    ast::ExprMatch(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(ast_map::NodeStmt(_)) => \"statement\",\n-                Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n-                Some(_) | None => {\n-                    return tcx.sess.span_note(span, &unknown_scope());\n-                }\n-            };\n-            let scope_decorated_tag = match scope {\n-                region::CodeExtent::Misc(_) => tag,\n-                region::CodeExtent::ParameterScope { .. } => {\n-                    \"scope of parameters for function\"\n-                }\n-                region::CodeExtent::DestructionScope(_) => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::CodeExtent::Remainder(r) => {\n-                    new_string = format!(\"block suffix following statement {}\",\n-                                         r.first_statement_index);\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n+        fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n+                        -> (String, Option<Span>) {\n+            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+            (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n+             Some(span))\n         }\n \n-        ty::ReFree(ref fr) => {\n-            let prefix = match fr.bound_region {\n-                ty::BrAnon(idx) => {\n-                    format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n-                }\n-                ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n-                _ => {\n-                    format!(\"the lifetime {} as defined on\",\n-                            fr.bound_region)\n-                }\n-            };\n+        let (description, span) = match region {\n+            ty::ReScope(scope) => {\n+                let new_string;\n+                let unknown_scope = || {\n+                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                            prefix, scope, suffix)\n+                };\n+                let span = match scope.span(&self.map) {\n+                    Some(s) => s,\n+                    None => return self.sess.note(&unknown_scope())\n+                };\n+                let tag = match self.map.find(scope.node_id()) {\n+                    Some(ast_map::NodeBlock(_)) => \"block\",\n+                    Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                        ast::ExprCall(..) => \"call\",\n+                        ast::ExprMethodCall(..) => \"method call\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        ast::ExprMatch(..) => \"match\",\n+                        _ => \"expression\",\n+                    },\n+                    Some(ast_map::NodeStmt(_)) => \"statement\",\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                    Some(_) | None => {\n+                        return self.sess.span_note(span, &unknown_scope());\n+                    }\n+                };\n+                let scope_decorated_tag = match scope {\n+                    region::CodeExtent::Misc(_) => tag,\n+                    region::CodeExtent::ParameterScope { .. } => {\n+                        \"scope of parameters for function\"\n+                    }\n+                    region::CodeExtent::DestructionScope(_) => {\n+                        new_string = format!(\"destruction scope surrounding {}\", tag);\n+                        &new_string[..]\n+                    }\n+                    region::CodeExtent::Remainder(r) => {\n+                        new_string = format!(\"block suffix following statement {}\",\n+                                             r.first_statement_index);\n+                        &new_string[..]\n+                    }\n+                };\n+                explain_span(self, scope_decorated_tag, span)\n+            }\n \n-            match tcx.map.find(fr.scope.node_id) {\n-                Some(ast_map::NodeBlock(ref blk)) => {\n-                    let (msg, opt_span) = explain_span(tcx, \"block\", blk.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(ast_map::NodeItem(it)) => {\n-                    let tag = item_scope_tag(&*it);\n-                    let (msg, opt_span) = explain_span(tcx, tag, it.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(_) | None => {\n-                    // this really should not happen\n-                    (format!(\"{} unknown free region bounded by scope {:?}\",\n-                             prefix, fr.scope), None)\n+            ty::ReFree(ref fr) => {\n+                let prefix = match fr.bound_region {\n+                    ty::BrAnon(idx) => {\n+                        format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                    }\n+                    ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                    _ => {\n+                        format!(\"the lifetime {} as defined on\",\n+                                fr.bound_region)\n+                    }\n+                };\n+\n+                match self.map.find(fr.scope.node_id) {\n+                    Some(ast_map::NodeBlock(ref blk)) => {\n+                        let (msg, opt_span) = explain_span(self, \"block\", blk.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(ast_map::NodeItem(it)) => {\n+                        let tag = item_scope_tag(&*it);\n+                        let (msg, opt_span) = explain_span(self, tag, it.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(_) | None => {\n+                        // this really should not happen\n+                        (format!(\"{} unknown free region bounded by scope {:?}\",\n+                                 prefix, fr.scope), None)\n+                    }\n                 }\n             }\n-        }\n \n-        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+            ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-        ty::ReEarlyBound(ref data) => {\n-            (format!(\"{}\", token::get_name(data.name)), None)\n-        }\n+            ty::ReEarlyBound(ref data) => {\n+                (format!(\"{}\", token::get_name(data.name)), None)\n+            }\n \n-        // I believe these cases should not occur (except when debugging,\n-        // perhaps)\n-        ty::ReInfer(_) | ty::ReLateBound(..) => {\n-            (format!(\"lifetime {:?}\", region), None)\n+            // I believe these cases should not occur (except when debugging,\n+            // perhaps)\n+            ty::ReInfer(_) | ty::ReLateBound(..) => {\n+                (format!(\"lifetime {:?}\", region), None)\n+            }\n+        };\n+        let message = format!(\"{}{}{}\", prefix, description, suffix);\n+        if let Some(span) = span {\n+            self.sess.span_note(span, &message);\n+        } else {\n+            self.sess.note(&message);\n         }\n-    };\n-    let message = format!(\"{}{}{}\", prefix, description, suffix);\n-    if let Some(span) = span {\n-        tcx.sess.span_note(span, &message);\n-    } else {\n-        tcx.sess.note(&message);\n     }\n }\n \n@@ -491,7 +493,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      terr: &ty::type_err<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n-        ty::note_and_explain_type_err(self.tcx, terr, span);\n+        self.tcx.note_and_explain_type_err(terr, span);\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -576,8 +578,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n                         bound_kind));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n@@ -600,13 +601,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n@@ -615,42 +614,33 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 span_err!(self.tcx.sess, span, E0313,\n                     \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string());\n-                note_and_explain_region(\n-                    self.tcx,\n+                            self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"...but `{}` is only valid for \",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string()),\n+                             self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n@@ -659,8 +649,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"dereference of reference outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n@@ -669,25 +658,21 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     &format!(\"captured variable `{}` does not \\\n-                            outlive the enclosing closure\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   id).to_string()));\n-                note_and_explain_region(\n-                    self.tcx,\n+                              outlive the enclosing closure\",\n+                             self.tcx.local_var_name_str(id)));\n+                self.tcx.note_and_explain_region(\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(span,\n                                        \"index of slice outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n@@ -697,13 +682,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of the source pointer does not outlive \\\n                      lifetime bound of the object type\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"object type is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n@@ -714,7 +697,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -723,13 +706,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n@@ -740,7 +721,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -750,8 +731,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of method receiver does not outlive \\\n                      the method call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n@@ -761,8 +741,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of function argument does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n@@ -772,8 +751,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of return value does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n@@ -783,8 +761,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of operand does not outlive \\\n                      the operation\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n@@ -794,8 +771,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -805,8 +781,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"automatically reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -817,8 +792,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n                             self.ty_to_string(t)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n@@ -829,13 +803,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"unsafe use of destructor: destructor might be called \\\n                      while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"superregion: \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"subregion: \",\n                     sub,\n                     \"\");\n@@ -844,8 +816,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime of variable does not enclose its declaration\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n@@ -856,13 +827,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n@@ -878,16 +847,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sup_region: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&sup_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n@@ -903,16 +870,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                region2: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime must be contained by \",\n             region1,\n             \"...\");\n \n         self.note_region_origin(&origin1);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n@@ -1353,7 +1318,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     };\n                     match a_def {\n                         def::DefTy(did, _) | def::DefStruct(did) => {\n-                            let generics = ty::lookup_item_type(self.tcx, did).generics;\n+                            let generics = self.tcx.lookup_item_type(did).generics;\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace) as u32;\n@@ -1591,7 +1556,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n             }\n         };\n \n@@ -1671,7 +1636,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\n                         \"...so that closure can access `{}`\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id)\n+                        self.tcx.local_var_name_str(upvar_id.var_id)\n                             .to_string()))\n             }\n             infer::InfStackClosure(span) => {\n@@ -1695,9 +1660,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n-                            ty::local_var_name_str(\n-                                self.tcx,\n-                                id).to_string()));\n+                            self.tcx.local_var_name_str(id)));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "f1af2705d4ed891d9f619eb2709886f909c80889", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -983,7 +983,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 error_str));\n \n             if let Some(err) = err {\n-                ty::note_and_explain_type_err(self.tcx, err, sp)\n+                self.tcx.note_and_explain_type_err(err, sp)\n             }\n         }\n     }"}, {"sha": "c5f6f0126de378eec7d6fcba1fb9ba2f8a529bfb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -54,7 +54,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n+        let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n@@ -160,8 +160,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // In all cases, we keep the original unsubstituted types\n         // around for error reporting.\n \n-        let from_tc = ty::type_contents(self.tcx, from);\n-        let to_tc = ty::type_contents(self.tcx, to);\n+        let from_tc = from.type_contents(self.tcx);\n+        let to_tc = to.type_contents(self.tcx);\n         if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute to or from a type that contains \\\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n                        space, index, param_ty);\n \n-                if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n+                if !param_ty.is_sized(param_env, span) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n@@ -253,9 +253,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         if let ast::ExprPath(..) = expr.node {\n-            match ty::resolve_expr(self.tcx, expr) {\n+            match self.tcx.resolve_expr(expr) {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n-                    let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                    let typ = self.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {"}, {"sha": "d354c1667da38b7b03dcfcfaffaf5aab0c9a0c02", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -465,7 +465,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n                 if let DefLocal(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -1138,7 +1138,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                ty::expr_ty_adjusted(self.ir.tcx, &**f).fn_ret().diverges();\n+                self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1494,7 +1494,7 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n-        let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n+        let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1511,8 +1511,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     {\n         // within the fn body, late-bound regions are liberated:\n         let fn_ret =\n-            ty::liberate_late_bound_regions(\n-                self.ir.tcx,\n+            self.ir.tcx.liberate_late_bound_regions(\n                 region::DestructionScopeData::new(body.id),\n                 &self.fn_ret(id));\n \n@@ -1527,7 +1526,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n-                                    ty::expr_ty(self.ir.tcx, &**e) == t_ret\n+                                    self.ir.tcx.expr_ty(&**e) == t_ret\n                                 },\n                                 _ => false\n                             },"}, {"sha": "969ffaf88a719cee613a7df622075f404d974cfa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -285,7 +285,7 @@ pub type McResult<T> = Result<T, ()>;\n pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n@@ -406,9 +406,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().get(&expr.id),\n-                         |method_call| self.typer.node_method_ty(method_call)))\n+        Ok(unadjusted_ty.adjust(\n+            self.tcx(), expr.span, expr.id,\n+            self.typer.adjustments().borrow().get(&expr.id),\n+            |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -927,8 +928,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    ty::no_late_bound_regions(\n-                        self.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n+                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -1024,7 +1024,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n                 let self_ty = method_ty.fn_sig().input(0);\n-                ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap()\n+                self.tcx().no_late_bound_regions(&self_ty).unwrap()\n             }\n             None => {\n                 match base_cmt.ty.builtin_index() {\n@@ -1244,7 +1244,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let cmt = match opt_def {\n             Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n-                if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n+                if !self.tcx().enum_is_univariant(enum_did) => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                 }\n             _ => cmt\n@@ -1375,7 +1375,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        ty::no_late_bound_regions(self.tcx(), &method_ty.fn_ret())\n+        self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n            .unwrap()\n            .unwrap() // overloaded ops do not diverge, either\n     }\n@@ -1583,7 +1583,7 @@ impl<'tcx> fmt::Debug for categorization<'tcx> {\n             cat_static_item => write!(f, \"static\"),\n             cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n             cat_local(id) => {\n-               let name = ty::tls::with(|tcx| ty::local_var_name_str(tcx, id));\n+               let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n                write!(f, \"local({})\", name)\n             }\n             cat_upvar(upvar) => {"}, {"sha": "15a1ba853245b0934771e3e8f2daa7b4ecb24cf7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -192,7 +192,7 @@ pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n }\n \n pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n-    ty::with_path(tcx, id, |path| ast::Path {\n+    tcx.with_path(id, |path| ast::Path {\n         global: false,\n         segments: path.last().map(|elem| ast::PathSegment {\n             identifier: ast::Ident::new(elem.name()),"}, {"sha": "4766ae8933d0b535564e6e0769e3d21a16df50cb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -382,7 +382,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // items.\n         ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n-            let trait_items = ty::trait_items(tcx, trait_did);\n+            let trait_items = tcx.trait_items(trait_did);\n \n             for impl_item in impl_items {\n                 let item = trait_items.iter().find(|item| {\n@@ -425,7 +425,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                             method_num: index,\n                             ..\n                         }) => {\n-                            ty::trait_item(tcx, trait_ref.def_id, index).def_id()\n+                            tcx.trait_item(trait_ref.def_id, index).def_id()\n                         }\n                     }\n                 }\n@@ -434,9 +434,9 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         }\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+            match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(did, _) => {\n-                    ty::lookup_struct_fields(tcx, did)\n+                    tcx.lookup_struct_fields(did)\n                         .iter()\n                         .find(|f| f.name == field.node.name)\n                         .unwrap_or_else(|| {\n@@ -451,9 +451,9 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         }\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+            match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(did, _) => {\n-                    ty::lookup_struct_fields(tcx, did)\n+                    tcx.lookup_struct_fields(did)\n                         .get(field.node)\n                         .unwrap_or_else(|| {\n                             tcx.sess.span_bug(field.span,\n@@ -468,10 +468,10 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n             }\n         }\n         ast::ExprStruct(_, ref expr_fields, _) => {\n-            let type_ = ty::expr_ty(tcx, e);\n+            let type_ = tcx.expr_ty(e);\n             match type_.sty {\n                 ty::TyStruct(did, _) => {\n-                    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                    let struct_fields = tcx.lookup_struct_fields(did);\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n@@ -525,11 +525,11 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let did = match ty::pat_ty_opt(tcx, pat) {\n+    let did = match tcx.pat_ty_opt(pat) {\n         Some(&ty::TyS { sty: ty::TyStruct(did, _), .. }) => did,\n         Some(_) | None => return,\n     };\n-    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+    let struct_fields = tcx.lookup_struct_fields(did);\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {\n@@ -574,7 +574,7 @@ fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n }\n \n fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n-    match ty::trait_item_of_item(tcx, id) {\n+    match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n             if trait_method_id != id => {\n                 is_staged_api(tcx, trait_method_id)\n@@ -602,7 +602,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     debug!(\"lookup(id={:?})\", id);\n \n     // is this definition the implementation of a trait method?\n-    match ty::trait_item_of_item(tcx, id) {\n+    match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n             debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n             return lookup(tcx, trait_method_id)\n@@ -617,8 +617,8 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     };\n \n     item_stab.or_else(|| {\n-        if ty::is_impl(tcx, id) {\n-            if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n+        if tcx.is_impl(id) {\n+            if let Some(trait_id) = tcx.trait_id_of_impl(id) {\n                 // FIXME (#18969): for the time being, simply use the\n                 // stability of the trait to determine the stability of any\n                 // unmarked impls for it. See FIXME above for more details."}, {"sha": "371b5c309a85067016b756ec8c3a55fb4b8b112f", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -38,7 +38,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n            impl1_def_id,\n            impl2_def_id);\n \n-    let param_env = &ty::empty_parameter_environment(infcx.tcx);\n+    let param_env = &infcx.tcx.empty_parameter_environment();\n     let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n     infcx.probe(|_| {\n         overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n@@ -111,7 +111,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n     // already\n     if\n         trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n-        !ty::has_attr(tcx, trait_ref.def_id, \"fundamental\")\n+        !tcx.has_attr(trait_ref.def_id, \"fundamental\")\n     {\n         debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n         return false;\n@@ -142,13 +142,13 @@ fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let impl_substs =\n         &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n     let impl_trait_ref =\n-        ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n+        selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref =\n         impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = ty::lookup_predicates(selcx.tcx(), impl_def_id);\n+    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         project::normalize(selcx, ObligationCause::dummy(), &predicates);\n@@ -183,7 +183,7 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n-    let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n@@ -280,9 +280,9 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n         ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) =>\n-            ty::has_attr(tcx, def_id, \"fundamental\"),\n+            tcx.has_attr(def_id, \"fundamental\"),\n         ty::TyTrait(ref data) =>\n-            ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n+            tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n         _ =>\n             false\n     }"}, {"sha": "582873082a68b2625f07949c0456089859f22805", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -79,14 +79,14 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                      span: Span) -> Option<String> {\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n-    for item in ty::get_attrs(infcx.tcx, def_id).iter() {\n+    for item in infcx.tcx.get_attrs(def_id).iter() {\n         if item.check_name(\"rustc_on_unimplemented\") {\n             let err_sp = if item.meta().span == DUMMY_SP {\n                 span\n             } else {\n                 item.meta().span\n             };\n-            let def = ty::lookup_trait_def(infcx.tcx, def_id);\n+            let def = infcx.tcx.lookup_trait_def(def_id);\n             let trait_str = def.trait_ref.to_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n@@ -260,7 +260,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         TraitNotObjectSafe(did) => {\n             span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n                 \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-                ty::item_path_str(infcx.tcx, did));\n+                infcx.tcx.item_path_str(did));\n \n             for violation in object_safety_violations(infcx.tcx, did) {\n                 match violation {\n@@ -401,7 +401,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n-            let item_name = ty::item_path_str(tcx, item_def_id);\n+            let item_name = tcx.item_path_str(item_def_id);\n             tcx.sess.span_note(\n                 cause_span,\n                 &format!(\"required by `{}`\", item_name));\n@@ -442,8 +442,8 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = ty::item_path_str(tcx, def_id);\n-            let name = ty::local_var_name_str(tcx, var_id);\n+            let trait_name = tcx.item_path_str(def_id);\n+            let name = tcx.local_var_name_str(var_id);\n             span_note!(tcx.sess, closure_span,\n                        \"the closure that captures `{}` requires that all captured variables \\\n                        implement the trait `{}`\","}, {"sha": "5e274dcec70e431b423b2209d93a135daee40c49", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -421,7 +421,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             // regions.  If there are, we will call this obligation an\n             // error. Eventually we should be able to support some\n             // cases here, I imagine (e.g., `for<'a> int : 'a`).\n-            if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n+            if selcx.tcx().count_late_bound_regions(binder) != 0 {\n                 errors.push(\n                     FulfillmentError::new(\n                         obligation.clone(),"}, {"sha": "e7f11b06bd132b1d7c82faac784d704cd149f34c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -57,7 +57,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let def = tcx.lookup_trait_def(trait_def_id);\n \n     let result = def.object_safety().unwrap_or_else(|| {\n         let result = object_safety_violations(tcx, trait_def_id).is_empty();\n@@ -90,7 +90,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     // Check methods for violations.\n     let mut violations: Vec<_> =\n-        ty::trait_items(tcx, trait_def_id).iter()\n+        tcx.trait_items(trait_def_id).iter()\n         .flat_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n@@ -122,10 +122,10 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     trait_def_id: ast::DefId)\n                                     -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n     let trait_ref = trait_ref.to_poly_trait_ref();\n-    let predicates = ty::lookup_super_predicates(tcx, trait_def_id);\n+    let predicates = tcx.lookup_super_predicates(trait_def_id);\n     predicates\n         .predicates\n         .into_iter()\n@@ -153,8 +153,8 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let trait_predicates = tcx.lookup_predicates(trait_def_id);\n     generics_require_sized_self(tcx, &trait_def.generics, &trait_predicates)\n }\n \n@@ -169,7 +169,7 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = ty::construct_free_substs(tcx, generics, ast::DUMMY_NODE_ID);\n+    let free_substs = tcx.construct_free_substs(generics, ast::DUMMY_NODE_ID);\n     let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n@@ -321,7 +321,7 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                 // Compute supertraits of current trait lazily.\n                 if supertraits.is_none() {\n-                    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                    let trait_def = tcx.lookup_trait_def(trait_def_id);\n                     let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n                     supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n                 }"}, {"sha": "184de682c67db20d71b849d30ea24fd9588dc139", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -574,7 +574,7 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n+    let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n@@ -892,7 +892,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     // It is not in the impl - get the default from the trait.\n     let trait_ref = obligation.predicate.trait_ref;\n-    for trait_item in ty::trait_items(selcx.tcx(), trait_ref.def_id).iter() {\n+    for trait_item in selcx.tcx().trait_items(trait_ref.def_id).iter() {\n         if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n             if assoc_ty.name == obligation.predicate.item_name {\n                 if let Some(ty) = assoc_ty.ty {"}, {"sha": "01faa6b7cf7b9a9d86238b725535b1f93a5f2791", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -773,7 +773,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match candidate {\n             ImplCandidate(def_id) => {\n-                match ty::trait_impl_polarity(self.tcx(), def_id) {\n+                match self.tcx().trait_impl_polarity(def_id) {\n                     Some(ast::ImplPolarity::Negative) => return Err(Unimplemented),\n                     _ => {}\n                 }\n@@ -1024,7 +1024,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 projection_trait_ref={:?}\",\n                projection_trait_ref);\n \n-        let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n+        let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n         let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 bounds={:?}\",\n@@ -1224,7 +1224,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n-        let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n+        let def = self.tcx().lookup_trait_def(obligation.predicate.def_id());\n \n         def.for_each_relevant_impl(\n             self.tcx(),\n@@ -1252,7 +1252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let def_id = obligation.predicate.def_id();\n \n-        if ty::trait_has_default_impl(self.tcx(), def_id) {\n+        if self.tcx().trait_has_default_impl(def_id) {\n             match self_ty.sty {\n                 ty::TyTrait(..) => {\n                     // For object types, we don't know what the closed\n@@ -1264,7 +1264,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // object types, because it just lets you reflect\n                     // onto the object type, not into the object's\n                     // interior.\n-                    if ty::has_attr(self.tcx(), def_id, \"rustc_reflect_like\") {\n+                    if self.tcx().has_attr(def_id, \"rustc_reflect_like\") {\n                         candidates.vec.push(DefaultImplObjectCandidate(def_id));\n                     }\n                 }\n@@ -1397,7 +1397,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let self_ty = match ty::no_late_bound_regions(self.tcx(), &obligation.self_ty()) {\n+        let self_ty = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -1736,15 +1736,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyStruct(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                    self.tcx().struct_fields(def_id, substs).iter()\n                                                                  .map(|f| f.mt.ty)\n                                                                  .collect();\n                 nominal(bound, types)\n             }\n \n             ty::TyEnum(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                    self.tcx().substd_enum_variants(def_id, substs)\n                     .iter()\n                     .flat_map(|variant| &variant.args)\n                     .cloned()\n@@ -1881,13 +1881,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::TyStruct(def_id, substs) => {\n-                Some(ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                Some(self.tcx().struct_fields(def_id, substs).iter()\n                      .map(|f| f.mt.ty)\n                      .collect())\n             }\n \n             ty::TyEnum(def_id, substs) => {\n-                Some(ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                Some(self.tcx().substd_enum_variants(def_id, substs)\n                      .iter()\n                      .flat_map(|variant| &variant.args)\n                      .map(|&ty| ty)\n@@ -2161,7 +2161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation,\n                trait_def_id);\n \n-        assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n+        assert!(self.tcx().has_attr(trait_def_id, \"rustc_reflect_like\"));\n \n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n@@ -2178,7 +2178,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // reintroduce the two binding levels we skipped, then flatten into one\n                 let all_types = ty::Binder(ty::Binder(all_types));\n-                let all_types = ty::flatten_late_bound_regions(self.tcx(), &all_types);\n+                let all_types = self.tcx().flatten_late_bound_regions(&all_types);\n \n                 self.vtable_default_impl(obligation, trait_def_id, all_types)\n             }\n@@ -2434,7 +2434,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n-            ty::no_late_bound_regions(tcx, &obligation.self_ty()).unwrap());\n+            tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n@@ -2525,8 +2525,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // Struct<T> -> Struct<U>.\n             (&ty::TyStruct(def_id, substs_a), &ty::TyStruct(_, substs_b)) => {\n-                let fields = ty::lookup_struct_fields(tcx, def_id).iter().map(|f| {\n-                    ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n+                let fields = tcx.lookup_struct_fields(def_id).iter().map(|f| {\n+                    tcx.lookup_field_type_unsubstituted(def_id, f.id)\n                 }).collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n@@ -2628,7 +2628,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   -> Result<(Normalized<'tcx, Substs<'tcx>>,\n                              infer::SkolemizationMap), ()>\n     {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n+        let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n@@ -2765,7 +2765,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                          impl_def_id);\n \n         // Find the self type for the impl.\n-        let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n+        let impl_self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n         let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n \n         debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n@@ -2890,7 +2890,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n \n-        let predicates = ty::lookup_predicates(self.tcx(), def_id);\n+        let predicates = self.tcx().lookup_predicates(def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n         let mut predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);"}, {"sha": "5c9a8d6c1aa3fb411be50c23fd2de96e05de13fd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -43,19 +43,19 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n         // regions before we throw things into the underlying set.\n         let normalized_pred = match *pred {\n             ty::Predicate::Trait(ref data) =>\n-                ty::Predicate::Trait(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Trait(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::Equate(ref data) =>\n-                ty::Predicate::Equate(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Equate(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::RegionOutlives(ref data) =>\n-                ty::Predicate::RegionOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::RegionOutlives(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::TypeOutlives(ref data) =>\n-                ty::Predicate::TypeOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::TypeOutlives(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::Projection(ref data) =>\n-                ty::Predicate::Projection(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Projection(self.tcx.anonymize_late_bound_regions(data)),\n         };\n         self.set.insert(normalized_pred)\n     }\n@@ -116,7 +116,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = ty::lookup_super_predicates(self.tcx, data.def_id());\n+                let predicates = self.tcx.lookup_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -236,7 +236,7 @@ impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = ty::lookup_super_predicates(self.tcx, def_id);\n+        let predicates = self.tcx.lookup_super_predicates(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -297,7 +297,7 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                           -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n@@ -416,7 +416,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             break;\n         }\n \n-        let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+        let trait_items = tcx.trait_items(bound_ref.def_id());\n         for trait_item in trait_items.iter() {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n@@ -427,7 +427,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // count number of methods preceding the one we are selecting and\n     // add them to the total offset; skip over associated types.\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     for trait_item in trait_items.iter().take(method_offset_in_trait) {\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,"}, {"sha": "302ec08db6f26751918c3bd0b7fa36712e850dcc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2581, "deletions": 2743, "changes": 5324, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4"}, {"sha": "4e88e23377d0c56e6a969fcb0bd0c4a757f491a7", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -113,7 +113,7 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = ty::item_variances(relation.tcx(), item_def_id);\n+        variances = relation.tcx().item_variances(item_def_id);\n         Some(&*variances)\n     } else {\n         None"}, {"sha": "dcdf457965efa054a9ca5df60cdd02ee3301f81f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -71,7 +71,7 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n     where GG: for<'tcx> FnOnce(&ty::ctxt<'tcx>) -> ty::Generics<'tcx>\n {\n     let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n-        try!(write!(f, \"{}\", ty::item_path_str(tcx, did)));\n+        try!(write!(f, \"{}\", tcx.item_path_str(did)));\n         Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n     }));\n \n@@ -265,7 +265,7 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n                       projection_bounds,\n-                      |tcx| ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n+                      |tcx| tcx.lookup_trait_def(trait_ref.def_id).generics.clone())\n     }\n }\n \n@@ -616,7 +616,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         parameterized(f, self.substs, self.def_id, &[],\n-                      |tcx| ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+                      |tcx| tcx.lookup_trait_def(self.def_id).generics.clone())\n     }\n }\n \n@@ -671,7 +671,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n \n                 if let Some(def_id) = opt_def_id {\n                     try!(write!(f, \" {{{}}}\", ty::tls::with(|tcx| {\n-                        ty::item_path_str(tcx, def_id)\n+                        tcx.item_path_str(def_id)\n                     })));\n                 }\n                 Ok(())\n@@ -681,7 +681,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n             TyEnum(did, substs) | TyStruct(did, substs) => {\n                 parameterized(f, substs, did, &[],\n-                              |tcx| ty::lookup_item_type(tcx, did).generics)\n+                              |tcx| tcx.lookup_item_type(did).generics)\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n@@ -720,7 +720,7 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"UpvarId({};`{}`;{})\",\n                self.var_id,\n-               ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n+               ty::tls::with(|tcx| tcx.local_var_name_str(self.var_id)),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "9d4fb4c994d404bd18fa2046567282aa8b7f8dcc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n                     ty::TyStruct(def_id, _) | ty::TyEnum(def_id, _) => {\n-                        if ty::has_dtor(self.tcx(), def_id) {\n+                        if self.tcx().has_dtor(def_id) {\n                             // In the case where the owner implements drop, then\n                             // the path must be initialized to prevent a case of\n                             // partial reinitialization"}, {"sha": "9bd4da28c99fbd2d839b5ba3b3c14985ce708f00", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -353,7 +353,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         (&ty::TyStruct(def_id, ref _substs), None) => {\n-            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            let fields = tcx.lookup_struct_fields(def_id);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     for f in &fields {\n@@ -378,7 +378,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n \n         (&ty::TyEnum(enum_def_id, substs), ref enum_variant_info) => {\n             let variant_info = {\n-                let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n+                let mut variants = tcx.substd_enum_variants(enum_def_id, substs);\n                 match *enum_variant_info {\n                     Some((variant_def_id, ref _lp2)) =>\n                         variants.iter()\n@@ -442,9 +442,9 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n     let loan_path_elem = LpInterior(InteriorField(new_field_name));\n     let new_lp_type = match new_field_name {\n         mc::NamedField(ast_name) =>\n-            ty::named_element_ty(tcx, parent.to_type(), ast_name, opt_variant_did),\n+            tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),\n         mc::PositionalField(idx) =>\n-            ty::positional_element_ty(tcx, parent.to_type(), idx, opt_variant_did),\n+            tcx.positional_element_ty(parent.to_type(), idx, opt_variant_did),\n     };\n     let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n     let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());"}, {"sha": "2b33dde2cbe2daa18f1e5c4e67beb1e7614cd5bb", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -35,7 +35,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = ty::node_id_to_type(bccx.tcx, var_id);\n+    let ty = bccx.tcx.node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n@@ -180,7 +180,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyStruct(did, _) | ty::TyEnum(did, _) => {\n-                    if ty::has_dtor(bccx.tcx, did) {\n+                    if bccx.tcx.has_dtor(did) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "44a4a0d250402ec8c2493b15f374eef1d8275c09", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -490,7 +490,7 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n+            let param_env = self.bccx.tcx.empty_parameter_environment();\n             let mc = mc::MemCategorizationContext::new(&param_env);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "5baabebea116b57b5e080ed16bccaa3dbf7e7044", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -137,7 +137,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyStruct(did, _) |\n-                ty::TyEnum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n+                ty::TyEnum(did, _) if bccx.tcx.has_dtor(did) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "4f726044a1bac866f385396a1608beec40076175", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -29,8 +29,8 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::infer::error_reporting::note_and_explain_region;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Typer;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n \n@@ -662,7 +662,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             move_data::MovePat => {\n-                let pat_ty = ty::node_id_to_type(self.tcx, the_move.id);\n+                let pat_ty = self.tcx.node_id_to_type(the_move.id);\n                 let span = self.tcx.map.span(the_move.id);\n                 self.tcx.sess.span_note(span,\n                     &format!(\"`{}` moved here{} because it has type `{}`, \\\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n@@ -747,7 +747,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                     -> (&'static str, &'static str) {\n             match ty.sty {\n                 _ => {\n-                    if ty::type_moves_by_default(param_env, span, ty) {\n+                    if param_env.type_moves_by_default(ty, span) {\n                         (\"non-copyable\",\n                          \"perhaps you meant to use `clone()`?\")\n                     } else {\n@@ -997,13 +997,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             err_out_of_scope(super_scope, sub_scope) => {\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n@@ -1020,14 +1018,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     None => self.cmt_to_string(&*err.cmt),\n                 };\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n                     \"\");\n@@ -1041,14 +1037,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n-                out.push_str(&ty::local_var_name_str(self.tcx, id));\n+                out.push_str(&self.tcx.local_var_name_str(id));\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n+                out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1094,7 +1090,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n+                out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1184,7 +1180,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n+                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };\n@@ -1216,7 +1212,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n+                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };"}, {"sha": "1ad3f53c328d90b2c24661b86308f4f8972c0b5b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -648,16 +648,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n-    ty::with_ctxt(sess,\n-                  arenas,\n-                  def_map,\n-                  named_region_map,\n-                  ast_map,\n-                  freevars,\n-                  region_map,\n-                  lang_items,\n-                  stability::Index::new(krate),\n-                  |tcx| {\n+    ty::ctxt::create_and_enter(sess,\n+                               arenas,\n+                               def_map,\n+                               named_region_map,\n+                               ast_map,\n+                               freevars,\n+                               region_map,\n+                               lang_items,\n+                               stability::Index::new(krate),\n+                               |tcx| {\n \n         // passes are timed inside typeck\n         typeck::check_crate(tcx, trait_map);"}, {"sha": "610f3f3a75ee64b40e6c7ffc7211c42aeca6e41b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              &ty::expr_ty(self.tcx, expr).to_string()));\n+                              &self.tcx.expr_ty(expr).to_string()));\n                 s.pclose()\n             }\n             _ => Ok(())"}, {"sha": "5ec6e293684ccf20ca804a6c3fd3aa0d5b0f9ee5", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -130,16 +130,16 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    ty::with_ctxt(sess,\n-                  &arenas,\n-                  def_map,\n-                  named_region_map,\n-                  ast_map,\n-                  freevars,\n-                  region_map,\n-                  lang_items,\n-                  stability::Index::new(krate),\n-                  |tcx| {\n+    ty::ctxt::create_and_enter(sess,\n+                               &arenas,\n+                               def_map,\n+                               named_region_map,\n+                               ast_map,\n+                               freevars,\n+                               region_map,\n+                               lang_items,\n+                               stability::Index::new(krate),\n+                               |tcx| {\n         let infcx = infer::new_infer_ctxt(tcx);\n         body(Env { infcx: &infcx });\n         let free_regions = FreeRegionMap::new();"}, {"sha": "8fe07da157970dd04a9d2000e8e04ea6e6825b8d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -30,6 +30,7 @@\n \n use metadata::{csearch, decoder};\n use middle::def::*;\n+use middle::mem_categorization::Typer;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n@@ -142,7 +143,7 @@ impl LintPass for TypeLimits {\n                         }\n                     },\n                     _ => {\n-                        let t = ty::expr_ty(cx.tcx, &**expr);\n+                        let t = cx.tcx.expr_ty(&**expr);\n                         match t.sty {\n                             ty::TyUint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATION, e.span,\n@@ -168,7 +169,7 @@ impl LintPass for TypeLimits {\n                 }\n \n                 if is_shift_binop(binop.node) {\n-                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n+                    let opt_ty_bits = match cx.tcx.expr_ty(&**l).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n@@ -193,7 +194,7 @@ impl LintPass for TypeLimits {\n                 }\n             },\n             ast::ExprLit(ref lit) => {\n-                match ty::expr_ty(cx.tcx, e).sty {\n+                match cx.tcx.expr_ty(e).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n@@ -343,7 +344,7 @@ impl LintPass for TypeLimits {\n             } else {\n                 binop\n             };\n-            match ty::expr_ty(tcx, expr).sty {\n+            match tcx.expr_ty(expr).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -412,7 +413,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n \n-                if !ty::is_ffi_safe(self.cx.tcx, tty) {\n+                if !tty.is_ffi_safe(self.cx.tcx) {\n                     self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                       \"found type without foreign-function-safe \\\n                                        representation annotation in foreign module, consider \\\n@@ -482,20 +483,11 @@ pub struct BoxPointers;\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n-        let mut n_uniq: usize = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match t.sty {\n-                ty::TyBox(_) => {\n-                    n_uniq += 1;\n-                }\n-                _ => ()\n-            };\n-            t\n-        });\n-\n-        if n_uniq > 0 {\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n-            cx.span_lint(BOX_POINTERS, span, &m[..]);\n+        for leaf_ty in ty.walk() {\n+            if let ty::TyBox(_) = leaf_ty.sty {\n+                let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n+                cx.span_lint(BOX_POINTERS, span, &m);\n+            }\n         }\n     }\n }\n@@ -512,7 +504,7 @@ impl LintPass for BoxPointers {\n             ast::ItemEnum(..) |\n             ast::ItemStruct(..) =>\n                 self.check_heap_type(cx, it.span,\n-                                     ty::node_id_to_type(cx.tcx, it.id)),\n+                                     cx.tcx.node_id_to_type(it.id)),\n             _ => ()\n         }\n \n@@ -521,15 +513,15 @@ impl LintPass for BoxPointers {\n             ast::ItemStruct(ref struct_def, _) => {\n                 for struct_field in &struct_def.fields {\n                     self.check_heap_type(cx, struct_field.span,\n-                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n+                                         cx.tcx.node_id_to_type(struct_field.node.id));\n                 }\n             }\n             _ => ()\n         }\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let ty = ty::expr_ty(cx.tcx, e);\n+        let ty = cx.tcx.expr_ty(e);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -582,13 +574,13 @@ impl LintPass for RawPointerDerive {\n             ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n                 if let &Some(ref trait_ref) = t_ref_opt {\n-                    let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                    let def_id = cx.tcx.trait_ref_to_def_id(trait_ref);\n                     if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n                         return;\n                     }\n                 }\n \n-                match ty::node_id_to_type(cx.tcx, item.id).sty {\n+                match cx.tcx.node_id_to_type(item.id).sty {\n                     ty::TyEnum(did, _) => did,\n                     ty::TyStruct(did, _) => did,\n                     _ => return,\n@@ -732,7 +724,7 @@ impl LintPass for UnusedResults {\n             return;\n         }\n \n-        let t = ty::expr_ty(cx.tcx, expr);\n+        let t = cx.tcx.expr_ty(expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyBool => return,\n@@ -877,7 +869,7 @@ fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n             ty::ImplContainer(cid) => {\n-                match ty::impl_trait_ref(cx.tcx, cid) {\n+                match cx.tcx.impl_trait_ref(cid) {\n                     Some(_) => MethodContext::TraitImpl,\n                     None => MethodContext::PlainImpl\n                 }\n@@ -1601,7 +1593,7 @@ impl LintPass for MissingDoc {\n             ast::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n                 match cx.tcx.map.find(real_trait.node) {\n                     Some(ast_map::NodeItem(item)) => if item.vis == ast::Visibility::Inherited {\n                         for itm in impl_items {\n@@ -1711,11 +1703,11 @@ impl LintPass for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n-        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n+        let parameter_environment = cx.tcx.empty_parameter_environment();\n+        if !parameter_environment.type_moves_by_default(ty, item.span) {\n             return;\n         }\n-        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n+        if parameter_environment.can_type_implement_copy(ty, item.span).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\\n@@ -1763,11 +1755,11 @@ impl LintPass for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let debug_def = ty::lookup_trait_def(cx.tcx, debug);\n+            let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if d.krate == ast::LOCAL_CRATE {\n-                    if let Some(ty_def) = ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)) {\n+                    if let Some(ty_def) = cx.tcx.node_id_to_type(d.node).ty_to_def_id() {\n                         impls.insert(ty_def.node);\n                     }\n                 }\n@@ -1878,7 +1870,7 @@ impl LintPass for UnconditionalRecursion {\n             visit::FkFnBlock => return\n         };\n \n-        let impl_def_id = ty::impl_of_method(cx.tcx, local_def(id))\n+        let impl_def_id = cx.tcx.impl_of_method(local_def(id))\n             .unwrap_or(local_def(ast::DUMMY_NODE_ID));\n         assert!(ast_util::is_local(impl_def_id));\n         let impl_node_id = impl_def_id.node;\n@@ -2010,7 +2002,7 @@ impl LintPass for UnconditionalRecursion {\n                     // method instead.\n                     ty::MethodTypeParam(\n                         ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n-                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                        tcx.trait_item(trait_ref.def_id, method_num).def_id()\n                     }\n \n                     // The `impl` is known, so we check that with a\n@@ -2175,11 +2167,11 @@ impl LintPass for MutableTransmutes {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let DefFn(did, _) = ty::resolve_expr(cx.tcx, expr) {\n+            if let DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = ty::node_id_to_type(cx.tcx, expr.id);\n+                let typ = cx.tcx.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyBareFn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         if let ty::FnConverging(to) = bare_fn.sig.0.output {\n@@ -2194,11 +2186,11 @@ impl LintPass for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n-            match ty::lookup_item_type(cx.tcx, def_id).ty.sty {\n+            match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n             }\n-            ty::with_path(cx.tcx, def_id, |path| match path.last() {\n+            cx.tcx.with_path(def_id, |path| match path.last() {\n                 Some(ref last) => last.name().as_str() == \"transmute\",\n                 _ => false\n             })\n@@ -2251,7 +2243,7 @@ impl LintPass for DropWithReprExtern {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.krate == ast::LOCAL_CRATE {\n                     let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);\n-                    let ty = ty::lookup_item_type(ctx.tcx, impl_did).ty;\n+                    let ty = ctx.tcx.lookup_item_type(impl_did).ty;\n                     (impl_did, ty)\n                 } else {\n                     continue;\n@@ -2261,9 +2253,9 @@ impl LintPass for DropWithReprExtern {\n                 ty::TyEnum(self_type_did, _) |\n                 ty::TyStruct(self_type_did, _) |\n                 ty::TyClosure(self_type_did, _) => {\n-                    let hints = ty::lookup_repr_hints(ctx.tcx, self_type_did);\n+                    let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n-                        ty::ty_dtor(ctx.tcx, self_type_did).has_drop_flag() {\n+                        ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n                                                                      codemap::DUMMY_SP);\n                         let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,"}, {"sha": "24803562fa3734fffef5be24fa77caf5d2b4ad42", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                     _ => true,\n                 };\n-                let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n+                let tr = self.tcx.impl_trait_ref(local_def(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n                     !is_local(tr.def_id) ||\n                      self.exported_items.contains(&tr.def_id.node)\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -476,7 +476,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n-                            match ty::impl_trait_ref(self.tcx, imp) {\n+                            match self.tcx.impl_trait_ref(imp) {\n                                 Some(..) => return Allowable,\n                                 _ if ii.vis == ast::Public => {\n                                     return Allowable\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                    span: Span,\n                    id: ast::DefId,\n                    name: FieldName) {\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let fields = self.tcx.lookup_struct_fields(id);\n         let field = match name {\n             NamedField(f_name) => {\n                 debug!(\"privacy - check named field {} in struct {:?}\", f_name, id);\n@@ -709,10 +709,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             return\n         }\n \n-        let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n+        let struct_type = self.tcx.lookup_item_type(id).ty;\n         let struct_desc = match struct_type.sty {\n             ty::TyStruct(_, _) =>\n-                format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n+                format!(\"struct `{}`\", self.tcx.item_path_str(id)),\n             // struct variant fields have inherited visibility\n             ty::TyEnum(..) => return,\n             _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                            name: ast::Name) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n-        let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n+        let method_id = match self.tcx.impl_or_trait_item(method_id) {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n@@ -893,12 +893,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n-                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span, id, NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span, id, UnnamedField(idx.node));\n                 }\n             }\n@@ -917,12 +917,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                match ty::expr_ty(self.tcx, expr).sty {\n+                match self.tcx.expr_ty(expr).sty {\n                     ty::TyStruct(ctor_id, _) => {\n                         // RFC 736: ensure all unmentioned fields are visible.\n                         // Rather than computing the set of unmentioned fields\n                         // (i.e. `all_fields - fields`), just check them all.\n-                        let all_fields = ty::lookup_struct_fields(self.tcx, ctor_id);\n+                        let all_fields = self.tcx.lookup_struct_fields(ctor_id);\n                         for field in all_fields {\n                             self.check_field(expr.span, ctor_id,\n                                              NamedField(field.name));\n@@ -950,7 +950,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprPath(..) => {\n                 let guard = |did: ast::DefId| {\n-                    let fields = ty::lookup_struct_fields(self.tcx, did);\n+                    let fields = self.tcx.lookup_struct_fields(did);\n                     let any_priv = fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n                             !is_local(f.id) ||\n@@ -994,7 +994,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n+                match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(id, _) => {\n                         for field in fields {\n                             self.check_field(pattern.span, id,\n@@ -1025,7 +1025,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n+                match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             if let ast::PatWild(..) = field.node {\n@@ -1337,7 +1337,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n+                        let did = self.tcx.trait_ref_to_def_id(tr);\n \n                         !is_local(did) || self.trait_is_public(did.node)\n                     });"}, {"sha": "5ddad0e1947e83eda92f508ace6a8398ebdd6424", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -311,7 +311,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(self.tcx, ast_util::local_def(id)) {\n+        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n             Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -320,11 +320,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&ty_to_string(&**ty));\n \n-                            match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n+                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        &ty::item_path_str(self.tcx, def_id));\n+                                        &self.tcx.item_path_str(def_id));\n                                 },\n                                 None => {}\n                             }\n@@ -344,12 +344,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                  impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 },\n             },\n-            None => match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n+            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n                     match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(self.tcx, def_id))\n+                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n                         _ => {\n                             self.sess.span_bug(span,\n@@ -368,7 +368,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n \n         // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(self.tcx, ast_util::local_def(id))\n+        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n             .and_then(|new_id| {\n                 let def_id = new_id.def_id();\n                 if def_id.node != 0 && def_id != ast_util::local_def(id) {\n@@ -776,10 +776,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(self.tcx, declid);\n+                    let ti = self.tcx.impl_or_trait_item(declid);\n                     match provenence {\n                         def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(self.tcx, def_id)\n+                            Some(self.tcx.trait_items(def_id)\n                                     .iter()\n                                     .find(|mr| {\n                                         mr.name() == ti.name()\n@@ -793,10 +793,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                            .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n-                                                ty::impl_or_trait_item(\n-                                                    self.tcx,\n-                                                    mr.def_id()\n-                                                ).name() == ti.name()\n+                                                self.tcx.impl_or_trait_item(mr.def_id()).name()\n+                                                    == ti.name()\n                                             })\n                                            .unwrap()\n                                            .def_id())\n@@ -826,7 +824,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // modules or types in the path prefix\n         match def {\n             def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(self.tcx, did);\n+                let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n                         self.write_sub_path_trait_truncated(path);\n@@ -895,14 +893,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n-                    match ty::trait_item_of_item(self.tcx, def_id) {\n+                    match self.tcx.trait_item_of_item(def_id) {\n                         None => None,\n                         Some(decl_id) => Some(decl_id.def_id()),\n                     };\n \n                 // This incantation is required if the method referenced is a\n                 // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(self.tcx, def_id) {\n+                let def_id = match self.tcx.impl_or_trait_item(def_id) {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n@@ -915,16 +913,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n-                let trait_item = ty::trait_item(self.tcx,\n-                                                mp.trait_ref.def_id,\n-                                                mp.method_num);\n+                let trait_item = self.tcx.trait_item(mp.trait_ref.def_id,\n+                                                     mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n-                let trait_item = ty::trait_item(self.tcx,\n-                                                mo.trait_ref.def_id,\n-                                                mo.method_num);\n+                let trait_item = self.tcx.trait_item(mo.trait_ref.def_id,\n+                                                     mo.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n         };\n@@ -953,7 +949,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(self.tcx, p.id)) {\n+                        match self.tcx.node_id_to_type(p.id).ty_to_def_id() {\n                             None => {\n                                 self.sess.span_bug(p.span,\n                                                    &format!(\"Could not find struct_def for `{}`\",\n@@ -965,7 +961,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 };\n \n                 if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(self.tcx, struct_def);\n+                    let struct_fields = self.tcx.lookup_struct_fields(struct_def);\n                     for &Spanned { node: ref field, span } in fields {\n                         let sub_span = self.span.span_for_first_ident(span);\n                         for f in &struct_fields {\n@@ -1252,10 +1248,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let ty = &ty::expr_ty_adjusted(self.tcx, &**sub_ex).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n+                        let fields = self.tcx.lookup_struct_fields(def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n                                 let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);"}, {"sha": "27805b9d8330b90066a29234a60cd9ba521bc5ef", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -327,10 +327,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let ty = &ty::expr_ty_adjusted(self.tcx, &sub_ex).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n+                        let fields = self.tcx.lookup_struct_fields(def_id);\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -354,7 +354,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let ty = &ty::expr_ty_adjusted(&self.tcx, expr).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(expr).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -384,7 +384,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               struct_id: DefId,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = ty::lookup_struct_fields(&self.tcx, struct_id);\n+        let fields = self.tcx.lookup_struct_fields(struct_id);\n         let field_name = get_ident(field_ref.ident.node).to_string();\n         for f in &fields {\n             if f.name == field_ref.ident.node.name {"}, {"sha": "47c2a5e579d941556252aca22000b49cff86c105", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -197,6 +197,7 @@ use middle::def::{self, DefMap};\n use middle::expr_use_visitor as euv;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Typer;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n@@ -235,7 +236,7 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n         match const_eval::compare_lit_exprs(tcx, self.0, other.0, None,\n-                                            |id| {ty::node_id_item_substs(tcx, id).substs}) {\n+                                            |id| {tcx.node_id_item_substs(id).substs}) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n@@ -279,7 +280,7 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         let ccx = bcx.ccx();\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n-                let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n+                let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n                 let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n@@ -562,7 +563,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n             check_match::Constructor::Variant(def_id)\n     };\n \n-    let param_env = ty::empty_parameter_environment(bcx.tcx());\n+    let param_env = bcx.tcx().empty_parameter_environment();\n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n         param_env: param_env,\n@@ -603,7 +604,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n+                        let variant = tcx.enum_variant_with_id(enum_id, var_id);\n                         Variant(variant.disr_val,\n                                 adt::represent_node(bcx, cur.id),\n                                 var_id,\n@@ -1067,7 +1068,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n-        param_env: ty::empty_parameter_environment(bcx.tcx()),\n+        param_env: bcx.tcx().empty_parameter_environment(),\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n@@ -1090,9 +1091,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n-                let fields = ty::lookup_struct_fields(bcx.tcx(), def_id);\n+                let fields = bcx.tcx().lookup_struct_fields(def_id);\n                 let unsized_ty = fields.iter().last().map(|field| {\n-                    let fty = ty::lookup_field_type(bcx.tcx(), def_id, field.id, substs);\n+                    let fty = bcx.tcx().lookup_field_type(def_id, field.id, substs);\n                     monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n                 }).unwrap();\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n@@ -1409,13 +1410,13 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n-        let param_env = ty::empty_parameter_environment(tcx);\n+        let param_env = tcx.empty_parameter_environment();\n \n         let llmatch;\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(&param_env, span, variable_ty) || reassigned =>\n+                if !param_env.type_moves_by_default(variable_ty, span) || reassigned =>\n             {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n@@ -1468,7 +1469,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     }\n \n     let t = node_id_type(bcx, discr_expr.id);\n-    let chk = if ty::type_is_empty(tcx, t) {\n+    let chk = if t.is_empty(tcx) {\n         Unreachable\n     } else {\n         Infallible\n@@ -1747,9 +1748,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n-                                                         enum_id,\n-                                                         var_id);\n+                    let vinfo = ccx.tcx().enum_variant_with_id(enum_id, var_id);\n                     let args = extract_variant_args(bcx,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n@@ -1789,7 +1788,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields {\n-                    let ix = ty::field_idx_strict(tcx, f.node.ident.name, field_tys);\n+                    let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, &*f.node.pat, fldptr, cleanup_scope);"}, {"sha": "3ce76167e85171b08425da88a9d34406e769acbb", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -209,13 +209,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n+            let fields = cx.tcx().lookup_struct_fields(def_id);\n             let mut ftys = fields.iter().map(|field| {\n-                let fty = ty::lookup_field_type(cx.tcx(), def_id, field.id, substs);\n+                let fty = cx.tcx().lookup_field_type(def_id, field.id, substs);\n                 monomorphize::normalize_associated_type(cx.tcx(), &fty)\n             }).collect::<Vec<_>>();\n-            let packed = ty::lookup_packed(cx.tcx(), def_id);\n-            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n+            let packed = cx.tcx().lookup_packed(def_id);\n+            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -230,10 +230,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::TyEnum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).get(0)\n+            let hint = *cx.tcx().lookup_repr_hints(def_id).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n+            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n \n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n@@ -261,9 +261,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n-                                      discriminants\",\n-                                      ty::item_path_str(cx.tcx(),\n-                                                        def_id)));\n+                                        discriminants\",\n+                                       cx.tcx().item_path_str(def_id)));\n             }\n \n             if cases.len() == 1 {\n@@ -411,9 +410,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n         ty::TyStruct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n+            let nonzero_fields = tcx.lookup_struct_fields(did);\n             assert_eq!(nonzero_fields.len(), 1);\n-            let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n+            let nonzero_field = tcx.lookup_field_type(did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n                 ty::TyRawPtr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n@@ -430,9 +429,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            let fields = tcx.lookup_struct_fields(def_id);\n             for (j, field) in fields.iter().enumerate() {\n-                let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n+                let field_ty = tcx.lookup_field_type(def_id, field.id, substs);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);\n@@ -504,7 +503,7 @@ fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n                    def_id: ast::DefId,\n                    substs: &subst::Substs<'tcx>)\n                    -> Vec<Case<'tcx>> {\n-    ty::enum_variants(tcx, def_id).iter().map(|vi| {\n+    tcx.enum_variants(def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n             monomorphize::apply_param_substs(tcx, substs, &raw_ty)\n         }).collect();"}, {"sha": "b432560bc4b3c2c8c96f2de4d6b85eef8f26b371", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -153,7 +153,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n \n     let mut attrs = llvm::AttrBuilder::new();\n     let ret_ty = fn_sig.output;\n@@ -274,7 +274,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n                 // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n                 // on memory dependencies rather than pointer equality\n-                let interior_unsafe = ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe();\n+                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n \n                 if mt.mutbl == ast::MutMutable || !interior_unsafe {\n                     attrs.arg(idx, llvm::Attribute::NoAlias);"}, {"sha": "42108d6d6e7b7024e744349ddc7fe2e2bddd7a56", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -232,7 +232,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n     // don't do this then linker errors can be generated where the linker\n     // complains that one object files has a thread local version of the\n     // symbol and another one doesn't.\n-    for attr in ty::get_attrs(ccx.tcx(), did).iter() {\n+    for attr in ccx.tcx().get_attrs(did).iter() {\n         if attr.check_name(\"thread_local\") {\n             llvm::set_thread_local(c, true);\n         }\n@@ -462,7 +462,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ty::enum_variants(ccx.tcx(), tid);\n+          let variants = ccx.tcx().enum_variants(tid);\n           let n_variants = (*variants).len();\n \n           // NB: we must hit the discriminant first so that structural\n@@ -1216,7 +1216,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n-          param_env: ty::empty_parameter_environment(ccx.tcx()),\n+          param_env: ccx.tcx().empty_parameter_environment(),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n           needs_ret_allocas: nested_returns,\n@@ -1668,8 +1668,8 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n-    let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &fn_ty.fn_ret());\n+    let fn_ty = ccx.tcx().node_id_to_type(id);\n+    let output_type = ccx.tcx().erase_late_bound_regions(&fn_ty.fn_ret());\n     let abi = fn_ty.fn_abi();\n     trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n                   closure::ClosureEnv::NotClosure);\n@@ -1704,7 +1704,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let result_ty = match ctor_ty.sty {\n         ty::TyBareFn(_, ref bft) => {\n-            ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n+            bcx.tcx().erase_late_bound_regions(&bft.sig.output()).unwrap()\n         }\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n@@ -1777,12 +1777,12 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                                                      disr: ty::Disr,\n                                                      param_substs: &'tcx Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n-    let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+    let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n         ty::TyBareFn(_, ref bft) => {\n-            ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n+            ccx.tcx().erase_late_bound_regions(&bft.sig.output())\n         }\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n@@ -1798,9 +1798,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let arg_tys =\n-        ty::erase_late_bound_regions(\n-            ccx.tcx(), &ctor_ty.fn_args());\n+    let arg_tys = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_args());\n \n     let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n \n@@ -1836,7 +1834,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n         return\n     }\n \n-    let ty = ty::node_id_to_type(ccx.tcx(), id);\n+    let ty = ccx.tcx().node_id_to_type(id);\n     let avar = adt::represent_type(ccx, ty);\n     match *avar {\n         adt::General(_, ref variants, _) => {\n@@ -2035,7 +2033,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     // error in trans. This is used to write compile-fail tests\n                     // that actually test that compilation succeeds without\n                     // reporting an error.\n-                    if ty::has_attr(ccx.tcx(), local_def(item.id), \"rustc_error\") {\n+                    if ccx.tcx().has_attr(local_def(item.id), \"rustc_error\") {\n                         ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n                     }\n                 }\n@@ -2314,7 +2312,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val: id={} item={:?}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n-            let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n+            let ty = ccx.tcx().node_id_to_type(i.id);\n             let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n@@ -2421,7 +2419,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n-                    let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n+                    let ty = ccx.tcx().node_id_to_type(ni.id);\n                     let name = foreign::link_name(&*ni);\n                     let llfn = foreign::register_foreign_item_fn(ccx, abi, ty, &name);\n                     attributes::from_fn_attrs(ccx, &ni.attrs, llfn);\n@@ -2442,7 +2440,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n             };\n             assert!(!args.is_empty());\n-            let ty = ty::node_id_to_type(ccx.tcx(), id);\n+            let ty = ccx.tcx().node_id_to_type(id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);\n             let sym = exported_name(ccx,\n@@ -2471,7 +2469,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             };\n             let parent = ccx.tcx().map.get_parent(id);\n             let struct_item = ccx.tcx().map.expect_item(parent);\n-            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+            let ty = ccx.tcx().node_id_to_type(ctor_id);\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n@@ -2503,7 +2501,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    attrs: &[ast::Attribute], span: Span) -> ValueRef {\n-    let mty = ty::node_id_to_type(ccx.tcx(), id);\n+    let mty = ccx.tcx().node_id_to_type(id);\n \n     let sym = exported_name(ccx, id, mty, &attrs);\n "}, {"sha": "24abe0ed3fdd2f7c36867bd704e2a12987ff0b3a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -173,7 +173,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                                 bcx.fcx.param_substs).val)\n             }\n             def::DefVariant(tid, vid, _) => {\n-                let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n+                let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n                 let substs = common::node_id_substs(bcx.ccx(),\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n@@ -307,7 +307,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                       bare_fn_ty));\n             }\n         };\n-    let sig = ty::erase_late_bound_regions(tcx, sig);\n+    let sig = tcx.erase_late_bound_regions(sig);\n     let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n     let tuple_fn_ty = tcx.mk_fn(opt_def_id,\n         tcx.mk_bare_fn(ty::BareFnTy {\n@@ -406,17 +406,17 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let substs = substs.erase_regions();\n \n     // Load the info for the appropriate trait if necessary.\n-    match ty::trait_of_item(tcx, def_id) {\n+    match tcx.trait_of_item(def_id) {\n         None => {}\n         Some(trait_id) => {\n-            ty::populate_implementations_for_trait_if_necessary(tcx, trait_id)\n+            tcx.populate_implementations_for_trait_if_necessary(trait_id)\n         }\n     }\n \n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n+    let (is_default, def_id, substs) = match tcx.provided_source(def_id) {\n         None => {\n             (false, def_id, tcx.mk_substs(substs))\n         }\n@@ -434,16 +434,16 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let impl_id = ty::impl_or_trait_item(tcx, def_id).container()\n+            let impl_id = tcx.impl_or_trait_item(def_id).container()\n                                                              .id();\n-            let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n+            let impl_or_trait_item = tcx.impl_or_trait_item(source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n+                    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n+                        tcx.make_substs_for_receiver_types(&trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them\n@@ -516,7 +516,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n             let ref_ty = match node {\n-                ExprId(id) => ty::node_id_to_type(tcx, id),\n+                ExprId(id) => tcx.node_id_to_type(id),\n                 MethodCallKey(method_call) => {\n                     tcx.method_map.borrow().get(&method_call).unwrap().ty\n                 }\n@@ -534,7 +534,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     }\n \n     // Type scheme of the function item (may have type params)\n-    let fn_type_scheme = ty::lookup_item_type(tcx, def_id);\n+    let fn_type_scheme = tcx.lookup_item_type(def_id);\n     let fn_type = monomorphize::normalize_associated_type(tcx, &fn_type_scheme.ty);\n \n     // Find the actual function pointer.\n@@ -640,7 +640,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n-        ty::node_id_to_type(bcx.tcx(), did.node)\n+        bcx.tcx().node_id_to_type(did.node)\n     } else {\n         csearch::get_type(bcx.tcx(), did).ty\n     };\n@@ -692,7 +692,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let (abi, ret_ty) = match callee_ty.sty {\n         ty::TyBareFn(_, ref f) => {\n-            let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n+            let output = bcx.tcx().erase_late_bound_regions(&f.sig.output());\n             (f.abi, output)\n         }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n@@ -914,9 +914,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              ignore_self: bool)\n                              -> Block<'blk, 'tcx>\n {\n-    let args =\n-        ty::erase_late_bound_regions(\n-            bcx.tcx(), &fn_ty.fn_args());\n+    let args = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_args());\n \n     // Translate the `self` argument first.\n     if !ignore_self {\n@@ -977,7 +975,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &fn_ty.fn_args());\n+    let arg_tys = bcx.tcx().erase_late_bound_regions( &fn_ty.fn_args());\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         bcx = trans_arg_datum(bcx,\n@@ -1023,7 +1021,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &fn_ty.fn_args());\n+    let arg_tys = cx.tcx().erase_late_bound_regions(&fn_ty.fn_args());\n     let variadic = fn_ty.fn_sig().0.variadic;\n \n     let mut bcx = cx;"}, {"sha": "cb30bcdbf53996ed0dd26f587d1cfe7d16f9f436", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -135,7 +135,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         return None\n     }\n \n-    let function_type = ty::node_id_to_type(ccx.tcx(), closure_id.node);\n+    let function_type = ccx.tcx().node_id_to_type(closure_id.node);\n     let function_type = monomorphize::apply_param_substs(ccx.tcx(), substs, &function_type);\n \n     // Normalize type so differences in regions and typedefs don't cause\n@@ -218,9 +218,9 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let function_type = typer.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().cloned().collect());\n+        tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n \n-    let sig = ty::erase_late_bound_regions(tcx, &function_type.sig);\n+    let sig = tcx.erase_late_bound_regions(&function_type.sig);\n \n     trans_closure(ccx,\n                   decl,\n@@ -392,7 +392,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n             ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n         });\n \n-    let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n+    let sig = tcx.erase_late_bound_regions(&llonce_bare_fn_ty.sig);\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,"}, {"sha": "777b61f25f0ef1f0536c49ee5b11f9b5b4aa3684", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -23,6 +23,7 @@ use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Typer;\n use middle::region;\n use middle::subst::{self, Subst, Substs};\n use trans::base;\n@@ -89,7 +90,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n             where T : TypeFoldable<'tcx>\n         {\n-            let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n+            let u = self.tcx().anonymize_late_bound_regions(t);\n             ty_fold::super_fold_binder(self, &u)\n         }\n \n@@ -119,7 +120,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n \n /// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty::type_is_sized(None, tcx, DUMMY_SP, ty)\n+    ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -161,7 +162,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n                 ty::TyFloat(_) | ty::TyTuple(_) | ty::TyRawPtr(_) => false,\n \n                 ty::TyEnum(did, substs) =>\n-                    ty::enum_variants(tcx, did).iter().any(|v|\n+                    tcx.enum_variants(did).iter().any(|v|\n                         v.args.iter().any(|&aty| {\n                             let t = aty.subst(tcx, substs);\n                             type_needs_unwind_cleanup_(tcx, t, tycache)\n@@ -183,7 +184,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n /// (Note that this implies that if `ty` has a destructor attached,\n /// then `type_needs_drop` will definitely return `true` for `ty`.)\n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_needs_drop_given_env(cx, ty, &ty::empty_parameter_environment(cx))\n+    type_needs_drop_given_env(cx, ty, &cx.empty_parameter_environment())\n }\n \n /// Core implementation of type_needs_drop, potentially making use of\n@@ -195,7 +196,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // normalized version of the type, and therefore will definitely\n     // know whether the type implements Copy (and thus needs no\n     // cleanup/drop/zeroing) ...\n-    let implements_copy = !ty::type_moves_by_default(&param_env, DUMMY_SP, ty);\n+    let implements_copy = !param_env.type_moves_by_default(ty, DUMMY_SP);\n \n     if implements_copy { return false; }\n \n@@ -210,17 +211,17 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // bound attached (see above), it is sound to treat it as having a\n     // destructor (e.g. zero its memory on move).\n \n-    let contents = ty::type_contents(cx, ty);\n+    let contents = ty.type_contents(cx);\n     debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n     contents.needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(ccx.tcx(), def_id);\n+            let fields = ccx.tcx().lookup_struct_fields(def_id);\n             fields.len() == 1 && {\n-                let ty = ty::lookup_field_type(ccx.tcx(), def_id, fields[0].id, substs);\n+                let ty = ccx.tcx().lookup_field_type(def_id, fields[0].id, substs);\n                 let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n                 type_is_immediate(ccx, ty)\n             }\n@@ -267,7 +268,7 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-    ty.is_nil() || ty::type_is_empty(ccx.tcx(), ty)\n+    ty.is_nil() || ty.is_empty(ccx.tcx())\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n@@ -661,8 +662,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n \n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-        self.fcx.param_env.type_moves_by_default(span, ty)\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        self.fcx.param_env.type_moves_by_default(ty, span)\n     }\n }\n \n@@ -952,7 +953,7 @@ pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> T\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     let tcx = bcx.tcx();\n-    let t = ty::node_id_to_type(tcx, id);\n+    let t = tcx.node_id_to_type(id);\n     monomorphize_type(bcx, t)\n }\n \n@@ -961,7 +962,7 @@ pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx>\n }\n \n pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n+    monomorphize_type(bcx, bcx.tcx().expr_ty_adjusted(ex))\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n@@ -989,7 +990,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n            trait_ref, trait_ref.def_id());\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     // Do the initial selection for the obligation. This yields the\n@@ -1077,7 +1078,7 @@ impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n         // Parameter environment is used to give details about type parameters,\n         // but since we are in trans, everything is fully monomorphized.\n-        NormalizingClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+        NormalizingClosureTyper { param_env: tcx.empty_parameter_environment() }\n     }\n }\n \n@@ -1111,7 +1112,7 @@ impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::closure_upvars(&self.param_env, def_id, substs);\n+        let result = self.param_env.closure_upvars(def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n@@ -1187,7 +1188,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = match node {\n         ExprId(id) => {\n-            ty::node_id_item_substs(tcx, id).substs\n+            tcx.node_id_item_substs(id).substs\n         }\n         MethodCallKey(method_call) => {\n             tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()"}, {"sha": "8ec60000ee8425014f7385d3f2e0e410a68ca087", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -57,7 +57,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             C_integral(Type::uint_from_ty(cx, t), u, false)\n         }\n         ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n-            let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n+            let lit_int_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_int_ty.sty {\n                 ty::TyInt(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n@@ -75,7 +75,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             C_floating(&fs, Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n-            let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n+            let lit_float_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_float_ty.sty {\n                 ty::TyFloat(t) => {\n                     C_floating(&fs, Type::float_from_ty(cx, t))\n@@ -249,7 +249,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n-                                                  &ty::expr_ty(ccx.tcx(), expr));\n+                                                  &ccx.tcx().expr_ty(expr));\n         const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n     } else {\n         const_expr(ccx, expr, param_substs, None).0\n@@ -276,11 +276,11 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             fn_args: FnArgMap)\n                             -> (ValueRef, Ty<'tcx>) {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                               &ty::expr_ty(cx.tcx(), e));\n+                                               &cx.tcx().expr_ty(e));\n     let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args);\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                                            &ty::expr_ty_adjusted(cx.tcx(), e));\n+                                                            &cx.tcx().expr_ty_adjusted(e));\n     let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n         Some(ty::AdjustReifyFnPointer) => {\n@@ -588,7 +588,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n+                  let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n@@ -803,7 +803,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = ty::eval_repeat_count(cx.tcx(), count);\n+            let n = cx.tcx().eval_repeat_count(count);\n             let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n@@ -829,9 +829,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n-                    let vinfo = ty::enum_variant_with_id(cx.tcx(),\n-                                                         enum_did,\n-                                                         variant_did);\n+                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n                     if !vinfo.args.is_empty() {\n                         // N-ary variant.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -884,9 +882,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   }\n                   def::DefVariant(enum_did, variant_did, _) => {\n                       let repr = adt::represent_type(cx, ety);\n-                      let vinfo = ty::enum_variant_with_id(cx.tcx(),\n-                                                           enum_did,\n-                                                           variant_did);\n+                      let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n@@ -945,8 +941,8 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) ->\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            let node_ty = ty::node_id_to_type(ccx.tcx(), id);\n-            let tcontents = ty::type_contents(ccx.tcx(), node_ty);\n+            let node_ty = ccx.tcx().node_id_to_type(id);\n+            let tcontents = node_ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n                 llvm::LLVMSetGlobalConstant(g, True);\n             }"}, {"sha": "2c539b67cb6274c282e6c1de5651412274d6020c", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -101,7 +101,8 @@ use trans::cleanup::CleanupMethods;\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n-use middle::ty::{self, Ty};\n+use middle::mem_categorization::Typer;\n+use middle::ty::Ty;\n \n use std::fmt;\n use syntax::ast;\n@@ -605,9 +606,8 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n          * affine values (since they must never be duplicated).\n          */\n \n-        assert!(!ty::type_moves_by_default(&ty::empty_parameter_environment(bcx.tcx()),\n-                                           DUMMY_SP,\n-                                           self.ty));\n+        assert!(!bcx.tcx().empty_parameter_environment()\n+                          .type_moves_by_default(self.ty, DUMMY_SP));\n         self.shallow_copy_raw(bcx, dst)\n     }\n "}, {"sha": "1fbbf0763aa53ba293c5f394a0167047ca0a6b58", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -242,9 +242,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::TyTrait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n \n-                let principal =\n-                    ty::erase_late_bound_regions(cx.tcx(),\n-                                                 &trait_data.principal);\n+                let principal = cx.tcx().erase_late_bound_regions(&trait_data.principal);\n \n                 from_def_id_and_substs(self,\n                                        cx,\n@@ -261,7 +259,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+                let sig = cx.tcx().erase_late_bound_regions(sig);\n \n                 for &parameter_type in &sig.inputs {\n                     let parameter_type_id =\n@@ -376,7 +374,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         unique_type_id.push_str(\"|\");\n \n-        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+        let sig = cx.tcx().erase_late_bound_regions(sig);\n \n         for &parameter_type in &sig.inputs {\n             let parameter_type_id =\n@@ -626,7 +624,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n+    let signature = cx.tcx().erase_late_bound_regions(signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n@@ -1176,7 +1174,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+    let mut fields = cx.tcx().struct_fields(def_id, substs);\n \n     // The `Ty` values returned by `ty::struct_fields` can still contain\n     // `TyProjection` variants, so normalize those away.\n@@ -1588,7 +1586,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n-    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n+    let variants = cx.tcx().enum_variants(enum_def_id);\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1891,7 +1889,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n+    let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_name(name).to_string();"}, {"sha": "7487e8d331bf55f47af81de1a7fca74fbb4b66fa", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -30,7 +30,7 @@ use rustc::ast_map;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n use trans::monomorphize;\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{Ty, ClosureTyper};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n \n@@ -412,7 +412,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n-        let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n+        let return_type = cx.tcx().node_id_to_type(fn_ast_id);\n         let return_type = monomorphize::apply_param_substs(cx.tcx(),\n                                                            param_substs,\n                                                            &return_type);\n@@ -425,7 +425,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // Arguments types\n         for arg in &fn_decl.inputs {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n-            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n+            let arg_type = cx.tcx().node_id_to_type(arg.pat.id);\n             let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n                                                             param_substs,\n                                                             &arg_type);"}, {"sha": "2e5943a248a5f81bbfd6b128d58f00b80fa86635", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -16,7 +16,7 @@ use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::ast_map;\n use trans::common::CrateContext;\n-use middle::ty::{self, ClosureTyper};\n+use middle::ty::ClosureTyper;\n \n use std::ffi::CString;\n use std::ptr;\n@@ -56,7 +56,7 @@ pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n }\n \n pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n-    ty::with_path(cx.tcx(), def_id, |path| {\n+    cx.tcx().with_path(def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n             let crate_namespace_name = token::intern(crate_root_namespace(cx));"}, {"sha": "6ea43d7392c944e19793905f49b9d3f5a9429802", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -106,7 +106,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            let principal = cx.tcx().erase_late_bound_regions(&trait_data.principal);\n             push_item_name(cx, principal.def_id, false, output);\n             push_type_params(cx, principal.substs, output);\n         },\n@@ -123,7 +123,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            let sig = cx.tcx().erase_late_bound_regions(sig);\n             if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n@@ -170,7 +170,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       def_id: ast::DefId,\n                       qualified: bool,\n                       output: &mut String) {\n-        ty::with_path(cx.tcx(), def_id, |path| {\n+        cx.tcx().with_path(def_id, |path| {\n             if qualified {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     output.push_str(crate_root_namespace(cx));"}, {"sha": "646ca6733c3b61864c8b2bacc7483f47542ae341", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -128,7 +128,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n-    let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n+    let sig = ty::Binder(ccx.tcx().erase_late_bound_regions(sig));\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));"}, {"sha": "8fd88055b8e45a58417999ed8567778b34680f66", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -73,7 +73,6 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::cast::{CastKind, CastTy};\n-use middle::ty::{struct_fields, tup_fields};\n use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n@@ -313,7 +312,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 old_info: Option<ValueRef>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> ValueRef {\n-    let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n+    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n         (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n@@ -500,7 +499,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n                 traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-                    ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n+                    bcx.tcx().custom_coerce_unsized_kind(impl_def_id)\n                 }\n                 vtable => {\n                     bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {:?}\",\n@@ -748,7 +747,7 @@ fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                base: &ast::Expr,\n                                field: ast::Name)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |tcx, field_tys| ty::field_idx_strict(tcx, field, field_tys))\n+    trans_field(bcx, base, |tcx, field_tys| tcx.field_idx_strict(field, field_tys))\n }\n \n /// Translates `base.<idx>`.\n@@ -789,8 +788,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n-                ty::no_late_bound_regions(\n-                    bcx.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n+                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let elt_ty = match ref_ty.builtin_deref(true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n@@ -1227,7 +1225,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match def {\n         def::DefVariant(tid, vid, _) => {\n-            let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n+            let variant_info = bcx.tcx().enum_variant_with_id(tid, vid);\n             if !variant_info.args.is_empty() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n@@ -1247,7 +1245,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::TyStruct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n+                ty::TyStruct(did, _) if bcx.tcx().has_dtor(did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n@@ -1342,13 +1340,22 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::TyStruct(did, substs) => {\n-            let fields = struct_fields(tcx, did, substs);\n+            let fields = tcx.struct_fields(did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n             op(0, &fields[..])\n         }\n \n         ty::TyTuple(ref v) => {\n-            op(0, &tup_fields(&v[..]))\n+            let fields: Vec<_> = v.iter().enumerate().map(|(i, &f)| {\n+                ty::field {\n+                    name: token::intern(&i.to_string()),\n+                    mt: ty::mt {\n+                        ty: f,\n+                        mutbl: ast::MutImmutable\n+                    }\n+                }\n+            }).collect();\n+            op(0, &fields)\n         }\n \n         ty::TyEnum(_, substs) => {\n@@ -1364,8 +1371,8 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n-                            let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n-                            let fields = struct_fields(tcx, variant_id, substs);\n+                            let variant_info = tcx.enum_variant_with_id(enum_id, variant_id);\n+                            let fields = tcx.struct_fields(variant_id, substs);\n                             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n                             op(variant_info.disr_val, &fields[..])\n                         }\n@@ -2241,8 +2248,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n-                ty::no_late_bound_regions(\n-                    ccx.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n+                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n@@ -2629,9 +2635,9 @@ fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n \n     match expr.node {\n         ast::ExprPath(..) => {\n-            match ty::resolve_expr(tcx, expr) {\n+            match tcx.resolve_expr(expr) {\n                 def::DefStruct(_) | def::DefVariant(..) => {\n-                    if let ty::TyBareFn(..) = ty::node_id_to_type(tcx, expr.id).sty {\n+                    if let ty::TyBareFn(..) = tcx.node_id_to_type(expr.id).sty {\n                         // ctor function\n                         ExprKind::RvalueDatum\n                     } else {"}, {"sha": "9e8c0189a9762722a7683480a7bc632c623684cf", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -109,7 +109,7 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n \n pub fn register_static(ccx: &CrateContext,\n                        foreign_item: &ast::ForeignItem) -> ValueRef {\n-    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n@@ -245,7 +245,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::TyBareFn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          &llsig.llarg_tys,\n@@ -478,7 +478,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n             match foreign_mod.abi {\n                 Rust | RustIntrinsic => {}\n                 abi => {\n-                    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+                    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n                         ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n@@ -554,7 +554,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n     let tys = foreign_types_for_id(ccx, node_id);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let t = ty::node_id_to_type(ccx.tcx(), node_id);\n+    let t = ccx.tcx().node_id_to_type(node_id);\n     let cconv = match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n@@ -578,7 +578,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 hash: Option<&str>) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n-    let fnty = ty::node_id_to_type(ccx.tcx(), id);\n+    let fnty = ccx.tcx().node_id_to_type(id);\n     let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n     let tys = foreign_types_for_fn_ty(ccx, mty);\n \n@@ -601,7 +601,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n-        let t = ty::node_id_to_type(tcx, id);\n+        let t = tcx.node_id_to_type(id);\n         let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n@@ -933,7 +933,7 @@ fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   id: ast::NodeId) -> ForeignTypes<'tcx> {\n-    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx(), id))\n+    foreign_types_for_fn_ty(ccx, ccx.tcx().node_id_to_type(id))\n }\n \n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -942,7 +942,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyBareFn(_, ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        &llsig.llarg_tys,"}, {"sha": "3bcdcd89c47f5d152a30aa51380dae329b6da515", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -326,7 +326,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         let tcx = ccx.tcx();\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n+        let class_ty = tcx.lookup_item_type(parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ccx.tcx().mk_ctor_fn(did,\n                                            &[get_drop_glue_type(ccx, t)],\n@@ -399,7 +399,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let fields = ty::struct_fields(bcx.tcx(), id, substs);\n+            let fields = bcx.tcx().struct_fields(id, substs);\n             let last_field = fields[fields.len()-1];\n             let field_ty = last_field.mt.ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n@@ -495,7 +495,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n         }\n         ty::TyStruct(did, substs) | ty::TyEnum(did, substs) => {\n             let tcx = bcx.tcx();\n-            match (ty::ty_dtor(tcx, did), skip_dtor) {\n+            match (tcx.ty_dtor(did), skip_dtor) {\n                 (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct)."}, {"sha": "75c80690f2ad4b73f415cd93112c27135859ca74", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -14,7 +14,6 @@ use middle::astencode;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use trans::common::*;\n-use middle::ty;\n \n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -28,7 +27,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n-                   ty::item_path_str(ccx.tcx(), fn_id), node_id);\n+                   ccx.tcx().item_path_str(fn_id), node_id);\n             return Some(local_def(node_id));\n         }\n         Some(&None) => {\n@@ -104,8 +103,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n           let mut my_id = 0;\n           match item.node {\n             ast::ItemEnum(_, _) => {\n-              let vs_here = ty::enum_variants(ccx.tcx(), local_def(item.id));\n-              let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n+              let vs_here = ccx.tcx().enum_variants(local_def(item.id));\n+              let vs_there = ccx.tcx().enum_variants(parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n@@ -140,7 +139,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // the logic to do that already exists in `middle`. In order to\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n-            let ty_trait_item = ty::impl_or_trait_item(ccx.tcx(), fn_id).clone();\n+            let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n             ccx.tcx().impl_or_trait_items.borrow_mut()\n                      .insert(local_def(trait_item.id), ty_trait_item);\n \n@@ -157,7 +156,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             // Translate monomorphic impl methods immediately.\n             if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n+                let impl_tpt = ccx.tcx().lookup_item_type(impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n                         sig.generics.ty_params.is_empty() {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());"}, {"sha": "b449c3ad060b81a82f67f31657ee0067c5eaf2d5", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -163,7 +163,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let ret_ty = match callee_ty.sty {\n         ty::TyBareFn(_, ref f) => {\n-            ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n+            bcx.tcx().erase_late_bound_regions(&f.sig.output())\n         }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n@@ -411,10 +411,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            let hash = ty::hash_crate_independent(\n-                ccx.tcx(),\n-                *substs.types.get(FnSpace, 0),\n-                &ccx.link_meta().crate_hash);\n+            let hash = ccx.tcx().hash_crate_independent(*substs.types.get(FnSpace, 0),\n+                                                        &ccx.link_meta().crate_hash);\n             C_u64(ccx, hash)\n         }\n         (_, \"init_dropped\") => {"}, {"sha": "a3e5b640fd0f1f5d022161f6dd5808e754f641a4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -182,7 +182,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n             expr_id={})\",\n            method_id,\n-           ty::item_path_str(tcx, trait_id),\n+           tcx.item_path_str(trait_id),\n            expr_id);\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n@@ -282,7 +282,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         traits::VtableObject(ref data) => {\n             let trait_item_def_ids =\n-                ty::trait_item_def_ids(ccx.tcx(), trait_id);\n+                ccx.tcx().trait_item_def_ids(trait_id);\n             let method_offset_in_trait =\n                 trait_item_def_ids.iter()\n                                   .position(|item| item.def_id() == method_id)\n@@ -314,7 +314,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n-                                ty::impl_or_trait_item(ccx.tcx(), did.def_id()).name() == name\n+                                ccx.tcx().impl_or_trait_item(did.def_id()).name() == name\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n@@ -334,7 +334,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableImpl(vtable_impl) => {\n             let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n+            let mname = match ccx.tcx().trait_item(trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.name,\n                 _ => {\n                     bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n@@ -567,12 +567,12 @@ pub fn trans_object_shim<'a, 'tcx>(\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n+    let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n+    let method_ty = match tcx.trait_item(trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n         _ => {\n             tcx.sess.bug(\"can't create a method shim for a non-method item\")\n@@ -591,7 +591,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n         ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n     });\n \n-    let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n+    let sig = ccx.tcx().erase_late_bound_regions(&fty.sig);\n \n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -747,16 +747,16 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            substs,\n            param_substs);\n \n-    let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n+    let trt_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n                                       make a vtable for a type impl!\")\n     };\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n+    tcx.populate_implementations_for_trait_if_necessary(trt_id);\n \n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n-    let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n+    let trait_item_def_ids = tcx.trait_item_def_ids(trt_id);\n     trait_item_def_ids\n         .iter()\n \n@@ -775,7 +775,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             debug!(\"emit_vtable_methods: trait_method_def_id={:?}\",\n                    trait_method_def_id);\n \n-            let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n+            let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n@@ -793,7 +793,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n             let impl_method_def_id = method_with_name(ccx, impl_id, name);\n-            let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n+            let impl_method_type = match tcx.impl_or_trait_item(impl_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n@@ -806,7 +806,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // particular set of type parameters. Note that this\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n-            if ty::provided_source(tcx, impl_method_def_id).is_some() {\n+            if tcx.provided_source(impl_method_def_id).is_some() {\n                 let predicates = impl_method_type.predicates.predicates.subst(tcx, &substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"emit_vtable_methods: predicates do not hold\");"}, {"sha": "cae810c9082e5f94a899cdd1881fa3040fa8764f", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -56,15 +56,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         params: &psubsts.types\n     };\n \n-    let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n+    let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n \n     debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n     let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n-            ty::item_path_str(ccx.tcx(), fn_id));\n+            ccx.tcx().item_path_str(fn_id));\n             return (val, mono_ty, false);\n         }\n         None => ()\n@@ -198,7 +198,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx().map.get_parent(fn_id.node);\n-            let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n+            let tvs = ccx.tcx().enum_variants(local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n@@ -284,7 +284,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n-    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n+    debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n     (lldecl, mono_ty, true)\n }\n "}, {"sha": "d94a0e235ee861fd3316451dc22ec7dc75e3b380", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -225,7 +225,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &**element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match ty::eval_repeat_count(bcx.tcx(), &**count_expr) {\n+                    match bcx.tcx().eval_repeat_count(&**count_expr) {\n                         0 => expr::trans_into(bcx, &**element, Ignore),\n                         1 => expr::trans_into(bcx, &**element, SaveIn(lldest)),\n                         count => {\n@@ -277,7 +277,7 @@ fn elements_required(bcx: Block, content_expr: &ast::Expr) -> usize {\n         },\n         ast::ExprVec(ref es) => es.len(),\n         ast::ExprRepeat(_, ref count_expr) => {\n-            ty::eval_repeat_count(bcx.tcx(), &**count_expr)\n+            bcx.tcx().eval_repeat_count(&**count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "20d25518e2700c8a7dd2b5d5081dad22229b285c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -102,7 +102,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            sig,\n            abi);\n \n-    let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+    let sig = cx.tcx().erase_late_bound_regions(sig);\n     assert!(!sig.variadic); // rust fns are never variadic\n \n     let mut atys: Vec<Type> = Vec::new();\n@@ -362,7 +362,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let unsized_part = ty::struct_tail(cx.tcx(), ty);\n+                  let unsized_part = cx.tcx().struct_tail(ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n                           Type::uint_from_ty(cx, ast::TyUs)\n@@ -454,7 +454,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             did: ast::DefId,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n-    let base = ty::item_path_str(cx.tcx(), did);\n+    let base = cx.tcx().item_path_str(did);\n     let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base"}, {"sha": "2575dc0184f8c6ede732dae63908b27dfab53aa0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -124,7 +124,7 @@ pub trait AstConv<'tcx> {\n                                         item_name: ast::Name)\n                                         -> Ty<'tcx>\n     {\n-        if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+        if self.tcx().binds_late_bound_regions(&poly_trait_ref) {\n             span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n@@ -513,7 +513,7 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n         let mut accumulator = Vec::new();\n-        ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+        input_type.accumulate_lifetimes_in_type(&mut accumulator);\n \n         if accumulator.len() == 1 {\n             // there's a chance that the unique lifetime of this\n@@ -1060,7 +1060,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n         traits::supertraits(tcx, object_trait_ref)\n         .flat_map(|tr| {\n-            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            let trait_def = tcx.lookup_trait_def(tr.def_id());\n             trait_def.associated_type_names\n                 .clone()\n                 .into_iter()\n@@ -1078,7 +1078,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name,\n-                    ty::item_path_str(tcx, trait_def_id));\n+                    tcx.item_path_str(trait_def_id));\n     }\n \n     tcx.mk_trait(object.principal, object.bounds)\n@@ -1265,7 +1265,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             _ => unreachable!()\n         }\n     } else {\n-        let trait_items = ty::trait_items(tcx, trait_did);\n+        let trait_items = tcx.trait_items(trait_did);\n         let item = trait_items.iter().find(|i| i.name() == assoc_name);\n         item.expect(\"missing associated type\").def_id()\n     };\n@@ -1290,7 +1290,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let self_ty = if let Some(ty) = opt_self_ty {\n         ty\n     } else {\n-        let path_str = ty::item_path_str(tcx, trait_def_id);\n+        let path_str = tcx.item_path_str(trait_def_id);\n         report_ambiguous_associated_type(tcx,\n                                          span,\n                                          \"Type\",\n@@ -2116,8 +2116,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        if ty::try_add_builtin_trait(tcx,\n-                                                     trait_did,\n+                        if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;"}, {"sha": "87f867d7f90acdfe3347e00070711fa3760ad4fe", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -147,7 +147,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n-            let const_scheme = ty::lookup_item_type(tcx, const_did);\n+            let const_scheme = tcx.lookup_item_type(const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n                                                            &Substs::empty(),\n@@ -227,8 +227,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n                                             path, pat.span, pat.id) {\n                 if check_assoc_item_is_const(pcx, def, pat.span) {\n-                    let scheme = ty::lookup_item_type(tcx, def.def_id());\n-                    let predicates = ty::lookup_predicates(tcx, def.def_id());\n+                    let scheme = tcx.lookup_item_type(def.def_id());\n+                    let predicates = tcx.lookup_predicates(def.def_id());\n                     instantiate_path(fcx, segments,\n                                      scheme, &predicates,\n                                      opt_ty, def, pat.span, pat.id);\n@@ -555,7 +555,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n             return;\n         },\n         _ => {\n-            let def_type = ty::lookup_item_type(tcx, def.def_id());\n+            let def_type = tcx.lookup_item_type(def.def_id());\n             match def_type.ty.sty {\n                 ty::TyStruct(struct_def_id, _) =>\n                     (struct_def_id, struct_def_id),\n@@ -579,8 +579,8 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n \n     instantiate_path(pcx.fcx,\n                      &path.segments,\n-                     ty::lookup_item_type(tcx, enum_def_id),\n-                     &ty::lookup_predicates(tcx, enum_def_id),\n+                     tcx.lookup_item_type(enum_def_id),\n+                     &tcx.lookup_predicates(enum_def_id),\n                      None,\n                      def,\n                      pat.span,\n@@ -595,7 +595,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n \n-    let struct_fields = ty::struct_fields(tcx, variant_def_id, &item_substs);\n+    let struct_fields = tcx.struct_fields(variant_def_id, &item_substs);\n     check_struct_pat_fields(pcx, pat.span, fields, &struct_fields,\n                             variant_def_id, etc);\n }\n@@ -631,10 +631,10 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n-    let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n-    let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n+    let ctor_scheme = tcx.lookup_item_type(enum_def);\n+    let ctor_predicates = tcx.lookup_predicates(enum_def);\n     let path_scheme = if ctor_scheme.ty.is_fn() {\n-        let fn_ret = ty::no_late_bound_regions(tcx, &ctor_scheme.ty.fn_ret()).unwrap();\n+        let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n         ty::TypeScheme {\n             ty: fn_ret.unwrap(),\n             generics: ctor_scheme.generics,\n@@ -664,14 +664,14 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ty::TyEnum(enum_def_id, expected_substs)\n             if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n         {\n-            let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n+            let variant = tcx.enum_variant_with_id(enum_def_id, def.def_id());\n             (variant.args.iter()\n                          .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n                          .collect(),\n              \"variant\")\n         }\n         ty::TyStruct(struct_def_id, expected_substs) => {\n-            let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n+            let struct_fields = tcx.struct_fields(struct_def_id, expected_substs);\n             (struct_fields.iter()\n                           .map(|field| fcx.instantiate_type_scheme(pat.span,\n                                                                    expected_substs,\n@@ -761,7 +761,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n-                            ty::item_path_str(tcx, struct_id),\n+                            tcx.item_path_str(struct_id),\n                             token::get_ident(field.ident));\n                         tcx.types.err\n                     })"}, {"sha": "7109e45b55279533f04b9d258ea690160f779e12", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -358,9 +358,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig =\n-                    ty::no_late_bound_regions(fcx.tcx(),\n-                                              method_callee.ty.fn_sig()).unwrap();\n+                let method_sig = fcx.tcx().no_late_bound_regions(method_callee.ty.fn_sig())\n+                                          .unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={:?}\",\n                        method_callee);"}, {"sha": "49b47da517720117139778d969980462eebaf615", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -80,7 +80,7 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n         ty::TyStruct(did, substs) => {\n-            match ty::struct_fields(fcx.tcx(), did, substs).pop() {\n+            match fcx.tcx().struct_fields(did, substs).pop() {\n                 None => None,\n                 Some(f) => unsize_kind(fcx, f.mt.ty)\n             }"}, {"sha": "d431c0fda986580839723df4af652c241888c877", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -65,10 +65,8 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     fcx.write_ty(expr.id, closure_type);\n \n-    let fn_sig =\n-        ty::liberate_late_bound_regions(fcx.tcx(),\n-                                        region::DestructionScopeData::new(body.id),\n-                                        &fn_ty.sig);\n+    let fn_sig = fcx.tcx().liberate_late_bound_regions(\n+        region::DestructionScopeData::new(body.id), &fn_ty.sig);\n \n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,"}, {"sha": "73b9a16d1ebea731bfe9dd6a3e6c6794eb82ef92", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -271,7 +271,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             _ => (source, None)\n         };\n-        let source = ty::adjust_ty_for_autoref(self.tcx(), source, reborrow);\n+        let source = source.adjust_for_autoref(self.tcx(), reborrow);\n \n         let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n "}, {"sha": "349d1a8bb65a8e1a0feb9000c3330876bd78a474", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -100,7 +100,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             token::get_name(trait_m.name),\n             impl_m.fty.sig.0.inputs.len(),\n             if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n-            ty::item_path_str(tcx, trait_m.def_id),\n+            tcx.item_path_str(trait_m.def_id),\n             trait_m.fty.sig.0.inputs.len());\n         return;\n     }"}, {"sha": "a48cffb4472f44d9d1664a18a3ade43d384b3d4d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -37,8 +37,8 @@ use syntax::codemap::{self, Span};\n ///\n pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n-    let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n+                         ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n+    let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n         ty::TyStruct(self_type_did, self_to_impl_substs) |\n@@ -91,7 +91,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n     let ty::TypeScheme { generics: ref named_type_generics,\n                          ty: named_type } =\n-        ty::lookup_item_type(tcx, self_type_did);\n+        tcx.lookup_item_type(self_type_did);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     infcx.commit_if_ok(|snapshot| {\n@@ -179,7 +179,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = ty::lookup_predicates(tcx, self_type_did);\n+    let generic_assumptions = tcx.lookup_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n@@ -288,7 +288,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         rcx.tcx().sess,\n                         span,\n                         \"overflowed on enum {} variant {} argument {} type: {}\",\n-                        ty::item_path_str(tcx, def_id),\n+                        tcx.item_path_str(def_id),\n                         variant,\n                         arg_index,\n                         detected_on_typ);\n@@ -298,7 +298,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         rcx.tcx().sess,\n                         span,\n                         \"overflowed on struct {} field {} type: {}\",\n-                        ty::item_path_str(tcx, def_id),\n+                        tcx.item_path_str(def_id),\n                         field,\n                         detected_on_typ);\n                 }\n@@ -365,7 +365,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         let (typ, xref_depth) = match typ.sty {\n             ty::TyStruct(struct_did, substs) => {\n                 if opt_phantom_data_def_id == Some(struct_did) {\n-                    let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n+                    let item_type = rcx.tcx().lookup_item_type(struct_did);\n                     let tp_def = item_type.generics.types\n                         .opt_get(subst::TypeSpace, 0).unwrap();\n                     let new_typ = substs.type_for_def(tp_def);\n@@ -471,13 +471,11 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     walker.skip_current_subtree();\n \n                     let fields =\n-                        ty::lookup_struct_fields(rcx.tcx(), struct_did);\n+                        rcx.tcx().lookup_struct_fields(struct_did);\n                     for field in &fields {\n-                        let field_type =\n-                            ty::lookup_field_type(rcx.tcx(),\n-                                                  struct_did,\n-                                                  field.id,\n-                                                  substs);\n+                        let field_type = rcx.tcx().lookup_field_type(struct_did,\n+                                                                     field.id,\n+                                                                     substs);\n                         try!(iterate_over_potentially_unsafe_regions_in_type(\n                             rcx,\n                             breadcrumbs,\n@@ -501,9 +499,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     walker.skip_current_subtree();\n \n                     let all_variant_info =\n-                        ty::substd_enum_variants(rcx.tcx(),\n-                                                 enum_did,\n-                                                 substs);\n+                        rcx.tcx().substd_enum_variants(enum_did, substs);\n                     for variant_info in &all_variant_info {\n                         for (i, arg_type) in variant_info.args.iter().enumerate() {\n                             try!(iterate_over_potentially_unsafe_regions_in_type(\n@@ -591,13 +587,13 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n         DtorKind::KnownDropMethod(dtor_method_did) => {\n-            let impl_did = ty::impl_of_method(tcx, dtor_method_did)\n+            let impl_did = tcx.impl_of_method(dtor_method_did)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_bug(\n                         span, \"no Drop impl found for drop method\")\n                 });\n \n-            let dtor_typescheme = ty::lookup_item_type(tcx, impl_did);\n+            let dtor_typescheme = tcx.lookup_item_type(impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n \n             let mut has_pred_of_interest = false;\n@@ -609,7 +605,7 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     continue;\n                 }\n \n-                for pred in ty::lookup_predicates(tcx, item_def_id).predicates {\n+                for pred in tcx.lookup_predicates(item_def_id).predicates {\n                     let result = match pred {\n                         ty::Predicate::Equate(..) |\n                         ty::Predicate::RegionOutlives(..) |\n@@ -623,7 +619,7 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                         ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n                             let def_id = t_pred.trait_ref.def_id;\n-                            if ty::trait_items(tcx, def_id).len() != 0 {\n+                            if tcx.trait_items(def_id).len() != 0 {\n                                 // If trait has items, assume it adds\n                                 // capability to access borrowed data.\n                                 true"}, {"sha": "5f7a78ec611a29e477b63679f49df5eb490cb1dd", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -139,7 +139,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             let region = self.infcx().next_region_var(infer::Autoref(self.span));\n             let autoref = ty::AutoPtr(self.tcx().mk_region(region), mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n-                ty::adjust_ty_for_autoref(self.tcx(), target, Some(autoref))\n+                target.adjust_for_autoref(self.tcx(), Some(autoref))\n             }))\n         } else {\n             // No unsizing should be performed without autoref (at\n@@ -179,7 +179,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         if let Some(target) = unsize {\n             target\n         } else {\n-            ty::adjust_ty_for_autoref(self.tcx(), autoderefd_ty, autoref)\n+            autoderefd_ty.adjust_for_autoref(self.tcx(), autoref)\n         }\n     }\n \n@@ -199,7 +199,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     {\n         match pick.kind {\n             probe::InherentImplPick(impl_def_id) => {\n-                assert!(ty::impl_trait_ref(self.tcx(), impl_def_id).is_none(),\n+                assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n@@ -254,15 +254,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     self.fcx.instantiate_type_scheme(\n                         self.span,\n                         &impl_polytype.substs,\n-                        &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n+                        &self.tcx().impl_trait_ref(impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num,\n                                                            impl_def_id: Some(impl_def_id) });\n                 (impl_trait_ref.substs.clone(), origin)\n             }\n \n             probe::TraitPick(trait_def_id, method_num) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+                let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in"}, {"sha": "0f8048f27a0e3bd8bc4c8a88c7dbd9c9bb09b5ab", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -167,7 +167,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            m_name,\n            trait_def_id);\n \n-    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n+    let trait_def = fcx.tcx().lookup_trait_def(trait_def_id);\n \n     let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n     let input_types = match opt_input_types {\n@@ -359,7 +359,7 @@ fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     item_name: ast::Name)\n                     -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     trait_items\n         .iter()\n         .enumerate()\n@@ -376,6 +376,6 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n         .find(|m| m.name() == item_name)\n }"}, {"sha": "8026fce69ecca5a418d6e46b446fd300eb02b217", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -377,7 +377,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<ast::DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n-            ty::populate_implementations_for_primitive_if_necessary(self.tcx(), impl_def_id);\n+            self.tcx().populate_implementations_for_primitive_if_necessary(impl_def_id);\n \n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n@@ -386,7 +386,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        ty::populate_inherent_implementations_for_type_if_necessary(self.tcx(), def_id);\n+        self.tcx().populate_inherent_implementations_for_type_if_necessary(def_id);\n \n         if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {\n@@ -606,7 +606,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n-            ty::trait_items(self.tcx(), trait_def_id);\n+            self.tcx().trait_items(trait_def_id);\n         let matching_index =\n             trait_items.iter()\n                        .position(|item| item.name() == self.item_name);\n@@ -647,7 +647,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                      item: ty::ImplOrTraitItem<'tcx>,\n                                                      item_index: usize)\n     {\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n@@ -665,7 +665,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"impl_substs={:?}\", impl_substs);\n \n             let impl_trait_ref =\n-                ty::impl_trait_ref(self.tcx(), impl_def_id)\n+                self.tcx().impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx(), &impl_substs);\n \n@@ -705,7 +705,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             None => { return true; }\n         };\n \n-        let impl_type = ty::lookup_item_type(self.tcx(), impl_def_id);\n+        let impl_type = self.tcx().lookup_item_type(impl_def_id);\n         let impl_simplified_type =\n             match fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n                 Some(simplified_type) => simplified_type,\n@@ -759,7 +759,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             let substs = self.infcx().fresh_substs_for_trait(self.span,\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n@@ -802,8 +802,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n                    projection_trait_ref);\n \n-            let trait_predicates = ty::lookup_predicates(self.tcx(),\n-                                                         projection_trait_ref.def_id);\n+            let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n             let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -894,7 +893,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 match source {\n                     TraitSource(id) => id,\n                     ImplSource(impl_id) => {\n-                        match ty::trait_id_of_impl(tcx, impl_id) {\n+                        match tcx.trait_id_of_impl(impl_id) {\n                             Some(id) => id,\n                             None =>\n                                 tcx.sess.span_bug(span,\n@@ -1081,7 +1080,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+                    let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n                     let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n                     let traits::Normalized { value: impl_bounds,\n                                              obligations: norm_obligations } =\n@@ -1266,7 +1265,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           impl_def_id: ast::DefId)\n                           -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n-        let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n+        let impl_pty = self.tcx().lookup_item_type(impl_def_id);\n \n         let type_vars =\n             impl_pty.generics.types.map(\n@@ -1301,7 +1300,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        ty::erase_late_bound_regions(self.tcx(), value)\n+        self.tcx().erase_late_bound_regions(value)\n     }\n }\n \n@@ -1314,7 +1313,7 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n         .find(|item| item.name() == item_name)\n }\n \n@@ -1325,7 +1324,7 @@ fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     item_name: ast::Name)\n                     -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()"}, {"sha": "b193ddcb2134903bb287ddde853011e58e8d597b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -66,7 +66,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // If the item has the name of a field, give a help note\n             if let (&ty::TyStruct(did, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                let fields = ty::lookup_struct_fields(cx, did);\n+                let fields = cx.lookup_struct_fields(did);\n \n                 if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n@@ -89,7 +89,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     // Determine if the field can be used as a function in some way\n-                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n+                    let field_ty = cx.lookup_field_type(did, field.id, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n                         let infcx = fcx.infcx();\n                         infcx.probe(|_| {\n@@ -159,7 +159,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n                                item_name,\n-                               ty::item_path_str(fcx.tcx(), trait_def_id));\n+                               fcx.tcx().item_path_str(trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                         msg, pprust::expr_to_string(callee))\n@@ -188,11 +188,12 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n \n-                    let insertion = match ty::impl_trait_ref(fcx.tcx(), impl_did) {\n+                    let insertion = match fcx.tcx().impl_trait_ref(impl_did) {\n                         None => format!(\"\"),\n-                        Some(trait_ref) => format!(\" of the trait `{}`\",\n-                                                   ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n+                        Some(trait_ref) => {\n+                            format!(\" of the trait `{}`\",\n+                                    fcx.tcx().item_path_str(trait_ref.def_id))\n+                        }\n                     };\n \n                     span_note!(fcx.sess(), item_span,\n@@ -207,7 +208,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n-                               ty::item_path_str(fcx.tcx(), trait_did));\n+                               fcx.tcx().item_path_str(trait_did));\n                 }\n             }\n         }\n@@ -243,7 +244,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.sess().fileline_help(span,\n                                      &*format!(\"candidate #{}: use `{}`\",\n                                                i + 1,\n-                                               ty::item_path_str(fcx.tcx(), *trait_did)))\n+                                               fcx.tcx().item_path_str(*trait_did)))\n \n         }\n         return\n@@ -289,7 +290,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.sess().fileline_help(span,\n                                      &*format!(\"candidate #{}: `{}`\",\n                                                i + 1,\n-                                               ty::item_path_str(fcx.tcx(), trait_info.def_id)))\n+                                               fcx.tcx().item_path_str(trait_info.def_id)))\n         }\n     }\n }"}, {"sha": "299ccd579ccb77130cd113dbf6e1864ab5aa7c46", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -97,7 +97,6 @@ use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n-use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n@@ -308,7 +307,7 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n         self.resolve_type_vars_or_error(&ty)\n     }\n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         !traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n@@ -363,9 +362,8 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n     fn closure_upvars(&self,\n                       def_id: ast::DefId,\n                       substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        ty::closure_upvars(self, def_id, substs)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>> {\n+        ty::ctxt::closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -430,7 +428,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::empty_parameter_environment(ccx.tcx);\n+    let param_env = ccx.tcx.empty_parameter_environment();\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -512,9 +510,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n             let fn_sig =\n-                liberate_late_bound_regions(ccx.tcx,\n-                                            region::DestructionScopeData::new(body.id),\n-                                            &fn_sig);\n+                ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n+                                                    &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n@@ -718,15 +715,15 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     check_representable(tcx, span, id, \"struct\");\n     check_instantiable(tcx, span, id);\n \n-    if ty::lookup_simd(tcx, local_def(id)) {\n+    if tcx.lookup_simd(local_def(id)) {\n         check_simd(tcx, span, id);\n     }\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_type(it.id={}, it.ident={})\",\n            it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+           ccx.tcx.item_path_str(local_def(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -741,7 +738,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemFn(..) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n-          match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n+          match ccx.tcx.impl_trait_ref(local_def(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n@@ -758,7 +755,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         check_struct(ccx, it.id, it.span);\n       }\n       ast::ItemTy(ref t, ref generics) => {\n-        let pty_ty = ty::node_id_to_type(ccx.tcx, it.id);\n+        let pty_ty = ccx.tcx.node_id_to_type(it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, pty_ty);\n       }\n       ast::ItemForeignMod(ref m) => {\n@@ -768,7 +765,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n+                let pty = ccx.tcx.lookup_item_type(local_def(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -790,18 +787,18 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_body(it.id={}, it.ident={})\",\n            it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+           ccx.tcx.item_path_str(local_def(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       ast::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let fn_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n-        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let impl_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n \n         for impl_item in impl_items {\n             match impl_item.node {\n@@ -820,7 +817,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         }\n       }\n       ast::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n+        let trait_def = ccx.tcx.lookup_trait_def(local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 ast::ConstTraitItem(_, Some(ref expr)) => {\n@@ -921,7 +918,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             item_generics, id);\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n-    let fty = ty::node_id_to_type(ccx.tcx, id);\n+    let fty = ccx.tcx.node_id_to_type(id);\n     debug!(\"check_method_body: fty={:?}\", fty);\n \n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n@@ -933,16 +930,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_items: &[P<ast::ImplItem>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n-    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n+    let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n             ast::ConstImplItem(..) => {\n                 let impl_const_def_id = local_def(impl_item.id);\n-                let impl_const_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                           impl_const_def_id);\n+                let impl_const_ty = ccx.tcx.impl_or_trait_item(impl_const_def_id);\n \n                 // Find associated const definition.\n                 let opt_associated_const =\n@@ -985,8 +981,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n                 let impl_method_def_id = local_def(impl_item.id);\n-                let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                          impl_method_def_id);\n+                let impl_item_ty = ccx.tcx.impl_or_trait_item(impl_method_def_id);\n \n                 // If this is an impl of a trait method, find the\n                 // corresponding method definition in the trait.\n@@ -1027,8 +1022,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n             ast::TypeImplItem(_) => {\n                 let typedef_def_id = local_def(impl_item.id);\n-                let typedef_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                        typedef_def_id);\n+                let typedef_ty = ccx.tcx.impl_or_trait_item(typedef_def_id);\n \n                 // If this is an impl of an associated type, find the\n                 // corresponding type definition in the trait.\n@@ -1067,8 +1061,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n-    let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n+    let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n+    let associated_consts = tcx.associated_consts(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n@@ -1189,13 +1183,13 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn get_item_type_scheme(&self, _: Span, id: ast::DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n-        Ok(ty::lookup_item_type(self.tcx(), id))\n+        Ok(self.tcx().lookup_item_type(id))\n     }\n \n     fn get_trait_def(&self, _: Span, id: ast::DefId)\n                      -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n-        Ok(ty::lookup_trait_def(self.tcx(), id))\n+        Ok(self.tcx().lookup_trait_def(id))\n     }\n \n     fn ensure_super_predicates(&self, _: Span, _: ast::DefId) -> Result<(), ErrorReported> {\n@@ -1238,7 +1232,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        let trait_def = ty::lookup_trait_def(self.ccx.tcx, trait_def_id);\n+        let trait_def = self.ccx.tcx.lookup_trait_def(trait_def_id);\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n@@ -1506,9 +1500,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             -> TypeAndSubsts<'tcx>\n     {\n         let type_scheme =\n-            ty::lookup_item_type(self.tcx(), def_id);\n+            self.tcx().lookup_item_type(def_id);\n         let type_predicates =\n-            ty::lookup_predicates(self.tcx(), def_id);\n+            self.tcx().lookup_predicates(def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n@@ -1543,7 +1537,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx();\n \n         let ty::TypeScheme { generics, ty: decl_ty } =\n-            ty::lookup_item_type(tcx, did);\n+            tcx.lookup_item_type(did);\n \n         let substs = astconv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n@@ -1651,14 +1645,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let raw_ty = self.expr_ty(expr);\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n-        ty::adjust_ty(self.tcx(),\n-                      expr.span,\n-                      expr.id,\n-                      raw_ty,\n-                      adjustment,\n-                      |method_call| self.inh.method_map.borrow()\n-                                                       .get(&method_call)\n-                                                       .map(|method| resolve_ty(method.ty)))\n+        raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n+            self.inh.method_map.borrow().get(&method_call)\n+                                        .map(|method| resolve_ty(method.ty))\n+        })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n@@ -1798,7 +1788,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                            -> Option<Ty<'tcx>>\n     {\n         let o_field = items.iter().find(|f| f.name == fieldname);\n-        o_field.map(|f| ty::lookup_field_type(self.tcx(), class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n@@ -1811,7 +1801,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                -> Option<Ty<'tcx>>\n     {\n         let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n-        o_field.map(|f| ty::lookup_field_type(self.tcx(), class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n@@ -2046,7 +2036,7 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // extract method method return type, which will be &T;\n             // all LB regions should have been instantiated during method lookup\n             let ret_ty = method.ty.fn_ret();\n-            let ret_ty = ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap();\n+            let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n             if let Some(method_call) = method_call {\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n@@ -2528,7 +2518,7 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               -> TypeAndSubsts<'tcx> {\n     let tcx = fcx.tcx();\n \n-    let ity = ty::lookup_item_type(tcx, did);\n+    let ity = tcx.lookup_item_type(did);\n     let (n_tps, rps, raw_ty) =\n         (ity.generics.types.len(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n@@ -2738,7 +2728,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n-                        let fields = ty::lookup_struct_fields(tcx, base_id);\n+                        let fields = tcx.lookup_struct_fields(base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n                     }\n@@ -2794,7 +2784,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let name = &ident;\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let fields = ty::lookup_struct_fields(tcx, id);\n+        let fields = tcx.lookup_struct_fields(id);\n         let mut best = None;\n         for elem in &fields {\n             let n = elem.name.as_str();\n@@ -2839,10 +2829,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n-                        tuple_like = ty::is_tuple_struct(tcx, base_id);\n+                        tuple_like = tcx.is_tuple_struct(base_id);\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n-                            let fields = ty::lookup_struct_fields(tcx, base_id);\n+                            let fields = tcx.lookup_struct_fields(base_id);\n                             fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n                         } else {\n@@ -2915,8 +2905,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         field.ident.span,\n                         |actual| match enum_id_opt {\n                             Some(enum_id) => {\n-                                let variant_type = ty::enum_variant_with_id(tcx,\n-                                                                            enum_id,\n+                                let variant_type = tcx.enum_variant_with_id(enum_id,\n                                                                             class_id);\n                                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n                                         actual, variant_type.name.as_str(),\n@@ -2934,7 +2923,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n                     let actual_id = match enum_id_opt {\n                         Some(_) => class_id,\n-                        None => ty::ty_to_def_id(struct_ty).unwrap()\n+                        None => struct_ty.ty_to_def_id().unwrap()\n                     };\n                     suggest_field_names(actual_id, &field.ident, tcx, skip_fields.collect());\n                     error_happened = true;\n@@ -2947,8 +2936,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 Some((field_id, false)) => {\n                     expected_field_type =\n-                        ty::lookup_field_type(\n-                            tcx, class_id, field_id, substitutions);\n+                        tcx.lookup_field_type(class_id, field_id, substitutions);\n                     expected_field_type =\n                         fcx.normalize_associated_types_in(\n                             field.span, &expected_field_type);\n@@ -3008,7 +2996,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         } = fcx.instantiate_type(span, class_id);\n \n         // Look up and check the fields.\n-        let class_fields = ty::lookup_struct_fields(tcx, class_id);\n+        let class_fields = tcx.lookup_struct_fields(class_id);\n         check_struct_or_variant_fields(fcx,\n                                        struct_type,\n                                        span,\n@@ -3051,7 +3039,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n-        let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n+        let variant_fields = tcx.lookup_struct_fields(variant_id);\n         check_struct_or_variant_fields(fcx,\n                                        enum_type,\n                                        span,\n@@ -3208,7 +3196,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                    if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n+                    if fcx.tcx().expr_is_lval(&**oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -3336,7 +3324,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, &**lhs) {\n+        if !tcx.expr_is_lval(&**lhs) {\n             span_err!(tcx.sess, expr.span, E0070,\n                 \"illegal left-hand side expression\");\n         }\n@@ -3465,7 +3453,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n-        let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n+        let count = fcx.tcx().eval_repeat_count(&**count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3558,7 +3546,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             },\n             def => {\n                 // Verify that this was actually a struct.\n-                let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n+                let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n                 match typ.ty.sty {\n                     ty::TyStruct(struct_did, _) => {\n                         check_struct_constructor(fcx,\n@@ -3605,7 +3593,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             .ty_to_string(\n                                                 actual_structure_type),\n                                          type_error);\n-                    ty::note_and_explain_type_err(tcx, &type_error, path.span);\n+                    tcx.note_and_explain_type_err(&type_error, path.span);\n                 }\n             }\n         }\n@@ -3700,7 +3688,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n-                    let predicates = ty::lookup_predicates(tcx, did);\n+                    let predicates = tcx.lookup_predicates(did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n                     let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n                     fcx.add_obligations_for_parameters(\n@@ -4096,7 +4084,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         e: &'tcx ast::Expr,\n                         id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n-    let rty = ty::node_id_to_type(ccx.tcx, id);\n+    let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n@@ -4129,14 +4117,14 @@ pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n                            designation: &str) -> bool {\n-    let rty = ty::node_id_to_type(tcx, item_id);\n+    let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match ty::is_type_representable(tcx, sp, rty) {\n+    match rty.is_representable(tcx, sp) {\n       ty::SelfRecursive => {\n         span_err!(tcx.sess, sp, E0072,\n             \"illegal recursive {} type; \\\n@@ -4164,8 +4152,8 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n                           item_id: ast::NodeId)\n                           -> bool {\n-    let item_ty = ty::node_id_to_type(tcx, item_id);\n-    if !ty::is_instantiable(tcx, item_ty) {\n+    let item_ty = tcx.node_id_to_type(item_id);\n+    if !item_ty.is_instantiable(tcx) {\n         span_err!(tcx.sess, sp, E0073,\n             \"this type cannot be instantiated without an \\\n              instance of itself\");\n@@ -4178,21 +4166,21 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n }\n \n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n-    let t = ty::node_id_to_type(tcx, id);\n+    let t = tcx.node_id_to_type(id);\n     if t.needs_subst() {\n         span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n     match t.sty {\n         ty::TyStruct(did, substs) => {\n-            let fields = ty::lookup_struct_fields(tcx, did);\n+            let fields = tcx.lookup_struct_fields(did);\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n+            let e = tcx.lookup_field_type(did, fields[0].id, substs);\n             if !fields.iter().all(\n-                         |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n+                         |f| tcx.lookup_field_type(did, f.id, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n@@ -4244,13 +4232,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           hint: attr::ReprAttr) {\n         #![allow(trivial_numeric_casts)]\n \n-        let rty = ty::node_id_to_type(ccx.tcx, id);\n+        let rty = ccx.tcx.node_id_to_type(id);\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n \n         let inh = static_inherited_fields(ccx);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-        let (_, repr_type_ty) = ty::enum_repr_type(ccx.tcx, Some(&hint));\n+        let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));\n         for v in vs {\n             if let Some(ref e) = v.node.disr_expr {\n                 check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n@@ -4261,7 +4249,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         // ty::enum_variants guards against discriminant overflows, so\n         // we need not check for that.\n-        let variants = ty::enum_variants(ccx.tcx, def_id);\n+        let variants = ccx.tcx.enum_variants(def_id);\n \n         for (v, variant) in vs.iter().zip(variants.iter()) {\n             let current_disr_val = variant.disr_val;\n@@ -4295,7 +4283,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n+    let hint = *ccx.tcx.lookup_repr_hints(ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n         .get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n@@ -4333,7 +4321,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n         def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n-            (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n+            (fcx.tcx().lookup_item_type(id), fcx.tcx().lookup_predicates(id))\n         }\n         def::DefTrait(_) |\n         def::DefTy(..) |\n@@ -4595,7 +4583,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // is inherent, there is no `Self` parameter, instead, the impl needs\n         // type parameters, which we can infer by unifying the provided `Self`\n         // with the substituted impl type.\n-        let impl_scheme = ty::lookup_item_type(fcx.tcx(), impl_def_id);\n+        let impl_scheme = fcx.tcx().lookup_item_type(impl_def_id);\n         assert_eq!(substs.types.len(subst::TypeSpace),\n                    impl_scheme.generics.types.len(subst::TypeSpace));\n         assert_eq!(substs.regions().len(subst::TypeSpace),\n@@ -5221,7 +5209,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             variadic: false,\n         }),\n     }));\n-    let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n+    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,"}, {"sha": "5a114c811191cdfa4659424f6d1dcdd2ac6d4579", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -56,7 +56,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     }\n \n     let tcx = fcx.tcx();\n-    if !ty::expr_is_lval(tcx, lhs_expr) {\n+    if !tcx.expr_is_lval(lhs_expr) {\n         span_err!(tcx.sess, lhs_expr.span, E0067, \"illegal left-hand side expression\");\n     }\n \n@@ -335,7 +335,7 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n             let ret_ty = method_ty.fn_ret();\n-            Ok(ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap())\n+            Ok(fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap())\n         }\n         None => {\n             Err(())"}, {"sha": "13961834aebdde4a63f6f0ef025d38169da199a2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -265,10 +265,10 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         if ty_unadjusted.references_error() {\n             ty_unadjusted\n         } else {\n-            let tcx = self.fcx.tcx();\n-            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted,\n-                          self.fcx.inh.adjustments.borrow().get(&expr.id),\n-                          |method_call| self.resolve_method_type(method_call))\n+            ty_unadjusted.adjust(\n+                self.fcx.tcx(), expr.span, expr.id,\n+                self.fcx.inh.adjustments.borrow().get(&expr.id),\n+                |method_call| self.resolve_method_type(method_call))\n         }\n     }\n \n@@ -662,7 +662,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        ty::no_late_bound_regions(rcx.tcx(), &method.ty.fn_ret()).unwrap();\n+                        rcx.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n                     fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -893,7 +893,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = method.ty.fn_sig();\n                 let fn_sig = // late-bound regions should have been instantiated\n-                    ty::no_late_bound_regions(rcx.tcx(), fn_sig).unwrap();\n+                    rcx.tcx().no_late_bound_regions(fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -1017,9 +1017,9 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0,\n-                           rcx.fcx.inh.adjustments.borrow().get(&id),\n-                           |method_call| rcx.resolve_method_type(method_call));\n+    let ty = ty0.adjust(tcx, origin.span(), id,\n+                        rcx.fcx.inh.adjustments.borrow().get(&id),\n+                        |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n             ty,  ty0,\n@@ -1172,10 +1172,8 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            id, mutbl, cmt_borrowed);\n \n     let rptr_ty = rcx.resolve_node_type(id);\n-    if !rptr_ty.references_error() {\n-        let tcx = rcx.fcx.ccx.tcx;\n+    if let ty::TyRef(&r, _) = rptr_ty.sty {\n         debug!(\"rptr_ty={}\",  rptr_ty);\n-        let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n     }\n@@ -1462,10 +1460,8 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            generic);\n \n     // To start, collect bounds from user:\n-    let mut param_bounds =\n-        ty::required_region_bounds(rcx.tcx(),\n-                                   generic.to_ty(rcx.tcx()),\n-                                   param_env.caller_bounds.clone());\n+    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n+                                                            param_env.caller_bounds.clone());\n \n     // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n     match *generic {\n@@ -1532,7 +1528,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // ```\n     //\n     // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-    let trait_predicates = ty::lookup_predicates(tcx, projection_ty.trait_ref.def_id);\n+    let trait_predicates = tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n     let predicates = trait_predicates.predicates.as_slice().to_vec();\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {"}, {"sha": "1345f322476b9789a73488a25d9b6baf5a47932f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -136,7 +136,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                    closure_def_id);\n         }\n \n-        ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+        self.tcx().with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n                 let var_node_id = freevar.def.local_node_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,"}, {"sha": "00bbbafd5cd32922dd60593ae1ee5404d3cb7304", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -16,7 +16,6 @@ use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n \n use std::collections::HashSet;\n@@ -56,7 +55,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n-               ty::item_path_str(ccx.tcx, local_def(item.id)));\n+               ccx.tcx.item_path_str(local_def(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -80,13 +79,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ty::impl_trait_ref(ccx.tcx,\n-                                                   local_def(item.id)).unwrap();\n-                ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n+                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        if !ty::trait_has_default_impl(ccx.tcx, trait_ref.def_id) {\n+                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n                             span_err!(ccx.tcx.sess, item.span, E0192,\n                                       \"negative impls are only allowed for traits with \\\n                                        default impls (e.g., `Send` and `Sync`)\")\n@@ -119,9 +117,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             ast::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n-                    ty::lookup_predicates(ccx.tcx, local_def(item.id));\n+                    ccx.tcx.lookup_predicates(local_def(item.id));\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ty::trait_has_default_impl(ccx.tcx, local_def(item.id)) {\n+                if ccx.tcx.trait_has_default_impl(local_def(item.id)) {\n                     if !items.is_empty() {\n                         span_err!(ccx.tcx.sess, item.span, E0380,\n                                   \"traits with default impls (`e.g. unsafe impl \\\n@@ -138,15 +136,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n-        let type_scheme = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        let type_predicates = ty::lookup_predicates(ccx.tcx, item_def_id);\n+        let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n+        let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n-        let param_env =\n-            ty::construct_parameter_environment(ccx.tcx,\n-                                                item.span,\n-                                                &type_scheme.generics,\n-                                                &type_predicates,\n-                                                item.id);\n+        let param_env = ccx.tcx.construct_parameter_environment(item.span,\n+                                                                &type_scheme.generics,\n+                                                                &type_predicates,\n+                                                                item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n@@ -201,7 +197,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         Some(&mut this.cache));\n             debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n-            let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh.param_env.free_substs,\n                                                       &type_scheme.ty);\n@@ -222,7 +218,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n             // to free.\n-            let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n+            let self_ty = fcx.tcx().node_id_to_type(item.id);\n             let self_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh.param_env.free_substs,\n                                                       &self_ty);\n@@ -231,7 +227,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Similarly, obtain an \"inside\" reference to the trait\n             // that the impl implements.\n-            let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n+            let trait_ref = match fcx.tcx().impl_trait_ref(local_def(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n@@ -258,7 +254,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n             let poly_trait_ref = ty::Binder(trait_ref);\n-            let predicates = ty::lookup_super_predicates(fcx.tcx(), poly_trait_ref.def_id());\n+            let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n             let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n@@ -278,8 +274,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      ast_generics: &ast::Generics)\n     {\n         let item_def_id = local_def(item.id);\n-        let ty_predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n-        let variances = ty::item_variances(self.tcx(), item_def_id);\n+        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n@@ -358,7 +354,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n-                             ty::item_path_str(self.tcx(), def_id)));\n+                             self.tcx().item_path_str(def_id)));\n             }\n             None => {\n                 // no lang items, no help!\n@@ -432,7 +428,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match ty::impl_or_trait_item(self.tcx(), local_def(id)) {\n+                match self.tcx().impl_or_trait_item(local_def(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n@@ -445,7 +441,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n         if let ast::MethodTraitItem(_, None) = trait_item.node {\n-            match ty::impl_or_trait_item(self.tcx(), local_def(trait_item.id)) {\n+            match self.tcx().impl_or_trait_item(local_def(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds(\n                         self.tcx(),\n@@ -496,7 +492,7 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n     pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, span: Span) {\n-        let trait_predicates = ty::lookup_predicates(self.fcx.tcx(), trait_ref.def_id);\n+        let trait_predicates = self.fcx.tcx().lookup_predicates(trait_ref.def_id);\n \n         let bounds = self.fcx.instantiate_bounds(span,\n                                                  trait_ref.substs,\n@@ -538,8 +534,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         self.binding_count += 1;\n-        let value = liberate_late_bound_regions(\n-            self.fcx.tcx(),\n+        let value = self.fcx.tcx().liberate_late_bound_regions(\n             region::DestructionScopeData::new(self.scope),\n             binder);\n         debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n@@ -567,7 +562,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::TyStruct(type_id, substs) |\n             ty::TyEnum(type_id, substs) => {\n-                let type_predicates = ty::lookup_predicates(self.fcx.tcx(), type_id);\n+                let type_predicates = self.fcx.tcx().lookup_predicates(type_id);\n                 let bounds = self.fcx.instantiate_bounds(self.span, substs,\n                                                          &type_predicates);\n \n@@ -638,7 +633,7 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         struct_def.fields\n         .iter()\n         .map(|field| {\n-            let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n+            let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n                                                        &fcx.inh.param_env.free_substs,\n                                                        &field_ty);\n@@ -655,13 +650,11 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .map(|variant| {\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) if !args.is_empty() => {\n-                    let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n+                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n \n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n-                    let arg_tys =\n-                        ty::no_late_bound_regions(\n-                            fcx.tcx(), &ctor_ty.fn_args()).unwrap();\n+                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "29119f3b5946dcc8de5a0a3fb4ae1a94abf73187", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -171,7 +171,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               ty::node_id_to_type(self.tcx(), p.id));\n+               self.tcx().node_id_to_type(p.id));\n \n         visit::walk_pat(self, p);\n     }\n@@ -334,11 +334,11 @@ impl ResolveReason {\n             ResolvingLocal(s) => s,\n             ResolvingPattern(s) => s,\n             ResolvingUpvar(upvar_id) => {\n-                ty::expr_span(tcx, upvar_id.closure_expr_id)\n+                tcx.expr_span(upvar_id.closure_expr_id)\n             }\n             ResolvingClosure(did) => {\n                 if did.krate == ast::LOCAL_CRATE {\n-                    ty::expr_span(tcx, did.node)\n+                    tcx.expr_span(did.node)\n                 } else {\n                     DUMMY_SP\n                 }\n@@ -403,7 +403,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0104,\n                         \"cannot resolve lifetime for captured variable `{}`: {}\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string(),\n+                        self.tcx.local_var_name_str(upvar_id.var_id).to_string(),\n                         infer::fixup_err_to_string(e));\n                 }\n "}, {"sha": "06bd572ac12f3729388a2906add266dcc0d83d53", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -139,15 +139,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n-        let self_type = ty::lookup_item_type(tcx, impl_did);\n+        let self_type = tcx.lookup_item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n-                                                    impl_did) {\n+        if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n                    item.ident);\n@@ -181,9 +180,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={:?})\",\n                impl_id, trait_ref);\n \n-        let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n+        let impl_type_scheme = tcx.lookup_item_type(impl_id);\n \n-        let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n+        let prov = tcx.provided_trait_methods(trait_ref.def_id);\n         for trait_method in &prov {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n@@ -245,8 +244,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref, impl_def_id);\n-        let trait_def = ty::lookup_trait_def(self.crate_context.tcx,\n-                                             impl_trait_ref.def_id);\n+        let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n         trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n@@ -273,11 +271,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }).collect();\n \n-                if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n-                                                            local_def(item.id)) {\n-                    self.instantiate_default_methods(local_def(item.id),\n-                                                     &trait_ref,\n-                                                     &mut items);\n+                let def_id = local_def(item.id);\n+                if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(def_id) {\n+                    self.instantiate_default_methods(def_id, &trait_ref, &mut items);\n                 }\n \n                 items\n@@ -299,8 +295,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n-        ty::populate_implementations_for_trait_if_necessary(tcx, drop_trait);\n-        let drop_trait = ty::lookup_trait_def(tcx, drop_trait);\n+        tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n+        let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n         let impl_items = tcx.impl_items.borrow();\n \n@@ -312,7 +308,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = ty::lookup_item_type(tcx, impl_did);\n+            let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n                 ty::TyEnum(type_def_id, _) |\n                 ty::TyStruct(type_def_id, _) |\n@@ -355,8 +351,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(id) => id,\n             None => return,\n         };\n-        ty::populate_implementations_for_trait_if_necessary(tcx, copy_trait);\n-        let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n+        tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n+        let copy_trait = tcx.lookup_trait_def(copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={:?}\",\n@@ -368,7 +364,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return\n             }\n \n-            let self_type = ty::lookup_item_type(tcx, impl_did);\n+            let self_type = tcx.lookup_item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n@@ -380,7 +376,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n                    self_type);\n \n-            match ty::can_type_implement_copy(&param_env, span, self_type) {\n+            match param_env.can_type_implement_copy(self_type, span) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                        span_err!(tcx.sess, span, E0204,\n@@ -425,7 +421,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n         };\n \n-        let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n+        let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n \n         trait_def.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n@@ -437,9 +433,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return;\n             }\n \n-            let source = ty::lookup_item_type(tcx, impl_did).ty;\n-            let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n-                                               impl_did).unwrap();\n+            let source = tcx.lookup_item_type(impl_did).ty;\n+            let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n@@ -478,8 +473,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n                 (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {\n                     if def_id_a != def_id_b {\n-                        let source_path = ty::item_path_str(tcx, def_id_a);\n-                        let target_path = ty::item_path_str(tcx, def_id_b);\n+                        let source_path = tcx.item_path_str(def_id_a);\n+                        let target_path = tcx.item_path_str(def_id_b);\n                         span_err!(tcx.sess, span, E0377,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with the same \\\n@@ -489,9 +484,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let origin = infer::Misc(span);\n-                    let fields = ty::lookup_struct_fields(tcx, def_id_a);\n+                    let fields = tcx.lookup_struct_fields(def_id_a);\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let ty = ty::lookup_field_type_unsubstituted(tcx, def_id_a, f.id);\n+                        let ty = tcx.lookup_field_type_unsubstituted(def_id_a, f.id);\n                         let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n                         if infcx.sub_types(false, origin, b, a).is_ok() {\n                             None\n@@ -592,7 +587,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            provided_source: Option<ast::DefId>)\n                                            -> ty::Method<'tcx>\n {\n-    let combined_substs = ty::make_substs_for_receiver_types(tcx, trait_ref, method);\n+    let combined_substs = tcx.make_substs_for_receiver_types(trait_ref, method);\n \n     debug!(\"subst_receiver_types_in_method_ty: combined_substs={:?}\",\n            combined_substs);"}, {"sha": "e585b8cd2bde0fea2076d1d4a7563dc6554d5675", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -67,7 +67,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n+                let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n                     ty::TyEnum(def_id, _) |\n                     ty::TyStruct(def_id, _) => {\n@@ -210,7 +210,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => { }\n@@ -269,9 +269,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 debug!(\"trait_ref={:?} trait_def_id={:?} trait_has_default_impl={}\",\n                        trait_ref,\n                        trait_def_id,\n-                       ty::trait_has_default_impl(self.tcx, trait_def_id));\n+                       self.tcx.trait_has_default_impl(trait_def_id));\n                 if\n-                    ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n+                    self.tcx.trait_has_default_impl(trait_def_id) &&\n                     trait_def_id.krate != ast::LOCAL_CRATE\n                 {\n                     let self_ty = trait_ref.self_ty();\n@@ -297,15 +297,15 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                     \"cross-crate traits with a default impl, like `{}`, \\\n                                      can only be implemented for a struct/enum type \\\n                                      defined in the current crate\",\n-                                    ty::item_path_str(self.tcx, trait_def_id)))\n+                                    self.tcx.item_path_str(trait_def_id)))\n                             }\n                         }\n                         _ => {\n                             Some(format!(\n                                 \"cross-crate traits with a default impl, like `{}`, \\\n                                  can only be implemented for a struct/enum type, \\\n                                  not `{}`\",\n-                                ty::item_path_str(self.tcx, trait_def_id),\n+                                self.tcx.item_path_str(trait_def_id),\n                                 self_ty))\n                         }\n                     };\n@@ -332,7 +332,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,\n                               \"cannot create default implementations for traits outside the \\"}, {"sha": "b4ad55ef2e46b8a7ae3c24d64a24d75fd293cae6", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -50,9 +50,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n \n         for trait_def in trait_defs {\n-            ty::populate_implementations_for_trait_if_necessary(\n-                self.tcx,\n-                trait_def.trait_ref.def_id);\n+            self.tcx.populate_implementations_for_trait_if_necessary(trait_def.trait_ref.def_id);\n             self.check_for_overlapping_impls_of_trait(trait_def);\n         }\n     }\n@@ -147,7 +145,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n                   \"conflicting implementations for trait `{}`\",\n-                  ty::item_path_str(self.tcx, trait_def_id));\n+                  self.tcx.item_path_str(trait_def_id));\n \n         self.report_overlap_note(impl1, impl2);\n     }\n@@ -181,7 +179,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = ast_util::local_def(item.id);\n-                let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n@@ -194,7 +192,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n             }\n             ast::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n                 let impl_def_id = ast_util::local_def(item.id);\n-                let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {\n                     ty::TyTrait(ref data) => {\n@@ -208,7 +206,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                             // giving a misleading message below.\n                             span_err!(self.tcx.sess, self_ty.span, E0372,\n                                       \"the trait `{}` cannot be made into an object\",\n-                                      ty::item_path_str(self.tcx, data.principal_def_id()));\n+                                      self.tcx.item_path_str(data.principal_def_id()));\n                         } else {\n                             let mut supertrait_def_ids =\n                                 traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n@@ -217,7 +215,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                           \"the object type `{}` automatically \\\n                                            implements the trait `{}`\",\n                                           trait_ref.self_ty(),\n-                                          ty::item_path_str(self.tcx, trait_def_id));\n+                                          self.tcx.item_path_str(trait_def_id));\n                             }\n                         }\n                     }"}, {"sha": "c0323ba60fc47040c99ca4df4c97b9b6ac64f473", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -30,7 +30,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self, item: &'v ast::Item,\n                                 unsafety: ast::Unsafety,\n                                 polarity: ast::ImplPolarity) {\n-        match ty::impl_trait_ref(self.tcx, ast_util::local_def(item.id)) {\n+        match self.tcx.impl_trait_ref(ast_util::local_def(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {\n@@ -43,7 +43,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n             }\n \n             Some(trait_ref) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n+                let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 match (trait_def.unsafety, unsafety, polarity) {\n                     (ast::Unsafety::Unsafe,\n                      ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {"}, {"sha": "e43a3542b6e338181397124ad8264abeccbdf885", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -242,12 +242,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             AstConvRequest::GetTraitDef(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when processing `{}`...\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n@@ -264,12 +264,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 AstConvRequest::GetTraitDef(def_id) => {\n                     tcx.sess.note(\n                         &format!(\"...which then requires processing `{}`...\",\n-                                 ty::item_path_str(tcx, def_id)));\n+                                 tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::EnsureSuperPredicates(def_id) => {\n                     tcx.sess.note(\n                         &format!(\"...which then requires computing the supertraits of `{}`...\",\n-                                 ty::item_path_str(tcx, def_id)));\n+                                 tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::GetTypeParameterBounds(id) => {\n                     let def = tcx.type_parameter_def(id);\n@@ -286,13 +286,13 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             AstConvRequest::GetTraitDef(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires computing the supertraits of `{}`, \\\n                               completing the cycle.\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n@@ -311,7 +311,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let tcx = self.tcx;\n \n         if trait_id.krate != ast::LOCAL_CRATE {\n-            return ty::lookup_trait_def(tcx, trait_id)\n+            return tcx.lookup_trait_def(trait_id)\n         }\n \n         let item = match tcx.map.get(trait_id.node) {\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n         if trait_def_id.krate == ast::LOCAL_CRATE {\n             trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n         } else {\n-            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             trait_def.associated_type_names.contains(&assoc_name)\n         }\n     }\n@@ -822,7 +822,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                     ast_trait_ref,\n                                                     None);\n \n-            ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n+            tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n             tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), Some(trait_ref));\n         }\n@@ -944,7 +944,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = ty::lookup_predicates(tcx, local_def(it.id));\n+            let trait_predicates = tcx.lookup_predicates(local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -1230,7 +1230,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n-    let paren_sugar = ty::has_attr(tcx, def_id, \"rustc_paren_sugar\");\n+    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n     if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n         ccx.tcx.sess.span_err(\n             it.span,\n@@ -1343,7 +1343,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n     };\n \n-    let super_predicates = ty::lookup_super_predicates(ccx.tcx, def_id);\n+    let super_predicates = ccx.tcx.lookup_super_predicates(def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n@@ -1407,7 +1407,7 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   -> ty::TypeScheme<'tcx>\n {\n     if def_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_item_type(ccx.tcx, def_id);\n+        return ccx.tcx.lookup_item_type(def_id);\n     }\n \n     match ccx.tcx.map.find(def_id.node) {\n@@ -1529,7 +1529,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n \n     // Debugging aid.\n-    if ty::has_attr(tcx, local_def(it.id), \"rustc_object_lifetime_default\") {\n+    if tcx.has_attr(local_def(it.id), \"rustc_object_lifetime_default\") {\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n@@ -1691,20 +1691,20 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(tcx, tpb);\n+            let trait_def_id = tcx.trait_ref_to_def_id(tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n                     tcx.sess.span_warn(span,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\\n                                        a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(tcx, kind_id, bounds);\n+                    tcx.try_add_builtin_trait(kind_id, bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(tcx, kind_id.unwrap(), bounds);\n+            tcx.try_add_builtin_trait(kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n@@ -2187,17 +2187,15 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         let required_type_free =\n             liberate_early_bound_regions(\n                 tcx, body_scope,\n-                &ty::liberate_late_bound_regions(\n-                    tcx, body_scope, &ty::Binder(required_type)));\n+                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n                 tcx, body_scope,\n-                &ty::liberate_late_bound_regions(\n-                    tcx, body_scope, &ty::Binder(base_type)));\n+                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={:?} required_type_free={:?} \\\n                 base_type={:?} base_type_free={:?}\",\n@@ -2262,9 +2260,9 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              impl_def_id: ast::DefId,\n                                              impl_items: &[P<ast::ImplItem>])\n {\n-    let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n-    let impl_predicates = ty::lookup_predicates(tcx, impl_def_id);\n-    let impl_trait_ref = ty::impl_trait_ref(tcx, impl_def_id);\n+    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n@@ -2293,7 +2291,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .map(|item| ty::impl_or_trait_item(tcx, local_def(item.id)))\n+                  .map(|item| tcx.impl_or_trait_item(local_def(item.id)))\n                   .filter_map(|item| match item {\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None"}, {"sha": "fc825c198e7513980376b8171a4a8ee67af9b2fe", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -199,7 +199,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n         Ok(_) => true,\n         Err(ref terr) => {\n             span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n-            ty::note_and_explain_type_err(tcx, terr, span);\n+            tcx.note_and_explain_type_err(terr, span);\n             false\n         }\n     }\n@@ -209,7 +209,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = ty::node_id_to_type(tcx, main_id);\n+    let main_t = tcx.node_id_to_type(main_id);\n     match main_t.sty {\n         ty::TyBareFn(..) => {\n             match tcx.map.find(main_id) {\n@@ -254,7 +254,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = ty::node_id_to_type(tcx, start_id);\n+    let start_t = tcx.node_id_to_type(start_id);\n     match start_t.sty {\n         ty::TyBareFn(..) => {\n             match tcx.map.find(start_id) {"}, {"sha": "c1f9725fc8134191721eb1e0b52a24b50a98a1a0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               ty::item_path_str(self.tcx, ast_util::local_def(item_id)),\n+               self.tcx.item_path_str(ast_util::local_def(item_id)),\n                item_id, kind, space, index, param_id, inf_index,\n                initial_variance);\n     }\n@@ -603,7 +603,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n-                let scheme = ty::lookup_item_type(tcx, did);\n+                let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -633,24 +633,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             ast::ItemStruct(..) => {\n-                let scheme = ty::lookup_item_type(tcx, did);\n+                let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(&scheme.generics);\n \n-                let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                let struct_fields = tcx.lookup_struct_fields(did);\n                 for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n-                    let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n+                    let field_ty = tcx.node_id_to_type(field_info.id.node);\n                     self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n                 }\n             }\n \n             ast::ItemTrait(..) => {\n-                let trait_def = ty::lookup_trait_def(tcx, did);\n+                let trait_def = tcx.lookup_trait_def(did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,\n                                                     trait_def.trait_ref,\n                                                     self.invariant);\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n-            let variances = ty::item_variances(self.tcx(), item_def_id);\n+            let variances = self.tcx().item_variances(item_def_id);\n             let variance = match kind {\n                 TypeParam => *variances.types.get(space, index),\n                 RegionParam => *variances.regions.get(space, index),\n@@ -848,7 +848,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                trait_ref,\n                variance);\n \n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n \n         self.add_constraints_from_substs(\n             generics,\n@@ -904,7 +904,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyEnum(def_id, substs) |\n             ty::TyStruct(def_id, substs) => {\n-                let item_type = ty::lookup_item_type(self.tcx(), def_id);\n+                let item_type = self.tcx().lookup_item_type(def_id);\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n@@ -924,7 +924,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n                 self.add_constraints_from_substs(\n                     generics,\n                     trait_ref.def_id,\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n-            if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n+            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n                 span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n             }\n "}, {"sha": "e80fd360e04fd2559b52ed3050a9655d5c306dc0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -150,9 +150,9 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n-    let def = ty::lookup_trait_def(tcx, did);\n-    let trait_items = ty::trait_items(tcx, did).clean(cx);\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let def = tcx.lookup_trait_def(did);\n+    let trait_items = tcx.trait_items(did).clean(cx);\n+    let predicates = tcx.lookup_predicates(did);\n     let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -165,12 +165,12 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n }\n \n fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n-    let t = ty::lookup_item_type(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n         ty::TyBareFn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let predicates = tcx.lookup_predicates(did);\n     clean::Function {\n         decl: decl,\n         generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n@@ -183,9 +183,9 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n     use syntax::parse::token::special_idents::unnamed_field;\n \n-    let t = ty::lookup_item_type(tcx, did);\n-    let predicates = ty::lookup_predicates(tcx, did);\n-    let fields = ty::lookup_struct_fields(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n+    let fields = tcx.lookup_struct_fields(did);\n \n     clean::Struct {\n         struct_type: match &*fields {\n@@ -201,14 +201,14 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n }\n \n fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n-    let t = ty::lookup_item_type(tcx, did);\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n         ty::TyEnum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: ty::enum_variants(tcx, edid).clean(cx),\n+                variants: tcx.enum_variants(edid).clean(cx),\n             })\n         }\n         _ => {}\n@@ -222,7 +222,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                    did: ast::DefId) -> Vec<clean::Item> {\n-    ty::populate_inherent_implementations_for_type_if_necessary(tcx, did);\n+    tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {\n@@ -307,16 +307,16 @@ pub fn build_impl(cx: &DocContext,\n         });\n     }\n \n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let predicates = tcx.lookup_predicates(did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n             .filter_map(|did| {\n         let did = did.def_id();\n-        let impl_item = ty::impl_or_trait_item(tcx, did);\n+        let impl_item = tcx.impl_or_trait_item(did);\n         match impl_item {\n             ty::ConstTraitItem(ref assoc_const) => {\n                 let did = assoc_const.def_id;\n-                let type_scheme = ty::lookup_item_type(tcx, did);\n+                let type_scheme = tcx.lookup_item_type(did);\n                 let default = match assoc_const.default {\n                     Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n                                                .unwrap().span.to_src(cx)),\n@@ -383,7 +383,7 @@ pub fn build_impl(cx: &DocContext,\n         }\n     }).collect::<Vec<_>>();\n     let polarity = csearch::get_impl_polarity(tcx, did);\n-    let ty = ty::lookup_item_type(tcx, did);\n+    let ty = tcx.lookup_item_type(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n             clean::TraitBound(polyt, _) => polyt.trait_,\n@@ -477,7 +477,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n+        type_: tcx.lookup_item_type(did).ty.clean(cx),\n         expr: sn\n     }\n }\n@@ -486,7 +486,7 @@ fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n+        type_: tcx.lookup_item_type(did).ty.clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "c25267520ccd80d89289741058fca3e28254f342", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -1332,7 +1332,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n         let provided = match self.container {\n             ty::ImplContainer(..) => false,\n             ty::TraitContainer(did) => {\n-                ty::provided_trait_methods(cx.tcx(), did).iter().any(|m| {\n+                cx.tcx().provided_trait_methods(did).iter().any(|m| {\n                     m.def_id == self.def_id\n                 })\n             }\n@@ -1742,7 +1742,7 @@ impl Clean<Item> for ty::field_ty {\n             (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n         };\n \n-        let ty = ty::lookup_item_type(cx.tcx(), self.id);\n+        let ty = cx.tcx().lookup_item_type(self.id);\n \n         Item {\n             name: name.clean(cx),\n@@ -2731,8 +2731,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             // are actually located on the trait/impl itself, so we need to load\n             // all of the generics from there and then look for bounds that are\n             // applied to this associated type in question.\n-            let def = ty::lookup_trait_def(cx.tcx(), did);\n-            let predicates = ty::lookup_predicates(cx.tcx(), did);\n+            let def = cx.tcx().lookup_trait_def(did);\n+            let predicates = cx.tcx().lookup_predicates(did);\n             let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n             generics.where_predicates.iter().filter_map(|pred| {\n                 let (name, self_type, trait_, bounds) = match *pred {"}, {"sha": "e65cdd8ff5de62e93a29261da5815b9f6aad93a6", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad66c215aa2b20cf42968915571886e6ce8e9dd4/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=ad66c215aa2b20cf42968915571886e6ce8e9dd4", "patch": "@@ -30,7 +30,6 @@ use std::mem;\n use std::collections::HashMap;\n \n use rustc::middle::subst;\n-use rustc::middle::ty;\n use syntax::ast;\n \n use clean::PathParameters as PP;\n@@ -154,8 +153,8 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: ast::DefId,\n     if child == trait_ {\n         return true\n     }\n-    let def = ty::lookup_trait_def(cx.tcx(), child);\n-    let predicates = ty::lookup_predicates(cx.tcx(), child);\n+    let def = cx.tcx().lookup_trait_def(child);\n+    let predicates = cx.tcx().lookup_predicates(child);\n     let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n     generics.where_predicates.iter().filter_map(|pred| {\n         match *pred {"}]}