{"sha": "328a898d23ce7f415e61399b687d7cdd70bfc566", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOGE4OThkMjNjZTdmNDE1ZTYxMzk5YjY4N2Q3Y2RkNzBiZmM1NjY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-03T20:36:13Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-06T15:03:56Z"}, "message": "Remove `valid_promotion_candidates`\n\nWe no longer compare the results of\n`promote_consts::validate_candidates` with\n`checker.promotion_candidates`, and `promote_consts` becomes the\ncanonical source for determining promotability.", "tree": {"sha": "58b08c98ab35d81f86bcf237a5285cad45a70c8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58b08c98ab35d81f86bcf237a5285cad45a70c8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/328a898d23ce7f415e61399b687d7cdd70bfc566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/328a898d23ce7f415e61399b687d7cdd70bfc566", "html_url": "https://github.com/rust-lang/rust/commit/328a898d23ce7f415e61399b687d7cdd70bfc566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/328a898d23ce7f415e61399b687d7cdd70bfc566/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61a551b4939ec1d5596e585351038b8fbd0124ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/61a551b4939ec1d5596e585351038b8fbd0124ba", "html_url": "https://github.com/rust-lang/rust/commit/61a551b4939ec1d5596e585351038b8fbd0124ba"}], "stats": {"total": 112, "additions": 39, "deletions": 73}, "files": [{"sha": "73471bab0169bb8c2ff606349373f0e2e645946d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 39, "deletions": 73, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/328a898d23ce7f415e61399b687d7cdd70bfc566/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328a898d23ce7f415e61399b687d7cdd70bfc566/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=328a898d23ce7f415e61399b687d7cdd70bfc566", "patch": "@@ -1064,7 +1064,13 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n             self.promotion_candidates.clone()\n         } else {\n-            self.valid_promotion_candidates()\n+            promote_consts::validate_candidates(\n+                self.tcx,\n+                self.body,\n+                self.def_id,\n+                &self.temp_promotion_state,\n+                &self.unchecked_promotion_candidates,\n+            )\n         };\n         debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n         for candidate in promotion_candidates {\n@@ -1106,49 +1112,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n \n-    /// Get the subset of `unchecked_promotion_candidates` that are eligible\n-    /// for promotion.\n-    // FIXME(eddyb) replace the old candidate gathering with this.\n-    fn valid_promotion_candidates(&self) -> Vec<Candidate> {\n-        // Sanity-check the promotion candidates.\n-        let candidates = promote_consts::validate_candidates(\n-            self.tcx,\n-            self.body,\n-            self.def_id,\n-            &self.temp_promotion_state,\n-            &self.unchecked_promotion_candidates,\n-        );\n-\n-        if candidates != self.promotion_candidates {\n-            let report = |msg, candidate| {\n-                let span = match candidate {\n-                    Candidate::Ref(loc) |\n-                    Candidate::Repeat(loc) => self.body.source_info(loc).span,\n-                    Candidate::Argument { bb, .. } => {\n-                        self.body[bb].terminator().source_info.span\n-                    }\n-                };\n-                self.tcx.sess.span_err(span, &format!(\"{}: {:?}\", msg, candidate));\n-            };\n-\n-            for &c in &self.promotion_candidates {\n-                if !candidates.contains(&c) {\n-                    report(\"invalidated old candidate\", c);\n-                }\n-            }\n-\n-            for &c in &candidates {\n-                if !self.promotion_candidates.contains(&c) {\n-                    report(\"extra new candidate\", c);\n-                }\n-            }\n-\n-            bug!(\"promotion candidate validation mismatches (see above)\");\n-        }\n-\n-        candidates\n-    }\n-\n     /// Returns `true` if the operand of a repeat expression is promotable.\n     fn should_promote_repeat_expression(&self, operand: &Operand<'tcx>) -> bool {\n         let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n@@ -1768,39 +1731,42 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n \n         debug!(\"run_pass: mode={:?}\", mode);\n         if let Mode::NonConstFn | Mode::ConstFn = mode {\n-            // This is ugly because Checker holds onto mir,\n-            // which can't be mutated until its scope ends.\n-            let (temps, candidates) = {\n-                let mut checker = Checker::new(tcx, def_id, body, mode);\n-                if let Mode::ConstFn = mode {\n-                    let use_min_const_fn_checks =\n-                        !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                        tcx.is_min_const_fn(def_id);\n-                    if use_min_const_fn_checks {\n-                        // Enforce `min_const_fn` for stable `const fn`s.\n-                        use super::qualify_min_const_fn::is_min_const_fn;\n-                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                            error_min_const_fn_violation(tcx, span, err);\n-                            return;\n-                        }\n-\n-                        // `check_const` should not produce any errors, but better safe than sorry\n-                        // FIXME(#53819)\n-                        // NOTE(eddyb) `check_const` is actually needed for promotion inside\n-                        // `min_const_fn` functions.\n+            let mut checker = Checker::new(tcx, def_id, body, mode);\n+            if let Mode::ConstFn = mode {\n+                let use_min_const_fn_checks =\n+                    !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                    tcx.is_min_const_fn(def_id);\n+                if use_min_const_fn_checks {\n+                    // Enforce `min_const_fn` for stable `const fn`s.\n+                    use super::qualify_min_const_fn::is_min_const_fn;\n+                    if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                        error_min_const_fn_violation(tcx, span, err);\n+                        return;\n                     }\n \n-                    // Enforce a constant-like CFG for `const fn`.\n-                    checker.check_const();\n-                } else {\n-                    while let Some((bb, data)) = checker.rpo.next() {\n-                        checker.visit_basic_block_data(bb, data);\n-                    }\n+                    // `check_const` should not produce any errors, but better safe than sorry\n+                    // FIXME(#53819)\n+                    // NOTE(eddyb) `check_const` is actually needed for promotion inside\n+                    // `min_const_fn` functions.\n                 }\n \n-                let promotion_candidates = checker.valid_promotion_candidates();\n-                (checker.temp_promotion_state, promotion_candidates)\n-            };\n+                // Enforce a constant-like CFG for `const fn`.\n+                checker.check_const();\n+            } else {\n+                while let Some((bb, data)) = checker.rpo.next() {\n+                    checker.visit_basic_block_data(bb, data);\n+                }\n+            }\n+\n+            // Promote only the promotable candidates.\n+            let temps = checker.temp_promotion_state;\n+            let candidates = promote_consts::validate_candidates(\n+                tcx,\n+                body,\n+                def_id,\n+                &temps,\n+                &checker.unchecked_promotion_candidates,\n+            );\n \n             // Do the actual promotion, now that we know what's viable.\n             self.promoted.set("}]}