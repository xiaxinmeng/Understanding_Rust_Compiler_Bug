{"sha": "25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZGU4MGFkMjMyYjg0Y2U1ODFmZTY3Y2MwOGI0M2U5ZGI2YjBiMWY=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-02-10T15:42:00Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-02-10T17:38:09Z"}, "message": "Remove common usage pattern from `AllocRef`", "tree": {"sha": "d454049b29646b57a6912f7f3b3b8262dc552e14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d454049b29646b57a6912f7f3b3b8262dc552e14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "html_url": "https://github.com/rust-lang/rust/commit/25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25de80ad232b84ce581fe67cc08b43e9db6b0b1f/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d1241f5158ffd66730e094d8f199ed654ed52ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae", "html_url": "https://github.com/rust-lang/rust/commit/4d1241f5158ffd66730e094d8f199ed654ed52ae"}], "stats": {"total": 232, "additions": 9, "deletions": 223}, "files": [{"sha": "144654946a2acb53225ac5dedb413f4a2aa95dd4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25de80ad232b84ce581fe67cc08b43e9db6b0b1f/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25de80ad232b84ce581fe67cc08b43e9db6b0b1f/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "patch": "@@ -280,7 +280,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, uniq) = match self.current_layout() {\n+            let (new_cap, ptr) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +297,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Ok(ptr) => (new_cap, ptr),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -308,13 +308,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n                     // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n+                    let layout = Layout::array::<T>(new_cap).unwrap();\n+                    match self.a.alloc(layout) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n             };\n-            self.ptr = uniq;\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n         }\n     }"}, {"sha": "c75ef44655f9591bd2809c57ee54131dcf1b2e28", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 199, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/25de80ad232b84ce581fe67cc08b43e9db6b0b1f/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25de80ad232b84ce581fe67cc08b43e9db6b0b1f/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "patch": "@@ -593,9 +593,8 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n-///   reallocation method (`realloc`, `realloc_excess`, or\n-///   `realloc_array`), and\n+///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n+///   (`realloc`, `realloc_excess`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n@@ -606,11 +605,6 @@ pub unsafe trait GlobalAlloc {\n /// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n-/// * However, some higher-level allocation methods (`alloc_one`,\n-///   `alloc_array`) are well-defined on zero-sized types and can\n-///   optionally support them: it is left up to the implementor\n-///   whether to return `Err`, or to return `Ok` with some pointer.\n-///\n /// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n@@ -1035,195 +1029,4 @@ pub unsafe trait AllocRef {\n         // new_layout.size() <= layout.size()        [required by this method]\n         if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-\n-    // == COMMON USAGE PATTERNS ==\n-    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n-\n-    /// Allocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `T` does not meet allocator's size or alignment constraints.\n-    ///\n-    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n-    /// will *not* yield undefined behavior.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n-    }\n-\n-    /// Deallocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// The given block must have been produced by this allocator,\n-    /// and must be suitable for storing a `T` (in terms of alignment\n-    /// as well as minimum and maximum size); otherwise yields\n-    /// undefined behavior.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            self.dealloc(ptr.cast(), k);\n-        }\n-    }\n-\n-    /// Allocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Reallocates a block previously suitable for holding `n_old`\n-    /// instances of `T`, returning a block suitable for holding\n-    /// `n_new` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n_new]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(\n-        &mut self,\n-        ptr: NonNull<T>,\n-        n_old: usize,\n-        n_new: usize,\n-    ) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n-                debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n-            }\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Deallocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `[T; n]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either `[T; n]` or the given\n-    /// memory block does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n-            _ => Err(AllocErr),\n-        }\n-    }\n }"}, {"sha": "b821a2c59396282462026cd60f03bee3b112cc00", "filename": "src/test/ui/allocator-alloc-one.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1241f5158ffd66730e094d8f199ed654ed52ae/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-alloc-one.rs?ref=4d1241f5158ffd66730e094d8f199ed654ed52ae", "patch": "@@ -1,18 +0,0 @@\n-// run-pass\n-\n-#![allow(stable_features)]\n-\n-#![feature(allocator_api, nonnull)]\n-\n-use std::alloc::{AllocRef, Global, Layout, handle_alloc_error};\n-\n-fn main() {\n-    unsafe {\n-        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| {\n-            handle_alloc_error(Layout::new::<i32>())\n-        });\n-        *ptr.as_ptr() = 4;\n-        assert_eq!(*ptr.as_ptr(), 4);\n-        Global.dealloc_one(ptr);\n-    }\n-}"}]}