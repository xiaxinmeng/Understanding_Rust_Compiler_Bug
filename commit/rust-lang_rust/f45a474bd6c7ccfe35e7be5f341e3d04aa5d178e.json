{"sha": "f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NWE0NzRiZDZjN2NjZmUzNWU3YmU1ZjM0MWUzZDA0YWE1ZDE3OGU=", "commit": {"author": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-06T17:11:27Z"}, "committer": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-13T13:40:51Z"}, "message": "rustc_trans: add abi::CastTarget::ChunkedPrefix", "tree": {"sha": "41274eff6d97946c68c99644bbbcfe631f939da5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41274eff6d97946c68c99644bbbcfe631f939da5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "html_url": "https://github.com/rust-lang/rust/commit/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e/comments", "author": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d2d3fc5dadf894a8ad709a5860a549f2c0b1032", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d2d3fc5dadf894a8ad709a5860a549f2c0b1032", "html_url": "https://github.com/rust-lang/rust/commit/4d2d3fc5dadf894a8ad709a5860a549f2c0b1032"}], "stats": {"total": 40, "additions": 38, "deletions": 2}, "files": [{"sha": "60f3105170b7d3baae38aabdd2d2a9878858ccb0", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "patch": "@@ -407,7 +407,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum CastTarget {\n     Uniform(Uniform),\n-    Pair(Reg, Reg)\n+    Pair(Reg, Reg),\n+    ChunkedPrefix { prefix: [RegKind; 8], chunk: Size, total: Size }\n }\n \n impl From<Reg> for CastTarget {\n@@ -429,7 +430,8 @@ impl CastTarget {\n             CastTarget::Pair(a, b) => {\n                 (a.size.abi_align(a.align(cx)) + b.size)\n                     .abi_align(self.align(cx))\n-            }\n+            },\n+            CastTarget::ChunkedPrefix { total, .. } => total\n         }\n     }\n \n@@ -440,6 +442,12 @@ impl CastTarget {\n                 cx.data_layout().aggregate_align\n                     .max(a.align(cx))\n                     .max(b.align(cx))\n+            },\n+            CastTarget::ChunkedPrefix { chunk, .. } => {\n+                cx.data_layout().aggregate_align\n+                    .max(Reg { kind: RegKind::Integer, size: chunk }.align(cx))\n+                    .max(Reg { kind: RegKind::Float, size: chunk }.align(cx))\n+                    .max(Reg { kind: RegKind::Vector, size: chunk }.align(cx))\n             }\n         }\n     }\n@@ -452,6 +460,34 @@ impl CastTarget {\n                     a.llvm_type(cx),\n                     b.llvm_type(cx)\n                 ], false)\n+            },\n+            CastTarget::ChunkedPrefix { prefix, chunk, total } => {\n+                let total_chunks = total.bytes() / chunk.bytes();\n+                let rem_bytes = total.bytes() % chunk.bytes();\n+                let prefix_chunks = total_chunks.min(prefix.len() as u64);\n+\n+                let int_ll_type = Reg { kind: RegKind::Integer, size: chunk }.llvm_type(cx);\n+\n+                // Simple cases simplify to an array\n+                if rem_bytes == 0 && prefix.into_iter().all(|&kind| kind == RegKind::Integer) {\n+                    return Type::array(&int_ll_type, total_chunks);\n+                }\n+\n+                // The final structure is made up of:\n+                //  Up to 8 chunks of the type specified in the prefix\n+                //  Any other complete chunks as integers\n+                //  One final integer needed to make up the total structure size\n+                let mut args: Vec<_> =\n+                    prefix.into_iter().take(prefix_chunks as usize)\n+                        .map(|&kind| Reg { kind: kind, size: chunk }.llvm_type(cx))\n+                    .chain((0..total_chunks - prefix_chunks).map(|_| int_ll_type))\n+                    .collect();\n+\n+                if rem_bytes > 0 {\n+                    args.push(Type::ix(cx, rem_bytes * 8));\n+                }\n+\n+                Type::struct_(cx, &args, false)\n             }\n         }\n     }"}]}