{"sha": "bca56e82a1bbd775498257cc080f5ea27b214f49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTU2ZTgyYTFiYmQ3NzU0OTgyNTdjYzA4MGY1ZWEyN2IyMTRmNDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-11T21:17:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-12T00:32:47Z"}, "message": "generalize type variables too\n\nWhen we are generalizing a super/sub-type, we have to replace type\nvariables with a fresh variable (and not just region variables).  So if\nwe know that `Box<?T> <: ?U`, for example, we instantiate `?U` with\n`Box<?V>` and then relate `Box<?T>` to `Box<?V>` (and hence require that\n`?T <: ?V`).\n\nThis change has some complex interactions, however:\n\nFirst, the occurs check must be updated to detect constraints like `?T\n<: ?U` and `?U <: Box<?T>`. If we're not careful, we'll create a\nnever-ending sequence of new variables. To address this, we add a second\nunification set into `type_variables` that tracks type variables related\nthrough **either** equality **or** subtyping, and use that during the\noccurs-check.\n\nSecond, the \"fudge regions if ok\" code was expecting no new type\nvariables to be created. It must be updated to create new type variables\noutside of the probe. This is relatively straight-forward under the new\nscheme, since type variables are now independent from one another, and\nany relations are moderated by pending subtype obliations and so forth.\nThis part would be tricky to backport though.\n\ncc #18653\ncc #40951", "tree": {"sha": "7e860851e6843f720c3d75b8a1323c2d346ccbfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e860851e6843f720c3d75b8a1323c2d346ccbfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca56e82a1bbd775498257cc080f5ea27b214f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca56e82a1bbd775498257cc080f5ea27b214f49", "html_url": "https://github.com/rust-lang/rust/commit/bca56e82a1bbd775498257cc080f5ea27b214f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca56e82a1bbd775498257cc080f5ea27b214f49/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5bbf89b2229c629c6f01bdd87354cba136d133", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5bbf89b2229c629c6f01bdd87354cba136d133", "html_url": "https://github.com/rust-lang/rust/commit/3a5bbf89b2229c629c6f01bdd87354cba136d133"}], "stats": {"total": 347, "additions": 297, "deletions": 50}, "files": [{"sha": "03ed654e3cce4f907b43d4ee2f39117805a522aa", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -264,20 +264,27 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Attempts to generalize `ty` for the type variable `for_vid`.  This checks for cycle -- that\n-    /// is, whether the type `ty` references `for_vid`. If `make_region_vars` is true, it will also\n-    /// replace all regions with fresh variables. Returns `TyError` in the case of a cycle, `Ok`\n-    /// otherwise.\n+    /// Attempts to generalize `ty` for the type variable `for_vid`.\n+    /// This checks for cycle -- that is, whether the type `ty`\n+    /// references `for_vid`. If `make_region_vars` is true, it will\n+    /// also replace all regions with fresh variables. Returns\n+    /// `TyError` in the case of a cycle, `Ok` otherwise.\n+    ///\n+    /// Preconditions:\n+    ///\n+    /// - `for_vid` is a \"root vid\"\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n                   -> RelateResult<'tcx, Ty<'tcx>>\n     {\n+        debug_assert!(self.infcx.type_variables.borrow_mut().root_var(for_vid) == for_vid);\n+\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid: for_vid,\n+            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n             make_region_vars: make_region_vars,\n             cycle_detected: false\n         };\n@@ -293,7 +300,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n-    for_vid: ty::TyVid,\n+    for_vid_sub_root: ty::TyVid,\n     make_region_vars: bool,\n     cycle_detected: bool,\n }\n@@ -305,17 +312,17 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         // Check to see whether the type we are genealizing references\n-        // `vid`. At the same time, also update any type variables to\n-        // the values that they are bound to. This is needed to truly\n-        // check for cycles, but also just makes things readable.\n-        //\n-        // (In particular, you could have something like `$0 = Box<$1>`\n-        //  where `$1` has already been instantiated with `Box<$0>`)\n+        // any other type variable related to `vid` via\n+        // subtyping. This is basically our \"occurs check\", preventing\n+        // us from creating infinitely sized types.\n         match t.sty {\n             ty::TyInfer(ty::TyVar(vid)) => {\n                 let mut variables = self.infcx.type_variables.borrow_mut();\n                 let vid = variables.root_var(vid);\n-                if vid == self.for_vid {\n+                let sub_vid = variables.sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n                     self.cycle_detected = true;\n                     self.tcx().types.err\n                 } else {\n@@ -324,7 +331,18 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n                             drop(variables);\n                             self.fold_ty(u)\n                         }\n-                        None => t,\n+                        None => {\n+                            if self.make_region_vars {\n+                                let origin = variables.origin(vid);\n+                                let new_var_id = variables.new_var(false, origin, None);\n+                                let u = self.tcx().mk_var(new_var_id);\n+                                debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n+                                       vid, u);\n+                                u\n+                            } else {\n+                                t\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "ab0ff32dcc3ecd5c59c6dd5af990c9054ac29216", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::{self, TyCtxt};\n+use infer::type_variable::TypeVariableMap;\n+use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n \n use super::InferCtxt;\n@@ -54,57 +55,52 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the actual types (`?T`, `Option<?T`) -- and remember that\n     /// after the snapshot is popped, the variable `?T` is no longer\n     /// unified.\n-    ///\n-    /// Assumptions:\n-    /// - no new type variables are created during `f()` (asserted\n-    ///   below); this simplifies our logic since we don't have to\n-    ///   check for escaping type variables\n     pub fn fudge_regions_if_ok<T, E, F>(&self,\n                                         origin: &RegionVariableOrigin,\n                                         f: F) -> Result<T, E> where\n         F: FnOnce() -> Result<T, E>,\n         T: TypeFoldable<'tcx>,\n     {\n-        let (region_vars, value) = self.probe(|snapshot| {\n-            let vars_at_start = self.type_variables.borrow().num_vars();\n+        debug!(\"fudge_regions_if_ok(origin={:?})\", origin);\n \n+        let (type_variables, region_vars, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n                     let value = self.resolve_type_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n-                    // to regions that have been created during the\n-                    // snapshot (we assert below that `f()` does not\n-                    // create any new type variables, so there\n-                    // shouldn't be any of those). Once we exit\n-                    // `probe()`, those are going to be popped, so we\n-                    // will have to eliminate any references to them.\n-\n-                    assert_eq!(self.type_variables.borrow().num_vars(), vars_at_start,\n-                               \"type variables were created during fudge_regions_if_ok\");\n+                    // to types/regions that have been created during\n+                    // the snapshot. Once we exit `probe()`, those are\n+                    // going to be popped, so we will have to\n+                    // eliminate any references to them.\n+\n+                    let type_variables =\n+                        self.type_variables.borrow_mut().types_created_since_snapshot(\n+                            &snapshot.type_snapshot);\n                     let region_vars =\n                         self.region_vars.vars_created_since_snapshot(\n                             &snapshot.region_vars_snapshot);\n \n-                    Ok((region_vars, value))\n+                    Ok((type_variables, region_vars, value))\n                 }\n                 Err(e) => Err(e),\n             }\n         })?;\n \n         // At this point, we need to replace any of the now-popped\n-        // region variables that appear in `value` with a fresh region\n-        // variable. We can't do this during the probe because they\n-        // would just get popped then too. =)\n+        // type/region variables that appear in `value` with a fresh\n+        // variable of the appropriate kind. We can't do this during\n+        // the probe because they would just get popped then too. =)\n \n         // Micro-optimization: if no variables have been created, then\n         // `value` can't refer to any of them. =) So we can just return it.\n-        if region_vars.is_empty() {\n+        if type_variables.is_empty() && region_vars.is_empty() {\n             return Ok(value);\n         }\n \n         let mut fudger = RegionFudger {\n             infcx: self,\n+            type_variables: &type_variables,\n             region_vars: &region_vars,\n             origin: origin\n         };\n@@ -115,6 +111,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    type_variables: &'a TypeVariableMap,\n     region_vars: &'a Vec<ty::RegionVid>,\n     origin: &'a RegionVariableOrigin,\n }\n@@ -124,6 +121,40 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyInfer(ty::InferTy::TyVar(vid)) => {\n+                match self.type_variables.get(&vid) {\n+                    None => {\n+                        // This variable was created before the\n+                        // \"fudging\".  Since we refresh all type\n+                        // variables to their binding anyhow, we know\n+                        // that it is unbound, so we can just return\n+                        // it.\n+                        debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_none());\n+                        ty\n+                    }\n+\n+                    Some(info) => {\n+                        // This variable was created during the\n+                        // fudging; it was mapped the root\n+                        // `root_vid`. There are now two\n+                        // possibilities: either the root was creating\n+                        // during the fudging too, in which case we\n+                        // want a fresh variable, or it was not, in\n+                        // which case we can return it.\n+                        if self.type_variables.contains_key(&info.root_vid) {\n+                            self.infcx.next_ty_var(info.root_origin)\n+                        } else {\n+                            self.infcx.tcx.mk_var(info.root_vid)\n+                        }\n+                    }\n+                }\n+            }\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n     fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         match *r {\n             ty::ReVar(v) if self.region_vars.contains(&v) => {"}, {"sha": "e98792b120de284c332e144571439a39a69e11af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -1036,9 +1036,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             let origin = &ObligationCause::dummy();\n             let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            self.sub(true, trace, &a, &b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n             })\n         })\n     }"}, {"sha": "2a7dbbc026bc0bda28f84ce3236871ee60b4497a", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -80,15 +80,19 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(_)), &ty::TyInfer(TyVar(_))) => {\n+            (&ty::TyInfer(TyVar(a_vid)), &ty::TyInfer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n                 assert!(!a.has_escaping_regions());\n                 assert!(!b.has_escaping_regions());\n \n                 // can't make progress on `A <: B` if both A and B are\n-                // type variables, so record an obligation.\n+                // type variables, so record an obligation. We also\n+                // have to record in the `type_variables` tracker that\n+                // the two variables are equal modulo subtyping, which\n+                // is important to the occurs check later on.\n+                infcx.type_variables.borrow_mut().sub(a_vid, b_vid);\n                 self.fields.obligations.push(\n                     Obligation::new(\n                         self.fields.trace.cause.clone(),"}, {"sha": "a32404c1ac515bcb54a2ce8b1ff6aacc774751a2", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 103, "deletions": 5, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -18,16 +18,39 @@ use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n     values: sv::SnapshotVec<Delegate<'tcx>>,\n+\n+    /// Two variables are unified in `eq_relations` when we have a\n+    /// constraint `?X == ?Y`.\n     eq_relations: ut::UnificationTable<ty::TyVid>,\n+\n+    /// Two variables are unified in `eq_relations` when we have a\n+    /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n+    /// table exists only to help with the occurs check. In particular,\n+    /// we want to report constraints like these as an occurs check\n+    /// violation:\n+    ///\n+    ///     ?1 <: ?3\n+    ///     Box<?3> <: ?1\n+    ///\n+    /// This works because `?1` and `?3` are unified in the\n+    /// `sub_relations` relation (not in `eq_relations`). Then when we\n+    /// process the `Box<?3> <: ?1` constraint, we do an occurs check\n+    /// on `Box<?3>` and find a potential cycle.\n+    ///\n+    /// This is reasonable because, in Rust, subtypes have the same\n+    /// \"skeleton\" and hence there is no possible type such that\n+    /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n+    sub_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n /// Reasons to create a type inference variable\n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum TypeVariableOrigin {\n     MiscVariable(Span),\n     NormalizeProjectionType(Span),\n@@ -41,6 +64,14 @@ pub enum TypeVariableOrigin {\n     DivergingBlockExpr(Span),\n     DivergingFn(Span),\n     LatticeVariable(Span),\n+    Generalized(ty::TyVid),\n+}\n+\n+pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableInfo>;\n+\n+pub struct TypeVariableInfo {\n+    pub root_vid: ty::TyVid,\n+    pub root_origin: TypeVariableOrigin,\n }\n \n struct TypeVariableData<'tcx> {\n@@ -70,6 +101,7 @@ pub struct Default<'tcx> {\n pub struct Snapshot {\n     snapshot: sv::Snapshot,\n     eq_snapshot: ut::Snapshot<ty::TyVid>,\n+    sub_snapshot: ut::Snapshot<ty::TyVid>,\n }\n \n struct Instantiate<'tcx> {\n@@ -84,6 +116,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n             values: sv::SnapshotVec::new(),\n             eq_relations: ut::UnificationTable::new(),\n+            sub_relations: ut::UnificationTable::new(),\n         }\n     }\n \n@@ -109,6 +142,16 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         debug_assert!(self.probe(a).is_none());\n         debug_assert!(self.probe(b).is_none());\n         self.eq_relations.union(a, b);\n+        self.sub_relations.union(a, b);\n+    }\n+\n+    /// Records that `a <: b`, depending on `dir`.\n+    ///\n+    /// Precondition: neither `a` nor `b` are known.\n+    pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n+        debug_assert!(self.probe(a).is_none());\n+        debug_assert!(self.probe(b).is_none());\n+        self.sub_relations.union(a, b);\n     }\n \n     /// Instantiates `vid` with the type `ty`.\n@@ -141,6 +184,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                    default: Option<Default<'tcx>>,) -> ty::TyVid {\n         debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n         self.eq_relations.new_key(());\n+        self.sub_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { default: default },\n             origin: origin,\n@@ -155,15 +199,41 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.values.len()\n     }\n \n+    /// Returns the \"root\" variable of `vid` in the `eq_relations`\n+    /// equivalence table. All type variables that have been equated\n+    /// will yield the same root variable (per the union-find\n+    /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n+    /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.eq_relations.find(vid)\n     }\n \n+    /// Returns the \"root\" variable of `vid` in the `sub_relations`\n+    /// equivalence table. All type variables that have been are\n+    /// related via equality or subtyping will yield the same root\n+    /// variable (per the union-find algorithm), so `sub_root_var(a)\n+    /// == sub_root_var(b)` implies that:\n+    ///\n+    ///     exists X. (a <: X || X <: a) && (b <: X || X <: b)\n+    pub fn sub_root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n+        self.sub_relations.find(vid)\n+    }\n+\n+    /// True if `a` and `b` have same \"sub-root\" (i.e., exists some\n+    /// type X such that `forall i in {a, b}. (i <: X || X <: i)`.\n+    pub fn sub_unified(&mut self, a: ty::TyVid, b: ty::TyVid) -> bool {\n+        self.sub_root_var(a) == self.sub_root_var(b)\n+    }\n+\n     pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         let vid = self.root_var(vid);\n         self.probe_root(vid)\n     }\n \n+    pub fn origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {\n+        self.values.get(vid.index as usize).origin.clone()\n+    }\n+\n     /// Retrieves the type of `vid` given that it is currently a root in the unification table\n     pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         debug_assert!(self.root_var(vid) == vid);\n@@ -189,6 +259,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         Snapshot {\n             snapshot: self.values.start_snapshot(),\n             eq_snapshot: self.eq_relations.snapshot(),\n+            sub_snapshot: self.sub_relations.snapshot(),\n         }\n     }\n \n@@ -204,13 +275,40 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             }\n         });\n \n-        self.values.rollback_to(s.snapshot);\n-        self.eq_relations.rollback_to(s.eq_snapshot);\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.rollback_to(snapshot);\n+        self.eq_relations.rollback_to(eq_snapshot);\n+        self.sub_relations.rollback_to(sub_snapshot);\n     }\n \n     pub fn commit(&mut self, s: Snapshot) {\n-        self.values.commit(s.snapshot);\n-        self.eq_relations.commit(s.eq_snapshot);\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.commit(snapshot);\n+        self.eq_relations.commit(eq_snapshot);\n+        self.sub_relations.commit(sub_snapshot);\n+    }\n+\n+    /// Returns a map `{V1 -> V2}`, where the keys `{V1}` are\n+    /// ty-variables created during the snapshot, and the values\n+    /// `{V2}` are the root variables that they were unified with,\n+    /// along with their origin.\n+    pub fn types_created_since_snapshot(&mut self, s: &Snapshot) -> TypeVariableMap {\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        let eq_relations = &mut self.eq_relations;\n+        let values = &self.values;\n+\n+        actions_since_snapshot\n+            .iter()\n+            .filter_map(|action| match action {\n+                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n+                _ => None,\n+            })\n+            .map(|vid| {\n+                let root_vid = eq_relations.find(vid);\n+                let root_origin = values.get(vid.index as usize).origin.clone();\n+                (vid, TypeVariableInfo { root_vid, root_origin })\n+            })\n+            .collect()\n     }\n \n     pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {"}, {"sha": "f7a7d0e2071f210287dc4b4b6c575866146e1f21", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -69,6 +69,19 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     found_pattern: Option<&'a Pat>,\n }\n \n+impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn is_match(&self, ty: Ty<'tcx>) -> bool {\n+        ty == *self.target_ty || match (&ty.sty, &self.target_ty.sty) {\n+            (&ty::TyInfer(ty::TyVar(a_vid)), &ty::TyInfer(ty::TyVar(b_vid))) =>\n+                self.infcx.type_variables\n+                          .borrow_mut()\n+                          .sub_unified(a_vid, b_vid),\n+\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> Visitor<'a> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'a> {\n         NestedVisitorMap::None\n@@ -77,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'a> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     fn visit_local(&mut self, local: &'a Local) {\n         if let Some(&ty) = self.infcx.tables.borrow().node_types.get(&local.id) {\n             let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-            let is_match = ty.walk().any(|t| t == *self.target_ty);\n+            let is_match = ty.walk().any(|t| self.is_match(t));\n \n             if is_match && self.found_pattern.is_none() {\n                 self.found_pattern = Some(&*local.pat);\n@@ -564,8 +577,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::Subtype(ref predicate) => {\n-                        // TODO\n-                        panic!(\"subtype requirement not satisfied {:?}\", predicate)\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n                     ty::Predicate::Equate(ref predicate) => {\n@@ -779,7 +794,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // no need to overload user in such cases\n                 } else {\n                     let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n-                    assert!(a.is_ty_var() && b.is_ty_var()); // else other would've been instantiated\n+                    // both must be type variables, or the other would've been instantiated\n+                    assert!(a.is_ty_var() && b.is_ty_var());\n                     self.need_type_info(obligation, a);\n                 }\n             }"}, {"sha": "adc7101b16aa18a7cdc9fe6e3993421b0e11203a", "filename": "src/test/run-pass/issue-40951.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Ftest%2Frun-pass%2Fissue-40951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Ftest%2Frun-pass%2Fissue-40951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40951.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #40951.\n+\n+const FOO: [&'static str; 1] = [\"foo\"];\n+\n+fn find<T: PartialEq>(t: &[T], element: &T) { }\n+\n+fn main() {\n+    let x = format!(\"hi\");\n+    find(&FOO, &&*x);\n+}"}, {"sha": "d7fb85ca4842e6824736ab98df5857b885c259c8", "filename": "src/test/run-pass/type-infer-generalize-ty-var.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca56e82a1bbd775498257cc080f5ea27b214f49/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs?ref=bca56e82a1bbd775498257cc080f5ea27b214f49", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a scenario where we generate a constraint like `?1 <: &?2`.\n+// In such a case, it is important that we instantiate `?1` with `&?3`\n+// where `?3 <: ?2`, and not with `&?2`. This is a regression test for\n+// #18653. The important thing is that we build.\n+\n+use std::cell::RefCell;\n+\n+enum Wrap<A> {\n+    WrapSome(A),\n+    WrapNone\n+}\n+\n+use Wrap::*;\n+\n+struct T;\n+struct U;\n+\n+trait Get<T: ?Sized> {\n+    fn get(&self) -> &T;\n+}\n+\n+impl Get<MyShow + 'static> for Wrap<T> {\n+    fn get(&self) -> &(MyShow + 'static) {\n+        static x: usize = 42;\n+        &x\n+    }\n+}\n+\n+impl Get<usize> for Wrap<U> {\n+    fn get(&self) -> &usize {\n+        static x: usize = 55;\n+        &x\n+    }\n+}\n+\n+trait MyShow { fn dummy(&self) { } }\n+impl<'a> MyShow for &'a (MyShow + 'a) { }\n+impl MyShow for usize { }\n+fn constrain<'a>(rc: RefCell<&'a (MyShow + 'a)>) { }\n+\n+fn main() {\n+    let mut collection: Wrap<_> = WrapNone;\n+\n+    {\n+        let __arg0 = Get::get(&collection);\n+        let __args_cell = RefCell::new(__arg0);\n+        constrain(__args_cell);\n+    }\n+    collection = WrapSome(T);\n+}"}]}