{"sha": "28256052a4b141350dc0fe4e2e5357137bb49706", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MjU2MDUyYTRiMTQxMzUwZGMwZmU0ZTJlNTM1NzEzN2JiNDk3MDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-02T22:33:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-10T06:46:18Z"}, "message": "core: Use the new `for` protocol", "tree": {"sha": "6d5660a849451c8a39c75cebe6a4ce148c31ab49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d5660a849451c8a39c75cebe6a4ce148c31ab49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28256052a4b141350dc0fe4e2e5357137bb49706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28256052a4b141350dc0fe4e2e5357137bb49706", "html_url": "https://github.com/rust-lang/rust/commit/28256052a4b141350dc0fe4e2e5357137bb49706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28256052a4b141350dc0fe4e2e5357137bb49706/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cde8ba684e738fa71ce62d691ba2886776e49f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cde8ba684e738fa71ce62d691ba2886776e49f9", "html_url": "https://github.com/rust-lang/rust/commit/0cde8ba684e738fa71ce62d691ba2886776e49f9"}], "stats": {"total": 1663, "additions": 1492, "deletions": 171}, "files": [{"sha": "a5df97e3d574f84ef0467abd46cc8c381ea443a4", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -127,6 +127,7 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n+#[cfg(stage0)]\n unsafe fn each_live_alloc(read_next_before: bool,\n                           f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n     //! Walks the internal list of allocations\n@@ -141,8 +142,8 @@ unsafe fn each_live_alloc(read_next_before: bool,\n         let uniq =\n             (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n \n-        if ! f(box, uniq) {\n-            break\n+        if !f(box, uniq) {\n+            return;\n         }\n \n         if read_next_before {\n@@ -152,6 +153,33 @@ unsafe fn each_live_alloc(read_next_before: bool,\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+unsafe fn each_live_alloc(read_next_before: bool,\n+                          f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) -> bool {\n+    //! Walks the internal list of allocations\n+\n+    use managed;\n+\n+    let task: *Task = transmute(rustrt::rust_get_task());\n+    let box = (*task).boxed_region.live_allocs;\n+    let mut box: *mut BoxRepr = transmute(copy box);\n+    while box != mut_null() {\n+        let next_before = transmute(copy (*box).header.next);\n+        let uniq =\n+            (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n+\n+        if !f(box, uniq) {\n+            return false;\n+        }\n+\n+        if read_next_before {\n+            box = next_before;\n+        } else {\n+            box = transmute(copy (*box).header.next);\n+        }\n+    }\n+    return true;\n+}\n \n #[cfg(unix)]\n fn debug_mem() -> bool {"}, {"sha": "1d5d77649549e294573c8d47a42728f0a399b87f", "filename": "src/libcore/container.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -30,16 +30,32 @@ pub trait Map<K, V>: Mutable {\n     fn contains_key(&self, key: &K) -> bool;\n \n     // Visits all keys and values\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool);\n+    // Visits all keys and values\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool) -> bool;\n \n     /// Visit all keys\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&K) -> bool);\n+    /// Visit all keys\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&K) -> bool) -> bool;\n \n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool);\n+    /// Visit all values\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool;\n \n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool;\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n@@ -65,6 +81,7 @@ pub trait Map<K, V>: Mutable {\n     fn pop(&mut self, k: &K) -> Option<V>;\n }\n \n+#[cfg(stage0)]\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;\n@@ -99,3 +116,39 @@ pub trait Set<T>: Mutable {\n     /// Visit the values representing the union\n     fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }\n+\n+#[cfg(not(stage0))]\n+pub trait Set<T>: Mutable {\n+    /// Return true if the set contains a value\n+    fn contains(&self, value: &T) -> bool;\n+\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: T) -> bool;\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool;\n+\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    fn is_disjoint(&self, other: &Self) -> bool;\n+\n+    /// Return true if the set is a subset of another\n+    fn is_subset(&self, other: &Self) -> bool;\n+\n+    /// Return true if the set is a superset of another\n+    fn is_superset(&self, other: &Self) -> bool;\n+\n+    /// Visit the values representing the difference\n+    fn difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the symmetric difference\n+    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the intersection\n+    fn intersection(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the union\n+    fn union(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+}"}, {"sha": "6a427297cc22d795ffdf604d1b631153a617dd44", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -129,7 +129,7 @@ type Visitor<'self> = &'self fn(root: **Word, tydesc: *Word) -> bool;\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n+unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     let fp_bytes: *u8 = cast::transmute(fp);\n     let sp_meta: *u32 = cast::transmute(sp.sp_meta);\n \n@@ -155,7 +155,7 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n             } else {\n                 ptr::null()\n             };\n-            if !visitor(root, tydesc) { return; }\n+            if !visitor(root, tydesc) { return false; }\n         }\n         sri += 1;\n     }\n@@ -168,6 +168,16 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n         }\n         rri += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n+    _walk_safe_point(fp, sp, visitor);\n+}\n+#[cfg(not(stage0))]\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+    _walk_safe_point(fp, sp, visitor)\n }\n \n // Is fp contained in segment?\n@@ -222,7 +232,7 @@ static need_cleanup:    Memory = exchange_heap | stack;\n \n // Walks stack, searching for roots of the requested type, and passes\n // each root to the visitor.\n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n+unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n     let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n     // To avoid collecting memory used by the GC itself, skip stack\n@@ -274,14 +284,14 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n                     // Root is a generic box.\n                     let refcount = **root;\n                     if mem | task_local_heap != 0 && refcount != -1 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     } else if mem | exchange_heap != 0 && refcount == -1 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     }\n                 } else {\n                     // Root is a non-immediate.\n                     if mem | stack != 0 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     }\n                 }\n             }\n@@ -290,8 +300,17 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n         }\n         reached_sentinel = delay_reached_sentinel;\n     }\n+    return true;\n }\n \n+#[cfg(stage0)]\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n+    _walk_gc_roots(mem, sentinel, visitor);\n+}\n+#[cfg(not(stage0))]\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+    _walk_gc_roots(mem, sentinel, visitor)\n+}\n pub fn gc() {\n     unsafe {\n         // Abort when GC is disabled."}, {"sha": "b5ae07208fc6689c6e4a64f98d6669e6175426c9", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -88,18 +88,32 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn bucket_sequence(&self, hash: uint,\n-                            op: &fn(uint) -> bool) -> uint {\n+                       op: &fn(uint) -> bool) {\n         let start_idx = self.to_bucket(hash);\n         let len_buckets = self.buckets.len();\n         let mut idx = start_idx;\n         loop {\n-            if !op(idx) {\n-                return idx;\n+            if !op(idx) { return; }\n+            idx = self.next_bucket(idx, len_buckets);\n+            if idx == start_idx {\n+                return;\n             }\n+        }\n+    }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn bucket_sequence(&self, hash: uint,\n+                       op: &fn(uint) -> bool) -> bool {\n+        let start_idx = self.to_bucket(hash);\n+        let len_buckets = self.buckets.len();\n+        let mut idx = start_idx;\n+        loop {\n+            if !op(idx) { return false; }\n             idx = self.next_bucket(idx, len_buckets);\n             if idx == start_idx {\n-                return start_idx;\n+                return true;\n             }\n         }\n     }\n@@ -122,14 +136,14 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 hash: uint,\n                                 k: &K)\n                              -> SearchResult {\n-        let _ = for self.bucket_sequence(hash) |i| {\n+        for self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n                     return FoundEntry(i);\n                 },\n                 None => return FoundHole(i)\n             }\n-        };\n+        }\n         TableFull\n     }\n \n@@ -138,7 +152,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                   hash: uint,\n                                                   k: &Q)\n                                                -> SearchResult {\n-        let _ = for self.bucket_sequence(hash) |i| {\n+        for self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) => {\n                     if bkt.hash == hash && k.equiv(&bkt.key) {\n@@ -147,7 +161,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                 },\n                 None => return FoundHole(i)\n             }\n-        };\n+        }\n         TableFull\n     }\n \n@@ -311,7 +325,8 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n-    fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n+    #[cfg(stage0)]\n+    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n                 if !blk(&bucket.key, &bucket.value) {\n@@ -321,17 +336,45 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all key-value pairs\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            for self.buckets[i].each |bucket| {\n+                if !blk(&bucket.key, &bucket.value) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all keys\n+    #[cfg(stage0)]\n     fn each_key(&self, blk: &fn(k: &K) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n+    /// Visit all keys\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n+\n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             match self.buckets[i] {\n@@ -343,6 +386,20 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            match self.buckets[i] {\n+              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n+                if !blk(key, value) { return false; }\n+              }\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n@@ -632,7 +689,10 @@ pub struct HashSet<T> {\n \n impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n@@ -683,6 +743,7 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n+    #[cfg(stage0)]\n     fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !other.contains(v) {\n@@ -691,15 +752,31 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n         }\n     }\n \n+    /// Visit the values representing the difference\n+    #[cfg(not(stage0))]\n+    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(|v| other.contains(v) || f(v))\n+    }\n+\n     /// Visit the values representing the symmetric difference\n+    #[cfg(stage0)]\n     fn symmetric_difference(&self,\n                             other: &HashSet<T>,\n                             f: &fn(&T) -> bool) {\n         self.difference(other, f);\n         other.difference(self, f);\n     }\n \n+    /// Visit the values representing the symmetric difference\n+    #[cfg(not(stage0))]\n+    fn symmetric_difference(&self,\n+                            other: &HashSet<T>,\n+                            f: &fn(&T) -> bool) -> bool {\n+        self.difference(other, f) && other.difference(self, f)\n+    }\n+\n     /// Visit the values representing the intersection\n+    #[cfg(stage0)]\n     fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if other.contains(v) {\n@@ -708,7 +785,14 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n         }\n     }\n \n+    /// Visit the values representing the intersection\n+    #[cfg(not(stage0))]\n+    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(|v| !other.contains(v) || f(v))\n+    }\n+\n     /// Visit the values representing the union\n+    #[cfg(stage0)]\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !f(v) { return }\n@@ -720,6 +804,12 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n             }\n         }\n     }\n+\n+    /// Visit the values representing the union\n+    #[cfg(not(stage0))]\n+    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(f) && other.each(|v| self.contains(v) || f(v))\n+    }\n }\n \n pub impl <T:Hash + Eq> HashSet<T> {"}, {"sha": "67fc71a941e06b0e4ada8b5a99cb62a9f65f3893", "filename": "src/libcore/io.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -247,7 +247,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_byte(&self, it: &fn(int) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_byte(&self, it: &fn(int) -> bool) -> bool;\n \n     /**\n     * Iterate over every char until EOF or the iterator breaks.\n@@ -256,7 +259,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n \n     /**\n     * Iterate over every line until EOF or the iterator breaks.\n@@ -265,7 +271,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_line(&self, it: &fn(&str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_line(&self, it: &fn(&str) -> bool) -> bool;\n \n     /**\n     * Reads all of the lines in the stream.\n@@ -676,18 +685,35 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n+    #[cfg(stage0)]\n     fn each_byte(&self, it: &fn(int) -> bool) {\n         while !self.eof() {\n             if !it(self.read_byte()) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_byte(&self, it: &fn(int) -> bool) -> bool {\n+        while !self.eof() {\n+            if !it(self.read_byte()) { return false; }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool) {\n         while !self.eof() {\n             if !it(self.read_char()) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool {\n+        while !self.eof() {\n+            if !it(self.read_char()) { return false; }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n             // include the \\n, so that we can distinguish an entirely empty\n@@ -707,6 +733,27 @@ impl<T:Reader> ReaderUtil for T {\n             if !it(line) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_line(&self, it: &fn(s: &str) -> bool) -> bool {\n+        while !self.eof() {\n+            // include the \\n, so that we can distinguish an entirely empty\n+            // line read after \"...\\n\", and the trailing empty line in\n+            // \"...\\n\\n\".\n+            let mut line = self.read_until('\\n' as u8, true);\n+\n+            // blank line at the end of the reader is ignored\n+            if self.eof() && line.is_empty() { break; }\n+\n+            // trim the \\n, so that each_line is consistent with read_line\n+            let n = str::len(line);\n+            if line[n-1] == '\\n' as u8 {\n+                unsafe { str::raw::set_len(&mut line, n-1); }\n+            }\n+\n+            if !it(line) { return false; }\n+        }\n+        return true;\n+    }\n \n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {"}, {"sha": "0f064af657a28c9928215b97698bee5eb6053285", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -40,12 +40,17 @@ much easier to implement.\n \n */\n \n-use cmp::Ord;\n-use option::{Option, Some, None};\n+#[cfg(not(stage0))] use cmp::Ord;\n+#[cfg(not(stage0))] use option::{Option, Some, None};\n \n+#[cfg(stage0)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait Times {\n+    fn times(&self, it: &fn() -> bool) -> bool;\n+}\n \n /**\n  * Transform an internal iterator into an owned vector.\n@@ -59,7 +64,8 @@ pub trait Times {\n  * ~~~\n  */\n #[inline(always)]\n-pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool)) -> ~[T] {\n+#[cfg(not(stage0))]\n+pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n     let mut v = ~[];\n     for iter |x| { v.push(x) }\n     v\n@@ -77,13 +83,12 @@ pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool)) -> ~[T] {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn any<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n-    for iter |x| {\n-        if predicate(x) {\n-            return true\n-        }\n-    }\n-    false\n+#[cfg(not(stage0))]\n+pub fn any<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If the predicate returns true, we break. If we ever broke, then we found\n+    // something\n+    !iter(|x| !predicate(x))\n }\n \n /**\n@@ -97,13 +102,12 @@ pub fn any<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n-    for iter |x| {\n-        if !predicate(x) {\n-            return false\n-        }\n-    }\n-    true\n+#[cfg(not(stage0))]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If we ever break, iter will return false, so this will only return true\n+    // if predicate returns true for everything.\n+    iter(|x| predicate(x))\n }\n \n /**\n@@ -117,7 +121,9 @@ pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn find<T>(predicate: &fn(&T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn find<T>(predicate: &fn(&T) -> bool,\n+               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     for iter |x| {\n         if predicate(&x) {\n             return Some(x);\n@@ -137,7 +143,8 @@ pub fn find<T>(predicate: &fn(&T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> Opti\n  * ~~~~\n  */\n #[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n         match result {\n@@ -163,7 +170,8 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n  * ~~~~\n  */\n #[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n         match result {"}, {"sha": "40c9637f692bc79835bf5cac2b90672cf011aaf5", "filename": "src/libcore/iterator.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -41,7 +41,10 @@ pub trait IteratorUtil<A> {\n     fn take(self, n: uint) -> TakeIterator<Self>;\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, Self, St>;\n+    #[cfg(stage0)]\n     fn advance(&mut self, f: &fn(A) -> bool);\n+    #[cfg(not(stage0))]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -103,13 +106,28 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// A shim implementing the `for` loop iteration protocol for iterator objects\n     #[inline]\n+    #[cfg(stage0)]\n     fn advance(&mut self, f: &fn(A) -> bool) {\n         loop {\n             match self.next() {\n                 Some(x) => {\n-                    if !f(x) { return }\n+                    if !f(x) { return; }\n                 }\n-                None => return\n+                None => { return; }\n+            }\n+        }\n+    }\n+\n+    /// A shim implementing the `for` loop iteration protocol for iterator objects\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+        loop {\n+            match self.next() {\n+                Some(x) => {\n+                    if !f(x) { return false; }\n+                }\n+                None => { return true; }\n             }\n         }\n     }"}, {"sha": "f2bba6a4639042527893f284ef8802af8a3b6aca", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -86,38 +86,63 @@ pub fn gt(x: T, y: T) -> bool { x > y }\n ///\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+pub fn _range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n     } else if step > 0 { // ascending\n         while i < stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n-            if i > max_value - step { break; }\n+            if i > max_value - step { return true; }\n             i += step;\n         }\n     } else { // descending\n         while i > stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n-            if i < min_value - step { break; }\n+            if i < min_value - step { return true; }\n             i += step;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+    _range_step(start, stop, step, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n+    _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`lo`..`hi`)\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as T, it)\n+}\n+\n+#[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`hi`..`lo`)\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as T, it)\n+}\n \n /// Computes the bitwise complement\n #[inline(always)]"}, {"sha": "1c115ee507203cde52ef740da88697d5c5618692", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -51,43 +51,69 @@ pub fn gt(x: T, y: T) -> bool { x > y }\n ///\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n ///\n-pub fn range_step(start: T,\n-                       stop: T,\n-                       step: T_SIGNED,\n-                       it: &fn(T) -> bool) {\n+pub fn _range_step(start: T,\n+                   stop: T,\n+                   step: T_SIGNED,\n+                   it: &fn(T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n     }\n     if step >= 0 {\n         while i < stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n-            if i > max_value - (step as T) { break; }\n+            if i > max_value - (step as T) { return true; }\n             i += step as T;\n         }\n     } else {\n         while i > stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n-            if i < min_value + ((-step) as T) { break; }\n+            if i < min_value + ((-step) as T) { return true; }\n             i -= -step as T;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) {\n+    _range_step(start, stop, step, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) -> bool {\n+    _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`lo`..`hi`)\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as T_SIGNED, it)\n+}\n+\n+#[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n+#[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`hi`..`lo`)\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as T_SIGNED, it)\n+}\n+\n /// Computes the bitwise complement\n #[inline(always)]\n pub fn compl(i: T) -> T {"}, {"sha": "d8a4ec19304f36cb409fbe4804b0ca1355cc03c9", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -154,6 +154,7 @@ pub mod inst {\n         return true;\n     }\n \n+    #[cfg(stage0)]\n     impl iter::Times for uint {\n         #[inline(always)]\n         ///\n@@ -175,6 +176,29 @@ pub mod inst {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    impl iter::Times for uint {\n+        #[inline(always)]\n+        ///\n+        /// A convenience form for basic iteration. Given a uint `x`,\n+        /// `for x.times { ... }` executes the given block x times.\n+        ///\n+        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n+        ///\n+        /// Not defined on all integer types to permit unambiguous\n+        /// use with integer literals of inferred integer-type as\n+        /// the self-value (eg. `for 100.times { ... }`).\n+        ///\n+        fn times(&self, it: &fn() -> bool) -> bool {\n+            let mut i = *self;\n+            while i > 0 {\n+                if !it() { return false; }\n+                i -= 1;\n+            }\n+            return true;\n+        }\n+    }\n+\n     /// Returns the smallest power of 2 greater than or equal to `n`\n     #[inline(always)]\n     pub fn next_power_of_two(n: uint) -> uint {"}, {"sha": "8e31bbfd8781b71c3d6f040a6e8090dc0ff4e950", "filename": "src/libcore/old_iter.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fold_iter.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -22,21 +22,40 @@ use vec;\n /// A function used to initialize the elements of a sequence\n pub type InitOp<'self,T> = &'self fn(uint) -> T;\n \n+#[cfg(stage0)]\n pub trait BaseIter<A> {\n     fn each(&self, blk: &fn(v: &A) -> bool);\n     fn size_hint(&self) -> Option<uint>;\n }\n+#[cfg(not(stage0))]\n+pub trait BaseIter<A> {\n+    fn each(&self, blk: &fn(v: &A) -> bool) -> bool;\n+    fn size_hint(&self) -> Option<uint>;\n+}\n \n+#[cfg(stage0)]\n pub trait ReverseIter<A>: BaseIter<A> {\n     fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait ReverseIter<A>: BaseIter<A> {\n+    fn each_reverse(&self, blk: &fn(&A) -> bool) -> bool;\n+}\n \n+#[cfg(stage0)]\n pub trait MutableIter<A>: BaseIter<A> {\n     fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait MutableIter<A>: BaseIter<A> {\n+    fn each_mut(&mut self, blk: &fn(&mut A) -> bool) -> bool;\n+}\n \n pub trait ExtendedIter<A> {\n+    #[cfg(stage0)]\n     fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool;\n     fn all(&self, blk: &fn(&A) -> bool) -> bool;\n     fn any(&self, blk: &fn(&A) -> bool) -> bool;\n     fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n@@ -45,9 +64,14 @@ pub trait ExtendedIter<A> {\n     fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n+#[cfg(stage0)]\n pub trait ExtendedMutableIter<A> {\n     fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait ExtendedMutableIter<A> {\n+    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool) -> bool;\n+}\n \n pub trait EqIter<A:Eq> {\n     fn contains(&self, x: &A) -> bool;\n@@ -92,12 +116,22 @@ pub trait Buildable<A> {\n }\n \n #[inline(always)]\n-pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n+pub fn _eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     let mut i = 0;\n     for self.each |a| {\n-        if !blk(i, a) { break; }\n+        if !blk(i, a) { return false; }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n+    _eachi(self, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n+    _eachi(self, blk)\n }\n \n #[inline(always)]\n@@ -199,13 +233,24 @@ pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n+#[cfg(stage0)]\n pub fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n         i += 1;\n     }\n }\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn repeat(times: uint, blk: &fn() -> bool) -> bool {\n+    let mut i = 0;\n+    while i < times {\n+        if !blk() { return false; }\n+        i += 1;\n+    }\n+    return true;\n+}\n \n #[inline(always)]\n pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {"}, {"sha": "7cb408767058cfc35c5cca05b47214e55c81f836", "filename": "src/libcore/option.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -101,9 +101,16 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n+    /// Performs an operation on the contained value by reference\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) -> bool {\n+        match *self { None => true, Some(ref t) => { f(t) } }\n+    }\n \n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> {\n@@ -112,16 +119,27 @@ impl<T> BaseIter<T> for Option<T> {\n }\n \n impl<T> MutableIter<T> for Option<T> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) -> bool {\n+        match *self { None => true, Some(ref mut t) => { f(t) } }\n+    }\n }\n \n impl<A> ExtendedIter<A> for Option<A> {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }"}, {"sha": "4f9a49d581f67b47f1489947fadfb8461d5add4c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -550,6 +550,7 @@ pub fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n+#[cfg(stage0)]\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n \n     walk_dir_(p, f);\n@@ -577,6 +578,14 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n         return keepgoing;\n     }\n }\n+/// Recursively walk a directory structure\n+#[cfg(not(stage0))]\n+pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n+    list_dir(p).each(|q| {\n+        let path = &p.push(*q);\n+        f(path) && (!path_is_dir(path) || walk_dir(path, f))\n+    })\n+}\n \n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {"}, {"sha": "e86416f2499024f59f7c0ad718a516fcf3fb2329", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -24,6 +24,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n+#[cfg(stage0)]\n pub fn walk_stack(visit: &fn(Frame) -> bool) {\n \n     debug!(\"beginning stack walk\");\n@@ -51,6 +52,35 @@ pub fn walk_stack(visit: &fn(Frame) -> bool) {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n+\n+    debug!(\"beginning stack walk\");\n+\n+    do frame_address |frame_pointer| {\n+        let mut frame_address: *Word = unsafe {\n+            transmute(frame_pointer)\n+        };\n+        loop {\n+            let fr = Frame(frame_address);\n+\n+            debug!(\"frame: %x\", unsafe { transmute(fr.fp) });\n+            visit(fr);\n+\n+            unsafe {\n+                let next_fp: **Word = transmute(frame_address);\n+                frame_address = *next_fp;\n+                if *frame_address == 0u {\n+                    debug!(\"encountered task_start_wrapper. ending walk\");\n+                    // This is the task_start_wrapper_frame. There is\n+                    // no stack beneath it and it is a foreign frame.\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n #[test]\n fn test_simple() {"}, {"sha": "4ab6f659e9c0f46eef13bc5557678e1891653606", "filename": "src/libcore/str.rs", "status": "modified", "additions": 410, "deletions": 23, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -566,14 +566,30 @@ pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n+#[cfg(stage0)]\n pub fn each_split_char<'a>(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, true, it);\n+}\n+\n+/// Splits a string into substrings at each occurrence of a given character\n+#[cfg(not(stage0))]\n+pub fn each_split_char<'a>(s: &'a str, sep: char,\n+                           it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), true, true, it)\n }\n \n /// Like `each_split_char`, but a trailing empty string is omitted\n+#[cfg(stage0)]\n pub fn each_split_char_no_trailing<'a>(s: &'a str,\n                                        sep: char,\n                                        it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, false, it);\n+}\n+/// Like `each_split_char`, but a trailing empty string is omitted\n+#[cfg(not(stage0))]\n+pub fn each_split_char_no_trailing<'a>(s: &'a str,\n+                                       sep: char,\n+                                       it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n@@ -583,17 +599,39 @@ pub fn each_split_char_no_trailing<'a>(s: &'a str,\n  *\n  * The character must be a valid UTF-8/ASCII character\n  */\n+#[cfg(stage0)]\n pub fn each_splitn_char<'a>(s: &'a str,\n                             sep: char,\n                             count: uint,\n                             it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, count, true, true, it);\n+}\n+/**\n+ * Splits a string into substrings at each occurrence of a given\n+ * character up to 'count' times.\n+ *\n+ * The character must be a valid UTF-8/ASCII character\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_splitn_char<'a>(s: &'a str,\n+                            sep: char,\n+                            count: uint,\n+                            it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, count, true, true, it)\n }\n \n /// Like `each_split_char`, but omits empty strings\n+#[cfg(stage0)]\n pub fn each_split_char_nonempty<'a>(s: &'a str,\n                                     sep: char,\n                                     it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), false, false, it);\n+}\n+/// Like `each_split_char`, but omits empty strings\n+#[cfg(not(stage0))]\n+pub fn each_split_char_nonempty<'a>(s: &'a str,\n+                                    sep: char,\n+                                    it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n@@ -602,15 +640,17 @@ fn each_split_char_inner<'a>(s: &'a str,\n                              count: uint,\n                              allow_empty: bool,\n                              allow_trailing_empty: bool,\n-                             it: &fn(&'a str) -> bool) {\n+                             it: &fn(&'a str) -> bool) -> bool {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n+                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n+                        return false;\n+                    }\n                 }\n                 start = i + 1u;\n                 done += 1u;\n@@ -619,42 +659,79 @@ fn each_split_char_inner<'a>(s: &'a str,\n         }\n         // only slice a non-empty trailing substring\n         if allow_trailing_empty || start < l {\n-            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return; }\n+            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n         }\n-    } else {\n-        each_split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty, it)\n+        return true;\n     }\n+    return each_split_inner(s, |cur| cur == sep, count,\n+                            allow_empty, allow_trailing_empty, it)\n }\n \n /// Splits a string into substrings using a character function\n+#[cfg(stage0)]\n pub fn each_split<'a>(s: &'a str,\n                       sepfn: &fn(char) -> bool,\n                       it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, true, it);\n+}\n+/// Splits a string into substrings using a character function\n+#[cfg(not(stage0))]\n+pub fn each_split<'a>(s: &'a str,\n+                      sepfn: &fn(char) -> bool,\n+                      it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), true, true, it)\n }\n \n /// Like `each_split`, but a trailing empty string is omitted\n+#[cfg(stage0)]\n pub fn each_split_no_trailing<'a>(s: &'a str,\n                                   sepfn: &fn(char) -> bool,\n                                   it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, false, it);\n+}\n+/// Like `each_split`, but a trailing empty string is omitted\n+#[cfg(not(stage0))]\n+pub fn each_split_no_trailing<'a>(s: &'a str,\n+                                  sepfn: &fn(char) -> bool,\n+                                  it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n+#[cfg(stage0)]\n pub fn each_splitn<'a>(s: &'a str,\n                        sepfn: &fn(char) -> bool,\n                        count: uint,\n                        it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, count, true, true, it);\n+}\n+/**\n+ * Splits a string into substrings using a character function, cutting at\n+ * most `count` times.\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_splitn<'a>(s: &'a str,\n+                       sepfn: &fn(char) -> bool,\n+                       count: uint,\n+                       it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, count, true, true, it)\n }\n \n /// Like `each_split`, but omits empty strings\n+#[cfg(stage0)]\n pub fn each_split_nonempty<'a>(s: &'a str,\n                                sepfn: &fn(char) -> bool,\n                                it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), false, false, it);\n+}\n+/// Like `each_split`, but omits empty strings\n+#[cfg(not(stage0))]\n+pub fn each_split_nonempty<'a>(s: &'a str,\n+                               sepfn: &fn(char) -> bool,\n+                               it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n@@ -663,27 +740,32 @@ fn each_split_inner<'a>(s: &'a str,\n                         count: uint,\n                         allow_empty: bool,\n                         allow_trailing_empty: bool,\n-                        it: &fn(&'a str) -> bool) {\n+                        it: &fn(&'a str) -> bool) -> bool {\n     let l = len(s);\n     let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n+                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n+                    return false;\n+                }\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_trailing_empty || start < l {\n-        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return;  }\n+        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n     }\n+    return true;\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches<'a,'b>(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n+#[cfg(stage0)]\n+fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n+                       f: &fn(uint, uint) -> bool) {\n     let sep_len = len(sep), l = len(s);\n     assert!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -709,7 +791,38 @@ fn iter_matches<'a,'b>(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n         }\n     }\n }\n+// See Issue #1932 for why this is a naive search\n+#[cfg(not(stage0))]\n+fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n+                       f: &fn(uint, uint) -> bool) -> bool {\n+    let sep_len = len(sep), l = len(s);\n+    assert!(sep_len > 0u);\n+    let mut i = 0u, match_start = 0u, match_i = 0u;\n+\n+    while i < l {\n+        if s[i] == sep[match_i] {\n+            if match_i == 0u { match_start = i; }\n+            match_i += 1u;\n+            // Found a match\n+            if match_i == sep_len {\n+                if !f(match_start, i + 1u) { return false; }\n+                match_i = 0u;\n+            }\n+            i += 1u;\n+        } else {\n+            // Failed match, backtrack\n+            if match_i > 0u {\n+                match_i = 0u;\n+                i = match_start + 1u;\n+            } else {\n+                i += 1u;\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n+#[cfg(stage0)]\n fn iter_between_matches<'a,'b>(s: &'a str,\n                                sep: &'b str,\n                                f: &fn(uint, uint) -> bool) {\n@@ -720,6 +833,17 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n     }\n     f(last_end, len(s));\n }\n+#[cfg(not(stage0))]\n+fn iter_between_matches<'a,'b>(s: &'a str,\n+                               sep: &'b str,\n+                               f: &fn(uint, uint) -> bool) -> bool {\n+    let mut last_end = 0u;\n+    for iter_matches(s, sep) |from, to| {\n+        if !f(last_end, from) { return false; }\n+        last_end = to;\n+    }\n+    return f(last_end, len(s));\n+}\n \n /**\n  * Splits a string into a vector of the substrings separated by a given string\n@@ -732,14 +856,36 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n  * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n+#[cfg(stage0)]\n pub fn each_split_str<'a,'b>(s: &'a str,\n                              sep: &'b str,\n                              it: &fn(&'a str) -> bool) {\n     for iter_between_matches(s, sep) |from, to| {\n         if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n }\n+/**\n+ * Splits a string into a vector of the substrings separated by a given string\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let mut v = ~[];\n+ * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n+ * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n+ * ~~~\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_split_str<'a,'b>(s: &'a str,\n+                             sep: &'b str,\n+                             it: &fn(&'a str) -> bool) -> bool {\n+    for iter_between_matches(s, sep) |from, to| {\n+        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n+    }\n+    return true;\n+}\n \n+#[cfg(stage0)]\n pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n                                       sep: &'b str,\n                                       it: &fn(&'a str) -> bool) {\n@@ -750,6 +896,18 @@ pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n+                                      sep: &'b str,\n+                                      it: &fn(&'a str) -> bool) -> bool {\n+    for iter_between_matches(s, sep) |from, to| {\n+        if to > from {\n+            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n+        }\n+    }\n+    return true;\n+}\n+\n /// Levenshtein Distance between two strings\n pub fn levdistance(s: &str, t: &str) -> uint {\n \n@@ -787,14 +945,23 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into substrings separated by LF ('\\n').\n  */\n+#[cfg(stage0)]\n pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_char_no_trailing(s, '\\n', it);\n+}\n+/**\n+ * Splits a string into substrings separated by LF ('\\n').\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_no_trailing(s, '\\n', it)\n }\n \n /**\n  * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n+#[cfg(stage0)]\n pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n     for each_line(s) |s| {\n         let l = s.len();\n@@ -805,9 +972,31 @@ pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n         }\n     }\n }\n+/**\n+ * Splits a string into substrings separated by LF ('\\n')\n+ * and/or CR LF (\"\\r\\n\")\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n+    for each_line(s) |s| {\n+        let l = s.len();\n+        if l > 0u && s[l - 1u] == '\\r' as u8 {\n+            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n+        } else {\n+            if !it( s ) { return false; }\n+        }\n+    }\n+    return true;\n+}\n \n /// Splits a string into substrings separated by whitespace\n+#[cfg(stage0)]\n pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_nonempty(s, char::is_whitespace, it);\n+}\n+/// Splits a string into substrings separated by whitespace\n+#[cfg(not(stage0))]\n+pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_nonempty(s, char::is_whitespace, it)\n }\n \n@@ -820,9 +1009,9 @@ pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n  *  Fails during iteration if the string contains a non-whitespace\n  *  sequence longer than the limit.\n  */\n-pub fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) {\n+pub fn _each_split_within<'a>(ss: &'a str,\n+                              lim: uint,\n+                              it: &fn(&'a str) -> bool) -> bool {\n     // Just for fun, let's write this as an state machine:\n \n     enum SplitWithinState {\n@@ -880,6 +1069,20 @@ pub fn each_split_within<'a>(ss: &'a str,\n         machine(fake_i, ' ');\n         fake_i += 1;\n     }\n+    return cont;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) {\n+    _each_split_within(ss, lim, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) -> bool {\n+    _each_split_within(ss, lim, it)\n }\n \n /**\n@@ -1158,12 +1361,20 @@ pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b))\n }\n+/// Iterate over the bytes in a string\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each(s: &str, it: &fn(u8) -> bool) -> bool {\n+    eachi(s, |_i, b| it(b))\n+}\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = 0;\n     let len = s.len();\n@@ -1174,24 +1385,58 @@ pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     }\n }\n \n+/// Iterate over the bytes in a string, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n+    let mut pos = 0;\n+    let len = s.len();\n+\n+    while pos < len {\n+        if !it(pos, s[pos]) { return false; }\n+        pos += 1;\n+    }\n+    return true;\n+}\n+\n /// Iterate over the bytes in a string in reverse\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n     eachi_reverse(s, |_i, b| it(b) )\n }\n+/// Iterate over the bytes in a string in reverse\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_reverse(s: &str, it: &fn(u8) -> bool) -> bool {\n+    eachi_reverse(s, |_i, b| it(b) )\n+}\n \n /// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = s.len();\n     while pos > 0 {\n         pos -= 1;\n         if !it(pos, s[pos]) { break; }\n     }\n }\n+/// Iterate over the bytes in a string in reverse, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n+    let mut pos = s.len();\n+    while pos > 0 {\n+        pos -= 1;\n+        if !it(pos, s[pos]) { return false; }\n+    }\n+    return true;\n+}\n \n /// Iterate over each char of a string, without allocating\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_char(s: &str, it: &fn(char) -> bool) {\n     let mut i = 0;\n     let len = len(s);\n@@ -1201,9 +1446,23 @@ pub fn each_char(s: &str, it: &fn(char) -> bool) {\n         i = next;\n     }\n }\n+/// Iterate over each char of a string, without allocating\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_char(s: &str, it: &fn(char) -> bool) -> bool {\n+    let mut i = 0;\n+    let len = len(s);\n+    while i < len {\n+        let CharRange {ch, next} = char_range_at(s, i);\n+        if !it(ch) { return false; }\n+        i = next;\n+    }\n+    return true;\n+}\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0;\n     let mut ch_pos = 0u;\n@@ -1215,15 +1474,38 @@ pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n         ch_pos += 1u;\n     }\n }\n+/// Iterates over the chars in a string, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) -> bool {\n+    let mut pos = 0;\n+    let mut ch_pos = 0u;\n+    let len = s.len();\n+    while pos < len {\n+        let CharRange {ch, next} = char_range_at(s, pos);\n+        pos = next;\n+        if !it(ch_pos, ch) { return false; }\n+        ch_pos += 1u;\n+    }\n+    return true;\n+}\n \n /// Iterates over the chars in a string in reverse\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n     each_chari_reverse(s, |_, c| it(c))\n }\n+/// Iterates over the chars in a string in reverse\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) -> bool {\n+    each_chari_reverse(s, |_, c| it(c))\n+}\n \n // Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = s.len();\n     let mut ch_pos = s.char_len();\n@@ -1236,6 +1518,21 @@ pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n \n     }\n }\n+// Iterates over the chars in a string in reverse, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) -> bool {\n+    let mut pos = s.len();\n+    let mut ch_pos = s.char_len();\n+    while pos > 0 {\n+        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n+        pos = next;\n+        ch_pos -= 1;\n+\n+        if !it(ch_pos, ch) { return false; }\n+    }\n+    return true;\n+}\n \n /*\n Section: Searching\n@@ -2473,24 +2770,41 @@ pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n     fn char_iter(&self) -> StrCharIterator<'self>;\n-    fn each(&self, it: &fn(u8) -> bool);\n-    fn eachi(&self, it: &fn(uint, u8) -> bool);\n-    fn each_reverse(&self, it: &fn(u8) -> bool);\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n-    fn each_char(&self, it: &fn(char) -> bool);\n-    fn each_chari(&self, it: &fn(uint, char) -> bool);\n-    fn each_char_reverse(&self, it: &fn(char) -> bool);\n-    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(stage0)]      fn each(&self, it: &fn(u8) -> bool);\n+    #[cfg(not(stage0))] fn each(&self, it: &fn(u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    #[cfg(not(stage0))] fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_reverse(&self, it: &fn(u8) -> bool);\n+    #[cfg(not(stage0))] fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n+    #[cfg(not(stage0))] fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_char(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))] fn each_char(&self, it: &fn(char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(not(stage0))] fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))] fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(not(stage0))] fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    #[cfg(stage0)]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n@@ -2543,39 +2857,86 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Iterate over the bytes in a string\n     #[inline]\n+    #[cfg(stage0)]\n     fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each(&self, it: &fn(u8) -> bool) -> bool { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool { eachi(*self, it) }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    fn each_reverse(&self, it: &fn(u8) -> bool) {\n-        each_reverse(*self, it)\n-    }\n+    #[cfg(stage0)]\n+    fn each_reverse(&self, it: &fn(u8) -> bool) { each_reverse(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool { each_reverse(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n         eachi_reverse(*self, it)\n     }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool {\n+        eachi_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n+    /// Iterate over the chars in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n+    /// Iterate over the chars in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool {\n+        each_chari(*self, it)\n+    }\n     /// Iterate over the chars in a string in reverse\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_char_reverse(&self, it: &fn(char) -> bool) {\n         each_char_reverse(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool {\n+        each_char_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string in reverse, with indices from the\n     /// end\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n         each_chari_reverse(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse, with indices from the\n+    /// end\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool {\n+        each_chari_reverse(*self, it)\n+    }\n     /// Returns true if one string ends with another\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n@@ -2617,24 +2978,50 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) {\n         each_split(*self, sepfn, it)\n     }\n+    /// Splits a string into substrings using a character function\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool {\n+        each_split(*self, sepfn, it)\n+    }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) {\n         each_split_char(*self, sep, it)\n     }\n+    /**\n+     * Splits a string into substrings at each occurrence of a given character\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool {\n+        each_split_char(*self, sep, it)\n+    }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) {\n         each_split_str(*self, sep, it)\n     }\n+    /**\n+     * Splits a string into a vector of the substrings separated by a given\n+     * string\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool {\n+        each_split_str(*self, sep, it)\n+    }\n     /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {"}, {"sha": "846d4a349508bb776a461d4dc3e7c3abeb4ad4f2", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -110,9 +110,14 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert!(was_present);\n }\n+#[cfg(stage0)]\n pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n }\n+#[cfg(not(stage0))]\n+pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) -> bool {\n+    tasks.each(|k| blk(*k))\n+}\n \n // One of these per group of linked-failure tasks.\n struct TaskGroupData {\n@@ -685,13 +690,11 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                 };\n                 // Attempt to join every ancestor group.\n                 result =\n-                    for each_ancestor(ancestors, Some(bail)) |ancestor_tg| {\n+                    each_ancestor(ancestors, Some(bail), |ancestor_tg| {\n                         // Enlist as a descendant, not as an actual member.\n                         // Descendants don't kill ancestor groups on failure.\n-                        if !enlist_in_taskgroup(ancestor_tg, child, false) {\n-                            break;\n-                        }\n-                    };\n+                        enlist_in_taskgroup(ancestor_tg, child, false)\n+                    });\n                 // If any ancestor group fails, need to exit this group too.\n                 if !result {\n                     do access_group(child_arc) |child_tg| {"}, {"sha": "182a03da4b1c6904accc38d0a474e39e81ee090c", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 328, "deletions": 66, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -21,13 +21,19 @@ use str;\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n+#[cfg(stage0)]\n+pub trait IterBytes {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb);\n+}\n+\n /**\n  * A trait to implement in order to make a type hashable;\n  * This works in combination with the trait `Hash::Hash`, and\n  * may in the future be merged with that trait or otherwise\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n+#[cfg(not(stage0))]\n pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n@@ -43,9 +49,10 @@ pub trait IterBytes {\n      * left-to-right in declaration order, regardless of\n      * underlying memory endianness.\n      */\n-    fn iter_bytes(&self, lsb0: bool, f: Cb);\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n }\n \n+#[cfg(stage0)]\n impl IterBytes for bool {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -54,7 +61,17 @@ impl IterBytes for bool {\n         ]);\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for bool {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        f([\n+            *self as u8\n+        ])\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u8 {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -63,7 +80,17 @@ impl IterBytes for u8 {\n         ]);\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u8 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        f([\n+            *self\n+        ])\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -80,7 +107,25 @@ impl IterBytes for u16 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u16 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8\n+            ])\n+        } else {\n+            f([\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -101,7 +146,29 @@ impl IterBytes for u32 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u32 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+            ])\n+        } else {\n+            f([\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -130,73 +197,157 @@ impl IterBytes for u64 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u64 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 56) as u8\n+            ])\n+        } else {\n+            f([\n+                (*self >> 56) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i8 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i8 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i16 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u16).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i32 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i64 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u64).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for char {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n-\n-#[cfg(target_word_size = \"32\")]\n-pub mod x32 {\n-    use to_bytes::{Cb, IterBytes};\n-\n-    impl IterBytes for uint {\n-        #[inline(always)]\n-        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-            (*self as u32).iter_bytes(lsb0, f)\n-        }\n+#[cfg(not(stage0))]\n+impl IterBytes for char {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(target_word_size = \"64\")]\n-pub mod x64 {\n-    use to_bytes::{Cb, IterBytes};\n+#[cfg(target_word_size = \"32\", stage0)]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n+#[cfg(target_word_size = \"32\", not(stage0))]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n \n-    impl IterBytes for uint {\n-        #[inline(always)]\n-        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-            (*self as u64).iter_bytes(lsb0, f)\n-        }\n+#[cfg(target_word_size = \"64\", stage0)]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u64).iter_bytes(lsb0, f)\n+    }\n+}\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage0)]\n impl IterBytes for int {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for int {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -207,7 +358,15 @@ impl<'self,A:IterBytes> IterBytes for &'self [A] {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self,A:IterBytes> IterBytes for &'self [A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -218,7 +377,17 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n     }\n   }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n+  #[inline(always)]\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+    match *self {\n+      (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n+    }\n+  }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -229,46 +398,90 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n     }\n   }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n+  #[inline(always)]\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+    match *self {\n+      (ref a, ref b, ref c) => {\n+        a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) && c.iter_bytes(lsb0, f)\n+      }\n+    }\n+  }\n+}\n \n // Move this to vec, probably.\n fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for ~[A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for @[A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+// NOTE: remove all of these after a snapshot, the new for-loop iteration\n+//       protocol makes these unnecessary.\n \n+#[cfg(stage0)]\n pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n+                                             lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z)\n+}\n \n+#[cfg(stage0)]\n pub fn iter_bytes_3<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes>(a: &A, b: &B, c: &C,\n-                              lsb0: bool, z: Cb) {\n+                    B: IterBytes,\n+                    C: IterBytes>(a: &A, b: &B, c: &C,\n+                                  lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_3<A: IterBytes,\n+                    B: IterBytes,\n+                    C: IterBytes>(a: &A, b: &B, c: &C, lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z)\n+}\n \n+#[cfg(stage0)]\n pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n@@ -284,33 +497,24 @@ pub fn iter_bytes_4<A: IterBytes,\n     if !flag { return; }\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n-\n-pub fn iter_bytes_5<A: IterBytes,\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+                D: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D,\n+                              lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n+        d.iter_bytes(lsb0, z)\n }\n \n-pub fn iter_bytes_6<A: IterBytes,\n+#[cfg(stage0)]\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes,\n-                F: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E, f: &F,\n+                E: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E,\n                               lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n@@ -322,36 +526,20 @@ pub fn iter_bytes_6<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n-\n-pub fn iter_bytes_7<A: IterBytes,\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes,\n-                F: IterBytes,\n-                G: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E, f: &F,\n-                              g: &G,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+                E: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E,\n+                              lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n+        d.iter_bytes(lsb0, z) && e.iter_bytes(lsb0, z)\n }\n \n+#[cfg(stage0)]\n impl<'self> IterBytes for &'self str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -360,7 +548,17 @@ impl<'self> IterBytes for &'self str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self> IterBytes for &'self str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for ~str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -369,7 +567,17 @@ impl IterBytes for ~str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for ~str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for @str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -378,7 +586,17 @@ impl IterBytes for @str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for @str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -388,36 +606,80 @@ impl<A:IterBytes> IterBytes for Option<A> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for Option<A> {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+          Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n+          None => 1u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<'self,A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self,A:IterBytes> IterBytes for &'self A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for @A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for ~A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n+#[cfg(stage0)]\n impl<A> IterBytes for *const A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+// NB: raw-pointer IterBytes does _not_ dereference\n+// to the target; it just gives you the pointer-bytes.\n+#[cfg(not(stage0))]\n+impl<A> IterBytes for *const A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n pub trait ToBytes {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8];"}, {"sha": "05ef1cf433faf208a2a0174f7859923daf84c8db", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -57,28 +57,60 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each(f);\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        self.root.each(f)\n+    }\n+\n     /// Visit all keys in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|k, _| f(k))\n     }\n \n+    /// Visit all keys in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n+\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n \n+    /// Iterate over the map and mutate the contained values\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+        self.root.mutate_values(f)\n+    }\n+\n     /// Return a reference to the value corresponding to the key\n     #[inline(hint)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n@@ -151,21 +183,43 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each_reverse(f);\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        self.root.each_reverse(f)\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|k, _| f(k))\n     }\n+    /// Visit all keys in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.each_reverse(|k, _| f(k))\n+    }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|_, v| f(v))\n     }\n+    /// Visit all values in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.each_reverse(|_, v| f(v))\n+    }\n }\n \n pub struct TrieSet {\n@@ -175,17 +229,25 @@ pub struct TrieSet {\n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n impl Container for TrieSet {"}, {"sha": "e1947b77473ec8c89203272645f3b156bce6e347", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 190, "deletions": 23, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28256052a4b141350dc0fe4e2e5357137bb49706/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=28256052a4b141350dc0fe4e2e5357137bb49706", "patch": "@@ -1489,13 +1489,14 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n+pub fn _each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     //             ^^^^\n     // NB---this CANNOT be &const [T]!  The reason\n     // is that you are passing it to `f()` using\n     // an immutable.\n \n-    do vec::as_imm_buf(v) |p, n| {\n+    let mut broke = false;\n+    do as_imm_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n@@ -1506,42 +1507,69 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n             }\n             n -= 1u;\n         }\n+        broke = n > 0;\n     }\n+    return true;\n }\n \n+#[cfg(stage0)]\n+pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) { _each(v, f); }\n+#[cfg(not(stage0))]\n+pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool { _each(v, f) }\n+\n /// Like `each()`, but for the case where you have\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n-    do vec::as_mut_buf(v) |p, n| {\n+pub fn _each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n+    let mut broke = false;\n+    do as_mut_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0 {\n             unsafe {\n                 let q: &'r mut T = cast::transmute_mut_region(&mut *p);\n-                if !f(q) {\n-                    break;\n-                }\n+                if !f(q) { break; }\n                 p = p.offset(1);\n             }\n             n -= 1;\n         }\n+        broke = n > 0;\n     }\n+    return broke;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n+    _each_mut(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n+    _each_mut(v, f)\n }\n \n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) {\n+pub fn _each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n         if !f(&const v[i]) {\n-            return;\n+            return false;\n         }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) {\n+    _each_const(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) -> bool {\n+    _each_const(v, f)\n }\n \n /**\n@@ -1550,12 +1578,20 @@ pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n+pub fn _eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     let mut i = 0;\n     for each(v) |p| {\n-        if !f(i, p) { return; }\n+        if !f(i, p) { return false; }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) { _eachi(v, f); }\n+#[cfg(not(stage0))]\n+pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n+    _eachi(v, f)\n }\n \n /**\n@@ -1564,14 +1600,26 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+pub fn _eachi_mut<'r,T>(v: &'r mut [T],\n+                        f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n     let mut i = 0;\n     for each_mut(v) |p| {\n         if !f(i, p) {\n-            return;\n+            return false;\n         }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+    _eachi_mut(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T],\n+                       f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n+    _eachi_mut(v, f)\n }\n \n /**\n@@ -1580,8 +1628,17 @@ pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n+pub fn _each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n+    _eachi_reverse(v, |_i, v| blk(v))\n+}\n+\n+#[cfg(stage0)]\n pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n-    eachi_reverse(v, |_i, v| blk(v))\n+    _each_reverse(v, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n+    _each_reverse(v, blk)\n }\n \n /**\n@@ -1590,14 +1647,26 @@ pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+pub fn _eachi_reverse<'r,T>(v: &'r [T],\n+                            blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n         if !blk(i, &v[i]) {\n-            return;\n+            return false;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+    _eachi_reverse(v, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi_reverse<'r,T>(v: &'r [T],\n+                           blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n+    _eachi_reverse(v, blk)\n }\n \n /**\n@@ -1608,13 +1677,23 @@ pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     assert!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n-            return;\n+            return false;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+    _each2(v1, v2, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n+    _each2(v1, v2, f)\n }\n \n /**\n@@ -1627,7 +1706,8 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n+#[cfg(not(stage0))]\n+pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) -> bool {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1641,12 +1721,13 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n             rest.push_all(const_slice(v, i+1u, ln));\n             for each_permutation(rest) |permutation| {\n                 if !put(append(~[elt], permutation)) {\n-                    return;\n+                    return false;\n                 }\n             }\n             i += 1u;\n         }\n     }\n+    return true;\n }\n \n /**\n@@ -1932,8 +2013,14 @@ pub trait ImmutableVector<'self, T> {\n     fn initn(&self, n: uint) -> &'self [T];\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n+    #[cfg(stage0)]\n     fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    #[cfg(not(stage0))]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool;\n     fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n@@ -1995,15 +2082,29 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Iterates over a vector's elements in reverse.\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, blk: &fn(&T) -> bool) {\n         each_reverse(*self, blk)\n     }\n+    /// Iterates over a vector's elements in reverse.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool {\n+        each_reverse(*self, blk)\n+    }\n \n     /// Iterates over a vector's elements and indices in reverse.\n+    #[cfg(stage0)]\n     #[inline]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n         eachi_reverse(*self, blk)\n     }\n+    /// Iterates over a vector's elements and indices in reverse.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool {\n+        eachi_reverse(*self, blk)\n+    }\n \n     /// Reduce a vector from right to left\n     #[inline]\n@@ -2555,55 +2656,105 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for @[A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::MutableIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> old_iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<A> old_iter::MutableIter<A> for @mut [A] {\n+    #[inline(always)]\n+    fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n@@ -2627,16 +2778,27 @@ impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n \n impl<'self,A> old_iter::ExtendedMutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n         eachi_mut(*self, blk)\n     }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) -> bool {\n+        eachi_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n@@ -2660,9 +2822,14 @@ impl<A> old_iter::ExtendedIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for @[A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }"}]}