{"sha": "8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MThjZWI2N2FlYjJlOGQzMTllODQ4MWFkNTFmNTZkZDg1NTBmODc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-20T17:42:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-20T17:42:53Z"}, "message": "Rollup merge of #39913 - nikomatsakis:inference-error, r=pnkfelix\n\nReport full details of inference errors\n\nWhen the old suggestion machinery was removed by @brson in https://github.com/rust-lang/rust/pull/37057, it was not completely removed. There was a bit of code that had the job of going through errors and finding those for which suggestions were applicable, and it remained, causing us not to emit the full details of such errors.  This PR removes that.\n\nI've also added various lifetime tests to the UI test suite (so you can also see the before/after there). I have some concrete thoughts on how to improve these cases and am planning on writing those up in some mentoring issues (@CengizIO has expressed interest in working on those changes, so I plan to work with him on it, at least to start).\n\ncc @jonathandturner", "tree": {"sha": "883f02d4d9e7263265b96650e2129d61e0b52ef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/883f02d4d9e7263265b96650e2129d61e0b52ef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "html_url": "https://github.com/rust-lang/rust/commit/8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7c5563855123ab094db99d42ccab5f26dbccdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7c5563855123ab094db99d42ccab5f26dbccdf", "html_url": "https://github.com/rust-lang/rust/commit/5b7c5563855123ab094db99d42ccab5f26dbccdf"}, {"sha": "75da4b663ef3111f846e8fa5a9f3b3baaf92b4a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75da4b663ef3111f846e8fa5a9f3b3baaf92b4a3", "html_url": "https://github.com/rust-lang/rust/commit/75da4b663ef3111f846e8fa5a9f3b3baaf92b4a3"}], "stats": {"total": 622, "additions": 362, "deletions": 260}, "files": [{"sha": "9295fb2ee327b4f5910b4c29be7b12c8fc4491a6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 221, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -65,9 +65,6 @@ use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n-use super::region_inference::ProcessedErrors;\n-use super::region_inference::ProcessedErrorOrigin;\n-use super::region_inference::SameRegions;\n \n use hir::map as hir_map;\n use hir;\n@@ -77,11 +74,10 @@ use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, ReFree, Issue32330};\n+use ty::{Region, Issue32330};\n use ty::error::TypeError;\n \n use std::fmt;\n-use syntax::ast;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -255,8 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n-        let processed_errors = self.process_errors(errors);\n-        let errors = processed_errors.as_ref().unwrap_or(errors);\n+        let errors = self.process_errors(errors);\n \n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n@@ -278,13 +273,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n                 }\n-\n-                ProcessedErrors(ref origins,\n-                                ref same_regions) => {\n-                    if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins);\n-                    }\n-                }\n             }\n         }\n     }\n@@ -300,202 +288,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n-        let mut origins = Vec::new();\n-\n-        // we collect up ConcreteFailures and SubSupConflicts that are\n-        // relating free-regions bound on the fn-header and group them\n-        // together into this vector\n-        let mut same_regions = Vec::new();\n-\n-        // here we put errors that we will not be able to process nicely\n-        let mut other_errors = Vec::new();\n-\n-        // we collect up GenericBoundFailures in here.\n-        let mut bound_failures = Vec::new();\n-\n-        for error in errors {\n-            // Check whether we can process this error into some other\n-            // form; if not, fall through.\n-            match *error {\n-                ConcreteFailure(ref origin, sub, sup) => {\n-                    debug!(\"processing ConcreteFailure\");\n-                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n-                        // When comparing an impl method against a\n-                        // trait method, it is not helpful to suggest\n-                        // changes to the impl method.  This is\n-                        // because the impl method signature is being\n-                        // checked using the trait's environment, so\n-                        // usually the changes we suggest would\n-                        // actually have to be applied to the *trait*\n-                        // method (and it's not clear that the trait\n-                        // method is even under the user's control).\n-                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        origins.push(\n-                            ProcessedErrorOrigin::ConcreteFailure(\n-                                origin.clone(),\n-                                sub,\n-                                sup));\n-                        append_to_same_regions(&mut same_regions, &same_frs);\n-                        continue;\n-                    }\n-                }\n-                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n-                    match (sub_origin, sup_origin) {\n-                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n-                            // As above, when comparing an impl method\n-                            // against a trait method, it is not helpful\n-                            // to suggest changes to the impl method.\n-                        }\n-                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n-                            // See above.\n-                        }\n-                        _ => {\n-                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                                origins.push(\n-                                    ProcessedErrorOrigin::VariableFailure(\n-                                        var_origin.clone()));\n-                                append_to_same_regions(&mut same_regions, &same_frs);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-                GenericBoundFailure(ref origin, ref kind, region) => {\n-                    bound_failures.push((origin.clone(), kind.clone(), region));\n-                    continue;\n-                }\n-                ProcessedErrors(..) => {\n-                    bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n-                }\n-            }\n-\n-            // No changes to this error.\n-            other_errors.push(error.clone());\n-        }\n-\n-        // ok, let's pull together the errors, sorted in an order that\n-        // we think will help user the best\n-        let mut processed_errors = vec![];\n-\n-        // first, put the processed errors, if any\n-        if !same_regions.is_empty() {\n-            let common_scope_id = same_regions[0].scope_id;\n-            for sr in &same_regions {\n-                // Since ProcessedErrors is used to reconstruct the function\n-                // declaration, we want to make sure that they are, in fact,\n-                // from the same scope\n-                if sr.scope_id != common_scope_id {\n-                    debug!(\"returning empty result from process_errors because\n-                            {} != {}\", sr.scope_id, common_scope_id);\n-                    return None;\n-                }\n-            }\n-            assert!(origins.len() > 0);\n-            let pe = ProcessedErrors(origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n-            processed_errors.push(pe);\n-        }\n-\n-        // next, put the other misc errors\n-        processed_errors.extend(other_errors);\n-\n-        // finally, put the `T: 'a` errors, but only if there were no\n-        // other errors. otherwise, these have a very high rate of\n-        // being unhelpful in practice. This is because they are\n-        // basically secondary checks that test the state of the\n-        // region graph after the rest of inference is done, and the\n-        // other kinds of errors indicate that the region constraint\n-        // graph is internally inconsistent, so these test results are\n-        // likely to be meaningless.\n-        if processed_errors.is_empty() {\n-            for (origin, kind, region) in bound_failures {\n-                processed_errors.push(GenericBoundFailure(origin, kind, region));\n-            }\n-        }\n \n-        // we should always wind up with SOME errors, unless there were no\n-        // errors to start\n-        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n-\n-        return Some(processed_errors);\n-\n-        #[derive(Debug)]\n-        struct FreeRegionsFromSameFn {\n-            sub_fr: ty::FreeRegion,\n-            sup_fr: ty::FreeRegion,\n-            scope_id: ast::NodeId\n-        }\n-\n-        impl FreeRegionsFromSameFn {\n-            fn new(sub_fr: ty::FreeRegion,\n-                   sup_fr: ty::FreeRegion,\n-                   scope_id: ast::NodeId)\n-                   -> FreeRegionsFromSameFn {\n-                FreeRegionsFromSameFn {\n-                    sub_fr: sub_fr,\n-                    sup_fr: sup_fr,\n-                    scope_id: scope_id\n-                }\n-            }\n-        }\n-\n-        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: &'tcx Region,\n-                                                     sup: &'tcx Region)\n-                                                     -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n-            let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (&ReFree(fr1), &ReFree(fr2)) => {\n-                    if fr1.scope != fr2.scope {\n-                        return None\n-                    }\n-                    assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id(&tcx.region_maps), fr1, fr2)\n-                },\n-                _ => return None\n-            };\n-            let parent = tcx.hir.get_parent(scope_id);\n-            let parent_node = tcx.hir.find(parent);\n-            match parent_node {\n-                Some(node) => match node {\n-                    hir_map::NodeItem(item) => match item.node {\n-                        hir::ItemFn(..) => {\n-                            Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                        },\n-                        _ => None\n-                    },\n-                    hir_map::NodeImplItem(..) |\n-                    hir_map::NodeTraitItem(..) => {\n-                        Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                    },\n-                    _ => None\n-                },\n-                None => {\n-                    debug!(\"no parent node of scope_id {}\", scope_id);\n-                    None\n-                }\n-            }\n-        }\n+        // We want to avoid reporting generic-bound failures if we can\n+        // avoid it: these have a very high rate of being unhelpful in\n+        // practice. This is because they are basically secondary\n+        // checks that test the state of the region graph after the\n+        // rest of inference is done, and the other kinds of errors\n+        // indicate that the region constraint graph is internally\n+        // inconsistent, so these test results are likely to be\n+        // meaningless.\n+        //\n+        // Therefore, we filter them out of the list unless they are\n+        // the only thing in the list.\n+\n+        let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n+            ConcreteFailure(..) => false,\n+            SubSupConflict(..) => false,\n+            GenericBoundFailure(..) => true,\n+        };\n \n-        fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n-                                  same_frs: &FreeRegionsFromSameFn) {\n-            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n-                   same_regions, same_frs);\n-            let scope_id = same_frs.scope_id;\n-            let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n-                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n-                    sr.push(sub_fr.bound_region);\n-                    return\n-                }\n-            }\n-            same_regions.push(SameRegions {\n-                scope_id: scope_id,\n-                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n-            })\n+        if errors.iter().all(|e| is_bound_failure(e)) {\n+            errors.clone()\n+        } else {\n+            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n         }\n     }\n \n@@ -1072,20 +889,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n-        for origin in origins.iter() {\n-            let mut err = match *origin {\n-                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n-                    self.report_inference_failure(var_origin.clone()),\n-                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n-                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n-            };\n-\n-            err.emit();\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0bb9e2c7fa15c91345ea6c7ec0c7acb630d91410", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n-use ty::{BoundRegion, Region, RegionVid};\n+use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n@@ -171,13 +171,6 @@ pub enum RegionResolutionError<'tcx> {\n                    &'tcx Region,\n                    SubregionOrigin<'tcx>,\n                    &'tcx Region),\n-\n-    /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n-    /// more specific errors message by suggesting to the user where they\n-    /// should put a lifetime. In those cases we process and put those errors\n-    /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n-                    Vec<SameRegions>),\n }\n \n #[derive(Clone, Debug)]\n@@ -186,33 +179,6 @@ pub enum ProcessedErrorOrigin<'tcx> {\n     VariableFailure(RegionVariableOrigin),\n }\n \n-/// SameRegions is used to group regions that we think are the same and would\n-/// like to indicate so to the user.\n-/// For example, the following function\n-/// ```\n-/// struct Foo { bar: i32 }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b i32 {\n-///    &x.bar\n-/// }\n-/// ```\n-/// would report an error because we expect 'a and 'b to match, and so we group\n-/// 'a and 'b together inside a SameRegions struct\n-#[derive(Clone, Debug)]\n-pub struct SameRegions {\n-    pub scope_id: ast::NodeId,\n-    pub regions: Vec<BoundRegion>,\n-}\n-\n-impl SameRegions {\n-    pub fn contains(&self, other: &BoundRegion) -> bool {\n-        self.regions.contains(other)\n-    }\n-\n-    pub fn push(&mut self, other: BoundRegion) {\n-        self.regions.push(other);\n-    }\n-}\n-\n pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "9724d17bef1eaf446e77c95e0a0d7b59975fe0e1", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -108,9 +108,6 @@ impl Debug for Player {\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n     match to_parse { //~ ERROR match arms have incompatible types\n-    //~^ expected enum `RoomDirection`, found enum `std::option::Option`\n-    //~| expected type `RoomDirection`\n-    //~| found type `std::option::Option<_>`\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -119,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ NOTE match arm with an incompatible type\n+        _ => None\n     }\n }\n "}, {"sha": "9c1a4dbdffa846c24e266cc86e93398ea6d5fe11", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy, Clone)]\n enum E { V1(isize), V0 }\n+\n const C: &'static [E] = &[E::V0, E::V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];"}, {"sha": "30239f4c0946c0234f36ab67551a0dd6195ca11e", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "85e05422ab3b2f2e58aae9ec34194294dbc425f6", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,25 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:12:27\n+   |\n+12 |     if x > y { x } else { y }\n+   |                           ^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the body at 11:43...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "098950e13b3154f8832fd1240afde3319587b08d", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(x: &i32, y: &i32) -> &i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "fccc44caac81a5f7e25b11cdb0ca893266387bd7", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,10 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/ex1b-return-no-names-if-else.rs:11:29\n+   |\n+11 | fn foo(x: &i32, y: &i32) -> &i32 {\n+   |                             ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n+\n+error: aborting due to previous error\n+"}, {"sha": "71a1c865e09957e447621d70e0ac45e1717abe1f", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "6f42a9f679a6a51225746d8d0f386139afc0f8f4", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2a-push-one-existing-name.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'a, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #2 defined on the body at 15:51...\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "09038d8ce9027ce0708f2f314c58bd5e637d61e8", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "edc1c2362de57c597c75e923f1d8d81cca6dee04", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2b-push-no-existing-names.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'_, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #3 defined on the body at 15:43...\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb083f778deeb7e2e8d0e493988a60342a3efdd5", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let z = Ref { data: y.data };\n+    x.push(z);\n+}\n+\n+fn main() { }"}, {"sha": "755b71d4a1d9e9eabb90fbfaacda6d517096d634", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,37 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2c-push-inference-variable.rs:16:13\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2c-push-inference-variable.rs:16:25\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+  --> $DIR/ex2c-push-inference-variable.rs:17:12\n+   |\n+17 |     x.push(z);\n+   |            ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bcb7583beefcf5f28d45b2c0add7323f2fe56cb0", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    a.push(b);\n+}\n+\n+fn main() { }"}, {"sha": "daa6ea2d91aa3b567334a89cf84fad9a32e713ab", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2d-push-inference-variable-2.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2d05adb7ecd370b660bb8b13765cf071ba0e04c5", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    Vec::push(a, b);\n+}\n+\n+fn main() { }"}, {"sha": "b679532a4d91086ef85d0a22b5a81541e9780e01", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8918ceb67aeb2e8d319e8481ad51f56dd8550f87/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=8918ceb67aeb2e8d319e8481ad51f56dd8550f87", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2e-push-inference-variable-3.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}]}