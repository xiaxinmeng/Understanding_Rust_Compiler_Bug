{"sha": "ffa526937e54a22219a265df867e42f848a78a81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYTUyNjkzN2U1NGEyMjIxOWEyNjVkZjg2N2U0MmY4NDhhNzhhODE=", "commit": {"author": {"name": "Alex Zatelepin", "email": "mvzp10@gmail.com", "date": "2019-09-18T22:20:18Z"}, "committer": {"name": "Alex Zatelepin", "email": "mvzp10@gmail.com", "date": "2019-10-01T14:49:19Z"}, "message": "address review comments", "tree": {"sha": "a75239699c90d560c0d07e3565514cf88fdff713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a75239699c90d560c0d07e3565514cf88fdff713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffa526937e54a22219a265df867e42f848a78a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa526937e54a22219a265df867e42f848a78a81", "html_url": "https://github.com/rust-lang/rust/commit/ffa526937e54a22219a265df867e42f848a78a81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffa526937e54a22219a265df867e42f848a78a81/comments", "author": {"login": "ztlpn", "id": 2301957, "node_id": "MDQ6VXNlcjIzMDE5NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2301957?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ztlpn", "html_url": "https://github.com/ztlpn", "followers_url": "https://api.github.com/users/ztlpn/followers", "following_url": "https://api.github.com/users/ztlpn/following{/other_user}", "gists_url": "https://api.github.com/users/ztlpn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ztlpn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ztlpn/subscriptions", "organizations_url": "https://api.github.com/users/ztlpn/orgs", "repos_url": "https://api.github.com/users/ztlpn/repos", "events_url": "https://api.github.com/users/ztlpn/events{/privacy}", "received_events_url": "https://api.github.com/users/ztlpn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ztlpn", "id": 2301957, "node_id": "MDQ6VXNlcjIzMDE5NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2301957?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ztlpn", "html_url": "https://github.com/ztlpn", "followers_url": "https://api.github.com/users/ztlpn/followers", "following_url": "https://api.github.com/users/ztlpn/following{/other_user}", "gists_url": "https://api.github.com/users/ztlpn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ztlpn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ztlpn/subscriptions", "organizations_url": "https://api.github.com/users/ztlpn/orgs", "repos_url": "https://api.github.com/users/ztlpn/repos", "events_url": "https://api.github.com/users/ztlpn/events{/privacy}", "received_events_url": "https://api.github.com/users/ztlpn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c474c6e8253fe30684aa908ebef6e2923fb7146a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c474c6e8253fe30684aa908ebef6e2923fb7146a", "html_url": "https://github.com/rust-lang/rust/commit/c474c6e8253fe30684aa908ebef6e2923fb7146a"}], "stats": {"total": 76, "additions": 37, "deletions": 39}, "files": [{"sha": "db5b197c5d67355c4d01fc1a96399121ca472879", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ffa526937e54a22219a265df867e42f848a78a81/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa526937e54a22219a265df867e42f848a78a81/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=ffa526937e54a22219a265df867e42f848a78a81", "patch": "@@ -392,36 +392,34 @@ impl LoweringContext<'_> {\n         )\n     }\n \n+    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n+    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n+    /// and save the block id to use it as a break target for desugaring of the `?` operator.\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n         self.with_catch_scope(body.id, |this| {\n             let mut block = this.lower_block(body, true).into_inner();\n \n-            let tail_expr = block.expr.take().map_or_else(\n-                || {\n-                    let unit_span = this.mark_span_with_reason(\n-                        DesugaringKind::TryBlock,\n-                        this.sess.source_map().end_point(body.span),\n-                        None\n-                    );\n-                    this.expr_unit(unit_span)\n-                },\n-                |x: P<hir::Expr>| x.into_inner(),\n-            );\n-\n-            let from_ok_span = this.mark_span_with_reason(\n+            let try_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n-                tail_expr.span,\n+                body.span,\n                 this.allow_try_trait.clone(),\n             );\n \n+            // Final expression of the block (if present) or `()` with span at the end of block\n+            let tail_expr = block.expr.take().map_or_else(\n+                || this.expr_unit(this.sess.source_map().end_point(try_span)),\n+                |x: P<hir::Expr>| x.into_inner(),\n+            );\n+\n             let ok_wrapped_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n                 tail_expr.span,\n                 None\n             );\n \n+            // `::std::ops::Try::from_ok($tail_expr)`\n             block.expr = Some(this.wrap_in_try_constructor(\n-                sym::from_ok, from_ok_span, tail_expr, ok_wrapped_span));\n+                sym::from_ok, try_span, tail_expr, ok_wrapped_span));\n \n             hir::ExprKind::Block(P(block), None)\n         })"}, {"sha": "9152eee1a2c5a7f02d685c3c950c6baf3dd8db25", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ffa526937e54a22219a265df867e42f848a78a81/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa526937e54a22219a265df867e42f848a78a81/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=ffa526937e54a22219a265df867e42f848a78a81", "patch": "@@ -151,20 +151,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\",\n                expr, expected);\n \n-        // If when desugaring the try block we ok-wrapped an expression that diverges\n-        // (e.g. `try { return }`) then technically the ok-wrapping expression is unreachable.\n-        // But since it is autogenerated code the resulting warning is confusing for the user\n-        // so we want avoid generating it.\n-        // Ditto for the autogenerated `Try::from_ok(())` at the end of e.g. `try { return; }`.\n-        let (is_try_block_ok_wrapped_expr, is_try_block_generated_expr) = match expr.node {\n-            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n-                (true, args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock))\n-            }\n-            _ => (false, false),\n+        // True if `expr` is a `Try::from_ok(())` that is a result of desugaring a try block\n+        // without the final expr (e.g. `try { return; }`). We don't want to generate an\n+        // unreachable_code lint for it since warnings for autogenerated code are confusing.\n+        let is_try_block_generated_unit_expr = match expr.node {\n+            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) =>\n+                args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock),\n+\n+            _ => false,\n         };\n \n         // Warn for expressions after diverging siblings.\n-        if !is_try_block_generated_expr {\n+        if !is_try_block_generated_unit_expr {\n             self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n         }\n \n@@ -177,15 +175,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n-        if !is_try_block_ok_wrapped_expr {\n-            match expr.kind {\n-                ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n-                ExprKind::Call(ref callee, _) =>\n-                    self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n-                ExprKind::MethodCall(_, ref span, _) =>\n-                    self.warn_if_unreachable(expr.hir_id, *span, \"call\"),\n-                _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n-            }\n+        match expr.kind {\n+            ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n+            // If `expr` is a result of desugaring the try block and is an ok-wrapped\n+            // diverging expression (e.g. it arose from desugaring of `try { return }`),\n+            // we skip issuing a warning because it is autogenerated code.\n+            ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {},\n+            ExprKind::Call(ref callee, _) =>\n+                self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n+            ExprKind::MethodCall(_, ref span, _) =>\n+                self.warn_if_unreachable(expr.hir_id, *span, \"call\"),\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n         }\n \n         // Any expression that produces a value of type `!` must have diverged"}, {"sha": "e1c2c6b675e9bb1d1dd2d7a2ae56d7f1b73f9801", "filename": "src/test/ui/try-block/try-block-bad-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffa526937e54a22219a265df867e42f848a78a81/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffa526937e54a22219a265df867e42f848a78a81/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr?ref=ffa526937e54a22219a265df867e42f848a78a81", "patch": "@@ -32,18 +32,18 @@ LL |     let res: Result<i32, i32> = try { };\n               found type `()`\n \n error[E0277]: the trait bound `(): std::ops::Try` is not satisfied\n-  --> $DIR/try-block-bad-type.rs:17:25\n+  --> $DIR/try-block-bad-type.rs:17:23\n    |\n LL |     let res: () = try { };\n-   |                         ^ the trait `std::ops::Try` is not implemented for `()`\n+   |                       ^^^ the trait `std::ops::Try` is not implemented for `()`\n    |\n    = note: required by `std::ops::Try::from_ok`\n \n error[E0277]: the trait bound `i32: std::ops::Try` is not satisfied\n-  --> $DIR/try-block-bad-type.rs:19:26\n+  --> $DIR/try-block-bad-type.rs:19:24\n    |\n LL |     let res: i32 = try { 5 };\n-   |                          ^ the trait `std::ops::Try` is not implemented for `i32`\n+   |                        ^^^^^ the trait `std::ops::Try` is not implemented for `i32`\n    |\n    = note: required by `std::ops::Try::from_ok`\n "}]}