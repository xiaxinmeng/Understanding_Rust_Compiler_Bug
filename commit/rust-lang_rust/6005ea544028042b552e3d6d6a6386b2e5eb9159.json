{"sha": "6005ea544028042b552e3d6d6a6386b2e5eb9159", "node_id": "C_kwDOAAsO6NoAKDYwMDVlYTU0NDAyODA0MmI1NTJlM2Q2ZDZhNjM4NmIyZTVlYjkxNTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-09T16:11:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-09T16:11:30Z"}, "message": "Merge #10497\n\n10497: internal: move tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "319e4c6583e90920b367ad7387bd06e95ba1e87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/319e4c6583e90920b367ad7387bd06e95ba1e87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6005ea544028042b552e3d6d6a6386b2e5eb9159", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYb8yCRBK7hj4Ov3rIwAA3tsIAGHd2tAhOSLF7KYwVyuOa6Cm\nGFMUaigJm5NSOpb6xOUlsEnuLBHRJRCdn60waa71Ztx4DRzk3AHCNcrQOyJHNiPc\naMy8rl2GQLAG0tYUp0PH16aLnZYeVhUMBCnPpCrkIpjSpoVBlm+dJqgbyJFoGtzL\n5KHofrs/M0JshOd+u7rHbO6PW7oFTb3SdkOJIMmzdgAPTdbkGRYssscc3+I/80El\nHpnHv8895CMMLEj73777VYhmT3EKo0vBhQU7Y2MjkXZaif+dFDtybwbfLIZr785Q\n4KlB15fD7mMbc//TT8wiZ+FXY0S/yUmaO34BCzfwBNiJ+cOtvXlEZCLrMXKlyvM=\n=CSVX\n-----END PGP SIGNATURE-----\n", "payload": "tree 319e4c6583e90920b367ad7387bd06e95ba1e87b\nparent b2b703b2d79c40d145c1854b96d43a2680e3e808\nparent de136a534064509b956a794a9e40f9e3590baf6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633795890 +0000\ncommitter GitHub <noreply@github.com> 1633795890 +0000\n\nMerge #10497\n\n10497: internal: move tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6005ea544028042b552e3d6d6a6386b2e5eb9159", "html_url": "https://github.com/rust-lang/rust/commit/6005ea544028042b552e3d6d6a6386b2e5eb9159", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6005ea544028042b552e3d6d6a6386b2e5eb9159/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2b703b2d79c40d145c1854b96d43a2680e3e808", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b703b2d79c40d145c1854b96d43a2680e3e808", "html_url": "https://github.com/rust-lang/rust/commit/b2b703b2d79c40d145c1854b96d43a2680e3e808"}, {"sha": "de136a534064509b956a794a9e40f9e3590baf6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/de136a534064509b956a794a9e40f9e3590baf6e", "html_url": "https://github.com/rust-lang/rust/commit/de136a534064509b956a794a9e40f9e3590baf6e"}], "stats": {"total": 449, "additions": 232, "deletions": 217}, "files": [{"sha": "7279ff7e33c529ae86f9af8433011e365f523007", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/6005ea544028042b552e3d6d6a6386b2e5eb9159/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6005ea544028042b552e3d6d6a6386b2e5eb9159/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=6005ea544028042b552e3d6d6a6386b2e5eb9159", "patch": "@@ -383,3 +383,235 @@ fn baz() -> bool {\n \"#]],\n     );\n }\n+\n+#[test]\n+fn test_match_group_zero_match() {\n+    check(\n+        r#\"\n+macro_rules! m { ( $($i:ident)* ) => (); }\n+m!();\n+\"#,\n+        expect![[r#\"\n+macro_rules! m { ( $($i:ident)* ) => (); }\n+\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_match_group_in_group() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    [ $( ( $($i:ident)* ) )* ] => [ x![$( ( $($i)* ) )*]; ]\n+}\n+m! ( (a b) );\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    [ $( ( $($i:ident)* ) )* ] => [ x![$( ( $($i)* ) )*]; ]\n+}\n+x![(a b)];\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn test_expand_to_item_list() {\n+    check(\n+        r#\"\n+macro_rules! structs {\n+    ($($i:ident),*) => { $(struct $i { field: u32 } )* }\n+}\n+\n+// +tree\n+structs!(Foo, Bar);\n+            \"#,\n+        expect![[r#\"\n+macro_rules! structs {\n+    ($($i:ident),*) => { $(struct $i { field: u32 } )* }\n+}\n+\n+struct Foo {\n+    field:u32\n+}\n+struct Bar {\n+    field:u32\n+}\n+// MACRO_ITEMS@0..40\n+//   STRUCT@0..20\n+//     STRUCT_KW@0..6 \"struct\"\n+//     NAME@6..9\n+//       IDENT@6..9 \"Foo\"\n+//     RECORD_FIELD_LIST@9..20\n+//       L_CURLY@9..10 \"{\"\n+//       RECORD_FIELD@10..19\n+//         NAME@10..15\n+//           IDENT@10..15 \"field\"\n+//         COLON@15..16 \":\"\n+//         PATH_TYPE@16..19\n+//           PATH@16..19\n+//             PATH_SEGMENT@16..19\n+//               NAME_REF@16..19\n+//                 IDENT@16..19 \"u32\"\n+//       R_CURLY@19..20 \"}\"\n+//   STRUCT@20..40\n+//     STRUCT_KW@20..26 \"struct\"\n+//     NAME@26..29\n+//       IDENT@26..29 \"Bar\"\n+//     RECORD_FIELD_LIST@29..40\n+//       L_CURLY@29..30 \"{\"\n+//       RECORD_FIELD@30..39\n+//         NAME@30..35\n+//           IDENT@30..35 \"field\"\n+//         COLON@35..36 \":\"\n+//         PATH_TYPE@36..39\n+//           PATH@36..39\n+//             PATH_SEGMENT@36..39\n+//               NAME_REF@36..39\n+//                 IDENT@36..39 \"u32\"\n+//       R_CURLY@39..40 \"}\"\n+\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_two_idents() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($i:ident, $j:ident) => { fn foo() { let a = $i; let b = $j; } }\n+}\n+m! { foo, bar }\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($i:ident, $j:ident) => { fn foo() { let a = $i; let b = $j; } }\n+}\n+fn foo() {\n+    let a = foo;\n+    let b = bar;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_tt_to_stmts() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {\n+        let a = 0;\n+        a = 10 + 1;\n+        a\n+    }\n+}\n+\n+fn f() -> i32 {\n+    // +tree\n+    m!{}\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    () => {\n+        let a = 0;\n+        a = 10 + 1;\n+        a\n+    }\n+}\n+\n+fn f() -> i32 {\n+    let a = 0;\n+    a = 10+1;\n+    a\n+// MACRO_STMTS@0..15\n+//   LET_STMT@0..7\n+//     LET_KW@0..3 \"let\"\n+//     IDENT_PAT@3..4\n+//       NAME@3..4\n+//         IDENT@3..4 \"a\"\n+//     EQ@4..5 \"=\"\n+//     LITERAL@5..6\n+//       INT_NUMBER@5..6 \"0\"\n+//     SEMICOLON@6..7 \";\"\n+//   EXPR_STMT@7..14\n+//     BIN_EXPR@7..13\n+//       PATH_EXPR@7..8\n+//         PATH@7..8\n+//           PATH_SEGMENT@7..8\n+//             NAME_REF@7..8\n+//               IDENT@7..8 \"a\"\n+//       EQ@8..9 \"=\"\n+//       BIN_EXPR@9..13\n+//         LITERAL@9..11\n+//           INT_NUMBER@9..11 \"10\"\n+//         PLUS@11..12 \"+\"\n+//         LITERAL@12..13\n+//           INT_NUMBER@12..13 \"1\"\n+//     SEMICOLON@13..14 \";\"\n+//   PATH_EXPR@14..15\n+//     PATH@14..15\n+//       PATH_SEGMENT@14..15\n+//         NAME_REF@14..15\n+//           IDENT@14..15 \"a\"\n+\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_match_literal() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ('(') => { fn l_paren() {} }\n+}\n+m!['('];\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ('(') => { fn l_paren() {} }\n+}\n+fn l_paren() {}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_parse_macro_def_simple() {\n+    cov_mark::check!(parse_macro_def_simple);\n+    check(\n+        r#\"\n+macro m($id:ident) { fn $id() {} }\n+m!(bar);\n+\"#,\n+        expect![[r#\"\n+macro m($id:ident) { fn $id() {} }\n+fn bar() {}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_parse_macro_def_rules() {\n+    cov_mark::check!(parse_macro_def_rules);\n+\n+    check(\n+        r#\"\n+macro m {\n+    ($id:ident) => { fn $id() {} }\n+}\n+m!(bar);\n+\"#,\n+        expect![[r#\"\n+macro m {\n+    ($id:ident) => { fn $id() {} }\n+}\n+fn bar() {}\n+\"#]],\n+    );\n+}"}, {"sha": "393c2041d99cc2a2e7c1761ead1b8d4a50e7baaa", "filename": "crates/mbe/src/tests/expand.rs", "status": "modified", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/6005ea544028042b552e3d6d6a6386b2e5eb9159/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6005ea544028042b552e3d6d6a6386b2e5eb9159/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs?ref=6005ea544028042b552e3d6d6a6386b2e5eb9159", "patch": "@@ -71,92 +71,12 @@ macro_rules! foobar {\n     assert_eq!(get_text(tt::TokenId(13), T!['{']), \"{\");\n }\n \n-#[test]\n-fn test_match_group_zero_match() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ( $($i:ident)* ) => ();\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! ();\", \"\");\n-}\n-\n-#[test]\n-fn test_match_group_in_group() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! ( (a b) );\", \"(a b)\");\n-}\n-\n-#[test]\n-fn test_expand_to_item_list() {\n-    let tree = parse_macro(\n-        \"\n-            macro_rules! structs {\n-                ($($i:ident),*) => {\n-                    $(struct $i { field: u32 } )*\n-                }\n-            }\n-            \",\n-    )\n-    .expand_items(\"structs!(Foo, Bar);\");\n-    assert_eq!(\n-        format!(\"{:#?}\", tree).trim(),\n-        r#\"\n-MACRO_ITEMS@0..40\n-  STRUCT@0..20\n-    STRUCT_KW@0..6 \"struct\"\n-    NAME@6..9\n-      IDENT@6..9 \"Foo\"\n-    RECORD_FIELD_LIST@9..20\n-      L_CURLY@9..10 \"{\"\n-      RECORD_FIELD@10..19\n-        NAME@10..15\n-          IDENT@10..15 \"field\"\n-        COLON@15..16 \":\"\n-        PATH_TYPE@16..19\n-          PATH@16..19\n-            PATH_SEGMENT@16..19\n-              NAME_REF@16..19\n-                IDENT@16..19 \"u32\"\n-      R_CURLY@19..20 \"}\"\n-  STRUCT@20..40\n-    STRUCT_KW@20..26 \"struct\"\n-    NAME@26..29\n-      IDENT@26..29 \"Bar\"\n-    RECORD_FIELD_LIST@29..40\n-      L_CURLY@29..30 \"{\"\n-      RECORD_FIELD@30..39\n-        NAME@30..35\n-          IDENT@30..35 \"field\"\n-        COLON@35..36 \":\"\n-        PATH_TYPE@36..39\n-          PATH@36..39\n-            PATH_SEGMENT@36..39\n-              NAME_REF@36..39\n-                IDENT@36..39 \"u32\"\n-      R_CURLY@39..40 \"}\"\"#\n-            .trim()\n-    );\n-}\n-\n fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n     if let tt::TokenTree::Subtree(subtree) = tt {\n         return subtree;\n     }\n     unreachable!(\"It is not a subtree\");\n }\n-fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n-    if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n-        return lit;\n-    }\n-    unreachable!(\"It is not a literal\");\n-}\n \n fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n     if let tt::TokenTree::Leaf(tt::Leaf::Punct(lit)) = tt {\n@@ -165,35 +85,6 @@ fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n     unreachable!(\"It is not a Punct\");\n }\n \n-#[test]\n-fn test_expand_literals_to_token_tree() {\n-    let expansion = parse_macro(\n-        r#\"\n-            macro_rules! literals {\n-                ($i:ident) => {\n-                    {\n-                        let a = 'c';\n-                        let c = 1000;\n-                        let f = 12E+99_f64;\n-                        let s = \"rust1\";\n-                    }\n-                }\n-            }\n-            \"#,\n-    )\n-    .expand_tt(\"literals!(foo);\");\n-    let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n-\n-    // [let] [a] [=] ['c'] [;]\n-    assert_eq!(to_literal(&stm_tokens[3]).text, \"'c'\");\n-    // [let] [c] [=] [1000] [;]\n-    assert_eq!(to_literal(&stm_tokens[5 + 3]).text, \"1000\");\n-    // [let] [f] [=] [12E+99_f64] [;]\n-    assert_eq!(to_literal(&stm_tokens[10 + 3]).text, \"12E+99_f64\");\n-    // [let] [s] [=] [\"rust1\"] [;]\n-    assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n-}\n-\n #[test]\n fn test_attr_to_token_tree() {\n     let expansion = parse_to_token_tree_by_syntax(\n@@ -210,114 +101,6 @@ fn test_attr_to_token_tree() {\n     );\n }\n \n-#[test]\n-fn test_two_idents() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ident, $ j:ident) => {\n-                fn foo() { let a = $ i; let b = $j; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n-}\n-\n-#[test]\n-fn test_tt_to_stmts() {\n-    let stmts = parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            () => {\n-                 let a = 0;\n-                 a = 10 + 1;\n-                 a\n-            }\n-        }\n-\"#,\n-    )\n-    .expand_statements(\"foo!{}\");\n-\n-    assert_eq!(\n-        format!(\"{:#?}\", stmts).trim(),\n-        r#\"MACRO_STMTS@0..15\n-  LET_STMT@0..7\n-    LET_KW@0..3 \"let\"\n-    IDENT_PAT@3..4\n-      NAME@3..4\n-        IDENT@3..4 \"a\"\n-    EQ@4..5 \"=\"\n-    LITERAL@5..6\n-      INT_NUMBER@5..6 \"0\"\n-    SEMICOLON@6..7 \";\"\n-  EXPR_STMT@7..14\n-    BIN_EXPR@7..13\n-      PATH_EXPR@7..8\n-        PATH@7..8\n-          PATH_SEGMENT@7..8\n-            NAME_REF@7..8\n-              IDENT@7..8 \"a\"\n-      EQ@8..9 \"=\"\n-      BIN_EXPR@9..13\n-        LITERAL@9..11\n-          INT_NUMBER@9..11 \"10\"\n-        PLUS@11..12 \"+\"\n-        LITERAL@12..13\n-          INT_NUMBER@12..13 \"1\"\n-    SEMICOLON@13..14 \";\"\n-  PATH_EXPR@14..15\n-    PATH@14..15\n-      PATH_SEGMENT@14..15\n-        NAME_REF@14..15\n-          IDENT@14..15 \"a\"\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_match_literal() {\n-    parse_macro(\n-        r#\"\n-    macro_rules! foo {\n-        ('(') => {\n-            fn foo() {}\n-        }\n-    }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! ['('];\", \"fn foo () {}\");\n-}\n-\n-#[test]\n-fn test_parse_macro_def_simple() {\n-    cov_mark::check!(parse_macro_def_simple);\n-\n-    parse_macro2(\n-        r#\"\n-macro foo($id:ident) {\n-    fn $id() {}\n-}\n-\"#,\n-    )\n-    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n-}\n-\n-#[test]\n-fn test_parse_macro_def_rules() {\n-    cov_mark::check!(parse_macro_def_rules);\n-\n-    parse_macro2(\n-        r#\"\n-macro foo {\n-    ($id:ident) => {\n-        fn $id() {}\n-    }\n-}\n-\"#,\n-    )\n-    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n-}\n-\n #[test]\n fn test_macro_2_0_panic_2015() {\n     parse_macro2("}]}