{"sha": "ab9a1b7d60495ba3652f770305888d6f166c39fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOWExYjdkNjA0OTViYTM2NTJmNzcwMzA1ODg4ZDZmMTY2YzM5ZmU=", "commit": {"author": {"name": "whataloadofwhat", "email": "unusualmoniker@gmail.com", "date": "2014-11-02T13:27:15Z"}, "committer": {"name": "whataloadofwhat", "email": "unusualmoniker@gmail.com", "date": "2014-11-02T21:57:19Z"}, "message": "Change Json methods to &str and allow Indexing\n\nJson's find, find_path, and search methods now use &str rather\nthan &String.\n\nJson can now be indexed with &str (for Objects) and uint\n(for Lists).\n\nTests updated to reflect this change.\n\n[breaking-change]", "tree": {"sha": "15abc5832d157707b4dde2b5d50ba4ea89aa8f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15abc5832d157707b4dde2b5d50ba4ea89aa8f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab9a1b7d60495ba3652f770305888d6f166c39fe", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9a1b7d60495ba3652f770305888d6f166c39fe", "html_url": "https://github.com/rust-lang/rust/commit/ab9a1b7d60495ba3652f770305888d6f166c39fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab9a1b7d60495ba3652f770305888d6f166c39fe/comments", "author": null, "committer": null, "parents": [{"sha": "0547a407aa03b9f1c03843aead617a2e8c5d1147", "url": "https://api.github.com/repos/rust-lang/rust/commits/0547a407aa03b9f1c03843aead617a2e8c5d1147", "html_url": "https://github.com/rust-lang/rust/commit/0547a407aa03b9f1c03843aead617a2e8c5d1147"}], "stats": {"total": 56, "additions": 39, "deletions": 17}, "files": [{"sha": "31d306b01c31fa83b48ab59c8f13dd55968957d2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab9a1b7d60495ba3652f770305888d6f166c39fe/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9a1b7d60495ba3652f770305888d6f166c39fe/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ab9a1b7d60495ba3652f770305888d6f166c39fe", "patch": "@@ -203,6 +203,7 @@ use std::num::{FPNaN, FPInfinite};\n use std::str::ScalarValue;\n use std::string;\n use std::vec::Vec;\n+use std::ops;\n \n use Encodable;\n \n@@ -884,17 +885,17 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &string::String) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.find(key),\n+            &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n             _ => None\n         }\n     }\n \n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&string::String]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -908,20 +909,19 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &string::String) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n-                match map.find(key) {\n+                match map.find_with(|s| key.cmp(&s.as_slice())) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n-                        let mut value : Option<&'a Json> = None;\n                         for (_, v) in map.iter() {\n-                            value = v.search(key);\n-                            if value.is_some() {\n-                                break;\n+                            match v.search(key) {\n+                                x if x.is_some() => return x,\n+                                _ => ()\n                             }\n                         }\n-                        value\n+                        None\n                     }\n                 }\n             },\n@@ -1063,6 +1063,21 @@ impl Json {\n     }\n }\n \n+impl<'a> ops::Index<&'a str, Json>  for Json {\n+    fn index<'a>(&'a self, idx: & &str) -> &'a Json {\n+        self.find(*idx).unwrap()\n+    }\n+}\n+\n+impl ops::Index<uint, Json> for Json {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n+        match self {\n+            &List(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is a list\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[deriving(PartialEq, Clone, Show)]\n pub enum JsonEvent {\n@@ -3055,26 +3070,33 @@ mod tests {\n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_string());\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n+        let found_str = json_value.find(\"dog\");\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_string(),\n-                                             &\"cat\".to_string(), &\"mouse\".to_string()]);\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n+        let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_string()).and_then(|j| j.as_string());\n-        assert!(found_str.is_some());\n+        let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n \n+    #[test]\n+    fn test_index(){\n+        let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n+        let ref list = json_value[\"animals\"];\n+        assert_eq!(list[0].as_string().unwrap(), \"dog\");\n+        assert_eq!(list[1].as_string().unwrap(), \"cat\");\n+        assert_eq!(list[2].as_string().unwrap(), \"mouse\");\n+    }\n+\n     #[test]\n     fn test_is_object(){\n         let json_value = from_str(\"{}\").unwrap();"}]}