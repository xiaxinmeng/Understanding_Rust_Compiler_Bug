{"sha": "61004f88d1a250d2086c0ad28f005380a6a64f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMDA0Zjg4ZDFhMjUwZDIwODZjMGFkMjhmMDA1MzgwYTZhNjRmOWY=", "commit": {"author": {"name": "Ryan Prichard", "email": "ryan.prichard@gmail.com", "date": "2015-03-11T08:42:00Z"}, "committer": {"name": "Ryan Prichard", "email": "ryan.prichard@gmail.com", "date": "2015-03-11T08:42:00Z"}, "message": "Improve -Z unstable-options diagnostics and avoid an ICE\n\n * Consumers of handle_options assume the unstable options are defined in\n   the getopts::Matches value if -Z unstable-options is set, but that's not\n   the case if there weren't any actual unstable options. Fix this by\n   always reparsing options when -Z unstable-options is set.\n\n * If both argument parsing attempts fail, print the error from the second\n   attempt rather than the first. The error from the first is very poor\n   whenever unstable options are present. e.g.:\n\n       $ rustc hello.rs -Z unstable-options --show-span\n       error: Unrecognized option: 'show-span'.\n       $ rustc hello.rs -Z unstable-options --pretty --pretty\n       error: Unrecognized option: 'pretty'.\n       $ rustc hello.rs -Z unstable-options --pretty --bad-option\n       error: Unrecognized option: 'pretty'.\n\n * On the second parse, add a separate pass to reject unstable options if\n   -Z unstable-options wasn't specified.\n\nFixes #21715.\nr? @pnkfelix", "tree": {"sha": "72c28ecd5a50c3bdbb7c8ffaabb6bf810d6546f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72c28ecd5a50c3bdbb7c8ffaabb6bf810d6546f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61004f88d1a250d2086c0ad28f005380a6a64f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61004f88d1a250d2086c0ad28f005380a6a64f9f", "html_url": "https://github.com/rust-lang/rust/commit/61004f88d1a250d2086c0ad28f005380a6a64f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61004f88d1a250d2086c0ad28f005380a6a64f9f/comments", "author": {"login": "rprichard", "id": 1572855, "node_id": "MDQ6VXNlcjE1NzI4NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1572855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rprichard", "html_url": "https://github.com/rprichard", "followers_url": "https://api.github.com/users/rprichard/followers", "following_url": "https://api.github.com/users/rprichard/following{/other_user}", "gists_url": "https://api.github.com/users/rprichard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rprichard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rprichard/subscriptions", "organizations_url": "https://api.github.com/users/rprichard/orgs", "repos_url": "https://api.github.com/users/rprichard/repos", "events_url": "https://api.github.com/users/rprichard/events{/privacy}", "received_events_url": "https://api.github.com/users/rprichard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rprichard", "id": 1572855, "node_id": "MDQ6VXNlcjE1NzI4NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1572855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rprichard", "html_url": "https://github.com/rprichard", "followers_url": "https://api.github.com/users/rprichard/followers", "following_url": "https://api.github.com/users/rprichard/following{/other_user}", "gists_url": "https://api.github.com/users/rprichard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rprichard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rprichard/subscriptions", "organizations_url": "https://api.github.com/users/rprichard/orgs", "repos_url": "https://api.github.com/users/rprichard/repos", "events_url": "https://api.github.com/users/rprichard/events{/privacy}", "received_events_url": "https://api.github.com/users/rprichard/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14ce607d9b96ab3c8d5564bcddd553d6f8e175c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ce607d9b96ab3c8d5564bcddd553d6f8e175c7", "html_url": "https://github.com/rust-lang/rust/commit/14ce607d9b96ab3c8d5564bcddd553d6f8e175c7"}], "stats": {"total": 68, "additions": 43, "deletions": 25}, "files": [{"sha": "0af5de068525271415607a505eec5454e1f02d0a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/61004f88d1a250d2086c0ad28f005380a6a64f9f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61004f88d1a250d2086c0ad28f005380a6a64f9f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=61004f88d1a250d2086c0ad28f005380a6a64f9f", "patch": "@@ -688,39 +688,57 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    let matches =\n-        match getopts::getopts(&args[..], &config::optgroups()) {\n-            Ok(m) => m,\n-            Err(f_stable_attempt) => {\n-                // redo option parsing, including unstable options this time,\n-                // in anticipation that the mishandled option was one of the\n-                // unstable ones.\n-                let all_groups : Vec<getopts::OptGroup>\n-                    = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n-                match getopts::getopts(&args, &all_groups) {\n-                    Ok(m_unstable) => {\n-                        let r = m_unstable.opt_strs(\"Z\");\n-                        let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n-                        if include_unstable_options {\n-                            m_unstable\n+    fn allows_unstable_options(matches: &getopts::Matches) -> bool {\n+        let r = matches.opt_strs(\"Z\");\n+        r.iter().any(|x| *x == \"unstable-options\")\n+    }\n+\n+    fn parse_all_options(args: &Vec<String>) -> getopts::Matches {\n+        let all_groups : Vec<getopts::OptGroup>\n+            = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n+        match getopts::getopts(&args[..], &all_groups) {\n+            Ok(m) => {\n+                if !allows_unstable_options(&m) {\n+                    // If -Z unstable-options was not specified, verify that\n+                    // no unstable options were present.\n+                    for opt in config::rustc_optgroups().into_iter().filter(|x| !x.is_stable()) {\n+                        let opt_name = if !opt.opt_group.long_name.is_empty() {\n+                            &opt.opt_group.long_name\n                         } else {\n-                            early_error(&f_stable_attempt.to_string());\n+                            &opt.opt_group.short_name\n+                        };\n+                        if m.opt_present(opt_name) {\n+                            early_error(&format!(\"use of unstable option '{}' requires \\\n+                                                  -Z unstable-options\", opt_name));\n                         }\n                     }\n-                    Err(_) => {\n-                        // ignore the error from the unstable attempt; just\n-                        // pass the error we got from the first try.\n-                        early_error(&f_stable_attempt.to_string());\n-                    }\n                 }\n+                m\n             }\n-        };\n+            Err(f) => early_error(&f.to_string())\n+        }\n+    }\n \n-    let r = matches.opt_strs(\"Z\");\n-    let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n+    // As a speed optimization, first try to parse the command-line using just\n+    // the stable options.\n+    let matches = match getopts::getopts(&args[..], &config::optgroups()) {\n+        Ok(ref m) if allows_unstable_options(m) => {\n+            // If -Z unstable-options was specified, redo parsing with the\n+            // unstable options to ensure that unstable options are defined\n+            // in the returned getopts::Matches.\n+            parse_all_options(&args)\n+        }\n+        Ok(m) => m,\n+        Err(_) => {\n+            // redo option parsing, including unstable options this time,\n+            // in anticipation that the mishandled option was one of the\n+            // unstable ones.\n+            parse_all_options(&args)\n+        }\n+    };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(matches.opt_present(\"verbose\"), include_unstable_options);\n+        usage(matches.opt_present(\"verbose\"), allows_unstable_options(&matches));\n         return None;\n     }\n "}]}