{"sha": "89b47d5557b52e0da7b95e70ed61f76db152664b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjQ3ZDU1NTdiNTJlMGRhN2I5NWU3MGVkNjFmNzZkYjE1MjY2NGI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-12-13T16:47:03Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-12-16T09:23:28Z"}, "message": "debuginfo: Add test cases for function prologue handling.", "tree": {"sha": "86fe2046036dfc5db7cb56abf454d484ef5c705a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86fe2046036dfc5db7cb56abf454d484ef5c705a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b47d5557b52e0da7b95e70ed61f76db152664b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b47d5557b52e0da7b95e70ed61f76db152664b", "html_url": "https://github.com/rust-lang/rust/commit/89b47d5557b52e0da7b95e70ed61f76db152664b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b47d5557b52e0da7b95e70ed61f76db152664b/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91efb2a67f387773750b4ebc2290f16b14bf8e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/91efb2a67f387773750b4ebc2290f16b14bf8e13", "html_url": "https://github.com/rust-lang/rust/commit/91efb2a67f387773750b4ebc2290f16b14bf8e13"}], "stats": {"total": 495, "additions": 494, "deletions": 1}, "files": [{"sha": "6e56b73cd8eb25648ddfda689ed0dbb2c6c91322", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=89b47d5557b52e0da7b95e70ed61f76db152664b", "patch": "@@ -2235,7 +2235,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         })\n     }\n \n-    // Clang creates separate scope functions bodies, so let's do this too\n+    // Clang creates a separate scope for function bodies, so let's do this too\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,"}, {"sha": "e0a4afd4bdfddf8e3d825c8119b3734bb2d7a133", "filename": "src/test/debug-info/function-arg-initialization.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs?ref=89b47d5557b52e0da7b95e70ed61f76db152664b", "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-android: FIXME(#10381)\n+\n+// This test case checks if function arguments already have the correct value when breaking at the\n+// first line of the function, that is if the function prologue has already been executed at the\n+// first line. Note that because of the __morestack part of the prologue GDB incorrectly breaks at\n+// before the arguments have been properly loaded when setting the breakpoint via the function name.\n+// Therefore the setup here sets them using line numbers (so be careful when changing this file).\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break function-arg-initialization.rs:139\n+// debugger:break function-arg-initialization.rs:154\n+// debugger:break function-arg-initialization.rs:158\n+// debugger:break function-arg-initialization.rs:162\n+// debugger:break function-arg-initialization.rs:166\n+// debugger:break function-arg-initialization.rs:170\n+// debugger:break function-arg-initialization.rs:174\n+// debugger:break function-arg-initialization.rs:178\n+// debugger:break function-arg-initialization.rs:182\n+// debugger:break function-arg-initialization.rs:190\n+// debugger:break function-arg-initialization.rs:197\n+\n+\n+// debugger:run\n+\n+// IMMEDIATE ARGS\n+// debugger:print a\n+// check:$1 = 1\n+// debugger:print b\n+// check:$2 = true\n+// debugger:print c\n+// check:$3 = 2.5\n+// debugger:continue\n+\n+// NON IMMEDIATE ARGS\n+// debugger:print a\n+// check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// debugger:print b\n+// check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// debugger:continue\n+\n+// BINDING\n+// debugger:print a\n+// check:$6 = 19\n+// debugger:print b\n+// check:$7 = 20\n+// debugger:print c\n+// check:$8 = 21.5\n+// debugger:continue\n+\n+// ASSIGNMENT\n+// debugger:print a\n+// check:$9 = 22\n+// debugger:print b\n+// check:$10 = 23\n+// debugger:print c\n+// check:$11 = 24.5\n+// debugger:continue\n+\n+// FUNCTION CALL\n+// debugger:print x\n+// check:$12 = 25\n+// debugger:print y\n+// check:$13 = 26\n+// debugger:print z\n+// check:$14 = 27.5\n+// debugger:continue\n+\n+// EXPR\n+// debugger:print x\n+// check:$15 = 28\n+// debugger:print y\n+// check:$16 = 29\n+// debugger:print z\n+// check:$17 = 30.5\n+// debugger:continue\n+\n+// RETURN EXPR\n+// debugger:print x\n+// check:$18 = 31\n+// debugger:print y\n+// check:$19 = 32\n+// debugger:print z\n+// check:$20 = 33.5\n+// debugger:continue\n+\n+// ARITHMETIC EXPR\n+// debugger:print x\n+// check:$21 = 34\n+// debugger:print y\n+// check:$22 = 35\n+// debugger:print z\n+// check:$23 = 36.5\n+// debugger:continue\n+\n+// IF EXPR\n+// debugger:print x\n+// check:$24 = 37\n+// debugger:print y\n+// check:$25 = 38\n+// debugger:print z\n+// check:$26 = 39.5\n+// debugger:continue\n+\n+// WHILE EXPR\n+// debugger:print x\n+// check:$27 = 40\n+// debugger:print y\n+// check:$28 = 41\n+// debugger:print z\n+// check:$29 = 42\n+// debugger:continue\n+\n+// LOOP EXPR\n+// debugger:print x\n+// check:$30 = 43\n+// debugger:print y\n+// check:$31 = 44\n+// debugger:print z\n+// check:$32 = 45\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+\n+\n+\n+fn immediate_args(a: int, b: bool, c: f64) {\n+    ()\n+}\n+\n+struct BigStruct {\n+    a: u64,\n+    b: u64,\n+    c: u64,\n+    d: u64,\n+    e: u64,\n+    f: u64,\n+    g: u64,\n+    h: u64\n+}\n+\n+fn non_immediate_args(a: BigStruct, b: BigStruct) {\n+    ()\n+}\n+\n+fn binding(a: i64, b: u64, c: f64) {\n+    let x = 0;\n+}\n+\n+fn assignment(mut a: u64, b: u64, c: f64) {\n+    a = b;\n+}\n+\n+fn function_call(x: u64, y: u64, z: f64) {\n+    print(\"Hi!\")\n+}\n+\n+fn identifier(x: u64, y: u64, z: f64) -> u64 {\n+    x\n+}\n+\n+fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n+    return x;\n+}\n+\n+fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n+    x + y\n+}\n+\n+fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n+    if x + y < 1000 {\n+        x\n+    } else {\n+        y\n+    }\n+}\n+\n+fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    while x + y < 1000 {\n+        x += z\n+    }\n+    return x;\n+}\n+\n+fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    loop {\n+        x += z;\n+\n+        if x + y > 1000 {\n+            return x;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    immediate_args(1, true, 2.5);\n+\n+    non_immediate_args(\n+        BigStruct {\n+            a: 3,\n+            b: 4,\n+            c: 5,\n+            d: 6,\n+            e: 7,\n+            f: 8,\n+            g: 9,\n+            h: 10\n+        },\n+        BigStruct {\n+            a: 11,\n+            b: 12,\n+            c: 13,\n+            d: 14,\n+            e: 15,\n+            f: 16,\n+            g: 17,\n+            h: 18\n+        }\n+    );\n+\n+    binding(19, 20, 21.5);\n+    assignment(22, 23, 24.5);\n+    function_call(25, 26, 27.5);\n+    identifier(28, 29, 30.5);\n+    return_expr(31, 32, 33.5);\n+    arithmetic_expr(34, 35, 36.5);\n+    if_expr(37, 38, 39.5);\n+    while_expr(40, 41, 42);\n+    loop_expr(43, 44, 45);\n+}\n+\n+\n+"}, {"sha": "b0528744cff7ca8739b00f9398e22c2200a64769", "filename": "src/test/debug-info/function-prologue-stepping-no-split-stack.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b47d5557b52e0da7b95e70ed61f76db152664b/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs?ref=89b47d5557b52e0da7b95e70ed61f76db152664b", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-android: FIXME(#10381)\n+\n+// This test case checks if function arguments already have the correct value when breaking at the\n+// beginning of a function. Functions with the #[no_split_stack] attribute have the same prologue as\n+// regular C functions compiled with GCC or Clang and therefore are better handled by GDB. As a\n+// consequence, and as opposed to regular Rust functions, we can set the breakpoints via the\n+// function name (and don't have to fall back on using line numbers).\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:rbreak immediate_args\n+// debugger:rbreak binding\n+// debugger:rbreak assignment\n+// debugger:rbreak function_call\n+// debugger:rbreak identifier\n+// debugger:rbreak return_expr\n+// debugger:rbreak arithmetic_expr\n+// debugger:rbreak if_expr\n+// debugger:rbreak while_expr\n+// debugger:rbreak loop_expr\n+// debugger:run\n+\n+// IMMEDIATE ARGS\n+// debugger:print a\n+// check:$1 = 1\n+// debugger:print b\n+// check:$2 = true\n+// debugger:print c\n+// check:$3 = 2.5\n+// debugger:continue\n+\n+// NON IMMEDIATE ARGS\n+// debugger:print a\n+// check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// debugger:print b\n+// check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// debugger:continue\n+\n+// BINDING\n+// debugger:print a\n+// check:$6 = 19\n+// debugger:print b\n+// check:$7 = 20\n+// debugger:print c\n+// check:$8 = 21.5\n+// debugger:continue\n+\n+// ASSIGNMENT\n+// debugger:print a\n+// check:$9 = 22\n+// debugger:print b\n+// check:$10 = 23\n+// debugger:print c\n+// check:$11 = 24.5\n+// debugger:continue\n+\n+// FUNCTION CALL\n+// debugger:print x\n+// check:$12 = 25\n+// debugger:print y\n+// check:$13 = 26\n+// debugger:print z\n+// check:$14 = 27.5\n+// debugger:continue\n+\n+// EXPR\n+// debugger:print x\n+// check:$15 = 28\n+// debugger:print y\n+// check:$16 = 29\n+// debugger:print z\n+// check:$17 = 30.5\n+// debugger:continue\n+\n+// RETURN EXPR\n+// debugger:print x\n+// check:$18 = 31\n+// debugger:print y\n+// check:$19 = 32\n+// debugger:print z\n+// check:$20 = 33.5\n+// debugger:continue\n+\n+// ARITHMETIC EXPR\n+// debugger:print x\n+// check:$21 = 34\n+// debugger:print y\n+// check:$22 = 35\n+// debugger:print z\n+// check:$23 = 36.5\n+// debugger:continue\n+\n+// IF EXPR\n+// debugger:print x\n+// check:$24 = 37\n+// debugger:print y\n+// check:$25 = 38\n+// debugger:print z\n+// check:$26 = 39.5\n+// debugger:continue\n+\n+// WHILE EXPR\n+// debugger:print x\n+// check:$27 = 40\n+// debugger:print y\n+// check:$28 = 41\n+// debugger:print z\n+// check:$29 = 42\n+// debugger:continue\n+\n+// LOOP EXPR\n+// debugger:print x\n+// check:$30 = 43\n+// debugger:print y\n+// check:$31 = 44\n+// debugger:print z\n+// check:$32 = 45\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+#[no_split_stack]\n+fn immediate_args(a: int, b: bool, c: f64) {\n+    ()\n+}\n+\n+struct BigStruct {\n+    a: u64,\n+    b: u64,\n+    c: u64,\n+    d: u64,\n+    e: u64,\n+    f: u64,\n+    g: u64,\n+    h: u64\n+}\n+\n+#[no_split_stack]\n+fn non_immediate_args(a: BigStruct, b: BigStruct) {\n+    ()\n+}\n+\n+#[no_split_stack]\n+fn binding(a: i64, b: u64, c: f64) {\n+    let x = 0;\n+}\n+\n+#[no_split_stack]\n+fn assignment(mut a: u64, b: u64, c: f64) {\n+    a = b;\n+}\n+\n+#[no_split_stack]\n+fn function_call(x: u64, y: u64, z: f64) {\n+    print(\"Hi!\")\n+}\n+\n+#[no_split_stack]\n+fn identifier(x: u64, y: u64, z: f64) -> u64 {\n+    x\n+}\n+\n+#[no_split_stack]\n+fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n+    return x;\n+}\n+\n+#[no_split_stack]\n+fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n+    x + y\n+}\n+\n+#[no_split_stack]\n+fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n+    if x + y < 1000 {\n+        x\n+    } else {\n+        y\n+    }\n+}\n+\n+#[no_split_stack]\n+fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    while x + y < 1000 {\n+        x += z\n+    }\n+    return x;\n+}\n+\n+#[no_split_stack]\n+fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    loop {\n+        x += z;\n+\n+        if x + y > 1000 {\n+            return x;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    immediate_args(1, true, 2.5);\n+\n+    non_immediate_args(\n+        BigStruct {\n+            a: 3,\n+            b: 4,\n+            c: 5,\n+            d: 6,\n+            e: 7,\n+            f: 8,\n+            g: 9,\n+            h: 10\n+        },\n+        BigStruct {\n+            a: 11,\n+            b: 12,\n+            c: 13,\n+            d: 14,\n+            e: 15,\n+            f: 16,\n+            g: 17,\n+            h: 18\n+        }\n+    );\n+\n+    binding(19, 20, 21.5);\n+    assignment(22, 23, 24.5);\n+    function_call(25, 26, 27.5);\n+    identifier(28, 29, 30.5);\n+    return_expr(31, 32, 33.5);\n+    arithmetic_expr(34, 35, 36.5);\n+    if_expr(37, 38, 39.5);\n+    while_expr(40, 41, 42);\n+    loop_expr(43, 44, 45);\n+}\n+\n+\n+"}]}