{"sha": "0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "node_id": "C_kwDOAAsO6NoAKDBmYzk1ZTg4ZjU1NmQzZmI5NWRkOTJmMTlhMTgzYTMwYmI1Yzk2ODg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T21:31:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T21:31:37Z"}, "message": "Auto merge of #9318 - lukaslueg:ifletmutexref, r=xFrednet\n\nFix if_let_mutex not checking Mutexes behind refs\n\nFixes #9193\n\nWe can always peel references because we are looking for a method-call, for which autoderef applies.\n\n---\n\nchangelog: [`if_let_mutex`]: detect calls to `Mutex::lock()` if mutex is behind a ref\nchangelog: [`if_let_mutex`]: Add labels to the two instances of the same Mutex that will deadlock", "tree": {"sha": "8fcb7f407169cfd8df0161a9e58a07f26897790b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fcb7f407169cfd8df0161a9e58a07f26897790b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "html_url": "https://github.com/rust-lang/rust/commit/0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9040ceaa7ee32e77c8e8eb8002087accb13a38", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9040ceaa7ee32e77c8e8eb8002087accb13a38", "html_url": "https://github.com/rust-lang/rust/commit/8c9040ceaa7ee32e77c8e8eb8002087accb13a38"}, {"sha": "6de4bdfa8e36bcf5c814b0d43afc1cefb0630533", "url": "https://api.github.com/repos/rust-lang/rust/commits/6de4bdfa8e36bcf5c814b0d43afc1cefb0630533", "html_url": "https://github.com/rust-lang/rust/commit/6de4bdfa8e36bcf5c814b0d43afc1cefb0630533"}], "stats": {"total": 88, "additions": 61, "deletions": 27}, "files": [{"sha": "4d703d691acc2f81e57296256027072221c27214", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "patch": "@@ -1,8 +1,9 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n+use rustc_errors::Diagnostic;\n use rustc_hir::intravisit::{self as visit, Visitor};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -45,16 +46,8 @@ declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        let mut arm_visit = ArmVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n-        let mut op_visit = OppVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n+        let mut arm_visit = ArmVisitor { found_mutex: None, cx };\n+        let mut op_visit = OppVisitor { found_mutex: None, cx };\n         if let Some(higher::IfLet {\n             let_expr,\n             if_then,\n@@ -63,18 +56,28 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n         }) = higher::IfLet::hir(cx, expr)\n         {\n             op_visit.visit_expr(let_expr);\n-            if op_visit.mutex_lock_called {\n+            if let Some(op_mutex) = op_visit.found_mutex {\n                 arm_visit.visit_expr(if_then);\n                 arm_visit.visit_expr(if_else);\n \n-                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n-                    span_lint_and_help(\n+                if let Some(arm_mutex) = arm_visit.found_mutex_if_same_as(op_mutex) {\n+                    let diag = |diag: &mut Diagnostic| {\n+                        diag.span_label(\n+                            op_mutex.span,\n+                            \"this Mutex will remain locked for the entire `if let`-block...\",\n+                        );\n+                        diag.span_label(\n+                            arm_mutex.span,\n+                            \"... and is tried to lock again here, which will always deadlock.\",\n+                        );\n+                        diag.help(\"move the lock call outside of the `if let ...` expression\");\n+                    };\n+                    span_lint_and_then(\n                         cx,\n                         IF_LET_MUTEX,\n                         expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n-                        None,\n-                        \"move the lock call outside of the `if let ...` expression\",\n+                        diag,\n                     );\n                 }\n             }\n@@ -84,7 +87,6 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n \n /// Checks if `Mutex::lock` is called in the `if let` expr.\n pub struct OppVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -93,7 +95,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n@@ -102,7 +103,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n \n /// Checks if `Mutex::lock` is called in any of the branches.\n pub struct ArmVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -111,25 +111,27 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n     }\n }\n \n impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n-    fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        self.found_mutex\n-            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n+    fn found_mutex_if_same_as(&self, op_mutex: &Expr<'_>) -> Option<&Expr<'_>> {\n+        self.found_mutex.and_then(|arm_mutex| {\n+            SpanlessEq::new(self.cx)\n+                .eq_expr(op_mutex, arm_mutex)\n+                .then_some(arm_mutex)\n+        })\n     }\n }\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n-        let ty = cx.typeck_results().expr_ty(self_arg);\n+        let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);\n         then {\n             Some(self_arg)"}, {"sha": "321feb0224ed11a97d111f645b8c77b7af073b89", "filename": "tests/ui/if_let_mutex.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/tests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/tests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.rs?ref=0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "patch": "@@ -39,4 +39,12 @@ fn if_let_different_mutex() {\n     };\n }\n \n+fn mutex_ref(mutex: &Mutex<i32>) {\n+    if let Ok(i) = mutex.lock() {\n+        do_stuff(i);\n+    } else {\n+        let _x = mutex.lock();\n+    };\n+}\n+\n fn main() {}"}, {"sha": "8a4d5dbac592b33d12a0d3b0061413a719e17248", "filename": "tests/ui/if_let_mutex.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/tests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0fc95e88f556d3fb95dd92f19a183a30bb5c9688/tests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.stderr?ref=0fc95e88f556d3fb95dd92f19a183a30bb5c9688", "patch": "@@ -1,10 +1,14 @@\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:10:5\n    |\n-LL | /     if let Err(locked) = m.lock() {\n+LL |       if let Err(locked) = m.lock() {\n+   |       ^                    - this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n@@ -15,15 +19,35 @@ LL | |     };\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:22:5\n    |\n-LL | /     if let Some(locked) = m.lock().unwrap().deref() {\n+LL |       if let Some(locked) = m.lock().unwrap().deref() {\n+   |       ^                     - this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n    |\n    = help: move the lock call outside of the `if let ...` expression\n \n-error: aborting due to 2 previous errors\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:43:5\n+   |\n+LL |       if let Ok(i) = mutex.lock() {\n+   |       ^              ----- this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n+LL | |         do_stuff(i);\n+LL | |     } else {\n+LL | |         let _x = mutex.lock();\n+   | |                  ----- ... and is tried to lock again here, which will always deadlock.\n+LL | |     };\n+   | |_____^\n+   |\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: aborting due to 3 previous errors\n "}]}