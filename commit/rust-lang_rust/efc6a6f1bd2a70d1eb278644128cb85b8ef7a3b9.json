{"sha": "efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "node_id": "C_kwDOAAsO6NoAKGVmYzZhNmYxYmQyYTcwZDFlYjI3ODY0NDEyOGNiODViOGVmN2EzYjk", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-05-03T13:53:53Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-05-03T13:53:53Z"}, "message": "Report that opaque types are not allowed in impls even in the presence of other errors", "tree": {"sha": "65d7337be9e33c4bca193ba796ecc2d74b055875", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65d7337be9e33c4bca193ba796ecc2d74b055875"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "html_url": "https://github.com/rust-lang/rust/commit/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468492c2af3993f18b1fe98052200575c4a2e678", "url": "https://api.github.com/repos/rust-lang/rust/commits/468492c2af3993f18b1fe98052200575c4a2e678", "html_url": "https://github.com/rust-lang/rust/commit/468492c2af3993f18b1fe98052200575c4a2e678"}], "stats": {"total": 122, "additions": 64, "deletions": 58}, "files": [{"sha": "f57986a985cdea63face6a3d361ba95a0abd0663", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "patch": "@@ -44,6 +44,59 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n     };\n     let sp = tcx.sess.source_map().guess_head_span(item.span);\n     let tr = impl_.of_trait.as_ref().unwrap();\n+\n+    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n+    // and #84660 where it would otherwise allow unsoundness.\n+    if trait_ref.has_opaque_types() {\n+        trace!(\"{:#?}\", item);\n+        // First we find the opaque type in question.\n+        for ty in trait_ref.substs {\n+            for ty in ty.walk() {\n+                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n+                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n+                trace!(?def_id);\n+\n+                // Then we search for mentions of the opaque type's type alias in the HIR\n+                struct SpanFinder<'tcx> {\n+                    sp: Span,\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n+                    #[instrument(level = \"trace\", skip(self, _id))]\n+                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n+                        // You can't mention an opaque type directly, so we look for type aliases\n+                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n+                            // And check if that type alias's type contains the opaque type we're looking for\n+                            for arg in self.tcx.type_of(def_id).walk() {\n+                                if let GenericArgKind::Type(ty) = arg.unpack() {\n+                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n+                                        if def_id == self.def_id {\n+                                            // Finally we update the span to the mention of the type alias\n+                                            self.sp = path.span;\n+                                            return;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        hir::intravisit::walk_path(self, path)\n+                    }\n+                }\n+\n+                let mut visitor = SpanFinder { sp, def_id, tcx };\n+                hir::intravisit::walk_item(&mut visitor, item);\n+                let reported = tcx\n+                    .sess\n+                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n+                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n+                    .emit();\n+                return Err(reported);\n+            }\n+        }\n+        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n+    }\n+\n     match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n@@ -143,58 +196,6 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n         }\n     }\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     Ok(())\n }\n "}, {"sha": "6f764a952c02274041fa4ce12a26b3e65f843084", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "98ac215ad6cc53f6b7a280eb71df97f57e35cffd", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "patch": "@@ -12,6 +12,6 @@ fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n }\n \n impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+//~^ ERROR cannot implement trait on type alias impl trait\n \n fn main() {}"}, {"sha": "3ce25d94f6e124b832d7d0e97a697f083b351831", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "patch": "@@ -1,9 +1,14 @@\n-error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n-  --> $DIR/coherence.rs:14:6\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/coherence.rs:14:41\n    |\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-   |      ^ unconstrained type parameter\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/coherence.rs:9:30\n+   |\n+LL | type AliasOfForeignType<T> = impl LocalTrait;\n+   |                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0207`."}]}