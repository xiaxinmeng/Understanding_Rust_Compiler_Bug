{"sha": "ff9341a9e3c23494cbd51fabafd1275097d41203", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOTM0MWE5ZTNjMjM0OTRjYmQ1MWZhYmFmZDEyNzUwOTdkNDEyMDM=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-02-28T12:36:45Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-02-28T12:45:30Z"}, "message": "remove redundant clones, references to operands, explicit boolean comparisons and filter(x).next() calls.", "tree": {"sha": "e1c554a4abf7ebcd386b9ccec345187cea9d98c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1c554a4abf7ebcd386b9ccec345187cea9d98c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff9341a9e3c23494cbd51fabafd1275097d41203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9341a9e3c23494cbd51fabafd1275097d41203", "html_url": "https://github.com/rust-lang/rust/commit/ff9341a9e3c23494cbd51fabafd1275097d41203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff9341a9e3c23494cbd51fabafd1275097d41203/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2223c94bf433fc38234d1303e88cbaf14755863", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2223c94bf433fc38234d1303e88cbaf14755863", "html_url": "https://github.com/rust-lang/rust/commit/e2223c94bf433fc38234d1303e88cbaf14755863"}], "stats": {"total": 92, "additions": 39, "deletions": 53}, "files": [{"sha": "980a3f04781346d9ec349aeb51d4a959cb830e4b", "filename": "src/librustc_infer/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fwf.rs?ref=ff9341a9e3c23494cbd51fabafd1275097d41203", "patch": "@@ -232,10 +232,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //                 found type `()`\n                         if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n                             let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) = items\n-                                .iter()\n-                                .filter(|item| item.ident == trait_assoc_item.ident)\n-                                .next()\n+                            if let Some(impl_item) =\n+                                items.iter().find(|item| item.ident == trait_assoc_item.ident)\n                             {\n                                 cause.span = impl_item.span;\n                                 cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n@@ -285,13 +283,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         {\n                             if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n                                 .iter()\n-                                .filter(|i| i.def_id == *item_def_id)\n-                                .next()\n+                                .find(|i| i.def_id == *item_def_id)\n                                 .and_then(|trait_assoc_item| {\n                                     items\n                                         .iter()\n-                                        .filter(|i| i.ident == trait_assoc_item.ident)\n-                                        .next()\n+                                        .find(|i| i.ident == trait_assoc_item.ident)\n                                         .map(|impl_item| (impl_item, trait_assoc_item))\n                                 })\n                             {"}, {"sha": "a0d93d6d19ab89b30c0cb1917c0805568edce1a0", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=ff9341a9e3c23494cbd51fabafd1275097d41203", "patch": "@@ -689,11 +689,7 @@ pub trait BottomValue {\n     /// 3. Override `join` to do the opposite from what it's doing now.\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if Self::BOTTOM_VALUE == false {\n-            inout_set.union(in_set)\n-        } else {\n-            inout_set.intersect(in_set)\n-        }\n+        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n     }\n }\n "}, {"sha": "9073e131f700dda25281d4bcbed8b61e9c317152", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=ff9341a9e3c23494cbd51fabafd1275097d41203", "patch": "@@ -89,7 +89,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n         let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n+        let item = self.parse_item_common(attrs, false, true, |_| true)?;\n         self.directory.ownership = old;\n         Ok(item)\n     }"}, {"sha": "e2aa853e78ced6afa11f10428236b5c71752d69a", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=ff9341a9e3c23494cbd51fabafd1275097d41203", "patch": "@@ -968,18 +968,14 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         for missing in &self.missing_named_lifetime_spots {\n             match missing {\n                 MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) = generics\n-                        .params\n-                        .iter()\n-                        .filter(|p| match p.kind {\n+                    let (span, sugg) = if let Some(param) =\n+                        generics.params.iter().find(|p| match p.kind {\n                             hir::GenericParamKind::Type {\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n                                 ..\n                             } => false,\n                             _ => true,\n-                        })\n-                        .next()\n-                    {\n+                        }) {\n                         (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n                     } else {\n                         (generics.span, format!(\"<{}>\", lifetime_ref))\n@@ -1053,25 +1049,24 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             };\n-            let suggest_new =\n-                |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n-                    err.span_label(span, \"expected named lifetime parameter\");\n+            let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                err.span_label(span, \"expected named lifetime parameter\");\n \n-                    for missing in self.missing_named_lifetime_spots.iter().rev() {\n-                        let mut introduce_suggestion = vec![];\n-                        let msg;\n-                        let should_break;\n-                        introduce_suggestion.push(match missing {\n+                for missing in self.missing_named_lifetime_spots.iter().rev() {\n+                    let mut introduce_suggestion = vec![];\n+                    let msg;\n+                    let should_break;\n+                    introduce_suggestion.push(match missing {\n                         MissingLifetimeSpot::Generics(generics) => {\n                             msg = \"consider introducing a named lifetime parameter\".to_string();\n                             should_break = true;\n-                            if let Some(param) = generics.params.iter().filter(|p| match p.kind {\n+                            if let Some(param) = generics.params.iter().find(|p| match p.kind {\n                                 hir::GenericParamKind::Type {\n                                     synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n                                     ..\n                                 } => false,\n                                 _ => true,\n-                            }).next() {\n+                            }) {\n                                 (param.span.shrink_to_lo(), \"'a, \".to_string())\n                             } else {\n                                 (generics.span, \"<'a>\".to_string())\n@@ -1090,30 +1085,29 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             (*span, span_type.suggestion(\"'a\"))\n                         }\n                     });\n-                        for param in params {\n-                            if let Ok(snippet) =\n-                                self.tcx.sess.source_map().span_to_snippet(param.span)\n-                            {\n-                                if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                                } else if snippet.starts_with(\"&'_ \") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n-                                }\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n+                            } else if snippet.starts_with(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n                             }\n                         }\n-                        introduce_suggestion.push((span, sugg.to_string()));\n-                        err.multipart_suggestion(\n-                            &msg,\n-                            introduce_suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        if should_break {\n-                            break;\n-                        }\n                     }\n-                };\n+                    introduce_suggestion.push((span, sugg.to_string()));\n+                    err.multipart_suggestion(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    if should_break {\n+                        break;\n+                    }\n+                }\n+            };\n \n             match (\n                 lifetime_names.len(),"}, {"sha": "4d51b63b740fd8ee9e0ed5ca94c6e6cbf2ab7342", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9341a9e3c23494cbd51fabafd1275097d41203/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ff9341a9e3c23494cbd51fabafd1275097d41203", "patch": "@@ -398,7 +398,7 @@ pub fn make_test(\n             use rustc_span::source_map::FilePathMapping;\n \n             let filename = FileName::anon_source_code(s);\n-            let source = crates + &everything_else;\n+            let source = crates + everything_else;\n \n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that libsyntax emits directly into a `Sink` instead of stderr."}]}