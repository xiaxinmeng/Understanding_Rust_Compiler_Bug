{"sha": "ec7c0aece17c9a11bc2eca15b994355a161bf878", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjN2MwYWVjZTE3YzlhMTFiYzJlY2ExNWI5OTQzNTVhMTYxYmY4Nzg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-17T04:04:41Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-29T00:41:10Z"}, "message": "Merge `ExpnId` and `SyntaxContext`.", "tree": {"sha": "05ff8d97fedf1ab11028eddbd4982896cc61387f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05ff8d97fedf1ab11028eddbd4982896cc61387f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7c0aece17c9a11bc2eca15b994355a161bf878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7c0aece17c9a11bc2eca15b994355a161bf878", "html_url": "https://github.com/rust-lang/rust/commit/ec7c0aece17c9a11bc2eca15b994355a161bf878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7c0aece17c9a11bc2eca15b994355a161bf878/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "496996c2af6174cb83a65756249d289f315dff80", "url": "https://api.github.com/repos/rust-lang/rust/commits/496996c2af6174cb83a65756249d289f315dff80", "html_url": "https://github.com/rust-lang/rust/commit/496996c2af6174cb83a65756249d289f315dff80"}], "stats": {"total": 1158, "additions": 456, "deletions": 702}, "files": [{"sha": "786145f3091db79527f21de4eb4effdfda7138da", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -57,6 +57,7 @@ use std::mem;\n use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::codemap::{self, respan, Spanned};\n use syntax::std_inject;\n@@ -392,14 +393,16 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n-        span.expn_id = self.sess.codemap().record_expansion(codemap::ExpnInfo {\n+        let mark = Mark::fresh();\n+        mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n                 format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n         });\n+        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n         span\n     }\n \n@@ -1986,7 +1989,7 @@ impl<'a> LoweringContext<'a> {\n                     volatile: asm.volatile,\n                     alignstack: asm.alignstack,\n                     dialect: asm.dialect,\n-                    expn_id: asm.expn_id,\n+                    ctxt: asm.ctxt,\n                 };\n                 let outputs =\n                     asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect();"}, {"sha": "da7e71ac07d2182c930297fdc0532a73533e993a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -33,11 +33,12 @@ use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n-use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n@@ -1367,7 +1368,7 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub expn_id: ExpnId,\n+    pub ctxt: SyntaxContext,\n }\n \n /// represents an argument in a function header"}, {"sha": "1278d9f5171b3be590be3880fd4804a4d6f7242a", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -47,10 +47,6 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         }\n     }\n \n-    pub fn codemap(&self) -> &'tcx CodeMap {\n-        self.codemap\n-    }\n-\n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n                                     -> Option<(Rc<FileMap>, usize, BytePos)> {"}, {"sha": "0676075930dc3c99f28d4845126e6a1dcfec0617", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -236,7 +236,7 @@ impl CodeExtent {\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n                         let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, expn_id: stmt_span.expn_id })\n+                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, ctxt: stmt_span.ctxt })\n                     }\n                 }\n             }"}, {"sha": "2b5ea61d4e85454a181d8cf8aeefb7c31b3db6fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n-        if self.sess.codemap().span_allows_unstable(span) {\n+        if span.allows_unstable() {\n             debug!(\"stability: \\\n                     skipping span={:?} since it is internal\", span);\n             return;"}, {"sha": "977382b33adf75a429eb566390c9471f3793d65c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -580,7 +580,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n     krate = time(time_passes, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.clone();\n-        syntax::std_inject::maybe_inject_crates_ref(&sess.parse_sess, krate, alt_std_name)\n+        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name)\n     });\n \n     let mut addl_plugins = Some(addl_plugins);\n@@ -798,7 +798,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n-        syntax::ext::hygiene::reset_hygiene_data();\n+        syntax::ext::hygiene::clear_markings();\n     }\n \n     Ok(ExpansionResult {"}, {"sha": "367b85ac726db0aa49be0add1b7a59971713e526", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n+use syntax_pos::{DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n@@ -151,7 +151,7 @@ impl EmitterWriter {\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n-                if span_label.span == DUMMY_SP || span_label.span == COMMAND_LINE_SP {\n+                if span_label.span == DUMMY_SP {\n                     continue;\n                 }\n                 let lo = cm.lookup_char_pos(span_label.span.lo);\n@@ -615,15 +615,15 @@ impl EmitterWriter {\n         let mut max = 0;\n         if let Some(ref cm) = self.cm {\n             for primary_span in msp.primary_spans() {\n-                if primary_span != &DUMMY_SP && primary_span != &COMMAND_LINE_SP {\n+                if primary_span != &DUMMY_SP {\n                     let hi = cm.lookup_char_pos(primary_span.hi);\n                     if hi.line > max {\n                         max = hi.line;\n                     }\n                 }\n             }\n             for span_label in msp.span_labels() {\n-                if span_label.span != DUMMY_SP && span_label.span != COMMAND_LINE_SP {\n+                if span_label.span != DUMMY_SP {\n                     let hi = cm.lookup_char_pos(span_label.span.hi);\n                     if hi.line > max {\n                         max = hi.line;\n@@ -659,20 +659,20 @@ impl EmitterWriter {\n \n             // First, find all the spans in <*macros> and point instead at their use site\n             for sp in span.primary_spans() {\n-                if (*sp == COMMAND_LINE_SP) || (*sp == DUMMY_SP) {\n+                if *sp == DUMMY_SP {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp.clone()).contains(\"macros>\") {\n-                    let v = cm.macro_backtrace(sp.clone());\n+                    let v = sp.macro_backtrace();\n                     if let Some(use_site) = v.last() {\n                         before_after.push((sp.clone(), use_site.call_site.clone()));\n                     }\n                 }\n-                for trace in cm.macro_backtrace(sp.clone()).iter().rev() {\n+                for trace in sp.macro_backtrace().iter().rev() {\n                     // Only show macro locations that are local\n                     // and display them like a span_note\n                     if let Some(def_site) = trace.def_site_span {\n-                        if (def_site == COMMAND_LINE_SP) || (def_site == DUMMY_SP) {\n+                        if def_site == DUMMY_SP {\n                             continue;\n                         }\n                         // Check to make sure we're not in any <*macros>\n@@ -689,11 +689,11 @@ impl EmitterWriter {\n                 span.push_span_label(label_span, label_text);\n             }\n             for sp_label in span.span_labels() {\n-                if (sp_label.span == COMMAND_LINE_SP) || (sp_label.span == DUMMY_SP) {\n+                if sp_label.span == DUMMY_SP {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp_label.span.clone()).contains(\"macros>\") {\n-                    let v = cm.macro_backtrace(sp_label.span.clone());\n+                    let v = sp_label.span.macro_backtrace();\n                     if let Some(use_site) = v.last() {\n                         before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n                     }\n@@ -848,7 +848,7 @@ impl EmitterWriter {\n         // Make sure our primary file comes first\n         let primary_lo = if let (Some(ref cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n-            if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+            if primary_span != &&DUMMY_SP {\n                 cm.lookup_char_pos(primary_span.lo)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;"}, {"sha": "2efdaa57fba36bf68ad45c2f635745574a1b2791", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -48,7 +48,6 @@ pub mod styled_buffer;\n mod lock;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n-use syntax_pos::MacroBacktrace;\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum RenderSpan {\n@@ -75,7 +74,6 @@ pub trait CodeMapper {\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n-    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n }\n \n@@ -120,7 +118,7 @@ impl CodeSuggestion {\n         let bounding_span = Span {\n             lo: lo,\n             hi: hi,\n-            expn_id: NO_EXPANSION,\n+            ctxt: NO_EXPANSION,\n         };\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n         assert!(!lines.lines.is_empty());"}, {"sha": "5401b371888e939c58b6b3145b5f3faf67aa5315", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -17,9 +17,10 @@ use self::SawTraitOrImplItemComponent::*;\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::parse::token;\n use syntax::symbol::InternedString;\n-use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n+use syntax_pos::{Span, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n@@ -92,10 +93,10 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             span.hi\n         };\n \n-        let expn_kind = match span.expn_id {\n-            NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n-            COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n-            _ => SawSpanExpnKind::SomeExpansion,\n+        let expn_kind = if span.ctxt == SyntaxContext::empty() {\n+            SawSpanExpnKind::NoExpansion\n+        } else {\n+            SawSpanExpnKind::SomeExpansion\n         };\n \n         let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n@@ -121,8 +122,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         saw.hash(self.st);\n \n         if expn_kind == SawSpanExpnKind::SomeExpansion {\n-            let call_site = self.codemap.codemap().source_callsite(span);\n-            self.hash_span(call_site);\n+            self.hash_span(span.source_callsite());\n         }\n     }\n \n@@ -483,7 +483,6 @@ fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n #[derive(Clone, Copy, Hash, Eq, PartialEq)]\n enum SawSpanExpnKind {\n     NoExpansion,\n-    CommandLine,\n     SomeExpansion,\n }\n \n@@ -501,7 +500,7 @@ impl<'a> Hash for StableInlineAsm<'a> {\n             volatile,\n             alignstack,\n             dialect,\n-            expn_id: _, // This is used for error reporting\n+            ctxt: _, // This is used for error reporting\n         } = *self.0;\n \n         asm.as_str().hash(state);"}, {"sha": "9d236bd013c43114db3ef0f13921c839fd933e78", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             // This comes from a macro that has #[allow_internal_unstable].\n-            if self.tcx.sess.codemap().span_allows_unstable(self.span) {\n+            if self.span.allows_unstable() {\n                 return;\n             }\n \n@@ -805,7 +805,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     self.def_id.is_local() &&\n \n                     // this doesn't come from a macro that has #[allow_internal_unstable]\n-                    !self.tcx.sess.codemap().span_allows_unstable(self.span)\n+                    !self.span.allows_unstable()\n                 {\n                     let mut err = self.tcx.sess.struct_span_err(self.span,\n                         \"const fns are an unstable feature\");"}, {"sha": "e884f3bdbb122f24ff546440dbb7366a84e3a81f", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -20,7 +20,7 @@ use std::env;\n use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax_pos::{Span, COMMAND_LINE_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n pub type PluginRegistrarFun =\n@@ -81,7 +81,7 @@ pub fn load_plugins(sess: &Session,\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(COMMAND_LINE_SP, &plugin, vec![]);\n+            loader.load_plugin(DUMMY_SP, &plugin, vec![]);\n         }\n     }\n "}, {"sha": "fd6803e087a08de7b4258346ffbfbcc116a35c21", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -690,9 +690,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // Note we take care to use the source callsite/callee, to handle\n         // nested expansions and ensure we only generate data for source-visible\n         // macro uses.\n-        let callsite = self.tcx.sess.codemap().source_callsite(span);\n-        let callee = self.tcx.sess.codemap().source_callee(span);\n-        let callee = option_try!(callee);\n+        let callsite = span.source_callsite();\n+        let callee = option_try!(span.source_callee());\n         let callee_span = option_try!(callee.span);\n \n         // Ignore attribute macros, their spans are usually mangled\n@@ -1013,5 +1012,5 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n pub fn generated_code(span: Span) -> bool {\n-    span.expn_id != NO_EXPANSION || span == DUMMY_SP\n+    span.ctxt != NO_EXPANSION || span == DUMMY_SP\n }"}, {"sha": "c19f805a28575d888fcd68fc81e000bc10cddfce", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -462,8 +462,7 @@ impl<'a> SpanUtils<'a> {\n \n         // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n         // callsite. This filters out macro internal variables and most malformed spans.\n-        let span = self.sess.codemap().source_callsite(parent);\n-        !(span.contains(parent))\n+        !parent.source_callsite().contains(parent)\n     }\n }\n "}, {"sha": "3e270b7928ebc28127af2ab9d8228ce937286fa3", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -111,14 +111,14 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         bcx.store(v, val, None);\n     }\n \n-    // Store expn_id in a metadata node so we can map LLVM errors\n+    // Store mark in a metadata node so we can map LLVM errors\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n         let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.expn_id.into_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));"}, {"sha": "ccb3f7ac882aa8b209a2492fc551df8a6d5ee0b8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -371,14 +371,14 @@ struct HandlerFreeVars<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    use syntax_pos::ExpnId;\n+    use syntax::ext::hygiene::Mark;\n \n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n-            sess.codemap().with_expn_info(ExpnId::from_u32(cookie), |info| match info {\n+            match Mark::from_u32(cookie).expn_info() {\n                 Some(ei) => sess.span_err(ei.call_site, msg),\n                 None     => sess.err(msg),\n-            });\n+            };\n         }\n \n         None => {"}, {"sha": "21bbbea77d442aa98f625df2ada73c179496bc46", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -26,7 +26,7 @@ use monomorphize::{self, Instance};\n use abi::FnType;\n use type_of;\n \n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos, Span};\n+use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n \n use std::iter;\n@@ -124,24 +124,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.expn_id == NO_EXPANSION ||\n-            source_info.span.expn_id == COMMAND_LINE_EXPN ||\n-            self.ccx.sess().opts.debugging_opts.debug_macros {\n-\n+        if source_info.span.ctxt == NO_EXPANSION ||\n+           self.ccx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo);\n             (scope, source_info.span)\n         } else {\n-            let cm = self.ccx.sess().codemap();\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occurr\n             // at the level above that.\n             let mut span = source_info.span;\n-            while span.expn_id != NO_EXPANSION &&\n-                  span.expn_id != COMMAND_LINE_EXPN &&\n-                  span.expn_id != self.mir.span.expn_id {\n-                if let Some(callsite_span) = cm.with_expn_info(span.expn_id,\n-                                                    |ei| ei.map(|ei| ei.call_site.clone())) {\n-                    span = callsite_span;\n+            while span.ctxt != NO_EXPANSION && span.ctxt != self.mir.span.ctxt {\n+                if let Some(info) = span.ctxt.outer().expn_info() {\n+                    span = info.call_site;\n                 } else {\n                     break;\n                 }"}, {"sha": "b95e01f4ff6009a5154292d5121b9e0da93edde2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -4161,12 +4161,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if let Some(last_stmt) = extra_semi {\n-                    let original_span = original_sp(self.tcx.sess.codemap(),\n-                                                    last_stmt.span, blk.span);\n+                    let original_span = original_sp(last_stmt.span, blk.span);\n                     let span_semi = Span {\n                         lo: original_span.hi - BytePos(1),\n                         hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n+                        ctxt: original_span.ctxt,\n                     };\n                     err.span_help(span_semi, \"consider removing this semicolon:\");\n                 }"}, {"sha": "a4bebd311ded2ac1088417725b0fd0b0d83a5b2f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 53, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -14,10 +14,10 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n-pub use symbol::Symbol as Name;\n+pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n \n-use syntax_pos::{mk_sp, BytePos, Span, DUMMY_SP, ExpnId};\n+use syntax_pos::{mk_sp, BytePos, Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::{Mark, SyntaxContext};\n@@ -27,61 +27,12 @@ use rustc_data_structures::indexed_vec;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n+use serialize::{self, Encoder, Decoder};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n-use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n-\n-/// An identifier contains a Name (index into the interner\n-/// table) and a SyntaxContext to track renaming and\n-/// macro expansion per Flatt et al., \"Macros That Work Together\"\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    pub name: Symbol,\n-    pub ctxt: SyntaxContext\n-}\n-\n-impl Ident {\n-    pub const fn with_empty_ctxt(name: Name) -> Ident {\n-        Ident { name: name, ctxt: SyntaxContext::empty() }\n-    }\n-\n-    /// Maps a string to an identifier with an empty syntax context.\n-    pub fn from_str(s: &str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::intern(s))\n-    }\n-\n-    pub fn unhygienize(&self) -> Ident {\n-        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{:?}\", self.name, self.ctxt)\n-    }\n-}\n-\n-impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.name, f)\n-    }\n-}\n-\n-impl Encodable for Ident {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)\n-    }\n-}\n-\n-impl Decodable for Ident {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::with_empty_ctxt(Name::decode(d)?))\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -1445,7 +1396,7 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub expn_id: ExpnId,\n+    pub ctxt: SyntaxContext,\n }\n \n /// An argument in a function header."}, {"sha": "ba199eacb6276e63997b0714b5f7744edeb229a8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 277, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -17,6 +17,8 @@\n //! within the CodeMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n+pub use syntax_pos::*;\n+pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n use std::cell::RefCell;\n@@ -26,35 +28,21 @@ use std::rc::Rc;\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n-pub use syntax_pos::*;\n use errors::CodeMapper;\n \n-use ast::Name;\n-\n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n-pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = cm.with_expn_info(sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n-    let call_site2 = cm.with_expn_info(enclosing_sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n+    let call_site1 = sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n+    let call_site2 = enclosing_sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n     match (call_site1, call_site2) {\n         (None, _) => sp,\n         (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n-        (Some(call_site1), _) => original_sp(cm, call_site1, enclosing_sp),\n+        (Some(call_site1), _) => original_sp(call_site1, enclosing_sp),\n     }\n }\n \n-/// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n-pub enum ExpnFormat {\n-    /// e.g. #[derive(...)] <item>\n-    MacroAttribute(Name),\n-    /// e.g. `format!()`\n-    MacroBang(Name),\n-    /// Desugaring done by the compiler during HIR lowering.\n-    CompilerDesugaring(Name)\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n@@ -73,47 +61,6 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n     respan(DUMMY_SP, t)\n }\n \n-#[derive(Clone, Hash, Debug)]\n-pub struct NameAndSpan {\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n-    /// Whether the macro is allowed to use #[unstable]/feature-gated\n-    /// features internally without forcing the whole crate to opt-in\n-    /// to them.\n-    pub allow_internal_unstable: bool,\n-    /// The span of the macro definition itself. The macro may not\n-    /// have a sensible definition span (e.g. something defined\n-    /// completely inside libsyntax) in which case this is None.\n-    pub span: Option<Span>\n-}\n-\n-impl NameAndSpan {\n-    pub fn name(&self) -> Name {\n-        match self.format {\n-            ExpnFormat::MacroAttribute(s) |\n-            ExpnFormat::MacroBang(s) |\n-            ExpnFormat::CompilerDesugaring(s) => s,\n-        }\n-    }\n-}\n-\n-/// Extra information for tracking spans of macro and syntax sugar expansion\n-#[derive(Hash, Debug)]\n-pub struct ExpnInfo {\n-    /// The location of the actual macro invocation or syntax sugar , e.g.\n-    /// `let x = foo!();` or `if let Some(y) = x {}`\n-    ///\n-    /// This may recursively refer to other macro invocations, e.g. if\n-    /// `foo!()` invoked `bar!()` internally, and there was an\n-    /// expression inside `bar!`; the call_site of the expression in\n-    /// the expansion would point to the `bar!` invocation; that\n-    /// call_site span would have its own ExpnInfo, with the call_site\n-    /// pointing to the `foo!` invocation.\n-    pub call_site: Span,\n-    /// Information about the expansion.\n-    pub callee: NameAndSpan\n-}\n-\n // _____________________________________________________________________________\n // FileMap, MultiByteChar, FileName, FileLines\n //\n@@ -161,23 +108,20 @@ impl FileLoader for RealFileLoader {\n \n pub struct CodeMap {\n     pub files: RefCell<Vec<Rc<FileMap>>>,\n-    expansions: RefCell<Vec<ExpnInfo>>,\n     file_loader: Box<FileLoader>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            expansions: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader)\n         }\n     }\n \n     pub fn with_file_loader(file_loader: Box<FileLoader>) -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            expansions: RefCell::new(Vec::new()),\n             file_loader: file_loader\n         }\n     }\n@@ -353,14 +297,14 @@ impl CodeMap {\n     /// Returns `Some(span)`, a union of the lhs and rhs span.  The lhs must precede the rhs. If\n     /// there are gaps between lhs and rhs, the resulting union will cross these gaps.\n     /// For this to work, the spans have to be:\n-    ///    * the expn_id of both spans much match\n+    ///    * the ctxt of both spans much match\n     ///    * the lhs span needs to end on the same line the rhs span begins\n     ///    * the lhs span must start at or before the rhs span\n     pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n         use std::cmp;\n \n         // make sure we're at the same expansion id\n-        if sp_lhs.expn_id != sp_rhs.expn_id {\n+        if sp_lhs.ctxt != sp_rhs.ctxt {\n             return None;\n         }\n \n@@ -383,18 +327,14 @@ impl CodeMap {\n             Some(Span {\n                 lo: cmp::min(sp_lhs.lo, sp_rhs.lo),\n                 hi: cmp::max(sp_lhs.hi, sp_rhs.hi),\n-                expn_id: sp_lhs.expn_id,\n+                ctxt: sp_lhs.ctxt,\n             })\n         } else {\n             None\n         }\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if sp == COMMAND_LINE_SP {\n-            return \"<command line option>\".to_string();\n-        }\n-\n         if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n@@ -409,62 +349,6 @@ impl CodeMap {\n                         hi.col.to_usize() + 1)).to_string()\n     }\n \n-    /// Return the source span - this is either the supplied span, or the span for\n-    /// the macro callsite that expanded to it.\n-    pub fn source_callsite(&self, sp: Span) -> Span {\n-        let mut span = sp;\n-        // Special case - if a macro is parsed as an argument to another macro, the source\n-        // callsite is the first callsite, which is also source-equivalent to the span.\n-        let mut first = true;\n-        while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n-            if let Some(callsite) = self.with_expn_info(span.expn_id,\n-                                               |ei| ei.map(|ei| ei.call_site.clone())) {\n-                if first && span.source_equal(&callsite) {\n-                    if self.lookup_char_pos(span.lo).file.is_real_file() {\n-                        return Span { expn_id: NO_EXPANSION, .. span };\n-                    }\n-                }\n-                first = false;\n-                span = callsite;\n-            }\n-            else {\n-                break;\n-            }\n-        }\n-        span\n-    }\n-\n-    /// Return the source callee.\n-    ///\n-    /// Returns None if the supplied span has no expansion trace,\n-    /// else returns the NameAndSpan for the macro definition\n-    /// corresponding to the source callsite.\n-    pub fn source_callee(&self, sp: Span) -> Option<NameAndSpan> {\n-        let mut span = sp;\n-        // Special case - if a macro is parsed as an argument to another macro, the source\n-        // callsite is source-equivalent to the span, and the source callee is the first callee.\n-        let mut first = true;\n-        while let Some(callsite) = self.with_expn_info(span.expn_id,\n-                                            |ei| ei.map(|ei| ei.call_site.clone())) {\n-            if first && span.source_equal(&callsite) {\n-                if self.lookup_char_pos(span.lo).file.is_real_file() {\n-                    return self.with_expn_info(span.expn_id,\n-                                               |ei| ei.map(|ei| ei.callee.clone()));\n-                }\n-            }\n-            first = false;\n-            if let Some(_) = self.with_expn_info(callsite.expn_id,\n-                                                 |ei| ei.map(|ei| ei.call_site.clone())) {\n-                span = callsite;\n-            }\n-            else {\n-                return self.with_expn_info(span.expn_id,\n-                                           |ei| ei.map(|ei| ei.callee.clone()));\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n@@ -628,111 +512,9 @@ impl CodeMap {\n         return a;\n     }\n \n-    pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n-        let mut expansions = self.expansions.borrow_mut();\n-        expansions.push(expn_info);\n-        let len = expansions.len();\n-        if len > u32::max_value() as usize {\n-            panic!(\"too many ExpnInfo's!\");\n-        }\n-        ExpnId(len as u32 - 1)\n-    }\n-\n-    pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where\n-        F: FnOnce(Option<&ExpnInfo>) -> T,\n-    {\n-        match id {\n-            NO_EXPANSION | COMMAND_LINE_EXPN => f(None),\n-            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as usize]))\n-        }\n-    }\n-\n-    /// Check if a span is \"internal\" to a macro in which #[unstable]\n-    /// items can be used (that is, a macro marked with\n-    /// `#[allow_internal_unstable]`).\n-    pub fn span_allows_unstable(&self, span: Span) -> bool {\n-        debug!(\"span_allows_unstable(span = {:?})\", span);\n-        let mut allows_unstable = false;\n-        let mut expn_id = span.expn_id;\n-        loop {\n-            let quit = self.with_expn_info(expn_id, |expninfo| {\n-                debug!(\"span_allows_unstable: expninfo = {:?}\", expninfo);\n-                expninfo.map_or(/* hit the top level */ true, |info| {\n-\n-                    let span_comes_from_this_expansion =\n-                        info.callee.span.map_or(span.source_equal(&info.call_site), |mac_span| {\n-                            mac_span.contains(span)\n-                        });\n-\n-                    debug!(\"span_allows_unstable: span: {:?} call_site: {:?} callee: {:?}\",\n-                           (span.lo, span.hi),\n-                           (info.call_site.lo, info.call_site.hi),\n-                           info.callee.span.map(|x| (x.lo, x.hi)));\n-                    debug!(\"span_allows_unstable: from this expansion? {}, allows unstable? {}\",\n-                           span_comes_from_this_expansion,\n-                           info.callee.allow_internal_unstable);\n-                    if span_comes_from_this_expansion {\n-                        allows_unstable = info.callee.allow_internal_unstable;\n-                        // we've found the right place, stop looking\n-                        true\n-                    } else {\n-                        // not the right place, keep looking\n-                        expn_id = info.call_site.expn_id;\n-                        false\n-                    }\n-                })\n-            });\n-            if quit {\n-                break\n-            }\n-        }\n-        debug!(\"span_allows_unstable? {}\", allows_unstable);\n-        allows_unstable\n-    }\n-\n     pub fn count_lines(&self) -> usize {\n         self.files.borrow().iter().fold(0, |a, f| a + f.count_lines())\n     }\n-\n-    pub fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n-        let mut prev_span = DUMMY_SP;\n-        let mut span = span;\n-        let mut result = vec![];\n-        loop {\n-            let span_name_span = self.with_expn_info(span.expn_id, |expn_info| {\n-                expn_info.map(|ei| {\n-                    let (pre, post) = match ei.callee.format {\n-                        MacroAttribute(..) => (\"#[\", \"]\"),\n-                        MacroBang(..) => (\"\", \"!\"),\n-                        CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n-                    };\n-                    let macro_decl_name = format!(\"{}{}{}\",\n-                                                  pre,\n-                                                  ei.callee.name(),\n-                                                  post);\n-                    let def_site_span = ei.callee.span;\n-                    (ei.call_site, macro_decl_name, def_site_span)\n-                })\n-            });\n-\n-            match span_name_span {\n-                None => break,\n-                Some((call_site, macro_decl_name, def_site_span)) => {\n-                    // Don't print recursive invocations\n-                    if !call_site.source_equal(&prev_span) {\n-                        result.push(MacroBacktrace {\n-                            call_site: call_site,\n-                            macro_decl_name: macro_decl_name,\n-                            def_site_span: def_site_span,\n-                        });\n-                    }\n-                    prev_span = span;\n-                    span = call_site;\n-                }\n-            }\n-        }\n-        result\n-    }\n }\n \n impl CodeMapper for CodeMap {\n@@ -748,9 +530,6 @@ impl CodeMapper for CodeMap {\n     fn span_to_filename(&self, sp: Span) -> FileName {\n         self.span_to_filename(sp)\n     }\n-    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n-        self.macro_backtrace(span)\n-    }\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n         self.merge_spans(sp_lhs, sp_rhs)\n     }\n@@ -763,7 +542,6 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use symbol::keywords;\n     use std::rc::Rc;\n \n     #[test]\n@@ -912,7 +690,7 @@ mod tests {\n     fn t7() {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n@@ -928,7 +706,7 @@ mod tests {\n         assert_eq!(input.len(), selection.len());\n         let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), ctxt: NO_EXPANSION }\n     }\n \n     /// Test span_to_snippet and span_to_lines for a span coverting 3\n@@ -958,7 +736,7 @@ mod tests {\n     fn t8() {\n         // Test span_to_snippet for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n         assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -968,7 +746,7 @@ mod tests {\n     fn t9() {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -1022,7 +800,7 @@ mod tests {\n                     let span = Span {\n                         lo: BytePos(lo as u32 + file.start_pos.0),\n                         hi: BytePos(hi as u32 + file.start_pos.0),\n-                        expn_id: NO_EXPANSION,\n+                        ctxt: NO_EXPANSION,\n                     };\n                     assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                             substring);\n@@ -1032,45 +810,4 @@ mod tests {\n             }\n         }\n     }\n-\n-    fn init_expansion_chain(cm: &CodeMap) -> Span {\n-        // Creates an expansion chain containing two recursive calls\n-        // root -> expA -> expA -> expB -> expB -> end\n-        let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-\n-        let format_root = ExpnFormat::MacroBang(keywords::Invalid.name());\n-        let callee_root = NameAndSpan { format: format_root,\n-                                        allow_internal_unstable: false,\n-                                        span: Some(root) };\n-\n-        let info_a1 = ExpnInfo { call_site: root, callee: callee_root };\n-        let id_a1 = cm.record_expansion(info_a1);\n-        let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n-\n-        let format_a = ExpnFormat::MacroBang(keywords::As.name());\n-        let callee_a = NameAndSpan { format: format_a,\n-                                      allow_internal_unstable: false,\n-                                      span: Some(span_a1) };\n-\n-        let info_a2 = ExpnInfo { call_site: span_a1, callee: callee_a.clone() };\n-        let id_a2 = cm.record_expansion(info_a2);\n-        let span_a2 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a2 };\n-\n-        let info_b1 = ExpnInfo { call_site: span_a2, callee: callee_a };\n-        let id_b1 = cm.record_expansion(info_b1);\n-        let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n-\n-        let format_b = ExpnFormat::MacroBang(keywords::Box.name());\n-        let callee_b = NameAndSpan { format: format_b,\n-                                     allow_internal_unstable: false,\n-                                     span: None };\n-\n-        let info_b2 = ExpnInfo { call_site: span_b1, callee: callee_b.clone() };\n-        let id_b2 = cm.record_expansion(info_b2);\n-        let span_b2 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b2 };\n-\n-        let info_end = ExpnInfo { call_site: span_b2, callee: callee_b };\n-        let id_end = cm.record_expansion(info_end);\n-        Span { lo: BytePos(37), hi: BytePos(48), expn_id: id_end }\n-    }\n }"}, {"sha": "a2d54b62ec65d665ced22341ac5326e12d736b38", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -12,11 +12,11 @@ pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT\n \n use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n-use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n-use errors::{DiagnosticBuilder, FatalError};\n+use codemap::{self, CodeMap, Spanned, respan};\n+use syntax_pos::{Span, DUMMY_SP};\n+use errors::DiagnosticBuilder;\n use ext::expand::{self, Expansion, Invocation};\n-use ext::hygiene::Mark;\n+use ext::hygiene::{Mark, SyntaxContext};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n@@ -56,6 +56,14 @@ impl HasAttrs for Annotatable {\n }\n \n impl Annotatable {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            Annotatable::Item(ref item) => item.span,\n+            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n+            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -602,7 +610,6 @@ pub struct ModuleData {\n pub struct ExpansionData {\n     pub mark: Mark,\n     pub depth: usize,\n-    pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n     pub directory_ownership: DirectoryOwnership,\n }\n@@ -633,7 +640,6 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 mark: Mark::root(),\n                 depth: 0,\n-                backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned,\n             },\n@@ -658,59 +664,37 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n+        match self.current_expansion.mark.expn_info() {\n             Some(expn_info) => expn_info.call_site,\n-            None => self.bug(\"missing top span\")\n-        })\n+            None => DUMMY_SP,\n+        }\n+    }\n+    pub fn backtrace(&self) -> SyntaxContext {\n+        SyntaxContext::empty().apply_mark(self.current_expansion.mark)\n     }\n-    pub fn backtrace(&self) -> ExpnId { self.current_expansion.backtrace }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Span {\n-        let mut expn_id = self.backtrace();\n+        let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if self.codemap().with_expn_info(expn_id, |info| {\n-                info.map_or(None, |i| {\n-                    if i.callee.name() == \"include\" {\n-                        // Stop going up the backtrace once include! is encountered\n-                        return None;\n-                    }\n-                    expn_id = i.call_site.expn_id;\n-                    last_macro = Some(i.call_site);\n-                    return Some(());\n-                })\n+            if ctxt.outer().expn_info().map_or(None, |info| {\n+                if info.callee.name() == \"include\" {\n+                    // Stop going up the backtrace once include! is encountered\n+                    return None;\n+                }\n+                ctxt = info.call_site.ctxt;\n+                last_macro = Some(info.call_site);\n+                return Some(());\n             }).is_none() {\n                 break\n             }\n         }\n         last_macro.expect(\"missing expansion backtrace\")\n     }\n \n-    pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        if self.current_expansion.depth > self.ecfg.recursion_limit {\n-            let suggested_limit = self.ecfg.recursion_limit * 2;\n-            let mut err = self.struct_span_fatal(ei.call_site,\n-                &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         ei.callee.name()));\n-            err.help(&format!(\n-                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                suggested_limit));\n-            err.emit();\n-            panic!(FatalError);\n-        }\n-\n-        let mut call_site = ei.call_site;\n-        call_site.expn_id = self.backtrace();\n-        self.current_expansion.backtrace = self.codemap().record_expansion(ExpnInfo {\n-            call_site: call_site,\n-            callee: ei.callee\n-        });\n-    }\n-    pub fn bt_pop(&mut self) {}\n-\n     pub fn struct_span_warn(&self,\n                             sp: Span,\n                             msg: &str)\n@@ -792,9 +776,9 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n                               -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n-    // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n+    // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.expn_id = cx.backtrace();\n+        expr.span.ctxt = expr.span.ctxt.apply_mark(cx.current_expansion.mark);\n         expr\n     });\n "}, {"sha": "c79040424f619e0c4c8a745f3fae66138d235408", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use attr::HasAttrs;\n-use {ast, codemap};\n+use ast;\n+use codemap::{ExpnInfo, NameAndSpan, ExpnFormat};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use parse::parser::PathStyle;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n+use std::collections::HashSet;\n+\n pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n@@ -41,36 +44,35 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n     result\n }\n \n-fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n-    Span {\n-        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: span,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n-                span: Some(span),\n-                allow_internal_unstable: true,\n-            },\n-        }),\n-        ..span\n+pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: T) -> T\n+    where T: HasAttrs,\n+{\n+    let (mut names, mut pretty_name) = (HashSet::new(), \"derive(\".to_owned());\n+    for (i, path) in traits.iter().enumerate() {\n+        if i > 0 {\n+            pretty_name.push_str(\", \");\n+        }\n+        pretty_name.push_str(&path.to_string());\n+        names.insert(unwrap_or!(path.segments.get(0), continue).identifier.name);\n     }\n-}\n+    pretty_name.push(')');\n \n-pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[ast::Path], item: T) -> T {\n-    let span = match traits.get(0) {\n-        Some(path) => path.span,\n-        None => return item,\n-    };\n+    cx.current_expansion.mark.set_expn_info(ExpnInfo {\n+        call_site: span,\n+        callee: NameAndSpan {\n+            format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n+            span: None,\n+            allow_internal_unstable: true,\n+        },\n+    });\n \n+    let span = Span { ctxt: cx.backtrace(), ..span };\n     item.map_attrs(|mut attrs| {\n-        if traits.iter().any(|path| *path == \"PartialEq\") &&\n-           traits.iter().any(|path| *path == \"Eq\") {\n-            let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        if names.contains(&Symbol::intern(\"Eq\")) && names.contains(&Symbol::intern(\"PartialEq\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n             attrs.push(cx.attribute(span, meta));\n         }\n-        if traits.iter().any(|path| *path == \"Copy\") &&\n-           traits.iter().any(|path| *path == \"Clone\") {\n-            let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        if names.contains(&Symbol::intern(\"Copy\")) && names.contains(&Symbol::intern(\"Clone\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n             attrs.push(cx.attribute(span, meta));\n         }"}, {"sha": "1b3352f73ade794e9ee9da45730a72f5df9475b8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 46, "deletions": 65, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -13,6 +13,7 @@ use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use config::{is_test_or_bench, StripUnconfigured};\n+use errors::FatalError;\n use ext::base::*;\n use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::Mark;\n@@ -27,7 +28,7 @@ use ptr::P;\n use std_inject;\n use symbol::Symbol;\n use symbol::keywords;\n-use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::TokenStream;\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -273,7 +274,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let item = item\n                         .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n                     let item_with_markers =\n-                        add_derived_markers(&mut self.cx, &traits, item.clone());\n+                        add_derived_markers(&mut self.cx, item.span(), &traits, item.clone());\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n                     for path in &traits {\n@@ -363,11 +364,26 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n-        match invoc.kind {\n+        let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n             InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n+        };\n+\n+        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n+            let info = self.cx.current_expansion.mark.expn_info().unwrap();\n+            let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n+            let mut err = self.cx.struct_span_fatal(info.call_site,\n+                &format!(\"recursion limit reached while expanding the macro `{}`\",\n+                         info.callee.name()));\n+            err.help(&format!(\n+                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                suggested_limit));\n+            err.emit();\n+            panic!(FatalError);\n         }\n+\n+        result\n     }\n \n     fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n@@ -378,11 +394,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        self.cx.bt_push(ExpnInfo {\n+        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n-                span: Some(attr.span),\n+                span: None,\n                 allow_internal_unstable: false,\n             }\n         });\n@@ -403,19 +419,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n                 let item_toks = stream_for_item(&item, &self.cx.parse_sess);\n \n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n-                            span: None,\n-                            allow_internal_unstable: false,\n-                        },\n-                    }),\n-                    ..attr.span\n-                };\n-\n-                let tok_result = mac.expand(self.cx, attr.span, attr.tokens.clone(), item_toks);\n+                let span = Span { ctxt: self.cx.backtrace(), ..attr.span };\n+                let tok_result = mac.expand(self.cx, attr.span, attr.tokens, item_toks);\n                 self.parse_expansion(tok_result, kind, &attr.path, span)\n             }\n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n@@ -440,8 +445,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n-        let marked_tts =\n-            noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n+        let marked_tts = noop_fold_tts(mac.node.stream(), &mut Marker(mark));\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -451,7 +455,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 }\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -470,7 +474,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 };\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -502,7 +506,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 }\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -528,10 +532,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return kind.dummy(span);\n         };\n \n-        expanded.fold_with(&mut Marker {\n-            mark: mark,\n-            expn_id: Some(self.cx.backtrace()),\n-        })\n+        expanded.fold_with(&mut Marker(mark))\n     }\n \n     /// Expand a derive invocation. Returns the result of expansion.\n@@ -550,50 +551,33 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n         };\n \n-        self.cx.bt_push(ExpnInfo {\n+        let mut expn_info = ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(pretty_name),\n                 span: None,\n                 allow_internal_unstable: false,\n             }\n-        });\n+        };\n \n         match *ext {\n             SyntaxExtension::ProcMacroDerive(ref ext, _) => {\n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(pretty_name),\n-                            span: None,\n-                            allow_internal_unstable: false,\n-                        },\n-                    }),\n-                    ..span\n-                };\n+                invoc.expansion_data.mark.set_expn_info(expn_info);\n+                let span = Span { ctxt: self.cx.backtrace(), ..span };\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n                     name: keywords::Invalid.name(),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n-                return kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item));\n+                kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item))\n             }\n             SyntaxExtension::BuiltinDerive(func) => {\n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(pretty_name),\n-                            span: None,\n-                            allow_internal_unstable: true,\n-                        },\n-                    }),\n-                    ..span\n-                };\n+                expn_info.callee.allow_internal_unstable = true;\n+                invoc.expansion_data.mark.set_expn_info(expn_info);\n+                let span = Span { ctxt: self.cx.backtrace(), ..span };\n                 let mut items = Vec::new();\n                 func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n-                return kind.expect_from_annotatables(items);\n+                kind.expect_from_annotatables(items)\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n@@ -753,10 +737,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n-        let codemap = &self.cx.parse_sess.codemap();\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess, codemap, features);\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess, features);\n         }\n     }\n }\n@@ -1065,23 +1048,21 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-// A Marker adds the given mark to the syntax context and\n-// sets spans' `expn_id` to the given expn_id (unless it is `None`).\n-struct Marker { mark: Mark, expn_id: Option<ExpnId> }\n+// A Marker adds the given mark to the syntax context.\n+struct Marker(Mark);\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n-        ident.ctxt = ident.ctxt.apply_mark(self.mark);\n+        ident.ctxt = ident.ctxt.apply_mark(self.0);\n         ident\n     }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        noop_fold_mac(mac, self)\n-    }\n \n     fn new_span(&mut self, mut span: Span) -> Span {\n-        if let Some(expn_id) = self.expn_id {\n-            span.expn_id = expn_id;\n-        }\n+        span.ctxt = span.ctxt.apply_mark(self.0);\n         span\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        noop_fold_mac(mac, self)\n+    }\n }"}, {"sha": "0103d6ea959dd84dd93606d8a0d9203cab1dbaa8", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -185,7 +185,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let callsite = cx.codemap().source_callsite(sp);\n+        let callsite = sp.source_callsite();\n         let mut cu = PathBuf::from(&cx.codemap().span_to_filename(callsite));\n         cu.pop();\n         cu.push(arg);"}, {"sha": "12e746e024d3b22cd41106884beed81b19ef6a25", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -34,17 +34,19 @@ impl Delimited {\n     }\n \n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span },\n+        let open_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n \n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span },\n+        let close_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }"}, {"sha": "12d25ca4274fea1fe09ef93cbcd49784b407b4ec", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -28,7 +28,7 @@ use self::AttributeGate::*;\n use abi::Abi;\n use ast::{self, NodeId, PatKind, RangeEnd};\n use attr;\n-use codemap::{CodeMap, Spanned};\n+use codemap::Spanned;\n use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n@@ -831,7 +831,7 @@ impl GatedCfg {\n \n     pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) && !sess.codemap().span_allows_unstable(self.span) {\n+        if !has_feature(features) && !self.span.allows_unstable() {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n             emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n         }\n@@ -841,7 +841,6 @@ impl GatedCfg {\n struct Context<'a> {\n     features: &'a Features,\n     parse_sess: &'a ParseSess,\n-    cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n \n@@ -850,7 +849,7 @@ macro_rules! gate_feature_fn {\n         let (cx, has_feature, span, name, explain) = ($cx, $has_feature, $span, $name, $explain);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n-        if !has_feature && !cx.cm.span_allows_unstable(span) {\n+        if !has_feature && !span.allows_unstable() {\n             emit_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain);\n         }\n     }}\n@@ -908,12 +907,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess,\n-                       cm: &CodeMap, features: &Features) {\n-    let cx = Context {\n-        features: features, parse_sess: parse_sess,\n-        cm: cm, plugin_attributes: &[]\n-    };\n+pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n+    let cx = Context { features: features, parse_sess: parse_sess, plugin_attributes: &[] };\n     cx.check_attribute(attr, true);\n }\n \n@@ -1016,7 +1011,7 @@ struct PostExpansionVisitor<'a> {\n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !cx.context.cm.span_allows_unstable(span) {\n+        if !span.allows_unstable() {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n     }}\n@@ -1096,7 +1091,7 @@ fn starts_with_digit(s: &str) -> bool {\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if !self.context.cm.span_allows_unstable(attr.span) {\n+        if !attr.span.allows_unstable() {\n             // check for gated attributes\n             self.context.check_attribute(attr, false);\n         }\n@@ -1530,7 +1525,6 @@ pub fn check_crate(krate: &ast::Crate,\n     let ctx = Context {\n         features: features,\n         parse_sess: sess,\n-        cm: sess.codemap(),\n         plugin_attributes: plugin_attributes,\n     };\n     visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);"}, {"sha": "dec1b7d1d87be4bf09bcec60d3981061682ff962", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -202,7 +202,7 @@ impl DiagnosticSpan {\n         // backtrace ourselves, but the `macro_backtrace` helper makes\n         // some decision, such as dropping some frames, and I don't\n         // want to duplicate that logic here.\n-        let backtrace = je.cm.macro_backtrace(span).into_iter();\n+        let backtrace = span.macro_backtrace().into_iter();\n         DiagnosticSpan::from_span_full(span,\n                                        is_primary,\n                                        label,"}, {"sha": "86ee1c5336dfeb3f6a46038d524ac92c14cdd4e6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -125,7 +125,7 @@ pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n pub mod str;\n-pub mod symbol;\n+pub use syntax_pos::symbol;\n pub mod test;\n pub mod tokenstream;\n pub mod visit;"}, {"sha": "e9eb4fbcc9162697284c2c67f91919993508b40d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -5036,11 +5036,7 @@ impl<'a> Parser<'a> {\n                                        the path:\",\n                                        path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let sp = Span {\n-                    lo: start_span.lo,\n-                    hi: self.prev_span.hi,\n-                    expn_id: start_span.expn_id,\n-                };\n+                let sp = start_span.to(self.prev_span);\n                 let mut err = self.span_fatal_help(sp, &msg, &suggestion);\n                 err.span_suggestion(path_span, &help_msg, format!(\"in {}\", path));\n                 err.emit();  // emit diagnostic, but continue with public visibility"}, {"sha": "c7820a15fb3d23d9f8c0a6fb41c59e2e2af45012", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -10,29 +10,27 @@\n \n use ast;\n use attr;\n+use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::ParseSess;\n use ptr::P;\n use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n-fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n-    let info = ExpnInfo {\n+fn ignored_span(sp: Span) -> Span {\n+    let mark = Mark::fresh();\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n-    };\n-    let expn_id = sess.codemap().record_expansion(info);\n-    let mut sp = sp;\n-    sp.expn_id = expn_id;\n-    return sp;\n+    });\n+    Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..sp }\n }\n \n pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n@@ -45,10 +43,7 @@ pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n     }\n }\n \n-pub fn maybe_inject_crates_ref(sess: &ParseSess,\n-                               mut krate: ast::Crate,\n-                               alt_std_name: Option<String>)\n-                               -> ast::Crate {\n+pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<String>) -> ast::Crate {\n     let name = match injected_crate_name(&krate) {\n         Some(name) => name,\n         None => return krate,\n@@ -67,7 +62,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         span: DUMMY_SP,\n     }));\n \n-    let span = ignored_span(sess, DUMMY_SP);\n+    let span = ignored_span(DUMMY_SP);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,"}, {"sha": "50380626d7f0d484fc169440404d443be1087be9", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -31,6 +31,7 @@ use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, Resolver};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n+use ext::hygiene::{Mark, SyntaxContext};\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n@@ -62,6 +63,7 @@ struct TestCtxt<'a> {\n     testfns: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_test_crate: bool,\n+    ctxt: SyntaxContext,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -275,6 +277,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n+    let mark = Mark::fresh();\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n@@ -284,15 +287,16 @@ fn generate_test_harness(sess: &ParseSess,\n         reexport_test_harness_main: reexport_test_harness_main,\n         is_test_crate: is_test_crate(&krate),\n         toplevel_reexport: None,\n+        ctxt: SyntaxContext::empty().apply_mark(mark),\n     };\n     cx.ext_cx.crate_root = Some(\"std\");\n \n-    cx.ext_cx.bt_push(ExpnInfo {\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: true,\n         }\n     });\n \n@@ -307,18 +311,7 @@ fn generate_test_harness(sess: &ParseSess,\n /// call to codemap's is_internal check.\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n-    let info = ExpnInfo {\n-        call_site: sp,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(Symbol::intern(\"test\")),\n-            span: None,\n-            allow_internal_unstable: true,\n-        }\n-    };\n-    let expn_id = cx.sess.codemap().record_expansion(info);\n-    let mut sp = sp;\n-    sp.expn_id = expn_id;\n-    return sp;\n+    Span { ctxt: cx.ctxt, ..sp }\n }\n \n #[derive(PartialEq)]"}, {"sha": "c537a0ee16644d7e241a9a157488a46c9f47e613", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -83,7 +83,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     Span {\n         lo: BytePos(start as u32),\n         hi: BytePos(end as u32),\n-        expn_id: NO_EXPANSION,\n+        ctxt: NO_EXPANSION,\n     }\n }\n "}, {"sha": "86bfdebe42b0082e206b6a836b66916ce4061846", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -56,18 +56,20 @@ impl Delimited {\n \n     /// Returns the opening delimiter as a token tree.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span },\n+        let open_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n \n     /// Returns the closing delimiter as a token tree.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span },\n+        let close_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }\n@@ -425,7 +427,7 @@ mod tests {\n         Span {\n             lo: BytePos(a),\n             hi: BytePos(b),\n-            expn_id: NO_EXPANSION,\n+            ctxt: NO_EXPANSION,\n         }\n     }\n "}, {"sha": "923e8072f43462ba10ab69acd40f2c935948d877", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -13,7 +13,6 @@\n use self::State::*;\n \n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n@@ -240,15 +239,6 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         }\n     }\n \n-    let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-        call_site: sp,\n-        callee: codemap::NameAndSpan {\n-            format: codemap::MacroBang(Symbol::intern(\"asm\")),\n-            span: None,\n-            allow_internal_unstable: false,\n-        },\n-    });\n-\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n@@ -260,7 +250,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n             volatile: volatile,\n             alignstack: alignstack,\n             dialect: dialect,\n-            expn_id: expn_id,\n+            ctxt: cx.backtrace(),\n         })),\n         span: sp,\n         attrs: ast::ThinVec::new(),"}, {"sha": "1993d6ebe5b493fc778e74c0455301da599da3b3", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -111,7 +111,7 @@ fn cs_clone_shallow(name: &str,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = super::allow_unstable(cx, span, \"derive(Clone)\");\n+        let span = Span { ctxt: cx.backtrace(), ..span};\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "eef21492debc32440790ae38cb4049a745e48ba6", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -58,7 +58,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = super::allow_unstable(cx, span, \"derive(Eq)\");\n+        let span = Span { ctxt: cx.backtrace(), ..span };\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"cmp\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "ec4cb815960d1b6b35ca03f4eec966b90e384819", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -66,8 +66,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n     };\n \n-    // We want to make sure we have the expn_id set so that we can use unstable methods\n-    let span = Span { expn_id: cx.backtrace(), ..span };\n+    // We want to make sure we have the ctxt set so that we can use unstable methods\n+    let span = Span { ctxt: cx.backtrace(), ..span };\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());"}, {"sha": "1ff0fec1c96a6c70959d6bddf2b75942cb00718f", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -375,7 +375,7 @@ fn find_type_parameters(ty: &ast::Ty,\n         }\n \n         fn visit_mac(&mut self, mac: &ast::Mac) {\n-            let span = Span { expn_id: self.span.expn_id, ..mac.span };\n+            let span = Span { ctxt: self.span.ctxt, ..mac.span };\n             self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n         }\n     }\n@@ -1458,7 +1458,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let ident = v.node.name;\n-                let sp = Span { expn_id: trait_.span.expn_id, ..v.span };\n+                let sp = Span { ctxt: trait_.span.ctxt, ..v.span };\n                 let summary = trait_.summarise_struct(cx, &v.node.data);\n                 (ident, sp, summary)\n             })\n@@ -1478,7 +1478,7 @@ impl<'a> TraitDef<'a> {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n         for field in struct_def.fields() {\n-            let sp = Span { expn_id: self.span.expn_id, ..field.span };\n+            let sp = Span { ctxt: self.span.ctxt, ..field.span };\n             match field.ident {\n                 Some(ident) => named_idents.push((ident, sp)),\n                 _ => just_spans.push(sp),\n@@ -1523,7 +1523,7 @@ impl<'a> TraitDef<'a> {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = Span { expn_id: self.span.expn_id, ..struct_field.span };\n+            let sp = Span { ctxt: self.span.ctxt, ..struct_field.span };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned {\n                 span: sp,\n@@ -1544,7 +1544,7 @@ impl<'a> TraitDef<'a> {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n                         codemap::Spanned {\n-                            span: Span { expn_id: self.span.expn_id, ..pat.span },\n+                            span: Span { ctxt: self.span.ctxt, ..pat.span },\n                             node: ast::FieldPat {\n                                 ident: ident.unwrap(),\n                                 pat: pat,\n@@ -1576,7 +1576,7 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n-        let sp = Span { expn_id: self.span.expn_id, ..variant.span };\n+        let sp = Span { ctxt: self.span.ctxt, ..variant.span };\n         let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }"}, {"sha": "b2bb43e41ed9ee0763c67208736cf36e558ee556", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -12,9 +12,9 @@\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -74,20 +74,6 @@ pub mod ord;\n \n pub mod generic;\n \n-fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n-    Span {\n-        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: span,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n-                span: Some(span),\n-                allow_internal_unstable: true,\n-            },\n-        }),\n-        ..span\n-    }\n-}\n-\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -177,15 +163,15 @@ fn call_intrinsic(cx: &ExtCtxt,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-        call_site: span,\n-        callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(Symbol::intern(\"derive\")),\n-            span: Some(span),\n-            allow_internal_unstable: true,\n-        },\n-    });\n-\n+    if cx.current_expansion.mark.expn_info().unwrap().callee.allow_internal_unstable {\n+        span.ctxt = cx.backtrace();\n+    } else { // Avoid instability errors with user defined curstom derives, cc #36316\n+        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n+        info.callee.allow_internal_unstable = true;\n+        let mark = Mark::fresh();\n+        mark.set_expn_info(info);\n+        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n+    }\n     let path = cx.std_path(&[\"intrinsics\", intrinsic]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "aeb5b1e0a532bbce87151096ab44fca714f41310", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -641,10 +641,11 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn format_arg(ecx: &ExtCtxt,\n                   macsp: Span,\n-                  sp: Span,\n+                  mut sp: Span,\n                   ty: &ArgumentType,\n                   arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n+        sp.ctxt = sp.ctxt.apply_mark(ecx.current_expansion.mark);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n                 match &tyname[..] {"}, {"sha": "bb89caab709b0e8831c0eee51d742c7e4c120e9a", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -17,6 +17,7 @@ use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::fold::Folder;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -360,15 +361,16 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                 custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[ProcMacroDef],\n                 custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n-    let eid = cx.codemap().record_expansion(ExpnInfo {\n+    let mark = Mark::fresh();\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n     });\n-    let span = Span { expn_id: eid, ..DUMMY_SP };\n+    let span = Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..DUMMY_SP };\n \n     let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,"}, {"sha": "8a9ff647b3ea1b9a4504aa55f3ccd4f0766a212c", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 87, "deletions": 7, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -15,12 +15,16 @@\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n+use Span;\n+use symbol::Symbol;\n+\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Default)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n #[derive(Copy, Clone)]\n@@ -36,8 +40,8 @@ pub struct Mark(u32);\n impl Mark {\n     pub fn fresh() -> Self {\n         HygieneData::with(|data| {\n-            let next_mark = Mark(data.next_mark.0 + 1);\n-            ::std::mem::replace(&mut data.next_mark, next_mark)\n+            data.marks.push(None);\n+            Mark(data.marks.len() as u32 - 1)\n         })\n     }\n \n@@ -53,23 +57,31 @@ impl Mark {\n     pub fn from_u32(raw: u32) -> Mark {\n         Mark(raw)\n     }\n+\n+    pub fn expn_info(self) -> Option<ExpnInfo> {\n+        HygieneData::with(|data| data.marks[self.0 as usize].clone())\n+    }\n+\n+    pub fn set_expn_info(self, info: ExpnInfo) {\n+        HygieneData::with(|data| data.marks[self.0 as usize] = Some(info))\n+    }\n }\n \n struct HygieneData {\n+    marks: Vec<Option<ExpnInfo>>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    next_mark: Mark,\n }\n \n impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n+            marks: vec![None],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n                 prev_ctxt: SyntaxContext::empty(),\n             }],\n             markings: HashMap::new(),\n-            next_mark: Mark(1),\n         }\n     }\n \n@@ -81,8 +93,8 @@ impl HygieneData {\n     }\n }\n \n-pub fn reset_hygiene_data() {\n-    HygieneData::with(|data| *data = HygieneData::new())\n+pub fn clear_markings() {\n+    HygieneData::with(|data| data.markings = HashMap::new());\n }\n \n impl SyntaxContext {\n@@ -113,10 +125,78 @@ impl SyntaxContext {\n             })\n         })\n     }\n+\n+    pub fn outer(self) -> Mark {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"#{}\", self.0)\n     }\n }\n+\n+/// Extra information for tracking spans of macro and syntax sugar expansion\n+#[derive(Clone, Hash, Debug)]\n+pub struct ExpnInfo {\n+    /// The location of the actual macro invocation or syntax sugar , e.g.\n+    /// `let x = foo!();` or `if let Some(y) = x {}`\n+    ///\n+    /// This may recursively refer to other macro invocations, e.g. if\n+    /// `foo!()` invoked `bar!()` internally, and there was an\n+    /// expression inside `bar!`; the call_site of the expression in\n+    /// the expansion would point to the `bar!` invocation; that\n+    /// call_site span would have its own ExpnInfo, with the call_site\n+    /// pointing to the `foo!` invocation.\n+    pub call_site: Span,\n+    /// Information about the expansion.\n+    pub callee: NameAndSpan\n+}\n+\n+#[derive(Clone, Hash, Debug)]\n+pub struct NameAndSpan {\n+    /// The format with which the macro was invoked.\n+    pub format: ExpnFormat,\n+    /// Whether the macro is allowed to use #[unstable]/feature-gated\n+    /// features internally without forcing the whole crate to opt-in\n+    /// to them.\n+    pub allow_internal_unstable: bool,\n+    /// The span of the macro definition itself. The macro may not\n+    /// have a sensible definition span (e.g. something defined\n+    /// completely inside libsyntax) in which case this is None.\n+    pub span: Option<Span>\n+}\n+\n+impl NameAndSpan {\n+    pub fn name(&self) -> Symbol {\n+        match self.format {\n+            ExpnFormat::MacroAttribute(s) |\n+            ExpnFormat::MacroBang(s) |\n+            ExpnFormat::CompilerDesugaring(s) => s,\n+        }\n+    }\n+}\n+\n+/// The source of expansion.\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+pub enum ExpnFormat {\n+    /// e.g. #[derive(...)] <item>\n+    MacroAttribute(Symbol),\n+    /// e.g. `format!()`\n+    MacroBang(Symbol),\n+    /// Desugaring done by the compiler during HIR lowering.\n+    CompilerDesugaring(Symbol)\n+}\n+\n+impl Encodable for SyntaxContext {\n+    fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n+        Ok(()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}\n+\n+impl Decodable for SyntaxContext {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<SyntaxContext, D::Error> {\n+        Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}"}, {"sha": "9b45e364ecf34451b7531f3384da50cbd2e5b646", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -25,6 +25,7 @@\n \n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -43,6 +44,9 @@ extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod hygiene;\n+pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan};\n+\n+pub mod symbol;\n \n pub type FileName = String;\n \n@@ -60,7 +64,7 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_id: ExpnId\n+    pub ctxt: SyntaxContext,\n }\n \n /// A collection of spans. Spans have two orthogonal attributes:\n@@ -79,7 +83,7 @@ impl Span {\n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(self) -> Span {\n         let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n-        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n+        Span { lo: BytePos(lo), hi: self.hi, ctxt: self.ctxt }\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n@@ -107,6 +111,69 @@ impl Span {\n             None\n         }\n     }\n+\n+    /// Return the source span - this is either the supplied span, or the span for\n+    /// the macro callsite that expanded to it.\n+    pub fn source_callsite(self) -> Span {\n+        self.ctxt.outer().expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+    }\n+\n+    /// Return the source callee.\n+    ///\n+    /// Returns None if the supplied span has no expansion trace,\n+    /// else returns the NameAndSpan for the macro definition\n+    /// corresponding to the source callsite.\n+    pub fn source_callee(self) -> Option<NameAndSpan> {\n+        fn source_callee(info: ExpnInfo) -> NameAndSpan {\n+            match info.call_site.ctxt.outer().expn_info() {\n+                Some(info) => source_callee(info),\n+                None => info.callee,\n+            }\n+        }\n+        self.ctxt.outer().expn_info().map(source_callee)\n+    }\n+\n+    /// Check if a span is \"internal\" to a macro in which #[unstable]\n+    /// items can be used (that is, a macro marked with\n+    /// `#[allow_internal_unstable]`).\n+    pub fn allows_unstable(&self) -> bool {\n+        match self.ctxt.outer().expn_info() {\n+            Some(info) => info.callee.allow_internal_unstable,\n+            None => false,\n+        }\n+    }\n+\n+    pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n+        let mut prev_span = DUMMY_SP;\n+        let mut result = vec![];\n+        loop {\n+            let info = match self.ctxt.outer().expn_info() {\n+                Some(info) => info,\n+                None => break,\n+            };\n+\n+            let (pre, post) = match info.callee.format {\n+                ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n+                ExpnFormat::MacroBang(..) => (\"\", \"!\"),\n+                ExpnFormat::CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n+            };\n+            let macro_decl_name = format!(\"{}{}{}\", pre, info.callee.name(), post);\n+            let def_site_span = info.callee.span;\n+\n+            // Don't print recursive invocations\n+            if !info.call_site.source_equal(&prev_span) {\n+                result.push(MacroBacktrace {\n+                    call_site: info.call_site,\n+                    macro_decl_name: macro_decl_name,\n+                    def_site_span: def_site_span,\n+                });\n+            }\n+\n+            prev_span = self;\n+            self = info.call_site;\n+        }\n+        result\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -147,8 +214,8 @@ impl serialize::UseSpecializedDecodable for Span {\n }\n \n fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n-    write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\",\n-           span.lo, span.hi, span.expn_id)\n+    write!(f, \"Span {{ lo: {:?}, hi: {:?}, ctxt: {:?} }}\",\n+           span.lo, span.hi, span.ctxt)\n }\n \n impl fmt::Debug for Span {\n@@ -157,12 +224,7 @@ impl fmt::Debug for Span {\n     }\n }\n \n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n-\n-// Generic span to be used for code originating from the command line\n-pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n-                                         hi: BytePos(0),\n-                                         expn_id: COMMAND_LINE_EXPN };\n+pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n \n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n@@ -256,22 +318,7 @@ impl From<Span> for MultiSpan {\n     }\n }\n \n-#[derive(PartialEq, Eq, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Copy, Ord, PartialOrd)]\n-pub struct ExpnId(pub u32);\n-\n-pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n-// For code appearing from the command line\n-pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n-\n-impl ExpnId {\n-    pub fn from_u32(id: u32) -> ExpnId {\n-        ExpnId(id)\n-    }\n-\n-    pub fn into_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n+pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n /// Identifies an offset of a multi-byte character in a FileMap\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n@@ -651,7 +698,7 @@ thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::\n \n /* assuming that we're not in macro expansion */\n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n+    Span {lo: lo, hi: hi, ctxt: NO_EXPANSION}\n }\n \n pub struct MacroBacktrace {"}, {"sha": "b866652c49f854c67d7ab415c2753cc508bb4710", "filename": "src/libsyntax_pos/symbol.rs", "status": "renamed", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -12,11 +12,58 @@\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n+use hygiene::SyntaxContext;\n+\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Ident {\n+    pub name: Symbol,\n+    pub ctxt: SyntaxContext,\n+}\n+\n+impl Ident {\n+    pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n+        Ident { name: name, ctxt: SyntaxContext::empty() }\n+    }\n+\n+    /// Maps a string to an identifier with an empty syntax context.\n+    pub fn from_str(string: &str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::intern(string))\n+    }\n+\n+    pub fn unhygienize(self) -> Ident {\n+        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}{:?}\", self.name, self.ctxt)\n+    }\n+}\n+\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, f)\n+    }\n+}\n+\n+impl Encodable for Ident {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.name.encode(s)\n+    }\n+}\n+\n+impl Decodable for Ident {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n+        Ok(Ident::with_empty_ctxt(Symbol::decode(d)?))\n+    }\n+}\n+\n /// A symbol is an interned or gensymed string.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Symbol(u32);\n@@ -128,19 +175,19 @@ macro_rules! declare_keywords {(\n     $( ($index: expr, $konst: ident, $string: expr) )*\n ) => {\n     pub mod keywords {\n-        use ast;\n+        use super::{Symbol, Ident};\n         #[derive(Clone, Copy, PartialEq, Eq)]\n         pub struct Keyword {\n-            ident: ast::Ident,\n+            ident: Ident,\n         }\n         impl Keyword {\n-            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n-            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n+            #[inline] pub fn ident(self) -> Ident { self.ident }\n+            #[inline] pub fn name(self) -> Symbol { self.ident.name }\n         }\n         $(\n             #[allow(non_upper_case_globals)]\n             pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(super::Symbol($index))\n+                ident: Ident::with_empty_ctxt(super::Symbol($index))\n             };\n         )*\n     }", "previous_filename": "src/libsyntax/symbol.rs"}, {"sha": "272bf1150cacbfa77a8fa06c736b36dd87fa766b", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -27,14 +27,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");"}, {"sha": "5518ab47c2bd2e0570965a81b39ba2005d7d9759", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -30,14 +30,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     println!(\"{}\", pprust::expr_to_string(&*quote_expr!(&cx, 23)));"}, {"sha": "4a8246ec429c0d1849f5b43879c2e1544f4095f6", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7c0aece17c9a11bc2eca15b994355a161bf878/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=ec7c0aece17c9a11bc2eca15b994355a161bf878", "patch": "@@ -26,14 +26,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     macro_rules! check {"}]}