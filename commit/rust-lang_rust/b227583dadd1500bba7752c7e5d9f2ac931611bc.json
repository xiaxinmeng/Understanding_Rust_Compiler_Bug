{"sha": "b227583dadd1500bba7752c7e5d9f2ac931611bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjc1ODNkYWRkMTUwMGJiYTc3NTJjN2U1ZDlmMmFjOTMxNjExYmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-08T22:42:49Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-08T22:53:11Z"}, "message": "Merge remote-tracking branch 'anasazi/io'\n\nConflicts:\n\tsrc/libstd/rt/test.rs", "tree": {"sha": "af1e460423f3b12a4d67691ce523dfcfca0a4bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af1e460423f3b12a4d67691ce523dfcfca0a4bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b227583dadd1500bba7752c7e5d9f2ac931611bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b227583dadd1500bba7752c7e5d9f2ac931611bc", "html_url": "https://github.com/rust-lang/rust/commit/b227583dadd1500bba7752c7e5d9f2ac931611bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b227583dadd1500bba7752c7e5d9f2ac931611bc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4282539523905c95f34131e5cf8923764079b3be", "url": "https://api.github.com/repos/rust-lang/rust/commits/4282539523905c95f34131e5cf8923764079b3be", "html_url": "https://github.com/rust-lang/rust/commit/4282539523905c95f34131e5cf8923764079b3be"}, {"sha": "5e0be468528fdcf977aa1de6ba553b55303ec56a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e0be468528fdcf977aa1de6ba553b55303ec56a", "html_url": "https://github.com/rust-lang/rust/commit/5e0be468528fdcf977aa1de6ba553b55303ec56a"}], "stats": {"total": 2357, "additions": 1671, "deletions": 686}, "files": [{"sha": "3a93fd705436e2ae00b24fe0313b78ee5a8c0820", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+type Port = u16;\n+\n+#[deriving(Eq, TotalEq)]\n pub enum IpAddr {\n-    Ipv4(u8, u8, u8, u8, u16),\n-    Ipv6\n+    Ipv4(u8, u8, u8, u8, Port),\n+    Ipv6(u16, u16, u16, u16, u16, u16, u16, u16, Port)\n }"}, {"sha": "2425c909bf3d8b0a4a09a9ebdb5a9dde0ec698a9", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 209, "deletions": 31, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -18,15 +18,11 @@ use rt::rtio::{IoFactory, IoFactoryObject,\n                RtioTcpStream, RtioTcpStreamObject};\n use rt::local::Local;\n \n-pub struct TcpStream {\n-    rtstream: ~RtioTcpStreamObject\n-}\n+pub struct TcpStream(~RtioTcpStreamObject);\n \n impl TcpStream {\n     fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n-        TcpStream {\n-            rtstream: s\n-        }\n+        TcpStream(s)\n     }\n \n     pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n@@ -38,22 +34,19 @@ impl TcpStream {\n         };\n \n         match stream {\n-            Ok(s) => {\n-                Some(TcpStream::new(s))\n-            }\n+            Ok(s) => Some(TcpStream::new(s)),\n             Err(ioerr) => {\n                 rtdebug!(\"failed to connect: %?\", ioerr);\n                 io_error::cond.raise(ioerr);\n-                return None;\n+                None\n             }\n         }\n     }\n }\n \n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        let bytes_read = self.rtstream.read(buf);\n-        match bytes_read {\n+        match (**self).read(buf) {\n             Ok(read) => Some(read),\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n@@ -70,8 +63,7 @@ impl Reader for TcpStream {\n \n impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) {\n-        let res = self.rtstream.write(buf);\n-        match res {\n+        match (**self).write(buf) {\n             Ok(_) => (),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n@@ -82,9 +74,7 @@ impl Writer for TcpStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-pub struct TcpListener {\n-    rtlistener: ~RtioTcpListenerObject,\n-}\n+pub struct TcpListener(~RtioTcpListenerObject);\n \n impl TcpListener {\n     pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n@@ -93,11 +83,7 @@ impl TcpListener {\n             (*io).tcp_bind(addr)\n         };\n         match listener {\n-            Ok(l) => {\n-                Some(TcpListener {\n-                    rtlistener: l\n-                })\n-            }\n+            Ok(l) => Some(TcpListener(l)),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 return None;\n@@ -108,8 +94,7 @@ impl TcpListener {\n \n impl Listener<TcpStream> for TcpListener {\n     fn accept(&mut self) -> Option<TcpStream> {\n-        let rtstream = self.rtlistener.accept();\n-        match rtstream {\n+        match (**self).accept() {\n             Ok(s) => {\n                 Some(TcpStream::new(s))\n             }\n@@ -163,7 +148,7 @@ mod test {\n     }\n \n     #[test]\n-    fn smoke_test() {\n+    fn smoke_test_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -183,7 +168,27 @@ mod test {\n     }\n \n     #[test]\n-    fn read_eof() {\n+    fn smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n+            }\n+\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -203,7 +208,27 @@ mod test {\n     }\n \n     #[test]\n-    fn read_eof_twice() {\n+    fn read_eof_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_twice_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -225,7 +250,29 @@ mod test {\n     }\n \n     #[test]\n-    fn write_close() {\n+    fn read_eof_twice_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn write_close_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -254,7 +301,36 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_serial() {\n+    fn write_close_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let buf = [0];\n+                loop {\n+                    let mut stop = false;\n+                    do io_error::cond.trap(|e| {\n+                        // NB: ECONNRESET on linux, EPIPE on mac\n+                        assert!(e.kind == ConnectionReset || e.kind == BrokenPipe);\n+                        stop = true;\n+                    }).in {\n+                        stream.write(buf);\n+                    }\n+                    if stop { break }\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             let max = 10;\n@@ -279,7 +355,32 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_interleaved_greedy_schedule() {\n+    fn multiple_connect_serial_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            let max = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for max.times {\n+                    let mut stream = listener.accept();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert_eq!(buf[0], 99);\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                for max.times {\n+                    let mut stream = TcpStream::connect(addr);\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n@@ -318,7 +419,46 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_interleaved_lazy_schedule() {\n+    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell::new(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n@@ -355,5 +495,43 @@ mod test {\n             }\n         }\n     }\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell::new(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n \n }"}, {"sha": "f3b5278357392d94fbdecebea5b6ef025d7c4f61", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 225, "deletions": 16, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -8,38 +8,247 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::super::*;\n-use super::ip::IpAddr;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::io::net::ip::IpAddr;\n+use rt::io::{Reader, Writer};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::rtio::{RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n+use rt::local::Local;\n \n-pub struct UdpStream;\n+pub struct UdpSocket(~RtioUdpSocketObject);\n \n-impl UdpStream {\n-    pub fn connect(_addr: IpAddr) -> Option<UdpStream> {\n-        fail!()\n+impl UdpSocket {\n+    pub fn bind(addr: IpAddr) -> Option<UdpSocket> {\n+        let socket = unsafe { (*Local::unsafe_borrow::<IoFactoryObject>()).udp_bind(addr) };\n+        match socket {\n+            Ok(s) => Some(UdpSocket(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn recvfrom(&self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n+        match (**self).recvfrom(buf) {\n+            Ok((nread, src)) => Some((nread, src)),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn sendto(&self, buf: &[u8], dst: IpAddr) {\n+        match (**self).sendto(buf, dst) {\n+            Ok(_) => (),\n+            Err(ioerr) => io_error::cond.raise(ioerr),\n+        }\n+    }\n+\n+    pub fn connect(self, other: IpAddr) -> UdpStream {\n+        UdpStream { socket: self, connectedTo: other }\n     }\n }\n \n+pub struct UdpStream {\n+    socket: UdpSocket,\n+    connectedTo: IpAddr\n+}\n+\n+impl UdpStream {\n+    pub fn as_socket<T>(&self, f: &fn(&UdpSocket) -> T) -> T { f(&self.socket) }\n+\n+    pub fn disconnect(self) -> UdpSocket { self.socket }\n+}\n+\n impl Reader for UdpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        do self.as_socket |sock| {\n+            match sock.recvfrom(buf) {\n+                Some((_nread, src)) if src != self.connectedTo => Some(0),\n+                Some((nread, _src)) => Some(nread),\n+                None => None,\n+            }\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UdpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        do self.as_socket |sock| {\n+            sock.sendto(buf, self.connectedTo);\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n \n-pub struct UdpListener;\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::test::*;\n+    use rt::io::net::ip::Ipv4;\n+    use rt::io::*;\n+    use option::{Some, None};\n \n-impl UdpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<UdpListener> {\n-        fail!()\n+    #[test]  #[ignore]\n+    fn bind_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let socket = UdpSocket::bind(addr);\n+                assert!(socket.is_none());\n+            }\n+            assert!(called);\n+        }\n     }\n-}\n \n-impl Listener<UdpStream> for UdpListener {\n-    fn accept(&mut self) -> Option<UdpStream> { fail!() }\n+    #[test]\n+    fn socket_smoke_test_ip4() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip4();\n+            let client_ip = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let mut buf = [0];\n+                        match server.recvfrom(buf) {\n+                            Some((nread, src)) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                                assert_eq!(src, client_ip);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => client.sendto([99], server_ip),\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn socket_smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip6();\n+            let client_ip = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let mut buf = [0];\n+                        match server.recvfrom(buf) {\n+                            Some((nread, src)) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                                assert_eq!(src, client_ip);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => client.sendto([99], server_ip),\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip4() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip4();\n+            let client_ip = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let server = ~server;\n+                        let mut stream = server.connect(client_ip);\n+                        let mut buf = [0];\n+                        match stream.read(buf) {\n+                            Some(nread) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => {\n+                        let client = ~client;\n+                        let mut stream = client.connect(server_ip);\n+                        stream.write([99]);\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip6();\n+            let client_ip = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let server = ~server;\n+                        let mut stream = server.connect(client_ip);\n+                        let mut buf = [0];\n+                        match stream.read(buf) {\n+                            Some(nread) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => {\n+                        let client = ~client;\n+                        let mut stream = client.connect(server_ip);\n+                        stream.write([99]);\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "6bf352ee1447f94a65aa88aca71af961a8a1990b", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -22,6 +22,7 @@ pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n+pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -44,13 +45,42 @@ pub trait RemoteCallback {\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n     fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n+    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError>;\n }\n \n-pub trait RtioTcpListener {\n+pub trait RtioTcpListener : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn accept_simultaneously(&self);\n+    fn dont_accept_simultaneously(&self);\n }\n \n-pub trait RtioTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+pub trait RtioTcpStream : RtioSocket {\n+    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&self, buf: &[u8]) -> Result<(), IoError>;\n+    fn peer_name(&self) -> IpAddr;\n+    fn control_congestion(&self);\n+    fn nodelay(&self);\n+    fn keepalive(&self, delay_in_seconds: uint);\n+    fn letdie(&self);\n+}\n+\n+pub trait RtioSocket {\n+    fn socket_name(&self) -> IpAddr;\n+}\n+\n+pub trait RtioUdpSocket : RtioSocket {\n+    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n+    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n+\n+    fn join_multicast(&self, multi: IpAddr);\n+    fn leave_multicast(&self, multi: IpAddr);\n+\n+    fn loop_multicast_locally(&self);\n+    fn dont_loop_multicast_locally(&self);\n+\n+    fn multicast_time_to_live(&self, ttl: int);\n+    fn time_to_live(&self, ttl: int);\n+\n+    fn hear_broadcasts(&self);\n+    fn ignore_broadcasts(&self);\n }"}, {"sha": "f4b9269e8cd48fef7e483cba8148472d0d1839d8", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::Cell;\n use libc;\n use uint;\n use option::{Some, None};\n+use cell::Cell;\n+use clone::Clone;\n+use container::Container;\n+use iterator::IteratorUtil;\n+use vec::{OwnedVector, MutableVector};\n+use super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::sched::Scheduler;\n-use super::io::net::ip::{IpAddr, Ipv4};\n use rt::local::Local;\n use unstable::run_in_bare_thread;\n use rt::thread::Thread;\n@@ -324,11 +328,16 @@ pub fn next_test_port() -> u16 {\n     }\n }\n \n-/// Get a unique localhost:port pair starting at 9600\n+/// Get a unique IPv4 localhost:port pair starting at 9600\n pub fn next_test_ip4() -> IpAddr {\n     Ipv4(127, 0, 0, 1, next_test_port())\n }\n \n+/// Get a unique IPv6 localhost:port pair starting at 9600\n+pub fn next_test_ip6() -> IpAddr {\n+    Ipv6(0, 0, 0, 0, 0, 0, 0, 1, next_test_port())\n+}\n+\n /*\n XXX: Welcome to MegaHack City.\n "}, {"sha": "e39a6384bc63b26a9a016a3c5a93b3e040bdaf47", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -46,13 +46,14 @@ use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n use unstable::finally::Finally;\n+use rt::io::net::ip::IpAddr;\n \n use rt::io::IoError;\n \n #[cfg(test)] use unstable::run_in_bare_thread;\n \n pub use self::file::FsRequest;\n-pub use self::net::{StreamWatcher, TcpWatcher};\n+pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n@@ -126,6 +127,8 @@ pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n+pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, IpAddr, uint, Option<UvError>);\n+pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n@@ -137,7 +140,9 @@ struct WatcherData {\n     alloc_cb: Option<AllocCallback>,\n     idle_cb: Option<IdleCallback>,\n     timer_cb: Option<TimerCallback>,\n-    async_cb: Option<AsyncCallback>\n+    async_cb: Option<AsyncCallback>,\n+    udp_recv_cb: Option<UdpReceiveCallback>,\n+    udp_send_cb: Option<UdpSendCallback>\n }\n \n pub trait WatcherInterop {\n@@ -167,7 +172,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 alloc_cb: None,\n                 idle_cb: None,\n                 timer_cb: None,\n-                async_cb: None\n+                async_cb: None,\n+                udp_recv_cb: None,\n+                udp_send_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}, {"sha": "2707b9ce7d7b62c545090bd6e22f88090fe614aa", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 555, "deletions": 91, "changes": 646, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -9,35 +9,151 @@\n // except according to those terms.\n \n use prelude::*;\n-use libc::{size_t, ssize_t, c_int, c_void};\n+use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n-use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n+use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::uv::last_uv_error;\n+use vec;\n+use str;\n+use from_str::{FromStr};\n+use num;\n+\n+enum UvIpAddr {\n+    UvIpv4(*sockaddr_in),\n+    UvIpv6(*sockaddr_in6),\n+}\n \n-fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n-    match addr {\n-        Ipv4(a, b, c, d, p) => {\n-            unsafe {\n-                let addr = malloc_ip4_addr(fmt!(\"%u.%u.%u.%u\",\n-                                                a as uint,\n-                                                b as uint,\n-                                                c as uint,\n-                                                d as uint), p as int);\n-                do (|| {\n-                    f(addr)\n-                }).finally {\n-                    free_ip4_addr(addr);\n-                }\n-            }\n+fn sockaddr_to_UvIpAddr(addr: *uvll::sockaddr) -> UvIpAddr {\n+    unsafe {\n+        assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n+        assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n+        match addr {\n+            _ if is_ip4_addr(addr) => UvIpv4(as_sockaddr_in(addr)),\n+            _ if is_ip6_addr(addr) => UvIpv6(as_sockaddr_in6(addr)),\n+            _ => fail!(),\n         }\n-        Ipv6 => fail!()\n     }\n }\n \n+fn ip_as_uv_ip<T>(addr: IpAddr, f: &fn(UvIpAddr) -> T) -> T {\n+    let malloc = match addr {\n+        Ipv4(*) => malloc_ip4_addr,\n+        Ipv6(*) => malloc_ip6_addr,\n+    };\n+    let wrap = match addr {\n+        Ipv4(*) => UvIpv4,\n+        Ipv6(*) => UvIpv6,\n+    };\n+    let ip_str = match addr {\n+        Ipv4(x1, x2, x3, x4, _) =>\n+            fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n+        Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n+            fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                  x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n+                  x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n+    };\n+    let port = match addr {\n+        Ipv4(_, _, _, _, p) | Ipv6(_, _, _, _, _, _, _, _, p) => p as int\n+    };\n+    let free = match addr {\n+        Ipv4(*) => free_ip4_addr,\n+        Ipv6(*) => free_ip6_addr,\n+    };\n+\n+    let addr = unsafe { malloc(ip_str, port) };\n+    do (|| {\n+        f(wrap(addr))\n+    }).finally {\n+        unsafe { free(addr) };\n+    }\n+}\n+\n+fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n+    let ip_size = match addr {\n+        UvIpv4(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n+        UvIpv6(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n+    };\n+    let ip_name = {\n+        let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n+        unsafe {\n+            match addr {\n+                UvIpv4(addr) => uvll::ip4_name(addr, vec::raw::to_ptr(buf), ip_size as u64),\n+                UvIpv6(addr) => uvll::ip6_name(addr, vec::raw::to_ptr(buf), ip_size as u64),\n+            }\n+        };\n+        buf\n+    };\n+    let ip_port = unsafe {\n+        let port = match addr {\n+            UvIpv4(addr) => uvll::ip4_port(addr),\n+            UvIpv6(addr) => uvll::ip6_port(addr),\n+        };\n+        port as u16\n+    };\n+    let ip_str = str::from_bytes_slice(ip_name).trim_right_chars(&'\\x00');\n+    let ip = match addr {\n+        UvIpv4(*) => {\n+            let ip: ~[u8] = \n+                ip_str.split_iter('.')\n+                      .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n+                      .collect();\n+            assert_eq!(ip.len(), 4);\n+            Ipv4(ip[0], ip[1], ip[2], ip[3], ip_port)\n+        },\n+        UvIpv6(*) => {\n+            let ip: ~[u16] = {\n+                let expand_shorthand_and_convert = |s: &str| -> ~[~[u16]] {\n+                    let convert_each_segment = |s: &str| -> ~[u16] {\n+                        let read_hex_segment = |s: &str| -> u16 {\n+                            num::FromStrRadix::from_str_radix(s, 16u).unwrap()\n+                        };\n+                        match s {\n+                            \"\" => ~[],\n+                            s => s.split_iter(':').transform(read_hex_segment).collect(),\n+                        }\n+                    };\n+                    s.split_str_iter(\"::\").transform(convert_each_segment).collect()\n+                };\n+                match expand_shorthand_and_convert(ip_str) {\n+                    [x] => x, // no shorthand found\n+                    [l, r] => l + vec::from_elem(8 - l.len() - r.len(), 0u16) + r, // fill the gap\n+                    _ => fail!(), // impossible. only one shorthand allowed.\n+                }\n+            };\n+            assert_eq!(ip.len(), 8);\n+            Ipv6(ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7], ip_port)\n+        },\n+    };\n+\n+    // finally run the closure\n+    f(ip)\n+}\n+\n+fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n+    use util;\n+    uv_ip_as_ip(addr, util::id)\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_ip4_conversion() {\n+    use rt;\n+    let ip4 = rt::test::next_test_ip4();\n+    assert_eq!(ip4, ip_as_uv_ip(ip4, uv_ip_to_ip));\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_ip6_conversion() {\n+    use rt;\n+    let ip6 = rt::test::next_test_ip6();\n+    assert_eq!(ip6, ip_as_uv_ip(ip6, uv_ip_to_ip));\n+}\n+\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n@@ -51,22 +167,19 @@ impl StreamWatcher {\n             data.read_cb = Some(cb);\n         }\n \n-        let handle = self.native_handle();\n-        unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n+        unsafe { uvll::read_start(self.native_handle(), alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = stream_watcher.get_watcher_data();\n-            let alloc_cb = data.alloc_cb.get_ref();\n+            let alloc_cb = stream_watcher.get_watcher_data().alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n \n         extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = stream_watcher.get_watcher_data();\n-            let cb = data.read_cb.get_ref();\n+            let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n@@ -88,22 +201,15 @@ impl StreamWatcher {\n         }\n \n         let req = WriteRequest::new();\n-        let bufs = [buf];\n         unsafe {\n-            assert!(0 == uvll::write(req.native_handle(),\n-                                     self.native_handle(),\n-                                     bufs, write_cb));\n+        assert_eq!(0, uvll::write(req.native_handle(), self.native_handle(), [buf], write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n-            let cb = {\n-                let data = stream_watcher.get_watcher_data();\n-                let cb = data.write_cb.swap_unwrap();\n-                cb\n-            };\n+            let cb = stream_watcher.get_watcher_data().write_cb.swap_unwrap();\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }\n@@ -112,9 +218,7 @@ impl StreamWatcher {\n     pub fn accept(&mut self, stream: StreamWatcher) {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n-        unsafe {\n-            assert_eq!(0, uvll::accept(self_handle, stream_handle));\n-        }\n+        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n     }\n \n     pub fn close(self, cb: NullCallback) {\n@@ -129,19 +233,15 @@ impl StreamWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = stream_watcher.get_watcher_data();\n-                data.close_cb.swap_unwrap()();\n-            }\n+            stream_watcher.get_watcher_data().close_cb.swap_unwrap()();\n             stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n }\n \n impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    fn from_native_handle(\n-        handle: *uvll::uv_stream_t) -> StreamWatcher {\n+    fn from_native_handle(handle: *uvll::uv_stream_t) -> StreamWatcher {\n         StreamWatcher(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_stream_t {\n@@ -153,7 +253,7 @@ pub struct TcpWatcher(*uvll::uv_tcp_t);\n impl Watcher for TcpWatcher { }\n \n impl TcpWatcher {\n-    pub fn new(loop_: &mut Loop) -> TcpWatcher {\n+    pub fn new(loop_: &Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n@@ -165,20 +265,17 @@ impl TcpWatcher {\n     }\n \n     pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n-        match address {\n-            Ipv4(*) => {\n-                do ip4_as_uv_ip4(address) |addr| {\n-                    let result = unsafe {\n-                        uvll::tcp_bind(self.native_handle(), addr)\n-                    };\n-                    if result == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(last_uv_error(self))\n-                    }\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::tcp_bind(self.native_handle(), addr),\n+                    UvIpv6(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n                 }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(last_uv_error(self)),\n             }\n-            _ => fail!()\n         }\n     }\n \n@@ -188,27 +285,21 @@ impl TcpWatcher {\n             self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n-            match address {\n-                Ipv4(*) => {\n-                    do ip4_as_uv_ip4(address) |addr| {\n-                        rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                        assert!(0 == uvll::tcp_connect(connect_handle,\n-                                                            self.native_handle(),\n-                                                            addr, connect_cb));\n-                    }\n-                }\n-                _ => fail!()\n+            rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+            do ip_as_uv_ip(address) |addr| {\n+                let result = match addr {\n+                    UvIpv4(addr) => uvll::tcp_connect(connect_handle, self.native_handle(), addr, connect_cb),\n+                    UvIpv6(addr) => uvll::tcp_connect6(connect_handle, self.native_handle(), addr, connect_cb),\n+                };\n+                assert_eq!(0, result);\n             }\n \n             extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n                 rtdebug!(\"connect_t: %x\", req as uint);\n                 let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n-                let cb: ConnectionCallback = {\n-                    let data = stream_watcher.get_watcher_data();\n-                    data.connect_cb.swap_unwrap()\n-                };\n+                let cb = stream_watcher.get_watcher_data().connect_cb.swap_unwrap();\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n                 cb(stream_watcher, status);\n             }\n@@ -225,15 +316,13 @@ impl TcpWatcher {\n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n             // XXX: This can probably fail\n-            assert!(0 == uvll::listen(self.native_handle(),\n-                                           BACKLOG, connection_cb));\n+            assert_eq!(0, uvll::listen(self.native_handle(), BACKLOG, connection_cb));\n         }\n \n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let data = stream_watcher.get_watcher_data();\n-            let cb = data.connect_cb.get_ref();\n+            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n             let status = status_to_maybe_uv_error(handle, status);\n             (*cb)(stream_watcher, status);\n         }\n@@ -253,19 +342,135 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n+pub struct UdpWatcher(*uvll::uv_udp_t);\n+impl Watcher for UdpWatcher { }\n+\n+impl UdpWatcher {\n+    pub fn new(loop_: &Loop) -> UdpWatcher {\n+        unsafe {\n+            let handle = malloc_handle(UV_UDP);\n+            assert!(handle.is_not_null());\n+            assert_eq!(0, uvll::udp_init(loop_.native_handle(), handle));\n+            let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn bind(&self, address: IpAddr) -> Result<(), UvError> {\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n+                    UvIpv6(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n+                }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(last_uv_error(self)),\n+            }\n+        }\n+    }\n+\n+    pub fn recv_start(&self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n+        {\n+            let mut this = *self;\n+            let data = this.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.udp_recv_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n+\n+        extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let alloc_cb = udp_watcher.get_watcher_data().alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n+                          addr: *uvll::sockaddr, flags: c_uint) {\n+            rtdebug!(\"buf addr: %x\", buf.base as uint);\n+            rtdebug!(\"buf len: %d\", buf.len as int);\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, nread as c_int);\n+            let addr = uv_ip_to_ip(sockaddr_to_UvIpAddr(addr));\n+            (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n+        }\n+    }\n+\n+    pub fn recv_stop(&self) {\n+        unsafe { uvll::udp_recv_stop(self.native_handle()); }\n+    }\n+\n+    pub fn send(&self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n+        {\n+            let mut this = *self;\n+            let data = this.get_watcher_data();\n+            assert!(data.udp_send_cb.is_none());\n+            data.udp_send_cb = Some(cb);\n+        }\n+\n+        let req = UdpSendRequest::new();\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::udp_send(req.native_handle(), self.native_handle(), [buf], addr, send_cb),\n+                    UvIpv6(addr) => uvll::udp_send6(req.native_handle(), self.native_handle(), [buf], addr, send_cb),\n+                }\n+            };\n+            assert_eq!(0, result);\n+        }\n+\n+        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n+            let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n+            let mut udp_watcher = send_request.handle();\n+            send_request.delete();\n+            let cb = udp_watcher.get_watcher_data().udp_send_cb.swap_unwrap();\n+            let status = status_to_maybe_uv_error(udp_watcher.native_handle(), status);\n+            cb(udp_watcher, status);\n+        }\n+    }\n+\n+    pub fn close(self, cb: NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_udp_t) {\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            udp_watcher.get_watcher_data().close_cb.swap_unwrap()();\n+            udp_watcher.drop_watcher_data();\n+            unsafe { free_handle(handle as *c_void) }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_udp_t) -> UdpWatcher {\n+        UdpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_t {\n+        match self { &UdpWatcher(ptr) => ptr }\n+    }\n+}\n+\n // uv_connect_t is a subclass of uv_req_t\n struct ConnectRequest(*uvll::uv_connect_t);\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n \n     fn new() -> ConnectRequest {\n-        let connect_handle = unsafe {\n-            malloc_req(UV_CONNECT)\n-        };\n+        let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n         assert!(connect_handle.is_not_null());\n-        let connect_handle = connect_handle as *uvll::uv_connect_t;\n-        ConnectRequest(connect_handle)\n+        ConnectRequest(connect_handle as *uvll::uv_connect_t)\n     }\n \n     fn stream(&self) -> StreamWatcher {\n@@ -281,8 +486,7 @@ impl ConnectRequest {\n }\n \n impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    fn from_native_handle(\n-        handle: *uvll:: uv_connect_t) -> ConnectRequest {\n+    fn from_native_handle(handle: *uvll:: uv_connect_t) -> ConnectRequest {\n         ConnectRequest(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_connect_t {\n@@ -296,12 +500,9 @@ impl Request for WriteRequest { }\n \n impl WriteRequest {\n     pub fn new() -> WriteRequest {\n-        let write_handle = unsafe {\n-            malloc_req(UV_WRITE)\n-        };\n+        let write_handle = unsafe { malloc_req(UV_WRITE) };\n         assert!(write_handle.is_not_null());\n-        let write_handle = write_handle as *uvll::uv_write_t;\n-        WriteRequest(write_handle)\n+        WriteRequest(write_handle as *uvll::uv_write_t)\n     }\n \n     pub fn stream(&self) -> StreamWatcher {\n@@ -325,6 +526,36 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n     }\n }\n \n+pub struct UdpSendRequest(*uvll::uv_udp_send_t);\n+impl Request for UdpSendRequest { }\n+\n+impl UdpSendRequest {\n+    pub fn new() -> UdpSendRequest {\n+        let send_handle = unsafe { malloc_req(UV_UDP_SEND) };\n+        assert!(send_handle.is_not_null());\n+        UdpSendRequest(send_handle as *uvll::uv_udp_send_t)\n+    }\n+\n+    pub fn handle(&self) -> UdpWatcher {\n+        let send_request_handle = unsafe {\n+            uvll::get_udp_handle_from_send_req(self.native_handle())\n+        };\n+        NativeHandle::from_native_handle(send_request_handle)\n+    }\n+\n+    pub fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_send_t> for UdpSendRequest {\n+    fn from_native_handle(handle: *uvll::uv_udp_send_t) -> UdpSendRequest {\n+        UdpSendRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_send_t {\n+        match self { &UdpSendRequest(ptr) => ptr }\n+    }\n+}\n \n #[cfg(test)]\n mod test {\n@@ -339,7 +570,7 @@ mod test {\n     use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n \n     #[test]\n-    fn connect_close() {\n+    fn connect_close_ip4() {\n         do run_in_bare_thread() {\n             let mut loop_ = Loop::new();\n             let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n@@ -357,7 +588,51 @@ mod test {\n     }\n \n     #[test]\n-    fn listen() {\n+    fn connect_close_ip6() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip6();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_bind_close_ip4() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            udp_watcher.bind(addr);\n+            udp_watcher.close(||());\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_bind_close_ip6() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            udp_watcher.bind(addr);\n+            udp_watcher.close(||());\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_ip4() {\n         do run_in_bare_thread() {\n             static MAX: int = 10;\n             let mut loop_ = Loop::new();\n@@ -366,10 +641,82 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell::new(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc) |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).iter().advance() |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert_eq!(count, MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n+                    }\n+                    count_cell.put_back(count);\n+                }\n+            }\n+\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n+                    assert!(status.is_none());\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell::new(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell::new(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n+                }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n-                let mut server_stream_watcher = server_stream_watcher;\n                 let mut loop_ = loop_;\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n                 let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n@@ -409,10 +756,9 @@ mod test {\n                 rtdebug!(\"starting client thread\");\n                 let mut loop_ = Loop::new();\n                 let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n                     rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    let mut stream_watcher = stream_watcher;\n                     let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n                     let buf = slice_to_uv_buf(msg);\n                     let msg_cell = Cell::new(msg);\n@@ -432,4 +778,122 @@ mod test {\n             loop_.close();\n         }\n     }\n+\n+    #[test]\n+    fn udp_recv_ip4() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let server_addr = next_test_ip4();\n+            let client_addr = next_test_ip4();\n+\n+            let server = UdpWatcher::new(&loop_);\n+            assert!(server.bind(server_addr).is_ok());\n+\n+            rtdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+\n+            do server.recv_start(alloc) |server, nread, buf, src, flags, status| {\n+                server.recv_stop();\n+                rtdebug!(\"i'm reading!\");\n+                assert!(status.is_none());\n+                assert_eq!(flags, 0);\n+                assert_eq!(src, client_addr);\n+\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = 0;\n+                rtdebug!(\"got %d bytes\", nread);\n+\n+                let buf = buf.unwrap();\n+                for buf.slice(0, nread as uint).iter().advance() |&byte| {\n+                    assert!(byte == count as u8);\n+                    rtdebug!(\"%u\", byte as uint);\n+                    count += 1;\n+                }\n+                assert_eq!(count, MAX);\n+\n+                server.close(||{});\n+            }\n+\n+            do Thread::start {\n+                let mut loop_ = Loop::new();\n+                let client = UdpWatcher::new(&loop_);\n+                assert!(client.bind(client_addr).is_ok());\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+                let buf = slice_to_uv_buf(msg);\n+                do client.send(buf, server_addr) |client, status| {\n+                    rtdebug!(\"writing\");\n+                    assert!(status.is_none());\n+                    client.close(||{});\n+                }\n+\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_recv_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let server_addr = next_test_ip6();\n+            let client_addr = next_test_ip6();\n+\n+            let server = UdpWatcher::new(&loop_);\n+            assert!(server.bind(server_addr).is_ok());\n+\n+            rtdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+\n+            do server.recv_start(alloc) |server, nread, buf, src, flags, status| {\n+                server.recv_stop();\n+                rtdebug!(\"i'm reading!\");\n+                assert!(status.is_none());\n+                assert_eq!(flags, 0);\n+                assert_eq!(src, client_addr);\n+\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = 0;\n+                rtdebug!(\"got %d bytes\", nread);\n+\n+                let buf = buf.unwrap();\n+                for buf.slice(0, nread as uint).iter().advance() |&byte| {\n+                    assert!(byte == count as u8);\n+                    rtdebug!(\"%u\", byte as uint);\n+                    count += 1;\n+                }\n+                assert_eq!(count, MAX);\n+\n+                server.close(||{});\n+            }\n+\n+            do Thread::start {\n+                let mut loop_ = Loop::new();\n+                let client = UdpWatcher::new(&loop_);\n+                assert!(client.bind(client_addr).is_ok());\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+                let buf = slice_to_uv_buf(msg);\n+                do client.send(buf, server_addr) |client, status| {\n+                    rtdebug!(\"writing\");\n+                    assert!(status.is_none());\n+                    client.close(||{});\n+                }\n+\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n }"}, {"sha": "5d0c64c6867827d872d2363f4624df90209750ea", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 291, "deletions": 29, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -63,9 +63,8 @@ impl EventLoop for UvEventLoop {\n \n     fn callback(&mut self, f: ~fn()) {\n         let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |idle_watcher, status| {\n+        do idle_watcher.start |mut idle_watcher, status| {\n             assert!(status.is_none());\n-            let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n             idle_watcher.close(||());\n             f();\n@@ -221,7 +220,7 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+                    let res = Ok(~UvTcpStream(stream_watcher));\n \n                     // Store the stream in the task's stack\n                     unsafe { (*result_cell_ptr).put_back(res); }\n@@ -263,6 +262,24 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n     }\n+\n+    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError> {\n+        let /*mut*/ watcher = UdpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvUdpSocket(watcher)),\n+            Err(uverr) => {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do watcher.close {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n }\n \n // FIXME #6090: Prefer newtype structs but Drop doesn't work\n@@ -298,6 +315,11 @@ impl Drop for UvTcpListener {\n     }\n }\n \n+impl RtioSocket for UvTcpListener {\n+    // XXX implement\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n impl RtioTcpListener for UvTcpListener {\n \n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n@@ -314,15 +336,14 @@ impl RtioTcpListener for UvTcpListener {\n \n         let incoming_streams_cell = Cell::new(incoming_streams_cell.take());\n         let mut server_tcp_watcher = server_tcp_watcher;\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+        do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n             let maybe_stream = if status.is_none() {\n-                let mut server_stream_watcher = server_stream_watcher;\n                 let mut loop_ = server_stream_watcher.event_loop();\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n                 let client_tcp_watcher = client_tcp_watcher.as_stream();\n                 // XXX: Need's to be surfaced in interface\n                 server_stream_watcher.accept(client_tcp_watcher);\n-                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+                Ok(~UvTcpStream(client_tcp_watcher))\n             } else {\n                 Err(standard_error(OtherIoError))\n             };\n@@ -334,58 +355,58 @@ impl RtioTcpListener for UvTcpListener {\n \n         return self.incoming_streams.recv();\n     }\n-}\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n-pub struct UvTcpStream {\n-    watcher: StreamWatcher\n+    // XXX implement\n+    fn accept_simultaneously(&self) { fail!(); }\n+    fn dont_accept_simultaneously(&self) { fail!(); }\n }\n \n-impl UvTcpStream {\n-    fn watcher(&self) -> StreamWatcher { self.watcher }\n-}\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream(StreamWatcher);\n \n impl Drop for UvTcpStream {\n     fn drop(&self) {\n         rtdebug!(\"closing tcp stream\");\n-        let watcher = self.watcher();\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            do watcher.close {\n+            do self.close {\n                 let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n     }\n }\n \n+impl RtioSocket for UvTcpStream {\n+    // XXX implement\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n impl RtioTcpStream for UvTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |sched, task| {\n             rtdebug!(\"read: entered scheduler context\");\n             assert!(!sched.in_task_context());\n-            let mut watcher = watcher;\n             let task_cell = Cell::new(task);\n             // XXX: We shouldn't reallocate these callbacks every\n             // call to read\n             let alloc: AllocCallback = |_| unsafe {\n                 slice_to_uv_buf(*buf_ptr)\n             };\n-            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+            let mut watcher = **self;\n+            do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                 // Stop reading so that no read callbacks are\n                 // triggered before the user calls `read` again.\n                 // XXX: Is there a performance impact to calling\n                 // stop here?\n-                let mut watcher = watcher;\n                 watcher.read_stop();\n \n                 let result = if status.is_none() {\n@@ -406,17 +427,16 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |_, task| {\n-            let mut watcher = watcher;\n             let task_cell = Cell::new(task);\n             let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            let mut watcher = **self;\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n@@ -434,6 +454,112 @@ impl RtioTcpStream for UvTcpStream {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    // XXX implement\n+    fn peer_name(&self) -> IpAddr { fail!(); }\n+    fn control_congestion(&self) { fail!(); }\n+    fn nodelay(&self) { fail!(); }\n+    fn keepalive(&self, _delay_in_seconds: uint) { fail!(); }\n+    fn letdie(&self) { fail!(); }\n+}\n+\n+pub struct UvUdpSocket(UdpWatcher);\n+\n+impl Drop for UvUdpSocket {\n+    fn drop(&self) {\n+        rtdebug!(\"closing udp socket\");\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.close {\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for UvUdpSocket {\n+    // XXX implement\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n+impl RtioUdpSocket for UvUdpSocket {\n+    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n+\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |sched, task| {\n+            rtdebug!(\"recvfrom: entered scheduler context\");\n+            assert!(!sched.in_task_context());\n+            let task_cell = Cell::new(task);\n+            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do self.recv_start(alloc) |watcher, nread, _buf, addr, flags, status| {\n+                let _ = flags; // XXX add handling for partials?\n+\n+                watcher.recv_stop();\n+\n+                let result = match status {\n+                    None => {\n+                        assert!(nread >= 0);\n+                        Ok((nread as uint, addr))\n+                    }\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do self.send(buf, dst) |_watcher, status| {\n+\n+                let result = match status {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err)),\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    // XXX implement\n+    fn join_multicast(&self, _multi: IpAddr) { fail!(); }\n+    fn leave_multicast(&self, _multi: IpAddr) { fail!(); }\n+\n+    fn loop_multicast_locally(&self) { fail!(); }\n+    fn dont_loop_multicast_locally(&self) { fail!(); }\n+\n+    fn multicast_time_to_live(&self, _ttl: int) { fail!(); }\n+    fn time_to_live(&self, _ttl: int) { fail!(); }\n+\n+    fn hear_broadcasts(&self) { fail!(); }\n+    fn ignore_broadcasts(&self) { fail!(); }\n }\n \n #[test]\n@@ -448,6 +574,18 @@ fn test_simple_io_no_connect() {\n     }\n }\n \n+#[test]\n+fn test_simple_udp_io_bind_only() {\n+    do run_in_newsched_task {\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let addr = next_test_ip4();\n+            let maybe_socket = (*io).udp_bind(addr);\n+            assert!(maybe_socket.is_ok());\n+        }\n+    }\n+}\n+\n #[test]\n fn test_simple_tcp_server_and_client() {\n     do run_in_newsched_task {\n@@ -458,7 +596,7 @@ fn test_simple_tcp_server_and_client() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -472,13 +610,44 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n     }\n }\n \n+#[test]\n+fn test_simple_udp_server_and_client() {\n+    do run_in_newsched_task {\n+        let server_addr = next_test_ip4();\n+        let client_addr = next_test_ip4();\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let server_socket = (*io).udp_bind(server_addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let (nread,src) = server_socket.recvfrom(buf).unwrap();\n+                assert_eq!(nread, 8);\n+                for uint::range(0, nread) |i| {\n+                    rtdebug!(\"%u\", buf[i] as uint);\n+                    assert_eq!(buf[i], i as u8);\n+                }\n+                assert_eq!(src, client_addr);\n+            }\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let client_socket = (*io).udp_bind(client_addr).unwrap();\n+                client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n+            }\n+        }\n+    }\n+}\n+\n #[test] #[ignore(reason = \"busted\")]\n fn test_read_and_block() {\n     do run_in_newsched_task {\n@@ -487,7 +656,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n-            let mut stream = listener.accept().unwrap();\n+            let stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -520,7 +689,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -541,7 +710,7 @@ fn test_read_read_read() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n@@ -554,7 +723,7 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n@@ -570,3 +739,96 @@ fn test_read_read_read() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_udp_twice() {\n+    do run_in_newsched_task {\n+        let server_addr = next_test_ip4();\n+        let client_addr = next_test_ip4();\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let client = (*io).udp_bind(client_addr).unwrap();\n+                assert!(client.sendto([1], server_addr).is_ok());\n+                assert!(client.sendto([2], server_addr).is_ok());\n+            }\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let server = (*io).udp_bind(server_addr).unwrap();\n+                let mut buf1 = [0];\n+                let mut buf2 = [0];\n+                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n+                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+                assert_eq!(nread1, 1);\n+                assert_eq!(nread2, 1);\n+                assert_eq!(src1, client_addr);\n+                assert_eq!(src2, client_addr);\n+                assert_eq!(buf1[0], 1);\n+                assert_eq!(buf2[0], 2);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_udp_many_read() {\n+    do run_in_newsched_task {\n+        let server_out_addr = next_test_ip4();\n+        let server_in_addr = next_test_ip4();\n+        let client_out_addr = next_test_ip4();\n+        let client_in_addr = next_test_ip4();\n+        static MAX: uint = 500_000;\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let server_out = (*io).udp_bind(server_out_addr).unwrap();\n+                let server_in = (*io).udp_bind(server_in_addr).unwrap();\n+                let msg = [1, .. 2048];\n+                let mut total_bytes_sent = 0;\n+                let mut buf = [1];\n+                while buf[0] == 1 {\n+                    // send more data\n+                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n+                    total_bytes_sent += msg.len();\n+                    // check if the client has received enough\n+                    let res = server_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(nread, 1);\n+                    assert_eq!(src, client_out_addr);\n+                }\n+                assert!(total_bytes_sent >= MAX);\n+            }\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let client_out = (*io).udp_bind(client_out_addr).unwrap();\n+                let client_in = (*io).udp_bind(client_in_addr).unwrap();\n+                let mut total_bytes_recv = 0;\n+                let mut buf = [0, .. 2048];\n+                while total_bytes_recv < MAX {\n+                    // ask for more\n+                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n+                    // wait for data\n+                    let res = client_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(src, server_out_addr);\n+                    total_bytes_recv += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert_eq!(buf[i], 1);\n+                    }\n+                }\n+                // tell the server we're done\n+                assert!(client_out.sendto([0], server_in_addr).is_ok());\n+            }\n+        }\n+    }\n+}"}, {"sha": "62bf8f27af93de00b3f4838719a8096dd01598e9", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 171, "deletions": 49, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -60,17 +60,24 @@ pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n pub type uv_tcp_t = c_void;\n+pub type uv_udp_t = c_void;\n pub type uv_connect_t = c_void;\n pub type uv_write_t = c_void;\n pub type uv_async_t = c_void;\n pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n+pub type uv_udp_send_t = c_void;\n \n pub type uv_idle_cb = *u8;\n+pub type uv_alloc_cb = *u8;\n+pub type uv_udp_send_cb = *u8;\n+pub type uv_udp_recv_cb = *u8;\n \n+pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n+pub type uv_membership = c_void;\n \n #[deriving(Eq)]\n pub enum uv_handle_type {\n@@ -187,31 +194,88 @@ pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n     rust_uv_idle_stop(handle)\n }\n \n+pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n+    return rust_uv_udp_init(loop_handle, handle);\n+}\n+\n+pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n+    return rust_uv_udp_bind(server, addr, flags);\n+}\n+\n+pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n+    return rust_uv_udp_bind6(server, addr, flags);\n+}\n+\n+pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n+                          addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n+}\n+\n+pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n+                          addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n+}\n+\n+pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n+                             on_recv: uv_udp_recv_cb) -> c_int {\n+    return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n+}\n+\n+pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n+    return rust_uv_udp_recv_stop(server);\n+}\n+\n+pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+    return rust_uv_get_udp_handle_from_send_req(send_req);\n+}\n+\n+pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_udp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn udp_get_sockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int {\n+    return rust_uv_udp_getsockname6(handle, name);\n+}\n+\n+pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                 interface_addr: *c_char, membership: uv_membership) -> c_int {\n+    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership);\n+}\n+\n+pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n+    return rust_uv_udp_set_multicast_loop(handle, on);\n+}\n+\n+pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    return rust_uv_udp_set_multicast_ttl(handle, ttl);\n+}\n+\n+pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n+    return rust_uv_udp_set_broadcast(handle, on);\n+}\n+\n pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n     return rust_uv_tcp_init(loop_handle, handle);\n }\n \n-// FIXME ref #2064\n-pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n-                          tcp_handle_ptr: *uv_tcp_t,\n-                          addr_ptr: *sockaddr_in,\n-                          after_connect_cb: *u8) -> c_int {\n-    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                       after_connect_cb, addr_ptr);\n+pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n+                          addr_ptr: *sockaddr_in, after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n-// FIXME ref #2064\n-pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           addr_ptr: *sockaddr_in6,\n-                           after_connect_cb: *u8) -> c_int {\n-    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n-                                        after_connect_cb, addr_ptr);\n+\n+pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n+                           addr_ptr: *sockaddr_in6, after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n-// FIXME ref #2064\n+\n pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n     return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n }\n-// FIXME ref #2064\n+\n pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n     return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n }\n@@ -224,6 +288,26 @@ pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) -\n     return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n }\n \n+pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int {\n+    return rust_uv_tcp_getsockname6(handle, name);\n+}\n+\n+pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    return rust_uv_tcp_nodelay(handle, enable);\n+}\n+\n+pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n+    return rust_uv_tcp_keepalive(handle, enable, delay);\n+}\n+\n+pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    return rust_uv_tcp_simultaneous_accepts(handle, enable);\n+}\n+\n pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n     return rust_uv_listen(stream as *c_void, backlog, cb);\n }\n@@ -237,7 +321,7 @@ pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n-pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {\n+pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: uv_alloc_cb, on_read: *u8) -> c_int {\n     return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n }\n \n@@ -281,6 +365,22 @@ pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_stop(timer_ptr);\n }\n \n+pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n+    match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n+    match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in {\n+    return rust_uv_sockaddr_as_sockaddr_in(addr);\n+}\n+\n+pub unsafe fn as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6 {\n+    return rust_uv_sockaddr_as_sockaddr_in6(addr);\n+}\n+\n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n@@ -300,6 +400,22 @@ pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n     rust_uv_free_ip6_addr(addr);\n }\n \n+pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n+    return rust_uv_ip4_name(addr, dst, size);\n+}\n+\n+pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n+    return rust_uv_ip6_name(addr, dst, size);\n+}\n+\n+pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n+   return rust_uv_ip4_port(addr);\n+}\n+\n+pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n+    return rust_uv_ip6_port(addr);\n+}\n+\n // data access helpers\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n     return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n@@ -384,16 +500,11 @@ extern {\n     fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n \n     fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: *u8) -> c_int;\n+    fn rust_uv_async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int;\n     fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n-    // FIXME ref #2604 .. ?\n     fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n     fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n-    // FIXME ref #2064\n     fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n-    // FIXME ref #2064\n     fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n     fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n     fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n@@ -403,40 +514,51 @@ extern {\n     fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n     fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n     fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           after_cb: *u8,\n+    fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                            addr: *sockaddr_in) -> c_int;\n-    // FIXME ref #2064\n     fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                            tcp_handle_ptr: *uv_tcp_t,\n-                            after_cb: *u8,\n+    fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                             addr: *sockaddr_in6) -> c_int;\n-    // FIXME ref #2064\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                               name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n+    fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n+    fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n+\n+    fn rust_uv_udp_init(loop_handle: *uv_loop_t, handle_ptr: *uv_udp_t) -> c_int;\n+    fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n+    fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n+    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                        buf_cnt: c_int, addr: *sockaddr_in, cb: *u8) -> c_int;\n+    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                         buf_cnt: c_int, addr: *sockaddr_in6, cb: *u8) -> c_int;\n+    fn rust_uv_udp_recv_start(server: *uv_udp_t, on_alloc: *u8, on_recv: *u8) -> c_int;\n+    fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n+    fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n+    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int;\n+    fn rust_uv_udp_getsockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                  interface_addr: *c_char, membership: uv_membership) -> c_int;\n+    fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n+    fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n+\n+    fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_sockaddr_as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in;\n+    fn rust_uv_sockaddr_as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6;\n+\n     fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n     fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n-    fn rust_uv_write(req: *c_void,\n-                     stream: *c_void,\n-                     buf_in: *uv_buf_t,\n-                     buf_cnt: c_int,\n+    fn rust_uv_write(req: *c_void, stream: *c_void, buf_in: *uv_buf_t, buf_cnt: c_int,\n                      cb: *u8) -> c_int;\n-    fn rust_uv_read_start(stream: *c_void,\n-                          on_alloc: *u8,\n-                          on_read: *u8) -> c_int;\n+    fn rust_uv_read_start(stream: *c_void, on_alloc: *u8, on_read: *u8) -> c_int;\n     fn rust_uv_read_stop(stream: *c_void) -> c_int;\n-    fn rust_uv_timer_init(loop_handle: *c_void,\n-                          timer_handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n-                           cb: *u8,\n-                           timeout: libc::uint64_t,\n+    fn rust_uv_timer_init(loop_handle: *c_void, timer_handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: *u8, timeout: libc::uint64_t,\n                            repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n "}, {"sha": "0187ad3abf51751ce92ca3d47421bc0b48763759", "filename": "src/libstd/rt/uvio.rs", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/4282539523905c95f34131e5cf8923764079b3be/src%2Flibstd%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4282539523905c95f34131e5cf8923764079b3be/src%2Flibstd%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuvio.rs?ref=4282539523905c95f34131e5cf8923764079b3be", "patch": "@@ -1,458 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use option::*;\n-use result::*;\n-\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n-use ops::Drop;\n-use cell::Cell;\n-use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n-\n-#[cfg(test)] use container::Container;\n-#[cfg(test)] use uint;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n-\n-pub struct UvEventLoop {\n-    uvio: UvIoFactory\n-}\n-\n-impl UvEventLoop {\n-    pub fn new() -> UvEventLoop {\n-        UvEventLoop {\n-            uvio: UvIoFactory(Loop::new())\n-        }\n-    }\n-\n-    /// A convenience constructor\n-    pub fn new_scheduler() -> Scheduler {\n-        Scheduler::new(~UvEventLoop::new())\n-    }\n-}\n-\n-impl Drop for UvEventLoop {\n-    fn drop(&self) {\n-        // XXX: Need mutable finalizer\n-        let this = unsafe {\n-            transmute::<&UvEventLoop, &mut UvEventLoop>(self)\n-        };\n-        this.uvio.uv_loop().close();\n-    }\n-}\n-\n-impl EventLoop for UvEventLoop {\n-\n-    fn run(&mut self) {\n-        self.uvio.uv_loop().run();\n-    }\n-\n-    fn callback(&mut self, f: ~fn()) {\n-        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |idle_watcher, status| {\n-            assert!(status.is_none());\n-            let mut idle_watcher = idle_watcher;\n-            idle_watcher.stop();\n-            idle_watcher.close();\n-            f();\n-        }\n-    }\n-\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n-    }\n-}\n-\n-#[test]\n-fn test_callback_run_once() {\n-    do run_in_bare_thread {\n-        let mut event_loop = UvEventLoop::new();\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-        do event_loop.callback {\n-            unsafe { *count_ptr += 1 }\n-        }\n-        event_loop.run();\n-        assert!(count == 1);\n-    }\n-}\n-\n-pub struct UvIoFactory(Loop);\n-\n-impl UvIoFactory {\n-    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n-    }\n-}\n-\n-impl IoFactory for UvIoFactory {\n-    // Connect to an address and return a new stream\n-    // NB: This blocks the task waiting on the connection.\n-    // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n-        // Create a cell in the task to hold the result. We will fill\n-        // the cell before resuming the task.\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-\n-        // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |task| {\n-\n-            rtdebug!(\"connect: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n-            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n-            let task_cell = Cell::new(task);\n-\n-            // Wait for a connection\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connect: in connect callback\");\n-                let maybe_stream = if status.is_none() {\n-                    rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n-                } else {\n-                    rtdebug!(\"status is some\");\n-                    stream_watcher.close(||());\n-                    None\n-                };\n-\n-                // Store the stream in the task's stack\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n-        let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n-    }\n-}\n-\n-pub struct UvTcpListener(TcpWatcher);\n-\n-impl UvTcpListener {\n-    fn watcher(&self) -> TcpWatcher {\n-        match self { &UvTcpListener(w) => w }\n-    }\n-\n-    fn close(&self) {\n-        // XXX: Need to wait until close finishes before returning\n-        self.watcher().as_stream().close(||());\n-    }\n-}\n-\n-impl Drop for UvTcpListener {\n-    fn drop(&self) {\n-        // XXX: Again, this never gets called. Use .close() instead\n-        //self.watcher().as_stream().close(||());\n-    }\n-}\n-\n-impl TcpListener for UvTcpListener {\n-\n-    fn listen(&mut self) -> Option<~StreamObject> {\n-        rtdebug!(\"entering listen\");\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let server_tcp_watcher = self.watcher();\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell::new(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n-                } else {\n-                    None\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-}\n-\n-pub struct UvStream(StreamWatcher);\n-\n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n-    }\n-\n-    fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n-    }\n-\n-    // XXX: finalize isn't working for ~UvStream???\n-    fn close(&self) {\n-        // XXX: Need to wait until this finishes before returning\n-        self.watcher().close(||());\n-    }\n-}\n-\n-impl Drop for UvStream {\n-    fn drop(&self) {\n-        rtdebug!(\"closing stream\");\n-        //self.watcher().close(||());\n-    }\n-}\n-\n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            rtdebug!(\"read: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n-            let mut watcher = watcher;\n-            let task_cell = Cell::new(task);\n-            // XXX: We shouldn't reallocate these callbacks every\n-            // call to read\n-            let alloc: AllocCallback = |_| unsafe {\n-                slice_to_uv_buf(*buf_ptr)\n-            };\n-            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n-\n-                // Stop reading so that no read callbacks are\n-                // triggered before the user calls `read` again.\n-                // XXX: Is there a performance impact to calling\n-                // stop here?\n-                let mut watcher = watcher;\n-                watcher.read_stop();\n-\n-                let result = if status.is_none() {\n-                    assert!(nread >= 0);\n-                    Ok(nread as uint)\n-                } else {\n-                    Err(())\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let mut watcher = watcher;\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { &*buf_ptr };\n-            // XXX: OMGCOPIES\n-            let buf = buf.to_vec();\n-            do watcher.write(buf) |_watcher, status| {\n-                let result = if status.is_none() {\n-                    Ok(())\n-                } else {\n-                    Err(())\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_io_no_connect() {\n-    do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-\n-        // Start the server first so it's listening when we connect\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert!(nread == 8);\n-                for uint::range(0, nread) |i| {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n-                    assert!(buf[i] == i as u8);\n-                }\n-                stream.close();\n-                listener.close();\n-            }\n-        }\n-\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n-        }\n-    }\n-}\n-\n-#[test] #[ignore(reason = \"busted\")]\n-fn test_read_and_block() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for uint::range(0, nread) |i| {\n-                    let val = buf[i] as uint;\n-                    assert!(val == current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                let scheduler = local_sched::take();\n-                // Yield to the other task in hopes that it\n-                // will trigger a read callback while we are\n-                // not ready for it\n-                do scheduler.deschedule_running_task_and_then |task| {\n-                    let task = Cell::new(task);\n-                    do local_sched::borrow |scheduler| {\n-                        scheduler.task_queue.push_back(task.take());\n-                    }\n-                }\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-\n-            stream.close();\n-            listener.close();\n-        }\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n-        }\n-\n-    }\n-}\n-\n-#[test]\n-fn test_read_read_read() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-        static MAX: uint = 500000;\n-\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let buf = [1, .. 2048];\n-                let mut total_bytes_written = 0;\n-                while total_bytes_written < MAX {\n-                    stream.write(buf);\n-                    total_bytes_written += buf.len();\n-                }\n-                stream.close();\n-                listener.close();\n-            }\n-        }\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n-                }\n-            }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n-        }\n-    }\n-}"}, {"sha": "32ccc9ba4a82b7e5a43ae0914d5639284d58ab82", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -293,6 +293,118 @@ rust_uv_tcp_getpeername6\n     return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n }\n \n+extern \"C\" int\n+rust_uv_tcp_getsockname\n+(uv_tcp_t* handle, sockaddr_in* name) {\n+    int namelen = sizeof(sockaddr_in);\n+    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_getsockname6\n+(uv_tcp_t* handle, sockaddr_in6* name) {\n+    int namelen = sizeof(sockaddr_in6);\n+    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_nodelay\n+(uv_tcp_t* handle, int enable) {\n+    return uv_tcp_nodelay(handle, enable);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_keepalive\n+(uv_tcp_t* handle, int enable, unsigned int delay) {\n+    return uv_tcp_keepalive(handle, enable, delay);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_simultaneous_accepts\n+(uv_tcp_t* handle, int enable) {\n+    return uv_tcp_simultaneous_accepts(handle, enable);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n+    return uv_udp_init(loop, handle);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_bind(uv_udp_t* server, sockaddr_in* addr_ptr, unsigned flags) {\n+    return uv_udp_bind(server, *addr_ptr, flags);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_bind6(uv_udp_t* server, sockaddr_in6* addr_ptr, unsigned flags) {\n+    return uv_udp_bind6(server, *addr_ptr, flags);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* buf_in,\n+                 int buf_cnt, sockaddr_in* addr_ptr, uv_udp_send_cb cb) {\n+    return uv_udp_send(req, handle, buf_in, buf_cnt, *addr_ptr, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* buf_in,\n+                  int buf_cnt, sockaddr_in6* addr_ptr, uv_udp_send_cb cb) {\n+    return uv_udp_send6(req, handle, buf_in, buf_cnt, *addr_ptr, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_recv_start(uv_udp_t* server, uv_alloc_cb on_alloc, uv_udp_recv_cb on_read) {\n+    return uv_udp_recv_start(server, on_alloc, on_read);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_recv_stop(uv_udp_t* server) {\n+    return uv_udp_recv_stop(server);\n+}\n+\n+extern \"C\" uv_udp_t*\n+rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n+    return send_req->handle;\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_getsockname\n+(uv_udp_t* handle, sockaddr_in* name) {\n+    int namelen = sizeof(sockaddr_in);\n+    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_getsockname6\n+(uv_udp_t* handle, sockaddr_in6* name) {\n+    int namelen = sizeof(sockaddr_in6);\n+    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_membership\n+(uv_udp_t* handle, const char* m_addr, const char* i_addr, uv_membership membership) {\n+    return uv_udp_set_membership(handle, m_addr, i_addr, membership);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_multicast_loop\n+(uv_udp_t* handle, int on) {\n+    return uv_udp_set_multicast_loop(handle, on);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_multicast_ttl\n+(uv_udp_t* handle, int ttl) {\n+    return uv_udp_set_multicast_ttl(handle, ttl);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_broadcast\n+(uv_udp_t* handle, int on) {\n+    return uv_udp_set_broadcast(handle, on);\n+}\n+\n extern \"C\" int\n rust_uv_listen(uv_stream_t* stream, int backlog,\n         uv_connection_cb cb) {\n@@ -545,10 +657,34 @@ extern \"C\" void\n rust_uv_freeaddrinfo(addrinfo* res) {\n     uv_freeaddrinfo(res);\n }\n+\n+extern \"C\" int\n+rust_uv_is_ipv4_sockaddr(sockaddr* addr) {\n+    return addr->sa_family == AF_INET;\n+}\n+\n+extern \"C\" int\n+rust_uv_is_ipv6_sockaddr(sockaddr* addr) {\n+    return addr->sa_family == AF_INET6;\n+}\n+\n+extern \"C\" sockaddr_in*\n+rust_uv_sockaddr_as_sockaddr_in(sockaddr* addr) {\n+//    return (sockaddr_in*)addr->sa_data;\n+    return (sockaddr_in*)addr;\n+}\n+\n+extern \"C\" sockaddr_in6*\n+rust_uv_sockaddr_as_sockaddr_in6(sockaddr* addr) {\n+    //return (sockaddr_in6*)addr->sa_data;\n+    return (sockaddr_in6*)addr;\n+}\n+\n extern \"C\" bool\n rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET;\n }\n+\n extern \"C\" bool\n rust_uv_is_ipv6_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET6;"}, {"sha": "cd207a0a058e1c9a22c1e3d70e77e2275989d244", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -106,6 +106,29 @@ rust_uv_tcp_connect\n rust_uv_tcp_bind\n rust_uv_tcp_connect6\n rust_uv_tcp_bind6\n+rust_uv_tcp_getsockname\n+rust_uv_tcp_getsockname6\n+rust_uv_tcp_nodelay\n+rust_uv_tcp_keepalive\n+rust_uv_tcp_simultaneous_accepts\n+rust_uv_udp_init\n+rust_uv_udp_bind\n+rust_uv_udp_bind6\n+rust_uv_udp_send\n+rust_uv_udp_send6\n+rust_uv_udp_recv_start\n+rust_uv_udp_recv_stop\n+rust_uv_get_udp_handle_from_send_req\n+rust_uv_udp_getsockname\n+rust_uv_udp_getsockname6\n+rust_uv_udp_set_membership\n+rust_uv_udp_set_multicast_loop\n+rust_uv_udp_set_multicast_ttl\n+rust_uv_udp_set_broadcast\n+rust_uv_is_ipv4_sockaddr\n+rust_uv_is_ipv6_sockaddr\n+rust_uv_sockaddr_as_sockaddr_in\n+rust_uv_sockaddr_as_sockaddr_in6\n rust_uv_listen\n rust_uv_accept\n rust_uv_write"}]}