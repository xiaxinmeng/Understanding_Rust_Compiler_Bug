{"sha": "586f525cf1be21ece404c8718930be0f42ff12b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NmY1MjVjZjFiZTIxZWNlNDA0Yzg3MTg5MzBiZTBmNDJmZjEyYjQ=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2016-02-03T05:12:27Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2016-02-03T05:12:27Z"}, "message": "Merge pull request #780 from sidred/config_path\n\nAdd support for the config-path option", "tree": {"sha": "5b89ecbc475d8510ec3b8037ac2bf47f5a091f2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b89ecbc475d8510ec3b8037ac2bf47f5a091f2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/586f525cf1be21ece404c8718930be0f42ff12b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/586f525cf1be21ece404c8718930be0f42ff12b4", "html_url": "https://github.com/rust-lang/rust/commit/586f525cf1be21ece404c8718930be0f42ff12b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/586f525cf1be21ece404c8718930be0f42ff12b4/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c969ca6fb8367906de3fd028488dd1e973f8ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c969ca6fb8367906de3fd028488dd1e973f8ce3", "html_url": "https://github.com/rust-lang/rust/commit/9c969ca6fb8367906de3fd028488dd1e973f8ce3"}, {"sha": "46242ed10e2430add4ecdaa44ed195cddbee3197", "url": "https://api.github.com/repos/rust-lang/rust/commits/46242ed10e2430add4ecdaa44ed195cddbee3197", "html_url": "https://github.com/rust-lang/rust/commit/46242ed10e2430add4ecdaa44ed195cddbee3197"}], "stats": {"total": 75, "additions": 61, "deletions": 14}, "files": [{"sha": "fed74868f6a81607304c8e86b904663c811969e4", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/586f525cf1be21ece404c8718930be0f42ff12b4/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/586f525cf1be21ece404c8718930be0f42ff12b4/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=586f525cf1be21ece404c8718930be0f42ff12b4", "patch": "@@ -30,7 +30,7 @@ use getopts::{Matches, Options};\n /// Rustfmt operations.\n enum Operation {\n     /// Format files and their child modules.\n-    Format(Vec<PathBuf>, WriteMode),\n+    Format(Vec<PathBuf>, WriteMode, Option<PathBuf>),\n     /// Print the help message.\n     Help,\n     // Print version information\n@@ -40,7 +40,7 @@ enum Operation {\n     /// Invalid program input, including reason.\n     InvalidInput(String),\n     /// No file specified, read from stdin\n-    Stdin(String, WriteMode),\n+    Stdin(String, WriteMode, Option<PathBuf>),\n }\n \n /// Try to find a project file in the given directory and its parents. Returns the path of a the\n@@ -95,6 +95,20 @@ fn resolve_config(dir: &Path) -> io::Result<(Config, Option<PathBuf>)> {\n     Ok((Config::from_toml(&toml), Some(path)))\n }\n \n+/// read the given config file path recursively if present else read the project file path\n+fn match_cli_path_or_file(config_path: Option<PathBuf>,\n+                          input_file: &Path)\n+                          -> io::Result<(Config, Option<PathBuf>)> {\n+\n+    if let Some(config_file) = config_path {\n+        let (toml, path) = try!(resolve_config(config_file.as_ref()));\n+        if path.is_some() {\n+            return Ok((toml, path));\n+        }\n+    }\n+    resolve_config(input_file)\n+}\n+\n fn update_config(config: &mut Config, matches: &Matches) {\n     config.verbose = matches.opt_present(\"verbose\");\n     config.skip_children = matches.opt_present(\"skip-children\");\n@@ -114,6 +128,11 @@ fn execute() -> i32 {\n     opts.optflag(\"\",\n                  \"config-help\",\n                  \"show details of rustfmt configuration options\");\n+    opts.optopt(\"\",\n+                \"config-path\",\n+                \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+                 found reverts to the input file path\",\n+                \"[Path for the configuration file]\");\n \n     let matches = match opts.parse(env::args().skip(1)) {\n         Ok(m) => m,\n@@ -142,23 +161,41 @@ fn execute() -> i32 {\n             Config::print_docs();\n             0\n         }\n-        Operation::Stdin(input, write_mode) => {\n+        Operation::Stdin(input, write_mode, config_path) => {\n             // try to read config from local directory\n-            let (config, _) = resolve_config(&env::current_dir().unwrap())\n+            let (config, _) = match_cli_path_or_file(config_path, &env::current_dir().unwrap())\n                                   .expect(\"Error resolving config\");\n \n             run_from_stdin(input, write_mode, &config);\n             0\n         }\n-        Operation::Format(files, write_mode) => {\n+        Operation::Format(files, write_mode, config_path) => {\n+            let mut config = Config::default();\n+            let mut path = None;\n+            // Load the config path file if provided\n+            if let Some(config_file) = config_path {\n+                let (cfg_tmp, path_tmp) = resolve_config(config_file.as_ref())\n+                                              .expect(&format!(\"Error resolving config for {:?}\",\n+                                                               config_file));\n+                config = cfg_tmp;\n+                path = path_tmp;\n+            };\n+            if let Some(path) = path.as_ref() {\n+                println!(\"Using rustfmt config file {}\", path.display());\n+            }\n             for file in files {\n-                let (mut config, path) = resolve_config(file.parent().unwrap())\n-                                             .expect(&format!(\"Error resolving config for {}\",\n-                                                              file.display()));\n-                if let Some(path) = path {\n-                    println!(\"Using rustfmt config file {} for {}\",\n-                             path.display(),\n-                             file.display());\n+                // Check the file directory if the config-path could not be read or not provided\n+                if path.is_none() {\n+                    let (config_tmp, path_tmp) = resolve_config(file.parent().unwrap())\n+                                                     .expect(&format!(\"Error resolving config \\\n+                                                                       for {}\",\n+                                                                      file.display()));\n+                    if let Some(path) = path_tmp.as_ref() {\n+                        println!(\"Using rustfmt config file {} for {}\",\n+                                 path.display(),\n+                                 file.display());\n+                    }\n+                    config = config_tmp;\n                 }\n \n                 update_config(&mut config, &matches);\n@@ -211,6 +248,16 @@ fn determine_operation(matches: &Matches) -> Operation {\n         return Operation::Version;\n     }\n \n+    // Read the config_path and convert to parent dir if a file is provided.\n+    let config_path: Option<PathBuf> = matches.opt_str(\"config-path\")\n+                                              .map(PathBuf::from)\n+                                              .and_then(|dir| {\n+                                                  if dir.is_file() {\n+                                                      return dir.parent().map(|v| v.into());\n+                                                  }\n+                                                  Some(dir)\n+                                              });\n+\n     // if no file argument is supplied, read from stdin\n     if matches.free.is_empty() {\n \n@@ -221,7 +268,7 @@ fn determine_operation(matches: &Matches) -> Operation {\n         }\n \n         // WriteMode is always plain for Stdin\n-        return Operation::Stdin(buffer, WriteMode::Plain);\n+        return Operation::Stdin(buffer, WriteMode::Plain, config_path);\n     }\n \n     let write_mode = match matches.opt_str(\"write-mode\") {\n@@ -236,5 +283,5 @@ fn determine_operation(matches: &Matches) -> Operation {\n \n     let files: Vec<_> = matches.free.iter().map(PathBuf::from).collect();\n \n-    Operation::Format(files, write_mode)\n+    Operation::Format(files, write_mode, config_path)\n }"}]}