{"sha": "a4af0ec0e3766d0cd016940d33840127ae364238", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YWYwZWMwZTM3NjZkMGNkMDE2OTQwZDMzODQwMTI3YWUzNjQyMzg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-20T20:33:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-20T20:33:12Z"}, "message": "Merge pull request #1729 from topecongiro/single-line-block\n\nAllow single line block in expression context", "tree": {"sha": "5f71f2a2c65ccc8e04a2bf6a74059c1c5dea9088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f71f2a2c65ccc8e04a2bf6a74059c1c5dea9088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4af0ec0e3766d0cd016940d33840127ae364238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4af0ec0e3766d0cd016940d33840127ae364238", "html_url": "https://github.com/rust-lang/rust/commit/a4af0ec0e3766d0cd016940d33840127ae364238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4af0ec0e3766d0cd016940d33840127ae364238/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90251c32ff4b52e3f3ac466d1b16bb91366d21a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/90251c32ff4b52e3f3ac466d1b16bb91366d21a3", "html_url": "https://github.com/rust-lang/rust/commit/90251c32ff4b52e3f3ac466d1b16bb91366d21a3"}, {"sha": "64fc9e31e7e102e15d3d6570ce855b8738f6ace9", "url": "https://api.github.com/repos/rust-lang/rust/commits/64fc9e31e7e102e15d3d6570ce855b8738f6ace9", "html_url": "https://github.com/rust-lang/rust/commit/64fc9e31e7e102e15d3d6570ce855b8738f6ace9"}], "stats": {"total": 270, "additions": 181, "deletions": 89}, "files": [{"sha": "4d2f1cdc041c6408d86801fc29c7c3430264d075", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -79,7 +79,10 @@ impl CliOptions {\n                 ));\n             }\n         } else {\n-            println!(\"Warning: the default write-mode for Rustfmt will soon change to overwrite - this will not leave backups of changed files.\");\n+            println!(\n+                \"Warning: the default write-mode for Rustfmt will soon change to overwrite \\\n+                 - this will not leave backups of changed files.\"\n+            );\n         }\n \n         if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {"}, {"sha": "e3c80cd95ca5147024794a69cc5ccdf427d8ddeb", "filename": "src/expr.rs", "status": "modified", "additions": 140, "deletions": 85, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -42,7 +42,7 @@ impl Rewrite for ast::Expr {\n }\n \n #[derive(PartialEq)]\n-enum ExprType {\n+pub enum ExprType {\n     Statement,\n     SubExpression,\n }\n@@ -67,7 +67,7 @@ fn combine_attr_and_expr(\n     format!(\"{}{}{}\", attr_str, separator, expr_str)\n }\n \n-fn format_expr(\n+pub fn format_expr(\n     expr: &ast::Expr,\n     expr_type: ExprType,\n     context: &RewriteContext,\n@@ -160,7 +160,23 @@ fn format_expr(\n             to_control_flow(expr, expr_type)\n                 .and_then(|control_flow| control_flow.rewrite(context, shape))\n         }\n-        ast::ExprKind::Block(ref block) => block.rewrite(context, shape),\n+        ast::ExprKind::Block(ref block) => {\n+            match expr_type {\n+                ExprType::Statement => {\n+                    if is_unsafe_block(block) {\n+                        block.rewrite(context, shape)\n+                    } else {\n+                        // Rewrite block without trying to put it in a single line.\n+                        if let rw @ Some(_) = rewrite_empty_block(context, block, shape) {\n+                            return rw;\n+                        }\n+                        let prefix = try_opt!(block_prefix(context, block, shape));\n+                        rewrite_block_with_visitor(context, &prefix, block, shape)\n+                    }\n+                }\n+                ExprType::SubExpression => block.rewrite(context, shape),\n+            }\n+        }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n             rewrite_match(context, cond, arms, shape, expr.span)\n         }\n@@ -290,7 +306,9 @@ fn format_expr(\n             )\n         }\n         ast::ExprKind::Catch(ref block) => {\n-            if let rewrite @ Some(_) = try_one_line_block(context, shape, \"do catch \", block) {\n+            if let rewrite @ Some(_) =\n+                rewrite_single_line_block(context, \"do catch \", block, shape)\n+            {\n                 return rewrite;\n             }\n             // 9 = `do catch `\n@@ -315,23 +333,6 @@ fn format_expr(\n     }\n }\n \n-fn try_one_line_block(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    prefix: &str,\n-    block: &ast::Block,\n-) -> Option<String> {\n-    if is_simple_block(block, context.codemap) {\n-        let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n-        let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n-        let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n-        if result.len() <= shape.width && !result.contains('\\n') {\n-            return Some(result);\n-        }\n-    }\n-    None\n-}\n-\n pub fn rewrite_pair<LHS, RHS>(\n     lhs: &LHS,\n     rhs: &RHS,\n@@ -763,78 +764,124 @@ fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String\n     })\n }\n \n-impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        // shape.width is used only for the single line case: either the empty block `{}`,\n-        // or an unsafe expression `unsafe { e }`.\n+fn rewrite_empty_block(\n+    context: &RewriteContext,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) &&\n+        shape.width >= 2\n+    {\n+        return Some(\"{}\".to_owned());\n+    }\n \n-        if self.stmts.is_empty() && !block_contains_comment(self, context.codemap) &&\n-            shape.width >= 2\n+    // If a block contains only a single-line comment, then leave it on one line.\n+    let user_str = context.snippet(block.span);\n+    let user_str = user_str.trim();\n+    if user_str.starts_with('{') && user_str.ends_with('}') {\n+        let comment_str = user_str[1..user_str.len() - 1].trim();\n+        if block.stmts.is_empty() && !comment_str.contains('\\n') &&\n+            !comment_str.starts_with(\"//\") && comment_str.len() + 4 <= shape.width\n         {\n-            return Some(\"{}\".to_owned());\n+            return Some(format!(\"{{ {} }}\", comment_str));\n         }\n+    }\n \n-        // If a block contains only a single-line comment, then leave it on one line.\n-        let user_str = context.snippet(self.span);\n-        let user_str = user_str.trim();\n-        if user_str.starts_with('{') && user_str.ends_with('}') {\n-            let comment_str = user_str[1..user_str.len() - 1].trim();\n-            if self.stmts.is_empty() && !comment_str.contains('\\n') &&\n-                !comment_str.starts_with(\"//\") &&\n-                comment_str.len() + 4 <= shape.width\n-            {\n-                return Some(format!(\"{{ {} }}\", comment_str));\n+    None\n+}\n+\n+fn block_prefix(context: &RewriteContext, block: &ast::Block, shape: Shape) -> Option<String> {\n+    Some(match block.rules {\n+        ast::BlockCheckMode::Unsafe(..) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            // Extract comment between unsafe and block start.\n+            let trimmed = &snippet[6..open_pos].trim();\n+\n+            if !trimmed.is_empty() {\n+                // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n+                let budget = try_opt!(shape.width.checked_sub(9));\n+                format!(\n+                    \"unsafe {} \",\n+                    try_opt!(rewrite_comment(\n+                        trimmed,\n+                        true,\n+                        Shape::legacy(budget, shape.indent + 7),\n+                        context.config,\n+                    ))\n+                )\n+            } else {\n+                \"unsafe \".to_owned()\n             }\n         }\n+        ast::BlockCheckMode::Default => String::new(),\n+    })\n+}\n \n-        let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-        visitor.block_indent = shape.indent;\n-        visitor.is_if_else_block = context.is_if_else_block;\n+fn rewrite_single_line_block(\n+    context: &RewriteContext,\n+    prefix: &str,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if is_simple_block(block, context.codemap) {\n+        let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n+        let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n+        let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n+        if result.len() <= shape.width && !result.contains('\\n') {\n+            return Some(result);\n+        }\n+    }\n+    None\n+}\n \n-        let prefix = match self.rules {\n-            ast::BlockCheckMode::Unsafe(..) => {\n-                let snippet = context.snippet(self.span);\n-                let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n-                visitor.last_pos = self.span.lo + BytePos(open_pos as u32);\n+fn rewrite_block_with_visitor(\n+    context: &RewriteContext,\n+    prefix: &str,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, shape) {\n+        return rw;\n+    }\n \n-                // Extract comment between unsafe and block start.\n-                let trimmed = &snippet[6..open_pos].trim();\n+    let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n+    visitor.block_indent = shape.indent;\n+    visitor.is_if_else_block = context.is_if_else_block;\n+    match block.rules {\n+        ast::BlockCheckMode::Unsafe(..) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            visitor.last_pos = block.span.lo + BytePos(open_pos as u32)\n+        }\n+        ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo,\n+    }\n \n-                let prefix = if !trimmed.is_empty() {\n-                    // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n-                    let budget = try_opt!(shape.width.checked_sub(9));\n-                    format!(\n-                        \"unsafe {} \",\n-                        try_opt!(rewrite_comment(\n-                            trimmed,\n-                            true,\n-                            Shape::legacy(budget, shape.indent + 7),\n-                            context.config,\n-                        ))\n-                    )\n-                } else {\n-                    \"unsafe \".to_owned()\n-                };\n-                if let result @ Some(_) = try_one_line_block(context, shape, &prefix, self) {\n-                    return result;\n-                }\n-                prefix\n-            }\n-            ast::BlockCheckMode::Default => {\n-                visitor.last_pos = self.span.lo;\n-                String::new()\n-            }\n-        };\n+    visitor.visit_block(block);\n+    if visitor.failed && shape.indent.alignment != 0 {\n+        block.rewrite(\n+            context,\n+            Shape::indented(shape.indent.block_only(), context.config),\n+        )\n+    } else {\n+        Some(format!(\"{}{}\", prefix, visitor.buffer))\n+    }\n+}\n \n-        visitor.visit_block(self);\n-        if visitor.failed && shape.indent.alignment != 0 {\n-            self.rewrite(\n-                context,\n-                Shape::indented(shape.indent.block_only(), context.config),\n-            )\n-        } else {\n-            Some(format!(\"{}{}\", prefix, visitor.buffer))\n+impl Rewrite for ast::Block {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        // shape.width is used only for the single line case: either the empty block `{}`,\n+        // or an unsafe expression `unsafe { e }`.\n+        if let rw @ Some(_) = rewrite_empty_block(context, self, shape) {\n+            return rw;\n         }\n+\n+        let prefix = try_opt!(block_prefix(context, self, shape));\n+        if let rw @ Some(_) = rewrite_single_line_block(context, &prefix, self, shape) {\n+            return rw;\n+        }\n+\n+        rewrite_block_with_visitor(context, &prefix, self, shape)\n     }\n }\n \n@@ -1249,7 +1296,12 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         };\n         let mut block_context = context.clone();\n         block_context.is_if_else_block = self.else_block.is_some();\n-        let block_str = try_opt!(self.block.rewrite(&block_context, block_shape));\n+        let block_str = try_opt!(rewrite_block_with_visitor(\n+            &block_context,\n+            \"\",\n+            self.block,\n+            block_shape,\n+        ));\n \n         let mut result = format!(\"{}{}\", cond_str, block_str);\n \n@@ -1291,7 +1343,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                         width: min(1, shape.width),\n                         ..shape\n                     };\n-                    else_block.rewrite(context, else_shape)\n+                    format_expr(else_block, ExprType::Statement, context, else_shape)\n                 }\n             };\n \n@@ -1658,7 +1710,10 @@ impl Rewrite for ast::Arm {\n                 .unwrap()\n                 .sub_width(comma.len())\n                 .unwrap();\n-            let rewrite = nop_block_collapse(body.rewrite(context, arm_shape), arm_shape.width);\n+            let rewrite = nop_block_collapse(\n+                format_expr(body, ExprType::Statement, context, arm_shape),\n+                arm_shape.width,\n+            );\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n@@ -1693,7 +1748,7 @@ impl Rewrite for ast::Arm {\n         // necessary.\n         let body_shape = try_opt!(shape.block_left(context.config.tab_spaces()));\n         let next_line_body = try_opt!(nop_block_collapse(\n-            body.rewrite(context, body_shape),\n+            format_expr(body, ExprType::Statement, context, body_shape),\n             body_shape.width,\n         ));\n         let indent_str = shape"}, {"sha": "cb68231733ecb0ddaa7410eecb874b3552e8f003", "filename": "src/items.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -17,7 +17,7 @@ use utils::{format_mutability, format_visibility, contains_skip, end_typaram, wr\n             trimmed_last_line_width, colon_spaces, mk_sp};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, list_helper,\n             DefinitiveListTactic, ListTactic, definitive_tactic};\n-use expr::{is_empty_block, is_simple_block_stmt, rewrite_assign_rhs};\n+use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, ExprType};\n use comment::{FindUncommented, contains_comment, rewrite_comment, recover_comment_removed};\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n@@ -352,7 +352,9 @@ impl<'a> FmtVisitor<'a> {\n                         Some(e) => {\n                             let suffix = if semicolon_for_expr(e) { \";\" } else { \"\" };\n \n-                            e.rewrite(\n+                            format_expr(\n+                                &e,\n+                                ExprType::Statement,\n                                 &self.get_context(),\n                                 Shape::indented(self.block_indent, self.config),\n                             ).map(|s| s + suffix)"}, {"sha": "0f574d433fd054b47b8c4e59abf80c21740f3a7f", "filename": "src/visitor.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -17,6 +17,7 @@ use syntax::parse::ParseSess;\n use strings::string_buffer::StringBuffer;\n \n use {Indent, Shape};\n+use expr::{format_expr, ExprType};\n use utils::{self, mk_sp};\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{contains_comment, FindUncommented};\n@@ -87,7 +88,20 @@ impl<'a> FmtVisitor<'a> {\n                 );\n                 self.push_rewrite(stmt.span, rewrite);\n             }\n-            ast::StmtKind::Expr(ref expr) |\n+            ast::StmtKind::Expr(ref expr) => {\n+                let rewrite = format_expr(\n+                    expr,\n+                    ExprType::Statement,\n+                    &self.get_context(),\n+                    Shape::indented(self.block_indent, self.config),\n+                );\n+                let span = if expr.attrs.is_empty() {\n+                    stmt.span\n+                } else {\n+                    mk_sp(expr.attrs[0].span.lo, stmt.span.hi)\n+                };\n+                self.push_rewrite(span, rewrite)\n+            }\n             ast::StmtKind::Semi(ref expr) => {\n                 let rewrite = stmt.rewrite(\n                     &self.get_context(),"}, {"sha": "80e4f2b623f8605b0ea571b4c829e47c0cecf0f5", "filename": "tests/source/expr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -299,3 +299,12 @@ fn issue1106() {\n         .filter_entry(|entry| exclusions.filter_entry(entry)) {\n     }\n }\n+\n+fn issue1570() {\n+    a_very_long_function_name({some_func(1, {1})})\n+}\n+\n+fn issue1714() {\n+    v = &mut {v}[mid..];\n+    let (left, right) = {v}.split_at_mut(mid);\n+}"}, {"sha": "b650904071430c7340d2255f91c734e293cef8ad", "filename": "tests/target/expr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4af0ec0e3766d0cd016940d33840127ae364238/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af0ec0e3766d0cd016940d33840127ae364238/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=a4af0ec0e3766d0cd016940d33840127ae364238", "patch": "@@ -358,3 +358,12 @@ fn issue1106() {\n         .filter_entry(|entry| exclusions.filter_entry(entry))\n     {}\n }\n+\n+fn issue1570() {\n+    a_very_long_function_name({ some_func(1, { 1 }) })\n+}\n+\n+fn issue1714() {\n+    v = &mut { v }[mid..];\n+    let (left, right) = { v }.split_at_mut(mid);\n+}"}]}