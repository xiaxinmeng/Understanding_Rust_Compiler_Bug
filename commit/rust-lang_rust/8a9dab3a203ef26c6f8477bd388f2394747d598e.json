{"sha": "8a9dab3a203ef26c6f8477bd388f2394747d598e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOWRhYjNhMjAzZWYyNmM2Zjg0NzdiZDM4OGYyMzk0NzQ3ZDU5OGU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T12:36:00Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T23:44:44Z"}, "message": "Remove *Space wrappers in favor of direct impls or functions", "tree": {"sha": "1d358fcc19c0def2b17f943478e05694882701ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d358fcc19c0def2b17f943478e05694882701ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a9dab3a203ef26c6f8477bd388f2394747d598e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9dab3a203ef26c6f8477bd388f2394747d598e", "html_url": "https://github.com/rust-lang/rust/commit/8a9dab3a203ef26c6f8477bd388f2394747d598e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a9dab3a203ef26c6f8477bd388f2394747d598e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec349bef24dc6faf41970bc7de17d22bce6a7cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec349bef24dc6faf41970bc7de17d22bce6a7cfb", "html_url": "https://github.com/rust-lang/rust/commit/ec349bef24dc6faf41970bc7de17d22bce6a7cfb"}], "stats": {"total": 193, "additions": 84, "deletions": 109}, "files": [{"sha": "fafd43cb60b69a4cb72a6e83ef8e1a71ba348746", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 43, "deletions": 68, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8a9dab3a203ef26c6f8477bd388f2394747d598e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9dab3a203ef26c6f8477bd388f2394747d598e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8a9dab3a203ef26c6f8477bd388f2394747d598e", "patch": "@@ -108,28 +108,6 @@ impl Buffer {\n     }\n }\n \n-/// Helper to render an optional visibility with a space after it (if the\n-/// visibility is preset)\n-#[derive(Copy, Clone)]\n-pub struct VisSpace<'a>(pub &'a clean::Visibility);\n-/// Similarly to VisSpace, this structure is used to render a function style with a\n-/// space after it.\n-#[derive(Copy, Clone)]\n-pub struct UnsafetySpace(pub hir::Unsafety);\n-/// Similarly to VisSpace, this structure is used to render a function constness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct ConstnessSpace(pub hir::Constness);\n-/// Similarly to VisSpace, this structure is used to render a function asyncness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct AsyncSpace(pub hir::IsAsync);\n-/// Similar to VisSpace, but used for mutability\n-#[derive(Copy, Clone)]\n-pub struct MutableSpace(pub clean::Mutability);\n-pub struct AbiSpace(pub Abi);\n-pub struct DefaultSpace(pub bool);\n-\n /// Wrapper struct for properly emitting a function or method declaration.\n pub struct Function<'a> {\n     /// The declaration to emit.\n@@ -638,12 +616,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n+                       decl.unsafety.print_with_space(),\n+                       print_abi_with_space(decl.abi),\n                        decl.print_generic_params(),\n                        decl.decl.print())\n             } else {\n-                write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n+                write!(f, \"{}{}\",\n+                    decl.unsafety.print_with_space(), print_abi_with_space(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n                 write!(f, \"{}{}\", decl.print_generic_params(), decl.decl.print())\n             }\n@@ -705,7 +684,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 Some(l) => format!(\"{} \", l.print()),\n                 _ => String::new()\n             };\n-            let m = MutableSpace(mutability);\n+            let m = mutability.print_with_space();\n             let amp = if f.alternate() {\n                 \"&\".to_string()\n             } else {\n@@ -956,13 +935,13 @@ impl Function<'_> {\n                         }\n                         clean::SelfBorrowed(Some(ref lt), mtbl) => {\n                             args.push_str(\n-                                &format!(\"{}{} {}self\", amp, lt.print(), MutableSpace(mtbl)));\n+                                &format!(\"{}{} {}self\", amp, lt.print(), mtbl.print_with_space()));\n                             args_plain.push_str(\n-                                &format!(\"&{} {}self\", lt.print(), MutableSpace(mtbl)));\n+                                &format!(\"&{} {}self\", lt.print(), mtbl.print_with_space()));\n                         }\n                         clean::SelfBorrowed(None, mtbl) => {\n-                            args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n-                            args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n+                            args.push_str(&format!(\"{}{}self\", amp, mtbl.print_with_space()));\n+                            args_plain.push_str(&format!(\"&{}self\", mtbl.print_with_space()));\n                         }\n                         clean::SelfExplicit(ref typ) => {\n                             if f.alternate() {\n@@ -1032,14 +1011,8 @@ impl Function<'_> {\n     }\n }\n \n-impl<'a> fmt::Display for VisSpace<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.0.print_with_space(), f)\n-    }\n-}\n-\n impl clean::Visibility {\n-    fn print_with_space(&self) -> impl fmt::Display + '_ {\n+    crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n         display_fn(move |f| {\n             match *self {\n                 clean::Public => f.write_str(\"pub \"),\n@@ -1060,29 +1033,33 @@ impl clean::Visibility {\n     }\n }\n \n-impl fmt::Display for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {\n-            hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n-            hir::Unsafety::Normal => Ok(())\n+crate trait PrintWithSpace {\n+    fn print_with_space(&self) -> &str;\n+}\n+\n+impl PrintWithSpace for hir::Unsafety {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Unsafety::Unsafe => \"unsafe \",\n+            hir::Unsafety::Normal => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for ConstnessSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {\n-            hir::Constness::Const => write!(f, \"const \"),\n-            hir::Constness::NotConst => Ok(())\n+impl PrintWithSpace for hir::Constness {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Constness::Const => \"const \",\n+            hir::Constness::NotConst => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for AsyncSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {\n-            hir::IsAsync::Async => write!(f, \"async \"),\n-            hir::IsAsync::NotAsync => Ok(()),\n+impl PrintWithSpace for hir::IsAsync {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::IsAsync::Async => \"async \",\n+            hir::IsAsync::NotAsync => \"\",\n         }\n     }\n }\n@@ -1156,32 +1133,30 @@ impl clean::TypeBinding {\n     }\n }\n \n-impl fmt::Display for MutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            MutableSpace(clean::Immutable) => Ok(()),\n-            MutableSpace(clean::Mutable) => write!(f, \"mut \"),\n+impl clean::Mutability {\n+    crate fn print_with_space(&self) -> &str {\n+        match self {\n+            clean::Immutable => \"\",\n+            clean::Mutable => \"mut \",\n         }\n     }\n }\n \n-impl fmt::Display for AbiSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n+    display_fn(move |f| {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n-        match self.0 {\n+        match abi {\n             Abi::Rust => Ok(()),\n             abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n-    }\n+    })\n }\n \n-impl fmt::Display for DefaultSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.0 {\n-            write!(f, \"default \")\n-        } else {\n-            Ok(())\n-        }\n+crate fn print_default_space<'a>(v: bool) -> &'a str {\n+    if v {\n+        \"default \"\n+    } else {\n+        \"\"\n     }\n }\n "}, {"sha": "0b3cf5ea1e226716e4f70de3d7696bb2c6ed1be2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8a9dab3a203ef26c6f8477bd388f2394747d598e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9dab3a203ef26c6f8477bd388f2394747d598e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8a9dab3a203ef26c6f8477bd388f2394747d598e", "patch": "@@ -65,9 +65,9 @@ use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n-use crate::html::format::{Buffer, AsyncSpace, ConstnessSpace};\n-use crate::html::format::{print_generic_bounds, WhereClause, href, AbiSpace, DefaultSpace};\n-use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n+use crate::html::format::{Buffer, PrintWithSpace, print_abi_with_space};\n+use crate::html::format::{print_generic_bounds, WhereClause, href, print_default_space};\n+use crate::html::format::{Function};\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n@@ -2573,13 +2573,13 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, src),\n                                name)\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, name))\n                     }\n                 }\n@@ -2588,7 +2588,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(&myitem.visibility), import.print());\n+                       myitem.visibility.print_with_space(), import.print());\n             }\n \n             _ => {\n@@ -2794,7 +2794,7 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n     render_attributes(w, it, false);\n     write!(w, \"{vis}const \\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n+           vis = it.visibility.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_.print());\n     document(w, cx, it)\n@@ -2805,8 +2805,8 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n     render_attributes(w, it, false);\n     write!(w, \"{vis}static {mutability}\\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           mutability = MutableSpace(s.mutability),\n+           vis = it.visibility.print_with_space(),\n+           mutability = s.mutability.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_.print());\n     document(w, cx, it)\n@@ -2815,11 +2815,11 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        VisSpace(&it.visibility),\n-        ConstnessSpace(f.header.constness),\n-        UnsafetySpace(f.header.unsafety),\n-        AsyncSpace(f.header.asyncness),\n-        AbiSpace(f.header.abi),\n+        it.visibility.print_with_space(),\n+        f.header.constness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n         f.generics.print()\n     ).len();\n@@ -2828,11 +2828,11 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n     write!(w,\n            \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n            {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           constness = ConstnessSpace(f.header.constness),\n-           unsafety = UnsafetySpace(f.header.unsafety),\n-           asyncness = AsyncSpace(f.header.asyncness),\n-           abi = AbiSpace(f.header.abi),\n+           vis = it.visibility.print_with_space(),\n+           constness = f.header.constness.print_with_space(),\n+           unsafety = f.header.unsafety.print_with_space(),\n+           asyncness = f.header.asyncness.print_with_space(),\n+           abi = print_abi_with_space(f.header.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics.print(),\n            where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n@@ -2913,8 +2913,8 @@ fn item_trait(\n         write!(w, \"<pre class='rust trait'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}{}{}trait {}{}{}\",\n-               VisSpace(&it.visibility),\n-               UnsafetySpace(t.unsafety),\n+               it.visibility.print_with_space(),\n+               t.unsafety.print_with_space(),\n                if t.is_auto { \"auto \" } else { \"\" },\n                it.name.as_ref().unwrap(),\n                t.generics.print(),\n@@ -3175,7 +3175,7 @@ fn assoc_const(w: &mut Buffer,\n                extra: &str) {\n     write!(w, \"{}{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            extra,\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n            ty.print());\n@@ -3240,12 +3240,12 @@ fn render_assoc_item(w: &mut Buffer,\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            VisSpace(&meth.visibility),\n-            ConstnessSpace(header.constness),\n-            UnsafetySpace(header.unsafety),\n-            AsyncSpace(header.asyncness),\n-            DefaultSpace(meth.is_default()),\n-            AbiSpace(header.abi),\n+            meth.visibility.print_with_space(),\n+            header.constness.print_with_space(),\n+            header.unsafety.print_with_space(),\n+            header.asyncness.print_with_space(),\n+            print_default_space(meth.is_default()),\n+            print_abi_with_space(header.abi),\n             name,\n             g.print()\n         ).len();\n@@ -3259,12 +3259,12 @@ fn render_assoc_item(w: &mut Buffer,\n         write!(w, \"{}{}{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                if parent == ItemType::Trait { \"    \" } else { \"\" },\n-               VisSpace(&meth.visibility),\n-               ConstnessSpace(header.constness),\n-               UnsafetySpace(header.unsafety),\n-               AsyncSpace(header.asyncness),\n-               DefaultSpace(meth.is_default()),\n-               AbiSpace(header.abi),\n+               meth.visibility.print_with_space(),\n+               header.constness.print_with_space(),\n+               header.unsafety.print_with_space(),\n+               header.asyncness.print_with_space(),\n+               print_default_space(meth.is_default()),\n+               print_abi_with_space(header.abi),\n                href = href,\n                name = name,\n                generics = g.print(),\n@@ -3399,7 +3399,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}enum {}{}{}\",\n-               VisSpace(&it.visibility),\n+               it.visibility.print_with_space(),\n                it.name.as_ref().unwrap(),\n                e.generics.print(),\n                WhereClause { gens: &e.generics, indent: 0, end_newline: true });\n@@ -3588,7 +3588,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n@@ -3605,7 +3605,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"\\n{}    {}{}: {},\",\n                            tab,\n-                           VisSpace(&field.visibility),\n+                           field.visibility.print_with_space(),\n                            field.name.as_ref().unwrap(),\n                            ty.print());\n                     has_visible_fields = true;\n@@ -3635,7 +3635,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                         write!(w, \"_\")\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(&field.visibility), ty.print())\n+                        write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n                     }\n                     _ => unreachable!()\n                 }\n@@ -3662,7 +3662,7 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n                 tab: &str,\n                 structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n@@ -3674,7 +3674,7 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n     for field in fields {\n         if let clean::StructFieldItem(ref ty) = field.inner {\n             write!(w, \"    {}{}: {},\\n{}\",\n-                   VisSpace(&field.visibility),\n+                   field.visibility.print_with_space(),\n                    field.name.as_ref().unwrap(),\n                    ty.print(),\n                    tab);\n@@ -4186,7 +4186,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        VisSpace(&it.visibility),\n+        it.visibility.print_with_space(),\n         it.name.as_ref().unwrap(),\n     );\n "}]}