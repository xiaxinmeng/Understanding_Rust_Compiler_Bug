{"sha": "8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MjlmZDNlNGU1MTg0ODUyMzUyZWExYmIxOGJiMWM4NDY1ZmZhYzM=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-09T22:16:58Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-11T02:25:44Z"}, "message": "Improvements to comments in libstd, libcore, liballoc.", "tree": {"sha": "f6e2daab2a2584e18b8989a89a160ab27c6e548b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6e2daab2a2584e18b8989a89a160ab27c6e548b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "html_url": "https://github.com/rust-lang/rust/commit/8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d71ec1358ac063fe6ff1eaed0ba6ed3cedde610", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d71ec1358ac063fe6ff1eaed0ba6ed3cedde610", "html_url": "https://github.com/rust-lang/rust/commit/9d71ec1358ac063fe6ff1eaed0ba6ed3cedde610"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "cccd51b577930c78a6e6bc452ec60b011c8dd070", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -1198,7 +1198,7 @@ impl<I: Iterator> Peekable<I> {\n     }\n }\n \n-/// An iterator that rejects elements while `predicate` is true.\n+/// An iterator that rejects elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n /// documentation for more.\n@@ -1286,7 +1286,7 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n impl<I, P> FusedIterator for SkipWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n-/// An iterator that only accepts elements while `predicate` is true.\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n /// documentation for more."}, {"sha": "3d2fcdc97937701fc8c16a27b21e47ff88bf3612", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -1111,11 +1111,12 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+//\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n #[derive(Copy)]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n+// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n@@ -1125,13 +1126,13 @@ pub union MaybeUninit<T> {\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n-        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n         *self\n     }\n }\n \n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit<T>` initialized with the given value.\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1239,6 +1240,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n@@ -1277,6 +1279,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]"}, {"sha": "a83134a6b2ca49694ee4a2e0373dc2f29289f4a2", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -326,7 +326,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     round_by_remainder(v, rem, q, z)\n }\n \n-/// Skip over most Algorithm M iterations by checking the bit length.\n+/// Skips over most Algorithm M iterations by checking the bit length.\n fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n     // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)"}, {"sha": "d62cdae0688bea5f6c7bb8261d53b796afbd89e7", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -304,8 +304,8 @@ fn simplify(decimal: &mut Decimal) {\n     }\n }\n \n-/// Quick and dirty upper bound on the size (log10) of the largest value that Algorithm R and\n-/// Algorithm M will compute while working on the given decimal.\n+/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n+/// and Algorithm M will compute while working on the given decimal.\n fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n     // parser, which filter out the most extreme inputs for us.\n@@ -324,7 +324,7 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     }\n }\n \n-/// Detect obvious overflows and underflows without even looking at the decimal digits.\n+/// Detects obvious overflows and underflows without even looking at the decimal digits.\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {"}, {"sha": "f970595452ec9c8ab4f2899bd775212761cab104", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -78,7 +78,7 @@ pub fn parse_decimal(s: &str) -> ParseResult {\n     }\n }\n \n-/// Carve off decimal digits up to the first non-digit character.\n+/// Carves off decimal digits up to the first non-digit character.\n fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n     let mut i = 0;\n     while i < s.len() && b'0' <= s[i] && s[i] <= b'9' {"}, {"sha": "a8da31d3e4858c6eb0cb74494dbf59ff1c863f2b", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -10,7 +10,7 @@ use num::dec2flt::rawfp::RawFloat;\n ///\n /// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n ///   round to the original value. The range is inclusive only when\n-///   `inclusive` is true.\n+///   `inclusive` is `true`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Decoded {\n     /// The scaled mantissa."}, {"sha": "defd4247f4ea49b747d7fbc297ebf78bfa0176f1", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -315,15 +315,15 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n     }\n }\n \n-/// Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form\n-/// with at least given number of significant digits. When `upper` is true,\n+/// Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n+/// form with at least the given number of significant digits. When `upper` is `true`,\n /// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n /// stored to the supplied parts array and a slice of written parts is returned.\n ///\n /// `min_digits` can be less than the number of actual significant digits in `buf`;\n /// it will be ignored and full digits will be printed. It is only used to print\n-/// additional zeroes after rendered digits. Thus `min_digits` of 0 means that\n-/// it will only print given digits and nothing else.\n+/// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n+/// it will only print the given digits and nothing else.\n fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n                          parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n@@ -384,7 +384,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     }\n }\n \n-/// Formats given floating point number into the decimal form with at least\n+/// Formats the given floating point number into the decimal form with at least\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n@@ -438,7 +438,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Formats given floating point number into the decimal form or\n+/// Formats the given floating point number into the decimal form or\n /// the exponential form, depending on the resulting exponent. The result is\n /// stored to the supplied parts array while utilizing given byte buffer\n /// as a scratch. `upper` is used to determine the case of non-finite values\n@@ -497,7 +497,7 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Returns rather crude approximation (upper bound) for the maximum buffer size\n+/// Returns a rather crude approximation (upper bound) for the maximum buffer size\n /// calculated from the given decoded exponent.\n ///\n /// The exact limit is:"}, {"sha": "cf55b6c379d047482a0df491bf422ed1ee9f838f", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -1,4 +1,4 @@\n-//! Types which pin data to its location in memory\n+//! Types that pin data to its location in memory.\n //!\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon."}, {"sha": "528281d317be34b23797774023d5bb58b1c2ac57", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -2968,7 +2968,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3143,7 +3143,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3326,7 +3326,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3402,7 +3402,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///"}, {"sha": "12f812d3bed3eb6582519d1dab8ff6bdd7a407c9", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -108,7 +108,7 @@ impl Waker {\n         unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n+    /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function"}, {"sha": "1d45df499d86b914adf3ecae00967af2f0968d47", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -19,7 +19,7 @@ use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucke\n use super::table::BucketState::{Empty, Full};\n use super::table::Fallibility::{Fallible, Infallible};\n \n-const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n+const MIN_NONZERO_RAW_CAPACITY: usize = 32; // must be a power of two\n \n /// The default behavior of HashMap implements a maximum load factor of 90.9%.\n #[derive(Clone)]"}, {"sha": "1e7d1f1ad58fae8b546ac2c64b11ff60f49d8b24", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -8,7 +8,7 @@ use super::Recover;\n use super::map::{self, HashMap, Keys, RandomState};\n \n // Future Optimization (FIXME!)\n-// =============================\n+// ============================\n //\n // Iteration over zero sized values is a noop. There is no need\n // for `bucket.val` in the case of HashSet. I suppose we would need HKT"}, {"sha": "93cee50af13e5a6aacc2d4c0a3b9ec294829f77e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -211,7 +211,7 @@ pub struct DirBuilder {\n     recursive: bool,\n }\n \n-/// How large a buffer to pre-allocate before reading the entire file.\n+/// Indicates how large a buffer to pre-allocate before reading the entire file.\n fn initial_buffer_size(file: &File) -> usize {\n     // Allocate one extra byte so the buffer doesn't need to grow before the\n     // final `read` call at the end of the file.  Don't worry about `usize`"}, {"sha": "4ad383aa5b613b1e01cd601063ac14866a84eaf1", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -190,7 +190,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -254,7 +254,7 @@ impl Condvar {\n     ///\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex` is `false`, we wait.\n     /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n     /// ```\n     #[unstable(feature = \"wait_until\", issue = \"47960\")]\n@@ -311,7 +311,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex` is `false`, we wait.\n     /// loop {\n     ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -384,7 +384,7 @@ impl Condvar {\n     /// // wait for the thread to start up\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // as long as the value inside the `Mutex` is false, we wait\n+    /// // as long as the value inside the `Mutex` is `false`, we wait\n     /// loop {\n     ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -518,7 +518,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -558,7 +558,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }"}, {"sha": "b38727830f37f11c64a4acb9e858438612c95a50", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8629fd3e4e5184852352ea1bb18bb1c8465ffac3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=8629fd3e4e5184852352ea1bb18bb1c8465ffac3", "patch": "@@ -37,9 +37,9 @@ pub struct Pipes {\n ///\n /// The ours/theirs pipes are *not* specifically readable or writable. Each\n /// one only supports a read or a write, but which is which depends on the\n-/// boolean flag given. If `ours_readable` is true then `ours` is readable where\n-/// `theirs` is writable. Conversely if `ours_readable` is false then `ours` is\n-/// writable where `theirs` is readable.\n+/// boolean flag given. If `ours_readable` is `true`, then `ours` is readable and\n+/// `theirs` is writable. Conversely, if `ours_readable` is `false`, then `ours`\n+/// is writable and `theirs` is readable.\n ///\n /// Also note that the `ours` pipe is always a handle opened up in overlapped\n /// mode. This means that technically speaking it should only ever be used"}]}