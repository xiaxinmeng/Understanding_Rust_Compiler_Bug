{"sha": "bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTNjNDllODQ0ODk1Y2RjMzJkYzZlYTFhY2JmMGM2NTU1YmVlZmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-26T09:31:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T07:58:03Z"}, "message": "basic retagging (no fn_entry); this also makes us catch more bugs even with optimizations and we can finally stop mutating the state on deref", "tree": {"sha": "320b1858fd47e00af7436fcc082283588f549ad0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/320b1858fd47e00af7436fcc082283588f549ad0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "html_url": "https://github.com/rust-lang/rust/commit/bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac0e79ad5bcd8d7e4f8317c15238d5911faf11c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac0e79ad5bcd8d7e4f8317c15238d5911faf11c", "html_url": "https://github.com/rust-lang/rust/commit/7ac0e79ad5bcd8d7e4f8317c15238d5911faf11c"}], "stats": {"total": 161, "additions": 81, "deletions": 80}, "files": [{"sha": "e1ae805fb15f47eaad912fa85ad4adc81c60898e", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -528,9 +528,11 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !ecx.machine.validate {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n             // No tracking, or no retagging. This is possible because a dependency of ours might be\n             // called with different flags than we are,\n+            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n+            // uninitialized data.\n             return Ok(())\n         }\n         ecx.retag(fn_entry, place)"}, {"sha": "cb8c2a3e5e61d4f9d75c1a2a1b9e7561f415430b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,6 +1,6 @@\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n \n-use rustc::ty::{Ty, layout::Size};\n+use rustc::ty::{self, Ty, layout::Size};\n use rustc::hir;\n \n use super::{\n@@ -101,12 +101,12 @@ impl From<Option<hir::Mutability>> for RefKind {\n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n-    clock: Cell<Timestamp>\n+    clock: Timestamp\n }\n \n impl State {\n     pub fn new() -> State {\n-        State { clock: Cell::new(0) }\n+        State { clock: 0 }\n     }\n }\n \n@@ -129,6 +129,7 @@ impl Default for Stack {\n /// Extra per-allocation state\n #[derive(Clone, Debug, Default)]\n pub struct Stacks {\n+    // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n }\n \n@@ -249,9 +250,9 @@ impl<'tcx> Stack {\n }\n \n impl State {\n-    fn increment_clock(&self) -> Timestamp {\n-        let val = self.clock.get();\n-        self.clock.set(val + 1);\n+    fn increment_clock(&mut self) -> Timestamp {\n+        let val = self.clock;\n+        self.clock = val + 1;\n         val\n     }\n }\n@@ -334,14 +335,8 @@ impl<'tcx> Stacks {\n }\n \n pub trait EvalContextExt<'tcx> {\n-    fn tag_for_pointee(\n-        &self,\n-        pointee_ty: Ty<'tcx>,\n-        ref_kind: RefKind,\n-    ) -> Borrow;\n-\n     fn tag_reference(\n-        &self,\n+        &mut self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n@@ -371,13 +366,16 @@ pub trait EvalContextExt<'tcx> {\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n-    fn tag_for_pointee(\n-        &self,\n+    /// Called for place-to-value conversion.\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n+        size: Size,\n         ref_kind: RefKind,\n-    ) -> Borrow {\n+    ) -> EvalResult<'tcx, Borrow> {\n         let time = self.machine.stacked_borrows.increment_clock();\n-        match ref_kind {\n+        let new_bor = match ref_kind {\n             RefKind::Mut => Borrow::Mut(Mut::Uniq(time)),\n             RefKind::Shr =>\n                 // FIXME This does not do enough checking when only part of the data has\n@@ -390,18 +388,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     Borrow::Mut(Mut::Raw)\n                 },\n             RefKind::Raw => Borrow::Mut(Mut::Raw),\n-        }\n-    }\n-\n-    /// Called for place-to-value conversion.\n-    fn tag_reference(\n-        &self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n-        size: Size,\n-        ref_kind: RefKind,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        let new_bor = self.tag_for_pointee(pointee_ty, ref_kind);\n+        };\n         trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n             ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n \n@@ -424,7 +411,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n+        _pointee_ty: Ty<'tcx>,\n         size: Size,\n         ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow> {\n@@ -454,13 +441,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // also using `var`, and that would be okay.\n             }\n             (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n-                // A mut got transmuted to shr.  High time we freeze this location!\n-                // Make this a delayed reborrow.  Redundant reborows to shr are okay,\n-                // so we do not have to be worried about doing too much.\n-                // FIXME: Reconsider if we really want to mutate things while doing just a deref,\n-                // which, in particular, validation does.\n-                trace!(\"tag_dereference: Lazy freezing of {:?}\", ptr);\n-                return self.tag_reference(ptr, pointee_ty, size, ref_kind);\n+                // A mut got transmuted to shr.  The mut borrow must be reactivatable.\n             }\n             (RefKind::Mut, Borrow::Frz(_)) => {\n                 // This is just invalid.\n@@ -516,9 +497,24 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     fn retag(\n         &mut self,\n         _fn_entry: bool,\n-        _place: PlaceTy<'tcx, Borrow>\n+        place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n-        // TODO do something\n+        // For now, we only retag if the toplevel type is a reference.\n+        // TODO: Recurse into structs and enums, sharing code with validation.\n+        let mutbl = match place.layout.ty.sty {\n+            ty::Ref(_, _, mutbl) => mutbl, // go ahead\n+            _ => return Ok(()), // don't do a thing\n+        };\n+        // We want to reborrow the reference stored there. This will call the hooks\n+        // above.  First deref.\n+        // (This is somewhat redundant because validation already did the same thing,\n+        // but what can you do.)\n+        let val = self.read_value(self.place_to_op(place)?)?;\n+        let dest = self.ref_to_mplace(val)?;\n+        // Now put a new ref into the old place.\n+        // FIXME: Honor `fn_entry`!\n+        let val = self.create_ref(dest, Some(mutbl))?;\n+        self.write_value(val, place)?;\n         Ok(())\n     }\n }"}, {"sha": "eb8966f3a5c71659281ca789906e9fa76f9a2346", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,6 +1,3 @@\n-// With optimizations, we just store a raw in `x`, and there is no problem.\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n // This makes a ref that was passed to us via &mut alias with things it should not alias with"}, {"sha": "e86eb9ba6de80b139f40aaf9e193c2aa361ba2e2", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Without retagging, optimization kills finding this problem\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "a4f5f536b770d49255a278b02f5219e682052100", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Without retagging, optimization kills finding this problem\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "f4fefaad5e22ddf82cdfe74b2fc5edbe0ac05a0e", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,6 +1,3 @@\n-// The reborow gets optimized away, so we can only detect this issue without optimizations\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n fn main() {"}, {"sha": "12deb518b4e7ca5e51dd6b9f296e1b0e35188bc8", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,31 +1,13 @@\n-// The compiler inserts some reborrows, enable optimizations to\n-// get rid of them.\n-// compile-flags: -Zmir-opt-level=1\n-\n use std::mem;\n \n-// This is an example of a piece of code that intuitively seems like we might\n-// want to reject it, but that doesn't turn out to be possible.\n-\n fn main() {\n-    let target = 42;\n-    // Make sure a cannot use a raw-tagged `&mut` pointing to a frozen location, not\n-    // even to create a raw.\n-    let reference = &target; // freeze\n+    let mut target = 42;\n+    // Make sure we cannot use a raw-tagged `&mut` pointing to a frozen location.\n+    // Even just creating it unfreezes.\n+    let raw = &mut target as *mut _; // let this leak to raw\n+    let reference = unsafe { &*raw }; // freeze\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n-    let mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n-    // Now we have an &mut to a frozen location, but that is completely normal:\n-    // We'd just unfreeze the location if we used it.\n-    let bad_ptr = mut_ref as *mut i32; // even just creating this is like a use of `mut_ref`.\n-    // That violates the location being frozen!  However, we do not properly detect this:\n-    // We first see a `&mut` with a `Raw` tag being deref'd for a frozen location,\n-    // which can happen legitimately if the compiler optimized away an `&mut*` that\n-    // turns a raw into a `&mut`.  Next, we create a raw ref to a frozen location\n-    // from a `Raw` tag, which can happen legitimately when interior mutability\n-    // is involved.\n-    let _val = *reference; // Make sure it is still frozen.\n-\n-    // We only actually unfreeze once we muteate through the bad pointer.\n-    unsafe { *bad_ptr = 42 }; //~ ERROR does not exist on the stack\n-    let _val = *reference;\n+    let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+    // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n+    let _val = *reference; //~ ERROR Location should be frozen\n }"}, {"sha": "c02822ed4d3dadd9d93c7b91a3e1405ea6b8bf32", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -1,3 +1,11 @@\n+// Optimization kills all the reborrows, enough to make this error go away.  There are\n+// no retags either because we don't retag immediately after a `&[mut]`; we rely on\n+// that creating a fresh reference.\n+// See `shared_confusion_opt.rs` for a variant that is caught even with optimizations.\n+// Keep this test to make sure that without optimizations, we do not have to actually\n+// use the `x_inner_shr`.\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n use std::cell::RefCell;\n \n@@ -9,7 +17,7 @@ fn test(r: &mut RefCell<i32>) {\n     {\n         let x_inner_shr = &*x_inner; // frozen\n         let y = &*r; // outer ref, not freezing\n-        let x_inner_shr2 = &*x_inner; // freezing again\n+        let x_inner_shr = &*x_inner; // freezing again\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack"}, {"sha": "4a88d4d64133d5bd9d254676ad866d6f43391a04", "filename": "tests/compile-fail/stacked_borrows/shared_confusion_opt.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3c49e844895cdc32dc6ea1acbf0c6555beefd/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs?ref=bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "patch": "@@ -0,0 +1,25 @@\n+// A variant of `shared_confusion.rs` that gets flagged even with optimizations.\n+\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+fn test(r: &mut RefCell<i32>) {\n+    let x = &*r; // not freezing because interior mutability\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref; // Uniq reference\n+    let x_evil = x_inner as *mut _;\n+    {\n+        let x_inner_shr = &*x_inner; // frozen\n+        let _val = *x_inner_shr;\n+        let y = &*r; // outer ref, not freezing\n+        let x_inner_shr = &*x_inner; // freezing again\n+        let _val = *x_inner_shr;\n+    }\n+    // Our old raw should be dead by now\n+    unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n+    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n+}\n+\n+fn main() {\n+    test(&mut RefCell::new(0));\n+}"}]}