{"sha": "df4273f8742b2305632916091c2af77128a6e4bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNDI3M2Y4NzQyYjIzMDU2MzI5MTYwOTFjMmFmNzcxMjhhNmU0YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-18T22:42:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-18T22:42:36Z"}, "message": "auto merge of #4996 : luqmana/rust/no-rec-pipes, r=catamorphism\n\nRemoves the last use of structural records in the pipes extension and with that, libcore has no more structural records.\r\nAlso, explicit-self-ification.", "tree": {"sha": "d6bb3f77fa850c4f17f24ef41e63e8fa54e457a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6bb3f77fa850c4f17f24ef41e63e8fa54e457a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df4273f8742b2305632916091c2af77128a6e4bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df4273f8742b2305632916091c2af77128a6e4bf", "html_url": "https://github.com/rust-lang/rust/commit/df4273f8742b2305632916091c2af77128a6e4bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df4273f8742b2305632916091c2af77128a6e4bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1171a214a633128bbbd067bd0e582f8b40172e01", "url": "https://api.github.com/repos/rust-lang/rust/commits/1171a214a633128bbbd067bd0e582f8b40172e01", "html_url": "https://github.com/rust-lang/rust/commit/1171a214a633128bbbd067bd0e582f8b40172e01"}, {"sha": "baeac2f9ac0e64eefe22779d28a421c5f5eadb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/baeac2f9ac0e64eefe22779d28a421c5f5eadb58", "html_url": "https://github.com/rust-lang/rust/commit/baeac2f9ac0e64eefe22779d28a421c5f5eadb58"}], "stats": {"total": 351, "additions": 179, "deletions": 172}, "files": [{"sha": "6638a47ebf84af70e1ce15820eeb6f9a781de8e7", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 86, "deletions": 79, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=df4273f8742b2305632916091c2af77128a6e4bf", "patch": "@@ -67,61 +67,68 @@ pub impl append_types for @ast::path {\n }\n \n pub trait ext_ctxt_ast_builder {\n-    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n-    fn arg(name: ident, ty: @ast::Ty) -> ast::arg;\n-    fn expr_block(e: @ast::expr) -> ast::blk;\n-    fn fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(name: ident, span: span, +node: ast::item_) -> @ast::item;\n-    fn item_fn_poly(name: ident,\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn expr_block(&self, e: @ast::expr) -> ast::blk;\n+    fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n+    fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n                     +body: ast::blk) -> @ast::item;\n-    fn item_fn(name: ident,\n+    fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item;\n-    fn item_enum_poly(name: ident,\n+    fn item_enum_poly(&self, name: ident,\n                       span: span,\n                       +enum_definition: ast::enum_def,\n                       +ty_params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_enum(name: ident, span: span,\n+    fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n-    fn variant(name: ident, span: span, +tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(name: ident, span: span, +items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty;\n-    fn item_ty_poly(name: ident,\n+    fn item_struct_poly(&self, name: ident, span: span,\n+                        struct_def: ast::struct_def,\n+                        ty_params: ~[ast::ty_param]) -> @ast::item;\n+    fn item_struct(&self, name: ident, span: span,\n+                   struct_def: ast::struct_def) -> @ast::item;\n+    fn struct_expr(&self, path: @ast::path,\n+                   fields: ~[ast::field]) -> @ast::expr;\n+    fn variant(&self, name: ident, span: span,\n+               +tys: ~[@ast::Ty]) -> ast::variant;\n+    fn item_mod(&self, name: ident, span: span,\n+                +items: ~[@ast::item]) -> @ast::item;\n+    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty;\n+    fn item_ty_poly(&self, name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_vars_global(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field;\n-    fn ty_rec(+v: ~[ast::ty_field]) -> @ast::Ty;\n-    fn field_imm(name: ident, e: @ast::expr) -> ast::field;\n-    fn rec(+v: ~[ast::field]) -> @ast::expr;\n-    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n-    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n-    fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(b: ast::blk) -> @ast::expr;\n-    fn ty_option(ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer() -> @ast::Ty;\n-    fn ty_nil_ast_builder() -> @ast::Ty;\n-    fn strip_bounds(bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n+    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n+    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n+    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_infer(&self) -> @ast::Ty;\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n+    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n }\n \n pub impl ext_ctxt_ast_builder for ext_ctxt {\n-    fn ty_option(ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(~\"core\"),\n             self.ident_of(~\"option\"),\n             self.ident_of(~\"Option\")\n         ], dummy_sp()).add_ty(ty))\n     }\n \n-    fn block_expr(b: ast::blk) -> @ast::expr {\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n         @expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -130,33 +137,24 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n+    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt {\n         @spanned { node: ast::stmt_expr(e, self.next_id()),\n                    span: dummy_sp()}\n     }\n \n-    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n-        let ext_cx = self;\n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n+        let ext_cx = *self;\n         quote_stmt!( let $ident = $e; )\n     }\n \n-    fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n         spanned {\n             node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n             span: dummy_sp(),\n         }\n     }\n \n-    fn rec(+fields: ~[ast::field]) -> @ast::expr {\n-        @expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_rec(fields, None),\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n         spanned {\n             node: ast::ty_field_ {\n                 ident: name,\n@@ -166,29 +164,21 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_rec(fields),\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_infer() -> @ast::Ty {\n+    fn ty_infer(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_infer,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param\n     {\n         ast::ty_param { ident: id, id: self.next_id(), bounds: @bounds }\n     }\n \n-    fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n         ast::arg {\n             mode: ast::infer(self.next_id()),\n             is_mutbl: false,\n@@ -205,7 +195,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n+    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -217,11 +207,11 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         spanned { node: blk, span: dummy_sp() }\n     }\n \n-    fn expr_block(e: @ast::expr) -> ast::blk {\n+    fn expr_block(&self, e: @ast::expr) -> ast::blk {\n         self.block(~[], e)\n     }\n \n-    fn fn_decl(+inputs: ~[ast::arg],\n+    fn fn_decl(&self, +inputs: ~[ast::arg],\n                output: @ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n@@ -230,8 +220,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn item(name: ident,\n-            span: span,\n+    fn item(&self, name: ident, span: span,\n             +node: ast::item_) -> @ast::item {\n \n         // XXX: Would be nice if our generated code didn't violate\n@@ -254,7 +243,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                      span: span }\n     }\n \n-    fn item_fn_poly(name: ident,\n+    fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n@@ -267,27 +256,46 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                                body))\n     }\n \n-    fn item_fn(name: ident,\n+    fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item {\n         self.item_fn_poly(name, inputs, output, ~[], body)\n     }\n \n-    fn item_enum_poly(name: ident,\n-                      span: span,\n+    fn item_enum_poly(&self, name: ident, span: span,\n                       +enum_definition: ast::enum_def,\n                       +ty_params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_enum(enum_definition, ty_params))\n     }\n \n-    fn item_enum(name: ident, span: span,\n+    fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(name, span, enum_definition, ~[])\n     }\n \n-    fn variant(name: ident,\n-               span: span,\n+    fn item_struct(&self, name: ident, span: span,\n+                   struct_def: ast::struct_def) -> @ast::item {\n+        self.item_struct_poly(name, span, struct_def, ~[])\n+    }\n+\n+    fn item_struct_poly(&self, name: ident, span: span,\n+                        struct_def: ast::struct_def,\n+                        ty_params: ~[ast::ty_param]) -> @ast::item {\n+        self.item(name, span, ast::item_struct(@struct_def, ty_params))\n+    }\n+\n+    fn struct_expr(&self, path: @ast::path,\n+                   fields: ~[ast::field]) -> @ast::expr {\n+        @ast::expr {\n+            id: self.next_id(),\n+            callee_id: self.next_id(),\n+            node: ast::expr_struct(path, fields, None),\n+            span: dummy_sp()\n+        }\n+    }\n+\n+    fn variant(&self, name: ident, span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant {\n         let args = do tys.map |ty| {\n             ast::variant_arg { ty: *ty, id: self.next_id() }\n@@ -300,14 +308,15 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                 kind: ast::tuple_variant_kind(args),\n                 id: self.next_id(),\n                 disr_expr: None,\n-                vis: ast::public},\n+                vis: ast::public\n+            },\n             span: span,\n         }\n     }\n \n-    fn item_mod(name: ident,\n-                span: span,\n+    fn item_mod(&self, name: ident, span: span,\n                 +items: ~[@ast::item]) -> @ast::item {\n+\n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_import(~[\n@@ -345,45 +354,43 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         )\n     }\n \n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty {\n+    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),\n             span: path.span,\n         }\n     }\n \n-    fn ty_nil_ast_builder() -> @ast::Ty {\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn strip_bounds(bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n+    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n         do bounds.map |ty_param| {\n             ast::ty_param { bounds: @~[], ..copy *ty_param }\n         }\n     }\n \n-    fn item_ty_poly(name: ident,\n-                    span: span,\n-                    ty: @ast::Ty,\n+    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_ty(ty, params))\n     }\n \n-    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n         self.item_ty_poly(name, span, ty, ~[])\n     }\n \n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n             path(~[p.ident], dummy_sp())))\n     }\n \n-    fn ty_vars_global(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n             path(~[p.ident], dummy_sp())))\n     }"}, {"sha": "4676b5ed39363067dd2a83cd789eb2986d5fa7df", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=df4273f8742b2305632916091c2af77128a6e4bf", "patch": "@@ -38,10 +38,10 @@ use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n pub impl proto::visitor<(), (), ()> for ext_ctxt {\n-    fn visit_proto(_proto: protocol,\n+    fn visit_proto(&self, _proto: protocol,\n                    _states: &[()]) { }\n \n-    fn visit_state(state: state, _m: &[()]) {\n+    fn visit_state(&self, state: state, _m: &[()]) {\n         if state.messages.len() == 0 {\n             self.span_warn(\n                 state.span, // use a real span!\n@@ -51,7 +51,7 @@ pub impl proto::visitor<(), (), ()> for ext_ctxt {\n         }\n     }\n \n-    fn visit_message(name: ~str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(next_state { state: ref next, tys: next_tys }) => {"}, {"sha": "7c17660cea7681e37b4df28c2693f2ec93f52a08", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=df4273f8742b2305632916091c2af77128a6e4bf", "patch": "@@ -17,13 +17,13 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(id: ~str) -> protocol;\n-    fn parse_state(proto: protocol);\n-    fn parse_message(state: state);\n+    fn parse_proto(&self, id: ~str) -> protocol;\n+    fn parse_state(&self, proto: protocol);\n+    fn parse_message(&self, state: state);\n }\n \n pub impl proto_parser for parser::Parser {\n-    fn parse_proto(id: ~str) -> protocol {\n+    fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n \n         self.parse_seq_to_before_end(token::EOF,\n@@ -33,7 +33,7 @@ pub impl proto_parser for parser::Parser {\n         return proto;\n     }\n \n-    fn parse_state(proto: protocol) {\n+    fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n         let name = *self.interner.get(id);\n \n@@ -63,7 +63,7 @@ pub impl proto_parser for parser::Parser {\n             |self| self.parse_message(state));\n     }\n \n-    fn parse_message(state: state) {\n+    fn parse_message(&self, state: state) {\n         let mname = *self.interner.get(self.parse_ident());\n \n         let args = if self.token == token::LPAREN {"}, {"sha": "77164803caa610663e409a7af3e6aa3819349884", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=df4273f8742b2305632916091c2af77128a6e4bf", "patch": "@@ -27,28 +27,29 @@ use core::to_str::ToStr;\n use core::vec;\n \n pub trait gen_send {\n-    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item;\n-    fn to_ty(cx: ext_ctxt) -> @ast::Ty;\n+    fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item;\n+    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty;\n }\n \n pub trait to_type_decls {\n-    fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item];\n+    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item];\n+    fn to_endpoint_decls(&self, cx: ext_ctxt,\n+                         dir: direction) -> ~[@ast::item];\n }\n \n pub trait gen_init {\n-    fn gen_init(cx: ext_ctxt) -> @ast::item;\n-    fn compile(cx: ext_ctxt) -> @ast::item;\n-    fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty;\n-    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item;\n-    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr;\n-    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr;\n+    fn gen_init(&self, cx: ext_ctxt) -> @ast::item;\n+    fn compile(&self, cx: ext_ctxt) -> @ast::item;\n+    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty;\n+    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item;\n+    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr;\n+    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr;\n }\n \n pub impl gen_send for message {\n-    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n+    fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n-        match self {\n+        match *self {\n           message(ref _id, span, tys, this,\n                   Some(next_state {state: ref next, tys: next_tys})) => {\n             debug!(\"pipec: next state exists\");\n@@ -195,14 +196,14 @@ pub impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(cx: ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars_global(self.get_params())))\n     }\n }\n \n pub impl to_type_decls for state {\n-    fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n+    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n@@ -253,7 +254,8 @@ pub impl to_type_decls for state {\n         ]\n     }\n \n-    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n+    fn to_endpoint_decls(&self, cx: ext_ctxt,\n+                         dir: direction) -> ~[@ast::item] {\n         debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n           send => (*self).dir,\n@@ -306,7 +308,7 @@ pub impl to_type_decls for state {\n }\n \n pub impl gen_init for protocol {\n-    fn gen_init(cx: ext_ctxt) -> @ast::item {\n+    fn gen_init(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n         debug!(\"gen_init\");\n@@ -344,8 +346,10 @@ pub impl gen_init for protocol {\n                            body.to_source(cx)))\n     }\n \n-    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n-        ext_cx.rec(self.states.map_to_vec(|s| {\n+    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr {\n+        ext_cx.struct_expr(path(~[ext_cx.ident_of(~\"__Buffer\")],\n+                                dummy_sp()),\n+                      self.states.map_to_vec(|s| {\n             let fty = s.to_ty(ext_cx);\n             ext_cx.field_imm(ext_cx.ident_of(s.name),\n                              quote_expr!(\n@@ -354,7 +358,7 @@ pub impl gen_init for protocol {\n         }))\n     }\n \n-    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n+    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n         let buffer = quote_expr!(~::pipes::Buffer {\n@@ -380,7 +384,7 @@ pub impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n@@ -396,7 +400,7 @@ pub impl gen_init for protocol {\n                                .add_tys(cx.ty_vars_global(params)))\n     }\n \n-    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item {\n+    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: ~[ast::ty_param] = ~[];\n         let fields = do (copy self.states).map_to_vec |s| {\n@@ -409,17 +413,31 @@ pub impl gen_init for protocol {\n             let ty = s.to_ty(cx);\n             let fty = quote_ty!( ::pipes::Packet<$ty> );\n \n-            cx.ty_field_imm(cx.ident_of(s.name), fty)\n+            @spanned {\n+                node: ast::struct_field_ {\n+                    kind: ast::named_field(\n+                            cx.ident_of(s.name),\n+                            ast::struct_immutable,\n+                            ast::inherited),\n+                    id: cx.next_id(),\n+                    ty: fty\n+                },\n+                span: dummy_sp()\n+            }\n         };\n \n-        cx.item_ty_poly(\n+        cx.item_struct_poly(\n             cx.ident_of(~\"__Buffer\"),\n             dummy_sp(),\n-            cx.ty_rec(fields),\n+            ast::struct_def {\n+                fields: fields,\n+                dtor: None,\n+                ctor_id: None\n+            },\n             cx.strip_bounds(params))\n     }\n \n-    fn compile(cx: ext_ctxt) -> @ast::item {\n+    fn compile(&self, cx: ext_ctxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n         let mut server_states = ~[];"}, {"sha": "da67e48dfa6e6cf1c4e5dd8fcf409e205309cd05", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 41, "deletions": 59, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4273f8742b2305632916091c2af77128a6e4bf/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=df4273f8742b2305632916091c2af77128a6e4bf", "patch": "@@ -19,20 +19,9 @@ use core::cmp;\n use core::dvec::DVec;\n use core::to_str::ToStr;\n \n+#[deriving_eq]\n pub enum direction { send, recv }\n \n-pub impl cmp::Eq for direction {\n-    pure fn eq(&self, other: &direction) -> bool {\n-        match ((*self), (*other)) {\n-            (send, send) => true,\n-            (recv, recv) => true,\n-            (send, _) => false,\n-            (recv, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &direction) -> bool { !(*self).eq(other) }\n-}\n-\n pub impl ToStr for direction {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n@@ -43,8 +32,8 @@ pub impl ToStr for direction {\n }\n \n pub impl direction {\n-    fn reverse() -> direction {\n-        match self {\n+    fn reverse(&self) -> direction {\n+        match *self {\n           send => recv,\n           recv => send\n         }\n@@ -62,64 +51,64 @@ pub enum message {\n }\n \n pub impl message {\n-    fn name() -> ~str {\n-        match self {\n+    fn name(&self) -> ~str {\n+        match *self {\n           message(ref id, _, _, _, _) => (*id)\n         }\n     }\n \n-    fn span() -> span {\n-        match self {\n+    fn span(&self) -> span {\n+        match *self {\n           message(_, span, _, _, _) => span\n         }\n     }\n \n     /// Return the type parameters actually used by this message\n-    fn get_params() -> ~[ast::ty_param] {\n-        match self {\n+    fn get_params(&self) -> ~[ast::ty_param] {\n+        match *self {\n           message(_, _, _, this, _) => this.ty_params\n         }\n     }\n }\n \n-pub enum state {\n-    state_(@{\n-        id: uint,\n-        name: ~str,\n-        ident: ast::ident,\n-        span: span,\n-        dir: direction,\n-        ty_params: ~[ast::ty_param],\n-        messages: DVec<message>,\n-        proto: protocol,\n-    }),\n+pub type state = @state_;\n+\n+pub struct state_ {\n+    id: uint,\n+    name: ~str,\n+    ident: ast::ident,\n+    span: span,\n+    dir: direction,\n+    ty_params: ~[ast::ty_param],\n+    messages: DVec<message>,\n+    proto: protocol\n }\n \n-pub impl state {\n-    fn add_message(name: ~str, span: span,\n+pub impl state_ {\n+    fn add_message(@self, name: ~str, span: span,\n                    +data: ~[@ast::Ty], next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n \n-    fn filename() -> ~str {\n-        (*self).proto.filename()\n+    fn filename(&self) -> ~str {\n+        self.proto.filename()\n     }\n \n-    fn data_name() -> ast::ident {\n+    fn data_name(&self) -> ast::ident {\n         self.ident\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(cx: ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(self.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n-    fn reachable(f: fn(state) -> bool) {\n+    fn reachable(&self, f: fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n@@ -157,68 +146,61 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(name: ~str) -> state {\n+    fn get_state(&self, name: ~str) -> state {\n         self.states.find(|i| i.name == name).get()\n     }\n \n-    fn get_state_by_id(id: uint) -> state { self.states[id] }\n+    fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(name: ~str) -> bool {\n+    fn has_state(&self, name: ~str) -> bool {\n         self.states.find(|i| i.name == name).is_some()\n     }\n \n-    fn filename() -> ~str {\n+    fn filename(&self) -> ~str {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states() -> uint { self.states.len() }\n+    fn num_states(&self) -> uint { self.states.len() }\n \n-    fn has_ty_params() -> bool {\n+    fn has_ty_params(&self) -> bool {\n         for self.states.each |s| {\n             if s.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n         false\n     }\n-    fn is_bounded() -> bool {\n+    fn is_bounded(&self) -> bool {\n         let bounded = self.bounded.get();\n         bounded\n-        //if bounded && self.has_ty_params() {\n-        //    debug!(\"protocol %s has is bounded, but type parameters\\\n-        //            are not yet supported.\",\n-        //           *self.name);\n-        //    false\n-        //}\n-        //else { bounded }\n     }\n }\n \n pub impl protocol {\n-    fn add_state_poly(name: ~str, ident: ast::ident, dir: direction,\n+    fn add_state_poly(&self, name: ~str, ident: ast::ident, dir: direction,\n                       +ty_params: ~[ast::ty_param]) -> state {\n         let messages = DVec();\n \n-        let state = state_(@{\n+        let state = @state_ {\n             id: self.states.len(),\n             name: name,\n             ident: ident,\n             span: self.span,\n             dir: dir,\n             ty_params: ty_params,\n             messages: messages,\n-            proto: self\n-        });\n+            proto: *self\n+        };\n \n         self.states.push(state);\n         state\n     }\n }\n \n pub trait visitor<Tproto, Tstate, Tmessage> {\n-    fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n-    fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(name: ~str, spane: span, tys: &[@ast::Ty],\n+    fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n+    fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n+    fn visit_message(&self, name: ~str, spane: span, tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}]}