{"sha": "c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNmQxN2RlNGQ4N2Y1YmFiYTk1YjEzZDJiMWVjNzBlNjUyZjBmZTQ=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-08-02T06:18:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-02T06:18:24Z"}, "message": "Merge pull request #152 from rust-lang/feature/const_eval_checked\n\nFeature/const eval checked\r\nAdds the const_evaluatable_checked cargo feature for some experimental (but very useful) function implementations. Adds testing all cargo features to CI.", "tree": {"sha": "2f66f8339f8c4d5cecab9b34994ec783f77f7640", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f66f8339f8c4d5cecab9b34994ec783f77f7640"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhB44wCRBK7hj4Ov3rIwAAub0IAAc93jQqkNo25NpoJcnw2n53\nHNyzCi5oq0hEBZwbbd3FEn/pi/VPd0HNs9Ugyz/MrZVeS8eL4zDy9yJh3MDrp8nY\nFDZwmhsnCwWyUxYlCNmCwtv+C4Xdz3iqiz0QErJzcSV1zBuTZSQnnZExnpp41QIL\n6OYfzAZuT9Kdr6o35DgUDAX6UEyy1xhR/i5Y8oXighSCWwJCiE55zkwd6wMp+f7x\nellNnTc18u5P6sthSTs7hSCHO4HEWZ+JyYbcSpgqY1O7gTcof25kQKHbEZZFmNok\ngH2/spvewuk8eHSxqpufNddCwowQeR+WhPWImEs+0zw7CN8lACxsXU1gRu8Hyvo=\n=R9iJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f66f8339f8c4d5cecab9b34994ec783f77f7640\nparent 82e3405efe5ffd2bc214d32b581d5cfc1157eb8d\nparent cca91024298b92f5bff5fc7353155aff0eef38e5\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1627885104 -0700\ncommitter GitHub <noreply@github.com> 1627885104 -0700\n\nMerge pull request #152 from rust-lang/feature/const_eval_checked\n\nFeature/const eval checked\r\nAdds the const_evaluatable_checked cargo feature for some experimental (but very useful) function implementations. Adds testing all cargo features to CI."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "html_url": "https://github.com/rust-lang/rust/commit/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "html_url": "https://github.com/rust-lang/rust/commit/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d"}, {"sha": "cca91024298b92f5bff5fc7353155aff0eef38e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca91024298b92f5bff5fc7353155aff0eef38e5", "html_url": "https://github.com/rust-lang/rust/commit/cca91024298b92f5bff5fc7353155aff0eef38e5"}], "stats": {"total": 457, "additions": 239, "deletions": 218}, "files": [{"sha": "454bc315475161315d92f9f2705abd805a5ce865", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -196,3 +196,28 @@ jobs:\n       - name: Test (release)\n         run: cross test --verbose --target=${{ matrix.target }} --release\n \n+  features:\n+    name: \"Check cargo features (${{ matrix.features }} ${{ matrix.rustflags }})\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        rustflags:\n+          - \"\"\n+          - \"-Ctarget-feature=+avx512\" # AVX-512 uses packed bit masks, so enable it to test more code paths\n+        features:\n+          - \"\"\n+          - \"--features std\"\n+          - \"--features const_evaluatable_checked\"\n+          - \"--features std --features const_evaluatable_checked\"\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+      - name: Check build\n+        run: cargo check --all-targets --no-default-features ${{ matrix.features }}\n+        env:\n+            RUSTFLAGS: ${{ matrix.rustflags }}"}, {"sha": "764b199d5bf96a84f8b3625956d31222f8069df0", "filename": "crates/core_simd/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2FCargo.toml?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -10,8 +10,9 @@ categories = [\"hardware-support\", \"no-std\"]\n license = \"MIT OR Apache-2.0\"\n \n [features]\n-default = [\"std\"]\n+default = [\"std\", \"const_evaluatable_checked\"]\n std = []\n+const_evaluatable_checked = []\n \n [target.'cfg(target_arch = \"wasm32\")'.dev-dependencies.wasm-bindgen]\n version = \"0.2\""}, {"sha": "779575985ed9ed933b67cf4ea1b503e5201950e6", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 151, "deletions": 142, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -1,169 +1,173 @@\n-#![feature(portable_simd)]\n+#![cfg_attr(feature = \"std\", feature(portable_simd))]\n \n /// Benchmarks game nbody code\n /// Taken from the `packed_simd` crate\n /// Run this benchmark with `cargo test --example nbody`\n-use core_simd::*;\n+#[cfg(feature = \"std\")]\n+mod nbody {\n+    use core_simd::*;\n \n-use std::f64::consts::PI;\n-const SOLAR_MASS: f64 = 4.0 * PI * PI;\n-const DAYS_PER_YEAR: f64 = 365.24;\n+    use std::f64::consts::PI;\n+    const SOLAR_MASS: f64 = 4.0 * PI * PI;\n+    const DAYS_PER_YEAR: f64 = 365.24;\n \n-#[derive(Debug, Clone, Copy)]\n-pub struct Body {\n-    pub x: f64x4,\n-    pub v: f64x4,\n-    pub mass: f64,\n-}\n+    #[derive(Debug, Clone, Copy)]\n+    struct Body {\n+        pub x: f64x4,\n+        pub v: f64x4,\n+        pub mass: f64,\n+    }\n \n-const N_BODIES: usize = 5;\n-const BODIES: [Body; N_BODIES] = [\n-    // sun:\n-    Body {\n-        x: f64x4::from_array([0., 0., 0., 0.]),\n-        v: f64x4::from_array([0., 0., 0., 0.]),\n-        mass: SOLAR_MASS,\n-    },\n-    // jupiter:\n-    Body {\n-        x: f64x4::from_array([\n-            4.84143144246472090e+00,\n-            -1.16032004402742839e+00,\n-            -1.03622044471123109e-01,\n-            0.,\n-        ]),\n-        v: f64x4::from_array([\n-            1.66007664274403694e-03 * DAYS_PER_YEAR,\n-            7.69901118419740425e-03 * DAYS_PER_YEAR,\n-            -6.90460016972063023e-05 * DAYS_PER_YEAR,\n-            0.,\n-        ]),\n-        mass: 9.54791938424326609e-04 * SOLAR_MASS,\n-    },\n-    // saturn:\n-    Body {\n-        x: f64x4::from_array([\n-            8.34336671824457987e+00,\n-            4.12479856412430479e+00,\n-            -4.03523417114321381e-01,\n-            0.,\n-        ]),\n-        v: f64x4::from_array([\n-            -2.76742510726862411e-03 * DAYS_PER_YEAR,\n-            4.99852801234917238e-03 * DAYS_PER_YEAR,\n-            2.30417297573763929e-05 * DAYS_PER_YEAR,\n-            0.,\n-        ]),\n-        mass: 2.85885980666130812e-04 * SOLAR_MASS,\n-    },\n-    // uranus:\n-    Body {\n-        x: f64x4::from_array([\n-            1.28943695621391310e+01,\n-            -1.51111514016986312e+01,\n-            -2.23307578892655734e-01,\n-            0.,\n-        ]),\n-        v: f64x4::from_array([\n-            2.96460137564761618e-03 * DAYS_PER_YEAR,\n-            2.37847173959480950e-03 * DAYS_PER_YEAR,\n-            -2.96589568540237556e-05 * DAYS_PER_YEAR,\n-            0.,\n-        ]),\n-        mass: 4.36624404335156298e-05 * SOLAR_MASS,\n-    },\n-    // neptune:\n-    Body {\n-        x: f64x4::from_array([\n-            1.53796971148509165e+01,\n-            -2.59193146099879641e+01,\n-            1.79258772950371181e-01,\n-            0.,\n-        ]),\n-        v: f64x4::from_array([\n-            2.68067772490389322e-03 * DAYS_PER_YEAR,\n-            1.62824170038242295e-03 * DAYS_PER_YEAR,\n-            -9.51592254519715870e-05 * DAYS_PER_YEAR,\n-            0.,\n-        ]),\n-        mass: 5.15138902046611451e-05 * SOLAR_MASS,\n-    },\n-];\n+    const N_BODIES: usize = 5;\n+    const BODIES: [Body; N_BODIES] = [\n+        // sun:\n+        Body {\n+            x: f64x4::from_array([0., 0., 0., 0.]),\n+            v: f64x4::from_array([0., 0., 0., 0.]),\n+            mass: SOLAR_MASS,\n+        },\n+        // jupiter:\n+        Body {\n+            x: f64x4::from_array([\n+                4.84143144246472090e+00,\n+                -1.16032004402742839e+00,\n+                -1.03622044471123109e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                1.66007664274403694e-03 * DAYS_PER_YEAR,\n+                7.69901118419740425e-03 * DAYS_PER_YEAR,\n+                -6.90460016972063023e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 9.54791938424326609e-04 * SOLAR_MASS,\n+        },\n+        // saturn:\n+        Body {\n+            x: f64x4::from_array([\n+                8.34336671824457987e+00,\n+                4.12479856412430479e+00,\n+                -4.03523417114321381e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                -2.76742510726862411e-03 * DAYS_PER_YEAR,\n+                4.99852801234917238e-03 * DAYS_PER_YEAR,\n+                2.30417297573763929e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 2.85885980666130812e-04 * SOLAR_MASS,\n+        },\n+        // uranus:\n+        Body {\n+            x: f64x4::from_array([\n+                1.28943695621391310e+01,\n+                -1.51111514016986312e+01,\n+                -2.23307578892655734e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                2.96460137564761618e-03 * DAYS_PER_YEAR,\n+                2.37847173959480950e-03 * DAYS_PER_YEAR,\n+                -2.96589568540237556e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 4.36624404335156298e-05 * SOLAR_MASS,\n+        },\n+        // neptune:\n+        Body {\n+            x: f64x4::from_array([\n+                1.53796971148509165e+01,\n+                -2.59193146099879641e+01,\n+                1.79258772950371181e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                2.68067772490389322e-03 * DAYS_PER_YEAR,\n+                1.62824170038242295e-03 * DAYS_PER_YEAR,\n+                -9.51592254519715870e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 5.15138902046611451e-05 * SOLAR_MASS,\n+        },\n+    ];\n \n-pub fn offset_momentum(bodies: &mut [Body; N_BODIES]) {\n-    let (sun, rest) = bodies.split_at_mut(1);\n-    let sun = &mut sun[0];\n-    for body in rest {\n-        let m_ratio = body.mass / SOLAR_MASS;\n-        sun.v -= body.v * m_ratio;\n+    fn offset_momentum(bodies: &mut [Body; N_BODIES]) {\n+        let (sun, rest) = bodies.split_at_mut(1);\n+        let sun = &mut sun[0];\n+        for body in rest {\n+            let m_ratio = body.mass / SOLAR_MASS;\n+            sun.v -= body.v * m_ratio;\n+        }\n     }\n-}\n \n-pub fn energy(bodies: &[Body; N_BODIES]) -> f64 {\n-    let mut e = 0.;\n-    for i in 0..N_BODIES {\n-        let bi = &bodies[i];\n-        e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n-        for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n-            let dx = bi.x - bj.x;\n-            e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+    fn energy(bodies: &[Body; N_BODIES]) -> f64 {\n+        let mut e = 0.;\n+        for i in 0..N_BODIES {\n+            let bi = &bodies[i];\n+            e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n+            for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n+                let dx = bi.x - bj.x;\n+                e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+            }\n         }\n+        e\n     }\n-    e\n-}\n \n-pub fn advance(bodies: &mut [Body; N_BODIES], dt: f64) {\n-    const N: usize = N_BODIES * (N_BODIES - 1) / 2;\n+    fn advance(bodies: &mut [Body; N_BODIES], dt: f64) {\n+        const N: usize = N_BODIES * (N_BODIES - 1) / 2;\n+\n+        // compute distance between bodies:\n+        let mut r = [f64x4::splat(0.); N];\n+        {\n+            let mut i = 0;\n+            for j in 0..N_BODIES {\n+                for k in j + 1..N_BODIES {\n+                    r[i] = bodies[j].x - bodies[k].x;\n+                    i += 1;\n+                }\n+            }\n+        }\n+\n+        let mut mag = [0.0; N];\n+        for i in (0..N).step_by(2) {\n+            let d2s = f64x2::from_array([\n+                (r[i] * r[i]).horizontal_sum(),\n+                (r[i + 1] * r[i + 1]).horizontal_sum(),\n+            ]);\n+            let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n+            mag[i] = dmags[0];\n+            mag[i + 1] = dmags[1];\n+        }\n \n-    // compute distance between bodies:\n-    let mut r = [f64x4::splat(0.); N];\n-    {\n         let mut i = 0;\n         for j in 0..N_BODIES {\n             for k in j + 1..N_BODIES {\n-                r[i] = bodies[j].x - bodies[k].x;\n-                i += 1;\n+                let f = r[i] * mag[i];\n+                bodies[j].v -= f * bodies[k].mass;\n+                bodies[k].v += f * bodies[j].mass;\n+                i += 1\n             }\n         }\n+        for body in bodies {\n+            body.x += dt * body.v\n+        }\n     }\n \n-    let mut mag = [0.0; N];\n-    for i in (0..N).step_by(2) {\n-        let d2s = f64x2::from_array([\n-            (r[i] * r[i]).horizontal_sum(),\n-            (r[i + 1] * r[i + 1]).horizontal_sum(),\n-        ]);\n-        let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n-        mag[i] = dmags[0];\n-        mag[i + 1] = dmags[1];\n-    }\n-\n-    let mut i = 0;\n-    for j in 0..N_BODIES {\n-        for k in j + 1..N_BODIES {\n-            let f = r[i] * mag[i];\n-            bodies[j].v -= f * bodies[k].mass;\n-            bodies[k].v += f * bodies[j].mass;\n-            i += 1\n+    pub fn run(n: usize) -> (f64, f64) {\n+        let mut bodies = BODIES;\n+        offset_momentum(&mut bodies);\n+        let energy_before = energy(&bodies);\n+        for _ in 0..n {\n+            advance(&mut bodies, 0.01);\n         }\n-    }\n-    for body in bodies {\n-        body.x += dt * body.v\n-    }\n-}\n+        let energy_after = energy(&bodies);\n \n-pub fn run(n: usize) -> (f64, f64) {\n-    let mut bodies = BODIES;\n-    offset_momentum(&mut bodies);\n-    let energy_before = energy(&bodies);\n-    for _ in 0..n {\n-        advance(&mut bodies, 0.01);\n+        (energy_before, energy_after)\n     }\n-    let energy_after = energy(&bodies);\n-\n-    (energy_before, energy_after)\n }\n \n+#[cfg(feature = \"std\")]\n #[cfg(test)]\n mod tests {\n     // Good enough for demonstration purposes, not going for strictness here.\n@@ -173,12 +177,17 @@ mod tests {\n     #[test]\n     fn test() {\n         const OUTPUT: [f64; 2] = [-0.169075164, -0.169087605];\n-        let (energy_before, energy_after) = super::run(1000);\n+        let (energy_before, energy_after) = super::nbody::run(1000);\n         assert!(approx_eq_f64(energy_before, OUTPUT[0]));\n         assert!(approx_eq_f64(energy_after, OUTPUT[1]));\n     }\n }\n \n fn main() {\n-    // empty main to pass CI\n+    #[cfg(feature = \"std\")]\n+    {\n+        let (energy_before, energy_after) = nbody::run(1000);\n+        println!(\"Energy before: {}\", energy_before);\n+        println!(\"Energy after:  {}\", energy_after);\n+    }\n }"}, {"sha": "916c0dadf7527fe548534908ca23833df9d000e1", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -47,6 +47,7 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_fabs<T>(x: T) -> T;\n \n     /// fsqrt\n+    #[cfg(feature = \"std\")]\n     pub(crate) fn simd_fsqrt<T>(x: T) -> T;\n \n     /// fma"}, {"sha": "b017e7d137e308293c8ecd921674d33794565e27", "filename": "crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -6,9 +6,14 @@ use sealed::Sealed;\n /// A type representing a vector lane count.\n pub struct LaneCount<const LANES: usize>;\n \n+impl<const LANES: usize> LaneCount<LANES> {\n+    /// The number of bytes in a bitmask with this many lanes.\n+    pub const BITMASK_LEN: usize = (LANES + 7) / 8;\n+}\n+\n /// Helper trait for vector lane counts.\n pub trait SupportedLaneCount: Sealed {\n-    /// The bitmask representation of a mask.\n+    #[doc(hidden)]\n     type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n \n     #[doc(hidden)]"}, {"sha": "5f88e3c63b5becbc33d35072ca90eefb5a9eb1b2", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -1,6 +1,7 @@\n #![no_std]\n #![allow(incomplete_features)]\n #![feature(\n+    const_evaluatable_checked,\n     const_generics,\n     platform_intrinsics,\n     repr_simd,\n@@ -20,8 +21,8 @@ mod reduction;\n mod select;\n pub use select::Select;\n \n+#[cfg(feature = \"const_evaluatable_checked\")]\n mod to_bytes;\n-pub use to_bytes::ToBytes;\n \n mod comparisons;\n mod fmt;"}, {"sha": "ba7da704f61d4f63d53f26ae672919e05d65f78f", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -160,12 +160,12 @@ macro_rules! define_opaque_mask {\n             }\n \n             /// Convert this mask to a bitmask, with one bit set per lane.\n-            pub fn to_bitmask(self) -> <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask {\n+            pub fn to_bitmask(self) -> [u8; crate::LaneCount::<LANES>::BITMASK_LEN] {\n                 self.0.to_bitmask()\n             }\n \n             /// Convert a bitmask to a mask.\n-            pub fn from_bitmask(bitmask: <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n+            pub fn from_bitmask(bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n                 Self(<$inner_ty>::from_bitmask(bitmask))\n             }\n         }"}, {"sha": "69edd5235872cfee978773ff39ab0e661e74e527", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -128,13 +128,15 @@ where\n     }\n \n     #[inline]\n-    pub fn to_bitmask(self) -> <LaneCount<LANES> as SupportedLaneCount>::BitMask {\n-        self.0\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        // Safety: these are the same type and we are laundering the generic\n+        unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n     #[inline]\n-    pub fn from_bitmask(bitmask: <LaneCount<LANES> as SupportedLaneCount>::BitMask) -> Self {\n-        Self(bitmask)\n+    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        // Safety: these are the same type and we are laundering the generic\n+        Self(unsafe { core::mem::transmute_copy(&bitmask) })\n     }\n \n     #[inline]"}, {"sha": "2923cf1964a0dae4f724d2164137731870a95952", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -103,15 +103,15 @@ macro_rules! define_mask {\n             }\n \n             #[inline]\n-            pub fn to_bitmask(self) -> <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask {\n+            pub fn to_bitmask(self) -> [u8; crate::LaneCount::<LANES>::BITMASK_LEN] {\n                 unsafe {\n                     // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n                     assert_eq!(\n-                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n                         core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                        crate::LaneCount::<LANES>::BITMASK_LEN,\n                     );\n                     let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n-                    let mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask = core::mem::transmute_copy(&bitmask);\n+                    let mut bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN] = core::mem::transmute_copy(&bitmask);\n \n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -127,7 +127,7 @@ macro_rules! define_mask {\n             }\n \n             #[inline]\n-            pub fn from_bitmask(mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n+            pub fn from_bitmask(mut bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n                 unsafe {\n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -140,8 +140,8 @@ macro_rules! define_mask {\n \n                     // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n                     assert_eq!(\n-                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n                         core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                        crate::LaneCount::<LANES>::BITMASK_LEN,\n                     );\n                     let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = core::mem::transmute_copy(&bitmask);\n "}, {"sha": "c284ade463fc338eb8066bdb7bf2bb7f276736cf", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -41,7 +41,12 @@ macro_rules! implement {\n             pub fn fract(self) -> Self {\n                 self - self.trunc()\n             }\n+        }\n \n+        impl<const LANES: usize> crate::$type<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type.\n             ///"}, {"sha": "31d7dfebe1a7aa2563a71810e3e374c099418f88", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 20, "deletions": 53, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -1,72 +1,39 @@\n-mod sealed {\n-    pub trait Sealed {}\n-}\n-use sealed::Sealed;\n-\n-/// Supporting trait for byte conversion functions.\n-pub trait ToBytes: Sealed {\n-    /// The bytes representation of this type.\n-    type Bytes;\n-\n-    #[doc(hidden)]\n-    fn to_bytes_impl(self) -> Self::Bytes;\n-\n-    #[doc(hidden)]\n-    fn from_bytes_impl(bytes: Self::Bytes) -> Self;\n-}\n-\n macro_rules! impl_to_bytes {\n-    { $name:ident, $($int_width:literal -> $byte_width:literal),* } => {\n-        $(\n-        impl Sealed for crate::$name<$int_width>\n-        where\n-            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n-        {}\n-\n-        impl ToBytes for crate::$name<$int_width>\n-        where\n-            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n-        {\n-            type Bytes = crate::SimdU8<$byte_width>;\n-            fn to_bytes_impl(self) -> Self::Bytes {\n-                unsafe { core::mem::transmute(self) }\n-            }\n-            fn from_bytes_impl(bytes: Self::Bytes) -> Self {\n-                unsafe { core::mem::transmute(bytes) }\n-            }\n-        }\n-        )*\n-\n+    { $name:ident, $size:literal } => {\n         impl<const LANES: usize> crate::$name<LANES>\n         where\n             crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-            Self: ToBytes,\n+            crate::LaneCount<{{ $size * LANES }}>: crate::SupportedLaneCount,\n         {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n-            pub fn to_ne_bytes(self) -> <Self as ToBytes>::Bytes { self.to_bytes_impl() }\n+            pub fn to_ne_bytes(self) -> crate::SimdU8<{{ $size * LANES }}> {\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n-            pub fn from_ne_bytes(bytes: <Self as ToBytes>::Bytes) -> Self { Self::from_bytes_impl(bytes) }\n+            pub fn from_ne_bytes(bytes: crate::SimdU8<{{ $size * LANES }}>) -> Self {\n+                unsafe { core::mem::transmute_copy(&bytes) }\n+            }\n         }\n     }\n }\n \n-impl_to_bytes! { SimdU8, 1 -> 1, 2 -> 2, 4 -> 4, 8 -> 8, 16 -> 16, 32 -> 32 }\n-impl_to_bytes! { SimdU16, 1 -> 2, 2 -> 4, 4 -> 8, 8 -> 16, 16 -> 32 }\n-impl_to_bytes! { SimdU32, 1 -> 4, 2 -> 8, 4 -> 16, 8 -> 32 }\n-impl_to_bytes! { SimdU64, 1 -> 8, 2 -> 16, 4 -> 32 }\n+impl_to_bytes! { SimdU8, 1 }\n+impl_to_bytes! { SimdU16, 2 }\n+impl_to_bytes! { SimdU32, 4 }\n+impl_to_bytes! { SimdU64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdUsize, 1 -> 4, 2 -> 8, 4 -> 16, 8 -> 32 }\n+impl_to_bytes! { SimdUsize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdUsize, 1 -> 8, 2 -> 16, 4 -> 32 }\n+impl_to_bytes! { SimdUsize, 8 }\n \n-impl_to_bytes! { SimdI8, 1 -> 1, 2 -> 2, 4 -> 4, 8 -> 8, 16 -> 16, 32 -> 32 }\n-impl_to_bytes! { SimdI16, 1 -> 2, 2 -> 4, 4 -> 8, 8 -> 16, 16 -> 32 }\n-impl_to_bytes! { SimdI32, 1 -> 4, 2 -> 8, 4 -> 16, 8 -> 32 }\n-impl_to_bytes! { SimdI64, 1 -> 8, 2 -> 16, 4 -> 32 }\n+impl_to_bytes! { SimdI8, 1 }\n+impl_to_bytes! { SimdI16, 2 }\n+impl_to_bytes! { SimdI32, 4 }\n+impl_to_bytes! { SimdI64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdIsize, 1 -> 4, 2 -> 8, 4 -> 16, 8 -> 32 }\n+impl_to_bytes! { SimdIsize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdIsize, 1 -> 8, 2 -> 16, 4 -> 32 }\n+impl_to_bytes! { SimdIsize, 8 }"}, {"sha": "81553c34aa774b58ef3763a204c58cc9c9cf6886", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -443,14 +443,6 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n-                fn sqrt<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::sqrt,\n-                        &Scalar::sqrt,\n-                        &|_| true,\n-                    )\n-                }\n-\n                 fn recip<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         &Vector::<LANES>::recip,\n@@ -605,6 +597,17 @@ macro_rules! impl_float_tests {\n                     });\n                 }\n             }\n+\n+            #[cfg(feature = \"std\")]\n+            test_helpers::test_lanes! {\n+                fn sqrt<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::sqrt,\n+                        &Scalar::sqrt,\n+                        &|_| true,\n+                    )\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "22c97c95d927f9c46f97707db36e52d7aaebdac0", "filename": "crates/core_simd/tests/to_bytes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36d17de4d87f5baba95b13d2b1ec70e652f0fe4/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=c36d17de4d87f5baba95b13d2b1ec70e652f0fe4", "patch": "@@ -1,4 +1,6 @@\n-#![feature(portable_simd)]\n+#![feature(portable_simd, const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+#![cfg(feature = \"const_evaluatable_checked\")]\n \n use core_simd::SimdU32;\n "}]}