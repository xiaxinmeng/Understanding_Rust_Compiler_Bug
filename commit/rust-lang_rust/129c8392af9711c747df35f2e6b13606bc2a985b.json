{"sha": "129c8392af9711c747df35f2e6b13606bc2a985b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOWM4MzkyYWY5NzExYzc0N2RmMzVmMmU2YjEzNjA2YmMyYTk4NWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-08T23:20:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-08T23:22:03Z"}, "message": "rustc: Rename \"demand\" to \"pushdown\" in the typechecker and explain more clearly what it's for", "tree": {"sha": "0d7f4e8571a74832d8a02122d6b42f3ea9335218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d7f4e8571a74832d8a02122d6b42f3ea9335218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/129c8392af9711c747df35f2e6b13606bc2a985b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/129c8392af9711c747df35f2e6b13606bc2a985b", "html_url": "https://github.com/rust-lang/rust/commit/129c8392af9711c747df35f2e6b13606bc2a985b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/129c8392af9711c747df35f2e6b13606bc2a985b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1af3174fe3b565371a5978381f604ea9c01e86d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1af3174fe3b565371a5978381f604ea9c01e86d3", "html_url": "https://github.com/rust-lang/rust/commit/1af3174fe3b565371a5978381f604ea9c01e86d3"}], "stats": {"total": 785, "additions": 409, "deletions": 376}, "files": [{"sha": "98f71e20daa528e1de7d6fced745895bbee06c57", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 409, "deletions": 376, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/129c8392af9711c747df35f2e6b13606bc2a985b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/129c8392af9711c747df35f2e6b13606bc2a985b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=129c8392af9711c747df35f2e6b13606bc2a985b", "patch": "@@ -1034,413 +1034,439 @@ fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n     }\n }\n \n-// Type unification over typed patterns. Note that the pattern that you pass\n-// to this function must have been passed to check_pat() first.\n-//\n-// TODO: enforce this via a predicate.\n-\n-fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n-    auto p_1;\n \n-    alt (pat.node) {\n-        case (ast.pat_wild(?ann)) {\n-            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]],\n-                                            none[@ts_ann]));\n-        }\n-        case (ast.pat_lit(?lit, ?ann)) {\n-            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]],\n+// The \"push-down\" phase, which takes a typed grammar production and pushes\n+// its type down into its constituent parts.\n+//\n+// For example, consider \"auto x; x = 352;\". check_expr() doesn't know the\n+// type of \"x\" at the time it sees it, so that function will simply store a\n+// type variable for the type of \"x\". However, after checking the entire\n+// assignment expression, check_expr() will assign the type of int to the\n+// expression \"x = 352\" as a whole. In this case, then, the job of these\n+// functions is to clean up by assigning the type of int to both sides of the\n+// assignment expression.\n+//\n+// TODO: We only need to do this once per statement: check_expr() bubbles the\n+// types up, and pushdown_expr() pushes the types down. However, in many cases\n+// we're more eager than we need to be, calling pushdown_expr() and friends\n+// directly inside check_expr(). This results in a quadratic algorithm.\n+\n+mod Pushdown {\n+    // Push-down over typed patterns. Note that the pattern that you pass to\n+    // this function must have been passed to check_pat() first.\n+    //\n+    // TODO: enforce this via a predicate.\n+\n+    fn pushdown_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n+        auto p_1;\n+\n+        alt (pat.node) {\n+            case (ast.pat_wild(?ann)) {\n+                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]],\n                                                 none[@ts_ann]));\n-        }\n-        case (ast.pat_bind(?id, ?did, ?ann)) {\n-            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            fcx.locals.insert(did, t);\n-            p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n-                                                     none[vec[@ty.t]],\n-                                                     none[@ts_ann]));\n-        }\n-        case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n-            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-\n-            // FIXME: This is probably more convoluted than it has to be.\n-            // Refactor to use the type cache.\n-\n-            // Figure out the type parameters of the tag.\n-            auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n+            }\n+            case (ast.pat_lit(?lit, ?ann)) {\n+                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]],\n+                                                    none[@ts_ann]));\n+            }\n+            case (ast.pat_bind(?id, ?did, ?ann)) {\n+                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                fcx.locals.insert(did, t);\n+                p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n+                                                         none[vec[@ty.t]],\n+                                                         none[@ts_ann]));\n+            }\n+            case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n+                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n \n-            auto tpt = ty.lookup_generic_item_type(fcx.ccx.sess,\n-                fcx.ccx.type_cache, tag_id);\n-            auto ty_params = tpt._0;\n+                // FIXME: This is probably more convoluted than it has to be.\n+                // Refactor to use the type cache.\n \n-            // Take the type parameters out of the expected type.\n-            auto ty_param_substs;\n-            alt (t.struct) {\n-                case (ty.ty_tag(_, ?tps)) { ty_param_substs = tps; }\n-                case (_) {\n-                    log \"demand_pat(): expected type for tag pat isn't \" +\n-                        \"actually a tag?!\";\n-                    fail;\n-                }\n-            }\n-            auto tps_opt = some[vec[@ty.t]](ty_param_substs);\n+                // Figure out the type parameters of the tag.\n+                auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n \n-            // The type of the tag isn't enough; we also have to get the type\n-            // of the variant, which is either a tag type in the case of\n-            // nullary variants or a function type in the case of n-ary\n-            // variants.\n+                auto tpt = ty.lookup_generic_item_type(fcx.ccx.sess,\n+                    fcx.ccx.type_cache, tag_id);\n+                auto ty_params = tpt._0;\n \n-            auto vdef = option.get[ast.variant_def](vdef_opt);\n-            auto variant_ty = ty.lookup_item_type(fcx.ccx.sess,\n-                                                  fcx.ccx.type_cache,\n-                                                  vdef._1)._1;\n-\n-            auto subpats_len = _vec.len[@ast.pat](subpats);\n-            alt (variant_ty.struct) {\n-                case (ty.ty_tag(_, _)) {\n-                    // Nullary tag variant.\n-                    check (subpats_len == 0u);\n-                    p_1 = ast.pat_tag(id, subpats, vdef_opt,\n-                                      ast.ann_type(t, tps_opt,\n-                                                   none[@ts_ann]));\n+                // Take the type parameters out of the expected type.\n+                auto ty_param_substs;\n+                alt (t.struct) {\n+                    case (ty.ty_tag(_, ?tps)) { ty_param_substs = tps; }\n+                    case (_) {\n+                        log \"pushdown_pat(): expected type for tag pat \" +\n+                            \"isn't actually a tag?!\";\n+                        fail;\n+                    }\n                 }\n-                case (ty.ty_fn(_, ?args, ?tag_ty)) {\n-                    // N-ary tag variant.\n-                    let vec[@ast.pat] new_subpats = vec();\n-                    auto i = 0u;\n-                    for (arg a in args) {\n-                        auto subpat_ty = substitute_ty_params(fcx.ccx, a.ty,\n-                            ty_params, ty_param_substs, pat.span);\n-                        auto new_subpat = demand_pat(fcx, subpat_ty,\n-                                                     subpats.(i));\n-                        new_subpats += vec(new_subpat);\n-                        i += 1u;\n+                auto tps_opt = some[vec[@ty.t]](ty_param_substs);\n+\n+                // The type of the tag isn't enough; we also have to get the\n+                // type of the variant, which is either a tag type in the case\n+                // of nullary variants or a function type in the case of n-ary\n+                // variants.\n+\n+                auto vdef = option.get[ast.variant_def](vdef_opt);\n+                auto variant_ty = ty.lookup_item_type(fcx.ccx.sess,\n+                                                      fcx.ccx.type_cache,\n+                                                      vdef._1)._1;\n+\n+                auto subpats_len = _vec.len[@ast.pat](subpats);\n+                alt (variant_ty.struct) {\n+                    case (ty.ty_tag(_, _)) {\n+                        // Nullary tag variant.\n+                        check (subpats_len == 0u);\n+                        p_1 = ast.pat_tag(id, subpats, vdef_opt,\n+                                          ast.ann_type(t, tps_opt,\n+                                                       none[@ts_ann]));\n+                    }\n+                    case (ty.ty_fn(_, ?args, ?tag_ty)) {\n+                        // N-ary tag variant.\n+                        let vec[@ast.pat] new_subpats = vec();\n+                        auto i = 0u;\n+                        for (arg a in args) {\n+                            auto subpat_ty = substitute_ty_params(fcx.ccx,\n+                                a.ty, ty_params, ty_param_substs, pat.span);\n+                            auto new_subpat = pushdown_pat(fcx, subpat_ty,\n+                                                           subpats.(i));\n+                            new_subpats += vec(new_subpat);\n+                            i += 1u;\n+                        }\n+                        p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n+                                          ast.ann_type(tag_ty, tps_opt,\n+                                                       none[@ts_ann]));\n                     }\n-                    p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n-                                      ast.ann_type(tag_ty, tps_opt,\n-                                                   none[@ts_ann]));\n                 }\n             }\n         }\n+\n+        ret @fold.respan[ast.pat_](pat.span, p_1);\n     }\n \n-    ret @fold.respan[ast.pat_](pat.span, p_1);\n-}\n+    // Push-down over typed expressions. Note that the expression that you\n+    // pass to this function must have been passed to check_expr() first.\n+    //\n+    // TODO: enforce this via a predicate.\n+    // TODO: This function is incomplete.\n \n-// Type unification over typed expressions. Note that the expression that you\n-// pass to this function must have been passed to check_expr() first.\n-//\n-// TODO: enforce this via a predicate.\n-// TODO: propagate the types downward. This makes the typechecker quadratic,\n-//       but we can mitigate that if expected == actual == unified.\n-\n-fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n-    be demand_expr_full(fcx, expected, e, NO_AUTODEREF);\n-}\n+    fn pushdown_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e)\n+            -> @ast.expr {\n+        be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n+    }\n \n-fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n-                    autoderef_kind adk) -> @ast.expr {\n-    auto e_1;\n+    fn pushdown_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n+                        autoderef_kind adk) -> @ast.expr {\n+        auto e_1;\n \n-    alt (e.node) {\n-        case (ast.expr_vec(?es_0, ?mut, ?ann)) {\n-            // TODO: enforce mutability\n+        alt (e.node) {\n+            case (ast.expr_vec(?es_0, ?mut, ?ann)) {\n+                // TODO: enforce mutability\n \n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            let vec[@ast.expr] es_1 = vec();\n-            alt (t.struct) {\n-                case (ty.ty_vec(?mt)) {\n-                    for (@ast.expr e_0 in es_0) {\n-                        es_1 += vec(demand_expr(fcx, mt.ty, e_0));\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                let vec[@ast.expr] es_1 = vec();\n+                alt (t.struct) {\n+                    case (ty.ty_vec(?mt)) {\n+                        for (@ast.expr e_0 in es_0) {\n+                            es_1 += vec(pushdown_expr(fcx, mt.ty, e_0));\n+                        }\n                     }\n-                }\n-                case (_) {\n-                    log \"vec expr doesn't have a vec type!\";\n-                    fail;\n-                }\n-            }\n-            e_1 = ast.expr_vec(es_1, mut, triv_ann(t));\n-        }\n-        case (ast.expr_tup(?es_0, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            let vec[ast.elt] elts_1 = vec();\n-            alt (t.struct) {\n-                case (ty.ty_tup(?mts)) {\n-                    auto i = 0u;\n-                    for (ast.elt elt_0 in es_0) {\n-                        auto e_1 = demand_expr(fcx, mts.(i).ty, elt_0.expr);\n-                        elts_1 += vec(rec(mut=elt_0.mut, expr=e_1));\n-                        i += 1u;\n+                    case (_) {\n+                        log \"vec expr doesn't have a vec type!\";\n+                        fail;\n                     }\n                 }\n-                case (_) {\n-                    log \"tup expr doesn't have a tup type!\";\n-                    fail;\n+                e_1 = ast.expr_vec(es_1, mut, triv_ann(t));\n+            }\n+            case (ast.expr_tup(?es_0, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                let vec[ast.elt] elts_1 = vec();\n+                alt (t.struct) {\n+                    case (ty.ty_tup(?mts)) {\n+                        auto i = 0u;\n+                        for (ast.elt elt_0 in es_0) {\n+                            auto e_1 = pushdown_expr(fcx, mts.(i).ty,\n+                                                     elt_0.expr);\n+                            elts_1 += vec(rec(mut=elt_0.mut, expr=e_1));\n+                            i += 1u;\n+                        }\n+                    }\n+                    case (_) {\n+                        log \"tup expr doesn't have a tup type!\";\n+                        fail;\n+                    }\n                 }\n+                e_1 = ast.expr_tup(elts_1, triv_ann(t));\n             }\n-            e_1 = ast.expr_tup(elts_1, triv_ann(t));\n-        }\n-        case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n+            case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n \n-            auto base_1 = base_0;\n+                auto base_1 = base_0;\n \n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            let vec[ast.field] fields_1 = vec();\n-            alt (t.struct) {\n-                case (ty.ty_rec(?field_mts)) {\n-                    alt (base_0) {\n-                        case (none[@ast.expr]) {\n-                            auto i = 0u;\n-                            for (ast.field field_0 in fields_0) {\n-                                check (_str.eq(field_0.ident,\n-                                               field_mts.(i).ident));\n-                                auto e_1 = demand_expr(fcx,\n-                                                       field_mts.(i).mt.ty,\n-                                                       field_0.expr);\n-                                fields_1 += vec(rec(mut=field_0.mut,\n-                                                    ident=field_0.ident,\n-                                                    expr=e_1));\n-                                i += 1u;\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                let vec[ast.field] fields_1 = vec();\n+                alt (t.struct) {\n+                    case (ty.ty_rec(?field_mts)) {\n+                        alt (base_0) {\n+                            case (none[@ast.expr]) {\n+                                auto i = 0u;\n+                                for (ast.field field_0 in fields_0) {\n+                                    check (_str.eq(field_0.ident,\n+                                                   field_mts.(i).ident));\n+                                    auto e_1 =\n+                                        pushdown_expr(fcx,\n+                                                      field_mts.(i).mt.ty,\n+                                                      field_0.expr);\n+                                    fields_1 += vec(rec(mut=field_0.mut,\n+                                                        ident=field_0.ident,\n+                                                        expr=e_1));\n+                                    i += 1u;\n+                                }\n                             }\n-                        }\n-                        case (some[@ast.expr](?bx)) {\n-\n-                            base_1 =\n-                                some[@ast.expr](demand_expr(fcx, t, bx));\n-\n-                            let vec[field] base_fields = vec();\n-\n-                            for (ast.field field_0 in fields_0) {\n-\n-                                for (ty.field ft in field_mts) {\n-                                    if (_str.eq(field_0.ident, ft.ident)) {\n-                                        auto e_1 = demand_expr(fcx, ft.mt.ty,\n-                                                               field_0.expr);\n-                                        fields_1 +=\n-                                            vec(rec(mut=field_0.mut,\n-                                                    ident=field_0.ident,\n-                                                    expr=e_1));\n+                            case (some[@ast.expr](?bx)) {\n+\n+                                base_1 = some[@ast.expr](pushdown_expr(fcx, t,\n+                                                                       bx));\n+\n+                                let vec[field] base_fields = vec();\n+\n+                                for (ast.field field_0 in fields_0) {\n+\n+                                    for (ty.field ft in field_mts) {\n+                                        if (_str.eq(field_0.ident,\n+                                                    ft.ident)) {\n+                                            auto e_1 =\n+                                                pushdown_expr(fcx, ft.mt.ty,\n+                                                              field_0.expr);\n+                                            fields_1 +=\n+                                                vec(rec(mut=field_0.mut,\n+                                                        ident=field_0.ident,\n+                                                        expr=e_1));\n+                                        }\n                                     }\n                                 }\n                             }\n                         }\n                     }\n+                    case (_) {\n+                        log \"rec expr doesn't have a rec type!\";\n+                        fail;\n+                    }\n                 }\n-                case (_) {\n-                    log \"rec expr doesn't have a rec type!\";\n-                    fail;\n-                }\n-            }\n-            e_1 = ast.expr_rec(fields_1, base_1, triv_ann(t));\n-        }\n-        case (ast.expr_bind(?sube, ?es, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_bind(sube, es, triv_ann(t));\n-        }\n-        case (ast.expr_call(?sube, ?es, ?ann)) {\n-            // NB: we call 'demand_full' and pass in adk only in cases where\n-            // e is an expression that could *possibly* produce a box; things\n-            // like expr_binary or expr_bind can't, so there's no need.\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_call(sube, es, triv_ann(t));\n-        }\n-        case (ast.expr_self_method(?id, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_self_method(id, triv_ann(t));\n-        }\n-        case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(t));\n-        }\n-        case (ast.expr_unary(?uop, ?sube, ?ann)) {\n-            // See note in expr_unary for why we're calling demand_full.\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_unary(uop, sube, triv_ann(t));\n-        }\n-        case (ast.expr_lit(?lit, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_lit(lit, triv_ann(t));\n-        }\n-        case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_cast(sube, ast_ty, triv_ann(t));\n-        }\n-        case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            auto then_1 = demand_block(fcx, expected, then_0);\n-\n-            auto else_1;\n-            alt (else_0) {\n-                case (none[@ast.expr]) { else_1 = none[@ast.expr]; }\n-                case (some[@ast.expr](?e_0)) {\n-                    auto e_1 = demand_expr(fcx, expected, e_0);\n-                    else_1 = some[@ast.expr](e_1);\n-                }\n-            }\n-            e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(t));\n-        }\n-        case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for(decl, seq, bloc, triv_ann(t));\n-        }\n-        case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(t));\n-        }\n-        case (ast.expr_while(?cond, ?bloc, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_while(cond, bloc, triv_ann(t));\n-        }\n-        case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_do_while(bloc, cond, triv_ann(t));\n-        }\n-        case (ast.expr_block(?bloc, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_block(bloc, triv_ann(t));\n-        }\n-        case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n-            auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(t));\n-        }\n-        case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n-            auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(t));\n-        }\n-        case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_field(lhs, rhs, triv_ann(t));\n-        }\n-        case (ast.expr_index(?base, ?index, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_index(base, index, triv_ann(t));\n-        }\n-        case (ast.expr_path(?pth, ?d, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-\n-            // Fill in the type parameter substitutions if they weren't\n-            // provided by the programmer.\n-            auto ty_params_opt;\n-            alt (ann) {\n-                case (ast.ann_none) {\n-                    log \"demand_expr(): no type annotation for path expr; \" +\n-                        \"did you pass it to check_expr() first?\";\n-                    fail;\n+                e_1 = ast.expr_rec(fields_1, base_1, triv_ann(t));\n+            }\n+            case (ast.expr_bind(?sube, ?es, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_bind(sube, es, triv_ann(t));\n+            }\n+            case (ast.expr_call(?sube, ?es, ?ann)) {\n+                // NB: we call 'demand_full' and pass in adk only in cases\n+                // where e is an expression that could *possibly* produce a\n+                // box; things like expr_binary or expr_bind can't, so there's\n+                // no need.\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_call(sube, es, triv_ann(t));\n+            }\n+            case (ast.expr_self_method(?id, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_self_method(id, triv_ann(t));\n+            }\n+            case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(t));\n+            }\n+            case (ast.expr_unary(?uop, ?sube, ?ann)) {\n+                // See note in expr_unary for why we're calling demand_full.\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_unary(uop, sube, triv_ann(t));\n+            }\n+            case (ast.expr_lit(?lit, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_lit(lit, triv_ann(t));\n+            }\n+            case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_cast(sube, ast_ty, triv_ann(t));\n+            }\n+            case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                auto then_1 = pushdown_block(fcx, expected, then_0);\n+\n+                auto else_1;\n+                alt (else_0) {\n+                    case (none[@ast.expr]) { else_1 = none[@ast.expr]; }\n+                    case (some[@ast.expr](?e_0)) {\n+                        auto e_1 = pushdown_expr(fcx, expected, e_0);\n+                        else_1 = some[@ast.expr](e_1);\n+                    }\n                 }\n-                case (ast.ann_type(_, ?tps_opt, _)) {\n-                    alt (tps_opt) {\n-                        case (none[vec[@ty.t]]) {\n-                            auto defn = option.get[ast.def](d);\n-                            alt (ty_params_for_item(fcx.ccx, defn)) {\n+                e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(t));\n+            }\n+            case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_for(decl, seq, bloc, triv_ann(t));\n+            }\n+            case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(t));\n+            }\n+            case (ast.expr_while(?cond, ?bloc, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_while(cond, bloc, triv_ann(t));\n+            }\n+            case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_do_while(bloc, cond, triv_ann(t));\n+            }\n+            case (ast.expr_block(?bloc, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_block(bloc, triv_ann(t));\n+            }\n+            case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n+                auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n+                e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(t));\n+            }\n+            case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n+                auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n+                e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(t));\n+            }\n+            case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_field(lhs, rhs, triv_ann(t));\n+            }\n+            case (ast.expr_index(?base, ?index, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_index(base, index, triv_ann(t));\n+            }\n+            case (ast.expr_path(?pth, ?d, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+\n+                // Fill in the type parameter substitutions if they weren't\n+                // provided by the programmer.\n+                auto ty_params_opt;\n+                alt (ann) {\n+                    case (ast.ann_none) {\n+                        log \"pushdown_expr(): no type annotation for path \" +\n+                            \"expr; did you pass it to check_expr() first?\";\n+                        fail;\n+                    }\n+                    case (ast.ann_type(_, ?tps_opt, _)) {\n+                        alt (tps_opt) {\n+                            case (none[vec[@ty.t]]) {\n+                                auto defn = option.get[ast.def](d);\n+                                alt (ty_params_for_item(fcx.ccx, defn)) {\n                                 case (none[ty.ty_params_and_ty]) {\n                                     ty_params_opt = none[vec[@ty.t]];\n                                 }\n                                 case (some[ty.ty_params_and_ty](?tpt)) {\n                                     auto tps = ty.resolve_ty_params(tpt, t);\n                                     ty_params_opt = some[vec[@ty.t]](tps);\n                                 }\n+                                }\n+                            }\n+                            case (some[vec[@ty.t]](?tps)) {\n+                                ty_params_opt = some[vec[@ty.t]](tps);\n                             }\n-                        }\n-                        case (some[vec[@ty.t]](?tps)) {\n-                            ty_params_opt = some[vec[@ty.t]](tps);\n                         }\n                     }\n                 }\n-            }\n-\n-            e_1 = ast.expr_path(pth, d,\n-                                ast.ann_type(t, ty_params_opt,\n-                                             none[@ts_ann]));\n-        }\n-        case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n-            auto t = demand_full(fcx, e.span, expected,\n-                                 ann_to_type(ann), adk);\n-            e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n-        }\n-        /* FIXME: should this check the type annotations? */\n-        case (ast.expr_fail(_))  { e_1 = e.node; } \n-        case (ast.expr_log(_,_)) { e_1 = e.node; } \n-        case (ast.expr_break(_)) { e_1 = e.node; }\n-        case (ast.expr_cont(_))  { e_1 = e.node; }\n-        case (ast.expr_ret(_,_)) { e_1 = e.node; }\n-        case (ast.expr_put(_,_)) { e_1 = e.node; }\n-        case (ast.expr_be(_,_))  { e_1 = e.node; }\n-        case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n \n-        case (ast.expr_port(?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_port(triv_ann(t));\n-        }\n-\n-        case (ast.expr_chan(?es, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            let @ast.expr es_1;\n-            alt (t.struct) {\n-                case (ty.ty_chan(?subty)) {\n-                    auto pt = plain_ty(ty.ty_port(subty));\n-                    es_1 = demand_expr(fcx, pt, es);\n+                e_1 = ast.expr_path(pth, d,\n+                                    ast.ann_type(t, ty_params_opt,\n+                                                 none[@ts_ann]));\n+            }\n+            case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n+                auto t = demand_full(fcx, e.span, expected,\n+                                     ann_to_type(ann), adk);\n+                e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n+            }\n+            /* FIXME: should this check the type annotations? */\n+            case (ast.expr_fail(_))  { e_1 = e.node; } \n+            case (ast.expr_log(_,_)) { e_1 = e.node; } \n+            case (ast.expr_break(_)) { e_1 = e.node; }\n+            case (ast.expr_cont(_))  { e_1 = e.node; }\n+            case (ast.expr_ret(_,_)) { e_1 = e.node; }\n+            case (ast.expr_put(_,_)) { e_1 = e.node; }\n+            case (ast.expr_be(_,_))  { e_1 = e.node; }\n+            case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n+\n+            case (ast.expr_port(?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                e_1 = ast.expr_port(triv_ann(t));\n+            }\n+\n+            case (ast.expr_chan(?es, ?ann)) {\n+                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                let @ast.expr es_1;\n+                alt (t.struct) {\n+                    case (ty.ty_chan(?subty)) {\n+                        auto pt = plain_ty(ty.ty_port(subty));\n+                        es_1 = pushdown_expr(fcx, pt, es);\n+                    }\n+                    case (_) {\n+                        log \"chan expr doesn't have a chan type!\";\n+                        fail;\n+                    }\n                 }\n-                case (_) {\n-                    log \"chan expr doesn't have a chan type!\";\n-                    fail;\n+                e_1 = ast.expr_chan(es_1, triv_ann(t));\n+            }\n+\n+            case (ast.expr_alt(?discrim, ?arms_0, ?ann)) {\n+                auto t = expected;\n+                let vec[ast.arm] arms_1 = vec();\n+                for (ast.arm arm_0 in arms_0) {\n+                    auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n+                    t = demand(fcx, e.span, t, block_ty(block_1));\n+                    auto arm_1 = rec(pat=arm_0.pat, block=block_1,\n+                                     index=arm_0.index);\n+                    arms_1 += vec(arm_1);\n                 }\n+                e_1 = ast.expr_alt(discrim, arms_1, triv_ann(t));\n             }\n-            e_1 = ast.expr_chan(es_1, triv_ann(t));\n-        }\n \n-        case (ast.expr_alt(?discrim, ?arms_0, ?ann)) {\n-            auto t = expected;\n-            let vec[ast.arm] arms_1 = vec();\n-            for (ast.arm arm_0 in arms_0) {\n-                auto block_1 = demand_block(fcx, expected, arm_0.block);\n-                t = demand(fcx, e.span, t, block_ty(block_1));\n-                auto arm_1 = rec(pat=arm_0.pat, block=block_1,\n-                                 index=arm_0.index);\n-                arms_1 += vec(arm_1);\n+            case (_) {\n+                fcx.ccx.sess.span_unimpl(e.span,\n+                    \"type unification for expression variant\");\n+                fail;\n             }\n-            e_1 = ast.expr_alt(discrim, arms_1, triv_ann(t));\n         }\n \n-        case (_) {\n-            fcx.ccx.sess.span_unimpl(e.span,\n-                \"type unification for expression variant\");\n-            fail;\n-        }\n+        ret @fold.respan[ast.expr_](e.span, e_1);\n     }\n \n-    ret @fold.respan[ast.expr_](e.span, e_1);\n-}\n-\n-// Type unification over typed blocks.\n-fn demand_block(&@fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n-    alt (bloc.node.expr) {\n-        case (some[@ast.expr](?e_0)) {\n-            auto e_1 = demand_expr(fcx, expected, e_0);\n-            auto block_ = rec(stmts=bloc.node.stmts,\n-                              expr=some[@ast.expr](e_1),\n-                              index=bloc.node.index);\n-            ret fold.respan[ast.block_](bloc.span, block_);\n-        }\n-        case (none[@ast.expr]) {\n-            demand(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n-            ret bloc;\n+    // Push-down over typed blocks.\n+    fn pushdown_block(&@fn_ctxt fcx, @ty.t expected, &ast.block bloc)\n+            -> ast.block {\n+        alt (bloc.node.expr) {\n+            case (some[@ast.expr](?e_0)) {\n+                auto e_1 = pushdown_expr(fcx, expected, e_0);\n+                auto block_ = rec(stmts=bloc.node.stmts,\n+                                  expr=some[@ast.expr](e_1),\n+                                  index=bloc.node.index);\n+                ret fold.respan[ast.block_](bloc.span, block_);\n+            }\n+            case (none[@ast.expr]) {\n+                demand(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n+                ret bloc;\n+            }\n         }\n     }\n }\n \n+\n // Local variable resolution: the phase that finds all the types in the AST\n // and replaces opaque \"ty_local\" types with the resolved local types.\n \n@@ -1653,7 +1679,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         // Unify and write back to the function.\n-        auto f_1 = demand_expr(fcx, t_0, f_0);\n+        auto f_1 = Pushdown.pushdown_expr(fcx, t_0, f_0);\n \n         // Take the argument types out of the resulting function type.\n         auto t_1 = expr_ty(f_1);\n@@ -1675,7 +1701,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             alt (args_0.(i)) {\n                 case (some[@ast.expr](?e_0)) {\n                     auto arg_ty_1 = arg_tys_1.(i);\n-                    auto e_1 = demand_expr(fcx, arg_ty_1.ty, e_0);\n+                    auto e_1 = Pushdown.pushdown_expr(fcx, arg_ty_1.ty, e_0);\n                     _vec.push[option.t[@ast.expr]](args_1,\n                                                    some[@ast.expr](e_1));\n                 }\n@@ -1698,8 +1724,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         auto lhs_t0 = expr_ty(lhs_0);\n         auto rhs_t0 = expr_ty(rhs_0);\n \n-        auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n-        auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+        auto lhs_1 = Pushdown.pushdown_expr(fcx, rhs_t0, lhs_0);\n+        auto rhs_1 = Pushdown.pushdown_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n         auto ann = triv_ann(rhs_t0);\n         ret tup(lhs_1, rhs_1, ann);\n@@ -1741,10 +1767,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rhs_t0 = expr_ty(rhs_0);\n \n             // FIXME: Binops have a bit more subtlety than this.\n-            auto lhs_1 = demand_expr_full(fcx, rhs_t0, lhs_0,\n-                                          AUTODEREF_OK);\n-            auto rhs_1 = demand_expr_full(fcx, expr_ty(lhs_1), rhs_0,\n-                                          AUTODEREF_OK);\n+            auto lhs_1 = Pushdown.pushdown_expr_full(fcx, rhs_t0, lhs_0,\n+                                                     AUTODEREF_OK);\n+            auto rhs_1 = Pushdown.pushdown_expr_full(fcx, expr_ty(lhs_1),\n+                                                     rhs_0, AUTODEREF_OK);\n \n             auto t = strip_boxes(lhs_t0);\n             alt (binop) {\n@@ -1842,7 +1868,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n-                    auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n+                    auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty,\n+                                                         expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_ret(some(expr_1), boring_ann()));\n                 }\n@@ -1865,7 +1892,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n-                    auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n+                    auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty,\n+                                                         expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(some(expr_1), boring_ann()));\n                 }\n@@ -1876,7 +1904,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             /* FIXME: prove instead of check */\n             check (ast.is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n-            auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n+            auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_be(expr_1,\n                                                     boring_ann()));\n@@ -1918,7 +1946,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rhs_t = expr_ty(rhs_0);\n \n             auto chan_t = plain_ty(ty.ty_chan(rhs_t));\n-            auto lhs_1 = demand_expr(fcx, chan_t, lhs_0);\n+            auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n             alt (expr_ty(lhs_1).struct) {\n                 case (ty.ty_chan(?it)) {\n@@ -1928,7 +1956,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     fail;\n                 }\n             }\n-            auto rhs_1 = demand_expr(fcx, item_t, rhs_0);\n+            auto rhs_1 = Pushdown.pushdown_expr(fcx, item_t, rhs_0);\n \n             auto ann = triv_ann(chan_t);\n             auto newexpr = ast.expr_send(lhs_1, rhs_1, ann);\n@@ -1941,7 +1969,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto lhs_t1 = expr_ty(lhs_0);\n \n             auto port_t = plain_ty(ty.ty_port(lhs_t1));\n-            auto rhs_1 = demand_expr(fcx, port_t, rhs_0);\n+            auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n             alt (expr_ty(rhs_0).struct) {\n                 case (ty.ty_port(?it)) {\n@@ -1951,7 +1979,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     fail;\n                 }\n             }\n-            auto lhs_1 = demand_expr(fcx, item_t, lhs_0);\n+            auto lhs_1 = Pushdown.pushdown_expr(fcx, item_t, lhs_0);\n \n             auto ann = triv_ann(item_t);\n             auto newexpr = ast.expr_recv(lhs_1, rhs_1, ann);\n@@ -1960,7 +1988,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n+                                                 cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n             auto thn_t = block_ty(thn_0);\n@@ -1970,7 +1999,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             alt (elsopt) {\n                 case (some[@ast.expr](?els)) {\n                     auto els_0 = check_expr(fcx, els);\n-                    auto els_1 = demand_expr(fcx, thn_t, els_0);\n+                    auto els_1 = Pushdown.pushdown_expr(fcx, thn_t, els_0);\n                     elsopt_1 = some[@ast.expr](els_1);\n                     elsopt_t = expr_ty(els_1);\n                 }\n@@ -1980,7 +2009,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n+            auto thn_1 = Pushdown.pushdown_block(fcx, elsopt_t, thn_0);\n \n             auto ann = triv_ann(elsopt_t);\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2015,7 +2044,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n+                                                 cond_0);\n             auto body_1 = check_block(fcx, body);\n \n             auto ann = triv_ann(plain_ty(ty.ty_nil));\n@@ -2025,7 +2055,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n+                                                 cond_0);\n             auto body_1 = check_block(fcx, body);\n \n             auto ann = triv_ann(block_ty(body_1));\n@@ -2051,7 +2082,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             let vec[@ast.pat] pats_1 = vec();\n             for (@ast.pat pat_0 in pats_0) {\n-                pats_1 += vec(demand_pat(fcx, pattern_ty, pat_0));\n+                pats_1 += vec(Pushdown.pushdown_pat(fcx, pattern_ty, pat_0));\n             }\n \n             // Now typecheck the blocks.\n@@ -2068,15 +2099,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             let vec[ast.arm] arms_1 = vec();\n             auto i = 0u;\n             for (ast.block block_0 in blocks_0) {\n-                auto block_1 = demand_block(fcx, result_ty, block_0);\n+                auto block_1 = Pushdown.pushdown_block(fcx, result_ty,\n+                                                       block_0);\n                 auto pat_1 = pats_1.(i);\n                 auto arm = arms.(i);\n                 auto arm_1 = rec(pat=pat_1, block=block_1, index=arm.index);\n                 arms_1 += vec(arm_1);\n                 i += 1u;\n             }\n \n-            auto expr_1 = demand_expr(fcx, pattern_ty, expr_0);\n+            auto expr_1 = Pushdown.pushdown_expr(fcx, pattern_ty, expr_0);\n \n             auto ann = triv_ann(result_ty);\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2519,11 +2551,12 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n                     auto expr_1;\n                     alt (init.op) {\n                         case (ast.init_assign) {\n-                            expr_1 = demand_expr(fcx, lty, expr_0);\n+                            expr_1 = Pushdown.pushdown_expr(fcx, lty, expr_0);\n                         }\n                         case (ast.init_recv) {\n                             auto port_ty = plain_ty(ty.ty_port(lty));\n-                            expr_1 = demand_expr(fcx, port_ty, expr_0);\n+                            expr_1 = Pushdown.pushdown_expr(fcx, port_ty,\n+                                                            expr_0);\n                         }\n                     }\n                     auto init_0 = rec(expr = expr_1 with init);\n@@ -2594,7 +2627,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n                             ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n-    demand_expr(fcx, rty, e_);\n+    Pushdown.pushdown_expr(fcx, rty, e_);\n     auto item = ast.item_const(ident, t, e_, id, ann);\n     ret @fold.respan[ast.item_](sp, item);\n }"}]}