{"sha": "c76e55747b88949634438b6ed2e3f4dd24e799fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NmU1NTc0N2I4ODk0OTYzNDQzOGI2ZWQyZTNmNGRkMjRlNzk5ZmM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-01-17T21:07:27Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-01-19T16:30:45Z"}, "message": "Type check unnanotated constant items with NLL", "tree": {"sha": "f4a7d5ae1604a47344849efa861fd1b0e9f761bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a7d5ae1604a47344849efa861fd1b0e9f761bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76e55747b88949634438b6ed2e3f4dd24e799fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76e55747b88949634438b6ed2e3f4dd24e799fc", "html_url": "https://github.com/rust-lang/rust/commit/c76e55747b88949634438b6ed2e3f4dd24e799fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76e55747b88949634438b6ed2e3f4dd24e799fc/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65fe2516346f10dc8d670e9fdfbd4e4f99a5b34b", "url": "https://api.github.com/repos/rust-lang/rust/commits/65fe2516346f10dc8d670e9fdfbd4e4f99a5b34b", "html_url": "https://github.com/rust-lang/rust/commit/65fe2516346f10dc8d670e9fdfbd4e4f99a5b34b"}], "stats": {"total": 190, "additions": 128, "deletions": 62}, "files": [{"sha": "3e6aa358ee0d15d1d7491cd34f9bf2b1ff85225e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c76e55747b88949634438b6ed2e3f4dd24e799fc", "patch": "@@ -35,7 +35,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSubsts};\n use rustc::ty::{\n     self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserType,\n     CanonicalUserTypeAnnotation, UserTypeAnnotationIndex,\n@@ -283,7 +283,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n-                let annotation = self.cx.instantiated_type_annotations[&annotation_index];\n+                let annotation = &self.mir.user_type_annotations[annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -293,6 +293,39 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     terr,\n                 );\n             }\n+        } else {\n+            match *constant.literal {\n+                ty::LazyConst::Unevaluated(def_id, substs) => {\n+                    if let Err(terr) = self.cx.fully_perform_op(\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                            constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                        )),\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            constant,\n+                            \"bad constant type {:?} ({:?})\",\n+                            constant,\n+                            terr\n+                        );\n+                    }\n+                }\n+                ty::LazyConst::Evaluated(lit) => {\n+                    if let ty::FnDef(def_id, substs) = lit.ty.sty {\n+                        let tcx = self.tcx();\n+\n+                        let instantiated_predicates = tcx\n+                            .predicates_of(def_id)\n+                            .instantiate(tcx, substs);\n+                        self.cx.normalize_and_prove_instantiated_predicates(\n+                            instantiated_predicates,\n+                            location.to_locations(),\n+                        );\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -374,8 +407,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Checks that the constant's `ty` field matches up with what\n-    /// would be expected from its literal.\n+    /// Checks that the constant's `ty` field matches up with what would be\n+    /// expected from its literal. Unevaluated constants and well-formed\n+    /// constraints are checked by `visit_constant`.\n     fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         debug!(\n             \"sanitize_constant(constant={:?}, location={:?})\",\n@@ -387,35 +421,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ty::LazyConst::Unevaluated(..) => return,\n         };\n \n-        // FIXME(#46702) -- We need some way to get the predicates\n-        // associated with the \"pre-evaluated\" form of the\n-        // constant. For example, consider that the constant\n-        // may have associated constant projections (`<Foo as\n-        // Trait<'a, 'b>>::SOME_CONST`) that impose\n-        // constraints on `'a` and `'b`. These constraints\n-        // would be lost if we just look at the normalized\n-        // value.\n-        if let ty::FnDef(def_id, substs) = literal.ty.sty {\n-            let tcx = self.tcx();\n-            let type_checker = &mut self.cx;\n-\n-            // FIXME -- For now, use the substitutions from\n-            // `value.ty` rather than `value.val`. The\n-            // renumberer will rewrite them to independent\n-            // sets of regions; in principle, we ought to\n-            // derive the type of the `value.val` from \"first\n-            // principles\" and equate with value.ty, but as we\n-            // are transitioning to the miri-based system, we\n-            // don't have a handy function for that, so for\n-            // now we just ignore `value.val` regions.\n-\n-            let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-            type_checker.normalize_and_prove_instantiated_predicates(\n-                instantiated_predicates,\n-                location.to_locations(),\n-            );\n-        }\n-\n         debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n \n         if let Err(terr) = self.cx.eq_types(\n@@ -740,15 +745,6 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n-    /// For each user-type annotation (identified by a UserTypeAnnotationIndex), we create\n-    /// an \"instantiated\" version at the beginning of type check, which replaces each\n-    /// canonical variable with a fresh inference variable. These instantiated versions are\n-    /// stored either in this field or in user_substs, depending on the kind of user-type\n-    /// annotation. They are then referenced by the code which has the job of enforcing these\n-    /// annotations. Part of the reason for this setup is that it allows us to enforce basic\n-    /// WF criteria on the types even if the code that referenced them is dead\n-    /// code (see #54943).\n-    instantiated_type_annotations: FxHashMap<UserTypeAnnotationIndex, Ty<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -905,23 +901,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            instantiated_type_annotations: Default::default(),\n         };\n-        checker.instantiate_user_type_annotations();\n+        checker.check_user_type_annotations();\n         checker\n     }\n \n-    /// Instantiate canonical types from user type annotations in the `Mir` into the\n-    /// `TypeChecker`. Used when relating user type annotations and when checking if\n-    /// annotations are well-formed.\n-    fn instantiate_user_type_annotations(&mut self) {\n+    /// Equate the inferred type and the annotated type for user type annotations\n+    fn check_user_type_annotations(&mut self) {\n         debug!(\n-            \"instantiate_user_type_annotations: user_type_annotations={:?}\",\n+            \"check_user_type_annotations: user_type_annotations={:?}\",\n              self.mir.user_type_annotations\n         );\n-        for annotation_index in self.mir.user_type_annotations.indices() {\n-            let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } =\n-                self.mir.user_type_annotations[annotation_index];\n+        for user_annotation in &self.mir.user_type_annotations {\n+            let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let (annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n                 span, user_ty\n             );\n@@ -937,7 +929,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     ) {\n                         span_mirbug!(\n                             self,\n-                            self.mir.user_type_annotations[annotation_index],\n+                            user_annotation,\n                             \"bad user type ({:?} = {:?}): {:?}\",\n                             ty,\n                             inferred_ty,\n@@ -961,7 +953,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     ) {\n                         span_mirbug!(\n                             self,\n-                            self.mir.user_type_annotations[annotation_index],\n+                            user_annotation,\n                             \"bad user type AscribeUserType({:?}, {:?} {:?}): {:?}\",\n                             inferred_ty,\n                             def_id,\n@@ -971,12 +963,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 },\n             }\n-            self.instantiated_type_annotations.insert(annotation_index, inferred_ty);\n         }\n-        debug!(\n-            \"instantiate_user_type_annotations: instantiated_type_annotations={:?}\",\n-            self.instantiated_type_annotations,\n-        );\n     }\n \n     /// Given some operation `op` that manipulates types, proves\n@@ -1108,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        let annotated_type = self.instantiated_type_annotations[&user_ty.base];\n+        let annotated_type = self.mir.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n         let tcx = self.infcx.tcx;\n@@ -1293,7 +1280,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n-                        let annotation = self.instantiated_type_annotations[&annotation_index];\n+                        let annotation = &mir.user_type_annotations[annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n@@ -1352,7 +1339,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n-                    let annotation = self.instantiated_type_annotations[&projection.base];\n+                    let annotation = &mir.user_type_annotations[projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,"}, {"sha": "123be6b3e4098dc7911844576054e45b48db3f1f", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs?ref=c76e55747b88949634438b6ed2e3f4dd24e799fc", "patch": "@@ -0,0 +1,29 @@\n+// Test that we still check constants are well-formed, even when we there's no\n+// type annotation to check.\n+\n+#![feature(nll)]\n+\n+const FUN: fn(&'static ()) = |_| {};\n+struct A;\n+impl A {\n+    const ASSOCIATED_FUN: fn(&'static ()) = |_| {};\n+}\n+\n+struct B<'a>(&'a ());\n+impl B<'static> {\n+    const ALSO_ASSOCIATED_FUN: fn(&'static ()) = |_| {};\n+}\n+\n+trait Z: 'static {\n+    const TRAIT_ASSOCIATED_FUN: fn(&'static Self) = |_| ();\n+}\n+\n+impl Z for () {}\n+\n+fn main() {\n+    let x = ();\n+    FUN(&x);                        //~ ERROR `x` does not live long enough\n+    A::ASSOCIATED_FUN(&x);          //~ ERROR `x` does not live long enough\n+    B::ALSO_ASSOCIATED_FUN(&x);     //~ ERROR `x` does not live long enough\n+    <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+}"}, {"sha": "57cfaa2db043219a19b50e81d12fc6a3f7631228", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-2.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c76e55747b88949634438b6ed2e3f4dd24e799fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr?ref=c76e55747b88949634438b6ed2e3f4dd24e799fc", "patch": "@@ -0,0 +1,50 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:25:9\n+   |\n+LL |     FUN(&x);                        //~ ERROR `x` does not live long enough\n+   |     ----^^-\n+   |     |   |\n+   |     |   borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:26:23\n+   |\n+LL |     A::ASSOCIATED_FUN(&x);          //~ ERROR `x` does not live long enough\n+   |     ------------------^^-\n+   |     |                 |\n+   |     |                 borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:27:28\n+   |\n+LL |     B::ALSO_ASSOCIATED_FUN(&x);     //~ ERROR `x` does not live long enough\n+   |     -----------------------^^-\n+   |     |                      |\n+   |     |                      borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+LL |     <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:28:31\n+   |\n+LL |     <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+   |     --------------------------^^-\n+   |     |                         |\n+   |     |                         borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}