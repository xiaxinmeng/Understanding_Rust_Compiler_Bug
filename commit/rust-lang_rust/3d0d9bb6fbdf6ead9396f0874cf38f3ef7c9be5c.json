{"sha": "3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMGQ5YmI2ZmJkZjZlYWQ5Mzk2ZjA4NzRjZjM4ZjNlZjdjOWJlNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T22:56:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T22:56:20Z"}, "message": "auto merge of #20896 : sfackler/rust/atomic-rename, r=alexcrichton\n\nChange any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize\r\n\r\nCloses #20893\r\n\r\n[breaking-change]", "tree": {"sha": "9994c5b80534154e0130716d304d9185e7ae3481", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9994c5b80534154e0130716d304d9185e7ae3481"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "html_url": "https://github.com/rust-lang/rust/commit/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a44a19af29585c02e81e22ea7665f829ae0590a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a44a19af29585c02e81e22ea7665f829ae0590a", "html_url": "https://github.com/rust-lang/rust/commit/3a44a19af29585c02e81e22ea7665f829ae0590a"}, {"sha": "8b6cda3ce681d4d95c3097d12ed754975b4a07f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6cda3ce681d4d95c3097d12ed754975b4a07f6", "html_url": "https://github.com/rust-lang/rust/commit/8b6cda3ce681d4d95c3097d12ed754975b4a07f6"}], "stats": {"total": 587, "additions": 360, "deletions": 227}, "files": [{"sha": "c0cd034abfa4a414f71e7e91849d5e055b98978d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -137,8 +137,8 @@ unsafe impl<T: Sync + Send> Send for Weak<T> { }\n unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n \n struct ArcInner<T> {\n-    strong: atomic::AtomicUint,\n-    weak: atomic::AtomicUint,\n+    strong: atomic::AtomicUsize,\n+    weak: atomic::AtomicUsize,\n     data: T,\n }\n \n@@ -161,8 +161,8 @@ impl<T> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n         let x = box ArcInner {\n-            strong: atomic::AtomicUint::new(1),\n-            weak: atomic::AtomicUint::new(1),\n+            strong: atomic::AtomicUsize::new(1),\n+            weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n         Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n@@ -619,7 +619,7 @@ mod tests {\n     use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n \n-    struct Canary(*mut atomic::AtomicUint);\n+    struct Canary(*mut atomic::AtomicUsize);\n \n     impl Drop for Canary\n     {\n@@ -743,16 +743,16 @@ mod tests {\n \n     #[test]\n     fn drop_arc() {\n-        let mut canary = atomic::AtomicUint::new(0);\n-        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n+        let mut canary = atomic::AtomicUsize::new(0);\n+        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n         drop(x);\n         assert!(canary.load(Acquire) == 1);\n     }\n \n     #[test]\n     fn drop_arc_weak() {\n-        let mut canary = atomic::AtomicUint::new(0);\n-        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n+        let mut canary = atomic::AtomicUsize::new(0);\n+        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n         let arc_weak = arc.downgrade();\n         assert!(canary.load(Acquire) == 0);\n         drop(arc);"}, {"sha": "e5f9b2513e277c2d78666c1fee9b8b419d9d0c95", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -2199,7 +2199,7 @@ mod tests {\n \n     #[test]\n     fn test_map_in_place_zero_drop_count() {\n-        use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n+        use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n         #[derive(Clone, PartialEq, Show)]\n         struct Nothing;\n@@ -2213,7 +2213,7 @@ mod tests {\n             }\n         }\n         const NUM_ELEMENTS: uint = 2;\n-        static DROP_COUNTER: AtomicUint = ATOMIC_UINT_INIT;\n+        static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n \n         let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n "}, {"sha": "aa93d9ed8379230e1eb5dc9c7baa4d3ae962a772", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 258, "deletions": 127, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -15,7 +15,7 @@\n //! types.\n //!\n //! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicInt`, `AtomicUint`, and `AtomicOption`.\n+//! types, including `AtomicBool`, `AtomicIsize`, `AtomicUsize`, and `AtomicOption`.\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!\n@@ -41,11 +41,11 @@\n //!\n //! ```\n //! use std::sync::Arc;\n-//! use std::sync::atomic::{AtomicUint, Ordering};\n+//! use std::sync::atomic::{AtomicUsize, Ordering};\n //! use std::thread::Thread;\n //!\n //! fn main() {\n-//!     let spinlock = Arc::new(AtomicUint::new(1));\n+//!     let spinlock = Arc::new(AtomicUsize::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n //!     Thread::spawn(move|| {\n@@ -60,9 +60,9 @@\n //! Keep a global count of live tasks:\n //!\n //! ```\n-//! use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n+//! use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+//! static GLOBAL_TASK_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n //!\n //! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, Ordering::SeqCst);\n //! println!(\"live tasks: {}\", old_task_count + 1);\n@@ -80,31 +80,31 @@ use cell::UnsafeCell;\n /// A boolean type which can be safely shared between threads.\n #[stable]\n pub struct AtomicBool {\n-    v: UnsafeCell<uint>,\n+    v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n-pub struct AtomicInt {\n-    v: UnsafeCell<int>,\n+#[stable]\n+pub struct AtomicIsize {\n+    v: UnsafeCell<isize>,\n }\n \n-unsafe impl Sync for AtomicInt {}\n+unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n-pub struct AtomicUint {\n-    v: UnsafeCell<uint>,\n+#[stable]\n+pub struct AtomicUsize {\n+    v: UnsafeCell<usize>,\n }\n \n-unsafe impl Sync for AtomicUint {}\n+unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n-    p: UnsafeCell<uint>,\n+    p: UnsafeCell<usize>,\n }\n \n unsafe impl<T> Sync for AtomicPtr<T> {}\n@@ -149,17 +149,17 @@ pub enum Ordering {\n #[stable]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n-/// An `AtomicInt` initialized to `0`.\n-#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n-pub const ATOMIC_INT_INIT: AtomicInt =\n-        AtomicInt { v: UnsafeCell { value: 0 } };\n-/// An `AtomicUint` initialized to `0`.\n-#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n-pub const ATOMIC_UINT_INIT: AtomicUint =\n-        AtomicUint { v: UnsafeCell { value: 0, } };\n+/// An `AtomicIsize` initialized to `0`.\n+#[stable]\n+pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n+        AtomicIsize { v: UnsafeCell { value: 0 } };\n+/// An `AtomicUsize` initialized to `0`.\n+#[stable]\n+pub const ATOMIC_USIZE_INIT: AtomicUsize =\n+        AtomicUsize { v: UnsafeCell { value: 0, } };\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n-const UINT_TRUE: uint = -1;\n+const UINT_TRUE: usize = -1;\n \n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n@@ -199,7 +199,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n+        unsafe { atomic_load(self.v.get() as *const usize, order) > 0 }\n     }\n \n     /// Stores a value into the bool.\n@@ -323,7 +323,7 @@ impl AtomicBool {\n     ///\n     /// let foo = AtomicBool::new(true);\n     /// assert_eq!(true, foo.fetch_nand(true, Ordering::SeqCst));\n-    /// assert_eq!(0, foo.load(Ordering::SeqCst) as int);\n+    /// assert_eq!(0, foo.load(Ordering::SeqCst) as usize);\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(false);\n@@ -403,23 +403,23 @@ impl AtomicBool {\n     }\n }\n \n-#[unstable = \"awaiting int/uint conventions, types may change\"]\n-impl AtomicInt {\n-    /// Creates a new `AtomicInt`.\n+#[stable]\n+impl AtomicIsize {\n+    /// Creates a new `AtomicIsize`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::AtomicInt;\n+    /// use std::sync::atomic::AtomicIsize;\n     ///\n-    /// let atomic_forty_two  = AtomicInt::new(42);\n+    /// let atomic_forty_two  = AtomicIsize::new(42);\n     /// ```\n     #[inline]\n-    pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: UnsafeCell::new(v)}\n+    pub fn new(v: isize) -> AtomicIsize {\n+        AtomicIsize {v: UnsafeCell::new(v)}\n     }\n \n-    /// Loads a value from the int.\n+    /// Loads a value from the isize.\n     ///\n     /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n@@ -430,58 +430,58 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let some_int = AtomicInt::new(5);\n+    /// let some_isize = AtomicIsize::new(5);\n     ///\n-    /// let value = some_int.load(Ordering::Relaxed);\n+    /// let value = some_isize.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(self.v.get() as *const int, order) }\n+    pub fn load(&self, order: Ordering) -> isize {\n+        unsafe { atomic_load(self.v.get() as *const isize, order) }\n     }\n \n-    /// Stores a value into the int.\n+    /// Stores a value into the isize.\n     ///\n     /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let some_int = AtomicInt::new(5);\n+    /// let some_isize = AtomicIsize::new(5);\n     ///\n-    /// some_int.store(10, Ordering::Relaxed);\n+    /// some_isize.store(10, Ordering::Relaxed);\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    pub fn store(&self, val: int, order: Ordering) {\n+    pub fn store(&self, val: isize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Stores a value into the int, returning the old value.\n+    /// Stores a value into the isize, returning the old value.\n     ///\n     /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let some_int = AtomicInt::new(5);\n+    /// let some_isize = AtomicIsize::new(5);\n     ///\n-    /// let value = some_int.swap(10, Ordering::Relaxed);\n+    /// let value = some_isize.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn swap(&self, val: int, order: Ordering) -> int {\n+    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the int if the current value is the same as the expected value.\n+    /// Stores a value into the isize if the current value is the same as the expected value.\n     ///\n     /// If the return value is equal to `old` then the value was updated.\n     ///\n@@ -491,112 +491,112 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let some_int = AtomicInt::new(5);\n+    /// let some_isize = AtomicIsize::new(5);\n     ///\n-    /// let value = some_int.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// let value = some_isize.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add an int to the current value, returning the previous value.\n+    /// Add an isize to the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let foo = AtomicInt::new(0);\n+    /// let foo = AtomicIsize::new(0);\n     /// assert_eq!(0, foo.fetch_add(10, Ordering::SeqCst));\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract an int from the current value, returning the previous value.\n+    /// Subtract an isize from the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let foo = AtomicInt::new(0);\n+    /// let foo = AtomicIsize::new(0);\n     /// assert_eq!(0, foo.fetch_sub(10, Ordering::SeqCst));\n     /// assert_eq!(-10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current int, returning the previous value.\n+    /// Bitwise and with the current isize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let foo = AtomicInt::new(0b101101);\n+    /// let foo = AtomicIsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current int, returning the previous value.\n+    /// Bitwise or with the current isize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let foo = AtomicInt::new(0b101101);\n+    /// let foo = AtomicIsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current int, returning the previous value.\n+    /// Bitwise xor with the current isize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n     ///\n-    /// let foo = AtomicInt::new(0b101101);\n+    /// let foo = AtomicIsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[unstable = \"awaiting int/uint conventions, types may change\"]\n-impl AtomicUint {\n-    /// Creates a new `AtomicUint`.\n+#[stable]\n+impl AtomicUsize {\n+    /// Creates a new `AtomicUsize`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::AtomicUint;\n+    /// use std::sync::atomic::AtomicUsize;\n     ///\n-    /// let atomic_forty_two = AtomicUint::new(42u);\n+    /// let atomic_forty_two = AtomicUsize::new(42u);\n     /// ```\n     #[inline]\n-    pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: UnsafeCell::new(v) }\n+    pub fn new(v: usize) -> AtomicUsize {\n+        AtomicUsize { v: UnsafeCell::new(v) }\n     }\n \n-    /// Loads a value from the uint.\n+    /// Loads a value from the usize.\n     ///\n     /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n@@ -607,58 +607,58 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let some_uint = AtomicUint::new(5);\n+    /// let some_usize = AtomicUsize::new(5);\n     ///\n-    /// let value = some_uint.load(Ordering::Relaxed);\n+    /// let value = some_usize.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(self.v.get() as *const uint, order) }\n+    pub fn load(&self, order: Ordering) -> usize {\n+        unsafe { atomic_load(self.v.get() as *const usize, order) }\n     }\n \n-    /// Stores a value into the uint.\n+    /// Stores a value into the usize.\n     ///\n     /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let some_uint = AtomicUint::new(5);\n+    /// let some_usize = AtomicUsize::new(5);\n     ///\n-    /// some_uint.store(10, Ordering::Relaxed);\n+    /// some_usize.store(10, Ordering::Relaxed);\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    pub fn store(&self, val: uint, order: Ordering) {\n+    pub fn store(&self, val: usize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Stores a value into the uint, returning the old value.\n+    /// Stores a value into the usize, returning the old value.\n     ///\n     /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let some_uint = AtomicUint::new(5);\n+    /// let some_usize= AtomicUsize::new(5);\n     ///\n-    /// let value = some_uint.swap(10, Ordering::Relaxed);\n+    /// let value = some_usize.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the uint if the current value is the same as the expected value.\n+    /// Stores a value into the usize if the current value is the same as the expected value.\n     ///\n     /// If the return value is equal to `old` then the value was updated.\n     ///\n@@ -668,91 +668,91 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let some_uint = AtomicUint::new(5);\n+    /// let some_usize = AtomicUsize::new(5);\n     ///\n-    /// let value = some_uint.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// let value = some_usize.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add to the current uint, returning the previous value.\n+    /// Add to the current usize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let foo = AtomicUint::new(0);\n+    /// let foo = AtomicUsize::new(0);\n     /// assert_eq!(0, foo.fetch_add(10, Ordering::SeqCst));\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract from the current uint, returning the previous value.\n+    /// Subtract from the current usize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let foo = AtomicUint::new(10);\n+    /// let foo = AtomicUsize::new(10);\n     /// assert_eq!(10, foo.fetch_sub(10, Ordering::SeqCst));\n     /// assert_eq!(0, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current uint, returning the previous value.\n+    /// Bitwise and with the current usize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let foo = AtomicUint::new(0b101101);\n+    /// let foo = AtomicUsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current uint, returning the previous value.\n+    /// Bitwise or with the current usize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let foo = AtomicUint::new(0b101101);\n+    /// let foo = AtomicUsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current uint, returning the previous value.\n+    /// Bitwise xor with the current usize, returning the previous value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n     ///\n-    /// let foo = AtomicUint::new(0b101101);\n+    /// let foo = AtomicUsize::new(0b101101);\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n@@ -771,7 +771,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as uint) }\n+        AtomicPtr { p: UnsafeCell::new(p as usize) }\n     }\n \n     /// Loads a value from the pointer.\n@@ -823,7 +823,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n+        unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n     }\n \n     /// Stores a value into the pointer, returning the old value.\n@@ -845,7 +845,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n+        unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the expected value.\n@@ -872,8 +872,8 @@ impl<T> AtomicPtr<T> {\n     #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get(), old as uint,\n-                                    new as uint, order) as *mut T\n+            atomic_compare_and_swap(self.p.get(), old as usize,\n+                                    new as usize, order) as *mut T\n         }\n     }\n }\n@@ -1035,3 +1035,134 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n+\n+#[deprecated=\"renamed to AtomicIsize\"]\n+#[allow(missing_docs)]\n+pub struct AtomicInt {\n+    v: UnsafeCell<int>,\n+}\n+\n+unsafe impl Sync for AtomicInt {}\n+\n+#[deprecated=\"renamed to AtomicUsize\"]\n+#[allow(missing_docs)]\n+pub struct AtomicUint {\n+    v: UnsafeCell<uint>,\n+}\n+\n+unsafe impl Sync for AtomicUint {}\n+\n+#[deprecated=\"use ATOMIC_ISIZE_INIT instead\"]\n+#[allow(missing_docs, deprecated)]\n+pub const ATOMIC_INT_INIT: AtomicInt =\n+        AtomicInt { v: UnsafeCell { value: 0 } };\n+#[deprecated=\"use ATOMIC_USIZE_INIT instead\"]\n+#[allow(missing_docs, deprecated)]\n+pub const ATOMIC_UINT_INIT: AtomicUint =\n+        AtomicUint { v: UnsafeCell { value: 0, } };\n+\n+#[allow(missing_docs, deprecated)]\n+impl AtomicInt {\n+    #[inline]\n+    pub fn new(v: int) -> AtomicInt {\n+        AtomicInt {v: UnsafeCell::new(v)}\n+    }\n+\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> int {\n+        unsafe { atomic_load(self.v.get() as *const int, order) }\n+    }\n+\n+    #[inline]\n+    pub fn store(&self, val: int, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    #[inline]\n+    pub fn swap(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}\n+\n+#[allow(missing_docs, deprecated)]\n+impl AtomicUint {\n+    #[inline]\n+    pub fn new(v: uint) -> AtomicUint {\n+        AtomicUint { v: UnsafeCell::new(v) }\n+    }\n+\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> uint {\n+        unsafe { atomic_load(self.v.get() as *const uint, order) }\n+    }\n+\n+    #[inline]\n+    pub fn store(&self, val: uint, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    #[inline]\n+    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}"}, {"sha": "8e3c7f4595a48cafe2865ecbdafbf6b389b2c461", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -30,49 +30,49 @@ fn bool_and() {\n \n #[test]\n fn uint_and() {\n-    let x = AtomicUint::new(0xf731);\n+    let x = AtomicUsize::new(0xf731);\n     assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n }\n \n #[test]\n fn uint_or() {\n-    let x = AtomicUint::new(0xf731);\n+    let x = AtomicUsize::new(0xf731);\n     assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n }\n \n #[test]\n fn uint_xor() {\n-    let x = AtomicUint::new(0xf731);\n+    let x = AtomicUsize::new(0xf731);\n     assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n #[test]\n fn int_and() {\n-    let x = AtomicInt::new(0xf731);\n+    let x = AtomicIsize::new(0xf731);\n     assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n }\n \n #[test]\n fn int_or() {\n-    let x = AtomicInt::new(0xf731);\n+    let x = AtomicIsize::new(0xf731);\n     assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n }\n \n #[test]\n fn int_xor() {\n-    let x = AtomicInt::new(0xf731);\n+    let x = AtomicIsize::new(0xf731);\n     assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n-static S_INT  : AtomicInt  = ATOMIC_INT_INIT;\n-static S_UINT : AtomicUint = ATOMIC_UINT_INIT;\n+static S_INT  : AtomicIsize  = ATOMIC_ISIZE_INIT;\n+static S_UINT : AtomicUsize = ATOMIC_USIZE_INIT;\n \n #[test]\n fn static_init() {"}, {"sha": "6de466eb20bfc9a51f3471700256b5cc5308e665", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -15,18 +15,18 @@ use prelude::v1::*;\n use libc;\n use os;\n use std::io::net::ip::*;\n-use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUint = ATOMIC_UINT_INIT;\n+    static NEXT_OFFSET: AtomicUsize = ATOMIC_USIZE_INIT;\n     base_port() + NEXT_OFFSET.fetch_add(1, Ordering::Relaxed) as u16\n }\n \n // iOS has a pretty long tmpdir path which causes pipe creation\n // to like: invalid argument: path must be smaller than SUN_LEN\n fn next_test_unix_socket() -> String {\n-    static COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable."}, {"sha": "588f729d8005d4687157cf8e8b88e27482dd95d7", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -54,7 +54,7 @@ use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n use str::{Str, StrExt};\n use string::{String, ToString};\n-use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, Ordering};\n+use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use vec::Vec;\n \n #[cfg(unix)] use ffi::{self, CString};\n@@ -590,7 +590,7 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicInt = ATOMIC_INT_INIT;\n+static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n /// Sets the process exit code\n ///"}, {"sha": "f2d66e1a4d765ea91545e740f35ec77305c65cd4", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicInt = atomic::ATOMIC_INT_INIT;\n+    static ENABLED: atomic::AtomicIsize = atomic::ATOMIC_ISIZE_INIT;\n     match ENABLED.load(Ordering::SeqCst) {\n         1 => return false,\n         2 => return true,"}, {"sha": "6326e4c08f190e46b53a751a5ca08538b4310dbf", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -83,16 +83,16 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n //\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n-static CALLBACKS: [atomic::AtomicUint; MAX_CALLBACKS] =\n-        [atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n-         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT];\n-static CALLBACK_CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n+        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n+static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n "}, {"sha": "be293e8d4cb99b7a8d2b9ac16da85d37cb82c107", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -46,7 +46,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> uint {\n-    static MIN: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+    static MIN: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n     match MIN.load(Ordering::SeqCst) {\n         0 => {}\n         n => return n - 1,"}, {"sha": "bcd5f56a353792790e6467a5835e0987a03ba63a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n+use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n use sync::poison::{self, LockResult};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n@@ -78,7 +78,7 @@ unsafe impl Sync for Condvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n-    mutex: AtomicUint,\n+    mutex: AtomicUsize,\n }\n \n unsafe impl Send for StaticCondvar {}\n@@ -88,7 +88,7 @@ unsafe impl Sync for StaticCondvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n-    mutex: ATOMIC_UINT_INIT,\n+    mutex: ATOMIC_USIZE_INIT,\n };\n \n impl Condvar {\n@@ -99,7 +99,7 @@ impl Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n                 inner: unsafe { sys::Condvar::new() },\n-                mutex: AtomicUint::new(0),\n+                mutex: AtomicUsize::new(0),\n             }\n         }\n     }"}, {"sha": "ca667e65e30cc50b06868872b867761f9e22054d", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -42,7 +42,7 @@ use core::prelude::*;\n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use core::mem;\n-use sync::atomic::{AtomicUint, Ordering};\n+use sync::atomic::{AtomicUsize, Ordering};\n \n // Various states you can find a port in.\n const EMPTY: uint = 0;          // initial state: no data, no blocked reciever\n@@ -56,7 +56,7 @@ const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n-    state: AtomicUint,\n+    state: AtomicUsize,\n     // One-shot data slot location\n     data: Option<T>,\n     // when used for the second time, a oneshot channel must be upgraded, and\n@@ -93,7 +93,7 @@ impl<T: Send> Packet<T> {\n         Packet {\n             data: None,\n             upgrade: NothingSent,\n-            state: AtomicUint::new(EMPTY),\n+            state: AtomicUsize::new(EMPTY),\n         }\n     }\n "}, {"sha": "c97af4c6bca3611355140f7f8ec60ef8950e2890", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -25,7 +25,7 @@ use core::prelude::*;\n use core::cmp;\n use core::int;\n \n-use sync::atomic::{AtomicUint, AtomicInt, AtomicBool, Ordering};\n+use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::mpsc_queue as mpsc;\n use sync::mpsc::select::StartResult::*;\n@@ -42,17 +42,17 @@ const MAX_STEALS: int = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n-    cnt: AtomicInt, // How many items are on this channel\n+    cnt: AtomicIsize, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: AtomicUint, // SignalToken for wake up\n+    to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n-    channels: AtomicInt,\n+    channels: AtomicIsize,\n \n     // See the discussion in Port::drop and the channel send methods for what\n     // these are used for\n     port_dropped: AtomicBool,\n-    sender_drain: AtomicInt,\n+    sender_drain: AtomicIsize,\n \n     // this lock protects various portions of this implementation during\n     // select()\n@@ -70,12 +70,12 @@ impl<T: Send> Packet<T> {\n     pub fn new() -> Packet<T> {\n         let p = Packet {\n             queue: mpsc::Queue::new(),\n-            cnt: AtomicInt::new(0),\n+            cnt: AtomicIsize::new(0),\n             steals: 0,\n-            to_wake: AtomicUint::new(0),\n-            channels: AtomicInt::new(2),\n+            to_wake: AtomicUsize::new(0),\n+            channels: AtomicIsize::new(2),\n             port_dropped: AtomicBool::new(false),\n-            sender_drain: AtomicInt::new(0),\n+            sender_drain: AtomicIsize::new(0),\n             select_lock: Mutex::new(()),\n         };\n         return p;"}, {"sha": "34fd6bb70dc9a94fb840a5aa6e1de187fcac757c", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -41,7 +41,7 @@ use alloc::boxed::Box;\n use core::mem;\n use core::cell::UnsafeCell;\n \n-use sync::atomic::{AtomicPtr, AtomicUint, Ordering};\n+use sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n \n // Node within the linked list queue of messages to send\n struct Node<T> {\n@@ -69,8 +69,8 @@ pub struct Queue<T> {\n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n     cache_bound: uint,\n-    cache_additions: AtomicUint,\n-    cache_subtractions: AtomicUint,\n+    cache_additions: AtomicUsize,\n+    cache_subtractions: AtomicUsize,\n }\n \n unsafe impl<T: Send> Send for Queue<T> { }\n@@ -117,8 +117,8 @@ impl<T: Send> Queue<T> {\n             first: UnsafeCell::new(n1),\n             tail_copy: UnsafeCell::new(n1),\n             cache_bound: bound,\n-            cache_additions: AtomicUint::new(0),\n-            cache_subtractions: AtomicUint::new(0),\n+            cache_additions: AtomicUsize::new(0),\n+            cache_subtractions: AtomicUsize::new(0),\n         }\n     }\n "}, {"sha": "a03add8c5325517286ff9a8f6162c3c2ecf6a078", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -28,7 +28,7 @@ use core::cmp;\n use core::int;\n use thread::Thread;\n \n-use sync::atomic::{AtomicInt, AtomicUint, Ordering, AtomicBool};\n+use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::spsc_queue as spsc;\n@@ -42,9 +42,9 @@ const MAX_STEALS: int = 1 << 20;\n pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n-    cnt: AtomicInt, // How many items are on this channel\n+    cnt: AtomicIsize, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: AtomicUint, // SignalToken for the blocked thread to wake up\n+    to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n@@ -79,9 +79,9 @@ impl<T: Send> Packet<T> {\n         Packet {\n             queue: unsafe { spsc::Queue::new(128) },\n \n-            cnt: AtomicInt::new(0),\n+            cnt: AtomicIsize::new(0),\n             steals: 0,\n-            to_wake: AtomicUint::new(0),\n+            to_wake: AtomicUsize::new(0),\n \n             port_dropped: AtomicBool::new(false),\n         }"}, {"sha": "30304dffb75a52557db36710d0cb95b60db7c0e7", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -41,15 +41,15 @@ use self::Blocker::*;\n use vec::Vec;\n use core::mem;\n \n-use sync::atomic::{Ordering, AtomicUint};\n+use sync::atomic::{Ordering, AtomicUsize};\n use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n use sync::mpsc::select::StartResult::{self, Installed, Abort};\n use sync::{Mutex, MutexGuard};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n-    channels: AtomicUint,\n+    channels: AtomicUsize,\n \n     lock: Mutex<State<T>>,\n }\n@@ -138,7 +138,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n impl<T: Send> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n-            channels: AtomicUint::new(1),\n+            channels: AtomicUsize::new(1),\n             lock: Mutex::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,"}, {"sha": "6231a91833d47a3c9d0f604ad24ac30c46e8fcbd", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -17,7 +17,7 @@ use int;\n use marker::Sync;\n use mem::drop;\n use ops::FnOnce;\n-use sync::atomic::{AtomicInt, Ordering, ATOMIC_INT_INIT};\n+use sync::atomic::{AtomicIsize, Ordering, ATOMIC_ISIZE_INIT};\n use sync::{StaticMutex, MUTEX_INIT};\n \n /// A synchronization primitive which can be used to run a one-time global\n@@ -39,8 +39,8 @@ use sync::{StaticMutex, MUTEX_INIT};\n #[stable]\n pub struct Once {\n     mutex: StaticMutex,\n-    cnt: AtomicInt,\n-    lock_cnt: AtomicInt,\n+    cnt: AtomicIsize,\n+    lock_cnt: AtomicIsize,\n }\n \n unsafe impl Sync for Once {}\n@@ -49,8 +49,8 @@ unsafe impl Sync for Once {}\n #[stable]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: ATOMIC_INT_INIT,\n-    lock_cnt: ATOMIC_INT_INIT,\n+    cnt: ATOMIC_ISIZE_INIT,\n+    lock_cnt: ATOMIC_ISIZE_INIT,\n };\n \n impl Once {"}, {"sha": "edd16e0c0629e3f5a50a8c7424b153a9dc979374", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -58,7 +58,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{self, AtomicUint, Ordering};\n+use sync::atomic::{self, AtomicUsize, Ordering};\n use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n@@ -97,7 +97,7 @@ pub struct StaticKey {\n \n /// Inner contents of `StaticKey`, created by the `INIT_INNER` constant.\n pub struct StaticKeyInner {\n-    key: AtomicUint,\n+    key: AtomicUsize,\n }\n \n /// A type for a safely managed OS-based TLS slot.\n@@ -137,7 +137,7 @@ pub const INIT: StaticKey = StaticKey {\n ///\n /// This value allows specific configuration of the destructor for a TLS key.\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::ATOMIC_UINT_INIT,\n+    key: atomic::ATOMIC_USIZE_INIT,\n };\n \n static INIT_KEYS: Once = ONCE_INIT;"}, {"sha": "c0c231a9e7303788e74337aedbc4ab60c864cb72", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -211,7 +211,7 @@ impl Timer {\n         // instead of ()\n         HELPER.boot(|| {}, helper);\n \n-        static ID: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+        static ID: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n         let id = ID.fetch_add(1, Ordering::Relaxed);\n         Ok(Timer {\n             id: id,"}, {"sha": "fcdd4ff7c5440832c0a2d7d65be66ab0c2873322", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -10,17 +10,17 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n use alloc::{self, heap};\n \n use libc::DWORD;\n use sys::sync as ffi;\n \n const SPIN_COUNT: DWORD = 4000;\n \n-pub struct Mutex { inner: AtomicUint }\n+pub struct Mutex { inner: AtomicUsize }\n \n-pub const MUTEX_INIT: Mutex = Mutex { inner: ATOMIC_UINT_INIT };\n+pub const MUTEX_INIT: Mutex = Mutex { inner: ATOMIC_USIZE_INIT };\n \n unsafe impl Sync for Mutex {}\n \n@@ -32,7 +32,7 @@ pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n impl Mutex {\n     #[inline]\n     pub unsafe fn new() -> Mutex {\n-        Mutex { inner: AtomicUint::new(init_lock() as uint) }\n+        Mutex { inner: AtomicUsize::new(init_lock() as uint) }\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "cbe56b00c13d59be061059d437efa6751a80c417", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: uint = 1;\n-pub const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+pub const C2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n pub const C3: fn() = foo;\n pub const C4: uint = C1 * C1 + C1 / C1;\n pub const C5: &'static uint = &C4;\n \n pub static S1: uint = 3;\n-pub static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+pub static S2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n \n fn foo() {}"}, {"sha": "9807fc43140d9a8426256f5e315116de7a8d855b", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -17,9 +17,9 @@ use std::ptr;\n fn main() {\n     let x = ATOMIC_BOOL_INIT;\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_INT_INIT;\n+    let x = ATOMIC_ISIZE_INIT;\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_UINT_INIT;\n+    let x = ATOMIC_USIZE_INIT;\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x: AtomicPtr<usize> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of borrowed content"}, {"sha": "e4782e28928748b584c031bc4405658fb70df79d", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -12,10 +12,10 @@\n \n extern crate \"issue-17718\" as other;\n \n-use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n const C1: uint = 1;\n-const C2: AtomicUint = ATOMIC_UINT_INIT;\n+const C2: AtomicUsize = ATOMIC_USIZE_INIT;\n const C3: fn() = foo;\n const C4: uint = C1 * C1 + C1 / C1;\n const C5: &'static uint = &C4;\n@@ -25,7 +25,7 @@ const C6: uint = {\n };\n \n static S1: uint = 3;\n-static S2: AtomicUint = ATOMIC_UINT_INIT;\n+static S2: AtomicUsize = ATOMIC_USIZE_INIT;\n \n mod test {\n     static A: uint = 4;"}, {"sha": "c7149fa503bb3d2837503ac6355a20cd03e6501d", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -15,7 +15,7 @@\n \n use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n use std::sync::Arc;\n-use std::sync::atomic::{AtomicUint, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n@@ -30,7 +30,7 @@ fn test() {\n     let mut l = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n     let addr = l.socket_name().unwrap();\n     let mut a = l.listen().unwrap();\n-    let cnt = Arc::new(AtomicUint::new(0));\n+    let cnt = Arc::new(AtomicUsize::new(0));\n \n     let (srv_tx, srv_rx) = channel();\n     let (cli_tx, cli_rx) = channel();"}, {"sha": "9e74c6da548996b6876dccfc5755059a38d1178c", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c", "patch": "@@ -8,27 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n use std::rand::{thread_rng, Rng, Rand};\n use std::thread::Thread;\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n-static drop_counts: [AtomicUint;  MAX_LEN] =\n-    // FIXME #5244: AtomicUint is not Copy.\n+static drop_counts: [AtomicUsize;  MAX_LEN] =\n+    // FIXME #5244: AtomicUsize is not Copy.\n     [\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n-        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n      ];\n \n-static creation_count: AtomicUint = ATOMIC_UINT_INIT;\n+static creation_count: AtomicUsize = ATOMIC_USIZE_INIT;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: uint, creation_id: uint }"}]}