{"sha": "7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMjIxOWRjNzZkNmNkZGM0NmVhZGIyYjJkZDY3NDc5NWUwZWZjZTg=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-05-28T02:21:20Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-27T14:10:26Z"}, "message": "Track expr parents during lowering, use parent map when checking if unsafe exprs are within unsafe blocks", "tree": {"sha": "7c2dbb2ea490684de4f49d28fb1c3928f1194728", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c2dbb2ea490684de4f49d28fb1c3928f1194728"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "html_url": "https://github.com/rust-lang/rust/commit/7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ce44be2ab7e9a99eece1c2e254f15ad1c6d73c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce44be2ab7e9a99eece1c2e254f15ad1c6d73c5", "html_url": "https://github.com/rust-lang/rust/commit/9ce44be2ab7e9a99eece1c2e254f15ad1c6d73c5"}], "stats": {"total": 277, "additions": 177, "deletions": 100}, "files": [{"sha": "076d1a4fa9fb12f15eb45805ac76eb69379aa233", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "patch": "@@ -184,6 +184,7 @@ pub struct Body {\n     /// The `ExprId` of the actual body expression.\n     pub body_expr: ExprId,\n     pub item_scope: ItemScope,\n+    pub parent_map: FxHashMap<ExprId, ExprId>,\n }\n \n pub type ExprPtr = AstPtr<ast::Expr>;"}, {"sha": "a1678adeb8b4c7ffd6e6f23ff7796c0ae1026c52", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 164, "deletions": 88, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "patch": "@@ -15,6 +15,7 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr,\n };\n+use rustc_hash::FxHashMap;\n use test_utils::mark;\n \n use crate::{\n@@ -74,6 +75,7 @@ pub(super) fn lower(\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n             item_scope: Default::default(),\n+            parent_map: FxHashMap::default(),\n         },\n         item_trees: {\n             let mut map = FxHashMap::default();\n@@ -171,11 +173,28 @@ impl ExprCollector<'_> {\n         id\n     }\n \n+    fn update_parent_map(\n+        &mut self,\n+        (parent_expr, children_exprs): (ExprId, Vec<ExprId>),\n+    ) -> ExprId {\n+        for child_expr in children_exprs {\n+            self.body.parent_map.insert(child_expr, parent_expr);\n+        }\n+\n+        parent_expr\n+    }\n+\n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        let parent_and_children = self.collect_expr_inner(expr);\n+        self.update_parent_map(parent_and_children)\n+    }\n+\n+    fn collect_expr_inner(&mut self, expr: ast::Expr) -> (ExprId, Vec<ExprId>) {\n         let syntax_ptr = AstPtr::new(&expr);\n         if !self.expander.is_cfg_enabled(&expr) {\n-            return self.missing_expr();\n+            return (self.missing_expr(), vec![]);\n         }\n+\n         match expr {\n             ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n@@ -205,32 +224,48 @@ impl ExprCollector<'_> {\n                                     guard: None,\n                                 },\n                             ];\n-                            return self\n-                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n+                            let children_exprs = if let Some(else_branch) = else_branch {\n+                                vec![match_expr, then_branch, else_branch]\n+                            } else {\n+                                vec![match_expr, then_branch]\n+                            };\n+                            return (\n+                                self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n+                                children_exprs,\n+                            );\n                         }\n                     },\n                 };\n \n-                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n+                let children_exprs = if let Some(else_branch) = else_branch {\n+                    vec![then_branch, else_branch, condition]\n+                } else {\n+                    vec![then_branch, condition]\n+                };\n+\n+                (\n+                    self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr),\n+                    children_exprs,\n+                )\n             }\n             ast::Expr::EffectExpr(e) => match e.effect() {\n                 ast::Effect::Try(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                    (self.alloc_expr(Expr::TryBlock { body }, syntax_ptr), vec![body])\n                 }\n                 ast::Effect::Unsafe(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n+                    (self.alloc_expr(Expr::Unsafe { body }, syntax_ptr), vec![body])\n                 }\n                 // FIXME: we need to record these effects somewhere...\n                 ast::Effect::Async(_) | ast::Effect::Label(_) => {\n-                    self.collect_block_opt(e.block_expr())\n+                    (self.collect_block_opt(e.block_expr()), vec![])\n                 }\n             },\n-            ast::Expr::BlockExpr(e) => self.collect_block(e),\n+            ast::Expr::BlockExpr(e) => (self.collect_block(e), vec![]),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(\n+                (self.alloc_expr(\n                     Expr::Loop {\n                         body,\n                         label: e\n@@ -239,7 +274,7 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                )\n+                ), vec![body])\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -250,6 +285,7 @@ impl ExprCollector<'_> {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n+                            // FIXME(pfaria) track the break and arms parents here?\n                             mark::hit!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n@@ -262,7 +298,7 @@ impl ExprCollector<'_> {\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(\n+                            return (self.alloc_expr(\n                                 Expr::Loop {\n                                     body: match_expr,\n                                     label: e\n@@ -271,12 +307,12 @@ impl ExprCollector<'_> {\n                                         .map(|l| Name::new_lifetime(&l)),\n                                 },\n                                 syntax_ptr,\n-                            );\n+                            ), vec![match_expr]);\n                         }\n                     },\n                 };\n \n-                self.alloc_expr(\n+                (self.alloc_expr(\n                     Expr::While {\n                         condition,\n                         body,\n@@ -286,13 +322,13 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                )\n+                ), vec![body, condition])\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(\n+                (self.alloc_expr(\n                     Expr::For {\n                         iterable,\n                         pat,\n@@ -303,7 +339,7 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                )\n+                ), vec![iterable, body])\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -312,77 +348,92 @@ impl ExprCollector<'_> {\n                 } else {\n                     Vec::new()\n                 };\n-                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+                let mut children_exprs = args.clone();\n+                children_exprs.push(callee);\n+                (self.alloc_expr(Expr::Call { callee, args }, syntax_ptr), children_exprs)\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n                 } else {\n-                    Vec::new()\n+                    vec![]\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n                     e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n-                self.alloc_expr(\n-                    Expr::MethodCall { receiver, method_name, args, generic_args },\n-                    syntax_ptr,\n+                let mut children_exprs = args.clone();\n+                children_exprs.push(receiver);\n+                (\n+                    self.alloc_expr(\n+                        Expr::MethodCall { receiver, method_name, args, generic_args },\n+                        syntax_ptr,\n+                    ),\n+                    children_exprs,\n                 )\n             }\n             ast::Expr::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n-                    match_arm_list\n-                        .arms()\n-                        .map(|arm| MatchArm {\n-                            pat: self.collect_pat_opt(arm.pat()),\n-                            expr: self.collect_expr_opt(arm.expr()),\n-                            guard: arm\n-                                .guard()\n-                                .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e)),\n-                        })\n-                        .collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+                let (arms, mut children_exprs): (Vec<_>, Vec<_>) =\n+                    if let Some(match_arm_list) = e.match_arm_list() {\n+                        match_arm_list\n+                            .arms()\n+                            .map(|arm| {\n+                                let expr = self.collect_expr_opt(arm.expr());\n+                                (\n+                                    MatchArm {\n+                                        pat: self.collect_pat_opt(arm.pat()),\n+                                        expr,\n+                                        guard: arm\n+                                            .guard()\n+                                            .and_then(|guard| guard.expr())\n+                                            .map(|e| self.collect_expr(e)),\n+                                    },\n+                                    expr,\n+                                )\n+                            })\n+                            .unzip()\n+                    } else {\n+                        (vec![], vec![])\n+                    };\n+                children_exprs.push(expr);\n+                (self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr), children_exprs)\n             }\n             ast::Expr::PathExpr(e) => {\n                 let path = e\n                     .path()\n                     .and_then(|path| self.expander.parse_path(path))\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n-                self.alloc_expr(path, syntax_ptr)\n+                (self.alloc_expr(path, syntax_ptr), vec![])\n             }\n-            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n+            ast::Expr::ContinueExpr(e) => (self.alloc_expr(\n                 Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                 syntax_ptr,\n-            ),\n+            ), vec![]),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(\n+                (self.alloc_expr(\n                     Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                     syntax_ptr,\n-                )\n+                ), expr.into_iter().collect())\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 let src = self.expander.to_source(syntax_ptr);\n                 self.source_map.expr_map.insert(src, inner);\n-                inner\n+                (inner, vec![])\n             }\n             ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+                (self.alloc_expr(Expr::Return { expr }, syntax_ptr), expr.into_iter().collect())\n             }\n             ast::Expr::RecordLit(e) => {\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n-                let record_lit = if let Some(nfl) = e.record_field_list() {\n-                    let fields = nfl\n+                let (record_lit, children) = if let Some(nfl) = e.record_field_list() {\n+                    let (fields, children): (Vec<_>, Vec<_>) = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .filter_map(|field| {\n@@ -391,48 +442,49 @@ impl ExprCollector<'_> {\n                             }\n                             let name = field.field_name()?.as_name();\n \n-                            Some(RecordLitField {\n-                                name,\n-                                expr: match field.expr() {\n-                                    Some(e) => self.collect_expr(e),\n-                                    None => self.missing_expr(),\n-                                },\n-                            })\n+                            let expr = match field.expr() {\n+                                Some(e) => self.collect_expr(e),\n+                                None => self.missing_expr(),\n+                            };\n+                            Some((RecordLitField { name, expr }, expr))\n                         })\n-                        .collect();\n+                        .unzip();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    Expr::RecordLit { path, fields, spread }\n+                    (\n+                        Expr::RecordLit { path, fields, spread: spread },\n+                        children.into_iter().chain(spread.into_iter()).collect(),\n+                    )\n                 } else {\n-                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n+                    (Expr::RecordLit { path, fields: Vec::new(), spread: None }, vec![])\n                 };\n \n                 let res = self.alloc_expr(record_lit, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     let src = self.expander.to_source(ptr);\n                     self.source_map.field_map.insert((res, i), src);\n                 }\n-                res\n+                (res, children)\n             }\n             ast::Expr::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n-                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+                (self.alloc_expr(Expr::Field { expr, name }, syntax_ptr), vec![expr])\n             }\n             ast::Expr::AwaitExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n+                (self.alloc_expr(Expr::Await { expr }, syntax_ptr), vec![expr])\n             }\n             ast::Expr::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+                (self.alloc_expr(Expr::Try { expr }, syntax_ptr), vec![expr])\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n-                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+                (self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr), vec![expr])\n             }\n             ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -455,9 +507,9 @@ impl ExprCollector<'_> {\n             ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n-                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n+                    (self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr), vec![expr])\n                 } else {\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                    (self.alloc_expr(Expr::Missing, syntax_ptr), vec![])\n                 }\n             }\n             ast::Expr::LambdaExpr(e) => {\n@@ -477,56 +529,71 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.type_ref())\n                     .map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n+                (\n+                    self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr),\n+                    vec![body],\n+                )\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind().map(BinaryOp::from);\n-                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+                (self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr), vec![lhs, rhs])\n             }\n             ast::Expr::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n+                (self.alloc_expr(Expr::Tuple { exprs: exprs.clone() }, syntax_ptr), exprs)\n             }\n             ast::Expr::BoxExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n+                (self.alloc_expr(Expr::Box { expr }, syntax_ptr), vec![expr])\n             }\n \n             ast::Expr::ArrayExpr(e) => {\n                 let kind = e.kind();\n \n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n-                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n+                        (\n+                            self.alloc_expr(\n+                                Expr::Array(Array::ElementList(exprs.clone())),\n+                                syntax_ptr,\n+                            ),\n+                            exprs,\n+                        )\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n                         let repeat = self.collect_expr_opt(repeat);\n-                        self.alloc_expr(\n-                            Expr::Array(Array::Repeat { initializer, repeat }),\n-                            syntax_ptr,\n+                        (\n+                            self.alloc_expr(\n+                                Expr::Array(Array::Repeat { initializer, repeat }),\n+                                syntax_ptr,\n+                            ),\n+                            vec![initializer, repeat],\n                         )\n                     }\n                 }\n             }\n \n-            ast::Expr::Literal(e) => self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr),\n+            ast::Expr::Literal(e) => {\n+                (self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr), vec![])\n+            }\n             ast::Expr::IndexExpr(e) => {\n                 let base = self.collect_expr_opt(e.base());\n                 let index = self.collect_expr_opt(e.index());\n-                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n+                (self.alloc_expr(Expr::Index { base, index }, syntax_ptr), vec![base, index])\n             }\n             ast::Expr::RangeExpr(e) => {\n                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n                 match e.op_kind() {\n-                    Some(range_type) => {\n-                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n-                    }\n-                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                    Some(range_type) => (\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr),\n+                        lhs.into_iter().chain(rhs.into_iter()).collect(),\n+                    ),\n+                    None => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n                 }\n             }\n             ast::Expr::MacroCall(e) => {\n@@ -540,7 +607,7 @@ impl ExprCollector<'_> {\n                     self.body.item_scope.define_legacy_macro(name, mac);\n \n                     // FIXME: do we still need to allocate this as missing ?\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                    (self.alloc_expr(Expr::Missing, syntax_ptr), vec![])\n                 } else {\n                     let macro_call = self.expander.to_source(AstPtr::new(&e));\n                     match self.expander.enter_expand(self.db, Some(&self.body.item_scope), e) {\n@@ -553,15 +620,15 @@ impl ExprCollector<'_> {\n                             self.item_trees.insert(self.expander.current_file_id, item_tree);\n                             let id = self.collect_expr(expansion);\n                             self.expander.exit(self.db, mark);\n-                            id\n+                            (id, vec![])\n                         }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                        None => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n                     }\n                 }\n             }\n \n             // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::Label(_e) => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n         }\n     }\n \n@@ -600,24 +667,33 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        let parent_and_children = self.collect_block_inner(block);\n+        self.update_parent_map(parent_and_children)\n+    }\n+\n+    fn collect_block_inner(&mut self, block: ast::BlockExpr) -> (ExprId, Vec<ExprId>) {\n         let syntax_node_ptr = AstPtr::new(&block.clone().into());\n         self.collect_block_items(&block);\n-        let statements = block\n+        let (statements, children_exprs): (Vec<_>, Vec<_>) = block\n             .statements()\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref =\n                         stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n+                    (Statement::Let { pat, type_ref, initializer }, initializer)\n+                }\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    let expr = self.collect_expr_opt(stmt.expr());\n+                    (Statement::Expr(expr), Some(expr))\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n-            .collect();\n+            .unzip();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n         let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n-        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n+        let children_exprs = children_exprs.into_iter().flatten().chain(tail.into_iter()).collect();\n+        (self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr), children_exprs)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "3942aada56189ebc173066fd220f9690e645c788", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "patch": "@@ -333,15 +333,12 @@ pub fn unsafe_expressions(\n     def: DefWithBodyId,\n ) -> Vec<UnsafeExpr> {\n     let mut unsafe_exprs = vec![];\n-    let mut unsafe_block_scopes = vec![];\n+    let mut unsafe_block_exprs = FxHashSet::default();\n     let body = db.body(def);\n-    let expr_scopes = db.expr_scopes(def);\n     for (id, expr) in body.exprs.iter() {\n         match expr {\n-            Expr::Unsafe { body } => {\n-                if let Some(scope) = expr_scopes.scope_for(*body) {\n-                    unsafe_block_scopes.push(scope);\n-                }\n+            Expr::Unsafe { .. } => {\n+                unsafe_block_exprs.insert(id);\n             }\n             Expr::Call { callee, .. } => {\n                 let ty = &infer[*callee];\n@@ -374,12 +371,13 @@ pub fn unsafe_expressions(\n     }\n \n     'unsafe_exprs: for unsafe_expr in &mut unsafe_exprs {\n-        let scope = expr_scopes.scope_for(unsafe_expr.expr);\n-        for scope in expr_scopes.scope_chain(scope) {\n-            if unsafe_block_scopes.contains(&scope) {\n+        let mut child = unsafe_expr.expr;\n+        while let Some(parent) = body.parent_map.get(&child) {\n+            if unsafe_block_exprs.contains(parent) {\n                 unsafe_expr.inside_unsafe_block = true;\n                 continue 'unsafe_exprs;\n             }\n+            child = *parent;\n         }\n     }\n \n@@ -417,8 +415,10 @@ impl<'a, 'b> UnsafeValidator<'a, 'b> {\n \n         let (_, body_source) = db.body_with_source_map(def);\n         for unsafe_expr in unsafe_expressions {\n-            if let Ok(in_file) = body_source.as_ref().expr_syntax(unsafe_expr.expr) {\n-                self.sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n+            if !unsafe_expr.inside_unsafe_block {\n+                if let Ok(in_file) = body_source.as_ref().expr_syntax(unsafe_expr.expr) {\n+                    self.sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n+                }\n             }\n         }\n     }"}, {"sha": "496cb428be0e50f5a982bfcca9549696755ac9f4", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2219dc76d6cddc46eadb2b2dd674795e0efce8/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=7f2219dc76d6cddc46eadb2b2dd674795e0efce8", "patch": "@@ -638,7 +638,7 @@ fn nothing_to_see_move_along() {\n     .diagnostics()\n     .0;\n \n-    assert_snapshot!(diagnostics, @\"\");\n+    assert_snapshot!(diagnostics, @r#\"\"*x\": This operation is unsafe and requires an unsafe function or block\"#);\n }\n \n #[test]"}]}