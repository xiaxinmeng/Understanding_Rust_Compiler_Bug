{"sha": "c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOTU1YTM0YmNiMTdmMGIzMWQ3Yjg2NTIyYTUyMGViZTdmYTkzYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-13T10:18:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-13T10:18:38Z"}, "message": "Auto merge of #51622 - kennytm:three-field-range-inclusive, r=SimonSapin\n\nChange RangeInclusive to a three-field struct.\n\nFix #45222.\n\nThis PR also reverts #48012 (i.e. removed the `try_fold`/`try_rfold` specialization for `RangeInclusive`) because LLVM no longer has trouble recognizing a RangeInclusive loop.", "tree": {"sha": "19eef2b6ba3ad8e7bae6370de1f0ab33e6c7df3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19eef2b6ba3ad8e7bae6370de1f0ab33e6c7df3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "html_url": "https://github.com/rust-lang/rust/commit/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b48b247dc24a40ce499415370bfd2b6cefa3a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b48b247dc24a40ce499415370bfd2b6cefa3a1b", "html_url": "https://github.com/rust-lang/rust/commit/8b48b247dc24a40ce499415370bfd2b6cefa3a1b"}, {"sha": "6093128ef3c5ae661ec66fbf3685833d6be217bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6093128ef3c5ae661ec66fbf3685833d6be217bb", "html_url": "https://github.com/rust-lang/rust/commit/6093128ef3c5ae661ec66fbf3685833d6be217bb"}], "stats": {"total": 320, "additions": 208, "deletions": 112}, "files": [{"sha": "35ae77411069cdf5c9a63fda2fedc313dad341b3", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -787,17 +787,19 @@ where\n     #[inline]\n     fn spec_next(&mut self) -> Option<Self::Item> {\n         self.first_take = false;\n-        if !(self.iter.start <= self.iter.end) {\n+        self.iter.compute_is_empty();\n+        if self.iter.is_empty.unwrap_or_default() {\n             return None;\n         }\n         // add 1 to self.step to get original step size back\n         // it was decremented for the general case on construction\n         if let Some(n) = self.iter.start.add_usize(self.step+1) {\n+            self.iter.is_empty = Some(!(n <= self.iter.end));\n             let next = mem::replace(&mut self.iter.start, n);\n             Some(next)\n         } else {\n-            let last = self.iter.start.replace_one();\n-            self.iter.end.replace_zero();\n+            let last = self.iter.start.clone();\n+            self.iter.is_empty = Some(true);\n             Some(last)\n         }\n     }"}, {"sha": "651c7a35d413c6478b6e661b23dbd586208be6a6", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 32, "deletions": 72, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -10,7 +10,7 @@\n \n use convert::TryFrom;\n use mem;\n-use ops::{self, Add, Sub, Try};\n+use ops::{self, Add, Sub};\n use usize;\n \n use super::{FusedIterator, TrustedLen};\n@@ -330,23 +330,23 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        if self.start <= self.end {\n-            if self.start < self.end {\n-                let n = self.start.add_one();\n-                Some(mem::replace(&mut self.start, n))\n-            } else {\n-                let last = self.start.replace_one();\n-                self.end.replace_zero();\n-                Some(last)\n-            }\n-        } else {\n-            None\n+        self.compute_is_empty();\n+        if self.is_empty.unwrap_or_default() {\n+            return None;\n         }\n+        let is_iterating = self.start < self.end;\n+        self.is_empty = Some(!is_iterating);\n+        Some(if is_iterating {\n+            let n = self.start.add_one();\n+            mem::replace(&mut self.start, n)\n+        } else {\n+            self.start.clone()\n+        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if !(self.start <= self.end) {\n+        if self.is_empty() {\n             return (0, Some(0));\n         }\n \n@@ -358,25 +358,29 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n+        self.compute_is_empty();\n+        if self.is_empty.unwrap_or_default() {\n+            return None;\n+        }\n+\n         if let Some(plus_n) = self.start.add_usize(n) {\n             use cmp::Ordering::*;\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n+                    self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n)\n                 }\n                 Some(Equal) => {\n-                    self.start.replace_one();\n-                    self.end.replace_zero();\n+                    self.is_empty = Some(true);\n                     return Some(plus_n)\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.start.replace_one();\n-        self.end.replace_zero();\n+        self.is_empty = Some(true);\n         None\n     }\n \n@@ -394,68 +398,24 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     fn max(mut self) -> Option<A> {\n         self.next_back()\n     }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        if self.start <= self.end {\n-            loop {\n-                let (x, done) =\n-                    if self.start < self.end {\n-                        let n = self.start.add_one();\n-                        (mem::replace(&mut self.start, n), false)\n-                    } else {\n-                        self.end.replace_zero();\n-                        (self.start.replace_one(), true)\n-                    };\n-                accum = f(accum, x)?;\n-                if done { break }\n-            }\n-        }\n-        Try::from_ok(accum)\n-    }\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.start <= self.end {\n-            if self.start < self.end {\n-                let n = self.end.sub_one();\n-                Some(mem::replace(&mut self.end, n))\n-            } else {\n-                let last = self.end.replace_zero();\n-                self.start.replace_one();\n-                Some(last)\n-            }\n-        } else {\n-            None\n+        self.compute_is_empty();\n+        if self.is_empty.unwrap_or_default() {\n+            return None;\n         }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        if self.start <= self.end {\n-            loop {\n-                let (x, done) =\n-                    if self.start < self.end {\n-                        let n = self.end.sub_one();\n-                        (mem::replace(&mut self.end, n), false)\n-                    } else {\n-                        self.start.replace_one();\n-                        (self.end.replace_zero(), true)\n-                    };\n-                accum = f(accum, x)?;\n-                if done { break }\n-            }\n-        }\n-        Try::from_ok(accum)\n+        let is_iterating = self.start < self.end;\n+        self.is_empty = Some(!is_iterating);\n+        Some(if is_iterating {\n+            let n = self.end.sub_one();\n+            mem::replace(&mut self.end, n)\n+        } else {\n+            self.end.clone()\n+        })\n     }\n }\n "}, {"sha": "9c635678d7aa0b2da528bdaad32761238d60e431", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use fmt;\n+use hash::{Hash, Hasher};\n \n /// An unbounded range (`..`).\n ///\n@@ -326,15 +327,56 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone)]  // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n-    // FIXME: The current representation follows RFC 1980,\n-    // but it is known that LLVM is not able to optimize loops following that RFC.\n-    // Consider adding an extra `bool` field to indicate emptiness of the range.\n-    // See #45222 for performance test cases.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n+    pub(crate) is_empty: Option<bool>,\n+    // This field is:\n+    //  - `None` when next() or next_back() was never called\n+    //  - `Some(false)` when `start <= end` assuming no overflow\n+    //  - `Some(true)` otherwise\n+    // The field cannot be a simple `bool` because the `..=` constructor can\n+    // accept non-PartialOrd types, also we want the constructor to be const.\n+}\n+\n+trait RangeInclusiveEquality: Sized {\n+    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n+}\n+impl<T> RangeInclusiveEquality for T {\n+    #[inline]\n+    default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n+        range.is_empty.unwrap_or_default()\n+    }\n+}\n+impl<T: PartialOrd> RangeInclusiveEquality for T {\n+    #[inline]\n+    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n+        range.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.start == other.start && self.end == other.end\n+            && RangeInclusiveEquality::canonicalized_is_empty(self)\n+                == RangeInclusiveEquality::canonicalized_is_empty(other)\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.start.hash(state);\n+        self.end.hash(state);\n+        RangeInclusiveEquality::canonicalized_is_empty(self).hash(state);\n+    }\n }\n \n impl<Idx> RangeInclusive<Idx> {\n@@ -350,7 +392,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end }\n+        Self { start, end, is_empty: None }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -492,8 +534,17 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(r.is_empty());\n     /// ```\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    #[inline]\n     pub fn is_empty(&self) -> bool {\n-        !(self.start <= self.end)\n+        self.is_empty.unwrap_or_else(|| !(self.start <= self.end))\n+    }\n+\n+    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n+    #[inline]\n+    pub(crate) fn compute_is_empty(&mut self) {\n+        if self.is_empty.is_none() {\n+            self.is_empty = Some(!(self.start <= self.end));\n+        }\n     }\n }\n "}, {"sha": "b766140ffe99a1e37f292e729df55ecb4850ad57", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -2265,36 +2265,36 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if self.end == usize::max_value() { None }\n-        else { (self.start..self.end + 1).get(slice) }\n+        if *self.end() == usize::max_value() { None }\n+        else { (*self.start()..self.end() + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if self.end == usize::max_value() { None }\n-        else { (self.start..self.end + 1).get_mut(slice) }\n+        if *self.end() == usize::max_value() { None }\n+        else { (*self.start()..self.end() + 1).get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (self.start..self.end + 1).get_unchecked(slice)\n+        (*self.start()..self.end() + 1).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (self.start..self.end + 1).get_unchecked_mut(slice)\n+        (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n-        (self.start..self.end + 1).index(slice)\n+        if *self.end() == usize::max_value() { slice_index_overflow_fail(); }\n+        (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n-        (self.start..self.end + 1).index_mut(slice)\n+        if *self.end() == usize::max_value() { slice_index_overflow_fail(); }\n+        (*self.start()..self.end() + 1).index_mut(slice)\n     }\n }\n "}, {"sha": "255e8a07d75492dc96aee5535f7b6f48e56ac2a7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -2004,31 +2004,31 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::max_value() { None }\n-            else { (self.start..self.end+1).get(slice) }\n+            if *self.end() == usize::max_value() { None }\n+            else { (*self.start()..self.end()+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::max_value() { None }\n-            else { (self.start..self.end+1).get_mut(slice) }\n+            if *self.end() == usize::max_value() { None }\n+            else { (*self.start()..self.end()+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (self.start..self.end+1).get_unchecked(slice)\n+            (*self.start()..self.end()+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (self.start..self.end+1).get_unchecked_mut(slice)\n+            (*self.start()..self.end()+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::max_value() { str_index_overflow_fail(); }\n-            (self.start..self.end+1).index(slice)\n+            if *self.end() == usize::max_value() { str_index_overflow_fail(); }\n+            (*self.start()..self.end()+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::max_value() { str_index_overflow_fail(); }\n-            (self.start..self.end+1).index_mut(slice)\n+            if *self.end() == usize::max_value() { str_index_overflow_fail(); }\n+            (*self.start()..self.end()+1).index_mut(slice)\n         }\n     }\n "}, {"sha": "30a03243f0151efe68e91fb33a70ca69968285d6", "filename": "src/test/codegen/issue-45222.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45222.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+// min-llvm-version 6.0\n+\n+#![crate_type = \"lib\"]\n+\n+// verify that LLVM recognizes a loop involving 0..=n and will const-fold it.\n+\n+//------------------------------------------------------------------------------\n+// Example from original issue #45222\n+\n+fn foo2(n: u64) -> u64 {\n+    let mut count = 0;\n+    for _ in 0..n {\n+        for j in (0..=n).rev() {\n+            count += j;\n+        }\n+    }\n+    count\n+}\n+\n+// CHECK-LABEL: @check_foo2\n+#[no_mangle]\n+pub fn check_foo2() -> u64 {\n+    // CHECK: ret i64 500005000000000\n+    foo2(100000)\n+}\n+\n+//------------------------------------------------------------------------------\n+// Simplified example of #45222\n+\n+fn triangle_inc(n: u64) -> u64 {\n+    let mut count = 0;\n+    for j in 0 ..= n {\n+        count += j;\n+    }\n+    count\n+}\n+\n+// CHECK-LABEL: @check_triangle_inc\n+#[no_mangle]\n+pub fn check_triangle_inc() -> u64 {\n+    // CHECK: ret i64 5000050000\n+    triangle_inc(100000)\n+}\n+\n+//------------------------------------------------------------------------------\n+// Demo in #48012\n+\n+fn foo3r(n: u64) -> u64 {\n+    let mut count = 0;\n+    (0..n).for_each(|_| {\n+        (0 ..= n).rev().for_each(|j| {\n+            count += j;\n+        })\n+    });\n+    count\n+}\n+\n+// CHECK-LABEL: @check_foo3r\n+#[no_mangle]\n+pub fn check_foo3r() -> u64 {\n+    // CHECK: ret i64 500005000000000\n+    foo3r(100000)\n+}"}, {"sha": "2bedfc133b5819485986a71f14eb517b8a1087d5", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -10,12 +10,18 @@\n \n // Test inclusive range syntax.\n \n-use std::ops::{RangeInclusive, RangeToInclusive};\n+#![feature(range_is_empty)]\n+#![allow(unused_comparisons)]\n+\n+use std::ops::RangeToInclusive;\n \n fn foo() -> isize { 42 }\n \n // Test that range syntax works in return statements\n-fn return_range_to() -> RangeToInclusive<i32> { return ..=1; }\n+pub fn return_range_to() -> RangeToInclusive<i32> { return ..=1; }\n+\n+#[derive(Debug)]\n+struct P(u8);\n \n pub fn main() {\n     let mut count = 0;\n@@ -26,7 +32,7 @@ pub fn main() {\n     assert_eq!(count, 55);\n \n     let mut count = 0;\n-    let mut range = 0_usize..=10;\n+    let range = 0_usize..=10;\n     for i in range {\n         assert!(i >= 0 && i <= 10);\n         count += i;\n@@ -80,7 +86,7 @@ pub fn main() {\n     short.next();\n     assert_eq!(long.size_hint(), (255, Some(255)));\n     assert_eq!(short.size_hint(), (0, Some(0)));\n-    assert_eq!(short, 1..=0);\n+    assert!(short.is_empty());\n \n     assert_eq!(long.len(), 255);\n     assert_eq!(short.len(), 0);\n@@ -95,28 +101,31 @@ pub fn main() {\n     for i in 3..=251 {\n         assert_eq!(long.next(), Some(i));\n     }\n-    assert_eq!(long, 1..=0);\n+    assert!(long.is_empty());\n \n     // check underflow\n     let mut narrow = 1..=0;\n     assert_eq!(narrow.next_back(), None);\n-    assert_eq!(narrow, 1..=0);\n+    assert!(narrow.is_empty());\n     let mut zero = 0u8..=0;\n     assert_eq!(zero.next_back(), Some(0));\n     assert_eq!(zero.next_back(), None);\n-    assert_eq!(zero, 1..=0);\n+    assert!(zero.is_empty());\n     let mut high = 255u8..=255;\n     assert_eq!(high.next_back(), Some(255));\n     assert_eq!(high.next_back(), None);\n-    assert_eq!(high, 1..=0);\n+    assert!(high.is_empty());\n \n     // what happens if you have a nonsense range?\n     let mut nonsense = 10..=5;\n     assert_eq!(nonsense.next(), None);\n-    assert_eq!(nonsense, 10..=5);\n+    assert!(nonsense.is_empty());\n \n     // output\n     assert_eq!(format!(\"{:?}\", 0..=10), \"0..=10\");\n     assert_eq!(format!(\"{:?}\", ..=10), \"..=10\");\n-    assert_eq!(format!(\"{:?}\", long), \"1..=0\");\n+    assert_eq!(format!(\"{:?}\", 9..=6), \"9..=6\");\n+\n+    // ensure that constructing a RangeInclusive does not need PartialOrd bound\n+    assert_eq!(format!(\"{:?}\", P(1)..=P(2)), \"P(1)..=P(2)\");\n }"}]}