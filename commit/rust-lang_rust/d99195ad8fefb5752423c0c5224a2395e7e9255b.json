{"sha": "d99195ad8fefb5752423c0c5224a2395e7e9255b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OTE5NWFkOGZlZmI1NzUyNDIzYzBjNTIyNGEyMzk1ZTdlOTI1NWI=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-24T20:30:34Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-03T10:41:55Z"}, "message": "Rename `Binder::no_late_bound_regions` to `Binder::no_bound_vars`", "tree": {"sha": "530ddbf5dbfe1b962fa77e849a2099e1b56f57df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/530ddbf5dbfe1b962fa77e849a2099e1b56f57df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99195ad8fefb5752423c0c5224a2395e7e9255b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99195ad8fefb5752423c0c5224a2395e7e9255b", "html_url": "https://github.com/rust-lang/rust/commit/d99195ad8fefb5752423c0c5224a2395e7e9255b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99195ad8fefb5752423c0c5224a2395e7e9255b/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45be1ac0fcb7ac2d4d8e52c6543e8384e7c1a6ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/45be1ac0fcb7ac2d4d8e52c6543e8384e7c1a6ea", "html_url": "https://github.com/rust-lang/rust/commit/45be1ac0fcb7ac2d4d8e52c6543e8384e7c1a6ea"}], "stats": {"total": 66, "additions": 34, "deletions": 32}, "files": [{"sha": "88d45671b9afdfab86538d6a1b6d6345cfeed3ba", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -323,7 +323,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         predicates\n             .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| p.no_late_bound_regions())\n+            .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }\n }"}, {"sha": "e87e425762d56eaf96399c1468eb1250f04f9eb4", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -683,8 +683,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &ty::Predicate::TypeOutlives(ref binder) => {\n                     match (\n-                        binder.no_late_bound_regions(),\n-                        binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n+                        binder.no_bound_vars(),\n+                        binder.map_bound_ref(|pred| pred.0).no_bound_vars(),\n                     ) {\n                         (None, Some(t_a)) => {\n                             select.infcx().register_region_obligation_with_cause("}, {"sha": "aea956461f27bea7252ff69d43a72af19d10d377", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -349,15 +349,15 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }\n \n             ty::Predicate::TypeOutlives(ref binder) => {\n-                // Check if there are higher-ranked regions.\n-                match binder.no_late_bound_regions() {\n+                // Check if there are higher-ranked vars.\n+                match binder.no_bound_vars() {\n                     // If there are, inspect the underlying type further.\n                     None => {\n                         // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n                         let binder = binder.map_bound_ref(|pred| pred.0);\n \n-                        // Check if the type has any bound regions.\n-                        match binder.no_late_bound_regions() {\n+                        // Check if the type has any bound vars.\n+                        match binder.no_bound_vars() {\n                             // If so, this obligation is an error (for now). Eventually we should be\n                             // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                             // NOTE: this is duplicate-implemented between here and fulfillment."}, {"sha": "5e2f1fe08b90e04acf57fad8aedc764f259a246a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> GoalKind<'tcx> {\n         domain_goal: PolyDomainGoal<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n-        match domain_goal.no_late_bound_regions() {\n+        match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n             None => GoalKind::Quantified(\n                 QuantifierKind::Universal,"}, {"sha": "80358294d056c535cadcdf9999b0f9eefeef69ab", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -1619,7 +1619,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n-        predicate.no_late_bound_regions()\n+        predicate.no_bound_vars()\n             .map(|predicate| ProjectionCacheKey {\n                 // We don't attempt to match up with a specific type-variable state\n                 // from a specific call to `opt_normalize_projection_type` - if"}, {"sha": "b3fae3bab347199ad0d95dd3d9d326725d53f056", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -164,7 +164,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ty::Predicate::ClosureKind(..) |\n             ty::Predicate::TypeOutlives(..) |\n             ty::Predicate::ConstEvaluatable(..) => None,\n-            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+            ty::Predicate::RegionOutlives(ref data) => data.no_bound_vars().map(\n                 |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n             ),\n         })"}, {"sha": "45dad508af560d9e78c8dafc32604d2031a30309", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -2168,7 +2168,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let source = match obligation.self_ty().no_late_bound_regions() {\n+        let source = match obligation.self_ty().no_bound_vars() {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -3235,7 +3235,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx\n-            .shallow_resolve(obligation.self_ty().no_late_bound_regions().unwrap());\n+            .shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n         let target = obligation\n             .predicate\n             .skip_binder()"}, {"sha": "fbc77fdfea30d709850bf2ce374eb3093898d2a9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -799,10 +799,10 @@ impl<T> Binder<T> {\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n-    /// discharge the binder using `no_late_bound_regions` or\n+    /// discharge the binder using `no_bound_vars` or\n     /// `replace_late_bound_regions` or something like\n     /// that. `skip_binder` is only valid when you are either\n-    /// extracting data that has nothing to do with bound regions, you\n+    /// extracting data that has nothing to do with bound vars, you\n     /// are doing some sort of test that does not involve bound\n     /// regions, or you are being very careful about your depth\n     /// accounting.\n@@ -811,7 +811,7 @@ impl<T> Binder<T> {\n     ///\n     /// - extracting the def-id from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n-    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    ///   a type parameter `X`, since the type `X` does not reference any regions\n     pub fn skip_binder(&self) -> &T {\n         &self.0\n     }\n@@ -833,17 +833,17 @@ impl<T> Binder<T> {\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n-    /// no bound regions at all. (In other words, if this binder --\n+    /// no bound vars at all. (In other words, if this binder --\n     /// and indeed any enclosing binder -- doesn't bind anything at\n     /// all.) Otherwise, returns `None`.\n     ///\n     /// (One could imagine having a method that just unwraps a single\n-    /// binder, but permits late-bound regions bound by enclosing\n+    /// binder, but permits late-bound vars bound by enclosing\n     /// binders, but that would require adjusting the debruijn\n     /// indices, and given the shallow binding structure we often use,\n     /// would not be that useful.)\n-    pub fn no_late_bound_regions<'tcx>(self) -> Option<T>\n-        where T : TypeFoldable<'tcx>\n+    pub fn no_bound_vars<'tcx>(self) -> Option<T>\n+        where T: TypeFoldable<'tcx>\n     {\n         if self.skip_binder().has_escaping_bound_vars() {\n             None"}, {"sha": "c1f096bc1911f4dc065a5feeed6d6a75921901ac", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -557,7 +557,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = cx.tcx.erase_regions(\n-            &main_ret_ty.no_late_bound_regions().unwrap(),\n+            &main_ret_ty.no_bound_vars().unwrap(),\n         );\n \n         if declare::get_defined_value(cx, \"main\").is_some() {"}, {"sha": "35ec478143546d90177a81c7f41efb2eebdcf5f8", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -82,9 +82,9 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n         let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n+            query_constraint.no_bound_vars().unwrap_or_else(|| {\n                 bug!(\n-                    \"query_constraint {:?} contained bound regions\",\n+                    \"query_constraint {:?} contained bound vars\",\n                     query_constraint,\n                 );\n             });"}, {"sha": "734ddbc3ab9a72af39babca2f7080aac3e3577c9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -2214,8 +2214,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     .enumerate()\n                     .filter_map(|(idx, constraint)| {\n                         let ty::OutlivesPredicate(k1, r2) =\n-                            constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                                bug!(\"query_constraint {:?} contained bound regions\", constraint,);\n+                            constraint.no_bound_vars().unwrap_or_else(|| {\n+                                bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                             });\n \n                         match k1.unpack() {"}, {"sha": "8e27635dee8c13868c3d5e9a04cd1bf3289a83f0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -1082,7 +1082,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = self.tcx.erase_regions(\n-            &main_ret_ty.no_late_bound_regions().unwrap(),\n+            &main_ret_ty.no_bound_vars().unwrap(),\n         );\n \n         let start_instance = Instance::resolve("}, {"sha": "76a8501fb177a89c4375e3c99fa175a8da097aaf", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -844,7 +844,9 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let param_env = gcx.param_env(def_id);\n \n     // Normalize the sig.\n-    let sig = gcx.fn_sig(def_id).no_late_bound_regions().expect(\"LBR in ADT constructor signature\");\n+    let sig = gcx.fn_sig(def_id)\n+        .no_bound_vars()\n+        .expect(\"LBR in ADT constructor signature\");\n     let sig = gcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {"}, {"sha": "80072153167f3c2eb6115cbfaef6905cc4b66220", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -143,7 +143,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n-    let sig = poly_sig.no_late_bound_regions().unwrap();\n+    let sig = poly_sig.no_bound_vars().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n     let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "7cc064f9c3d3d81906ad96caaa92a9e4c5e79a23", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -122,14 +122,14 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     vec![]\n                 }\n \n-                ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                ty::Predicate::RegionOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n                 },\n \n-                ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);"}, {"sha": "40f2072079a5a1ba203536b642b3f3d14ea8c53c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -816,7 +816,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n         // Replace constructor type with constructed type for tuple struct patterns.\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_late_bound_regions().expect(\"expected fn type\");\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "3156458b4aa4abe0690057c9cbfccfadb98e72a0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -419,7 +419,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let mut structural_to_nomimal = FxHashMap::default();\n \n                     let sig = tcx.fn_sig(def_id);\n-                    let sig = sig.no_late_bound_regions().unwrap();\n+                    let sig = sig.no_bound_vars().unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "bf3887ee8fcdd398532dfb6e269369747fd25afb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99195ad8fefb5752423c0c5224a2395e7e9255b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d99195ad8fefb5752423c0c5224a2395e7e9255b", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         item_def_id: DefId,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        if let Some(trait_ref) = poly_trait_ref.no_late_bound_regions() {\n+        if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder"}]}