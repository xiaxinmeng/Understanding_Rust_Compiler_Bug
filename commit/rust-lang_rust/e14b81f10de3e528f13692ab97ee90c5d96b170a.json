{"sha": "e14b81f10de3e528f13692ab97ee90c5d96b170a", "node_id": "C_kwDOAAsO6NoAKGUxNGI4MWYxMGRlM2U1MjhmMTM2OTJhYjk3ZWU5MGM1ZDk2YjE3MGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T11:41:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T11:41:57Z"}, "message": "Auto merge of #109989 - ids1024:m68k-asm, r=Amanieu\n\nAdd inline assembly support for m68k\n\nI believe this should be correct, to the extent I understand the logic around inline assembly. M68k is fairly straightforward here, other than having separate address registers.", "tree": {"sha": "a3b0332e07a773140b4c38c0f7b65c2ac812e419", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3b0332e07a773140b4c38c0f7b65c2ac812e419"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e14b81f10de3e528f13692ab97ee90c5d96b170a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e14b81f10de3e528f13692ab97ee90c5d96b170a", "html_url": "https://github.com/rust-lang/rust/commit/e14b81f10de3e528f13692ab97ee90c5d96b170a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e14b81f10de3e528f13692ab97ee90c5d96b170a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fab99073b01539ce2664366011c7f3e378e52b7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fab99073b01539ce2664366011c7f3e378e52b7e", "html_url": "https://github.com/rust-lang/rust/commit/fab99073b01539ce2664366011c7f3e378e52b7e"}, {"sha": "2ac8dee44fe81c75d998597d236b23470f41142e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac8dee44fe81c75d998597d236b23470f41142e", "html_url": "https://github.com/rust-lang/rust/commit/2ac8dee44fe81c75d998597d236b23470f41142e"}], "stats": {"total": 221, "additions": 220, "deletions": 1}, "files": [{"sha": "65de02b35671251bd4f6b552b54924266e8451fa", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -593,6 +593,9 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => \"a\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => \"d\",\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"d\", // more specific than \"r\"\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n@@ -664,6 +667,9 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Avr(_) => unimplemented!(),\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::Msp430(_) => unimplemented!(),\n@@ -849,6 +855,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::Avr(_) => None,\n         InlineAsmRegClass::S390x(_) => None,\n         InlineAsmRegClass::Msp430(_) => None,\n+        InlineAsmRegClass::M68k(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "1a3865360a3c6709161aab895dcf6198e4e94480", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -244,6 +244,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::Msp430 => {\n                     constraints.push(\"~{sr}\".to_string());\n                 }\n+                InlineAsmArch::M68k => {\n+                    constraints.push(\"~{ccr}\".to_string());\n+                }\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -671,6 +674,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => \"a\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => \"d\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -768,6 +774,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::M68k(_) => None,\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n@@ -839,6 +846,9 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => cx.type_i16(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => cx.type_i32(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "6bfae3771521b1d7954e519a844253508918c125", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -1175,7 +1175,9 @@ symbols! {\n         reg32,\n         reg64,\n         reg_abcd,\n+        reg_addr,\n         reg_byte,\n+        reg_data,\n         reg_iw,\n         reg_nonzero,\n         reg_pair,"}, {"sha": "8c857550cf21a135e007c4a5adb09c8335aa1f6a", "filename": "compiler/rustc_target/src/asm/m68k.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -0,0 +1,81 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n+use std::fmt;\n+\n+def_reg_class! {\n+    M68k M68kInlineAsmRegClass {\n+        reg,\n+        reg_addr,\n+        reg_data,\n+    }\n+}\n+\n+impl M68kInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n+        match self {\n+            Self::reg => types! { _: I16, I32; },\n+            Self::reg_data => types! { _: I8, I16, I32; },\n+            Self::reg_addr => types! { _: I16, I32; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    M68k M68kInlineAsmReg M68kInlineAsmRegClass {\n+        d0: reg, reg_data = [\"d0\"],\n+        d1: reg, reg_data = [\"d1\"],\n+        d2: reg, reg_data = [\"d2\"],\n+        d3: reg, reg_data = [\"d3\"],\n+        d4: reg, reg_data = [\"d4\"],\n+        d5: reg, reg_data = [\"d5\"],\n+        d6: reg, reg_data = [\"d6\"],\n+        d7: reg, reg_data = [\"d7\"],\n+        a0: reg, reg_addr = [\"a0\"],\n+        a1: reg, reg_addr = [\"a1\"],\n+        a2: reg, reg_addr = [\"a2\"],\n+        a3: reg, reg_addr = [\"a3\"],\n+        #error = [\"a4\"] =>\n+            \"a4 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a5\", \"bp\"] =>\n+            \"a5 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a6\", \"fp\"] =>\n+            \"a6 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a7\", \"sp\", \"usp\", \"ssp\", \"isp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl M68kInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "3f9c850b3524c45e4e4e7da4d0da9546f2b6f220", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -168,6 +168,7 @@ mod arm;\n mod avr;\n mod bpf;\n mod hexagon;\n+mod m68k;\n mod mips;\n mod msp430;\n mod nvptx;\n@@ -183,6 +184,7 @@ pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n pub use avr::{AvrInlineAsmReg, AvrInlineAsmRegClass};\n pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n+pub use m68k::{M68kInlineAsmReg, M68kInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use msp430::{Msp430InlineAsmReg, Msp430InlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n@@ -214,6 +216,7 @@ pub enum InlineAsmArch {\n     Bpf,\n     Avr,\n     Msp430,\n+    M68k,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -240,6 +243,7 @@ impl FromStr for InlineAsmArch {\n             \"bpf\" => Ok(Self::Bpf),\n             \"avr\" => Ok(Self::Avr),\n             \"msp430\" => Ok(Self::Msp430),\n+            \"m68k\" => Ok(Self::M68k),\n             _ => Err(()),\n         }\n     }\n@@ -262,6 +266,7 @@ pub enum InlineAsmReg {\n     Bpf(BpfInlineAsmReg),\n     Avr(AvrInlineAsmReg),\n     Msp430(Msp430InlineAsmReg),\n+    M68k(M68kInlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -280,6 +285,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n             Self::Msp430(r) => r.name(),\n+            Self::M68k(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -297,6 +303,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),\n             Self::Msp430(r) => InlineAsmRegClass::Msp430(r.reg_class()),\n+            Self::M68k(r) => InlineAsmRegClass::M68k(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -328,6 +335,7 @@ impl InlineAsmReg {\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmReg::parse(name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmReg::parse(name)?),\n             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(name)?),\n+            InlineAsmArch::M68k => Self::M68k(M68kInlineAsmReg::parse(name)?),\n         })\n     }\n \n@@ -351,6 +359,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::M68k(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Err => unreachable!(),\n         }\n     }\n@@ -375,6 +384,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Avr(r) => r.emit(out, arch, modifier),\n             Self::Msp430(r) => r.emit(out, arch, modifier),\n+            Self::M68k(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -392,6 +402,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),\n             Self::Msp430(_) => cb(self),\n+            Self::M68k(_) => cb(self),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -414,6 +425,7 @@ pub enum InlineAsmRegClass {\n     Bpf(BpfInlineAsmRegClass),\n     Avr(AvrInlineAsmRegClass),\n     Msp430(Msp430InlineAsmRegClass),\n+    M68k(M68kInlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -435,6 +447,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n             Self::Msp430(r) => r.name(),\n+            Self::M68k(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -458,6 +471,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n             Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),\n             Self::Msp430(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Msp430),\n+            Self::M68k(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::M68k),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -488,6 +502,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n             Self::Avr(r) => r.suggest_modifier(arch, ty),\n             Self::Msp430(r) => r.suggest_modifier(arch, ty),\n+            Self::M68k(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -514,6 +529,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.default_modifier(arch),\n             Self::Avr(r) => r.default_modifier(arch),\n             Self::Msp430(r) => r.default_modifier(arch),\n+            Self::M68k(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -539,6 +555,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.supported_types(arch),\n             Self::Avr(r) => r.supported_types(arch),\n             Self::Msp430(r) => r.supported_types(arch),\n+            Self::M68k(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -569,6 +586,7 @@ impl InlineAsmRegClass {\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::M68k => Self::M68k(M68kInlineAsmRegClass::parse(name)?),\n         })\n     }\n \n@@ -590,6 +608,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.valid_modifiers(arch),\n             Self::Avr(r) => r.valid_modifiers(arch),\n             Self::Msp430(r) => r.valid_modifiers(arch),\n+            Self::M68k(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -776,6 +795,11 @@ pub fn allocatable_registers(\n             msp430::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n+        InlineAsmArch::M68k => {\n+            let mut map = m68k::regclass_map();\n+            m68k::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n+            map\n+        }\n     }\n }\n "}, {"sha": "1f52ab75010e6f63a93cfde5f0cb0150838b2623", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -16,6 +16,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n - SPIR-V\n - AVR\n - MSP430\n+- M68k\n \n ## Register classes\n \n@@ -41,6 +42,9 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg_iw`       | `r25r24`, `X`, `Z`                 | `w`                  |\n | AVR          | `reg_ptr`      | `X`, `Z`                           | `e`                  |\n | MSP430       | `reg`          | `r[0-15]`                          | `r`                  |\n+| M68k         | `reg`          | `d[0-7]`, `a[0-7]`                 | `r`                  |\n+| M68k         | `reg_data`     | `d[0-7]`                           | `d`                  |\n+| M68k         | `reg_addr`     | `a[0-3]`                           | `a`                  |\n \n > **Notes**:\n > - NVPTX doesn't have a fixed register set, so named registers are not supported.\n@@ -70,6 +74,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg`, `reg_upper`              | None           | `i8`                                    |\n | AVR          | `reg_pair`, `reg_iw`, `reg_ptr` | None           | `i16`                                   |\n | MSP430       | `reg`                           | None           | `i8`, `i16`                             |\n+| M68k         | `reg`, `reg_addr`               | None           | `i16`, `i32`                            |\n+| M68k         | `reg_data`                      | None           | `i8`, `i16`, `i32`                      |\n \n ## Register aliases\n \n@@ -88,6 +94,9 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | MSP430       | `r2`          | `sr`      |\n | MSP430       | `r3`          | `cg`      |\n | MSP430       | `r4`          | `fp`      |\n+| M68k         | `a5`          | `bp`      |\n+| M68k         | `a6`          | `fp`      |\n+| M68k         | `a7`          | `sp`, `usp`, `ssp`, `isp` |\n \n > **Notes**:\n > - TI does not mandate a frame pointer for MSP430, but toolchains are allowed\n@@ -98,7 +107,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n | ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n | All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n-| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430), `a6` (M68k) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n | All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n | MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n | MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n@@ -108,6 +117,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | Hexagon      | `lr`                                    | This is the link register which cannot be used as an input or output.                                                                                                               |\n | AVR          | `r0`, `r1`, `r1r0`                      | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n |MSP430        | `r0`, `r2`, `r3`                        | These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.                          |\n+| M68k         | `a4`, `a5`                              | Used internally by LLVM for the base pointer and global base pointer. |\n \n ## Template modifiers\n \n@@ -130,3 +140,5 @@ These flags registers must be restored upon exiting the asm block if the `preser\n   - The status register `SREG`.\n - MSP430\n   - The status register `r2`.\n+- M68k\n+  - The condition code register `ccr`."}, {"sha": "0322e615a197a22c3266f148fc443a552a20b6b6", "filename": "tests/assembly/asm/m68k-types.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e14b81f10de3e528f13692ab97ee90c5d96b170a/tests%2Fassembly%2Fasm%2Fm68k-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14b81f10de3e528f13692ab97ee90c5d96b170a/tests%2Fassembly%2Fasm%2Fm68k-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fasm%2Fm68k-types.rs?ref=e14b81f10de3e528f13692ab97ee90c5d96b170a", "patch": "@@ -0,0 +1,83 @@\n+// assembly-output: emit-asm\n+// compile-flags: --target m68k-unknown-linux-gnu\n+// needs-llvm-components: m68k\n+\n+#![feature(no_core, lang_items, rustc_attrs, asm_experimental_arch)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const u64;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for ptr {}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!($mov, \" {}, {};\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_data_i8:\n+// CHECK: ;APP\n+// CHECK: move.b %d{{[0-9]}}, %d{{[0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_data_i8 i8 reg_data \"move.b\");\n+\n+// CHECK-LABEL: reg_data_i16:\n+// CHECK: ;APP\n+// CHECK: move.w %d{{[0-9]}}, %d{{[0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_data_i16 i16 reg_data \"move.w\");\n+\n+// CHECK-LABEL: reg_data_i32:\n+// CHECK: ;APP\n+// CHECK: move.l %d{{[0-9]}}, %d{{[0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_data_i32 i32 reg_data \"move.l\");\n+\n+// CHECK-LABEL: reg_addr_i16:\n+// CHECK: ;APP\n+// CHECK: move.w %a{{[0-9]}}, %a{{[0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_addr_i16 i16 reg_addr \"move.w\");\n+\n+// CHECK-LABEL: reg_addr_i32:\n+// CHECK: ;APP\n+// CHECK: move.l %a{{[0-9]}}, %a{{[0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_addr_i32 i32 reg_addr \"move.l\");\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: ;APP\n+// CHECK: move.w %{{[da][0-9]}}, %{{[da][0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_i16 i16 reg \"move.w\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: ;APP\n+// CHECK: move.l %{{[da][0-9]}}, %{{[da][0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_i32 i32 reg \"move.l\");"}]}