{"sha": "745233f3ab9ea4b48803ead076df6ae66f4e1072", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NTIzM2YzYWI5ZWE0YjQ4ODAzZWFkMDc2ZGY2YWU2NmY0ZTEwNzI=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2017-06-21T18:04:04Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2017-06-21T18:04:04Z"}, "message": "Use span_lint_and_sugg", "tree": {"sha": "eaee557919a3b32c855a993d62c56de99c92422c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaee557919a3b32c855a993d62c56de99c92422c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/745233f3ab9ea4b48803ead076df6ae66f4e1072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/745233f3ab9ea4b48803ead076df6ae66f4e1072", "html_url": "https://github.com/rust-lang/rust/commit/745233f3ab9ea4b48803ead076df6ae66f4e1072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/745233f3ab9ea4b48803ead076df6ae66f4e1072/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88101d5b78d6c45f3dd3e6842d43109d91d534bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88101d5b78d6c45f3dd3e6842d43109d91d534bd", "html_url": "https://github.com/rust-lang/rust/commit/88101d5b78d6c45f3dd3e6842d43109d91d534bd"}], "stats": {"total": 213, "additions": 91, "deletions": 122}, "files": [{"sha": "1178f98db593b16377378c6eedceda3cf46807a4", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -15,7 +15,7 @@\n use rustc::lint::*;\n use syntax::ast;\n \n-use utils::{in_macro, snippet_block, span_lint_and_then};\n+use utils::{in_macro, snippet_block, span_lint_and_then, span_lint_and_sugg};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for nested `if` statements which can be collapsed\n@@ -108,12 +108,12 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     ], {\n         match else_.node {\n             ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n-                span_lint_and_then(cx,\n+                span_lint_and_sugg(cx,\n                                    COLLAPSIBLE_IF,\n                                    block.span,\n-                                   \"this `else { if .. }` block can be collapsed\", |db| {\n-                    db.span_suggestion(block.span, \"try\", snippet_block(cx, else_.span, \"..\").into_owned());\n-                });\n+                                   \"this `else { if .. }` block can be collapsed\",\n+                                   \"try\",\n+                                   snippet_block(cx, else_.span, \"..\").into_owned());\n             }\n             _ => (),\n         }"}, {"sha": "266e61d90b03b0e588d32447400381cf7e764b46", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -4,7 +4,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::codemap::{Span, Spanned};\n-use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty};\n+use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for getting the length of something via `.len()`\n /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n@@ -171,11 +171,9 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n         if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n-            span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n-                db.span_suggestion(span,\n-                                   \"using `is_empty` is more concise:\",\n-                                   format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")));\n-            });\n+            span_lint_and_sugg(cx, LEN_ZERO, span, \"length comparison to zero\",\n+                               \"using `is_empty` is more concise:\",\n+                               format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")));\n         }\n     }\n }"}, {"sha": "8ef9c1d35f961b8cf042d537a6281d2d92de8a06", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -377,16 +377,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 // 1) it was ugly with big bodies;\n                                 // 2) it was not indented properly;\n                                 // 3) it wasn\u2019t very smart (see #675).\n-                                span_lint_and_then(cx,\n+                                span_lint_and_sugg(cx,\n                                                    WHILE_LET_LOOP,\n                                                    expr.span,\n                                                    \"this loop could be written as a `while let` loop\",\n-                                                   |db| {\n-                                    let sug = format!(\"while let {} = {} {{ .. }}\",\n-                                                      snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                      snippet(cx, matchexpr.span, \"..\"));\n-                                    db.span_suggestion(expr.span, \"try\", sug);\n-                                });\n+                                                   \"try\",\n+                                                   format!(\"while let {} = {} {{ .. }}\",\n+                                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                           snippet(cx, matchexpr.span, \"..\")));\n                             }\n                         },\n                         _ => (),\n@@ -405,13 +403,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                    span_lint_and_then(cx,\n+                    span_lint_and_sugg(cx,\n                                        WHILE_LET_ON_ITERATOR,\n                                        expr.span,\n                                        \"this loop could be written as a `for` loop\",\n-                                       |db| {\n-                        db.span_suggestion(expr.span, \"try\", format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n-                    });\n+                                       \"try\",\n+                                       format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n                 }\n             }\n         }"}, {"sha": "6ee110cd026b82cef0ee905891707925c4ec7103", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -9,7 +9,7 @@ use std::collections::Bound;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block, walk_ptrs_ty,\n+use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, span_lint_and_sugg, in_external_macro, expr_block, walk_ptrs_ty,\n             is_expn_of, remove_blocks};\n use utils::sugg::Sugg;\n \n@@ -210,20 +210,17 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n         SINGLE_MATCH\n     };\n     let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-    span_lint_and_then(cx,\n+    span_lint_and_sugg(cx,\n                        lint,\n                        expr.span,\n                        \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n                         let`\",\n-                       |db| {\n-        db.span_suggestion(expr.span,\n-                           \"try this\",\n-                           format!(\"if let {} = {} {}{}\",\n-                                   snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                   snippet(cx, ex.span, \"..\"),\n-                                   expr_block(cx, &arms[0].body, None, \"..\"),\n-                                   els_str));\n-    });\n+                       \"try this\",\n+                       format!(\"if let {} = {} {}{}\",\n+                               snippet(cx, arms[0].pats[0].span, \"..\"),\n+                               snippet(cx, ex.span, \"..\"),\n+                               expr_block(cx, &arms[0].body, None, \"..\"),\n+                               els_str));\n }\n \n fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {"}, {"sha": "d67b39a926e16a4b3123cff5c7946c92b22cbfcc", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -8,7 +8,7 @@ use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n+            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then, span_lint_and_sugg,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n             match_def_path, is_self, is_self_ty, iter_input_pats, match_path_old};\n use utils::paths;\n@@ -725,15 +725,12 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n-                        span_lint_and_then(cx,\n+                        span_lint_and_sugg(cx,\n                                            OR_FUN_CALL,\n                                            span,\n                                            &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                                           |db| {\n-                            db.span_suggestion(span,\n-                                               \"try this\",\n-                                               format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n-                        });\n+                                           \"try this\",\n+                                           format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n                         return true;\n                     }\n                 }\n@@ -791,15 +788,12 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             (false, true) => snippet(cx, fun_span, \"..\"),\n         };\n \n-        span_lint_and_then(cx,\n+        span_lint_and_sugg(cx,\n                            OR_FUN_CALL,\n                            span,\n                            &format!(\"use of `{}` followed by a function call\", name),\n-                           |db| {\n-            db.span_suggestion(span,\n-                               \"try this\",\n-                               format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n-        });\n+                           \"try this\",\n+                           format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n     }\n \n     if args.len() == 2 {\n@@ -865,14 +859,12 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n             return;\n         };\n \n-        span_lint_and_then(cx, STRING_EXTEND_CHARS, expr.span, \"calling `.extend(_.chars())`\", |db| {\n-            db.span_suggestion(expr.span,\n-                               \"try this\",\n-                               format!(\"{}.push_str({}{})\",\n-                                       snippet(cx, args[0].span, \"_\"),\n-                                       ref_str,\n-                                       snippet(cx, target.span, \"_\")));\n-        });\n+        span_lint_and_sugg(cx, STRING_EXTEND_CHARS, expr.span, \"calling `.extend(_.chars())`\",\n+                           \"try this\",\n+                           format!(\"{}.push_str({}{})\",\n+                                   snippet(cx, args[0].span, \"_\"),\n+                                   ref_str,\n+                                   snippet(cx, target.span, \"_\")));\n     }\n }\n \n@@ -951,20 +943,17 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n \n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let borrow_str = if is_mut { \"&mut \" } else { \"&\" };\n-    span_lint_and_then(cx,\n+    span_lint_and_sugg(cx,\n                        GET_UNWRAP,\n                        expr.span,\n                        &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n                                 mut_str,\n                                 caller_type),\n-                       |db| {\n-        db.span_suggestion(expr.span,\n-                           \"try this\",\n-                           format!(\"{}{}[{}]\",\n-                                   borrow_str,\n-                                   snippet(cx, get_args[0].span, \"_\"),\n-                                   snippet(cx, get_args[1].span, \"_\")));\n-    });\n+                       \"try this\",\n+                       format!(\"{}{}[{}]\",\n+                               borrow_str,\n+                               snippet(cx, get_args[0].span, \"_\"),\n+                               snippet(cx, get_args[1].span, \"_\")));\n }\n \n fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n@@ -1216,19 +1205,15 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n             return false;\n         }\n \n-        span_lint_and_then(cx,\n+        span_lint_and_sugg(cx,\n                            CHARS_NEXT_CMP,\n                            expr.span,\n                            \"you should use the `starts_with` method\",\n-                           |db| {\n-                               let sugg = format!(\"{}{}.starts_with({})\",\n-                                                  if eq { \"\" } else { \"!\" },\n-                                                  snippet(cx, args[0][0].span, \"_\"),\n-                                                  snippet(cx, arg_char[0].span, \"_\")\n-                                                  );\n-\n-                               db.span_suggestion(expr.span, \"like this\", sugg);\n-                           });\n+                           \"like this\",\n+                           format!(\"{}{}.starts_with({})\",\n+                                   if eq { \"\" } else { \"!\" },\n+                                   snippet(cx, args[0][0].span, \"_\"),\n+                                   snippet(cx, arg_char[0].span, \"_\")));\n \n         return true;\n     }}"}, {"sha": "db6c38b0ff6841a8ef415a91476aca23ca8c15aa", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -6,7 +6,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n-use utils::{span_lint, span_lint_and_then, snippet};\n+use utils::{span_lint, span_lint_and_sugg, snippet};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for expressions of the form `if c { true } else { false }`\n@@ -70,11 +70,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     snip.to_string()\n                 };\n \n-                span_lint_and_then(cx,\n+                span_lint_and_sugg(cx,\n                                    NEEDLESS_BOOL,\n                                    e.span,\n                                    \"this if-then-else expression returns a bool literal\",\n-                                   |db| { db.span_suggestion(e.span, \"you can reduce it to\", hint); });\n+                                   \"you can reduce it to\",\n+                                   hint);\n             };\n             if let ExprBlock(ref then_block) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n@@ -121,39 +122,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n-                    span_lint_and_then(cx,\n+                    span_lint_and_sugg(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n-                                       |db| { db.span_suggestion(e.span, \"try simplifying it as shown:\", hint); });\n+                                       \"try simplifying it as shown:\",\n+                                       hint);\n                 },\n                 (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n-                    span_lint_and_then(cx,\n+                    span_lint_and_sugg(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n-                                       |db| { db.span_suggestion(e.span, \"try simplifying it as shown:\", hint); });\n+                                       \"try simplifying it as shown:\",\n+                                       hint);\n                 },\n                 (Bool(false), Other) => {\n                     let hint = Sugg::hir(cx, right_side, \"..\");\n-                    span_lint_and_then(cx,\n+                    span_lint_and_sugg(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n-                                       |db| {\n-                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                    });\n+                                       \"try simplifying it as shown:\",\n+                                       (!hint).to_string());\n                 },\n                 (Other, Bool(false)) => {\n                     let hint = Sugg::hir(cx, left_side, \"..\");\n-                    span_lint_and_then(cx,\n+                    span_lint_and_sugg(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n-                                       |db| {\n-                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                    });\n+                                       \"try simplifying it as shown:\",\n+                                       (!hint).to_string());\n                 },\n                 _ => (),\n             }"}, {"sha": "a88662356fbbba96f0802b4ba6890100f9171876", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::def::Def;\n use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource, BiAnd, BiOr};\n-use utils::{in_macro, span_lint, snippet_opt, span_lint_and_then};\n+use utils::{in_macro, span_lint, snippet_opt, span_lint_and_sugg};\n use std::ops::Deref;\n \n /// **What it does:** Checks for statements which have no effect.\n@@ -120,11 +120,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         return;\n                     }\n                 }\n-                span_lint_and_then(cx,\n+                span_lint_and_sugg(cx,\n                                    UNNECESSARY_OPERATION,\n                                    stmt.span,\n                                    \"statement can be reduced\",\n-                                   |db| { db.span_suggestion(stmt.span, \"replace it with\", snippet); });\n+                                   \"replace it with\",\n+                                   snippet);\n             }\n         }\n     }"}, {"sha": "91178f0c99979fb5f0662793786dd5add114a0ea", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{span_lint_and_then, snippet};\n+use utils::{span_lint_and_sugg, snippet};\n \n /// **What it does:** Checks for operations where precedence may be unclear\n /// and suggests to add parentheses. Currently it catches the following:\n@@ -38,9 +38,8 @@ impl EarlyLintPass for Precedence {\n         if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n             let span_sugg =\n                 |expr: &Expr, sugg| {\n-                    span_lint_and_then(cx, PRECEDENCE, expr.span, \"operator precedence can trip the unwary\", |db| {\n-                        db.span_suggestion(expr.span, \"consider parenthesizing your expression\", sugg);\n-                    });\n+                    span_lint_and_sugg(cx, PRECEDENCE, expr.span, \"operator precedence can trip the unwary\",\n+                                       \"consider parenthesizing your expression\", sugg);\n                 };\n \n             if !is_bit_op(op) {\n@@ -80,15 +79,12 @@ impl EarlyLintPass for Precedence {\n                             LitKind::Int(..) |\n                             LitKind::Float(..) |\n                             LitKind::FloatUnsuffixed(..) => {\n-                                span_lint_and_then(cx,\n+                                span_lint_and_sugg(cx,\n                                                    PRECEDENCE,\n                                                    expr.span,\n                                                    \"unary minus has lower precedence than method call\",\n-                                                   |db| {\n-                                    db.span_suggestion(expr.span,\n-                                                       \"consider adding parentheses to clarify your intent\",\n-                                                       format!(\"-({})\", snippet(cx, rhs.span, \"..\")));\n-                                });\n+                                                   \"consider adding parentheses to clarify your intent\",\n+                                                   format!(\"-({})\", snippet(cx, rhs.span, \"..\")));\n                             },\n                             _ => (),\n                         }"}, {"sha": "0fb03d25f16b0c45642495df8e2171172919ea0f", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -1,6 +1,6 @@\n use syntax::ast::{Expr, ExprKind, UnOp};\n use rustc::lint::*;\n-use utils::{span_lint_and_then, snippet};\n+use utils::{span_lint_and_sugg, snippet};\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n ///\n@@ -40,9 +40,8 @@ impl EarlyLintPass for Pass {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n         if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node {\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node {\n-                span_lint_and_then(cx, DEREF_ADDROF, e.span, \"immediately dereferencing a reference\", |db| {\n-                    db.span_suggestion(e.span, \"try this\", format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n-                });\n+                span_lint_and_sugg(cx, DEREF_ADDROF, e.span, \"immediately dereferencing a reference\",\n+                                   \"try this\", format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n             }\n         }\n     }"}, {"sha": "a2801cb82e011e5f992a61fe7e0ce07b1d574d87", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use syntax::codemap::Spanned;\n use utils::SpanlessEq;\n-use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty, get_parent_expr};\n \n /// **What it does:** Checks for string appends of the form `x = x + y` (without\n /// `let`!).\n@@ -147,15 +147,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n-                            span_lint_and_then(cx,\n+                            span_lint_and_sugg(cx,\n                                                STRING_LIT_AS_BYTES,\n                                                e.span,\n                                                \"calling `as_bytes()` on a string literal\",\n-                                               |db| {\n-                                let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n-                                db.span_suggestion(e.span, \"consider using a byte string literal instead\", sugg);\n-                            });\n-\n+                                               \"consider using a byte string literal instead\",\n+                                               format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#)));\n                         }\n                     }\n                 }"}, {"sha": "f8a16635a2286c2eb2fb21d105cbf778b6098d7a", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -8,7 +8,7 @@ use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint, span_lint_and_then,\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint, span_lint_and_sugg,\n             opt_def_id, last_path_segment, type_size};\n use utils::paths;\n \n@@ -210,15 +210,12 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                         } else {\n                             \"\"\n                         };\n-                        span_lint_and_then(cx,\n+                        span_lint_and_sugg(cx,\n                             BORROWED_BOX,\n                             ast_ty.span,\n                             \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                            |db| {\n-                                db.span_suggestion(ast_ty.span,\n-                                    \"try\",\n-                                    format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")));\n-                            }\n+                            \"try\",\n+                            format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n                         );\n                         return; // don't recurse into the type\n                     }};"}, {"sha": "8a4731c3eb003a202e14d18aaefbc0c3745cf6d3", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745233f3ab9ea4b48803ead076df6ae66f4e1072/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=745233f3ab9ea4b48803ead076df6ae66f4e1072", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n-use utils::{higher, is_copy, snippet, span_lint_and_then};\n+use utils::{higher, is_copy, snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n /// be possible.\n@@ -80,11 +80,12 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n         },\n     };\n \n-    span_lint_and_then(cx,\n+    span_lint_and_sugg(cx,\n                        USELESS_VEC,\n                        span,\n                        \"useless use of `vec!`\",\n-                       |db| { db.span_suggestion(span, \"you can use a slice directly\", snippet); });\n+                       \"you can use a slice directly\",\n+                       snippet);\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`)."}]}