{"sha": "940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MGY2NTc4MmNjNWRmN2ZlY2FkMjdiMzhjYzI1YjZkMWVlYWYyZTg=", "commit": {"author": {"name": "David Ross", "email": "daboross@daboross.net", "date": "2020-02-09T05:34:38Z"}, "committer": {"name": "David Ross", "email": "daboross@daboross.net", "date": "2020-02-16T03:50:50Z"}, "message": "Parse & reject postfix operators after casts\n\nThis adds parsing for expressions like 'x as Ty[0]' which will\nimmediately error out, but still give the rest of the parser a valid\nparse tree to continue.", "tree": {"sha": "efb0a542523c63ed8de3ca72ee26e5abe3b8f4e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb0a542523c63ed8de3ca72ee26e5abe3b8f4e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "html_url": "https://github.com/rust-lang/rust/commit/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/comments", "author": {"login": "daboross", "id": 1152146, "node_id": "MDQ6VXNlcjExNTIxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1152146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daboross", "html_url": "https://github.com/daboross", "followers_url": "https://api.github.com/users/daboross/followers", "following_url": "https://api.github.com/users/daboross/following{/other_user}", "gists_url": "https://api.github.com/users/daboross/gists{/gist_id}", "starred_url": "https://api.github.com/users/daboross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daboross/subscriptions", "organizations_url": "https://api.github.com/users/daboross/orgs", "repos_url": "https://api.github.com/users/daboross/repos", "events_url": "https://api.github.com/users/daboross/events{/privacy}", "received_events_url": "https://api.github.com/users/daboross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "daboross", "id": 1152146, "node_id": "MDQ6VXNlcjExNTIxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1152146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daboross", "html_url": "https://github.com/daboross", "followers_url": "https://api.github.com/users/daboross/followers", "following_url": "https://api.github.com/users/daboross/following{/other_user}", "gists_url": "https://api.github.com/users/daboross/gists{/gist_id}", "starred_url": "https://api.github.com/users/daboross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daboross/subscriptions", "organizations_url": "https://api.github.com/users/daboross/orgs", "repos_url": "https://api.github.com/users/daboross/repos", "events_url": "https://api.github.com/users/daboross/events{/privacy}", "received_events_url": "https://api.github.com/users/daboross/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ba3ca0e6bef416ecba3c8ded1f67a953d28600f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba3ca0e6bef416ecba3c8ded1f67a953d28600f", "html_url": "https://github.com/rust-lang/rust/commit/8ba3ca0e6bef416ecba3c8ded1f67a953d28600f"}], "stats": {"total": 178, "additions": 176, "deletions": 2}, "files": [{"sha": "d7d3145770ca139636240b8fb133e740bda35221", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "patch": "@@ -551,7 +551,7 @@ impl<'a> Parser<'a> {\n         // Save the state of the parser before parsing type normally, in case there is a\n         // LessThan comparison after this cast.\n         let parser_snapshot_before_type = self.clone();\n-        match self.parse_ty_no_plus() {\n+        let type_result = match self.parse_ty_no_plus() {\n             Ok(rhs) => Ok(mk_expr(self, rhs)),\n             Err(mut type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n@@ -616,7 +616,44 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-        }\n+        };\n+\n+        // Disallow postfix operators such as `.`, `?` or index (`[]`) after casts.\n+        // Parses the postfix operator and emits an error.\n+        let expr = type_result?;\n+        let span = expr.span;\n+\n+        // The resulting parse tree for `&x as T[0]` has a precedence of `((&x) as T)[0]`.\n+        let with_postfix = self.parse_dot_or_call_expr_with_(expr, span)?;\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _)) {\n+            let expr_str = self.span_to_snippet(span);\n+\n+            let msg = format!(\n+                \"casts followed by {} are not supported\",\n+                match with_postfix.kind {\n+                    ExprKind::Index(_, _) => \"index operators\",\n+                    ExprKind::Try(_) => \"try operators\",\n+                    ExprKind::Field(_, _) => \"field access expressions\",\n+                    ExprKind::MethodCall(_, _) => \"method call expressions\",\n+                    ExprKind::Await(_) => \"awaits\",\n+                    _ => \"expressions\",\n+                }\n+            );\n+            let mut err = self.struct_span_err(with_postfix.span, &msg);\n+            let suggestion = \"try surrounding the expression with parentheses\";\n+            if let Ok(expr_str) = expr_str {\n+                err.span_suggestion(\n+                    span,\n+                    suggestion,\n+                    format!(\"({})\", expr_str),\n+                    Applicability::MachineApplicable,\n+                )\n+            } else {\n+                err.span_help(span, suggestion)\n+            }\n+            .emit();\n+        };\n+        Ok(with_postfix)\n     }\n \n     fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {"}, {"sha": "dd608b263ec6cbe45a41c4af3219535806a92156", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs?ref=940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "patch": "@@ -0,0 +1,63 @@\n+// edition:2018\n+#![crate_type = \"lib\"]\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+// This tests the parser for \"x as Y[z]\". It errors, but we want to give useful\n+// errors and parse such that further code gives useful errors.\n+pub fn index_after_as_cast() {\n+    vec![1, 2, 3] as Vec<i32>[0];\n+    //~^ ERROR: casts followed by index operators are not supported\n+}\n+\n+pub fn index_after_cast_to_index() {\n+    (&[0]) as &[i32][0];\n+    //~^ ERROR: casts followed by index operators are not supported\n+}\n+\n+// this tests that the precedence for `!x as Y.Z` is still what we expect\n+pub fn precedence() {\n+    let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+    //~^ ERROR: casts followed by index operators are not supported\n+}\n+\n+pub fn complex() {\n+    let _ = format!(\n+        \"{}\",\n+        if true { 33 } else { 44 } as i32.max(0)\n+        //~^ ERROR: casts followed by method call expressions are not supported\n+    );\n+}\n+\n+pub fn in_condition() {\n+    if 5u64 as i32.max(0) == 0 {\n+        //~^ ERROR: casts followed by method call expressions are not supported\n+    }\n+}\n+\n+pub fn inside_block() {\n+    let _ = if true {\n+        5u64 as u32.max(0) == 0\n+        //~^ ERROR: casts followed by method call expressions are not supported\n+    } else { false };\n+}\n+\n+static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+//~^ ERROR: casts followed by index operators are not supported\n+\n+pub async fn cast_then_await() {\n+    Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+    //~^ ERROR: casts followed by awaits are not supported\n+}\n+\n+pub async fn noop() {}\n+\n+#[derive(Default)]\n+pub struct Foo {\n+    pub bar: u32,\n+}\n+\n+pub fn struct_field() {\n+    Foo::default() as Foo.bar;\n+    //~^ ERROR: casts followed by field access expressions are not supported\n+}"}, {"sha": "9459e076ea0c52d63be108ded9b852eac7d703f8", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940f65782cc5df7fecad27b38cc25b6d1eeaf2e8/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr?ref=940f65782cc5df7fecad27b38cc25b6d1eeaf2e8", "patch": "@@ -0,0 +1,74 @@\n+error: casts followed by index operators are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:9:5\n+   |\n+LL |     vec![1, 2, 3] as Vec<i32>[0];\n+   |     -------------------------^^^\n+   |     |\n+   |     help: try surrounding the expression with parentheses: `(vec![1, 2, 3] as Vec<i32>)`\n+\n+error: casts followed by index operators are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:14:5\n+   |\n+LL |     (&[0]) as &[i32][0];\n+   |     ----------------^^^\n+   |     |\n+   |     help: try surrounding the expression with parentheses: `((&[0]) as &[i32])`\n+\n+error: casts followed by index operators are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:20:18\n+   |\n+LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+   |                  ---------------------------^^^\n+   |                  |\n+   |                  help: try surrounding the expression with parentheses: `(&vec![1, 2, 3] as &Vec<i32>)`\n+\n+error: casts followed by method call expressions are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:33:8\n+   |\n+LL |     if 5u64 as i32.max(0) == 0 {\n+   |        -----------^^^^^^^\n+   |        |\n+   |        help: try surrounding the expression with parentheses: `(5u64 as i32)`\n+\n+error: casts followed by method call expressions are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:40:9\n+   |\n+LL |         5u64 as u32.max(0) == 0\n+   |         -----------^^^^^^^\n+   |         |\n+   |         help: try surrounding the expression with parentheses: `(5u64 as u32)`\n+\n+error: casts followed by index operators are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:45:24\n+   |\n+LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+   |                        ------------------^^^^^^\n+   |                        |\n+   |                        help: try surrounding the expression with parentheses: `(&[1,2,3] as &[i32])`\n+\n+error: casts followed by awaits are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:49:5\n+   |\n+LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+   |     -----------------------------------------------------^^^^^^\n+   |     |\n+   |     help: try surrounding the expression with parentheses: `(Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>)`\n+\n+error: casts followed by field access expressions are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:61:5\n+   |\n+LL |     Foo::default() as Foo.bar;\n+   |     ---------------------^^^^\n+   |     |\n+   |     help: try surrounding the expression with parentheses: `(Foo::default() as Foo)`\n+\n+error: casts followed by method call expressions are not supported\n+  --> $DIR/issue-35813-postfix-after-cast.rs:27:9\n+   |\n+LL |         if true { 33 } else { 44 } as i32.max(0)\n+   |         ---------------------------------^^^^^^^\n+   |         |\n+   |         help: try surrounding the expression with parentheses: `(if true { 33 } else { 44 } as i32)`\n+\n+error: aborting due to 9 previous errors\n+"}]}