{"sha": "1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTAwY2ZkNzRjMDJiNmY5Zjg0YTRlNzM4N2Q4MTI2Yzc5ZjNmNzY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-01T06:01:08Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-30T02:51:55Z"}, "message": "changes to libs", "tree": {"sha": "f4c5489c98cfb2deb492c37021f4ab7d3ed54427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4c5489c98cfb2deb492c37021f4ab7d3ed54427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "html_url": "https://github.com/rust-lang/rust/commit/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "html_url": "https://github.com/rust-lang/rust/commit/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0"}], "stats": {"total": 294, "additions": 145, "deletions": 149}, "files": [{"sha": "c4e213790880f894c7269dd3190f03204e339326", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -53,7 +53,6 @@ register_diagnostics!(\n     E0035,\n     E0036,\n     E0038,\n-    E0039,\n     E0040,\n     E0044,\n     E0045,"}, {"sha": "4829083f021bf4e04ac3bc4a318db1d5af3e0382", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -21,8 +21,7 @@ use middle::typeck::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::UserString;\n-use util::ppaux::Repr;\n+use util::ppaux::{UserString, Repr, ty_to_string};\n \n pub fn check_object_cast(fcx: &FnCtxt,\n                          cast_expr: &ast::Expr,\n@@ -131,32 +130,61 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     }\n }\n \n-// TODO comment\n+// Check that a trait is 'object-safe'. This should be checked whenever a trait object\n+// is created (by casting or coercion, etc.). A trait is object-safe if all its\n+// methods are object-safe. A trait method is object-safe if it does not take\n+// self by value, has no type parameters and does not use the `Self` type, except\n+// in self position.\n pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Span) {\n+    // Skip the fn_once lang item trait since only the compiler should call\n+    // `call_once` which is the method which takes self by value. What could go\n+    // wrong?\n+    match tcx.lang_items.fn_once_trait() {\n+        Some(def_id) if def_id == object_trait.def_id => return,\n+        _ => {}\n+    }\n+\n     let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+\n+    let mut errors = Vec::new();\n     for item in trait_items.iter() {\n         match *item {\n-            ty::MethodTraitItem(ref m) => check_object_safety_of_method(tcx, &**m, span),\n+            ty::MethodTraitItem(ref m) => {\n+                errors.push(check_object_safety_of_method(tcx, &**m))\n+            }\n             ty::TypeTraitItem(_) => {}\n         }\n     }\n \n-    // TODO error messages\n-    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method, span: Span) {\n+    let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n+    if errors.peek().is_some() {\n+        let trait_name = ty::item_path_str(tcx, object_trait.def_id);\n+        span_err!(tcx.sess, span, E0038,\n+            \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+            trait_name);\n+\n+        for msg in errors {\n+            tcx.sess.note(msg.as_slice());\n+        }\n+    }\n+\n+    // Returns a vec of error messages. If hte vec is empty - no errors!\n+    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method) -> Vec<String> {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n          * (that's the whole point of a trait instance, after all, to\n          * obscure the self type) and (b) the call must go through a\n          * vtable and hence cannot be monomorphized.\n          */\n+        let mut msgs = Vec::new();\n+\n+        let method_name = method.ident.repr(tcx);\n \n         match method.explicit_self {\n             ty::ByValueExplicitSelfCategory => { // reason (a) above\n-                tcx.sess.span_err(\n-                    span,\n-                    \"cannot call a method with a by-value receiver \\\n-                     through a trait object\");\n+                msgs.push(format!(\"cannot call a method (`{}`) with a by-value \\\n+                                   receiver through a trait object\", method_name))\n             }\n \n             ty::StaticExplicitSelfCategory |\n@@ -167,31 +195,29 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n         // reason (a) above\n         let check_for_self_ty = |ty| {\n             if ty::type_has_self(ty) {\n-                span_err!(tcx.sess, span, E0038,\n-                    \"cannot call a method whose type contains a \\\n-                     self-type through an object: {}\", ::util::ppaux::ty_to_string(tcx, ty));\n-                true\n+                Some(format!(\n+                    \"cannot call a method (`{}`) whose type (`{}`) contains \\\n+                     a self-type through a trait object\",\n+                    method_name, ty_to_string(tcx, ty)))\n             } else {\n-                false\n+                None\n             }\n         };\n         let ref sig = method.fty.sig;\n-        let mut found_self_ty = false;\n-        for &input_ty in sig.inputs.tail().iter() {\n-            if check_for_self_ty(input_ty) {\n-                found_self_ty = true;\n-                break;\n+        for &input_ty in sig.inputs.tail().iter().chain([sig.output].iter()) {\n+            match check_for_self_ty(input_ty) {\n+                Some(msg) => msgs.push(msg),\n+                _ => {}\n             }\n         }\n-        if !found_self_ty {\n-            check_for_self_ty(sig.output);\n-        }\n \n         if method.generics.has_type_params(FnSpace) {\n             // reason (b) above\n-            span_err!(tcx.sess, span, E0039,\n-                \"cannot call a generic method through an object\");\n+            msgs.push(format!(\"cannot call a generic method (`{}`) through a trait object\",\n+                              method_name));\n         }\n+\n+        msgs\n     }\n }\n "}, {"sha": "cbb982e731ab45be507c9e06fc3c6d840f117286", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -14,7 +14,7 @@\n \n use cmp;\n use collections::Collection;\n-use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n+use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult, AsRefReader};\n use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n@@ -118,6 +118,8 @@ impl<R: Reader> Reader for BufferedReader<R> {\n     }\n }\n \n+impl<R: Reader> AsRefReader for BufferedReader<R> {}\n+\n /// Wraps a Writer and buffers output to it\n ///\n /// It can be excessively inefficient to work directly with a `Writer`. For"}, {"sha": "c743bee1fc9776c2c9124ea498ac973aa621e2e5", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -17,7 +17,7 @@ use collections::Collection;\n use option::None;\n use result::{Err, Ok};\n use io;\n-use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n+use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult, AsRefReader, AsRefWriter};\n use slice;\n use slice::AsSlice;\n use vec::Vec;\n@@ -97,6 +97,8 @@ impl Writer for MemWriter {\n     }\n }\n \n+impl AsRefWriter for MemWriter {}\n+\n /// Reads from an owned byte vector\n ///\n /// # Example\n@@ -163,6 +165,8 @@ impl Reader for MemReader {\n     }\n }\n \n+impl AsRefReader for MemReader {}\n+\n impl Seek for MemReader {\n     #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n@@ -309,6 +313,8 @@ impl<'a> Reader for BufReader<'a> {\n      }\n }\n \n+impl<'a> AsRefReader for BufReader<'a> {}\n+\n impl<'a> Seek for BufReader<'a> {\n     #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }"}, {"sha": "6aba5f67643a61240508a63ffe119da6a42c0960", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -712,17 +712,6 @@ pub trait Reader {\n         })\n     }\n \n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n-        extensions::Bytes::new(self)\n-    }\n-\n     // Byte conversion helpers\n \n     /// Reads `n` little-endian unsigned integer bytes.\n@@ -932,7 +921,10 @@ pub trait Reader {\n     fn read_i8(&mut self) -> IoResult<i8> {\n         self.read_byte().map(|i| i as i8)\n     }\n+}\n \n+/// A reader which can be converted to a RefReader.\n+pub trait AsRefReader {\n     /// Creates a wrapper around a mutable reference to the reader.\n     ///\n     /// This is useful to allow applying adaptors while still\n@@ -942,6 +934,20 @@ pub trait Reader {\n     }\n }\n \n+/// A reader which can be converted to bytes.\n+pub trait BytesReader: Reader {\n+    /// Create an iterator that reads a single byte on\n+    /// each iteration, until EOF.\n+    ///\n+    /// # Error\n+    ///\n+    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n+    /// is returned by the iterator and should be handled by the caller.\n+    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n+        extensions::Bytes::new(self)\n+    }\n+}\n+\n impl<'a> Reader for Box<Reader+'a> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let reader: &mut Reader = &mut **self;\n@@ -986,6 +992,7 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// # fn process_input<R: Reader>(r: R) {}\n /// # fn foo() {\n /// use std::io;\n+/// use std::io::AsRefReader;\n /// use std::io::util::LimitReader;\n ///\n /// let mut stream = io::stdin();\n@@ -1268,7 +1275,10 @@ pub trait Writer {\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n+}\n \n+/// A writer which can be converted to a RefWriter.\n+pub trait AsRefWriter {\n     /// Creates a wrapper around a mutable reference to the writer.\n     ///\n     /// This is useful to allow applying wrappers while still\n@@ -1309,7 +1319,7 @@ impl<'a> Writer for &'a mut Writer+'a {\n /// # fn process_input<R: Reader>(r: R) {}\n /// # fn foo () {\n /// use std::io::util::TeeReader;\n-/// use std::io::{stdin, MemWriter};\n+/// use std::io::{stdin, MemWriter, AsRefWriter};\n ///\n /// let mut output = MemWriter::new();\n ///"}, {"sha": "37c7162333bfd941afd60f1818c1936fb38af8f6", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -89,11 +89,9 @@ impl Writer for WriterWrapper {\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stdout() as Box<Writer + Send>,\n-        });\n-    ti.map(|t| box t as Box<Terminal<WriterWrapper> + Send>)\n+    TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stdout() as Box<Writer + Send>,\n+    })\n }\n \n #[cfg(windows)]\n@@ -121,11 +119,9 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> {\n-    let ti: Option<TerminfoTerminal<WriterWrapper>>\n-        = Terminal::new(WriterWrapper {\n-            wrapped: box std::io::stderr() as Box<Writer + Send>,\n-        });\n-    ti.map(|t| box t as Box<Terminal<WriterWrapper> + Send>)\n+    TerminfoTerminal::new(WriterWrapper {\n+        wrapped: box std::io::stderr() as Box<Writer + Send>,\n+    })\n }\n \n #[cfg(windows)]\n@@ -208,10 +204,6 @@ pub mod attr {\n /// A terminal with similar capabilities to an ANSI Terminal\n /// (foreground/background colors etc).\n pub trait Terminal<T: Writer>: Writer {\n-    /// Returns `None` whenever the terminal cannot be created for some\n-    /// reason.\n-    fn new(out: T) -> Option<Self>;\n-\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n@@ -242,12 +234,15 @@ pub trait Terminal<T: Writer>: Writer {\n     /// Returns `Ok()`.\n     fn reset(&mut self) -> IoResult<()>;\n \n-    /// Returns the contained stream, destroying the `Terminal`\n-    fn unwrap(self) -> T;\n-\n     /// Gets an immutable reference to the stream inside\n     fn get_ref<'a>(&'a self) -> &'a T;\n \n     /// Gets a mutable reference to the stream inside\n     fn get_mut<'a>(&'a mut self) -> &'a mut T;\n }\n+\n+/// A terminal which can be unwrapped.\n+pub trait UnwrappableTerminal<T: Writer>: Terminal<T> {\n+    /// Returns the contained stream, destroying the `Terminal`\n+    fn unwrap(self) -> T;\n+}"}, {"sha": "73edcf948921687719cbf081923266081bb1553b", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d500cfd74c02b6f9f84a4e7387d8126c79f3f76/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=1d500cfd74c02b6f9f84a4e7387d8126c79f3f76", "patch": "@@ -17,6 +17,7 @@ use std::os;\n use attr;\n use color;\n use Terminal;\n+use UnwrappableTerminal;\n use self::searcher::open;\n use self::parser::compiled::{parse, msys_terminfo};\n use self::parm::{expand, Number, Variables};\n@@ -71,44 +72,7 @@ pub struct TerminfoTerminal<T> {\n     ti: Box<TermInfo>\n }\n \n-impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n-    fn new(out: T) -> Option<TerminfoTerminal<T>> {\n-        let term = match os::getenv(\"TERM\") {\n-            Some(t) => t,\n-            None => {\n-                debug!(\"TERM environment variable not defined\");\n-                return None;\n-            }\n-        };\n-\n-        let entry = open(term.as_slice());\n-        if entry.is_err() {\n-            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n-                    \"mintty.exe\" == s.as_slice()\n-                }) {\n-                // msys terminal\n-                return Some(TerminfoTerminal {out: out, ti: msys_terminfo(), num_colors: 8});\n-            }\n-            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n-            return None;\n-        }\n-\n-        let mut file = entry.unwrap();\n-        let ti = parse(&mut file, false);\n-        if ti.is_err() {\n-            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n-            return None;\n-        }\n-\n-        let inf = ti.unwrap();\n-        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n-                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n-                 } else { 0 };\n-\n-        return Some(TerminfoTerminal {out: out, ti: inf, num_colors: nc});\n-    }\n-\n+impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n     fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n@@ -195,14 +159,59 @@ impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n         Ok(())\n     }\n \n-    fn unwrap(self) -> T { self.out }\n-\n     fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n \n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n }\n \n-impl<T: Writer> TerminfoTerminal<T> {\n+impl<T: Writer+Send> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n+    fn unwrap(self) -> T { self.out }\n+}\n+\n+impl<T: Writer+Send> TerminfoTerminal<T> {\n+    /// Returns `None` whenever the terminal cannot be created for some\n+    /// reason.\n+    pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n+        let term = match os::getenv(\"TERM\") {\n+            Some(t) => t,\n+            None => {\n+                debug!(\"TERM environment variable not defined\");\n+                return None;\n+            }\n+        };\n+\n+        let entry = open(term.as_slice());\n+        if entry.is_err() {\n+            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n+                    \"mintty.exe\" == s.as_slice()\n+                }) {\n+                // msys terminal\n+                return Some(box TerminfoTerminal {out: out,\n+                                                  ti: msys_terminfo(),\n+                                                  num_colors: 8} as Box<Terminal<T>+Send>);\n+            }\n+            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n+            return None;\n+        }\n+\n+        let mut file = entry.unwrap();\n+        let ti = parse(&mut file, false);\n+        if ti.is_err() {\n+            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n+            return None;\n+        }\n+\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n+                 } else { 0 };\n+\n+        return Some(box TerminfoTerminal {out: out,\n+                                          ti: inf,\n+                                          num_colors: nc} as Box<Terminal<T>+Send>);\n+    }\n+\n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n         if color >= self.num_colors && color >= 8 && color < 16 {\n             color-8"}, {"sha": "6b000866d3ab942cb1cf5cd172151a8328d0996b", "filename": "src/test/run-fail/by-value-self-objects-fail.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs?ref=8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:explicit panic\n-\n-trait Foo {\n-    fn foo(self, x: int);\n-}\n-\n-struct S {\n-    x: int,\n-    y: int,\n-    z: int,\n-    s: String,\n-}\n-\n-impl Foo for S {\n-    fn foo(self, x: int) {\n-        panic!()\n-    }\n-}\n-\n-impl Drop for S {\n-    fn drop(&mut self) {\n-        println!(\"bye 1!\");\n-    }\n-}\n-\n-fn f() {\n-    let s = S {\n-        x: 2,\n-        y: 3,\n-        z: 4,\n-        s: \"hello\".to_string(),\n-    };\n-    let st = box s as Box<Foo>;\n-    st.foo(5);\n-}\n-\n-fn main() {\n-    f();\n-}\n-\n-"}]}