{"sha": "88665133b709928a88efed760d1219f2d821aea2", "node_id": "C_kwDOAAsO6NoAKDg4NjY1MTMzYjcwOTkyOGE4OGVmZWQ3NjBkMTIxOWYyZDgyMWFlYTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T13:20:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T13:20:54Z"}, "message": "Auto merge of #2512 - cbeuw:scfix, r=RalfJung\n\nStrengthen C++20 SC accesses\n\n`@SabrinaJewson` noted in #2301 that Miri could produce behaviours forbidden under C++20 even without SC fences. Due to the added coherence-ordered before relationship which is created from read from and read before, plus the fact that coherence-ordered before between SC operations must be consistent with the Global Total Order S, in C++20 if there's an SC load that reads from any store, then a later SC load cannot read before that store. This PR adds this restriction", "tree": {"sha": "8459f5baf304e7e693956c130916b21d5a24ebbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8459f5baf304e7e693956c130916b21d5a24ebbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88665133b709928a88efed760d1219f2d821aea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88665133b709928a88efed760d1219f2d821aea2", "html_url": "https://github.com/rust-lang/rust/commit/88665133b709928a88efed760d1219f2d821aea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88665133b709928a88efed760d1219f2d821aea2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d99abac0532a3707b3cbf84b43b6c49442ec38", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d99abac0532a3707b3cbf84b43b6c49442ec38", "html_url": "https://github.com/rust-lang/rust/commit/74d99abac0532a3707b3cbf84b43b6c49442ec38"}, {"sha": "3e97d8e65ffc1dc6a9c342888de61146b452a1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e97d8e65ffc1dc6a9c342888de61146b452a1fd", "html_url": "https://github.com/rust-lang/rust/commit/3e97d8e65ffc1dc6a9c342888de61146b452a1fd"}], "stats": {"total": 127, "additions": 98, "deletions": 29}, "files": [{"sha": "0e579a38af85ea2c4c00e634433884d40d5888f1", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 68, "deletions": 29, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/88665133b709928a88efed760d1219f2d821aea2/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88665133b709928a88efed760d1219f2d821aea2/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=88665133b709928a88efed760d1219f2d821aea2", "patch": "@@ -6,11 +6,16 @@\n //! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n //! certain weak behaviours observable on real hardware but not while using this.\n //!\n-//! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n+//! Note that this implementation does not fully take into account of C++20's memory model revision to SC accesses\n //! and fences introduced by P0668 (<https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html>).\n //! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n //! disallows (<https://github.com/rust-lang/miri/issues/2301>).\n //!\n+//! A modification is made to the paper's model to partially address C++20 changes.\n+//! Specifically, if an SC load reads from an atomic store of any ordering, then a later SC load cannot read from\n+//! an earlier store in the location's modification order. This is to prevent creating a backwards S edge from the second\n+//! load to the first, as a result of C++20's coherence-ordered before rules.\n+//!\n //! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n //! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n //! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n@@ -133,9 +138,17 @@ struct StoreElement {\n     // (partially) uninitialized data.\n     val: Scalar<Provenance>,\n \n+    /// Metadata about loads from this store element,\n+    /// behind a RefCell to keep load op take &self\n+    load_info: RefCell<LoadInfo>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+struct LoadInfo {\n     /// Timestamp of first loads from this store element by each thread\n-    /// Behind a RefCell to keep load op take &self\n-    loads: RefCell<FxHashMap<VectorIdx, VTimestamp>>,\n+    timestamps: FxHashMap<VectorIdx, VTimestamp>,\n+    /// Whether this store element has been read by an SC load\n+    sc_loaded: bool,\n }\n \n impl StoreBufferAlloc {\n@@ -235,18 +248,23 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             timestamp: 0,\n             val: init,\n             is_seqcst: false,\n-            loads: RefCell::new(FxHashMap::default()),\n+            load_info: RefCell::new(LoadInfo::default()),\n         };\n         ret.buffer.push_back(store_elem);\n         ret\n     }\n \n     /// Reads from the last store in modification order\n-    fn read_from_last_store(&self, global: &DataRaceState, thread_mgr: &ThreadManager<'_, '_>) {\n+    fn read_from_last_store(\n+        &self,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        is_seqcst: bool,\n+    ) {\n         let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n             let (index, clocks) = global.current_thread_state(thread_mgr);\n-            store_elem.load_impl(index, &clocks);\n+            store_elem.load_impl(index, &clocks, is_seqcst);\n         }\n     }\n \n@@ -276,7 +294,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         validate()?;\n \n         let (index, clocks) = global.current_thread_state(thread_mgr);\n-        let loaded = store_elem.load_impl(index, &clocks);\n+        let loaded = store_elem.load_impl(index, &clocks, is_seqcst);\n         Ok((loaded, recency))\n     }\n \n@@ -293,6 +311,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         Ok(())\n     }\n \n+    #[allow(clippy::if_same_then_else, clippy::needless_bool)]\n     /// Selects a valid store element in the buffer.\n     fn fetch_store<R: rand::Rng + ?Sized>(\n         &self,\n@@ -319,34 +338,43 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                 keep_searching = if store_elem.timestamp <= clocks.clock[store_elem.store_index] {\n                     // CoWR: if a store happens-before the current load,\n                     // then we can't read-from anything earlier in modification order.\n-                    log::info!(\"Stopping due to coherent write-read\");\n+                    // C++20 \u00a76.9.2.2 [intro.races] paragraph 18\n                     false\n-                } else if store_elem.loads.borrow().iter().any(|(&load_index, &load_timestamp)| {\n-                    load_timestamp <= clocks.clock[load_index]\n-                }) {\n+                } else if store_elem.load_info.borrow().timestamps.iter().any(\n+                    |(&load_index, &load_timestamp)| load_timestamp <= clocks.clock[load_index],\n+                ) {\n                     // CoRR: if there was a load from this store which happened-before the current load,\n                     // then we cannot read-from anything earlier in modification order.\n-                    log::info!(\"Stopping due to coherent read-read\");\n+                    // C++20 \u00a76.9.2.2 [intro.races] paragraph 16\n                     false\n                 } else if store_elem.timestamp <= clocks.fence_seqcst[store_elem.store_index] {\n-                    // The current load, which may be sequenced-after an SC fence, can only read-from\n-                    // the last store sequenced-before an SC fence in another thread (or any stores\n-                    // later than that SC fence)\n-                    log::info!(\"Stopping due to coherent load sequenced after sc fence\");\n+                    // The current load, which may be sequenced-after an SC fence, cannot read-before\n+                    // the last store sequenced-before an SC fence in another thread.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 6\n                     false\n                 } else if store_elem.timestamp <= clocks.write_seqcst[store_elem.store_index]\n                     && store_elem.is_seqcst\n                 {\n-                    // The current non-SC load can only read-from the latest SC store (or any stores later than that\n-                    // SC store)\n-                    log::info!(\"Stopping due to needing to load from the last SC store\");\n+                    // The current non-SC load, which may be sequenced-after an SC fence,\n+                    // cannot read-before the last SC store executed before the fence.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 4\n+                    false\n+                } else if is_seqcst\n+                    && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index]\n+                {\n+                    // The current SC load cannot read-before the last store sequenced-before\n+                    // the last SC fence.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 5\n                     false\n-                } else if is_seqcst && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index] {\n-                    // The current SC load can only read-from the last store sequenced-before\n-                    // the last SC fence (or any stores later than the SC fence)\n-                    log::info!(\"Stopping due to sc load needing to load from the last SC store before an SC fence\");\n+                } else if is_seqcst && store_elem.load_info.borrow().sc_loaded {\n+                    // The current SC load cannot read-before a store that an earlier SC load has observed.\n+                    // See https://github.com/rust-lang/miri/issues/2301#issuecomment-1222720427\n+                    // Consequences of C++20 \u00a731.4 [atomics.order] paragraph 3.1, 3.3 (coherence-ordered before)\n+                    // and 4.1 (coherence-ordered before between SC makes global total order S)\n                     false\n-                } else {true};\n+                } else {\n+                    true\n+                };\n \n                 true\n             })\n@@ -387,7 +415,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             // access\n             val,\n             is_seqcst,\n-            loads: RefCell::new(FxHashMap::default()),\n+            load_info: RefCell::new(LoadInfo::default()),\n         };\n         self.buffer.push_back(store_elem);\n         if self.buffer.len() > STORE_BUFFER_LIMIT {\n@@ -415,8 +443,15 @@ impl StoreElement {\n     /// buffer regardless of subsequent loads by the same thread; if the earliest load of another\n     /// thread doesn't happen before the current one, then no subsequent load by the other thread\n     /// can happen before the current one.\n-    fn load_impl(&self, index: VectorIdx, clocks: &ThreadClockSet) -> Scalar<Provenance> {\n-        let _ = self.loads.borrow_mut().try_insert(index, clocks.clock[index]);\n+    fn load_impl(\n+        &self,\n+        index: VectorIdx,\n+        clocks: &ThreadClockSet,\n+        is_seqcst: bool,\n+    ) -> Scalar<Provenance> {\n+        let mut load_info = self.load_info.borrow_mut();\n+        load_info.sc_loaded |= is_seqcst;\n+        let _ = load_info.timestamps.try_insert(index, clocks.clock[index]);\n         self.val\n     }\n }\n@@ -476,7 +511,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n             let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n-            buffer.read_from_last_store(global, threads);\n+            buffer.read_from_last_store(global, threads, atomic == AtomicRwOrd::SeqCst);\n             buffer.buffered_write(new_val, global, threads, atomic == AtomicRwOrd::SeqCst)?;\n         }\n         Ok(())\n@@ -583,7 +618,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                 let buffer = alloc_buffers\n                     .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n-                buffer.read_from_last_store(global, &this.machine.threads);\n+                buffer.read_from_last_store(\n+                    global,\n+                    &this.machine.threads,\n+                    atomic == AtomicReadOrd::SeqCst,\n+                );\n             }\n         }\n         Ok(())"}, {"sha": "f3820bd660d28055745b197f00cbbb70b6b0386d", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88665133b709928a88efed760d1219f2d821aea2/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88665133b709928a88efed760d1219f2d821aea2/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=88665133b709928a88efed760d1219f2d821aea2", "patch": "@@ -257,6 +257,35 @@ fn test_sync_through_rmw_and_fences() {\n     assert_ne!((a, b), (0, 0));\n }\n \n+// Test case by @SabrinaJewson\n+// https://github.com/rust-lang/miri/issues/2301#issuecomment-1221502757\n+// Demonstrating C++20 SC access changes\n+fn test_iriw_sc_rlx() {\n+    let x = static_atomic_bool(false);\n+    let y = static_atomic_bool(false);\n+\n+    x.store(false, Relaxed);\n+    y.store(false, Relaxed);\n+\n+    let a = spawn(move || x.store(true, Relaxed));\n+    let b = spawn(move || y.store(true, Relaxed));\n+    let c = spawn(move || {\n+        while !x.load(SeqCst) {}\n+        y.load(SeqCst)\n+    });\n+    let d = spawn(move || {\n+        while !y.load(SeqCst) {}\n+        x.load(SeqCst)\n+    });\n+\n+    a.join().unwrap();\n+    b.join().unwrap();\n+    let c = c.join().unwrap();\n+    let d = d.join().unwrap();\n+\n+    assert!(c || d);\n+}\n+\n pub fn main() {\n     for _ in 0..50 {\n         test_single_thread();\n@@ -267,5 +296,6 @@ pub fn main() {\n         test_corr();\n         test_sc_store_buffering();\n         test_sync_through_rmw_and_fences();\n+        test_iriw_sc_rlx();\n     }\n }"}]}