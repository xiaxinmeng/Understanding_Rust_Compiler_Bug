{"sha": "10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "node_id": "C_kwDOAAsO6NoAKDEwZGNjZGM3ZmNiZGM2NGVlOWVmZTJjMWVkOTc1YWI4YzFkNjEyODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-09T08:58:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-09T08:58:47Z"}, "message": "Auto merge of #94515 - estebank:tweak-move-error, r=davidtwco\n\nTweak move error\n\nPoint at method definition that causes type to be consumed.\n\nFix #94056.", "tree": {"sha": "ac3a8cd3110ee50a3b957ef43085a344c92a7027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac3a8cd3110ee50a3b957ef43085a344c92a7027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "html_url": "https://github.com/rust-lang/rust/commit/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6045c34f15d463c7d51104b968c1eabc5275b9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6045c34f15d463c7d51104b968c1eabc5275b9c1", "html_url": "https://github.com/rust-lang/rust/commit/6045c34f15d463c7d51104b968c1eabc5275b9c1"}, {"sha": "98752776b853cad6fc99f51d91f7fdd797490a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/98752776b853cad6fc99f51d91f7fdd797490a8d", "html_url": "https://github.com/rust-lang/rust/commit/98752776b853cad6fc99f51d91f7fdd797490a8d"}], "stats": {"total": 531, "additions": 289, "deletions": 242}, "files": [{"sha": "1cbca58ca2590f3ed28ae1d1088efb0984533f4c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 15, "deletions": 140, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use rustc_const_eval::util::{CallDesugaringKind, CallKind};\n+use rustc_const_eval::util::CallKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -17,7 +17,7 @@ use rustc_middle::ty::{\n };\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n-use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n@@ -195,144 +195,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     is_loop_move = true;\n                 }\n \n-                if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n-                    let place_name = self\n-                        .describe_place(moved_place.as_ref())\n-                        .map(|n| format!(\"`{}`\", n))\n-                        .unwrap_or_else(|| \"value\".to_owned());\n-                    match kind {\n-                        CallKind::FnCall { fn_trait_id, .. }\n-                            if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n-                        {\n-                            err.span_label(\n-                                fn_call_span,\n-                                &format!(\n-                                    \"{} {}moved due to this call{}\",\n-                                    place_name, partially_str, loop_message\n-                                ),\n-                            );\n-                            err.span_note(\n-                                var_span,\n-                                \"this value implements `FnOnce`, which causes it to be moved when called\",\n-                            );\n-                        }\n-                        CallKind::Operator { self_arg, .. } => {\n-                            let self_arg = self_arg.unwrap();\n-                            err.span_label(\n-                                fn_call_span,\n-                                &format!(\n-                                    \"{} {}moved due to usage in operator{}\",\n-                                    place_name, partially_str, loop_message\n-                                ),\n-                            );\n-                            if self.fn_self_span_reported.insert(fn_span) {\n-                                err.span_note(\n-                                    // Check whether the source is accessible\n-                                    if self\n-                                        .infcx\n-                                        .tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_to_snippet(self_arg.span)\n-                                        .is_ok()\n-                                    {\n-                                        self_arg.span\n-                                    } else {\n-                                        fn_call_span\n-                                    },\n-                                    \"calling this operator moves the left-hand side\",\n-                                );\n-                            }\n-                        }\n-                        CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n-                            let self_arg = self_arg.unwrap();\n-                            if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n-                                err.span_label(\n-                                    fn_call_span,\n-                                    &format!(\n-                                        \"{} {}moved due to this implicit call to `.into_iter()`{}\",\n-                                        place_name, partially_str, loop_message\n-                                    ),\n-                                );\n-                                let sess = self.infcx.tcx.sess;\n-                                let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n-                                // If we have a `&mut` ref, we need to reborrow.\n-                                if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind() {\n-                                    // If we are in a loop this will be suggested later.\n-                                    if !is_loop_move {\n-                                        err.span_suggestion_verbose(\n-                                            move_span.shrink_to_lo(),\n-                                            &format!(\n-                                                \"consider creating a fresh reborrow of {} here\",\n-                                                self.describe_place(moved_place.as_ref())\n-                                                    .map(|n| format!(\"`{}`\", n))\n-                                                    .unwrap_or_else(\n-                                                        || \"the mutable reference\".to_string()\n-                                                    ),\n-                                            ),\n-                                            \"&mut *\".to_string(),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                } else if let Ok(snippet) =\n-                                    sess.source_map().span_to_snippet(move_span)\n-                                {\n-                                    err.span_suggestion(\n-                                        move_span,\n-                                        \"consider borrowing to avoid moving into the for loop\",\n-                                        format!(\"&{}\", snippet),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            } else {\n-                                err.span_label(\n-                                    fn_call_span,\n-                                    &format!(\n-                                        \"{} {}moved due to this method call{}\",\n-                                        place_name, partially_str, loop_message\n-                                    ),\n-                                );\n-                            }\n-                            if is_option_or_result && maybe_reinitialized_locations.is_empty() {\n-                                err.span_suggestion_verbose(\n-                                    fn_call_span.shrink_to_lo(),\n-                                    \"consider calling `.as_ref()` to borrow the type's contents\",\n-                                    \"as_ref().\".to_string(),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            // Avoid pointing to the same function in multiple different\n-                            // error messages.\n-                            if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span)\n-                            {\n-                                err.span_note(\n-                                        self_arg.span,\n-                                        &format!(\"this function takes ownership of the receiver `self`, which moves {}\", place_name)\n-                                    );\n-                            }\n-                        }\n-                        // Other desugarings takes &self, which cannot cause a move\n-                        _ => unreachable!(),\n-                    }\n-                } else {\n-                    err.span_label(\n-                        move_span,\n-                        format!(\"value {}moved{} here{}\", partially_str, move_msg, loop_message),\n-                    );\n-                    // If the move error occurs due to a loop, don't show\n-                    // another message for the same span\n-                    if loop_message.is_empty() {\n-                        move_spans.var_span_label(\n-                            &mut err,\n-                            format!(\n-                                \"variable {}moved due to use{}\",\n-                                partially_str,\n-                                move_spans.describe()\n-                            ),\n-                            \"moved\",\n-                        );\n-                    }\n-                }\n+                self.explain_captures(\n+                    &mut err,\n+                    span,\n+                    move_span,\n+                    move_spans,\n+                    *moved_place,\n+                    Some(used_place),\n+                    partially_str,\n+                    loop_message,\n+                    move_msg,\n+                    is_loop_move,\n+                    maybe_reinitialized_locations.is_empty(),\n+                );\n \n                 if let (UseSpans::PatUse(span), []) =\n                     (move_spans, &maybe_reinitialized_locations[..])"}, {"sha": "164ebfed0f7959306de31dc8a6f2373d4502701f", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 174, "deletions": 5, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -1,20 +1,22 @@\n //! Borrow checker diagnostics.\n \n-use rustc_const_eval::util::call_kind;\n-use rustc_errors::Diagnostic;\n+use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GeneratorKind;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n     Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n+use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -482,9 +484,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             BorrowedContentSource::DerefSharedRef\n         }\n     }\n-}\n \n-impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n     pub(super) fn get_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n@@ -995,4 +995,173 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }\n+\n+    fn explain_captures(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        move_span: Span,\n+        move_spans: UseSpans<'tcx>,\n+        moved_place: Place<'tcx>,\n+        used_place: Option<PlaceRef<'tcx>>,\n+        partially_str: &str,\n+        loop_message: &str,\n+        move_msg: &str,\n+        is_loop_move: bool,\n+        maybe_reinitialized_locations_is_empty: bool,\n+    ) {\n+        if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n+            let place_name = self\n+                .describe_place(moved_place.as_ref())\n+                .map(|n| format!(\"`{}`\", n))\n+                .unwrap_or_else(|| \"value\".to_owned());\n+            match kind {\n+                CallKind::FnCall { fn_trait_id, .. }\n+                    if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n+                {\n+                    err.span_label(\n+                        fn_call_span,\n+                        &format!(\n+                            \"{} {}moved due to this call{}\",\n+                            place_name, partially_str, loop_message\n+                        ),\n+                    );\n+                    err.span_note(\n+                        var_span,\n+                        \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                    );\n+                }\n+                CallKind::Operator { self_arg, .. } => {\n+                    let self_arg = self_arg.unwrap();\n+                    err.span_label(\n+                        fn_call_span,\n+                        &format!(\n+                            \"{} {}moved due to usage in operator{}\",\n+                            place_name, partially_str, loop_message\n+                        ),\n+                    );\n+                    if self.fn_self_span_reported.insert(fn_span) {\n+                        err.span_note(\n+                            // Check whether the source is accessible\n+                            if self\n+                                .infcx\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .span_to_snippet(self_arg.span)\n+                                .is_ok()\n+                            {\n+                                self_arg.span\n+                            } else {\n+                                fn_call_span\n+                            },\n+                            \"calling this operator moves the left-hand side\",\n+                        );\n+                    }\n+                }\n+                CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                    let self_arg = self_arg.unwrap();\n+                    if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n+                        let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n+                        let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n+                            Some(def_id) => self.infcx.tcx.infer_ctxt().enter(|infcx| {\n+                                type_known_to_meet_bound_modulo_regions(\n+                                    &infcx,\n+                                    self.param_env,\n+                                    infcx.tcx.mk_imm_ref(\n+                                        infcx.tcx.lifetimes.re_erased,\n+                                        infcx.tcx.erase_regions(ty),\n+                                    ),\n+                                    def_id,\n+                                    DUMMY_SP,\n+                                )\n+                            }),\n+                            _ => false,\n+                        };\n+                        if suggest {\n+                            err.span_suggestion_verbose(\n+                                move_span.shrink_to_lo(),\n+                                &format!(\n+                                    \"consider iterating over a slice of the `{}`'s content to \\\n+                                     avoid moving into the `for` loop\",\n+                                    ty,\n+                                ),\n+                                \"&\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+\n+                        err.span_label(\n+                            fn_call_span,\n+                            &format!(\n+                                \"{} {}moved due to this implicit call to `.into_iter()`{}\",\n+                                place_name, partially_str, loop_message\n+                            ),\n+                        );\n+                        // If we have a `&mut` ref, we need to reborrow.\n+                        if let Some(ty::Ref(_, _, hir::Mutability::Mut)) = used_place\n+                            .map(|used_place| used_place.ty(self.body, self.infcx.tcx).ty.kind())\n+                        {\n+                            // If we are in a loop this will be suggested later.\n+                            if !is_loop_move {\n+                                err.span_suggestion_verbose(\n+                                    move_span.shrink_to_lo(),\n+                                    &format!(\n+                                        \"consider creating a fresh reborrow of {} here\",\n+                                        self.describe_place(moved_place.as_ref())\n+                                            .map(|n| format!(\"`{}`\", n))\n+                                            .unwrap_or_else(|| \"the mutable reference\".to_string()),\n+                                    ),\n+                                    \"&mut *\".to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(\n+                            fn_call_span,\n+                            &format!(\n+                                \"{} {}moved due to this method call{}\",\n+                                place_name, partially_str, loop_message\n+                            ),\n+                        );\n+                    }\n+                    if is_option_or_result && maybe_reinitialized_locations_is_empty {\n+                        err.span_suggestion_verbose(\n+                            fn_call_span.shrink_to_lo(),\n+                            \"consider calling `.as_ref()` to borrow the type's contents\",\n+                            \"as_ref().\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    // Avoid pointing to the same function in multiple different\n+                    // error messages.\n+                    if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n+                        err.span_note(\n+                            self_arg.span,\n+                            &format!(\"this function takes ownership of the receiver `self`, which moves {}\", place_name)\n+                        );\n+                    }\n+                }\n+                // Other desugarings takes &self, which cannot cause a move\n+                _ => {}\n+            }\n+        } else {\n+            if move_span != span || !loop_message.is_empty() {\n+                err.span_label(\n+                    move_span,\n+                    format!(\"value {}moved{} here{}\", partially_str, move_msg, loop_message),\n+                );\n+            }\n+            // If the move error occurs due to a loop, don't show\n+            // another message for the same span\n+            if loop_message.is_empty() {\n+                move_spans.var_span_label(\n+                    err,\n+                    format!(\"variable {}moved due to use{}\", partially_str, move_spans.describe()),\n+                    \"moved\",\n+                );\n+            }\n+        }\n+    }\n }"}, {"sha": "f76ec031aa9e258e6dc5b8ae35a826d050596d1a", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -1,15 +1,12 @@\n-use rustc_const_eval::util::CallDesugaringKind;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty;\n use rustc_mir_dataflow::move_paths::{\n     IllegalMoveOrigin, IllegalMoveOriginKind, LookupResult, MoveError, MovePathIndex,\n };\n-use rustc_span::{sym, Span, DUMMY_SP};\n-use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n+use rustc_span::{sym, Span};\n \n-use crate::diagnostics::{CallKind, UseSpans};\n+use crate::diagnostics::UseSpans;\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n \n@@ -409,34 +406,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 \".as_ref()\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n-        } else if let Some(UseSpans::FnSelfUse {\n-            kind:\n-                CallKind::Normal { desugaring: Some((CallDesugaringKind::ForLoopIntoIter, _)), .. },\n-            ..\n-        }) = use_spans\n-        {\n-            let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n-                Some(def_id) => self.infcx.tcx.infer_ctxt().enter(|infcx| {\n-                    type_known_to_meet_bound_modulo_regions(\n-                        &infcx,\n-                        self.param_env,\n-                        infcx\n-                            .tcx\n-                            .mk_imm_ref(infcx.tcx.lifetimes.re_erased, infcx.tcx.erase_regions(ty)),\n-                        def_id,\n-                        DUMMY_SP,\n-                    )\n-                }),\n-                _ => false,\n-            };\n-            if suggest {\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_lo(),\n-                    &format!(\"consider iterating over a slice of the `{}`'s content\", ty),\n-                    \"&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+        } else if let Some(use_spans) = use_spans {\n+            self.explain_captures(\n+                &mut err, span, span, use_spans, move_place, None, \"\", \"\", \"\", false, true,\n+            );\n         }\n         err\n     }\n@@ -491,11 +464,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n \n                 use_spans.args_span_label(err, format!(\"move out of {} occurs here\", place_desc));\n-                use_spans.var_span_label(\n-                    err,\n-                    format!(\"move occurs due to use{}\", use_spans.describe()),\n-                    \"moved\",\n-                );\n             }\n         }\n     }"}, {"sha": "d88185af778f16b75b31488f5b45bf67488b4ee8", "filename": "src/test/ui/borrowck/borrowck-feature-nll-overrides-migrate.edition.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.edition.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,10 +2,8 @@ error[E0507]: cannot move out of `foo` in pattern guard\n   --> $DIR/borrowck-feature-nll-overrides-migrate.rs:22:18\n    |\n LL |                 (|| { let bar = foo; bar.take() })();\n-   |                  ^^             ---\n-   |                  |              |\n-   |                  |              move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n-   |                  |              move occurs due to use in closure\n+   |                  ^^             --- move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n+   |                  |\n    |                  move out of `foo` occurs here\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard"}, {"sha": "d88185af778f16b75b31488f5b45bf67488b4ee8", "filename": "src/test/ui/borrowck/borrowck-feature-nll-overrides-migrate.zflag.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.zflag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.zflag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-feature-nll-overrides-migrate.zflag.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,10 +2,8 @@ error[E0507]: cannot move out of `foo` in pattern guard\n   --> $DIR/borrowck-feature-nll-overrides-migrate.rs:22:18\n    |\n LL |                 (|| { let bar = foo; bar.take() })();\n-   |                  ^^             ---\n-   |                  |              |\n-   |                  |              move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n-   |                  |              move occurs due to use in closure\n+   |                  ^^             --- move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n+   |                  |\n    |                  move out of `foo` occurs here\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard"}, {"sha": "f81b34a641bf081c1121ea189dcdd929e2a2b626", "filename": "src/test/ui/borrowck/borrowck-move-by-capture.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-by-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-by-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-by-capture.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -8,8 +8,8 @@ LL |       let _g = to_fn_mut(|| {\n LL | |         let _h = to_fn_once(move || -> isize { *bar });\n    | |                             ^^^^^^^^^^^^^^^^   ----\n    | |                             |                  |\n+   | |                             |                  variable moved due to use in closure\n    | |                             |                  move occurs because `bar` has type `Box<isize>`, which does not implement the `Copy` trait\n-   | |                             |                  move occurs due to use in closure\n    | |                             move out of `bar` occurs here\n LL | |     });\n    | |_____- captured by this `FnMut` closure"}, {"sha": "800f30b34e58921dd71977b9d9c753562928429a", "filename": "src/test/ui/borrowck/borrowck-move-out-of-overloaded-auto-deref.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,7 +2,16 @@ error[E0507]: cannot move out of an `Rc`\n   --> $DIR/borrowck-move-out-of-overloaded-auto-deref.rs:4:14\n    |\n LL |     let _x = Rc::new(vec![1, 2]).into_iter();\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `Vec<i32>`, which does not implement the `Copy` trait\n+   |              ^^^^^^^^^^^^^^^^^^^^-----------\n+   |              |                   |\n+   |              |                   value moved due to this method call\n+   |              move occurs because value has type `Vec<i32>`, which does not implement the `Copy` trait\n+   |\n+note: this function takes ownership of the receiver `self`, which moves value\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c4ce7e62fda82bc24bb45d8b3f90b7afb8f9664b", "filename": "src/test/ui/borrowck/issue-27282-mutation-in-guard.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fissue-27282-mutation-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Fissue-27282-mutation-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-27282-mutation-in-guard.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,10 +2,8 @@ error[E0507]: cannot move out of `foo` in pattern guard\n   --> $DIR/issue-27282-mutation-in-guard.rs:6:18\n    |\n LL |                 (|| { let bar = foo; bar.take() })();\n-   |                  ^^             ---\n-   |                  |              |\n-   |                  |              move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n-   |                  |              move occurs due to use in closure\n+   |                  ^^             --- move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n+   |                  |\n    |                  move out of `foo` occurs here\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard"}, {"sha": "3ea7226200362c77be54afd1e5b56fd1f584691b", "filename": "src/test/ui/borrowck/unboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -6,10 +6,18 @@ LL |       let y = vec![format!(\"World\")];\n LL |       call(|| {\n    |  __________-\n LL | |         y.into_iter();\n-   | |         ^ move occurs because `y` has type `Vec<String>`, which does not implement the `Copy` trait\n+   | |         ^ ----------- `y` moved due to this method call\n+   | |         |\n+   | |         move occurs because `y` has type `Vec<String>`, which does not implement the `Copy` trait\n LL | |\n LL | |     });\n    | |_____- captured by this `Fn` closure\n+   |\n+note: this function takes ownership of the receiver `self`, which moves `y`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ce8d1ef03493c277c960ec783ee3da0f1e1d2697", "filename": "src/test/ui/error-codes/E0507.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,7 +2,16 @@ error[E0507]: cannot move out of dereference of `Ref<'_, TheDarkKnight>`\n   --> $DIR/E0507.rs:12:5\n    |\n LL |     x.borrow().nothing_is_true();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `TheDarkKnight`, which does not implement the `Copy` trait\n+   |     ^^^^^^^^^^^-----------------\n+   |     |          |\n+   |     |          value moved due to this method call\n+   |     move occurs because value has type `TheDarkKnight`, which does not implement the `Copy` trait\n+   |\n+note: this function takes ownership of the receiver `self`, which moves value\n+  --> $DIR/E0507.rs:6:24\n+   |\n+LL |     fn nothing_is_true(self) {}\n+   |                        ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a0d32616f83b74f2dad691636171476b1d40cc59", "filename": "src/test/ui/issues/issue-27282-move-ref-mut-into-guard.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-ref-mut-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-ref-mut-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-ref-mut-into-guard.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,10 +2,8 @@ error[E0507]: cannot move out of `foo` in pattern guard\n   --> $DIR/issue-27282-move-ref-mut-into-guard.rs:9:19\n    |\n LL |             if { (|| { let bar = foo; bar.take() })(); false } => {},\n-   |                   ^^             ---\n-   |                   |              |\n-   |                   |              move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n-   |                   |              move occurs due to use in closure\n+   |                   ^^             --- move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n+   |                   |\n    |                   move out of `foo` occurs here\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard"}, {"sha": "e5b671d7b7ab0b71bbf6e871864094dd35c6ed2a", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -4,10 +4,7 @@ error[E0382]: borrow of moved value: `bad_letters`\n LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n    |         --------------- move occurs because `bad_letters` has type `Vec<char>`, which does not implement the `Copy` trait\n LL |     for l in bad_letters {\n-   |              -----------\n-   |              |\n-   |              `bad_letters` moved due to this implicit call to `.into_iter()`\n-   |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n+   |              ----------- `bad_letters` moved due to this implicit call to `.into_iter()`\n ...\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n@@ -17,6 +14,10 @@ note: this function takes ownership of the receiver `self`, which moves `bad_let\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider iterating over a slice of the `Vec<char>`'s content to avoid moving into the `for` loop\n+   |\n+LL |     for l in &bad_letters {\n+   |              +\n \n error: aborting due to previous error\n "}, {"sha": "ef178bbd155388f94e8b832d5c48c2a6bb65ade4", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -4,10 +4,7 @@ error[E0382]: use of moved value: `orig`\n LL |     let orig = vec![true];\n    |         ---- move occurs because `orig` has type `Vec<bool>`, which does not implement the `Copy` trait\n LL |     for _val in orig {}\n-   |                 ----\n-   |                 |\n-   |                 `orig` moved due to this implicit call to `.into_iter()`\n-   |                 help: consider borrowing to avoid moving into the for loop: `&orig`\n+   |                 ---- `orig` moved due to this implicit call to `.into_iter()`\n LL |     let _closure = || orig;\n    |                    ^^ ---- use occurs due to use in closure\n    |                    |\n@@ -18,6 +15,10 @@ note: this function takes ownership of the receiver `self`, which moves `orig`\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider iterating over a slice of the `Vec<bool>`'s content to avoid moving into the `for` loop\n+   |\n+LL |     for _val in &orig {}\n+   |                 +\n \n error: aborting due to previous error\n "}, {"sha": "57d76016c4539d3e8ff8f0623af847d73ae30a08", "filename": "src/test/ui/loops/issue-82916.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -4,10 +4,7 @@ error[E0382]: use of moved value: `x`\n LL | fn foo(x: Vec<S>) {\n    |        - move occurs because `x` has type `Vec<S>`, which does not implement the `Copy` trait\n LL |     for y in x {\n-   |              -\n-   |              |\n-   |              `x` moved due to this implicit call to `.into_iter()`\n-   |              help: consider borrowing to avoid moving into the for loop: `&x`\n+   |              - `x` moved due to this implicit call to `.into_iter()`\n ...\n LL |     let z = x;\n    |             ^ value used here after move\n@@ -17,6 +14,10 @@ note: this function takes ownership of the receiver `self`, which moves `x`\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider iterating over a slice of the `Vec<S>`'s content to avoid moving into the `for` loop\n+   |\n+LL |     for y in &x {\n+   |              +\n \n error: aborting due to previous error\n "}, {"sha": "baa87e3e9fdb2111f386b81cfa0ba958d7bb4d80", "filename": "src/test/ui/moves/issue-46099-move-in-macro.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-46099-move-in-macro.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -4,10 +4,7 @@ error[E0382]: use of moved value: `b`\n LL |     let b = Box::new(true);\n    |         - move occurs because `b` has type `Box<bool>`, which does not implement the `Copy` trait\n LL |     test!({b});\n-   |            ^\n-   |            |\n-   |            value moved here\n-   |            value used here after move\n+   |            ^ value used here after move\n \n error: aborting due to previous error\n "}, {"sha": "3a686121a9283c802073af9bd935eab1e72c76db", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -119,12 +119,14 @@ error[E0382]: use of moved value: `implicit_into_iter`\n LL |     let implicit_into_iter = vec![true];\n    |         ------------------ move occurs because `implicit_into_iter` has type `Vec<bool>`, which does not implement the `Copy` trait\n LL |     for _val in implicit_into_iter {}\n-   |                 ------------------\n-   |                 |\n-   |                 `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n-   |                 help: consider borrowing to avoid moving into the for loop: `&implicit_into_iter`\n+   |                 ------------------ `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n LL |     implicit_into_iter;\n    |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+   |\n+help: consider iterating over a slice of the `Vec<bool>`'s content to avoid moving into the `for` loop\n+   |\n+LL |     for _val in &implicit_into_iter {}\n+   |                 +\n \n error[E0382]: use of moved value: `explicit_into_iter`\n   --> $DIR/move-fn-self-receiver.rs:67:5"}, {"sha": "8d636c11b78c7bd25500a5dfa364b9c6a4aaea2b", "filename": "src/test/ui/moves/move-in-guard-2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -5,10 +5,7 @@ LL |     let x: Box<_> = Box::new(1);\n    |         - move occurs because `x` has type `Box<i32>`, which does not implement the `Copy` trait\n ...\n LL |         (_, 2) if take(x) => (),\n-   |                        ^\n-   |                        |\n-   |                        value moved here\n-   |                        value used here after move\n+   |                        ^ value used here after move\n \n error: aborting due to previous error\n "}, {"sha": "c0fb5f65382dce4eccdd3be95cecabd71085d28b", "filename": "src/test/ui/nll/match-guards-always-borrow.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-always-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-always-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-always-borrow.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,10 +2,8 @@ error[E0507]: cannot move out of `foo` in pattern guard\n   --> $DIR/match-guards-always-borrow.rs:8:14\n    |\n LL |             (|| { let bar = foo; bar.take() })();\n-   |              ^^             ---\n-   |              |              |\n-   |              |              move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n-   |              |              move occurs due to use in closure\n+   |              ^^             --- move occurs because `foo` has type `&mut Option<&i32>`, which does not implement the `Copy` trait\n+   |              |\n    |              move out of `foo` occurs here\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard"}, {"sha": "1059e3d1525aa779fc659c3ad4dbb991fe0f376e", "filename": "src/test/ui/suggestions/borrow-for-loop-head.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -13,16 +13,17 @@ LL |     let a = vec![1, 2, 3];\n    |         - move occurs because `a` has type `Vec<i32>`, which does not implement the `Copy` trait\n LL |     for i in &a {\n LL |         for j in a {\n-   |                  ^\n-   |                  |\n-   |                  `a` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n-   |                  help: consider borrowing to avoid moving into the for loop: `&a`\n+   |                  ^ `a` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n note: this function takes ownership of the receiver `self`, which moves `a`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n    |\n LL |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\n+help: consider iterating over a slice of the `Vec<i32>`'s content to avoid moving into the `for` loop\n+   |\n+LL |         for j in &a {\n+   |                  +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "88be9e30a764125261b822c14a6e7c761d4d26a2", "filename": "src/test/ui/suggestions/for-i-in-vec.stderr", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -2,9 +2,17 @@ error[E0507]: cannot move out of `self.v` which is behind a shared reference\n   --> $DIR/for-i-in-vec.rs:11:18\n    |\n LL |         for _ in self.v {\n-   |                  ^^^^^^ move occurs because `self.v` has type `Vec<u32>`, which does not implement the `Copy` trait\n+   |                  ^^^^^^\n+   |                  |\n+   |                  `self.v` moved due to this implicit call to `.into_iter()`\n+   |                  move occurs because `self.v` has type `Vec<u32>`, which does not implement the `Copy` trait\n    |\n-help: consider iterating over a slice of the `Vec<u32>`'s content\n+note: this function takes ownership of the receiver `self`, which moves `self.v`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+help: consider iterating over a slice of the `Vec<u32>`'s content to avoid moving into the `for` loop\n    |\n LL |         for _ in &self.v {\n    |                  +\n@@ -13,9 +21,12 @@ error[E0507]: cannot move out of `self.h` which is behind a shared reference\n   --> $DIR/for-i-in-vec.rs:13:18\n    |\n LL |         for _ in self.h {\n-   |                  ^^^^^^ move occurs because `self.h` has type `HashMap<i32, i32>`, which does not implement the `Copy` trait\n+   |                  ^^^^^^\n+   |                  |\n+   |                  `self.h` moved due to this implicit call to `.into_iter()`\n+   |                  move occurs because `self.h` has type `HashMap<i32, i32>`, which does not implement the `Copy` trait\n    |\n-help: consider iterating over a slice of the `HashMap<i32, i32>`'s content\n+help: consider iterating over a slice of the `HashMap<i32, i32>`'s content to avoid moving into the `for` loop\n    |\n LL |         for _ in &self.h {\n    |                  +\n@@ -24,9 +35,17 @@ error[E0507]: cannot move out of a shared reference\n   --> $DIR/for-i-in-vec.rs:21:19\n    |\n LL |     for loader in *LOADERS {\n-   |                   ^^^^^^^^ move occurs because value has type `Vec<&u8>`, which does not implement the `Copy` trait\n+   |                   ^^^^^^^^\n+   |                   |\n+   |                   value moved due to this implicit call to `.into_iter()`\n+   |                   move occurs because value has type `Vec<&u8>`, which does not implement the `Copy` trait\n+   |\n+note: this function takes ownership of the receiver `self`, which moves value\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n    |\n-help: consider iterating over a slice of the `Vec<&u8>`'s content\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+help: consider iterating over a slice of the `Vec<&u8>`'s content to avoid moving into the `for` loop\n    |\n LL |     for loader in &*LOADERS {\n    |                   +"}, {"sha": "16cbbaba512a4e0c0fe58b505ebc1f872f5bb2bb", "filename": "src/test/ui/suggestions/option-content-move2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr?ref=10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "patch": "@@ -12,8 +12,8 @@ LL | |\n LL | |             var = Some(NotCopyable);\n    | |             ---\n    | |             |\n+   | |             variable moved due to use in closure\n    | |             move occurs because `var` has type `Option<NotCopyable>`, which does not implement the `Copy` trait\n-   | |             move occurs due to use in closure\n LL | |         }\n LL | |     });\n    | |_____- captured by this `FnMut` closure"}]}