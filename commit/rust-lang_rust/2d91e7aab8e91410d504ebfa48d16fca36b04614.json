{"sha": "2d91e7aab8e91410d504ebfa48d16fca36b04614", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOTFlN2FhYjhlOTE0MTBkNTA0ZWJmYTQ4ZDE2ZmNhMzZiMDQ2MTQ=", "commit": {"author": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-06T11:44:38Z"}, "committer": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-16T11:33:15Z"}, "message": "Refactor macro resolution errors + add derive macro suggestions", "tree": {"sha": "a0f9403ccd17cd8dd24f47712c42f6af6e39b4df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f9403ccd17cd8dd24f47712c42f6af6e39b4df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d91e7aab8e91410d504ebfa48d16fca36b04614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d91e7aab8e91410d504ebfa48d16fca36b04614", "html_url": "https://github.com/rust-lang/rust/commit/2d91e7aab8e91410d504ebfa48d16fca36b04614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d91e7aab8e91410d504ebfa48d16fca36b04614/comments", "author": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "committer": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05a7f25cc42d08aa541f50876915489bdc0eb4bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/05a7f25cc42d08aa541f50876915489bdc0eb4bb", "html_url": "https://github.com/rust-lang/rust/commit/05a7f25cc42d08aa541f50876915489bdc0eb4bb"}], "stats": {"total": 423, "additions": 300, "deletions": 123}, "files": [{"sha": "de789d5686fcfb81024bb8ebf8e66bfd4f66686d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -726,6 +726,8 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         });\n     }\n \n+    after_expand(&krate)?;\n+\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -751,14 +753,14 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          || ast_validation::check_crate(sess, &krate));\n \n     time(time_passes, \"name resolution\", || -> CompileResult {\n-        // Since import resolution will eventually happen in expansion,\n-        // don't perform `after_expand` until after import resolution.\n-        after_expand(&krate)?;\n-\n         resolver.resolve_crate(&krate);\n         Ok(())\n     })?;\n \n+    if resolver.found_unresolved_macro {\n+        sess.parse_sess.span_diagnostic.abort_if_errors();\n+    }\n+\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(time_passes, \"complete gated feature checking\", || {\n         sess.track_errors(|| {"}, {"sha": "fa3c12624c67ebbd38ddf6187977d0fdef64d910", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -51,6 +51,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{Determined, Undetermined};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -785,7 +786,7 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span, MacroKind)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1117,6 +1118,7 @@ pub struct Resolver<'a> {\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_exports: Vec<Export>,\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n+    pub found_unresolved_macro: bool,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1315,6 +1317,7 @@ impl<'a> Resolver<'a> {\n             warned_proc_macros: FxHashSet(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: DefIdMap(),\n+            found_unresolved_macro: false,\n         }\n     }\n "}, {"sha": "880f5f388d0601ff45b34ea137a5566c797d6e1d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 73, "deletions": 52, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -24,6 +24,7 @@ use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -236,8 +237,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n@@ -256,6 +257,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);\n+                self.found_unresolved_macro = true;\n                 return Err(Determinacy::Determined);\n             }\n \n@@ -266,7 +268,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n-                _ => Err(Determinacy::Determined),\n+                _ => {\n+                    self.found_unresolved_macro = true;\n+                    Err(Determinacy::Determined)\n+                },\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n@@ -279,40 +284,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n             None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n-                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n-                _ => {\n-                    let msg = format!(\"macro undefined: `{}`\", name);\n-                    let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&name.as_str(), &mut err);\n-                    err.emit();\n-                    return Err(Determinacy::Determined);\n-                },\n+                Err(Determinacy::Undetermined) if !force =>\n+                    return Err(Determinacy::Undetermined),\n+                Err(_) => {\n+                    self.found_unresolved_macro = true;\n+                    Err(Determinacy::Determined)\n+                }\n             },\n         };\n \n-        if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n-        }\n-        result\n-    }\n+        self.current_module.legacy_macro_resolutions.borrow_mut()\n+            .push((scope, path[0], span, kind));\n \n-    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let ast::Path { span, .. } = *path;\n-        match self.resolve_macro(scope, path, false) {\n-            Ok(ext) => match *ext {\n-                SyntaxExtension::BuiltinDerive(..) |\n-                SyntaxExtension::ProcMacroDerive(..) => Ok(ext),\n-                _ => Err(Determinacy::Determined),\n-            },\n-            Err(Determinacy::Undetermined) if force => {\n-                let msg = format!(\"cannot find derive macro `{}` in this scope\", path);\n-                let mut err = self.session.struct_span_err(span, &msg);\n-                err.emit();\n-                Err(Determinacy::Determined)\n-            },\n-            Err(err) => Err(err),\n-        }\n+        result\n     }\n }\n \n@@ -438,37 +422,74 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n-            let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n-                (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n+            match (legacy_resolution, resolution) {\n+                (Some(legacy_resolution), Ok(resolution)) => {\n+                    let (legacy_span, participle) = match legacy_resolution {\n+                        MacroBinding::Modern(binding)\n+                            if binding.def() == resolution.def() => continue,\n+                        MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n+                        MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+                    };\n+                    let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n+                    let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n+                    self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n+                        .span_note(legacy_span, &msg1)\n+                        .span_note(resolution.span, &msg2)\n+                        .emit();\n+                },\n                 (Some(MacroBinding::Modern(binding)), Err(_)) => {\n                     self.record_use(ident, MacroNS, binding, span);\n                     self.err_if_macro_use_proc_macro(ident.name, span, binding);\n-                    continue\n                 },\n-                _ => continue,\n-            };\n-            let (legacy_span, participle) = match legacy_resolution {\n-                MacroBinding::Modern(binding) if binding.def() == resolution.def() => continue,\n-                MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n-                MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+                (None, Err(_)) => {\n+                    let msg = match kind {\n+                        MacroKind::Bang =>\n+                            format!(\"cannot find macro `{}!` in this scope\", ident),\n+                        MacroKind::Attr =>\n+                            format!(\"cannot find attribute macro `{}` in this scope\", ident),\n+                        MacroKind::Derive =>\n+                            format!(\"cannot find derive macro `{}` in this scope\", ident),\n+                    };\n+                    let mut err = self.session.struct_span_err(span, &msg);\n+                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err);\n+                    err.emit();\n+                },\n+                _ => {},\n             };\n-            let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n-            let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                .span_note(legacy_span, &msg1)\n-                .span_note(resolution.span, &msg2)\n-                .emit();\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n-        if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n+    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n+                          err: &mut DiagnosticBuilder<'a>) {\n+        let suggestion = match kind {\n+            MacroKind::Bang =>\n+                find_best_match_for_name(self.macro_names.iter(), name, None),\n+            MacroKind::Attr |\n+            MacroKind::Derive => {\n+                // Find a suggestion from the legacy namespace.\n+                // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n+                let builtin_macros = self.builtin_macros.clone();\n+                let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+                    if binding.get_macro(self).kind() == kind {\n+                        Some(name)\n+                    } else {\n+                        None\n+                    }\n+                });\n+                find_best_match_for_name(names, name, None)\n+            }\n+        };\n+        if let Some(suggestion) = suggestion {\n             if suggestion != name {\n-                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+                if let MacroKind::Bang = kind {\n+                    err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+                } else {\n+                    err.help(&format!(\"did you mean `{}`?\", suggestion));\n+                }\n             } else {\n                 err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n             }"}, {"sha": "b61ab74687bb79c3f15eacbad1d569e995956783", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -474,6 +474,17 @@ impl MacResult for DummyResult {\n pub type BuiltinDeriveFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n \n+/// Represents different kinds of macro invocations that can be resolved.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum MacroKind {\n+    /// A bang macro - foo!()\n+    Bang,\n+    /// An attribute macro - #[foo]\n+    Attr,\n+    /// A derive attribute macro - #[derive(Foo)]\n+    Derive,\n+}\n+\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items\n@@ -520,6 +531,25 @@ pub enum SyntaxExtension {\n     BuiltinDerive(BuiltinDeriveFn),\n }\n \n+impl SyntaxExtension {\n+    /// Return which kind of macro calls this syntax extension.\n+    pub fn kind(&self) -> MacroKind {\n+        match *self {\n+            SyntaxExtension::NormalTT(..) |\n+            SyntaxExtension::IdentTT(..) |\n+            SyntaxExtension::ProcMacro(..) =>\n+                MacroKind::Bang,\n+            SyntaxExtension::MultiDecorator(..) |\n+            SyntaxExtension::MultiModifier(..) |\n+            SyntaxExtension::AttrProcMacro(..) =>\n+                MacroKind::Attr,\n+            SyntaxExtension::ProcMacroDerive(..) |\n+            SyntaxExtension::BuiltinDerive(..) =>\n+                MacroKind::Derive,\n+        }\n+    }\n+}\n+\n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n@@ -535,10 +565,8 @@ pub trait Resolver {\n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -561,12 +589,8 @@ impl Resolver for DummyResolver {\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n+                     _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n }"}, {"sha": "38494378f72ada31a9c25fb4d64b2d182a97c1ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -282,8 +282,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let mark = Mark::fresh();\n                         derives.push(mark);\n                         let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                        let item = match self.cx.resolver\n-                                             .resolve_macro(Mark::root(), &path, false) {\n+                        let item = match self.cx.resolver.resolve_macro(\n+                                Mark::root(), &path, MacroKind::Derive, false) {\n                             Ok(ext) => match *ext {\n                                 SyntaxExtension::BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n@@ -369,12 +369,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                      -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n         let (attr, traits, item) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n-                return self.cx.resolver.resolve_macro(scope, &mac.node.path, force).map(Some);\n+                return self.cx.resolver.resolve_macro(scope, &mac.node.path,\n+                                                      MacroKind::Bang, force).map(Some);\n             }\n             InvocationKind::Attr { attr: None, .. } => return Ok(None),\n             InvocationKind::Derive { name, span, .. } => {\n                 let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.cx.resolver.resolve_derive_macro(scope, &path, force).map(Some);\n+                return self.cx.resolver.resolve_macro(scope, &path,\n+                                                      MacroKind::Derive, force).map(Some)\n             }\n             InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n         };\n@@ -385,7 +387,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let mut determined = true;\n-        match self.cx.resolver.resolve_macro(scope, &path, force) {\n+        match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Attr, force) {\n             Ok(ext) => return Ok(Some(ext)),\n             Err(Determinacy::Undetermined) => determined = false,\n             Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n@@ -394,7 +396,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         for &(name, span) in traits {\n             let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.cx.resolver.resolve_macro(scope, &path, force) {\n+            match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here."}, {"sha": "726af9864b48215022022f436320d276c500a516", "filename": "src/test/compile-fail-fulldeps/gated-quote.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -25,32 +25,45 @@ extern crate syntax;\n \n use syntax::ast;\n use syntax::parse;\n-use syntax_pos::Span;\n \n struct ParseSess;\n \n impl ParseSess {\n     fn cfg(&self) -> ast::CrateConfig { loop { } }\n     fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { loop { } }\n-    fn call_site(&self) -> Span { loop { } }\n+    fn call_site(&self) -> () { loop { } }\n     fn ident_of(&self, st: &str) -> ast::Ident { loop { } }\n     fn name_of(&self, st: &str) -> ast::Name { loop { } }\n }\n \n pub fn main() {\n     let ecx = &ParseSess;\n-    let x = quote_tokens!(ecx, 3);    //~ ERROR macro undefined: `quote_tokens`\n-    let x = quote_expr!(ecx, 3);      //~ ERROR macro undefined: `quote_expr`\n-    let x = quote_ty!(ecx, 3);        //~ ERROR macro undefined: `quote_ty`\n-    let x = quote_method!(ecx, 3);    //~ ERROR macro undefined: `quote_method`\n-    let x = quote_item!(ecx, 3);      //~ ERROR macro undefined: `quote_item`\n-    let x = quote_pat!(ecx, 3);       //~ ERROR macro undefined: `quote_pat`\n-    let x = quote_arm!(ecx, 3);       //~ ERROR macro undefined: `quote_arm`\n-    let x = quote_stmt!(ecx, 3);      //~ ERROR macro undefined: `quote_stmt`\n-    let x = quote_matcher!(ecx, 3);   //~ ERROR macro undefined: `quote_matcher`\n-    let x = quote_attr!(ecx, 3);      //~ ERROR macro undefined: `quote_attr`\n-    let x = quote_arg!(ecx, 3);       //~ ERROR macro undefined: `quote_arg`\n-    let x = quote_block!(ecx, 3);     //~ ERROR macro undefined: `quote_block`\n-    let x = quote_meta_item!(ecx, 3); //~ ERROR macro undefined: `quote_meta_item`\n-    let x = quote_path!(ecx, 3);      //~ ERROR macro undefined: `quote_path`\n+    let x = quote_tokens!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_tokens!` in this scope\n+    let x = quote_expr!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_expr!` in this scope\n+    let x = quote_ty!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_ty!` in this scope\n+    let x = quote_method!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_method!` in this scope\n+    let x = quote_item!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_item!` in this scope\n+    let x = quote_pat!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_pat!` in this scope\n+    let x = quote_arm!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_arm!` in this scope\n+    let x = quote_stmt!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_stmt!` in this scope\n+    let x = quote_matcher!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_matcher!` in this scope\n+    let x = quote_attr!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_attr!` in this scope\n+    let x = quote_arg!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_arg!` in this scope\n+    let x = quote_block!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_block!` in this scope\n+    let x = quote_meta_item!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_meta_item!` in this scope\n+    let x = quote_path!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_path!` in this scope\n }"}, {"sha": "886b6247c0a3d97df9961f2589bfbdbffbe6b664", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -14,5 +14,6 @@\n extern crate macro_crate_test;\n \n fn main() {\n-    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: `unexported_macro`\n+    unexported_macro!();\n+    //~^ ERROR cannot find macro `unexported_macro!` in this scope\n }"}, {"sha": "719fbdb15ef2a7f852a2f9056d7661ea12ade038", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-clona.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Clona)]\n+pub fn derive_clonea(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "64dcf72ba2029b5165dbf06c32f669c2783ba024", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-foo.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(FooWithLongName)]\n+pub fn derive_foo(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "c9a36920a19e403a27824e3e5eeef6a1000f1e26", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-foo.rs\n+// aux-build:derive-clona.rs\n+// aux-build:attr_proc_macro.rs\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_foo;\n+#[macro_use]\n+extern crate derive_clona;\n+extern crate attr_proc_macro;\n+\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[derive(FooWithLongNam)]\n+//~^ ERROR cannot find derive macro `FooWithLongNam` in this scope\n+//~^^ HELP did you mean `FooWithLongName`?\n+struct Foo;\n+\n+#[attr_proc_macra]\n+//~^ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n+struct Bar;\n+\n+#[derive(Dlone)]\n+//~^ ERROR cannot find derive macro `Dlone` in this scope\n+//~^^ HELP did you mean `Clone`?\n+struct A;\n+\n+#[derive(Dlona)]\n+//~^ ERROR cannot find derive macro `Dlona` in this scope\n+//~^^ HELP did you mean `Clona`?\n+struct B;\n+\n+fn main() {}"}, {"sha": "04fdee5e3edf616bff0fceebe063aa3668df6924", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(FromPrimitive)] //~ERROR cannot find derive macro `FromPrimitive` in this scope\n+#[derive(FromPrimitive)] //~ ERROR cannot find derive macro `FromPrimitive` in this scope\n enum Foo {}\n \n fn main() {}"}, {"sha": "823a7426079aaedd454e5ff60141dca77746db60", "filename": "src/test/compile-fail/empty-macro-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -14,5 +14,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "a5bf79606248753e8f92877c667c08c203995bdf", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:macro undefined\n+// error-pattern:cannot find macro\n fn main() { iamnotanextensionthatexists!(\"\"); }"}, {"sha": "bbdf248780f3397c473f9e59d267e7e3590ba8ce", "filename": "src/test/compile-fail/feature-gate-rustc-diagnostic-macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -12,12 +12,12 @@\n // gate\n \n __register_diagnostic!(E0001);\n-//~^ ERROR macro undefined: `__register_diagnostic`\n+//~^ ERROR cannot find macro `__register_diagnostic!` in this scope\n \n fn main() {\n     __diagnostic_used!(E0001);\n-    //~^ ERROR macro undefined: `__diagnostic_used`\n+    //~^ ERROR cannot find macro `__diagnostic_used!` in this scope\n }\n \n __build_diagnostic_array!(DIAGNOSTICS);\n-//~^ ERROR macro undefined: `__build_diagnostic_array`\n+//~^ ERROR cannot find macro `__build_diagnostic_array!` in this scope"}, {"sha": "f577aad04e620bf0c7e02bedb9ebdc60167a529c", "filename": "src/test/compile-fail/issue-11692-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    print!(test!());\n+    //~^ ERROR: format argument must be a string literal\n+}"}, {"sha": "acac2d151fe9ad5ef8008d3caf10f1a5de111bf7", "filename": "src/test/compile-fail/issue-11692-2.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    print!(test!());\n-    //~^ ERROR: macro undefined: `test`\n-    //~^^ ERROR: format argument must be a string literal\n-\n     concat!(test!());\n-    //~^ ERROR: macro undefined: `test`\n+    //~^ ERROR cannot find macro `test!` in this scope\n }", "previous_filename": "src/test/compile-fail/issue-11692.rs"}, {"sha": "a3820d20aac5b0813d55d7769ac30ecd044fcb91", "filename": "src/test/compile-fail/issue-19734.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -10,6 +10,9 @@\n \n fn main() {}\n \n+struct Type;\n+\n impl Type {\n-    undef!(); //~ ERROR macro undefined: `undef`\n+    undef!();\n+    //~^ ERROR cannot find macro `undef!` in this scope\n }"}, {"sha": "78f95e365c44b7ef8510c649a35b1fe0ebf0d038", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -16,5 +16,4 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR macro undefined: `derive`\n }"}, {"sha": "ada06b0b3f452cdb3c97859e3ba551d05d4d706b", "filename": "src/test/compile-fail/macro-expansion-tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -12,14 +12,16 @@ mod macros_cant_escape_fns {\n     fn f() {\n         macro_rules! m { () => { 3 + 4 } }\n     }\n-    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+    fn g() -> i32 { m!() }\n+    //~^ ERROR cannot find macro\n }\n \n mod macros_cant_escape_mods {\n     mod f {\n         macro_rules! m { () => { 3 + 4 } }\n     }\n-    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+    fn g() -> i32 { m!() }\n+    //~^ ERROR cannot find macro\n }\n \n mod macros_can_escape_flattened_mods_test {"}, {"sha": "4840205fee4c368a0f2f786e587ba0f3a2d995b2", "filename": "src/test/compile-fail/macro-name-typo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    printlx!(\"oh noes!\"); //~ ERROR macro undefined\n-    //~^ HELP did you mean `println!`?\n+    printlx!(\"oh noes!\");\n+    //~^ ERROR cannot find macro\n+    //~^^ HELP did you mean `println!`?\n }"}, {"sha": "07467e06eb2df9346f1272b56466899c110c50db", "filename": "src/test/compile-fail/macro-no-implicit-reexport.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -15,5 +15,6 @@\n extern crate macro_non_reexport_2;\n \n fn main() {\n-    assert_eq!(reexported!(), 3);  //~ ERROR macro undefined\n+    assert_eq!(reexported!(), 3);\n+    //~^ ERROR cannot find macro `reexported!` in this scope\n }"}, {"sha": "54a74b0e134315b99bd1dfb12b49696a23b864bb", "filename": "src/test/compile-fail/macro-reexport-not-locally-visible.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -17,5 +17,6 @@\n extern crate macro_reexport_1;\n \n fn main() {\n-    assert_eq!(reexported!(), 3);  //~ ERROR macro undefined\n+    assert_eq!(reexported!(), 3);\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "143ecb4ce5e0a0ebea0583b7d630ae4519149ada", "filename": "src/test/compile-fail/macro-use-wrong-name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -14,5 +14,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "00c8d44f3060240cc6a715329a8d03af3e34ea25", "filename": "src/test/compile-fail/macro_undefined.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -18,8 +18,10 @@ mod m {\n }\n \n fn main() {\n-    k!(); //~ ERROR macro undefined: `k`\n-          //~^ HELP did you mean `kl!`?\n-    kl!(); //~ ERROR macro undefined: `kl`\n-           //~^ HELP have you added the `#[macro_use]` on the module/import?\n+    k!();\n+    //~^ ERROR cannot find macro `k!` in this scope\n+    //~^^ HELP did you mean `kl!`?\n+    kl!();\n+    //~^ ERROR cannot find macro `kl!` in this scope\n+    //~^^ HELP have you added the `#[macro_use]` on the module/import?\n }"}, {"sha": "7046ee12b50e563de83d718f08bf88486667e51a", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -14,15 +14,10 @@\n #![feature(asm)]\n #![feature(trace_macros, concat_idents)]\n \n-#[derive(Zero)] //~ ERROR\n-struct CantDeriveThis;\n-\n #[derive(Default)] //~ ERROR\n enum OrDeriveThis {}\n \n fn main() {\n-    doesnt_exist!(); //~ ERROR\n-\n     asm!(invalid); //~ ERROR\n \n     concat_idents!(\"not\", \"idents\"); //~ ERROR"}, {"sha": "bfe49ea00097251e4d0639043750a199f16e2729", "filename": "src/test/compile-fail/missing-macro-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -13,5 +13,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro `macro_two!` in this scope\n }"}, {"sha": "20d2e2ca9cfa1264961d65c59cd1760247bb7355", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91e7aab8e91410d504ebfa48d16fca36b04614/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=2d91e7aab8e91410d504ebfa48d16fca36b04614", "patch": "@@ -10,12 +10,16 @@\n \n // compile-flags: -Z continue-parse-after-error\n \n-struct Self;\n-//~^ ERROR expected identifier, found keyword `Self`\n+mod foo {\n+  struct Self;\n+  //~^ ERROR expected identifier, found keyword `Self`\n+}\n \n struct Bar<'Self>;\n //~^ ERROR lifetimes cannot use keyword names\n \n+struct Foo;\n+\n pub fn main() {\n     match 15 {\n         ref Self => (),\n@@ -25,7 +29,7 @@ pub fn main() {\n         ref mut Self => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Self!() => (),\n-        //~^ ERROR macro undefined: `Self`\n+        //~^ ERROR cannot find macro `Self!` in this scope\n         Foo { Self } => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n     }"}]}