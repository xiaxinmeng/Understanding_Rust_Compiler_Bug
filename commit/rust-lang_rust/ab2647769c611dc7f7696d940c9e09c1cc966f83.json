{"sha": "ab2647769c611dc7f7696d940c9e09c1cc966f83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjY0Nzc2OWM2MTFkYzdmNzY5NmQ5NDBjOWUwOWMxY2M5NjZmODM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-11T14:16:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-11T14:16:16Z"}, "message": "Return both field and local references for shorthands in goto_def", "tree": {"sha": "e742b810c715472223ef537dd1fba21ff878401a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e742b810c715472223ef537dd1fba21ff878401a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2647769c611dc7f7696d940c9e09c1cc966f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2647769c611dc7f7696d940c9e09c1cc966f83", "html_url": "https://github.com/rust-lang/rust/commit/ab2647769c611dc7f7696d940c9e09c1cc966f83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2647769c611dc7f7696d940c9e09c1cc966f83/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c41f1279a39e641918014e77e52de18061d07ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c41f1279a39e641918014e77e52de18061d07ba0", "html_url": "https://github.com/rust-lang/rust/commit/c41f1279a39e641918014e77e52de18061d07ba0"}], "stats": {"total": 148, "additions": 92, "deletions": 56}, "files": [{"sha": "7c73751045148bce59f5220774e0c01ff236dd10", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=ab2647769c611dc7f7696d940c9e09c1cc966f83", "patch": "@@ -51,11 +51,3 @@ pub(crate) fn annotations(ra_fixture: &str) -> (Analysis, FilePosition, Vec<(Fil\n         .collect();\n     (host.analysis(), FilePosition { file_id, offset }, annotations)\n }\n-\n-pub(crate) fn nav_target_annotation(ra_fixture: &str) -> (Analysis, FilePosition, FileRange) {\n-    let (analysis, position, mut annotations) = annotations(ra_fixture);\n-    let (expected, data) = annotations.pop().unwrap();\n-    assert!(annotations.is_empty());\n-    assert_eq!(data, \"\");\n-    (analysis, position, expected)\n-}"}, {"sha": "2e4132b6a0c26861152c99ab95a118d0b1d60bdd", "filename": "crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=ab2647769c611dc7f7696d940c9e09c1cc966f83", "patch": "@@ -24,47 +24,55 @@ pub(crate) fn goto_declaration(\n     let def = match_ast! {\n         match parent {\n             ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                    Definition::Local(local_ref)\n-                }\n+                NameRefClass::Definition(it) => Some(it),\n+                _ => None\n             },\n             ast::Name(name) => match NameClass::classify(&sema, &name)? {\n-                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n+                NameClass::Definition(it) => Some(it),\n+                _ => None\n             },\n-            _ => return None,\n+            _ => None,\n         }\n     };\n-    match def {\n+    match def? {\n         Definition::ModuleDef(hir::ModuleDef::Module(module)) => Some(RangeInfo::new(\n             original_token.text_range(),\n             vec![NavigationTarget::from_module_to_decl(db, module)],\n         )),\n-        _ => return None,\n+        _ => None,\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check(ra_fixture: &str) {\n-        let (analysis, position, expected) = fixture::nav_target_annotation(ra_fixture);\n-        let mut navs = analysis\n+        let (analysis, position, expected) = fixture::annotations(ra_fixture);\n+        let navs = analysis\n             .goto_declaration(position)\n             .unwrap()\n             .expect(\"no declaration or definition found\")\n             .info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }\n-        assert_eq!(navs.len(), 1);\n \n-        let nav = navs.pop().unwrap();\n-        assert_eq!(expected, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() });\n+        let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n+        let navs = navs\n+            .into_iter()\n+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        let expected = expected\n+            .into_iter()\n+            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        assert_eq!(expected, navs);\n     }\n \n     #[test]"}, {"sha": "595c0ec05c49fb90a459025b750ac3e5ccb3ce5c", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2647769c611dc7f7696d940c9e09c1cc966f83/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=ab2647769c611dc7f7696d940c9e09c1cc966f83", "patch": "@@ -1,4 +1,4 @@\n-use std::convert::TryInto;\n+use std::{convert::TryInto, iter};\n \n use either::Either;\n use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n@@ -11,7 +11,7 @@ use ide_db::{\n use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n use crate::{\n-    display::TryToNav,\n+    display::{ToNav, TryToNav},\n     doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n@@ -54,41 +54,44 @@ pub(crate) fn goto_definition(\n         let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }\n-    let nav = match_ast! {\n+\n+    let navs = match_ast! {\n         match parent {\n             ast::NameRef(name_ref) => {\n                 reference_definition(&sema, Either::Right(&name_ref))\n             },\n             ast::Name(name) => {\n-                let def = match NameClass::classify(&sema, &name)? {\n-                    NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                    NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n-                };\n-                try_find_trait_item_definition(sema.db, &def).or_else(|| def.try_to_nav(sema.db))\n+                match NameClass::classify(&sema, &name)? {\n+                    NameClass::Definition(def) | NameClass::ConstReference(def) => {\n+                        try_find_trait_item_definition(sema.db, &def).unwrap_or_else(|| def_to_nav(sema.db, def))\n+                    }\n+                    NameClass::PatFieldShorthand { local_def, field_ref } => {\n+                        local_and_field_to_nav(sema.db, local_def, field_ref)\n+                    },\n+                }\n             },\n             ast::Lifetime(lt) => if let Some(name_class) = NameClass::classify_lifetime(&sema, &lt) {\n-                let def = match name_class {\n-                    NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                    NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n-                };\n-                def.try_to_nav(sema.db)\n+                match name_class {\n+                    NameClass::Definition(def) => def_to_nav(sema.db, def),\n+                    _ => return None,\n+                }\n             } else {\n                 reference_definition(&sema, Either::Left(&lt))\n             },\n-            ast::TokenTree(tt) => try_lookup_include_path(sema.db, tt, token, position.file_id),\n+            ast::TokenTree(tt) => try_lookup_include_path(sema.db, tt, token, position.file_id)?,\n             _ => return None,\n         }\n     };\n \n-    Some(RangeInfo::new(original_token.text_range(), nav.into_iter().collect()))\n+    Some(RangeInfo::new(original_token.text_range(), navs))\n }\n \n fn try_lookup_include_path(\n     db: &RootDatabase,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n-) -> Option<NavigationTarget> {\n+) -> Option<Vec<NavigationTarget>> {\n     let path = ast::String::cast(token)?.value()?.into_owned();\n     let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n     let name = macro_call.path()?.segment()?.name_ref()?;\n@@ -97,7 +100,7 @@ fn try_lookup_include_path(\n     }\n     let file_id = db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n     let size = db.file_text(file_id).len().try_into().ok()?;\n-    Some(NavigationTarget {\n+    Some(vec![NavigationTarget {\n         file_id,\n         full_range: TextRange::new(0.into(), size),\n         name: path.into(),\n@@ -106,7 +109,7 @@ fn try_lookup_include_path(\n         container_name: None,\n         description: None,\n         docs: None,\n-    })\n+    }])\n }\n \n /// finds the trait definition of an impl'd item\n@@ -116,7 +119,10 @@ fn try_lookup_include_path(\n /// struct S;\n /// impl A for S { fn a(); } // <-- on this function, will get the location of a() in the trait\n /// ```\n-fn try_find_trait_item_definition(db: &RootDatabase, def: &Definition) -> Option<NavigationTarget> {\n+fn try_find_trait_item_definition(\n+    db: &RootDatabase,\n+    def: &Definition,\n+) -> Option<Vec<NavigationTarget>> {\n     let name = def.name(db)?;\n     let assoc = match def {\n         Definition::ModuleDef(ModuleDef::Function(f)) => f.as_assoc_item(db),\n@@ -135,40 +141,66 @@ fn try_find_trait_item_definition(db: &RootDatabase, def: &Definition) -> Option\n         .items(db)\n         .iter()\n         .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n+        .map(|it| vec![it])\n }\n \n pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n     name_ref: Either<&ast::Lifetime, &ast::NameRef>,\n-) -> Option<NavigationTarget> {\n-    let name_kind = name_ref.either(\n+) -> Vec<NavigationTarget> {\n+    let name_kind = match name_ref.either(\n         |lifetime| NameRefClass::classify_lifetime(sema, lifetime),\n         |name_ref| NameRefClass::classify(sema, name_ref),\n-    )?;\n-    let def = match name_kind {\n-        NameRefClass::Definition(def) => def,\n-        NameRefClass::FieldShorthand { local_ref, field_ref: _ } => Definition::Local(local_ref),\n+    ) {\n+        Some(class) => class,\n+        None => return Vec::new(),\n     };\n-    def.try_to_nav(sema.db)\n+    match name_kind {\n+        NameRefClass::Definition(def) => def_to_nav(sema.db, def),\n+        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n+            local_and_field_to_nav(sema.db, local_ref, field_ref)\n+        }\n+    }\n+}\n+\n+fn def_to_nav(db: &RootDatabase, def: Definition) -> Vec<NavigationTarget> {\n+    def.try_to_nav(db).map(|it| vec![it]).unwrap_or_default()\n+}\n+\n+fn local_and_field_to_nav(\n+    db: &RootDatabase,\n+    local: hir::Local,\n+    field: hir::Field,\n+) -> Vec<NavigationTarget> {\n+    iter::once(local.to_nav(db)).chain(field.try_to_nav(db)).collect()\n }\n \n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check(ra_fixture: &str) {\n-        let (analysis, position, expected) = fixture::nav_target_annotation(ra_fixture);\n-        let mut navs =\n-            analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n+        let (analysis, position, expected) = fixture::annotations(ra_fixture);\n+        let navs = analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }\n-        assert_eq!(navs.len(), 1);\n \n-        let nav = navs.pop().unwrap();\n-        assert_eq!(expected, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() });\n+        let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n+        let navs = navs\n+            .into_iter()\n+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        let expected = expected\n+            .into_iter()\n+            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        assert_eq!(expected, navs);\n     }\n \n     fn check_unresolved(ra_fixture: &str) {\n@@ -871,6 +903,7 @@ fn bar() {\n         check(\n             r#\"\n struct Foo { x: i32 }\n+           //^\n fn main() {\n     let x = 92;\n       //^\n@@ -886,6 +919,7 @@ fn main() {\n             r#\"\n enum Foo {\n     Bar { x: i32 }\n+        //^\n }\n fn baz(foo: Foo) {\n     match foo {\n@@ -1135,13 +1169,15 @@ fn foo<'foobar>(_: &'foobar ()) {\n     fn goto_lifetime_hrtb() {\n         // FIXME: requires the HIR to somehow track these hrtb lifetimes\n         check_unresolved(\n-            r#\"trait Foo<T> {}\n+            r#\"\n+trait Foo<T> {}\n fn foo<T>() where for<'a> T: Foo<&'a$0 (u8, u16)>, {}\n                     //^^\n \"#,\n         );\n         check_unresolved(\n-            r#\"trait Foo<T> {}\n+            r#\"\n+trait Foo<T> {}\n fn foo<T>() where for<'a$0> T: Foo<&'a (u8, u16)>, {}\n                     //^^\n \"#,"}]}