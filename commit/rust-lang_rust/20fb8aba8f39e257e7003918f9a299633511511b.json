{"sha": "20fb8aba8f39e257e7003918f9a299633511511b", "node_id": "C_kwDOAAsO6NoAKDIwZmI4YWJhOGYzOWUyNTdlNzAwMzkxOGY5YTI5OTYzMzUxMTUxMWI", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-07-12T07:11:05Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-07-14T09:01:17Z"}, "message": "Fix overlapping impls", "tree": {"sha": "a19b99ac9e5fe8efbe5d0f0474e146f8506a2dba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a19b99ac9e5fe8efbe5d0f0474e146f8506a2dba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20fb8aba8f39e257e7003918f9a299633511511b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20fb8aba8f39e257e7003918f9a299633511511b", "html_url": "https://github.com/rust-lang/rust/commit/20fb8aba8f39e257e7003918f9a299633511511b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20fb8aba8f39e257e7003918f9a299633511511b/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e612e2603cfffedfc000853648bc061a4aa7269c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e612e2603cfffedfc000853648bc061a4aa7269c", "html_url": "https://github.com/rust-lang/rust/commit/e612e2603cfffedfc000853648bc061a4aa7269c"}], "stats": {"total": 387, "additions": 215, "deletions": 172}, "files": [{"sha": "881682678dbed3c040ae3635923cb240f0f0f2fa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n+use rustc_middle::ty::abstract_const::AbstractConst;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::relate::RelateResult;\n@@ -1651,14 +1652,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToValTreeResult<'tcx> {\n-        let substs = self.resolve_vars_if_possible(unevaluated.substs);\n+        let mut substs = self.resolve_vars_if_possible(unevaluated.substs);\n         debug!(?substs);\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n-            debug!(\"substs have infer types or consts: {:?}\", substs);\n-            return Err(ErrorHandled::TooGeneric);\n+            let ac = AbstractConst::new(self.tcx, unevaluated.shrink());\n+            if let Ok(None) = ac {\n+                substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n+            } else {\n+                return Err(ErrorHandled::TooGeneric);\n+            }\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);"}, {"sha": "bed809930da615d61eff49b2ed099036fdfe90db", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 29, "deletions": 137, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -1,8 +1,10 @@\n //! A subset of a mir body used for const evaluatability checking.\n use crate::mir;\n+use crate::ty::visit::TypeVisitable;\n use crate::ty::{self, subst::Subst, DelaySpanBugEmitted, EarlyBinder, SubstsRef, Ty, TyCtxt};\n use rustc_errors::ErrorGuaranteed;\n-use std::iter;\n+use rustc_hir::def_id::DefId;\n+use std::cmp;\n use std::ops::ControlFlow;\n \n rustc_index::newtype_index! {\n@@ -63,6 +65,31 @@ impl<'tcx> AbstractConst<'tcx> {\n             Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n         }\n     }\n+\n+    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n+        let mut failure_kind = FailureKind::Concrete;\n+        walk_abstract_const::<!, _>(tcx, self, |node| {\n+            match node.root(tcx) {\n+                Node::Leaf(leaf) => {\n+                    if leaf.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if leaf.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Cast(_, _, ty) => {\n+                    if ty.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if ty.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n+            }\n+            ControlFlow::CONTINUE\n+        });\n+        failure_kind\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n@@ -104,7 +131,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn thir_abstract_const_opt_const_arg(\n         self,\n-        def: ty::WithOptConstParam<rustc_hir::def_id::DefId>,\n+        def: ty::WithOptConstParam<DefId>,\n     ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n         if let Some((did, param_did)) = def.as_const_arg() {\n             self.thir_abstract_const_of_const_arg((did, param_did))\n@@ -114,28 +141,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-pub fn try_unify_abstract_consts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a)? {\n-            if let Some(b) = AbstractConst::new(tcx, b)? {\n-                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-                return Ok(const_unify_ctxt.try_unify(a, b));\n-            }\n-        }\n-\n-        Ok(false)\n-    })()\n-    .unwrap_or_else(|_: ErrorGuaranteed| true)\n-    // FIXME(generic_const_exprs): We should instead have this\n-    // method return the resulting `ty::Const` and return `ConstKind::Error`\n-    // on `ErrorGuaranteed`.\n-}\n-\n #[instrument(skip(tcx, f), level = \"debug\")]\n pub fn walk_abstract_const<'tcx, R, F>(\n     tcx: TyCtxt<'tcx>,\n@@ -172,119 +177,6 @@ where\n     recurse(tcx, ct, &mut f)\n }\n \n-pub struct ConstUnifyCtxt<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> ConstUnifyCtxt<'tcx> {\n-    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    #[inline]\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_replace_substs_in_root(\n-        &self,\n-        mut abstr_const: AbstractConst<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n-        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n-            match AbstractConst::from_const(self.tcx, ct) {\n-                Ok(Some(act)) => abstr_const = act,\n-                Ok(None) => break,\n-                Err(_) => return None,\n-            }\n-        }\n-\n-        Some(abstr_const)\n-    }\n-\n-    /// Tries to unify two abstract constants using structural equality.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n-        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n-            a\n-        } else {\n-            return true;\n-        };\n-\n-        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n-            b\n-        } else {\n-            return true;\n-        };\n-\n-        let a_root = a.root(self.tcx);\n-        let b_root = b.root(self.tcx);\n-        debug!(?a_root, ?b_root);\n-\n-        match (a_root, b_root) {\n-            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-                let a_ct = a_ct.eval(self.tcx, self.param_env);\n-                debug!(\"a_ct evaluated: {:?}\", a_ct);\n-                let b_ct = b_ct.eval(self.tcx, self.param_env);\n-                debug!(\"b_ct evaluated: {:?}\", b_ct);\n-\n-                if a_ct.ty() != b_ct.ty() {\n-                    return false;\n-                }\n-\n-                match (a_ct.kind(), b_ct.kind()) {\n-                    // We can just unify errors with everything to reduce the amount of\n-                    // emitted errors here.\n-                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                        a_param == b_param\n-                    }\n-                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                    // means that we only allow inference variables if they are equal.\n-                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                    // We expand generic anonymous constants at the start of this function, so this\n-                    // branch should only be taking when dealing with associated constants, at\n-                    // which point directly comparing them seems like the desired behavior.\n-                    //\n-                    // FIXME(generic_const_exprs): This isn't actually the case.\n-                    // We also take this branch for concrete anonymous constants and\n-                    // expand generic anonymous constants with concrete substs.\n-                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                        a_uv == b_uv\n-                    }\n-                    // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                    // this, for now we just return false here.\n-                    _ => false,\n-                }\n-            }\n-            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify(a.subtree(ar), b.subtree(br))\n-            }\n-            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify(a.subtree(av), b.subtree(bv))\n-            }\n-            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-                if a_args.len() == b_args.len() =>\n-            {\n-                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n-                    && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n-            }\n-            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-                if (a_ty == b_ty) && (a_kind == b_kind) =>\n-            {\n-                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n-            }\n-            // use this over `_ => false` to make adding variants to `Node` less error prone\n-            (Node::Cast(..), _)\n-            | (Node::FunctionCall(..), _)\n-            | (Node::UnaryOp(..), _)\n-            | (Node::Binop(..), _)\n-            | (Node::Leaf(..), _) => false,\n-        }\n-    }\n-}\n-\n // We were unable to unify the abstract constant with\n // a constant found in the caller bounds, there are\n // now three possible cases here."}, {"sha": "e6284b1c4ace04a34776f9266752077c5a9f1067", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 139, "deletions": 29, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -8,19 +8,155 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::abstract_const::{\n-    walk_abstract_const, AbstractConst, ConstUnifyCtxt, FailureKind, Node, NotConstEvaluatable,\n+    walk_abstract_const, AbstractConst, FailureKind, Node, NotConstEvaluatable,\n };\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_session::lint;\n use rustc_span::Span;\n \n-use std::cmp;\n+use std::iter;\n use std::ops::ControlFlow;\n \n+pub struct ConstUnifyCtxt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n+    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n+    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n+        }\n+\n+        Some(abstr_const)\n+    }\n+\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n+            return true;\n+        };\n+\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n+\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n+\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n+                }\n+\n+                match (a_ct.kind(), b_ct.kind()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n+                }\n+            }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n+        }\n+    }\n+}\n+\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub fn try_unify_abstract_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> bool {\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a)? {\n+            if let Some(b) = AbstractConst::new(tcx, b)? {\n+                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n+            }\n+        }\n+\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|_: ErrorGuaranteed| true)\n+    // FIXME(generic_const_exprs): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `ErrorGuaranteed`.\n+}\n+\n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -36,33 +172,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             if satisfied_from_param_env(tcx, ct, param_env)? {\n                 return Ok(());\n             }\n-\n-            let mut failure_kind = FailureKind::Concrete;\n-            walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n-                    ControlFlow::CONTINUE\n-                }\n-            });\n-\n-            match failure_kind {\n+            match ct.unify_failure_kind(tcx) {\n                 FailureKind::MentionsInfer => {\n                     return Err(NotConstEvaluatable::MentionsInfer);\n                 }"}, {"sha": "0ad1b47a89079763509992f845d20b9d4a99859c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -847,7 +847,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         subst_and_check_impossible_predicates,\n         try_unify_abstract_consts: |tcx, param_env_and| {\n             let (param_env, (a, b)) = param_env_and.into_parts();\n-            rustc_middle::ty::abstract_const::try_unify_abstract_consts(tcx, (a, b), param_env)\n+            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n         },\n         ..*providers\n     };"}, {"sha": "7c2f4db94ff7269e7c60fd9bf9bf7db7d62bda11", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     /// Builds the abstract const by walking the thir and bailing out when\n     /// encountering an unsupported operation.\n     pub fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n-        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n+        debug!(\"AbstractConstBuilder::build: body={:?}\", &*self.body);\n         self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n@@ -331,7 +331,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n                 // expressions.\n                 // FIXME(generic_const_exprs): Verify/explain why this is sound\n-                if let ExprKind::Deref {arg} = arg_node.kind {\n+                if let ExprKind::Deref { arg } = arg_node.kind {\n                     self.recurse_build(arg)?\n                 } else {\n                     self.maybe_supported_error("}, {"sha": "e599eadd8cf4804815436c0bc859f53cfbe3ff72", "filename": "src/test/ui/const-generics/overlapping_impls.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/20fb8aba8f39e257e7003918f9a299633511511b/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fb8aba8f39e257e7003918f9a299633511511b/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs?ref=20fb8aba8f39e257e7003918f9a299633511511b", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+#![feature(generic_const_exprs)]\n+use std::marker::PhantomData;\n+\n+struct Foo<const I: i32, const J: i32> {}\n+\n+const ONE: i32 = 1;\n+const TWO: i32 = 2;\n+\n+impl<const I: i32> Foo<I, ONE> {\n+    pub fn foo() {}\n+}\n+\n+impl<const I: i32> Foo<I, TWO> {\n+    pub fn foo() {}\n+}\n+\n+\n+pub struct Foo2<const P: Protocol, T> {\n+    _marker: PhantomData<T>,\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub enum Protocol {\n+    Variant1,\n+    Variant2,\n+}\n+\n+pub trait Bar {}\n+\n+impl<T> Bar for Foo2<{ Protocol::Variant1 }, T> {}\n+impl<T> Bar for Foo2<{ Protocol::Variant2 }, T> {}\n+\n+fn main() {}"}]}