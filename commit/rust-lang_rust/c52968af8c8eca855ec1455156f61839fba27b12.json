{"sha": "c52968af8c8eca855ec1455156f61839fba27b12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1Mjk2OGFmOGM4ZWNhODU1ZWMxNDU1MTU2ZjYxODM5ZmJhMjdiMTI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-25T23:15:23Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-01T19:20:39Z"}, "message": "Move name resolution to phase 2", "tree": {"sha": "d714e16043a4aabf6210bd03cb6b9e0a2ff16119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d714e16043a4aabf6210bd03cb6b9e0a2ff16119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c52968af8c8eca855ec1455156f61839fba27b12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c52968af8c8eca855ec1455156f61839fba27b12", "html_url": "https://github.com/rust-lang/rust/commit/c52968af8c8eca855ec1455156f61839fba27b12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c52968af8c8eca855ec1455156f61839fba27b12/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d7e1bf70b58affdcd0b8baa678ce69f1a2eefd", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d7e1bf70b58affdcd0b8baa678ce69f1a2eefd", "html_url": "https://github.com/rust-lang/rust/commit/58d7e1bf70b58affdcd0b8baa678ce69f1a2eefd"}], "stats": {"total": 123, "additions": 66, "deletions": 57}, "files": [{"sha": "96a1bdf62dea7f5c9e081cc200da18cf14fb8f62", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c52968af8c8eca855ec1455156f61839fba27b12/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52968af8c8eca855ec1455156f61839fba27b12/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c52968af8c8eca855ec1455156f61839fba27b12", "patch": "@@ -94,15 +94,15 @@ pub fn compile_input(sess: &Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n-        let (outputs, expanded_crate, id) = {\n-            let krate = match phase_1_parse_input(sess, cfg, input) {\n-                Ok(krate) => krate,\n-                Err(mut parse_error) => {\n-                    parse_error.emit();\n-                    return Err(1);\n-                }\n-            };\n+        let krate = match phase_1_parse_input(sess, cfg, input) {\n+            Ok(krate) => krate,\n+            Err(mut parse_error) => {\n+                parse_error.emit();\n+                return Err(1);\n+            }\n+        };\n \n+        let krate = {\n             let mut compile_state = CompileState::state_after_parse(input,\n                                                                     sess,\n                                                                     outdir,\n@@ -113,17 +113,15 @@ pub fn compile_input(sess: &Session,\n                                     sess,\n                                     compile_state,\n                                     Ok(()));\n-            let krate = compile_state.krate.unwrap();\n \n-            let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-            let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n-            let expanded_crate = phase_2_configure_and_expand(sess,\n-                                                              &cstore,\n-                                                              krate,\n-                                                              &id,\n-                                                              addl_plugins)?;\n+            compile_state.krate.unwrap()\n+        };\n \n-            (outputs, expanded_crate, id)\n+        let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n+        let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n+            let make_glob_map = control.make_glob_map;\n+            phase_2_configure_and_expand(sess, &cstore, krate, &id, addl_plugins, make_glob_map)?\n         };\n \n         controller_entry_point!(after_expand,\n@@ -150,42 +148,12 @@ pub fn compile_input(sess: &Session,\n                                                                      &id),\n                                 Ok(()));\n \n-        let expanded_crate = assign_node_ids(sess, expanded_crate);\n-\n-        // Collect defintions for def ids.\n-        let mut defs = time(sess.time_passes(),\n-                            \"collecting defs\",\n-                            || hir_map::collect_definitions(&expanded_crate));\n-\n-        time(sess.time_passes(),\n-             \"external crate/lib resolution\",\n-             || read_local_crates(sess, &cstore, &defs, &expanded_crate, &id, &sess.dep_graph));\n-\n-        time(sess.time_passes(),\n-             \"early lint checks\",\n-             || lint::check_ast_crate(sess, &expanded_crate));\n-\n-        time(sess.time_passes(),\n-             \"AST validation\",\n-             || ast_validation::check_crate(sess, &expanded_crate));\n-\n-        let (analysis, resolutions, mut hir_forest) = {\n-            lower_and_resolve(sess, &id, &mut defs, &expanded_crate,\n-                              &sess.dep_graph, control.make_glob_map)\n-        };\n-\n-        // Discard MTWT tables that aren't required past lowering to HIR.\n-        if !keep_mtwt_tables(sess) {\n-            syntax::ext::mtwt::clear_tables();\n-        }\n-\n         let arenas = ty::CtxtArenas::new();\n \n         // Construct the HIR map\n-        let hir_forest = &mut hir_forest;\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           move || hir_map::map_crate(hir_forest, defs));\n+                           || hir_map::map_crate(&mut hir_forest, defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();\n@@ -577,19 +545,28 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n // For continuing compilation after a parsed crate has been\n // modified\n \n+pub struct ExpansionResult<'a> {\n+    pub expanded_crate: ast::Crate,\n+    pub defs: hir_map::Definitions,\n+    pub analysis: ty::CrateAnalysis<'a>,\n+    pub resolutions: Resolutions,\n+    pub hir_forest: hir_map::Forest,\n+}\n+\n /// Run the \"early phases\" of the compiler: initial `cfg` processing,\n /// loading compiler plugins (including those from `addl_plugins`),\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n-/// harness if one is to be provided and injection of a dependency on the\n-/// standard library and prelude.\n+/// harness if one is to be provided, injection of a dependency on the\n+/// standard library and prelude, and name resolution.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand(sess: &Session,\n-                                    cstore: &CStore,\n-                                    mut krate: ast::Crate,\n-                                    crate_name: &str,\n-                                    addl_plugins: Option<Vec<String>>)\n-                                    -> Result<ast::Crate, usize> {\n+pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n+                                        cstore: &CStore,\n+                                        mut krate: ast::Crate,\n+                                        crate_name: &'a str,\n+                                        addl_plugins: Option<Vec<String>>,\n+                                        make_glob_map: resolve::MakeGlobMap)\n+                                        -> Result<ExpansionResult<'a>, usize> {\n     let time_passes = sess.time_passes();\n \n     // strip before anything else because crate metadata may use #[cfg_attr]\n@@ -767,7 +744,39 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n-    Ok(krate)\n+    krate = assign_node_ids(sess, krate);\n+\n+    // Collect defintions for def ids.\n+    let mut defs =\n+        time(sess.time_passes(), \"collecting defs\", || hir_map::collect_definitions(&krate));\n+\n+    time(sess.time_passes(),\n+         \"external crate/lib resolution\",\n+         || read_local_crates(sess, &cstore, &defs, &krate, crate_name, &sess.dep_graph));\n+\n+    time(sess.time_passes(),\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n+    time(sess.time_passes(),\n+         \"AST validation\",\n+         || ast_validation::check_crate(sess, &krate));\n+\n+    let (analysis, resolutions, hir_forest) =\n+        lower_and_resolve(sess, crate_name, &mut defs, &krate, &sess.dep_graph, make_glob_map);\n+\n+    // Discard MTWT tables that aren't required past lowering to HIR.\n+    if !keep_mtwt_tables(sess) {\n+        syntax::ext::mtwt::clear_tables();\n+    }\n+\n+    Ok(ExpansionResult {\n+        expanded_crate: krate,\n+        defs: defs,\n+        analysis: analysis,\n+        resolutions: resolutions,\n+        hir_forest: hir_forest\n+    })\n }\n \n pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {"}]}