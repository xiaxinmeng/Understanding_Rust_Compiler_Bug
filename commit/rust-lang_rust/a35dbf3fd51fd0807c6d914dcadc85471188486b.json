{"sha": "a35dbf3fd51fd0807c6d914dcadc85471188486b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNWRiZjNmZDUxZmQwODA3YzZkOTE0ZGNhZGM4NTQ3MTE4ODQ4NmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T08:58:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T10:20:28Z"}, "message": "Don't spill immediates in order to drop them\n\nIssue #1012", "tree": {"sha": "bfbd07a4ec9dc664fd5621dc74060e59fdd3da09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfbd07a4ec9dc664fd5621dc74060e59fdd3da09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a35dbf3fd51fd0807c6d914dcadc85471188486b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a35dbf3fd51fd0807c6d914dcadc85471188486b", "html_url": "https://github.com/rust-lang/rust/commit/a35dbf3fd51fd0807c6d914dcadc85471188486b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a35dbf3fd51fd0807c6d914dcadc85471188486b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa1295343fdbccb608c95ec49c96eada9cb44f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1295343fdbccb608c95ec49c96eada9cb44f50", "html_url": "https://github.com/rust-lang/rust/commit/fa1295343fdbccb608c95ec49c96eada9cb44f50"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "c7ad040508c146e6042891cccb4e89b927aa3c2e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a35dbf3fd51fd0807c6d914dcadc85471188486b", "patch": "@@ -1321,7 +1321,9 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v));\n     } else if ty::type_is_unique_box(bcx_tcx(bcx), t) {\n         check trans_uniq::type_is_unique_box(bcx, t);\n-        bcx = trans_uniq::duplicate(bcx, v, t);\n+        let {bcx: cx, val} = trans_uniq::duplicate(bcx, Load(bcx, v), t);\n+        bcx = cx;\n+        Store(bcx, val, v);\n     } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n         bcx = iter_structural_ty(bcx, v, t, take_ty);\n     } else if ty::type_is_vec(bcx_tcx(bcx), t) {\n@@ -1954,6 +1956,27 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     ret cx;\n }\n \n+fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+    alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_box(_) { ret decr_refcnt_maybe_free(bcx, v, t); }\n+      ty::ty_uniq(_) { ret free_ty(bcx, v, t); }\n+      // FIXME A ty_ptr pointing at something that needs drop glue is somehow\n+      // marked as needing drop glue. This is probably a mistake.\n+      ty::ty_ptr(_) { ret bcx; }\n+    }\n+}\n+\n+fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+    alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_box(_) { ret rslt(incr_refcnt_of_boxed(bcx, v), v); }\n+      ty::ty_uniq(_) {\n+        check trans_uniq::type_is_unique_box(bcx, t);\n+        ret trans_uniq::duplicate(bcx, v, t);\n+      }\n+      _ { ret rslt(bcx, v); }\n+    }\n+}\n+\n fn free_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_has_pointers(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n@@ -4059,8 +4082,8 @@ fn get_landing_pad(bcx: @block_ctxt,\n     let scope_bcx = find_scope_for_lpad(bcx, have_zero_or_revoke);\n     if scope_bcx.lpad_dirty || have_zero_or_revoke {\n         let unwind_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n-        let lpadbb = trans_landing_pad(unwind_bcx, to_zero, to_revoke);\n-        scope_bcx.lpad = some(lpadbb);\n+        trans_landing_pad(unwind_bcx, to_zero, to_revoke);\n+        scope_bcx.lpad = some(unwind_bcx.llbb);\n         scope_bcx.lpad_dirty = have_zero_or_revoke;\n     }\n     assert option::is_some(scope_bcx.lpad);\n@@ -4418,10 +4441,15 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt dest {\n       by_val(cell) {\n-        if kind != owned {\n+        if kind == temporary {\n             revoke_clean(bcx, val);\n             *cell = val;\n+        } else if kind == owned_imm {\n+            let {bcx: cx, val} = take_ty_immediate(bcx, val, ty);\n+            *cell = val;\n+            bcx = cx;\n         } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n+            // FIXME make vectors immediate again, lose this hack\n             // Do a song and a dance to work around the fact that take_ty\n             // for unique boxes overwrites the pointer.\n             let oldval = Load(bcx, val);\n@@ -4723,9 +4751,15 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       // This is a local that is kept immediate\n       none. {\n         let initexpr = alt local.node.init { some({expr, _}) { expr } };\n-        let val = trans_temp_expr(bcx, initexpr);\n-        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val.val));\n-        ret val.bcx;\n+        let {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n+        if kind != temporary {\n+            if kind == owned { val = Load(bcx, val); }\n+            let rs = take_ty_immediate(bcx, val, ty);\n+            bcx = rs.bcx; val = rs.val;\n+            add_clean_temp(bcx, val, ty);\n+        }\n+        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val));\n+        ret bcx;\n       }\n     };\n \n@@ -4984,8 +5018,7 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     if is_simple && !bcx_ccx(cx).mut_map.contains_key(local.node.pat.id) &&\n-        ty::type_is_immediate(bcx_tcx(cx), t) &&\n-        !ty::type_needs_drop(bcx_tcx(cx), t) {\n+        ty::type_is_immediate(bcx_tcx(cx), t) {\n         alt local.node.init {\n           some({op: ast::init_assign., _}) { ret cx; }\n           _ {}"}, {"sha": "5d788586fe968d984111759eff962b0149e6f920", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=a35dbf3fd51fd0807c6d914dcadc85471188486b", "patch": "@@ -271,17 +271,17 @@ fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n-    fn spill_and_drop(cx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n+    fn do_drop(bcx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n        @block_ctxt {\n-        let bcx = cx;\n-        let r = trans::spill_if_immediate(bcx, val, ty);\n-        let spilled = r.val;\n-        bcx = r.bcx;\n-        ret drop_ty(bcx, spilled, ty);\n+        if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n+            ret trans::drop_ty_immediate(bcx, val, ty);\n+        } else {\n+            ret drop_ty(bcx, val, ty);\n+        }\n     }\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups +=\n-        [clean_temp(val, bind spill_and_drop(_, val, ty))];\n+        [clean_temp(val, bind do_drop(_, val, ty))];\n     scope_cx.lpad_dirty = true;\n }\n fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {"}, {"sha": "67e55ef6f5bc3694cb6b200c04e33d31f1a03eff", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35dbf3fd51fd0807c6d914dcadc85471188486b/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=a35dbf3fd51fd0807c6d914dcadc85471188486b", "patch": "@@ -98,15 +98,13 @@ fn autoderef(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n }\n \n fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n-    : type_is_unique_box(bcx, t) -> @block_ctxt {\n+    : type_is_unique_box(bcx, t) -> result {\n \n     let content_ty = content_ty(bcx, t);\n     let {bcx, val: llptr} = alloc_uniq(bcx, t);\n \n-    let src = Load(bcx, v);\n-    let src = load_if_immediate(bcx, src, content_ty);\n+    let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;\n     let bcx = trans::copy_val(bcx, INIT, dst, src, content_ty);\n-    Store(bcx, dst, v);\n-    ret bcx;\n+    ret rslt(bcx, dst);\n }\n\\ No newline at end of file"}]}