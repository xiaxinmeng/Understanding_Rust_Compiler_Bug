{"sha": "68048199c9d58e907c308620aeb0e5133d5aba7b", "node_id": "C_kwDOAAsO6NoAKDY4MDQ4MTk5YzlkNThlOTA3YzMwODYyMGFlYjBlNTEzM2Q1YWJhN2I", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-05-05T13:43:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-05T13:43:07Z"}, "message": "Rollup merge of #96714 - RalfJung:scalar-pair-debug, r=oli-obk\n\ninterpret/validity: debug-check ScalarPair layout information\n\nThis would have caught https://github.com/rust-lang/rust/issues/96158.\nI ran the Miri test suite and it still passes.\n\nr? `@oli-obk`", "tree": {"sha": "fceffb2c770b8efa062731eb7a6496510baf0e0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fceffb2c770b8efa062731eb7a6496510baf0e0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68048199c9d58e907c308620aeb0e5133d5aba7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJic9RrCRBK7hj4Ov3rIwAAkukIAHPFmT2hxN3XJBnHtbyv0jrT\nHMuRUvXsdD/NSeFV59W7GsqwHGOZuKHT2hmzRUpSj+LVb0Ln2/lfkevn+72VkO7b\nssgxcJVlM5ZcPCqdDxcdlJtojcD6bJzDY8+rahkNp60i6+/zbYdg2RRbEpsy5zTd\n/15tPp2nijdsHp21g8P7/p6RRjAjxG4y51am2sQqebNaAvKxnaGMVgqjDp+Bw8wv\nPozCqZL1KKsLxlKRJa1HItn651NzCdZGZURYoEI4Wu9e5HdQzjL9jqWU4gYF5On5\nCJZxezWmVBCgbBSb9CZ49OwsL0phC4t5hHL3mEy2RdAElmKqPP82BMgehM5d4ug=\n=VjsG\n-----END PGP SIGNATURE-----\n", "payload": "tree fceffb2c770b8efa062731eb7a6496510baf0e0e\nparent 7a915dd80d24a90c6507ff3ff38519c9b8578b91\nparent e47d6c7a6b643e836455d4ebf5e7fb1eaad5c870\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1651758187 +0200\ncommitter GitHub <noreply@github.com> 1651758187 +0200\n\nRollup merge of #96714 - RalfJung:scalar-pair-debug, r=oli-obk\n\ninterpret/validity: debug-check ScalarPair layout information\n\nThis would have caught https://github.com/rust-lang/rust/issues/96158.\nI ran the Miri test suite and it still passes.\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68048199c9d58e907c308620aeb0e5133d5aba7b", "html_url": "https://github.com/rust-lang/rust/commit/68048199c9d58e907c308620aeb0e5133d5aba7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68048199c9d58e907c308620aeb0e5133d5aba7b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a915dd80d24a90c6507ff3ff38519c9b8578b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a915dd80d24a90c6507ff3ff38519c9b8578b91", "html_url": "https://github.com/rust-lang/rust/commit/7a915dd80d24a90c6507ff3ff38519c9b8578b91"}, {"sha": "e47d6c7a6b643e836455d4ebf5e7fb1eaad5c870", "url": "https://api.github.com/repos/rust-lang/rust/commits/e47d6c7a6b643e836455d4ebf5e7fb1eaad5c870", "html_url": "https://github.com/rust-lang/rust/commit/e47d6c7a6b643e836455d4ebf5e7fb1eaad5c870"}], "stats": {"total": 152, "additions": 99, "deletions": 53}, "files": [{"sha": "a8a5ac2f9d95d4b6aae2cf0d801890322edd7c42", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=68048199c9d58e907c308620aeb0e5133d5aba7b", "patch": "@@ -84,14 +84,18 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>) {\n         match self {\n-            Immediate::ScalarPair(val1, val2) => Ok((val1.check_init()?, val2.check_init()?)),\n-            Immediate::Scalar(..) => {\n-                bug!(\"Got a scalar where a scalar pair was expected\")\n-            }\n+            Immediate::ScalarPair(val1, val2) => (val1, val2),\n+            Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n         }\n     }\n+\n+    #[inline]\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+        let (val1, val2) = self.to_scalar_or_uninit_pair();\n+        Ok((val1.check_init()?, val2.check_init()?))\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -248,9 +252,12 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    fn try_read_immediate_from_mplace(\n+    ///\n+    /// This is an internal function; call `read_immediate` instead.\n+    fn read_immediate_from_mplace_raw(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -271,42 +278,61 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // case where some of the bytes are initialized and others are not. So, we need an extra\n         // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n         // like a `Scalar` (or `ScalarPair`).\n-        match mplace.layout.abi {\n-            Abi::Scalar(abi::Scalar::Initialized { .. }) => {\n-                let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n-                Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n-            }\n+        let scalar_layout = match mplace.layout.abi {\n+            // `if` does not work nested inside patterns, making this a bit awkward to express.\n+            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => Some(s),\n+            Abi::Scalar(s) if force => Some(s.primitive()),\n+            _ => None,\n+        };\n+        if let Some(_) = scalar_layout {\n+            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n+            return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n+        }\n+        let scalar_pair_layout = match mplace.layout.abi {\n             Abi::ScalarPair(\n                 abi::Scalar::Initialized { value: a, .. },\n                 abi::Scalar::Initialized { value: b, .. },\n-            ) => {\n-                // We checked `ptr_align` above, so all fields will have the alignment they need.\n-                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n-                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let b_offset = a_size.align_to(b.align(self).abi);\n-                assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n-                let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n-                let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n-                Ok(Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout }))\n-            }\n-            _ => Ok(None),\n+            ) => Some((a, b)),\n+            Abi::ScalarPair(a, b) if force => Some((a.primitive(), b.primitive())),\n+            _ => None,\n+        };\n+        if let Some((a, b)) = scalar_pair_layout {\n+            // We checked `ptr_align` above, so all fields will have the alignment they need.\n+            // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+            // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n+            let (a_size, b_size) = (a.size(self), b.size(self));\n+            let b_offset = a_size.align_to(b.align(self).abi);\n+            assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n+            let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n+            let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::ScalarPair(a_val, b_val),\n+                layout: mplace.layout,\n+            }));\n         }\n+        // Neither a scalar nor scalar pair.\n+        return Ok(None);\n     }\n \n-    /// Try returning an immediate for the operand.\n-    /// If the layout does not permit loading this as an immediate, return where in memory\n-    /// we can find the data.\n+    /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n+    /// immediate, return where in memory we can find the data.\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n-    pub fn try_read_immediate(\n+    ///\n+    /// If `force` is `true`, then even scalars with fields that can be ununit will be\n+    /// read. This means the load is lossy and should not be written back!\n+    /// This flag exists only for validity checking.\n+    ///\n+    /// This is an internal function that should not usually be used; call `read_immediate` instead.\n+    pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n-                if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n+                if let Some(val) = self.read_immediate_from_mplace_raw(mplace, force)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -322,7 +348,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(imm) = self.try_read_immediate(op)? {\n+        if let Ok(imm) = self.read_immediate_raw(op, /*force*/ false)? {\n             Ok(imm)\n         } else {\n             span_bug!(self.cur_span(), \"primitive read failed for type: {:?}\", op.layout.ty);"}, {"sha": "df6e05bb13cde81b839894c3f2496d1a71c03123", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=68048199c9d58e907c308620aeb0e5133d5aba7b", "patch": "@@ -720,7 +720,7 @@ where\n         }\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        // See if we can avoid an allocation. This is the counterpart to `try_read_immediate`,\n+        // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n@@ -879,7 +879,7 @@ where\n         }\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let src = match self.try_read_immediate(src)? {\n+        let src = match self.read_immediate_raw(src, /*force*/ false)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly."}, {"sha": "92e3ac04dc41813522fd6266356d9611f85876f2", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=68048199c9d58e907c308620aeb0e5133d5aba7b", "patch": "@@ -20,8 +20,8 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n use std::hash::Hash;\n \n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    alloc_range, CheckInAllocMsg, GlobalAlloc, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -487,6 +487,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         ))\n     }\n \n+    fn read_immediate_forced(\n+        &self,\n+        op: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+        Ok(*try_validation!(\n+            self.ecx.read_immediate_raw(op, /*force*/ true),\n+            self.path,\n+            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        ).unwrap())\n+    }\n+\n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n@@ -626,18 +637,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        scalar: ScalarMaybeUninit<M::PointerTag>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         // We check `is_full_range` in a slightly complicated way because *if* we are checking\n         // number validity, then we want to ensure that `Scalar::Initialized` is indeed initialized,\n         // i.e. that we go over the `check_init` below.\n+        let size = scalar_layout.size(self.ecx);\n         let is_full_range = match scalar_layout {\n             ScalarAbi::Initialized { valid_range, .. } => {\n                 if M::enforce_number_validity(self.ecx) {\n                     false // not \"full\" since uninit is not accepted\n                 } else {\n-                    valid_range.is_full_for(op.layout.size)\n+                    valid_range.is_full_for(size)\n                 }\n             }\n             ScalarAbi::Union { .. } => true,\n@@ -646,21 +658,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // Nothing to check\n             return Ok(());\n         }\n-        // We have something to check.\n+        // We have something to check: it must at least be initialized.\n         let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n-        let max_value = op.layout.size.unsigned_int_max();\n+        let max_value = size.unsigned_int_max();\n         assert!(end <= max_value);\n-        // Determine the allowed range\n-        let value = self.read_scalar(op)?;\n         let value = try_validation!(\n-            value.check_init(),\n+            scalar.check_init(),\n             self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", value }\n+            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", scalar }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n         );\n         let bits = match value.try_to_int() {\n-            Ok(int) => int.assert_bits(op.layout.size),\n+            Ok(int) => int.assert_bits(size),\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n@@ -678,7 +688,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     } else {\n                         return Ok(());\n                     }\n-                } else if scalar_layout.valid_range(self.ecx).is_full_for(op.layout.size) {\n+                } else if scalar_layout.valid_range(self.ecx).is_full_for(size) {\n                     // Easy. (This is reachable if `enforce_number_validity` is set.)\n                     return Ok(());\n                 } else {\n@@ -817,13 +827,23 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             Abi::Scalar(scalar_layout) => {\n-                self.visit_scalar(op, scalar_layout)?;\n+                let scalar = self.read_immediate_forced(op)?.to_scalar_or_uninit();\n+                self.visit_scalar(scalar, scalar_layout)?;\n+            }\n+            Abi::ScalarPair(a_layout, b_layout) => {\n+                // We would validate these things as we descend into the fields,\n+                // but that can miss bugs in layout computation. Layout computation\n+                // is subtle due to enums having ScalarPair layout, where one field\n+                // is the discriminant.\n+                if cfg!(debug_assertions) {\n+                    let (a, b) = self.read_immediate_forced(op)?.to_scalar_or_uninit_pair();\n+                    self.visit_scalar(a, a_layout)?;\n+                    self.visit_scalar(b, b_layout)?;\n+                }\n             }\n-            Abi::ScalarPair { .. } | Abi::Vector { .. } => {\n-                // These have fields that we already visited above, so we already checked\n-                // all their scalar-level restrictions.\n-                // There is also no equivalent to `rustc_layout_scalar_valid_range_start`\n-                // that would make skipping them here an issue.\n+            Abi::Vector { .. } => {\n+                // No checks here, we assume layout computation gets this right.\n+                // (This is harder to check since Miri does not represent these as `Immediate`.)\n             }\n             Abi::Aggregate { .. } => {\n                 // Nothing to do."}, {"sha": "f7535d338da40dd05caa6e7a8e037498d2e94257", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=68048199c9d58e907c308620aeb0e5133d5aba7b", "patch": "@@ -415,7 +415,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -709,8 +709,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return;\n         }\n \n-        // FIXME> figure out what to do when try_read_immediate fails\n-        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n+        // FIXME> figure out what to do when read_immediate_raw fails\n+        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value, /*force*/ false));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {"}, {"sha": "aa898cfd3ba5ef3e5f14529e1cb3973599378348", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68048199c9d58e907c308620aeb0e5133d5aba7b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=68048199c9d58e907c308620aeb0e5133d5aba7b", "patch": "@@ -412,7 +412,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })"}]}