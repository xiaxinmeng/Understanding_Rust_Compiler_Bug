{"sha": "9007296a202b62f26aaa66393cefd93e731b9602", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMDcyOTZhMjAyYjYyZjI2YWFhNjYzOTNjZWZkOTNlNzMxYjk2MDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-06T10:46:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-06T10:46:08Z"}, "message": "Add check_mplace_ptr convenience method; provide ptr-normalization methods for mplace and op to avoid repeated int-to-ptr casting during validation.\n\nAlso change Memory::copy to work on `Pointer` instead of `Scalar`.\nAlso rename some methods from to_* to assert_* that will panic if their precondition is not met.", "tree": {"sha": "a2b4ae3f1e1e45370c89b6c9a4a1ed786964baf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2b4ae3f1e1e45370c89b6c9a4a1ed786964baf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9007296a202b62f26aaa66393cefd93e731b9602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9007296a202b62f26aaa66393cefd93e731b9602", "html_url": "https://github.com/rust-lang/rust/commit/9007296a202b62f26aaa66393cefd93e731b9602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9007296a202b62f26aaa66393cefd93e731b9602/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eed52de6b74b51edb5d7636c9fc495dd62b5a084", "url": "https://api.github.com/repos/rust-lang/rust/commits/eed52de6b74b51edb5d7636c9fc495dd62b5a084", "html_url": "https://github.com/rust-lang/rust/commit/eed52de6b74b51edb5d7636c9fc495dd62b5a084"}], "stats": {"total": 174, "additions": 108, "deletions": 66}, "files": [{"sha": "de0f8dbcf21af4f626b97c933d1cc5031139e2b6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -109,7 +109,7 @@ fn op_to_const<'tcx>(\n                 // `Immediate` is when we are called from `const_field`, and that `Immediate`\n                 // comes from a constant so it can happen have `Undef`, because the indirect\n                 // memory that was read had undefined bytes.\n-                let mplace = op.to_mem_place();\n+                let mplace = op.assert_mem_place();\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }"}, {"sha": "3f2a76a77be36b8f6f847482de41871418849830", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -214,10 +214,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n         };\n         self.copy(\n-            ptr.into(),\n-            Align::from_bytes(1).unwrap(), // old_align anyway gets checked below by `deallocate`\n-            new_ptr.into(),\n-            new_align,\n+            ptr,\n+            new_ptr,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n@@ -310,6 +308,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n     /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n     /// cause ICEs.\n+    ///\n+    /// Most of the time you should use `check_mplace_access`, but when you just have a pointer,\n+    /// this method is still appropriate.\n     pub fn check_ptr_access(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n@@ -751,39 +752,26 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n-    /// Performs appropriate bounds checks.\n+    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n-        src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        src: Pointer<M::PointerTag>,\n+        dest: Pointer<M::PointerTag>,\n         size: Size,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+        self.copy_repeatedly(src, dest, size, 1, nonoverlapping)\n     }\n \n-    /// Performs appropriate bounds checks.\n+    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy_repeatedly(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n-        src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        src: Pointer<M::PointerTag>,\n+        dest: Pointer<M::PointerTag>,\n         size: Size,\n         length: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        // We need to check *both* before early-aborting due to the size being 0.\n-        let (src, dest) = match (self.check_ptr_access(src, size, src_align)?,\n-                self.check_ptr_access(dest, size * length, dest_align)?)\n-        {\n-            (Some(src), Some(dest)) => (src, dest),\n-            // One of the two sizes is 0.\n-            _ => return Ok(()),\n-        };\n-\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target."}, {"sha": "b43c810b8e626f92da8ce4ae87d68952319e430e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -123,23 +123,23 @@ pub enum Operand<Tag=(), Id=AllocId> {\n \n impl<Tag> Operand<Tag> {\n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace<Tag>\n+    pub fn assert_mem_place(self) -> MemPlace<Tag>\n         where Tag: ::std::fmt::Debug\n     {\n         match self {\n             Operand::Indirect(mplace) => mplace,\n-            _ => bug!(\"to_mem_place: expected Operand::Indirect, got {:?}\", self),\n+            _ => bug!(\"assert_mem_place: expected Operand::Indirect, got {:?}\", self),\n \n         }\n     }\n \n     #[inline]\n-    pub fn to_immediate(self) -> Immediate<Tag>\n+    pub fn assert_immediate(self) -> Immediate<Tag>\n         where Tag: ::std::fmt::Debug\n     {\n         match self {\n             Operand::Immediate(imm) => imm,\n-            _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n+            _ => bug!(\"assert_immediate: expected Operand::Immediate, got {:?}\", self),\n \n         }\n     }\n@@ -214,6 +214,19 @@ pub(super) fn from_known_layout<'tcx>(\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// Normalice `place.ptr` to a `Pointer` if this is a place and not a ZST.\n+    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n+    #[inline]\n+    pub fn normalize_op_ptr(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        match op.try_as_mplace() {\n+            Ok(mplace) => Ok(self.normalize_mplace_ptr(mplace)?.into()),\n+            Err(imm) => Ok(imm.into()), // Nothing to normalize\n+        }\n+    }\n+\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace(\n@@ -224,9 +237,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Don't touch unsized\n             return Ok(None);\n         }\n-        let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n \n-        let ptr = match self.memory.check_ptr_access(ptr, mplace.layout.size, ptr_align)? {\n+        let ptr = match self.check_mplace_access(mplace, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Immediate::Scalar(Scalar::zst().into()),\n@@ -396,7 +408,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             } else {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.to_mem_place();\n+                let mplace = base.assert_mem_place();\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }\n         })"}, {"sha": "9641164b11907b12dad6748b8b0848a97933c897", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 55, "deletions": 17, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -230,6 +230,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n }\n \n+// These are defined here because they produce a place.\n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n@@ -240,7 +241,7 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }\n@@ -263,29 +264,29 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace<Tag> {\n+    pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n             Place::Ptr(mplace) => mplace,\n-            _ => bug!(\"to_mem_place: expected Place::Ptr, got {:?}\", self),\n+            _ => bug!(\"assert_mem_place: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n     #[inline]\n     pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n-        self.to_mem_place().to_scalar_ptr_align()\n+        self.assert_mem_place().to_scalar_ptr_align()\n     }\n \n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n-        self.to_mem_place().to_ptr()\n+        self.assert_mem_place().to_ptr()\n     }\n }\n \n impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n     #[inline]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n+    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+        MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n     }\n }\n \n@@ -322,8 +323,8 @@ where\n         Ok(MPlaceTy { mplace, layout })\n     }\n \n-    // Take an operand, representing a pointer, and dereference it to a place -- that\n-    // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    /// Take an operand, representing a pointer, and dereference it to a place -- that\n+    /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n     pub fn deref_operand(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n@@ -333,6 +334,38 @@ where\n         self.ref_to_mplace(val)\n     }\n \n+    /// Check if the given place is good for memory access with the given\n+    /// size, falling back to the layout's size if `None` (in the latter case,\n+    /// this must be a statically sized type).\n+    ///\n+    /// On success, returns `None` for zero-sized accesses (where nothing else is\n+    /// left to do) and a `Pointer` to use for the actual access otherwise.\n+    #[inline]\n+    pub fn check_mplace_access(\n+        &self,\n+        place: MPlaceTy<'tcx, M::PointerTag>,\n+        size: Option<Size>,\n+    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        let size = size.unwrap_or_else(|| {\n+            assert!(!place.layout.is_unsized());\n+            assert!(place.meta.is_none());\n+            place.layout.size\n+        });\n+        self.memory.check_ptr_access(place.ptr, size, place.align)\n+    }\n+\n+    /// Normalice `place.ptr` to a `Pointer` if this is not a ZST.\n+    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n+    pub fn normalize_mplace_ptr(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        if !place.layout.is_zst() {\n+            place.mplace.ptr = self.force_ptr(place.mplace.ptr)?.into();\n+        }\n+        Ok(place)\n+    }\n+\n     /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n     /// possible without allocating, so it can take `&self`. Also return the field's layout.\n     /// This supports both struct and array fields.\n@@ -741,14 +774,12 @@ where\n         value: Immediate<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n-        assert!(!dest.layout.is_unsized());\n \n-        let ptr = match self.memory.check_ptr_access(ptr, dest.layout.size, ptr_align)? {\n+        let ptr = match self.check_mplace_access(dest, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -850,14 +881,21 @@ where\n             dest.layout.size\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n+\n+        let src = self.check_mplace_access(src, Some(size))?;\n+        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let (src_ptr, dest_ptr) = match (src, dest) {\n+            (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n+            (None, None) => return Ok(()), // zero-sized copy\n+            _ => bug!(\"The pointers should both be Some or both None\"),\n+        };\n+\n         self.memory.copy(\n-            src.ptr, src.align,\n-            dest.ptr, dest.align,\n+            src_ptr,\n+            dest_ptr,\n             size,\n             /*nonoverlapping*/ true,\n-        )?;\n-\n-        Ok(())\n+        )\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must"}, {"sha": "246c90ba48e3aa3661ca61a81dbaf4ea932a0a0a", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -209,17 +209,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let dest = self.force_allocation(dest)?;\n                 let length = dest.len(self)?;\n \n-                if length > 0 {\n-                    // write the first\n+                if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n+                    // Write the first.\n                     let first = self.mplace_field(dest, 0)?;\n                     self.copy_op(op, first.into())?;\n \n                     if length > 1 {\n-                        // copy the rest\n-                        let (dest, dest_align) = first.to_scalar_ptr_align();\n-                        let rest = dest.ptr_offset(first.layout.size, self)?;\n+                        let elem_size = first.layout.size;\n+                        // Copy the rest. This is performance-sensitive code\n+                        // for big static/const arrays!\n+                        let rest_ptr = first_ptr.offset(elem_size, self)?;\n                         self.memory.copy_repeatedly(\n-                            dest, dest_align, rest, dest_align, first.layout.size, length - 1, true\n+                            first_ptr, rest_ptr, elem_size, length - 1, /*nonoverlapping:*/true\n                         )?;\n                     }\n                 }"}, {"sha": "c11e5e119237f48dba3930ba73e9ce57fb0da7bc", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -426,7 +426,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].to_mem_place()\n+                        args[0].assert_mem_place()\n                     }\n                 };\n                 // Find and consult vtable"}, {"sha": "bf062ac68a5c191fc0f647643393f53ab4721f10", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -440,9 +440,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             }\n                         }\n                     }\n-                    // Check if we have encountered this pointer+layout combination\n-                    // before.  Proceed recursively even for ZST, no\n-                    // reason to skip them! E.g., `!` is a ZST and we want to validate it.\n+                    // Proceed recursively even for ZST, no reason to skip them!\n+                    // `!` is a ZST and we want to validate it.\n+                    // Normalize before handing `place` to tracking because that will\n+                    // check for duplicates.\n+                    let place = self.ecx.normalize_mplace_ptr(place)?;\n                     let path = &self.path;\n                     ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n@@ -548,7 +550,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.sty {\n             ty::Str => {\n-                let mplace = op.to_mem_place(); // strings are never immediate\n+                let mplace = op.assert_mem_place(); // strings are never immediate\n                 try_validation!(self.ecx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\", self.path);\n             }\n@@ -565,7 +567,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     return Ok(());\n                 }\n                 // non-ZST array cannot be immediate, slices are never immediate\n-                let mplace = op.to_mem_place();\n+                let mplace = op.assert_mem_place();\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // zero length slices have nothing to be checked\n@@ -576,8 +578,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let ty_size = self.ecx.layout_of(tys)?.size;\n                 // This is the size in bytes of the whole array.\n                 let size = ty_size * len;\n-\n-                let ptr = self.ecx.force_ptr(mplace.ptr)?;\n+                // Size is not 0, get a pointer (no cast because we normalized in validate_operand).\n+                let ptr = mplace.ptr.assert_ptr();\n \n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n@@ -633,7 +635,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n     /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n-    /// specific validation checks\n+    /// specific validation checks.\n     pub fn validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -653,6 +655,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // Run it\n+        let op = self.normalize_op_ptr(op)?; // avoid doing ptr-to-int all the time\n         visitor.visit_value(op)\n     }\n }"}, {"sha": "91fbd307db12123e04108f0066eb37877ea20e28", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9007296a202b62f26aaa66393cefd93e731b9602/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=9007296a202b62f26aaa66393cefd93e731b9602", "patch": "@@ -242,7 +242,7 @@ macro_rules! make_value_visitor {\n                 match v.layout().ty.sty {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.to_mem_place();\n+                        let dest = v.to_op(self.ecx())?.assert_mem_place();\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -316,7 +316,7 @@ macro_rules! make_value_visitor {\n                             MPlaceTy::dangling(v.layout(), self.ecx())\n                         } else {\n                             // non-ZST array/slice/str cannot be immediate\n-                            v.to_op(self.ecx())?.to_mem_place()\n+                            v.to_op(self.ecx())?.assert_mem_place()\n                         };\n                         // Now we can go over all the fields.\n                         let iter = self.ecx().mplace_array_fields(mplace)?"}]}