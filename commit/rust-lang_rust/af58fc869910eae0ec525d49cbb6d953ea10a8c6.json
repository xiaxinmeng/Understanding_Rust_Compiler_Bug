{"sha": "af58fc869910eae0ec525d49cbb6d953ea10a8c6", "node_id": "C_kwDOAAsO6NoAKGFmNThmYzg2OTkxMGVhZTBlYzUyNWQ0OWNiYjZkOTUzZWExMGE4YzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T15:29:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T15:29:59Z"}, "message": "Auto merge of #101947 - aliemjay:astconv-normalize, r=lcnr\n\nDon't normalize in AstConv\n\nSee individual commits.\n\nFixes #101350\nFixes #54940", "tree": {"sha": "68bda15813c499969b94bcf6dd966a61f214e839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68bda15813c499969b94bcf6dd966a61f214e839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af58fc869910eae0ec525d49cbb6d953ea10a8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af58fc869910eae0ec525d49cbb6d953ea10a8c6", "html_url": "https://github.com/rust-lang/rust/commit/af58fc869910eae0ec525d49cbb6d953ea10a8c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af58fc869910eae0ec525d49cbb6d953ea10a8c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e0576bd3aec2f1acf935b353900bd75742860b", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e0576bd3aec2f1acf935b353900bd75742860b", "html_url": "https://github.com/rust-lang/rust/commit/89e0576bd3aec2f1acf935b353900bd75742860b"}, {"sha": "bf228ace5cf6824078d6d36144ad8a65f07fa8d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf228ace5cf6824078d6d36144ad8a65f07fa8d3", "html_url": "https://github.com/rust-lang/rust/commit/bf228ace5cf6824078d6d36144ad8a65f07fa8d3"}], "stats": {"total": 1685, "additions": 1182, "deletions": 503}, "files": [{"sha": "02222c0a03cb350f9dcfdebc2b963db3f1edfcd5", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,13 +1,13 @@\n use std::fmt;\n \n-use rustc_infer::infer::canonical::Canonical;\n-use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::infer::{canonical::Canonical, InferOk};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n-use rustc_trait_selection::traits::query::Fallible;\n+use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n \n use crate::diagnostics::{ToUniverseInfo, UniverseInfo};\n \n@@ -177,4 +177,74 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             value\n         })\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        // FIXME: Ideally MIR types are normalized, but this is not always true.\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(mir_ty, user_ty)),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n+\n+    /// *Incorrectly* skips the WF checks we normally do in `ascribe_user_type`.\n+    ///\n+    /// FIXME(#104478, #104477): This is a hack for backward-compatibility.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type_skip_wf(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        let ty::UserType::Ty(user_ty) = user_ty else { bug!() };\n+\n+        // A fast path for a common case with closure input/output types.\n+        if let ty::Infer(_) = user_ty.kind() {\n+            self.eq_types(user_ty, mir_ty, Locations::All(span), ConstraintCategory::Boring)\n+                .unwrap();\n+            return;\n+        }\n+\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+        let cause = ObligationCause::dummy_with_span(span);\n+        let param_env = self.param_env;\n+        let op = |infcx: &'_ _| {\n+            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+            let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+            ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n+            if !ocx.select_all_or_error().is_empty() {\n+                return Err(NoSolution);\n+            }\n+            Ok(InferOk { value: (), obligations: vec![] })\n+        };\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            type_op::custom::CustomTypeOp::new(op, || \"ascribe_user_type_skip_wf\".to_string()),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type_skip_wf `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n }"}, {"sha": "fa9ea769a14f79607e86c7d69dafbec2216b5c1a", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 47, "deletions": 79, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -10,14 +10,60 @@\n use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n \n use crate::universal_regions::UniversalRegions;\n \n use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Check explicit closure signature annotation,\n+    /// e.g., `|x: FxHashMap<_, &'static u32>| ...`.\n+    #[instrument(skip(self, body), level = \"debug\")]\n+    pub(super) fn check_signature_annotation(&mut self, body: &Body<'tcx>) {\n+        let mir_def_id = body.source.def_id().expect_local();\n+        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n+            return;\n+        }\n+        let Some(user_provided_poly_sig) =\n+            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n+        else {\n+            return;\n+        };\n+\n+        // Instantiate the canonicalized variables from user-provided signature\n+        // (e.g., the `_` in the code above) with fresh variables.\n+        // Then replace the bound items in the fn sig with fresh variables,\n+        // so that they represent the view from \"inside\" the closure.\n+        let user_provided_sig = self\n+            .instantiate_canonical_with_fresh_inference_vars(body.span, &user_provided_poly_sig);\n+        let user_provided_sig = self.infcx.replace_bound_vars_with_fresh_vars(\n+            body.span,\n+            LateBoundRegionConversionTime::FnCall,\n+            user_provided_sig,\n+        );\n+\n+        for (&user_ty, arg_decl) in user_provided_sig.inputs().iter().zip(\n+            // In MIR, closure args begin with an implicit `self`. Skip it!\n+            body.args_iter().skip(1).map(|local| &body.local_decls[local]),\n+        ) {\n+            self.ascribe_user_type_skip_wf(\n+                arg_decl.ty,\n+                ty::UserType::Ty(user_ty),\n+                arg_decl.source_info.span,\n+            );\n+        }\n+\n+        // If the user explicitly annotated the output type, enforce it.\n+        let output_decl = &body.local_decls[RETURN_PLACE];\n+        self.ascribe_user_type_skip_wf(\n+            output_decl.ty,\n+            ty::UserType::Ty(user_provided_sig.output()),\n+            output_decl.source_info.span,\n+        );\n+    }\n+\n     #[instrument(skip(self, body, universal_regions), level = \"debug\")]\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n@@ -31,39 +77,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?normalized_output_ty);\n         debug!(?normalized_input_tys);\n \n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        // If the user explicitly annotated the input types, extract\n-        // those.\n-        //\n-        // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n-        let user_provided_sig = if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n-            None\n-        } else {\n-            let typeck_results = self.tcx().typeck(mir_def_id);\n-\n-            typeck_results.user_provided_sigs.get(&mir_def_id).map(|user_provided_poly_sig| {\n-                // Instantiate the canonicalized variables from\n-                // user-provided signature (e.g., the `_` in the code\n-                // above) with fresh variables.\n-                let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n-                    body.span,\n-                    &user_provided_poly_sig,\n-                );\n-\n-                // Replace the bound items in the fn sig with fresh\n-                // variables, so that they represent the view from\n-                // \"inside\" the closure.\n-                self.infcx.replace_bound_vars_with_fresh_vars(\n-                    body.span,\n-                    LateBoundRegionConversionTime::FnCall,\n-                    poly_sig,\n-                )\n-            })\n-        };\n-\n-        debug!(?normalized_input_tys, ?body.local_decls);\n-\n         // Equate expected input tys with those in the MIR.\n         for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n             if argument_index + 1 >= body.local_decls.len() {\n@@ -86,28 +99,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             );\n         }\n \n-        if let Some(user_provided_sig) = user_provided_sig {\n-            for (argument_index, &user_provided_input_ty) in\n-                user_provided_sig.inputs().iter().enumerate()\n-            {\n-                // In MIR, closures begin an implicit `self`, so\n-                // argument N is stored in local N+2.\n-                let local = Local::new(argument_index + 2);\n-                let mir_input_ty = body.local_decls[local].ty;\n-                let mir_input_span = body.local_decls[local].source_info.span;\n-\n-                // If the user explicitly annotated the input types, enforce those.\n-                let user_provided_input_ty =\n-                    self.normalize(user_provided_input_ty, Locations::All(mir_input_span));\n-\n-                self.equate_normalized_input_or_output(\n-                    user_provided_input_ty,\n-                    mir_input_ty,\n-                    mir_input_span,\n-                );\n-            }\n-        }\n-\n         debug!(\n             \"equate_inputs_and_outputs: body.yield_ty {:?}, universal_regions.yield_ty {:?}\",\n             body.yield_ty(),\n@@ -153,29 +144,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 terr\n             );\n         };\n-\n-        // If the user explicitly annotated the output types, enforce those.\n-        // Note that this only happens for closures.\n-        if let Some(user_provided_sig) = user_provided_sig {\n-            let user_provided_output_ty = user_provided_sig.output();\n-            let user_provided_output_ty =\n-                self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_types(\n-                user_provided_output_ty,\n-                mir_output_ty,\n-                Locations::All(output_span),\n-                ConstraintCategory::BoringNoLocation,\n-            ) {\n-                span_mirbug!(\n-                    self,\n-                    Location::START,\n-                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    mir_output_ty,\n-                    user_provided_output_ty,\n-                    err\n-                );\n-            }\n-        }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "8778a19eeda1bf37080e516c9816889ff9e3c74e", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -38,7 +38,6 @@ use rustc_middle::ty::{\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -197,6 +196,8 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     }\n \n     checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    checker.check_signature_annotation(&body);\n+\n     liveness::generate(\n         &mut checker,\n         body,\n@@ -391,23 +392,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         check_err(self, promoted_body, ty, promoted_ty);\n                     }\n                 } else {\n-                    if let Err(terr) = self.cx.fully_perform_op(\n-                        locations,\n-                        ConstraintCategory::Boring,\n-                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            constant.literal.ty(),\n+                    self.cx.ascribe_user_type(\n+                        constant.literal.ty(),\n+                        UserType::TypeOf(\n                             uv.def.did,\n                             UserSubsts { substs: uv.substs, user_self_ty: None },\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            constant,\n-                            \"bad constant type {:?} ({:?})\",\n-                            constant,\n-                            terr\n-                        );\n-                    }\n+                        ),\n+                        locations.span(&self.cx.body),\n+                    );\n                 }\n             } else if let Some(static_def_id) = constant.check_static_ptr(tcx) {\n                 let unnormalized_ty = tcx.type_of(static_def_id);\n@@ -1041,58 +1033,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n-            debug!(?annotation);\n-            match annotation {\n-                UserType::Ty(mut ty) => {\n-                    ty = self.normalize(ty, Locations::All(span));\n-\n-                    if let Err(terr) = self.eq_types(\n-                        ty,\n-                        inferred_ty,\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type ({:?} = {:?}): {:?}\",\n-                            ty,\n-                            inferred_ty,\n-                            terr\n-                        );\n-                    }\n-\n-                    self.prove_predicate(\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(inferred_ty.into())),\n-                        Locations::All(span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    );\n-                }\n-                UserType::TypeOf(def_id, user_substs) => {\n-                    if let Err(terr) = self.fully_perform_op(\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                        self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type AscribeUserType({:?}, {:?} {:?}, type_of={:?}): {:?}\",\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                            self.tcx().type_of(def_id),\n-                            terr,\n-                        );\n-                    }\n-                }\n-            }\n+            self.ascribe_user_type(inferred_ty, annotation, span);\n         }\n     }\n "}, {"sha": "5a7957be318ea642a19f9753af3ab1106f43b010", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -106,11 +106,12 @@ pub trait AstConv<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n-    /// Normalize an associated type coming from the user.\n-    ///\n-    /// This should only be used by astconv. Use `FnCtxt::normalize`\n-    /// or `ObligationCtxt::normalize` in downstream crates.\n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n+    /// Returns `AdtDef` if `ty` is an ADT.\n+    /// Note that `ty` might be a projection type that needs normalization.\n+    /// This used to get the enum variants in scope of the type.\n+    /// For example, `Self::A` could refer to an associated type\n+    /// or to an enum variant depending on the result of this function.\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>>;\n \n     /// Invoked when we encounter an error from some prior pass\n     /// (e.g., resolve) that is translated into a ty-error. This is\n@@ -485,14 +486,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n                                 return tcx.ty_error().into();\n                             }\n-                            self.astconv\n-                                .normalize_ty(\n-                                    self.span,\n-                                    tcx.at(self.span)\n-                                        .bound_type_of(param.def_id)\n-                                        .subst(tcx, substs),\n-                                )\n-                                .into()\n+                            tcx.at(self.span).bound_type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n@@ -1267,7 +1261,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.normalize_ty(span, self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs))\n+        self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs)\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n@@ -1832,7 +1826,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n-    // Create a type from a path to an associated type.\n+    // Create a type from a path to an associated type or to an enum variant.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n@@ -1860,7 +1854,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, adt_substs) = qself_ty.kind() {\n+        if let Some(adt_def) = self.probe_adt(span, qself_ty) {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n@@ -1962,14 +1956,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n                     continue;\n                 };\n+                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n+                    // FIXME(inherent_associated_types)\n+                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n+                };\n                 let item_substs = self.create_substs_for_associated_item(\n                     span,\n                     assoc_ty_did,\n                     assoc_segment,\n                     adt_substs,\n                 );\n                 let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n-                let ty = self.normalize_ty(span, ty);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }\n@@ -2066,7 +2063,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         };\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, assoc_ty_did, assoc_segment, bound);\n-        let ty = self.normalize_ty(span, ty);\n \n         if let Some(variant_def_id) = variant_resolution {\n             tcx.struct_span_lint_hir(\n@@ -2202,7 +2198,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n+        tcx.mk_projection(item_def_id, item_substs)\n     }\n \n     pub fn prohibit_generics<'a>(\n@@ -2319,6 +2315,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Option<Ty<'tcx>>,\n         kind: DefKind,\n         def_id: DefId,\n+        span: Span,\n     ) -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n@@ -2386,8 +2383,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             // Case 2. Reference to a variant constructor.\n             DefKind::Ctor(CtorOf::Variant, ..) | DefKind::Variant => {\n-                let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n-                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                let (generics_def_id, index) = if let Some(self_ty) = self_ty {\n+                    let adt_def = self.probe_adt(span, self_ty).unwrap();\n                     debug_assert!(adt_def.is_enum());\n                     (adt_def.did(), last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n@@ -2463,7 +2460,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.note(\"`impl Trait` types can't have type parameters\");\n                 });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n-                self.normalize_ty(span, tcx.mk_opaque(did, substs))\n+                tcx.mk_opaque(did, substs)\n             }\n             Res::Def(\n                 DefKind::Enum\n@@ -2483,7 +2480,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n \n                 let path_segs =\n-                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n+                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id, span);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics(\n@@ -2623,7 +2620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     tcx.ty_error_with_guaranteed(err.emit())\n                 } else {\n-                    self.normalize_ty(span, ty)\n+                    ty\n                 }\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n@@ -2766,8 +2763,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     None,\n                     ty::BoundConstness::NotConst,\n                 );\n-                EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n-                    .subst(tcx, substs)\n+                EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length = match length {\n@@ -2777,8 +2773,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length));\n-                self.normalize_ty(ast_ty.span, array_ty)\n+                tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n             hir::TyKind::Typeof(ref e) => {\n                 let ty_erased = tcx.type_of(e.def_id);"}, {"sha": "b7f259668a1e48f005761958a12947e6986d77ea", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -505,9 +505,9 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn normalize_ty(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        // Types in item signatures are not normalized to avoid undue dependencies.\n-        ty\n+    fn probe_adt(&self, _span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        // FIXME(#103640): Should we handle the case where `ty` is a projection?\n+        ty.ty_adt_def()\n     }\n \n     fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {"}, {"sha": "399702fd41abcdabbeb055e5629452d6ddc3f0e8", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -647,14 +647,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ),\n             bound_vars,\n         );\n-        // Astconv can't normalize inputs or outputs with escaping bound vars,\n-        // so normalize them here, after we've wrapped them in a binder.\n-        let result = self.normalize(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n-        result\n+        // Normalize only after registering in `user_provided_sigs`.\n+        self.normalize(self.tcx.hir().span(hir_id), result)\n     }\n \n     /// Invoked when we are translating the generator that results"}, {"sha": "b7681d108ed01febb082121e5589dec25f117770", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 63, "deletions": 76, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,7 +1,7 @@\n use crate::callee::{self, DeferredCallResolution};\n use crate::method::{self, MethodCallee, SelfSource};\n use crate::rvalue_scopes;\n-use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n+use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, RawTy};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -24,7 +24,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, UserType,\n };\n-use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n+use rustc_middle::ty::{GenericArgKind, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n@@ -161,47 +161,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_method_call(&self, hir_id: hir::HirId, method: MethodCallee<'tcx>) {\n         self.write_resolution(hir_id, Ok((DefKind::AssocFn, method.def_id)));\n         self.write_substs(hir_id, method.substs);\n-\n-        // When the method is confirmed, the `method.substs` includes\n-        // parameters from not just the method, but also the impl of\n-        // the method -- in particular, the `Self` type will be fully\n-        // resolved. However, those are not something that the \"user\n-        // specified\" -- i.e., those types come from the inferred type\n-        // of the receiver, not something the user wrote. So when we\n-        // create the user-substs, we want to replace those earlier\n-        // types with just the types that the user actually wrote --\n-        // that is, those that appear on the *method itself*.\n-        //\n-        // As an example, if the user wrote something like\n-        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n-        // type of `foo` (possibly adjusted), but we don't want to\n-        // include that. We want just the `[_, u32]` part.\n-        if !method.substs.is_empty() {\n-            let method_generics = self.tcx.generics_of(method.def_id);\n-            if !method_generics.params.is_empty() {\n-                let user_type_annotation = self.probe(|_| {\n-                    let user_substs = UserSubsts {\n-                        substs: InternalSubsts::for_item(self.tcx, method.def_id, |param, _| {\n-                            let i = param.index as usize;\n-                            if i < method_generics.parent_count {\n-                                self.var_for_def(DUMMY_SP, param)\n-                            } else {\n-                                method.substs[i]\n-                            }\n-                        }),\n-                        user_self_ty: None, // not relevant here\n-                    };\n-\n-                    self.canonicalize_user_type_annotation(UserType::TypeOf(\n-                        method.def_id,\n-                        user_substs,\n-                    ))\n-                });\n-\n-                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n-                self.write_user_type_annotation(hir_id, user_type_annotation);\n-            }\n-        }\n     }\n \n     pub fn write_substs(&self, node_id: hir::HirId, substs: SubstsRef<'tcx>) {\n@@ -410,23 +369,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n+    pub fn handle_raw_ty(&self, span: Span, ty: Ty<'tcx>) -> RawTy<'tcx> {\n+        RawTy { raw: ty, normalized: self.normalize(span, ty) }\n+    }\n+\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> RawTy<'tcx> {\n         let t = <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t.into(), ast_t.span, traits::WellFormed(None));\n-        t\n+        self.handle_raw_ty(ast_t.span, t)\n     }\n \n     pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.canonicalize_response(UserType::Ty(ty));\n+        if Self::can_contain_user_lifetime_bounds(ty.raw) {\n+            let c_ty = self.canonicalize_response(UserType::Ty(ty.raw));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n-        ty\n+        ty.normalized\n+    }\n+\n+    pub(super) fn user_substs_for_adt(ty: RawTy<'tcx>) -> UserSubsts<'tcx> {\n+        match (ty.raw.kind(), ty.normalized.kind()) {\n+            (ty::Adt(_, substs), _) => UserSubsts { substs, user_self_ty: None },\n+            (_, ty::Adt(adt, substs)) => UserSubsts {\n+                substs,\n+                user_self_ty: Some(UserSelfTy { impl_def_id: adt.did(), self_ty: ty.raw }),\n+            },\n+            _ => bug!(\"non-adt type {:?}\", ty),\n+        }\n     }\n \n     pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> ty::Const<'tcx> {\n@@ -780,7 +754,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n+    ) -> (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\n             \"resolve_ty_and_res_fully_qualified_call: qpath={:?} hir_id={:?} span={:?}\",\n             qpath, hir_id, span\n@@ -803,23 +777,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // to be object-safe.\n                 // We manually call `register_wf_obligation` in the success path\n                 // below.\n-                (<dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself), qself, segment)\n+                let ty = <dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself);\n+                (self.handle_raw_ty(span, ty), qself, segment)\n             }\n             QPath::LangItem(..) => {\n                 bug!(\"`resolve_ty_and_res_fully_qualified_call` called on `LangItem`\")\n             }\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             let def = cached_result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id));\n             return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n         let result = self\n-            .resolve_fully_qualified_call(span, item_name, ty, qself.span, hir_id)\n+            .resolve_fully_qualified_call(span, item_name, ty.normalized, qself.span, hir_id)\n             .or_else(|error| {\n                 let result = match error {\n                     method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n@@ -830,13 +805,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // a WF obligation for `dyn MyTrait` when method lookup fails. Otherwise,\n                 // register a WF obligation so that we can detect any additional\n                 // errors in the self type.\n-                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.is_trait()) {\n-                    self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.normalized.is_trait()) {\n+                    self.register_wf_obligation(\n+                        ty.raw.into(),\n+                        qself.span,\n+                        traits::WellFormed(None),\n+                    );\n                 }\n                 if item_name.name != kw::Empty {\n                     if let Some(mut e) = self.report_method_error(\n                         span,\n-                        ty,\n+                        ty.normalized,\n                         item_name,\n                         SelfSource::QPath(qself),\n                         error,\n@@ -849,7 +828,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         if result.is_ok() {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n         }\n \n         // Write back the new resolution.\n@@ -986,7 +965,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn instantiate_value_path(\n         &self,\n         segments: &[hir::PathSegment<'_>],\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Option<RawTy<'tcx>>,\n         res: Res,\n         span: Span,\n         hir_id: hir::HirId,\n@@ -996,7 +975,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let path_segs = match res {\n             Res::Local(_) | Res::SelfCtor(_) => vec![],\n             Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n-                self, segments, self_ty, kind, def_id,\n+                self,\n+                segments,\n+                self_ty.map(|ty| ty.raw),\n+                kind,\n+                def_id,\n+                span,\n             ),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n         };\n@@ -1007,8 +991,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Def(DefKind::Ctor(CtorOf::Variant, _), _)\n                 if let Some(self_ty) = self_ty =>\n             {\n-                let adt_def = self_ty.ty_adt_def().unwrap();\n-                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty });\n+                let adt_def = self_ty.normalized.ty_adt_def().unwrap();\n+                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty: self_ty.raw });\n                 is_alias_variant_ctor = true;\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n@@ -1027,7 +1011,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inherent impl, we need to record the\n                             // `T` for posterity (see `UserSelfTy` for\n                             // details).\n-                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\").raw;\n                             user_self_ty = Some(UserSelfTy { impl_def_id: container_id, self_ty });\n                         }\n                     }\n@@ -1109,19 +1093,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n-            match *ty.kind() {\n-                ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    let (ctor_kind, ctor_def_id) = variant.ctor.unwrap();\n-                    (Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id), Some(substs))\n+            let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id));\n+            match ty.normalized.ty_adt_def() {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let (ctor_kind, ctor_def_id) = adt_def.non_enum_variant().ctor.unwrap();\n+                    let new_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n+                    let user_substs = Self::user_substs_for_adt(ty);\n+                    user_self_ty = user_substs.user_self_ty;\n+                    (new_res, Some(user_substs.substs))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(\n                         span,\n                         \"the `Self` constructor can only be used with tuple or unit structs\",\n                     );\n-                    if let Some(adt_def) = ty.ty_adt_def() {\n+                    if let Some(adt_def) = ty.normalized.ty_adt_def() {\n                         match adt_def.adt_kind() {\n                             AdtKind::Enum => {\n                                 err.help(\"did you mean to use one of the enum's variants?\");\n@@ -1193,7 +1179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         <dyn AstConv<'_>>::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.fcx.to_ty(ty).into()\n+                        self.fcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.fcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -1225,10 +1211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            let default = tcx.bound_type_of(param.def_id);\n-                            self.fcx\n-                                .normalize_ty(self.span, default.subst(tcx, substs.unwrap()))\n-                                .into()\n+                            tcx.bound_type_of(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n@@ -1250,13 +1233,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let substs = self_ctor_substs.unwrap_or_else(|| {\n+        let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n             <dyn AstConv<'_>>::create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],\n                 has_self,\n-                self_ty,\n+                self_ty.map(|s| s.raw),\n                 &arg_count,\n                 &mut CreateCtorSubstsContext {\n                     fcx: self,\n@@ -1269,7 +1252,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         // First, store the \"user substs\" for later.\n-        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs_raw, user_self_ty);\n+\n+        // Normalize only after registering type annotations.\n+        let substs = self.normalize(span, substs_raw);\n \n         self.add_required_obligations_for_hir(span, def_id, &substs, hir_id);\n \n@@ -1287,6 +1273,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // with the substituted impl type.\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.bound_type_of(impl_def_id).subst(tcx, substs));\n+            let self_ty = self.normalize(span, self_ty);\n             match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {"}, {"sha": "da411d0642e728d5aa0065d8e59a6ea2a67f92c2", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -5,7 +5,7 @@ use crate::method::MethodCallee;\n use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n use crate::{\n-    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs,\n+    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n };\n use rustc_ast as ast;\n@@ -1231,31 +1231,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 return None;\n             }\n-            Res::Def(DefKind::Variant, _) => match ty.kind() {\n-                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did(), substs)),\n-                _ => bug!(\"unexpected type: {:?}\", ty),\n+            Res::Def(DefKind::Variant, _) => match ty.normalized.ty_adt_def() {\n+                Some(adt) => {\n+                    Some((adt.variant_of_res(def), adt.did(), Self::user_substs_for_adt(ty)))\n+                }\n+                _ => bug!(\"unexpected type: {:?}\", ty.normalized),\n             },\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n             | Res::SelfTyParam { .. }\n-            | Res::SelfTyAlias { .. } => match ty.kind() {\n-                ty::Adt(adt, substs) if !adt.is_enum() => {\n-                    Some((adt.non_enum_variant(), adt.did(), substs))\n+            | Res::SelfTyAlias { .. } => match ty.normalized.ty_adt_def() {\n+                Some(adt) if !adt.is_enum() => {\n+                    Some((adt.non_enum_variant(), adt.did(), Self::user_substs_for_adt(ty)))\n                 }\n                 _ => None,\n             },\n             _ => bug!(\"unexpected definition: {:?}\", def),\n         };\n \n-        if let Some((variant, did, substs)) = variant {\n+        if let Some((variant, did, ty::UserSubsts { substs, user_self_ty })) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n+\n+            // Register type annotation.\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, user_self_ty);\n \n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty))\n+            Some((variant, ty.normalized))\n         } else {\n-            match ty.kind() {\n+            match ty.normalized.kind() {\n                 ty::Error(_) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n@@ -1268,7 +1272,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         path_span,\n                         E0071,\n                         \"expected struct, variant or union type, found {}\",\n-                        ty.sort_string(self.tcx)\n+                        ty.normalized.sort_string(self.tcx)\n                     )\n                     .span_label(path_span, \"not a struct\")\n                     .emit();\n@@ -1656,20 +1660,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &QPath<'_>,\n         path_span: Span,\n         hir_id: hir::HirId,\n-    ) -> (Res, Ty<'tcx>) {\n+    ) -> (Res, RawTy<'tcx>) {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n-                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n                 let ty = <dyn AstConv<'_>>::res_to_ty(self, self_ty, path, true);\n-                (path.res, ty)\n+                (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n                 let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, qself, segment, true,\n+                    self, hir_id, path_span, ty.raw, qself, segment, true,\n                 );\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n@@ -1678,7 +1683,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)), ty)\n             }\n             QPath::LangItem(lang_item, span, id) => {\n-                self.resolve_lang_item_path(lang_item, span, hir_id, id)\n+                let (res, ty) = self.resolve_lang_item_path(lang_item, span, hir_id, id);\n+                (res, self.handle_raw_ty(path_span, ty))\n             }\n         }\n     }"}, {"sha": "6347b9a69a0077906a78c12b1f1cce0be753ba85", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -17,8 +17,7 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitable};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n@@ -298,19 +297,36 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().mk_projection(item_def_id, item_substs)\n     }\n \n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_bound_vars() {\n-            ty // FIXME: normalization and escaping regions\n-        } else {\n-            self.normalize(span, ty)\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) => Some(*adt_def),\n+            // FIXME(#104767): Should we handle bound regions here?\n+            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+                self.normalize(span, ty).ty_adt_def()\n+            }\n+            _ => None,\n         }\n     }\n \n     fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n         self.infcx.set_tainted_by_errors(e)\n     }\n \n-    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span) {\n+        // FIXME: normalization and escaping regions\n+        let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n         self.write_ty(hir_id, ty)\n     }\n }\n+\n+/// Represents a user-provided type in the raw form (never normalized).\n+///\n+/// This is a bridge between the interface of `AstConv`, which outputs a raw `Ty`,\n+/// and the API in this module, which expect `Ty` to be fully normalized.\n+#[derive(Clone, Copy, Debug)]\n+pub struct RawTy<'tcx> {\n+    pub raw: Ty<'tcx>,\n+\n+    /// The normalized form of `raw`, stored here for efficiency.\n+    pub normalized: Ty<'tcx>,\n+}"}, {"sha": "15dd3412c34093e062eb5b74aa36a77fd5a3010a", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -77,15 +77,16 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty));\n+                let c_ty =\n+                    self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty.raw));\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n                 self.fcx\n                     .typeck_results\n                     .borrow_mut()\n                     .user_provided_types_mut()\n                     .insert(ty.hir_id, c_ty);\n \n-                Some(LocalTy { decl_ty: o_ty, revealed_ty: o_ty })\n+                Some(LocalTy { decl_ty: o_ty.normalized, revealed_ty: o_ty.normalized })\n             }\n             None => None,\n         };"}, {"sha": "69929589541f5e0de0078c64806dc79bea8cdb96", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -297,7 +297,7 @@ fn typeck_with_fallback<'tcx>(\n         fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize_ty(span, ty);\n+            let ty = fcx.normalize(span, ty);\n             fcx.require_type_is_sized(ty, span, code);\n         }\n "}, {"sha": "a2c6e246610b21c391782f20d40593437b5f8272", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -12,7 +12,8 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{self, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n-use rustc_span::Span;\n+use rustc_middle::ty::{InternalSubsts, UserSubsts, UserType};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits;\n \n use std::iter;\n@@ -372,7 +373,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                             .into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.cfcx.to_ty(ty).into()\n+                        self.cfcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.cfcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -397,15 +398,56 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.cfcx.var_for_def(self.cfcx.span, param)\n             }\n         }\n-        <dyn AstConv<'_>>::create_substs_for_generic_args(\n+\n+        let substs = <dyn AstConv<'_>>::create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,\n             false,\n             None,\n             &arg_count_correct,\n             &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n-        )\n+        );\n+\n+        // When the method is confirmed, the `substs` includes\n+        // parameters from not just the method, but also the impl of\n+        // the method -- in particular, the `Self` type will be fully\n+        // resolved. However, those are not something that the \"user\n+        // specified\" -- i.e., those types come from the inferred type\n+        // of the receiver, not something the user wrote. So when we\n+        // create the user-substs, we want to replace those earlier\n+        // types with just the types that the user actually wrote --\n+        // that is, those that appear on the *method itself*.\n+        //\n+        // As an example, if the user wrote something like\n+        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n+        // type of `foo` (possibly adjusted), but we don't want to\n+        // include that. We want just the `[_, u32]` part.\n+        if !substs.is_empty() && !generics.params.is_empty() {\n+            let user_type_annotation = self.probe(|_| {\n+                let user_substs = UserSubsts {\n+                    substs: InternalSubsts::for_item(self.tcx, pick.item.def_id, |param, _| {\n+                        let i = param.index as usize;\n+                        if i < generics.parent_count {\n+                            self.fcx.var_for_def(DUMMY_SP, param)\n+                        } else {\n+                            substs[i]\n+                        }\n+                    }),\n+                    user_self_ty: None, // not relevant here\n+                };\n+\n+                self.fcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+                    pick.item.def_id,\n+                    user_substs,\n+                ))\n+            });\n+\n+            debug!(\"instantiate_method_substs: user_type_annotation={:?}\", user_type_annotation);\n+            self.fcx.write_user_type_annotation(self.call_expr.hir_id, user_type_annotation);\n+        }\n+\n+        self.normalize(self.span, substs)\n     }\n \n     fn unify_receivers("}, {"sha": "1075378a1595549b4fcef2d7f208406ebd576633", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,4 +1,4 @@\n-use crate::FnCtxt;\n+use crate::{FnCtxt, RawTy};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -842,7 +842,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n+        path_resolution: (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {"}, {"sha": "543f5b87e00bccd3a0c887f9c06f31ce3149f923", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -15,22 +15,19 @@ use rustc_span::source_map::Span;\n \n pub mod type_op {\n     use crate::ty::fold::TypeFoldable;\n-    use crate::ty::subst::UserSubsts;\n-    use crate::ty::{Predicate, Ty};\n-    use rustc_hir::def_id::DefId;\n+    use crate::ty::{Predicate, Ty, UserType};\n     use std::fmt;\n \n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, Lift)]\n     #[derive(TypeFoldable, TypeVisitable)]\n     pub struct AscribeUserType<'tcx> {\n         pub mir_ty: Ty<'tcx>,\n-        pub def_id: DefId,\n-        pub user_substs: UserSubsts<'tcx>,\n+        pub user_ty: UserType<'tcx>,\n     }\n \n     impl<'tcx> AscribeUserType<'tcx> {\n-        pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n-            Self { mir_ty, def_id, user_substs }\n+        pub fn new(mir_ty: Ty<'tcx>, user_ty: UserType<'tcx>) -> Self {\n+            Self { mir_ty, user_ty }\n         }\n     }\n "}, {"sha": "bc7895c39707a6125006489697673f3e8cad45d3", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -679,7 +679,7 @@ impl<'tcx> CanonicalUserType<'tcx> {\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Eq, Hash, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "aa5c83ac2e6557cd98e40f7d29cbc18db5a99853", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -4,8 +4,8 @@ use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n-use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n-use rustc_middle::ty::{UserSelfTy, UserSubsts};\n+use rustc_middle::ty::{ParamEnvAnd, Predicate};\n+use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n@@ -50,13 +50,46 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n ) -> Result<(), NoSolution> {\n-    let (param_env, AscribeUserType { mir_ty, def_id, user_substs }) = key.into_parts();\n-    debug!(\n-        \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n-        mir_ty, def_id, user_substs\n-    );\n+    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n+    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n     let span = span.unwrap_or(DUMMY_SP);\n+    match user_ty {\n+        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n+        UserType::TypeOf(def_id, user_substs) => {\n+            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n+        }\n+    };\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_ty<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    user_ty: Ty<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let cause = ObligationCause::dummy_with_span(span);\n+    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n \n+    // FIXME(#104764): We should check well-formedness before normalization.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n+\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_substs<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    def_id: hir::def_id::DefId,\n+    user_substs: UserSubsts<'tcx>,\n+) -> Result<(), NoSolution> {\n     let UserSubsts { user_self_ty, substs } = user_substs;\n     let tcx = ocx.infcx.tcx;\n     let cause = ObligationCause::dummy_with_span(span);\n@@ -91,13 +124,13 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     }\n \n     if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n         let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n         let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n \n-        let predicate: Predicate<'tcx> =\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into())).to_predicate(tcx);\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n         ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n \n@@ -112,8 +145,7 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     // them?  This would only be relevant if some input\n     // type were ill-formed but did not appear in `ty`,\n     // which...could happen with normalization...\n-    let predicate: Predicate<'tcx> =\n-        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx);\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n     ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n     Ok(())\n }"}, {"sha": "adc0cb4e0423f2e5db414a7a649e0eea3c3e95d5", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -14,14 +14,6 @@ fn foo<T>() {\n     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n     //~^ ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` may not live long enough\n-    //~| ERROR `T` may not live long enough\n     //\n     // FIXME: This error is bogus, but it arises because we try to validate\n     // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving"}, {"sha": "d9d76adfbb55280b154fd576501b4b9fccc7f96a", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -10,64 +10,5 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:12\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:12\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | fn foo<T: 'static>() {\n-   |         +++++++++\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | fn foo<T: 'static>() {\n-   |         +++++++++\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: aborting due to 10 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0310`."}, {"sha": "8aa29926d4f9b2b15ca0f6dbdecdb7dd6b989b42", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -7,6 +7,7 @@ trait SomeTrait<'a> {\n fn give_me_ice<T>() {\n     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n     //~^ ERROR the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied [E0277]\n+    //~| ERROR the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied [E0277]\n }\n \n fn callee<T: Fn<(&'static (),)>>() {"}, {"sha": "3240518fbbe0808447ca8fe4f15ed5fca7e24efa", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,3 +1,14 @@\n+error[E0277]: the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied\n+  --> $DIR/issue-85455.rs:8:14\n+   |\n+LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> SomeTrait<'a>` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn give_me_ice<T: for<'a> SomeTrait<'a>>() {\n+   |                 +++++++++++++++++++++++\n+\n error[E0277]: the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied\n   --> $DIR/issue-85455.rs:8:5\n    |\n@@ -9,6 +20,6 @@ help: consider restricting type parameter `T`\n LL | fn give_me_ice<T: for<'a> SomeTrait<'a>>() {\n    |                 +++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "260c16c17d4a2b8c662abc1f27c47be07072b727", "filename": "src/test/ui/nll/closure-malformed-projection-input-issue-102800.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -16,16 +16,6 @@ impl Trait for &'static () {\n \n fn main() {\n     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-    //~^ ERROR lifetime may not live long enough\n-    //~| ERROR higher-ranked subtype error\n-    //~| ERROR higher-ranked subtype error\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n+    //~^ ERROR implementation of `Trait` is not general enough\n     //~| ERROR implementation of `Trait` is not general enough\n }"}, {"sha": "46dba0064339ff783c19d7229a80afe878565d53", "filename": "src/test/ui/nll/closure-malformed-projection-input-issue-102800.stderr", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,51 +1,3 @@\n-error: lifetime may not live long enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^-^\n-   |                                                ||\n-   |                                                |has type `<&'1 () as Trait>::Ty`\n-   |                                                requires that `'1` must outlive `'static`\n-\n-error: higher-ranked subtype error\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n error: implementation of `Trait` is not general enough\n   --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n    |\n@@ -64,41 +16,5 @@ LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n    = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n    = note: ...but `Trait` is actually implemented for the type `&'static ()`\n \n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: aborting due to 12 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "da3bc20832286aab2f63f8e0e2fc1e6b5e0febd6", "filename": "src/test/ui/nll/ty-outlives/wf-unreachable.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -5,7 +5,7 @@ LL | fn uninit<'a>() {\n    |           -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a ();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:11:12\n@@ -14,15 +14,15 @@ LL | fn var_type<'a>() {\n    |             -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a () = &&();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:15:12\n    |\n LL | fn uninit_infer<'a>() {\n    |                 -- lifetime `'a` defined here\n LL |     let x: &'static &'a _;\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:21:12\n@@ -31,7 +31,7 @@ LL | fn infer<'a>() {\n    |          -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a _ = &&();\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:26:12\n@@ -40,7 +40,7 @@ LL | fn uninit_no_var<'a>() {\n    |                  -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a ();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:31:12\n@@ -49,7 +49,7 @@ LL | fn no_var<'a>() {\n    |           -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a () = &&();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:36:12\n@@ -58,7 +58,7 @@ LL | fn infer_no_var<'a>() {\n    |                 -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a _ = &&();\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:49:12\n@@ -67,7 +67,7 @@ LL | fn required_substs<'a>() {\n    |                    -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: C<'static, 'a, _> = C((), &(), &());\n-   |            ^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "5db02c46ec36954a251626317b150f7f490c2096", "filename": "src/test/ui/nll/user-annotations/ascribed-type-wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,5 +1,5 @@\n-// check-pass\n-// known-bug: #101350\n+// Regression test for #101350.\n+// check-fail\n \n trait Trait {\n     type Ty;\n@@ -11,6 +11,7 @@ impl Trait for &'static () {\n \n fn extend<'a>() {\n     None::<<&'a () as Trait>::Ty>;\n+    //~^ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "91e7c6b8ecf1f2ca469e3f1c80d6d94cf63f9783", "filename": "src/test/ui/nll/user-annotations/ascribed-type-wf.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ascribed-type-wf.rs:13:5\n+   |\n+LL | fn extend<'a>() {\n+   |           -- lifetime `'a` defined here\n+LL |     None::<<&'a () as Trait>::Ty>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "4dbd3fd8d81e287c48cbee1c6fcc8d9594b42673", "filename": "src/test/ui/nll/user-annotations/closure-sig.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,15 @@\n+// This test fails if #104478 is fixed before #104477.\n+\n+// check-pass\n+\n+struct Printer<'a, 'b>(&'a (), &'b ());\n+\n+impl Printer<'_, '_> {\n+    fn test(self) {\n+        let clo = |_: &'_ Self| {};\n+        clo(&self);\n+        clo(&self);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "be23c3b747858fbb7c906089e5776750d7118c8d", "filename": "src/test/ui/nll/user-annotations/normalization-2.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,152 @@\n+// Make sure we honor region constraints when normalizing type annotations.\n+\n+// check-fail\n+\n+#![feature(more_qualified_paths)]\n+\n+trait Trait {\n+    type Assoc;\n+}\n+\n+impl<T> Trait for T\n+where\n+    T: 'static,\n+{\n+    type Assoc = MyTy<()>;\n+}\n+\n+enum MyTy<T> {\n+    Unit,\n+    Tuple(),\n+    Struct {},\n+    Dumb(T),\n+}\n+\n+impl<T> MyTy<T> {\n+    const CONST: () = ();\n+    fn method<X>() {}\n+    fn method2<X>(&self) {}\n+}\n+\n+trait TraitAssoc {\n+    const TRAIT_CONST: ();\n+    fn trait_method<X>(&self);\n+}\n+impl<T> TraitAssoc for T {\n+    const TRAIT_CONST: () = ();\n+    fn trait_method<X>(&self) {}\n+}\n+\n+type Ty<'a> = <&'a () as Trait>::Assoc;\n+\n+fn test_local<'a>() {\n+    let _: Ty<'a> = MyTy::Unit;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_closure_sig<'a, 'b>() {\n+    |_: Ty<'a>| {};\n+    //~^ ERROR lifetime may not live long enough\n+    || -> Option<Ty<'b>> { None };\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+    <Ty<'a>>::method::<Ty<'static>>;\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'static>>::method::<Ty<'b>>;\n+    //~^ ERROR lifetime may not live long enough\n+\n+    <Ty<'c>>::trait_method::<Ty<'static>>;\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'static>>::trait_method::<Ty<'d>>;\n+    //~^ ERROR lifetime may not live long enough\n+\n+    <Ty<'e>>::CONST;\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'f>>::TRAIT_CONST;\n+    //~^ ERROR lifetime may not live long enough\n+\n+    <Ty<'static>>::method::<Ty<'static>>;\n+    <Ty<'static>>::trait_method::<Ty<'static>>;\n+    <Ty<'static>>::CONST;\n+    <Ty<'static>>::TRAIT_CONST;\n+\n+    MyTy::Unit::<Ty<'g>>;\n+    //~^ ERROR lifetime may not live long enough\n+    MyTy::<Ty<'h>>::Unit;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_call<'a, 'b, 'c>() {\n+    <Ty<'a>>::method::<Ty<'static>>();\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'static>>::method::<Ty<'b>>();\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_variants<'a, 'b, 'c>() {\n+    <Ty<'a>>::Struct {};\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'b>>::Tuple();\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'c>>::Unit;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_method_call<'a, 'b>(x: MyTy<()>) {\n+    x.method2::<Ty<'a>>();\n+    //~^ ERROR lifetime may not live long enough\n+    x.trait_method::<Ty<'b>>();\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_struct_path<'a, 'b, 'c, 'd>() {\n+    struct Struct<T> { x: Option<T>, }\n+\n+    trait Project {\n+        type Struct;\n+        type Enum;\n+    }\n+    impl<T> Project for T {\n+        type Struct = Struct<()>;\n+        type Enum = MyTy<()>;\n+    }\n+\n+    // Resolves to enum variant\n+    MyTy::<Ty<'a>>::Struct {}; // without SelfTy\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'b> as Project>::Enum::Struct {}; // with SelfTy\n+    //~^ ERROR lifetime may not live long enough\n+\n+    // Resolves to struct and associated type respectively\n+    Struct::<Ty<'c>> { x: None, }; // without SelfTy\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'d> as Project>::Struct { x: None, }; // with SelfTy\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+    use MyTy::*;\n+    match MyTy::Unit {\n+        Struct::<Ty<'a>> {..} => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Tuple::<Ty<'b>> (..) => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Unit::<Ty<'c>> => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Dumb(_) => {},\n+    };\n+    match MyTy::Unit {\n+        <Ty<'d>>::Struct {..} => {},\n+        //~^ ERROR lifetime may not live long enough\n+        <Ty<'e>>::Tuple (..) => {},\n+        //~^ ERROR lifetime may not live long enough\n+        <Ty<'f>>::Unit => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Dumb(_) => {},\n+    };\n+}\n+\n+\n+fn main() {}"}, {"sha": "5299282ea151ed52eb69afeac079040e3ec90b79", "filename": "src/test/ui/nll/user-annotations/normalization-2.stderr", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,296 @@\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:43:12\n+   |\n+LL | fn test_local<'a>() {\n+   |               -- lifetime `'a` defined here\n+LL |     let _: Ty<'a> = MyTy::Unit;\n+   |            ^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:48:6\n+   |\n+LL | fn test_closure_sig<'a, 'b>() {\n+   |                     -- lifetime `'a` defined here\n+LL |     |_: Ty<'a>| {};\n+   |      ^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:50:11\n+   |\n+LL | fn test_closure_sig<'a, 'b>() {\n+   |                         -- lifetime `'b` defined here\n+...\n+LL |     || -> Option<Ty<'b>> { None };\n+   |           ^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:55:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |              -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::method::<Ty<'static>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:57:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                  -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'static>>::method::<Ty<'b>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:60:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                      -- lifetime `'c` defined here\n+...\n+LL |     <Ty<'c>>::trait_method::<Ty<'static>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:62:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                          -- lifetime `'d` defined here\n+...\n+LL |     <Ty<'static>>::trait_method::<Ty<'d>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'d` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:65:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                              -- lifetime `'e` defined here\n+...\n+LL |     <Ty<'e>>::CONST;\n+   |     ^^^^^^^^^^^^^^^ requires that `'e` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:67:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                                  -- lifetime `'f` defined here\n+...\n+LL |     <Ty<'f>>::TRAIT_CONST;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ requires that `'f` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:75:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                                      -- lifetime `'g` defined here\n+...\n+LL |     MyTy::Unit::<Ty<'g>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^ requires that `'g` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:77:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h>() {\n+   |                                          -- lifetime `'h` defined here\n+...\n+LL |     MyTy::<Ty<'h>>::Unit;\n+   |     ^^^^^^^^^^^^^^^^^^^^ requires that `'h` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+   = help: replace `'d` with `'static`\n+   = help: replace `'e` with `'static`\n+   = help: replace `'f` with `'static`\n+   = help: replace `'g` with `'static`\n+   = help: replace `'h` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:82:5\n+   |\n+LL | fn test_call<'a, 'b, 'c>() {\n+   |              -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::method::<Ty<'static>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:84:5\n+   |\n+LL | fn test_call<'a, 'b, 'c>() {\n+   |                  -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'static>>::method::<Ty<'b>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:89:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                  -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::Struct {};\n+   |     ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:91:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                      -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'b>>::Tuple();\n+   |     ^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:93:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                          -- lifetime `'c` defined here\n+...\n+LL |     <Ty<'c>>::Unit;\n+   |     ^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:98:7\n+   |\n+LL | fn test_method_call<'a, 'b>(x: MyTy<()>) {\n+   |                     -- lifetime `'a` defined here\n+LL |     x.method2::<Ty<'a>>();\n+   |       ^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:100:7\n+   |\n+LL | fn test_method_call<'a, 'b>(x: MyTy<()>) {\n+   |                         -- lifetime `'b` defined here\n+...\n+LL |     x.trait_method::<Ty<'b>>();\n+   |       ^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:117:5\n+   |\n+LL | fn test_struct_path<'a, 'b, 'c, 'd>() {\n+   |                     -- lifetime `'a` defined here\n+...\n+LL |     MyTy::<Ty<'a>>::Struct {}; // without SelfTy\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:119:5\n+   |\n+LL | fn test_struct_path<'a, 'b, 'c, 'd>() {\n+   |                         -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'b> as Project>::Enum::Struct {}; // with SelfTy\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:123:5\n+   |\n+LL | fn test_struct_path<'a, 'b, 'c, 'd>() {\n+   |                             -- lifetime `'c` defined here\n+...\n+LL |     Struct::<Ty<'c>> { x: None, }; // without SelfTy\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:125:5\n+   |\n+LL | fn test_struct_path<'a, 'b, 'c, 'd>() {\n+   |                                 -- lifetime `'d` defined here\n+...\n+LL |     <Ty<'d> as Project>::Struct { x: None, }; // with SelfTy\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'d` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+   = help: replace `'d` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:132:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                 -- lifetime `'a` defined here\n+...\n+LL |         Struct::<Ty<'a>> {..} => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:134:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                     -- lifetime `'b` defined here\n+...\n+LL |         Tuple::<Ty<'b>> (..) => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:136:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                         -- lifetime `'c` defined here\n+...\n+LL |         Unit::<Ty<'c>> => {},\n+   |         ^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:141:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                             -- lifetime `'d` defined here\n+...\n+LL |         <Ty<'d>>::Struct {..} => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^ requires that `'d` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:143:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                                 -- lifetime `'e` defined here\n+...\n+LL |         <Ty<'e>>::Tuple (..) => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^ requires that `'e` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:145:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c, 'd, 'e, 'f>() {\n+   |                                     -- lifetime `'f` defined here\n+...\n+LL |         <Ty<'f>>::Unit => {},\n+   |         ^^^^^^^^^^^^^^ requires that `'f` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+   = help: replace `'d` with `'static`\n+   = help: replace `'e` with `'static`\n+   = help: replace `'f` with `'static`\n+\n+error: aborting due to 28 previous errors\n+"}, {"sha": "fa52e6d857f6f62e3b3d6f57265f701fb053ba9e", "filename": "src/test/ui/nll/user-annotations/normalization-default.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,22 @@\n+// check-fail\n+\n+trait Trait { type Assoc; }\n+impl<'a> Trait for &'a () { type Assoc = &'a (); }\n+\n+struct MyTuple<T, U = <&'static () as Trait>::Assoc>(T, U);\n+fn test_tuple(x: &(), y: &()) {\n+    MyTuple::<_>((), x);\n+    //~^ ERROR\n+    let _: MyTuple::<_> = MyTuple((), y);\n+    //~^ ERROR\n+}\n+\n+struct MyStruct<T, U = <&'static () as Trait>::Assoc> { val: (T, U), }\n+fn test_struct(x: &(), y: &()) {\n+    MyStruct::<_> { val: ((), x) };\n+    //~^ ERROR\n+    let _: MyStruct::<_> = MyStruct { val: ((), y) };\n+    //~^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "6c73ac69254815f6467e838597b5244642d28104", "filename": "src/test/ui/nll/user-annotations/normalization-default.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-default.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,36 @@\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-default.rs:8:22\n+   |\n+LL | fn test_tuple(x: &(), y: &()) {\n+   |                  - let's call the lifetime of this reference `'1`\n+LL |     MyTuple::<_>((), x);\n+   |                      ^ this usage requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-default.rs:10:12\n+   |\n+LL | fn test_tuple(x: &(), y: &()) {\n+   |                          - let's call the lifetime of this reference `'2`\n+...\n+LL |     let _: MyTuple::<_> = MyTuple((), y);\n+   |            ^^^^^^^^^^^^ type annotation requires that `'2` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-default.rs:16:26\n+   |\n+LL | fn test_struct(x: &(), y: &()) {\n+   |                   - let's call the lifetime of this reference `'1`\n+LL |     MyStruct::<_> { val: ((), x) };\n+   |                          ^^^^^^^ this usage requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-default.rs:18:12\n+   |\n+LL | fn test_struct(x: &(), y: &()) {\n+   |                           - let's call the lifetime of this reference `'2`\n+...\n+LL |     let _: MyStruct::<_> = MyStruct { val: ((), y) };\n+   |            ^^^^^^^^^^^^^ type annotation requires that `'2` must outlive `'static`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "8bfc272d4ba095660caa925a52bd15c1862bc2b8", "filename": "src/test/ui/nll/user-annotations/normalization-infer.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,40 @@\n+// Annnotations may contain projection types with inference variables as input.\n+// Make sure we don't get ambiguities when normalizing them.\n+\n+// check-fail\n+\n+// Single impl.\n+fn test1<A, B, C, D>(a: A, b: B, c: C) {\n+    trait Tr { type Ty; }\n+    impl<T: 'static> Tr for (T,) { type Ty = T; }\n+\n+    let _: <(_,) as Tr>::Ty = a; //~ ERROR type `A`\n+    Some::<<(_,) as Tr>::Ty>(b); //~ ERROR type `B`\n+    || -> <(_,) as Tr>::Ty { c }; //~ ERROR type `C`\n+    |d: <(_,) as Tr>::Ty| -> D { d }; //~ ERROR type `D`\n+}\n+\n+\n+// Two impls. The selected impl depends on the actual type.\n+fn test2<A, B, C>(a: A, b: B, c: C) {\n+    trait Tr { type Ty; }\n+    impl<T: 'static> Tr for (u8, T) { type Ty = T; }\n+    impl<T>          Tr for (i8, T) { type Ty = T; }\n+    type Alias<X, Y> = (<(X, Y) as Tr>::Ty, X);\n+\n+    fn temp() -> String { todo!() }\n+\n+    // `u8` impl, requires static.\n+    let _: Alias<_, _> = (a, 0u8); //~ ERROR type `A`\n+    Some::<Alias<_, _>>((b, 0u8)); //~ ERROR type `B`\n+    || -> Alias<_, _> { (c, 0u8) }; //~ ERROR type `C`\n+\n+    let _: Alias<_, _> = (&temp(), 0u8); //~ ERROR temporary value\n+    Some::<Alias<_, _>>((&temp(), 0u8)); //~ ERROR temporary value\n+\n+    // `i8` impl, no region constraints.\n+    let _: Alias<_, _> = (&temp(), 0i8);\n+    Some::<Alias<_, _>>((&temp(), 0i8));\n+}\n+\n+fn main() {}"}, {"sha": "12854ab6816b7e074991b0a6b993b629f2c3845f", "filename": "src/test/ui/nll/user-annotations/normalization-infer.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,101 @@\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/normalization-infer.rs:11:12\n+   |\n+LL |     let _: <(_,) as Tr>::Ty = a;\n+   |            ^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A: 'static, B, C, D>(a: A, b: B, c: C) {\n+   |           +++++++++\n+\n+error[E0310]: the parameter type `B` may not live long enough\n+  --> $DIR/normalization-infer.rs:12:5\n+   |\n+LL |     Some::<<(_,) as Tr>::Ty>(b);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `B` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B: 'static, C, D>(a: A, b: B, c: C) {\n+   |              +++++++++\n+\n+error[E0310]: the parameter type `C` may not live long enough\n+  --> $DIR/normalization-infer.rs:13:11\n+   |\n+LL |     || -> <(_,) as Tr>::Ty { c };\n+   |           ^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B, C: 'static, D>(a: A, b: B, c: C) {\n+   |                 +++++++++\n+\n+error[E0310]: the parameter type `D` may not live long enough\n+  --> $DIR/normalization-infer.rs:14:6\n+   |\n+LL |     |d: <(_,) as Tr>::Ty| -> D { d };\n+   |      ^ ...so that the type `D` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B, C, D: 'static>(a: A, b: B, c: C) {\n+   |                    +++++++++\n+\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/normalization-infer.rs:28:12\n+   |\n+LL |     let _: Alias<_, _> = (a, 0u8);\n+   |            ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A: 'static, B, C>(a: A, b: B, c: C) {\n+   |           +++++++++\n+\n+error[E0310]: the parameter type `B` may not live long enough\n+  --> $DIR/normalization-infer.rs:29:5\n+   |\n+LL |     Some::<Alias<_, _>>((b, 0u8));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `B` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A, B: 'static, C>(a: A, b: B, c: C) {\n+   |              +++++++++\n+\n+error[E0310]: the parameter type `C` may not live long enough\n+  --> $DIR/normalization-infer.rs:30:11\n+   |\n+LL |     || -> Alias<_, _> { (c, 0u8) };\n+   |           ^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A, B, C: 'static>(a: A, b: B, c: C) {\n+   |                 +++++++++\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/normalization-infer.rs:32:28\n+   |\n+LL |     let _: Alias<_, _> = (&temp(), 0u8);\n+   |            -----------     ^^^^^^ creates a temporary value which is freed while still in use\n+   |            |\n+   |            type annotation requires that borrow lasts for `'static`\n+...\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/normalization-infer.rs:33:27\n+   |\n+LL |     Some::<Alias<_, _>>((&temp(), 0u8));\n+   |                         --^^^^^^------ - temporary value is freed at the end of this statement\n+   |                         | |\n+   |                         | creates a temporary value which is freed while still in use\n+   |                         this usage requires that borrow lasts for `'static`\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0310, E0716.\n+For more information about an error, try `rustc --explain E0310`."}, {"sha": "c18760b53cffbdc5b302908363a09a4bc9c8d999", "filename": "src/test/ui/nll/user-annotations/normalization-self.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,26 @@\n+// check-fail\n+\n+trait Trait { type Assoc; }\n+impl<'a> Trait for &'a () { type Assoc = &'a (); }\n+\n+struct MyTuple<T>(T);\n+impl MyTuple<<&'static () as Trait>::Assoc> {\n+    fn test(x: &(), y: &()) {\n+        Self(x);\n+        //~^ ERROR\n+        let _: Self = MyTuple(y);\n+        //~^ ERROR\n+    }\n+}\n+\n+struct MyStruct<T> { val: T, }\n+impl MyStruct<<&'static () as Trait>::Assoc> {\n+    fn test(x: &(), y: &()) {\n+        Self { val: x };\n+        //~^ ERROR\n+        let _: Self = MyStruct { val: y };\n+        //~^ ERROR\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e231ed03c2eea144850846dd60e0d1969841aebd", "filename": "src/test/ui/nll/user-annotations/normalization-self.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-self.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,36 @@\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-self.rs:9:14\n+   |\n+LL |     fn test(x: &(), y: &()) {\n+   |                - let's call the lifetime of this reference `'1`\n+LL |         Self(x);\n+   |              ^ this usage requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-self.rs:11:16\n+   |\n+LL |     fn test(x: &(), y: &()) {\n+   |                        - let's call the lifetime of this reference `'2`\n+...\n+LL |         let _: Self = MyTuple(y);\n+   |                ^^^^ type annotation requires that `'2` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-self.rs:19:21\n+   |\n+LL |     fn test(x: &(), y: &()) {\n+   |                - let's call the lifetime of this reference `'1`\n+LL |         Self { val: x };\n+   |                     ^ this usage requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-self.rs:21:16\n+   |\n+LL |     fn test(x: &(), y: &()) {\n+   |                        - let's call the lifetime of this reference `'2`\n+...\n+LL |         let _: Self = MyStruct { val: y };\n+   |                ^^^^ type annotation requires that `'2` must outlive `'static`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c2e892f573c2d6fa6ebc7372111dffed096bc19f", "filename": "src/test/ui/nll/user-annotations/normalization.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -3,8 +3,15 @@\n \n trait Foo { type Out; }\n impl Foo for () { type Out = &'static u32; }\n+impl<'a> Foo for &'a () { type Out = &'a u32; }\n \n fn main() {\n     let a = 22;\n-    let b: <() as Foo>::Out = &a; //~ ERROR\n+    let _: <() as Foo>::Out = &a; //~ ERROR\n+\n+    let a = 22;\n+    let _: <&'static () as Foo>::Out = &a; //~ ERROR\n+\n+    let a = 22;\n+    let _: <&'_ () as Foo>::Out = &a;\n }"}, {"sha": "975cb4b66d91d0ef91004d6524d5f21786f43878", "filename": "src/test/ui/nll/user-annotations/normalization.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,13 +1,25 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/normalization.rs:9:31\n+  --> $DIR/normalization.rs:10:31\n    |\n-LL |     let b: <() as Foo>::Out = &a;\n+LL |     let _: <() as Foo>::Out = &a;\n    |            ----------------   ^^ borrowed value does not live long enough\n    |            |\n    |            type annotation requires that `a` is borrowed for `'static`\n+...\n LL | }\n    | - `a` dropped here while still borrowed\n \n-error: aborting due to previous error\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/normalization.rs:13:40\n+   |\n+LL |     let _: <&'static () as Foo>::Out = &a;\n+   |            -------------------------   ^^ borrowed value does not live long enough\n+   |            |\n+   |            type annotation requires that `a` is borrowed for `'static`\n+...\n+LL | }\n+   | - `a` dropped here while still borrowed\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "2a26252036181ceb696733b2902ac6b0f628ab49", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "cdf70d2a5be974245001d8deb05d352a991fd56e", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -6,7 +6,7 @@ LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          |\n    |          lifetime `'a` defined here\n LL |     let z: Option<&'b &'a usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+   |            ^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n@@ -19,7 +19,7 @@ LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          lifetime `'a` defined here\n LL |     let y: Paramd<'a> = Paramd { x: a };\n LL |     let z: Option<&'b Paramd<'a>> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n@@ -31,7 +31,7 @@ LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          |\n    |          lifetime `'a` defined here\n LL |     let z: Option<&'a &'b usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "6a7c908fa40092873b4d5518f83471530903448d", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n \n@@ -20,7 +20,7 @@ LL | fn with_assoc_sub<'a,'b>() {\n    |                   lifetime `'a` defined here\n ...\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "eba2a0d585346a0fb49d36811c3cc8ff731af218", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "d20a2f06adfeccf818141a5dca2c4cf98ae799c4", "filename": "src/test/ui/regions/regions-outlives-projection-container.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n \n@@ -20,7 +20,7 @@ LL | fn without_assoc<'a,'b>() {\n    |                  lifetime `'a` defined here\n ...\n LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "962606508be7a492acf0fee3abf3b22f72c182b5", "filename": "src/test/ui/type-alias-impl-trait/associated-type-impl-trait-lifetime.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -0,0 +1,20 @@\n+//check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Trait {\n+    type Opaque1;\n+    type Opaque2;\n+    fn constrain(self);\n+}\n+\n+impl<'a> Trait for &'a () {\n+    type Opaque1 = impl Sized;\n+    type Opaque2 = impl Sized + 'a;\n+    fn constrain(self) {\n+        let _: Self::Opaque1 = ();\n+        let _: Self::Opaque2 = self;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5f7f6aa9f6ec62697ef4ae895994f184dd6686de", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -205,7 +205,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/ufcs-partially-resolved.rs:36:12\n    |\n LL |     let _: <u8 as Tr>::Y::NN;\n-   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u16 as Trait>::NN`\n+   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<u8 as Tr>::Y as Trait>::NN`\n \n error[E0599]: no associated item named `NN` found for type `u16` in the current scope\n   --> $DIR/ufcs-partially-resolved.rs:38:20"}]}