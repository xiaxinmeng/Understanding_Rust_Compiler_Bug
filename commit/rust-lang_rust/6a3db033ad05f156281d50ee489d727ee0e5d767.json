{"sha": "6a3db033ad05f156281d50ee489d727ee0e5d767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhM2RiMDMzYWQwNWYxNTYyODFkNTBlZTQ4OWQ3MjdlZTBlNWQ3Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-24T13:10:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-24T13:10:06Z"}, "message": "Auto merge of #52597 - oli-obk:promotion_simplify, r=nagisa\n\nPromoteds are statics and statics have a place, not just a value\n\nr? @eddyb\n\nThis makes everything around promoteds a little simpler", "tree": {"sha": "7c93b7fe78be90b0163bfc8e2de40c2220b9c613", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c93b7fe78be90b0163bfc8e2de40c2220b9c613"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a3db033ad05f156281d50ee489d727ee0e5d767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3db033ad05f156281d50ee489d727ee0e5d767", "html_url": "https://github.com/rust-lang/rust/commit/6a3db033ad05f156281d50ee489d727ee0e5d767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a3db033ad05f156281d50ee489d727ee0e5d767/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1e6bcb2085cba3d5e549ba3b175f99487c21639", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e6bcb2085cba3d5e549ba3b175f99487c21639", "html_url": "https://github.com/rust-lang/rust/commit/a1e6bcb2085cba3d5e549ba3b175f99487c21639"}, {"sha": "cbd42749efa3555b51463497869af9f829480142", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd42749efa3555b51463497869af9f829480142", "html_url": "https://github.com/rust-lang/rust/commit/cbd42749efa3555b51463497869af9f829480142"}], "stats": {"total": 965, "additions": 378, "deletions": 587}, "files": [{"sha": "38ea536b4ee729dccce470a78f5699b918a8c4d2", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -302,6 +302,9 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n             mir::Place::Static(ref statik) => {\n                 statik.hash_stable(hcx, hasher);\n             }\n+            mir::Place::Promoted(ref promoted) => {\n+                promoted.hash_stable(hcx, hasher);\n+            }\n             mir::Place::Projection(ref place_projection) => {\n                 place_projection.hash_stable(hcx, hasher);\n             }\n@@ -527,22 +530,6 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::Literal::Value { ref value } => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            mir::Literal::Promoted { index } => {\n-                index.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {"}, {"sha": "f1f826486a5f2f6052a37bd30e567f45e28373d3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 46, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -1701,6 +1701,9 @@ pub enum Place<'tcx> {\n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n \n+    /// Constant code promoted to an injected static\n+    Promoted(Box<(Promoted, Ty<'tcx>)>),\n+\n     /// projection out of a place (access a field, deref a pointer, etc)\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n@@ -1810,6 +1813,7 @@ impl<'tcx> Debug for Place<'tcx> {\n                 ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n                 ty\n             ),\n+            Promoted(ref promoted) => write!(fmt, \"({:?}: {:?})\", promoted.0, promoted.1),\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name)\n@@ -1910,9 +1914,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             ty,\n-            literal: Literal::Value {\n-                value: ty::Const::zero_sized(tcx, ty),\n-            },\n+            literal: ty::Const::zero_sized(tcx, ty),\n         })\n     }\n \n@@ -2200,38 +2202,15 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n-    pub literal: Literal<'tcx>,\n+    pub literal: &'tcx ty::Const<'tcx>,\n }\n \n newtype_index!(Promoted { DEBUG_FORMAT = \"promoted[{}]\" });\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum Literal<'tcx> {\n-    Value {\n-        value: &'tcx ty::Const<'tcx>,\n-    },\n-    Promoted {\n-        // Index into the `promoted` vector of `Mir`.\n-        index: Promoted,\n-    },\n-}\n-\n impl<'tcx> Debug for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}\", self.literal)\n-    }\n-}\n-\n-impl<'tcx> Debug for Literal<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        use self::Literal::*;\n-        match *self {\n-            Value { value } => {\n-                write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, value)\n-            }\n-            Promoted { index } => write!(fmt, \"{:?}\", index),\n-        }\n+        write!(fmt, \"const \")?;\n+        fmt_const_val(fmt, self.literal)\n     }\n }\n \n@@ -2918,20 +2897,3 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n         self.ty.visit_with(visitor) || self.literal.visit_with(visitor)\n     }\n }\n-\n-impl<'tcx> TypeFoldable<'tcx> for Literal<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            Literal::Value { value } => Literal::Value {\n-                value: value.fold_with(folder),\n-            },\n-            Literal::Promoted { index } => Literal::Promoted { index },\n-        }\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            Literal::Value { value } => value.visit_with(visitor),\n-            Literal::Promoted { .. } => false,\n-        }\n-    }\n-}"}, {"sha": "b55843ac527dfd9a90907a602bd492c48360dcb2", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -113,6 +113,7 @@ impl<'tcx> Place<'tcx> {\n         match *self {\n             Place::Local(index) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n+            Place::Promoted(ref data) => PlaceTy::Ty { ty: data.1 },\n             Place::Static(ref data) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>"}, {"sha": "cab6ed0c122cd88469aab9c5d2553926ad02cdf2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -191,12 +191,6 @@ macro_rules! make_mir_visitor {\n                 self.super_constant(constant, location);\n             }\n \n-            fn visit_literal(&mut self,\n-                             literal: & $($mutability)* Literal<'tcx>,\n-                             location: Location) {\n-                self.super_literal(literal, location);\n-            }\n-\n             fn visit_def_id(&mut self,\n                             def_id: & $($mutability)* DefId,\n                             _: Location) {\n@@ -648,6 +642,9 @@ macro_rules! make_mir_visitor {\n                     Place::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n+                    Place::Promoted(ref $($mutability)* promoted) => {\n+                        self.visit_ty(& $($mutability)* promoted.1, TyContext::Location(location));\n+                    },\n                     Place::Projection(ref $($mutability)* proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n@@ -748,18 +745,7 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n-                self.visit_literal(literal, location);\n-            }\n-\n-            fn super_literal(&mut self,\n-                             literal: & $($mutability)* Literal<'tcx>,\n-                             location: Location) {\n-                match *literal {\n-                    Literal::Value { ref $($mutability)* value } => {\n-                        self.visit_const(value, location);\n-                    }\n-                    Literal::Promoted { index: _ } => {}\n-                }\n+                self.visit_const(literal, location);\n             }\n \n             fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {"}, {"sha": "5a2d95803842215fb7ec7de49212fbf8d488ad45", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -242,9 +242,11 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n-pub fn codegen_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                def_id: DefId,\n-                                is_mutable: bool) {\n+pub fn codegen_static<'a, 'tcx>(\n+    cx: &CodegenCx<'a, 'tcx>,\n+    def_id: DefId,\n+    is_mutable: bool,\n+) {\n     unsafe {\n         let attrs = cx.tcx.codegen_fn_attrs(def_id);\n "}, {"sha": "dc4b9e0ae99d8f41a83b0fb044d43e891e1aca82", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -507,14 +507,40 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         // promotes any complex rvalues to constants.\n                         if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n                             match *arg {\n+                                // The shuffle array argument is usually not an explicit constant,\n+                                // but specified directly in the code. This means it gets promoted\n+                                // and we can then extract the value by evaluating the promoted.\n+                                mir::Operand::Copy(mir::Place::Promoted(box(index, ty))) |\n+                                mir::Operand::Move(mir::Place::Promoted(box(index, ty))) => {\n+                                    let param_env = ty::ParamEnv::reveal_all();\n+                                    let cid = mir::interpret::GlobalId {\n+                                        instance: self.instance,\n+                                        promoted: Some(index),\n+                                    };\n+                                    let c = bx.tcx().const_eval(param_env.and(cid));\n+                                    let (llval, ty) = self.simd_shuffle_indices(\n+                                        &bx,\n+                                        terminator.source_info.span,\n+                                        ty,\n+                                        c,\n+                                    );\n+                                    return OperandRef {\n+                                        val: Immediate(llval),\n+                                        layout: bx.cx.layout_of(ty),\n+                                    };\n+\n+                                },\n                                 mir::Operand::Copy(_) |\n                                 mir::Operand::Move(_) => {\n                                     span_bug!(span, \"shuffle indices must be constant\");\n                                 }\n                                 mir::Operand::Constant(ref constant) => {\n+                                    let c = self.eval_mir_constant(&bx, constant);\n                                     let (llval, ty) = self.simd_shuffle_indices(\n                                         &bx,\n-                                        constant,\n+                                        constant.span,\n+                                        constant.ty,\n+                                        c,\n                                     );\n                                     return OperandRef {\n                                         val: Immediate(llval),"}, {"sha": "0d682d5d6f6a1478fc86286a5ab68379a95b7abd", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -25,6 +25,7 @@ use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n+use syntax::codemap::Span;\n \n use super::super::callee;\n use super::FunctionCx;\n@@ -117,13 +118,12 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n \n pub fn codegen_static_initializer<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n-    def_id: DefId)\n-    -> Result<(ValueRef, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>>\n-{\n+    def_id: DefId,\n+) -> Result<(ValueRef, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>> {\n     let instance = ty::Instance::mono(cx.tcx, def_id);\n     let cid = GlobalId {\n         instance,\n-        promoted: None\n+        promoted: None,\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n@@ -161,28 +161,19 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         bx: &Builder<'a, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n-        match constant.literal {\n-            mir::Literal::Promoted { index } => {\n-                let param_env = ty::ParamEnv::reveal_all();\n-                let cid = mir::interpret::GlobalId {\n-                    instance: self.instance,\n-                    promoted: Some(index),\n-                };\n-                bx.tcx().const_eval(param_env.and(cid))\n-            }\n-            mir::Literal::Value { value } => {\n-                Ok(self.monomorphize(&value))\n-            }\n-        }.and_then(|c| self.fully_evaluate(bx, c))\n+        let c = self.monomorphize(&constant.literal);\n+        self.fully_evaluate(bx, c)\n     }\n \n     /// process constant containing SIMD shuffle indices\n     pub fn simd_shuffle_indices(\n         &mut self,\n         bx: &Builder<'a, 'tcx>,\n-        constant: &mir::Constant<'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        constant: Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>>,\n     ) -> (ValueRef, Ty<'tcx>) {\n-        self.eval_mir_constant(bx, constant)\n+        constant\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n@@ -217,11 +208,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             })\n             .unwrap_or_else(|e| {\n                 e.report_as_error(\n-                    bx.tcx().at(constant.span),\n+                    bx.tcx().at(span),\n                     \"could not evaluate shuffle_indices at compile time\",\n                 );\n                 // We've errored, so we don't have to produce working code.\n-                let ty = self.monomorphize(&constant.ty);\n+                let ty = self.monomorphize(&ty);\n                 let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n                 (C_undef(llty), ty)\n             })"}, {"sha": "777054014dc470b2dd1e700b34c93d5ff3a71cbe", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{ValueRef, LLVMConstInBoundsGEP};\n+use llvm::ValueRef;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n use rustc::mir::interpret::ConstValue;\n@@ -22,14 +22,12 @@ use common::{CodegenCx, C_undef, C_usize};\n use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n-use type_::Type;\n-use consts;\n \n use std::fmt;\n use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::{scalar_to_llvm, const_alloc_to_llvm};\n+use super::constant::scalar_to_llvm;\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -139,16 +137,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(alloc, offset) => {\n-                let init = const_alloc_to_llvm(bx.cx, alloc);\n-                let base_addr = consts::addr_of(bx.cx, init, layout.align, \"byte_str\");\n-\n-                let llval = unsafe { LLVMConstInBoundsGEP(\n-                    consts::bitcast(base_addr, Type::i8p(bx.cx)),\n-                    &C_usize(bx.cx, offset.bytes()),\n-                    1,\n-                )};\n-                let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());\n-                return Ok(PlaceRef::new_sized(llval, layout, alloc.align).load(bx));\n+                return Ok(PlaceRef::from_const_alloc(bx, layout, alloc, offset).load(bx));\n             },\n         };\n \n@@ -409,20 +398,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 self.eval_mir_constant(bx, constant)\n                     .and_then(|c| OperandRef::from_const(bx, c))\n                     .unwrap_or_else(|err| {\n-                        match constant.literal {\n-                            mir::Literal::Promoted { .. } => {\n-                                // this is unreachable as long as runtime\n-                                // and compile-time agree on values\n-                                // With floats that won't always be true\n-                                // so we generate an abort below\n-                            },\n-                            mir::Literal::Value { .. } => {\n-                                err.report_as_error(\n-                                    bx.tcx().at(constant.span),\n-                                    \"could not evaluate constant operand\",\n-                                );\n-                            },\n-                        }\n+                        err.report_as_error(\n+                            bx.tcx().at(constant.span),\n+                            \"could not evaluate constant operand\",\n+                        );\n+                        // Allow RalfJ to sleep soundly knowing that even refactorings that remove\n+                        // the above error (or silence it under some conditions) will not cause UB\n                         let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n                         // We've errored, so we don't have to produce working code."}, {"sha": "9abf9077a9577f4d6b48672f3ca3463a9c0712f6", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm::{self, ValueRef, LLVMConstInBoundsGEP};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -22,6 +22,7 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n use glue;\n+use mir::constant::const_alloc_to_llvm;\n \n use std::ptr;\n \n@@ -56,6 +57,24 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n+    pub fn from_const_alloc(\n+        bx: &Builder<'a, 'tcx>,\n+        layout: TyLayout<'tcx>,\n+        alloc: &mir::interpret::Allocation,\n+        offset: Size,\n+    ) -> PlaceRef<'tcx> {\n+        let init = const_alloc_to_llvm(bx.cx, alloc);\n+        let base_addr = consts::addr_of(bx.cx, init, layout.align, \"byte_str\");\n+\n+        let llval = unsafe { LLVMConstInBoundsGEP(\n+            consts::bitcast(base_addr, Type::i8p(bx.cx)),\n+            &C_usize(bx.cx, offset.bytes()),\n+            1,\n+        )};\n+        let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());\n+        PlaceRef::new_sized(llval, layout, alloc.align)\n+    }\n+\n     pub fn alloca(bx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n@@ -421,6 +440,32 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n         let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n+            mir::Place::Promoted(box (index, ty)) => {\n+                let param_env = ty::ParamEnv::reveal_all();\n+                let cid = mir::interpret::GlobalId {\n+                    instance: self.instance,\n+                    promoted: Some(index),\n+                };\n+                let layout = cx.layout_of(self.monomorphize(&ty));\n+                match bx.tcx().const_eval(param_env.and(cid)) {\n+                    Ok(val) => match val.val {\n+                        mir::interpret::ConstValue::ByRef(alloc, offset) => {\n+                            PlaceRef::from_const_alloc(bx, layout, alloc, offset)\n+                        }\n+                        _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n+                    },\n+                    Err(_) => {\n+                        // this is unreachable as long as runtime\n+                        // and compile-time agree on values\n+                        // With floats that won't always be true\n+                        // so we generate an abort\n+                        let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                        bx.call(fnname, &[], None);\n+                        let llval = C_undef(layout.llvm_type(bx.cx).ptr_to());\n+                        PlaceRef::new_sized(llval, layout, layout.align)\n+                    }\n+                }\n+            }\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 PlaceRef::new_sized(consts::get_static(cx, def_id), layout, layout.align)"}, {"sha": "9dcee3207565ff6abb9a01491543843325bbe69b", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -716,6 +716,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n+            Place::Promoted(_) => {\n+                buf.push_str(\"promoted\");\n+            }\n             Place::Local(local) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n@@ -858,6 +861,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             }\n+            Place::Promoted(ref prom) => self.describe_field_from_ty(&prom.1, field),\n             Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n@@ -928,6 +932,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[*local];\n                 Some(local.ty)\n             }\n+            Place::Promoted(ref prom) => Some(prom.1),\n             Place::Static(ref st) => Some(st.ty),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(_, ty) => Some(ty),"}, {"sha": "b3d7337cffe115b43ef5db31d68bcbf0a76b8dae", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -1232,6 +1232,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(Place::Static(..))\n                                 | Operand::Copy(Place::Static(..))\n+                                | Operand::Move(Place::Promoted(..))\n+                                | Operand::Copy(Place::Promoted(..))\n                                 | Operand::Constant(..) => {}\n                             }\n                         }\n@@ -1314,6 +1316,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n+            Place::Promoted(_) => (true, false),\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n@@ -1599,6 +1602,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *last_prefix {\n             Place::Local(_) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n+            Place::Promoted(_) |\n             Place::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n@@ -1625,6 +1629,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut place = place;\n         loop {\n             match *place {\n+                Place::Promoted(_) |\n                 Place::Local(_) | Place::Static(_) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n@@ -1820,6 +1825,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n+            RootPlace {\n+                place: Place::Promoted(..),\n+                is_local_mutation_allowed: _,\n+            } => {}\n             RootPlace {\n                 place: Place::Static(..),\n                 is_local_mutation_allowed: _,\n@@ -1855,6 +1864,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }),\n                 }\n             }\n+            // promoteds may never be mutated\n+            Place::Promoted(_) => bug!(\"encountered mutable promoted\"),\n             Place::Static(ref static_) => {\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n@@ -2021,6 +2032,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut deepest = place;\n         loop {\n             let proj = match *cursor {\n+                Place::Promoted(_) |\n                 Place::Local(..) | Place::Static(..) => return deepest,\n                 Place::Projection(ref proj) => proj,\n             };"}, {"sha": "4aa38fb5f37327c8e2552972c910abded20f0c4d", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -247,6 +247,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                             Place::Projection(ref proj) => {\n                                                 proj.base == Place::Local(Local::new(1))\n                                             }\n+                                            Place::Promoted(_) |\n                                             Place::Local(_) | Place::Static(_) => unreachable!(),\n                                         }\n                                     } =>\n@@ -389,6 +390,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 // overloaded * operator.\n                 local_decl.is_user_variable.is_some() && is_shared_ref(local_decl.ty)\n             }\n+            Place::Promoted(_) => true,\n             Place::Static(ref st) => is_shared_ref(st.ty),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(_, ty) => is_shared_ref(ty),"}, {"sha": "ab1ff1fa347d6323b50599f123ee290fccef31fe", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -122,6 +122,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            Place::Promoted(_) => unreachable!(),\n+\n             Place::Static(box Static { def_id, ty: _ }) => {\n                 if let Place::Static(_) = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());"}, {"sha": "b6c8ffcf88d65ab5588e96bc9ecf3850447f62bf", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 47, "deletions": 53, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -284,69 +284,48 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             constant, location\n         );\n \n-        let expected_ty = match constant.literal {\n-            Literal::Value { value } => {\n-                // FIXME(#46702) -- We need some way to get the predicates\n-                // associated with the \"pre-evaluated\" form of the\n-                // constant. For example, consider that the constant\n-                // may have associated constant projections (`<Foo as\n-                // Trait<'a, 'b>>::SOME_CONST`) that impose\n-                // constraints on `'a` and `'b`. These constraints\n-                // would be lost if we just look at the normalized\n-                // value.\n-                if let ty::TyFnDef(def_id, substs) = value.ty.sty {\n-                    let tcx = self.tcx();\n-                    let type_checker = &mut self.cx;\n-\n-                    // FIXME -- For now, use the substitutions from\n-                    // `value.ty` rather than `value.val`. The\n-                    // renumberer will rewrite them to independent\n-                    // sets of regions; in principle, we ought to\n-                    // derive the type of the `value.val` from \"first\n-                    // principles\" and equate with value.ty, but as we\n-                    // are transitioning to the miri-based system, we\n-                    // don't have a handy function for that, so for\n-                    // now we just ignore `value.val` regions.\n-\n-                    let instantiated_predicates =\n-                        tcx.predicates_of(def_id).instantiate(tcx, substs);\n-                    type_checker.normalize_and_prove_instantiated_predicates(\n-                        instantiated_predicates,\n-                        location.boring(),\n-                    );\n-                }\n-\n-                value.ty\n-            }\n-\n-            Literal::Promoted { .. } => {\n-                // FIXME -- promoted MIR return types reference\n-                // various \"free regions\" (e.g., scopes and things)\n-                // that they ought not to do. We have to figure out\n-                // how best to handle that -- probably we want treat\n-                // promoted MIR much like closures, renumbering all\n-                // their free regions and propagating constraints\n-                // upwards. We have the same acyclic guarantees, so\n-                // that should be possible. But for now, ignore them.\n-                //\n-                // let promoted_mir = &self.mir.promoted[index];\n-                // promoted_mir.return_ty()\n-                return;\n-            }\n-        };\n+        // FIXME(#46702) -- We need some way to get the predicates\n+        // associated with the \"pre-evaluated\" form of the\n+        // constant. For example, consider that the constant\n+        // may have associated constant projections (`<Foo as\n+        // Trait<'a, 'b>>::SOME_CONST`) that impose\n+        // constraints on `'a` and `'b`. These constraints\n+        // would be lost if we just look at the normalized\n+        // value.\n+        if let ty::TyFnDef(def_id, substs) = constant.literal.ty.sty {\n+            let tcx = self.tcx();\n+            let type_checker = &mut self.cx;\n+\n+            // FIXME -- For now, use the substitutions from\n+            // `value.ty` rather than `value.val`. The\n+            // renumberer will rewrite them to independent\n+            // sets of regions; in principle, we ought to\n+            // derive the type of the `value.val` from \"first\n+            // principles\" and equate with value.ty, but as we\n+            // are transitioning to the miri-based system, we\n+            // don't have a handy function for that, so for\n+            // now we just ignore `value.val` regions.\n+\n+            let instantiated_predicates =\n+                tcx.predicates_of(def_id).instantiate(tcx, substs);\n+            type_checker.normalize_and_prove_instantiated_predicates(\n+                instantiated_predicates,\n+                location.boring(),\n+            );\n+        }\n \n-        debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n+        debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n         if let Err(terr) = self\n             .cx\n-            .eq_types(expected_ty, constant.ty, location.boring())\n+            .eq_types(constant.literal.ty, constant.ty, location.boring())\n         {\n             span_mirbug!(\n                 self,\n                 constant,\n                 \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n                 constant,\n-                expected_ty,\n+                constant.literal.ty,\n                 constant.ty,\n                 terr,\n             );\n@@ -366,6 +345,21 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Local(index) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n+            Place::Promoted(box (_index, sty)) => {\n+                let sty = self.sanitize_type(place, sty);\n+                // FIXME -- promoted MIR return types reference\n+                // various \"free regions\" (e.g., scopes and things)\n+                // that they ought not to do. We have to figure out\n+                // how best to handle that -- probably we want treat\n+                // promoted MIR much like closures, renumbering all\n+                // their free regions and propagating constraints\n+                // upwards. We have the same acyclic guarantees, so\n+                // that should be possible. But for now, ignore them.\n+                //\n+                // let promoted_mir = &self.mir.promoted[index];\n+                // promoted_mir.return_ty()\n+                PlaceTy::Ty { ty: sty }\n+            }\n             Place::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);"}, {"sha": "70b4e0ea2f03caa6e2592625bba3a5bc08f8b2d5", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -140,6 +140,7 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n     match place {\n+        Place::Promoted(_) |\n         Place::Static(..) => false,\n         Place::Local(..) => true,\n         Place::Projection(box proj) => {"}, {"sha": "b0517c5e61f2b9c16a8f1773c20cb619c3b7e1a7", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -26,6 +26,7 @@ crate trait PlaceExt<'tcx> {\n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n         match self {\n+            Place::Promoted(_) |\n             Place::Local(_) => false,\n             Place::Static(static_) => {\n                 tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n@@ -52,6 +53,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         loop {\n             match p {\n                 Place::Projection(pi) => p = &pi.base,\n+                Place::Promoted(_) |\n                 Place::Static(_) => return None,\n                 Place::Local(l) => return Some(*l),\n             }"}, {"sha": "c44af0036547966e4f390cca6334c72425ef2225", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -282,6 +282,7 @@ fn unroll_place<'tcx, R>(\n             op,\n         ),\n \n+        Place::Promoted(_) |\n         Place::Local(_) | Place::Static(_) => {\n             let list = PlaceComponents {\n                 component: place,\n@@ -326,8 +327,21 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::EqualOrDisjoint\n             }\n         }\n+        (Place::Promoted(p1), Place::Promoted(p2)) => {\n+            if p1.0 == p2.0 {\n+                // the same promoted - base case, equal\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // different promoteds - base case, disjoint\n+                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (Place::Local(_), Place::Promoted(_)) | (Place::Promoted(_), Place::Local(_)) |\n+        (Place::Promoted(_), Place::Static(_)) | (Place::Static(_), Place::Promoted(_)) |\n         (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n-            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n             Overlap::Disjoint\n         }\n         (Place::Projection(pi1), Place::Projection(pi2)) => {"}, {"sha": "9b16130d25ec4c5dff032a53526212969a014bbe", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -36,6 +36,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n             }\n \n             match *cursor {\n+                Place::Promoted(_) |\n                 Place::Local(_) | Place::Static(_) => return false,\n                 Place::Projection(ref proj) => {\n                     cursor = &proj.base;\n@@ -98,6 +99,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         'cursor: loop {\n             let proj = match *cursor {\n+                Place::Promoted(_) |\n                 Place::Local(_) | // search yielded this leaf\n                 Place::Static(_) => {\n                     self.next = None;"}, {"sha": "68009e962a302f3dce9f4ce8eae98f01f47aa5d5", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -239,12 +239,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         operands.push(Operand::Constant(box Constant {\n                             span: expr_span,\n                             ty: this.hir.tcx().types.u32,\n-                            literal: Literal::Value {\n-                                value: ty::Const::from_bits(\n-                                    this.hir.tcx(),\n-                                    0,\n-                                    ty::ParamEnv::empty().and(this.hir.tcx().types.u32)),\n-                            },\n+                            literal: ty::Const::from_bits(\n+                                this.hir.tcx(),\n+                                0,\n+                                ty::ParamEnv::empty().and(this.hir.tcx().types.u32),\n+                            ),\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n                     }\n@@ -513,9 +512,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n-        let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n-        };\n+        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n         self.literal_operand(span, ty, literal)\n     }\n@@ -526,9 +523,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n-        let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n-        };\n+        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n         self.literal_operand(span, ty, literal)\n     }"}, {"sha": "f1591535fa1aacc16fd6469f2b5eb7055f6cb6cc", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -505,8 +505,8 @@ enum TestKind<'tcx> {\n \n     // test whether the value falls within an inclusive or exclusive range\n     Range {\n-        lo: Literal<'tcx>,\n-        hi: Literal<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n         end: hir::RangeEnd,\n     },"}, {"sha": "e2b460f69fd74ef1ee73b027a6a34ab9fcc63807", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -74,8 +74,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: Literal::Value { value: lo },\n-                        hi: Literal::Value { value: hi },\n+                        lo,\n+                        hi,\n                         ty: match_pair.pattern.ty.clone(),\n                         end,\n                     },\n@@ -260,9 +260,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             TestKind::Eq { value, mut ty } => {\n                 let mut val = Operand::Copy(place.clone());\n-                let mut expect = self.literal_operand(test.span, ty, Literal::Value {\n-                    value\n-                });\n+                let mut expect = self.literal_operand(test.span, ty, value);\n                 // Use PartialEq::eq instead of BinOp::Eq\n                 // (the binop can only handle primitives)\n                 let fail = self.cfg.start_new_block();\n@@ -300,9 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 let array = self.literal_operand(\n                                     test.span,\n                                     value.ty,\n-                                    Literal::Value {\n-                                        value\n-                                    },\n+                                    value,\n                                 );\n \n                                 let slice = self.temp(ty, test.span);"}, {"sha": "ae8070698c299b434575fbfc3ff36007c54cbeff", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn literal_operand(&mut self,\n                            span: Span,\n                            ty: Ty<'tcx>,\n-                           literal: Literal<'tcx>)\n+                           literal: &'tcx ty::Const<'tcx>)\n                            -> Operand<'tcx> {\n         let constant = box Constant {\n             span,\n@@ -52,9 +52,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty))\n-        };\n+        let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, ty, literal)\n     }"}, {"sha": "96f4c6b60f511648627799e684ecbacc91a95fcc", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -93,6 +93,7 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     match *place {\n         Place::Local(l) => Some(l),\n+        Place::Promoted(_) |\n         Place::Static(..) => None,\n         Place::Projection(ref proj) => {\n             match proj.elem {"}, {"sha": "ea59e42fd479bb9d77122bc21e33f116a3df5c09", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -259,6 +259,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     // Issue #46746: Two-phase borrows handles\n                     // stmts of form `Tmp = &mut Borrow` ...\n                     match lhs {\n+                        Place::Promoted(_) |\n                         Place::Local(..) | Place::Static(..) => {} // okay\n                         Place::Projection(..) => {\n                             // ... can assign into projections,"}, {"sha": "44e46e90549a706950d97da0750bd124f62035df", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -108,6 +108,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         debug!(\"lookup({:?})\", place);\n         match *place {\n             Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n+            Place::Promoted(..) |\n             Place::Static(..) => {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }"}, {"sha": "64bfd36b7eeb6d92faaeb0a19b77c1dcf5c46fb6", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -249,6 +249,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {\n             Place::Local(local) => LookupResult::Exact(self.locals[local]),\n+            Place::Promoted(_) |\n             Place::Static(..) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {"}, {"sha": "b60da286d9555533955d842e9477a2367deee2aa", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -627,15 +627,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 let source = if let Some((did, offset, ty)) = var {\n-                    let mk_const = |val| Expr {\n+                    let mk_const = |literal| Expr {\n                         temp_lifetime,\n                         ty,\n                         span: expr.span,\n-                        kind: ExprKind::Literal {\n-                            literal: Literal::Value {\n-                                value: val,\n-                            },\n-                        },\n+                        kind: ExprKind::Literal { literal },\n                     }.to_ref();\n                     let offset = mk_const(ty::Const::from_bits(\n                         cx.tcx,\n@@ -706,9 +702,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n-            literal: Literal::Value {\n-                value: ty::Const::zero_sized(cx.tcx(), ty),\n-            },\n+            literal: ty::Const::zero_sized(cx.tcx(), ty),\n         },\n     }\n }\n@@ -760,22 +754,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Method(_) |\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n-            literal: Literal::Value {\n-                value: ty::Const::zero_sized(\n-                    cx.tcx,\n-                    cx.tables().node_id_to_type(expr.hir_id)),\n-            },\n+            literal: ty::Const::zero_sized(\n+                cx.tcx,\n+                cx.tables().node_id_to_type(expr.hir_id),\n+            ),\n         },\n \n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => ExprKind::Literal {\n-            literal: Literal::Value {\n-                value: ty::Const::unevaluated(\n-                    cx.tcx,\n-                    def_id,\n-                    substs,\n-                    cx.tables().node_id_to_type(expr.hir_id))\n-            },\n+            literal: ty::Const::unevaluated(\n+                cx.tcx,\n+                def_id,\n+                substs,\n+                cx.tables().node_id_to_type(expr.hir_id),\n+            ),\n         },\n \n         Def::StructCtor(def_id, CtorKind::Const) |"}, {"sha": "4a7225c3a76d1a93e718dd31c5551003480ab8fd", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -112,10 +112,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: ty::Const::from_usize(self.tcx, value),\n-        }\n+    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n+        ty::Const::from_usize(self.tcx, value)\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {\n@@ -126,16 +124,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: ty::Const::from_bool(self.tcx, true),\n-        }\n+    pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+        ty::Const::from_bool(self.tcx, true)\n     }\n \n-    pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: ty::Const::from_bool(self.tcx, false),\n-        }\n+    pub fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+        ty::Const::from_bool(self.tcx, false)\n     }\n \n     // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n@@ -145,7 +139,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         sp: Span,\n         neg: bool,\n-    ) -> Literal<'tcx> {\n+    ) -> &'tcx ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n         let parse_float = |num, fty| -> ConstValue<'tcx> {\n@@ -209,9 +203,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 defined: 32,\n             }),\n         };\n-        Literal::Value {\n-            value: ty::Const::from_const_value(self.tcx, lit, ty)\n-        }\n+        ty::Const::from_const_value(self.tcx, lit, ty)\n     }\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n@@ -231,17 +223,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         method_name: &str,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n-                        -> (Ty<'tcx>, Literal<'tcx>) {\n+                        -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n         let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty,\n-                        Literal::Value {\n-                            value: ty::Const::zero_sized(self.tcx, method_ty)\n-                        });\n+                return (method_ty, ty::Const::zero_sized(self.tcx, method_ty));\n             }\n         }\n "}, {"sha": "c39aa9ca7806dd0a6052f3951a9362532794bea2", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -14,11 +14,11 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n+use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -271,7 +271,7 @@ pub enum ExprKind<'tcx> {\n         movability: Option<hir::GeneratorMovability>,\n     },\n     Literal {\n-        literal: Literal<'tcx>,\n+        literal: &'tcx Const<'tcx>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "3c92f3f623581716c87353dc2ad218bfd270fde3", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -178,7 +178,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     let ptr = ptr.into();\n     // always try to read the value and report errors\n     let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-        Some(val) if is_static.is_none() => val,\n+        Some(val) if is_static.is_none() && cid.promoted.is_none() => val,\n         // point at the allocation\n         _ => Value::ByRef(ptr, layout.align),\n     };\n@@ -561,7 +561,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n     res.and_then(|(mut val, _, miri_ty)| {\n-        if tcx.is_static(def_id).is_none() {\n+        if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n             val = ecx.try_read_by_ref(val, miri_ty)?;\n         }\n         Ok(value_to_const_value(&ecx, val, miri_ty))"}, {"sha": "10d3af85337e896d1ace729cca3f9b782d8bb213", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -831,19 +831,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             },\n \n             Constant(ref constant) => {\n-                use rustc::mir::Literal;\n-                let mir::Constant { ref literal, .. } = **constant;\n-                let value = match *literal {\n-                    Literal::Value { ref value } => self.const_to_value(value.val)?,\n-\n-                    Literal::Promoted { index } => {\n-                        let instance = self.frame().instance;\n-                        self.read_global_as_value(GlobalId {\n-                            instance,\n-                            promoted: Some(index),\n-                        })?\n-                    }\n-                };\n+                let value = self.const_to_value(constant.literal.val)?;\n \n                 Ok(ValTy {\n                     value,"}, {"sha": "28373741c2f58088c48f839ff65dcde5555150e1", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -109,6 +109,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Local(local) => self.frame().get_local(local).map(Some),\n             // No fast path for statics. Reading from statics is rare and would require another\n             // Machine function to handle differently in miri.\n+            Promoted(_) |\n             Static(_) => Ok(None),\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n@@ -214,6 +215,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 local,\n             },\n \n+            Promoted(ref promoted) => {\n+                let instance = self.frame().instance;\n+                let val = self.read_global_as_value(GlobalId {\n+                    instance,\n+                    promoted: Some(promoted.0),\n+                })?;\n+                if let Value::ByRef(ptr, align) = val {\n+                    Place::Ptr {\n+                        ptr,\n+                        align,\n+                        extra: PlaceExtra::None,\n+                    }\n+                } else {\n+                    bug!(\"evaluated promoted and got {:#?}\", val);\n+                }\n+            }\n+\n             Static(ref static_) => {\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);"}, {"sha": "7bfbda8b786e3ee1f54e74da840f6adbe91b802c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -440,9 +440,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n             ty: func_ty,\n-            literal: Literal::Value {\n-                value: ty::Const::zero_sized(self.tcx, func_ty)\n-            },\n+            literal: ty::Const::zero_sized(self.tcx, func_ty),\n         });\n \n         let ref_loc = self.make_place(\n@@ -500,9 +498,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n-            literal: Literal::Value {\n-                value: ty::Const::from_usize(self.tcx, value),\n-            }\n+            literal: ty::Const::from_usize(self.tcx, value),\n         }\n     }\n \n@@ -729,9 +725,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (Operand::Constant(box Constant {\n                 span,\n                 ty,\n-                literal: Literal::Value {\n-                    value: ty::Const::zero_sized(tcx, ty)\n-                },\n+                literal: ty::Const::zero_sized(tcx, ty),\n              }),\n              vec![rcvr])\n         }"}, {"sha": "4f7f45f173f73c6ec216da2f69f26889e2978e3e", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -34,6 +34,7 @@ fn place_context<'a, 'tcx, D>(\n \n     match *place {\n         Local { .. } => (None, hir::MutMutable),\n+        Promoted(_) |\n         Static(_) => (None, hir::MutImmutable),\n         Projection(ref proj) => {\n             match proj.elem {"}, {"sha": "ab7629eb66118f8fff83482266d01070a02b4a2d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -222,6 +222,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             &Place::Local(..) => {\n                 // locals are safe\n             }\n+            &Place::Promoted(_) => {\n+                bug!(\"unsafety checking should happen before promotion\")\n+            }\n             &Place::Static(box Static { def_id, ty: _ }) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\","}, {"sha": "94f96d46996d831b34029b52db6d97557248d2e7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -13,7 +13,7 @@\n \n \n use rustc::hir::def::Def;\n-use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, Rvalue, Local};\n+use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext};\n@@ -174,48 +174,22 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         c: &Constant<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n-        match c.literal {\n-            Literal::Value { value } => {\n-                self.ecx.tcx.span = source_info.span;\n-                match self.ecx.const_to_value(value.val) {\n-                    Ok(val) => Some((val, value.ty, c.span)),\n-                    Err(error) => {\n-                        let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n-                        let err = ConstEvalErr {\n-                            span,\n-                            error,\n-                            stacktrace,\n-                        };\n-                        err.report_as_error(\n-                            self.tcx.at(source_info.span),\n-                            \"could not evaluate constant\",\n-                        );\n-                        None\n-                    },\n-                }\n-            },\n-            // evaluate the promoted and replace the constant with the evaluated result\n-            Literal::Promoted { index } => {\n-                let generics = self.tcx.generics_of(self.source.def_id);\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(index),\n+        self.ecx.tcx.span = source_info.span;\n+        match self.ecx.const_to_value(c.literal.val) {\n+            Ok(val) => Some((val, c.literal.ty, c.span)),\n+            Err(error) => {\n+                let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n+                let err = ConstEvalErr {\n+                    span,\n+                    error,\n+                    stacktrace,\n                 };\n-                // cannot use `const_eval` here, because that would require having the MIR\n-                // for the current function available, but we're producing said MIR right now\n-                let (value, _, ty) = self.use_ecx(source_info, |this| {\n-                    eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n-                })?;\n-                let val = (value, ty, c.span);\n-                trace!(\"evaluated {:?} to {:?}\", c, val);\n-                Some(val)\n-            }\n+                err.report_as_error(\n+                    self.tcx.at(source_info.span),\n+                    \"could not evaluate constant\",\n+                );\n+                None\n+            },\n         }\n     }\n \n@@ -233,6 +207,27 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 },\n                 _ => None,\n             },\n+            Place::Promoted(ref promoted) => {\n+                let generics = self.tcx.generics_of(self.source.def_id);\n+                if generics.requires_monomorphization(self.tcx) {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(promoted.0),\n+                };\n+                // cannot use `const_eval` here, because that would require having the MIR\n+                // for the current function available, but we're producing said MIR right now\n+                let (value, _, ty) = self.use_ecx(source_info, |this| {\n+                    eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n+                })?;\n+                let val = (value, ty, source_info.span);\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, val);\n+                Some(val)\n+            },\n             _ => None,\n         }\n     }"}, {"sha": "d35608068a6a85e15089f4e3bfea8e733cff207d", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -530,9 +530,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             ty: self.tcx.types.bool,\n-            literal: Literal::Value {\n-                value: ty::Const::from_bool(self.tcx, val)\n-            }\n+            literal: ty::Const::from_bool(self.tcx, val),\n         })))\n     }\n "}, {"sha": "97467e003850a8f9f1c499dcd9638308ebdab49d", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -177,12 +177,11 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n         let val = Operand::Constant(box Constant {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n-            literal: Literal::Value {\n-                value: ty::Const::from_bits(\n-                    self.tcx,\n-                    state_disc.into(),\n-                    ty::ParamEnv::empty().and(self.tcx.types.u32)),\n-            },\n+            literal: ty::Const::from_bits(\n+                self.tcx,\n+                state_disc.into(),\n+                ty::ParamEnv::empty().and(self.tcx.types.u32)\n+            ),\n         });\n         Statement {\n             source_info,\n@@ -337,6 +336,7 @@ struct BorrowedLocals(liveness::LiveVarSet<Local>);\n fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     match *place {\n         Place::Local(l) => { locals.0.add(&l); },\n+        Place::Promoted(_) |\n         Place::Static(..) => (),\n         Place::Projection(ref proj) => {\n             match proj.elem {\n@@ -707,9 +707,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cond: Operand::Constant(box Constant {\n             span: mir.span,\n             ty: tcx.types.bool,\n-            literal: Literal::Value {\n-                value: ty::Const::from_bool(tcx, false),\n-            },\n+            literal: ty::Const::from_bool(tcx, false),\n         }),\n         expected: true,\n         msg: message,"}, {"sha": "a0a5980d141dd1538c33bd03b9c8df0afba8fae2", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -662,11 +662,18 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                     place: &mut Place<'tcx>,\n                     _ctxt: PlaceContext<'tcx>,\n                     _location: Location) {\n-        if let Place::Local(RETURN_PLACE) = *place {\n-            // Return pointer; update the place itself\n-            *place = self.destination.clone();\n-        } else {\n-            self.super_place(place, _ctxt, _location);\n+\n+        match place {\n+            Place::Local(RETURN_PLACE) => {\n+                // Return pointer; update the place itself\n+                *place = self.destination.clone();\n+            },\n+            Place::Promoted(ref mut promoted) => {\n+                if let Some(p) = self.promoted_map.get(promoted.0).cloned() {\n+                    promoted.0 = p;\n+                }\n+            },\n+            _ => self.super_place(place, _ctxt, _location),\n         }\n     }\n \n@@ -749,14 +756,4 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n         *scope = self.scope_map[*scope];\n     }\n-\n-    fn visit_literal(&mut self, literal: &mut Literal<'tcx>, loc: Location) {\n-        if let Literal::Promoted { ref mut index } = *literal {\n-            if let Some(p) = self.promoted_map.get(*index).cloned() {\n-                *index = p;\n-            }\n-        } else {\n-            self.super_literal(literal, loc);\n-        }\n-    }\n }"}, {"sha": "6e06beb30419d12e6e7f764d44e4bfd06c8d37bf", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -10,7 +10,7 @@\n \n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n+use rustc::mir::{Constant, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{TyCtxt, TypeVariants};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -103,8 +103,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n             if let TypeVariants::TyArray(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n-                let literal = Literal::Value { value: len };\n-                let constant = Constant { span, ty, literal };\n+                let constant = Constant { span, ty, literal: len };\n                 self.optimizations.arrays_lengths.insert(location, constant);\n             }\n         }"}, {"sha": "1d1ef1a151aa973598b0f58e64c6f5819695f057", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 12, "deletions": 50, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -25,12 +25,12 @@\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n-use std::{cmp, iter, mem, usize};\n+use std::{iter, mem, usize};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -152,7 +152,6 @@ struct Promoter<'a, 'tcx: 'a> {\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n-    extra_statements: &'a mut Vec<(Location, Statement<'tcx>)>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -288,27 +287,21 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n-        let mut rvalue = {\n+        let mut operand = {\n             let promoted = &mut self.promoted;\n-            let literal = Literal::Promoted {\n-                index: Promoted::new(self.source.promoted.len())\n-            };\n-            let operand = |ty, span| {\n+            let promoted_id = Promoted::new(self.source.promoted.len());\n+            let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] =\n                     LocalDecl::new_return_place(ty, span);\n-                Operand::Constant(box Constant {\n-                    span,\n-                    ty,\n-                    literal\n-                })\n+                Place::Promoted(box (promoted_id, ty))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(_, Rvalue::Ref(r, bk, ref mut place)) => {\n+                        StatementKind::Assign(_, Rvalue::Ref(_, _, ref mut place)) => {\n                             // Find the underlying local for this (necessarilly interior) borrow.\n                             // HACK(eddyb) using a recursive function because of mutable borrows.\n                             fn interior_base<'a, 'tcx>(place: &'a mut Place<'tcx>)\n@@ -322,32 +315,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             let place = interior_base(place);\n \n                             let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n-                            let ref_ty = self.tcx.mk_ref(r,\n-                                ty::TypeAndMut {\n-                                    ty,\n-                                    mutbl: bk.to_mutbl_lossy()\n-                                }\n-                            );\n                             let span = statement.source_info.span;\n \n-                            // Create a temp to hold the promoted reference.\n-                            // This is because `*r` requires `r` to be a local,\n-                            // otherwise we would use the `promoted` directly.\n-                            let mut promoted_ref = LocalDecl::new_temp(ref_ty, span);\n-                            promoted_ref.source_info = statement.source_info;\n-                            promoted_ref.visibility_scope = statement.source_info.scope;\n-                            let promoted_ref = local_decls.push(promoted_ref);\n-                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-                            self.extra_statements.push((loc, Statement {\n-                                source_info: statement.source_info,\n-                                kind: StatementKind::Assign(\n-                                    Place::Local(promoted_ref),\n-                                    Rvalue::Use(operand(ref_ty, span)),\n-                                )\n-                            }));\n-                            let promoted_place = Place::Local(promoted_ref).deref();\n-\n-                            Rvalue::Ref(r, bk, mem::replace(place, promoted_place))\n+                            Operand::Move(mem::replace(place, promoted_place(ty, span)))\n                         }\n                         _ => bug!()\n                     }\n@@ -358,7 +328,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         TerminatorKind::Call { ref mut args, .. } => {\n                             let ty = args[index].ty(local_decls, self.tcx);\n                             let span = terminator.source_info.span;\n-                            Rvalue::Use(mem::replace(&mut args[index], operand(ty, span)))\n+                            let operand = Operand::Copy(promoted_place(ty, span));\n+                            mem::replace(&mut args[index], operand)\n                         }\n                         _ => bug!()\n                     }\n@@ -367,13 +338,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         };\n \n         assert_eq!(self.new_block(), START_BLOCK);\n-        self.visit_rvalue(&mut rvalue, Location {\n+        self.visit_operand(&mut operand, Location {\n             block: BasicBlock::new(0),\n             statement_index: usize::MAX\n         });\n \n         let span = self.promoted.span;\n-        self.assign(RETURN_PLACE, rvalue, span);\n+        self.assign(RETURN_PLACE, Rvalue::Use(operand), span);\n         self.source.promoted.push(self.promoted);\n     }\n }\n@@ -397,7 +368,6 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n-    let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n             Candidate::Ref(Location { block, statement_index }) => {\n@@ -437,19 +407,11 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n             tcx,\n             source: mir,\n             temps: &mut temps,\n-            extra_statements: &mut extra_statements,\n             keep_original: false\n         };\n         promoter.promote_candidate(candidate);\n     }\n \n-    // Insert each of `extra_statements` before its indicated location, which\n-    // has to be done in reverse location order, to not invalidate the rest.\n-    extra_statements.sort_by_key(|&(loc, _)| cmp::Reverse(loc));\n-    for (loc, statement) in extra_statements {\n-        mir[loc.block].statements.insert(loc.statement_index, statement);\n-    }\n-\n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in mir.basic_blocks_mut() {"}, {"sha": "4e1129ea7e94587067e63d48caf3d96fa6fa0b2b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -449,6 +449,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     location: Location) {\n         match *place {\n             Place::Local(ref local) => self.visit_local(local, context, location),\n+            Place::Promoted(_) => bug!(\"promoting already promoted MIR\"),\n             Place::Static(ref global) => {\n                 if self.tcx\n                        .get_attrs(global.def_id)\n@@ -558,12 +559,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Operand::Constant(ref constant) => {\n-                if let Literal::Value {\n-                    value: &ty::Const { val: ConstValue::Unevaluated(def_id, _), ty, .. }\n-                } = constant.literal {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if self.tcx.trait_of_item(def_id).is_some() {\n-                        self.add_type(ty);\n+                        self.add_type(constant.literal.ty);\n                     } else {\n                         let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n@@ -573,7 +572,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         // Just in case the type is more specific than\n                         // the definition, e.g. impl associated const\n                         // with type parameters, take it into account.\n-                        self.qualif.restrict(ty, self.tcx, self.param_env);\n+                        self.qualif.restrict(constant.literal.ty, self.tcx, self.param_env);\n                     }\n                 }\n             }"}, {"sha": "e14941b8aeb9a2e6075214eb907edff21cb6032d", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -36,11 +36,11 @@ impl MirPass for SimplifyBranches {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n-                TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n-                    literal: Literal::Value { ref value }, ..\n-                }), switch_ty, ref values, ref targets, .. } => {\n+                TerminatorKind::SwitchInt {\n+                    discr: Operand::Constant(ref c), switch_ty, ref values, ref targets, ..\n+                } => {\n                     let switch_ty = ParamEnv::empty().and(switch_ty);\n-                    if let Some(constint) = value.assert_bits(tcx, switch_ty) {\n+                    if let Some(constint) = c.literal.assert_bits(tcx, switch_ty) {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (&v, t) in values.iter().zip(targets.iter()) {\n@@ -54,11 +54,9 @@ impl MirPass for SimplifyBranches {\n                         continue\n                     }\n                 },\n-                TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n-                    literal: Literal::Value {\n-                        value\n-                    }, ..\n-                }), expected, .. } if (value.assert_bool(tcx) == Some(true)) == expected => {\n+                TerminatorKind::Assert {\n+                    target, cond: Operand::Constant(ref c), expected, ..\n+                } if (c.literal.assert_bool(tcx) == Some(true)) == expected => {\n                     TerminatorKind::Goto { target: target }\n                 },\n                 TerminatorKind::FalseEdges { real_target, .. } => {"}, {"sha": "689eb62042bcc87dca0ce1ebfa634e9a5218813e", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -960,9 +960,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n-            literal: Literal::Value {\n-                value: ty::Const::from_usize(self.tcx(), val.into())\n-            }\n+            literal: ty::Const::from_usize(self.tcx(), val.into()),\n         })\n     }\n "}, {"sha": "3206fa6e17265c36a87fb3d0f07625bdba9794cd", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -13,7 +13,7 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n-use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n+use rustc::mir::{Constant, Location, Local, LocalDecl};\n use rustc::mir::{Place, PlaceElem, PlaceProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n@@ -204,6 +204,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match *place {\n             Place::Local(..) => \"Place::Local\",\n             Place::Static(..) => \"Place::Static\",\n+            Place::Promoted(..) => \"Place::Promoted\",\n             Place::Projection(..) => \"Place::Projection\",\n         }, place);\n         self.super_place(place, context, location);\n@@ -240,17 +241,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_constant(constant, location);\n     }\n \n-    fn visit_literal(&mut self,\n-                     literal: &Literal<'tcx>,\n-                     location: Location) {\n-        self.record(\"Literal\", literal);\n-        self.record(match *literal {\n-            Literal::Value { .. } => \"Literal::Value\",\n-            Literal::Promoted { .. } => \"Literal::Promoted\",\n-        }, literal);\n-        self.super_literal(literal, location);\n-    }\n-\n     fn visit_source_info(&mut self,\n                          source_info: &SourceInfo) {\n         self.record(\"SourceInfo\", source_info);"}, {"sha": "8f8c406bcb3a4278ca18ffd5e2c2b7a67094d3b9", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -122,19 +122,15 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //     let mut _6: &'10s S1;\n //     let mut _7: &'10s S1;\n //     let mut _8: S1;\n-//     let mut _9: &'10s S1;\n-//     let mut _10: &'12ds S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _10 = promoted[1];\n-//         _4 = &'12ds (*_10);\n+//         _4 = &'12ds (promoted[1]: S1);\n //         _3 = &'12ds (*_4);\n //         StorageLive(_6);\n //         StorageLive(_7);\n-//         _9 = promoted[0];\n-//         _7 = &'10s (*_9);\n+//         _7 = &'10s (promoted[0]: S1);\n //         _6 = &'10s (*_7);\n //         _2 = D1<'12ds, '10s>::{{constructor}}(move _3, move _6);\n //         EndRegion('10s);"}, {"sha": "43e711ca902f89923a5cfb0bdb49cb0aa212f9f1", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -54,8 +54,7 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      _3 = discriminant(_2);\n-//      _14 = promoted[1];\n-//      _4 = &(*_14);\n+//      _4 = &(promoted[1]: std::option::Option<i32>);\n //      _9 = discriminant(_2);\n //      switchInt(move _9) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n //  }\n@@ -86,8 +85,7 @@ fn main() {\n //  }\n //  bb8: { // binding1 and guard\n //      StorageLive(_7);\n-//      _13 = promoted[0];\n-//      _7 = &(((*_13) as Some).0: i32);\n+//      _7 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = const guard() -> [return: bb9, unwind: bb1];\n //  }"}, {"sha": "86287e1299729f14fcb5b6ae61ffc3d43cf44c12", "filename": "src/test/ui/const-eval/conditional_array_execution.nll.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.nll.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -12,21 +12,6 @@ note: lint level defined here\n LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n-warning: referenced constant has errors\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n-   |                   ----- attempt to subtract with overflow\n-...\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^ referenced constant has errors\n-\n error[E0080]: referenced constant has errors\n   --> $DIR/conditional_array_execution.rs:19:14\n    |"}, {"sha": "b3f56f27f635236e9cdfce4468b1ee79278bf46b", "filename": "src/test/ui/const-eval/conditional_array_execution.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -17,8 +17,6 @@ const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n \n fn main() {\n     println!(\"{}\", FOO);\n-    //~^ WARN this expression will panic at runtime\n-    //~| WARN referenced constant\n-    //~| ERROR erroneous constant used\n+    //~^ ERROR erroneous constant used\n     //~| E0080\n }"}, {"sha": "29f5f8e2ade59198d3eb2182f7942da7691f4f84", "filename": "src/test/ui/const-eval/conditional_array_execution.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -12,21 +12,6 @@ note: lint level defined here\n LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n-warning: referenced constant has errors\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n-   |                   ----- attempt to subtract with overflow\n-...\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^ referenced constant has errors\n-\n error[E0080]: referenced constant has errors\n   --> $DIR/conditional_array_execution.rs:19:20\n    |"}, {"sha": "732fe459834603d098f08a69efce47f1a999ac1c", "filename": "src/test/ui/const-eval/issue-43197.nll.stderr", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.nll.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -20,36 +20,6 @@ LL |     const Y: u32 = foo(0-1);\n    |                        |\n    |                        attempt to subtract with overflow\n \n-warning: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     const X: u32 = 0-1;\n-   |                    --- attempt to subtract with overflow\n-...\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^ referenced constant has errors\n-\n-warning: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     const Y: u32 = foo(0-1);\n-   |                        --- attempt to subtract with overflow\n-LL |     //~^ WARN this constant cannot be used\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^ referenced constant has errors\n-\n error[E0080]: referenced constant has errors\n   --> $DIR/issue-43197.rs:24:14\n    |"}, {"sha": "c0b45f0ba3041a9df2dec53de039f03eea1e3838", "filename": "src/test/ui/const-eval/issue-43197.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -22,12 +22,8 @@ fn main() {\n     const Y: u32 = foo(0-1);\n     //~^ WARN this constant cannot be used\n     println!(\"{} {}\", X, Y);\n-    //~^ WARN this expression will panic at runtime\n-    //~| WARN this expression will panic at runtime\n-    //~| ERROR erroneous constant used\n+    //~^ ERROR erroneous constant used\n     //~| ERROR erroneous constant used\n     //~| ERROR E0080\n     //~| ERROR E0080\n-    //~| WARN referenced constant\n-    //~| WARN referenced constant\n }"}, {"sha": "66921dcd7c50835ab02411acc6263f838fcc5b46", "filename": "src/test/ui/const-eval/issue-43197.stderr", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -20,36 +20,6 @@ LL |     const Y: u32 = foo(0-1);\n    |                        |\n    |                        attempt to subtract with overflow\n \n-warning: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     const X: u32 = 0-1;\n-   |                    --- attempt to subtract with overflow\n-...\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^ referenced constant has errors\n-\n-warning: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     const Y: u32 = foo(0-1);\n-   |                        --- attempt to subtract with overflow\n-LL |     //~^ WARN this constant cannot be used\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^\n-\n-warning: this expression will panic at runtime\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^ referenced constant has errors\n-\n error[E0080]: referenced constant has errors\n   --> $DIR/issue-43197.rs:24:26\n    |"}, {"sha": "f0f35ce614e613d4d83373d78df9df5e829d25c7", "filename": "src/test/ui/const-eval/promoted_const_fn_fail.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-pass\n+\n #![feature(const_fn)]\n \n #![deny(const_err)]\n@@ -23,15 +25,13 @@ const fn bar() -> u8 {\n         // is run on a system whose pointers need more\n         // than 8 bits\n         Bar { a: &42 }.b as u8\n-        //~^ ERROR this expression will panic at runtime\n-        //~| ERROR this expression will panic at runtime\n     }\n }\n \n fn main() {\n-    // FIXME(oli-obk): this should compile but panic at runtime\n-    // if we change the `const_err` lint to allow this will actually compile, but then\n-    // continue with undefined values.\n+    // FIXME(oli-obk): this should panic at runtime\n+    // this will actually compile, but then\n+    // abort at runtime (not panic, hard abort).\n     let x: &'static u8 = &(bar() + 1);\n     let y = *x;\n     unreachable!();"}, {"sha": "d805e1a27c9938811c43fc73f14c1d70afae2584", "filename": "src/test/ui/const-eval/promoted_const_fn_fail.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1e6bcb2085cba3d5e549ba3b175f99487c21639/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1e6bcb2085cba3d5e549ba3b175f99487c21639/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_const_fn_fail.stderr?ref=a1e6bcb2085cba3d5e549ba3b175f99487c21639", "patch": "@@ -1,20 +0,0 @@\n-error: this expression will panic at runtime\n-  --> $DIR/promoted_const_fn_fail.rs:25:9\n-   |\n-LL |         Bar { a: &42 }.b as u8\n-   |         ^^^^^^^^^^^^^^^^^^^^^^ a raw memory access tried to access part of a pointer value as raw bytes\n-   |\n-note: lint level defined here\n-  --> $DIR/promoted_const_fn_fail.rs:13:9\n-   |\n-LL | #![deny(const_err)]\n-   |         ^^^^^^^^^\n-\n-error: this expression will panic at runtime\n-  --> $DIR/promoted_const_fn_fail.rs:25:9\n-   |\n-LL |         Bar { a: &42 }.b as u8\n-   |         ^^^^^^^^^^^^^^^^^^^^^^ a raw memory access tried to access part of a pointer value as raw bytes\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "a58c4be66c42459e745ae86a6fd705894d710176", "filename": "src/test/ui/const-eval/promoted_errors.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -18,13 +18,11 @@ fn main() {\n     //~^ WARN const_err\n     println!(\"{}\", 1/(1-1));\n     //~^ WARN const_err\n-    //~| WARN const_err\n     let _x = 1/(1-1);\n     //~^ WARN const_err\n     //~| WARN const_err\n     println!(\"{}\", 1/(false as u32));\n     //~^ WARN const_err\n-    //~| WARN const_err\n     let _x = 1/(false as u32);\n     //~^ WARN const_err\n     //~| WARN const_err"}, {"sha": "85b5696be947cf2097f546f22cc790387da1737f", "filename": "src/test/ui/const-eval/promoted_errors.stderr", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -16,44 +16,32 @@ warning: attempt to divide by zero\n LL |     println!(\"{}\", 1/(1-1));\n    |                    ^^^^^^^\n \n-warning: this expression will panic at runtime\n-  --> $DIR/promoted_errors.rs:19:20\n-   |\n-LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^ attempt to divide by zero\n-\n warning: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:22:14\n+  --> $DIR/promoted_errors.rs:21:14\n    |\n LL |     let _x = 1/(1-1);\n    |              ^^^^^^^\n \n warning: this expression will panic at runtime\n-  --> $DIR/promoted_errors.rs:22:14\n+  --> $DIR/promoted_errors.rs:21:14\n    |\n LL |     let _x = 1/(1-1);\n    |              ^^^^^^^ attempt to divide by zero\n \n warning: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:25:20\n+  --> $DIR/promoted_errors.rs:24:20\n    |\n LL |     println!(\"{}\", 1/(false as u32));\n    |                    ^^^^^^^^^^^^^^^^\n \n-warning: this expression will panic at runtime\n-  --> $DIR/promoted_errors.rs:25:20\n-   |\n-LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^ attempt to divide by zero\n-\n warning: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:28:14\n+  --> $DIR/promoted_errors.rs:26:14\n    |\n LL |     let _x = 1/(false as u32);\n    |              ^^^^^^^^^^^^^^^^\n \n warning: this expression will panic at runtime\n-  --> $DIR/promoted_errors.rs:28:14\n+  --> $DIR/promoted_errors.rs:26:14\n    |\n LL |     let _x = 1/(false as u32);\n    |              ^^^^^^^^^^^^^^^^ attempt to divide by zero"}]}