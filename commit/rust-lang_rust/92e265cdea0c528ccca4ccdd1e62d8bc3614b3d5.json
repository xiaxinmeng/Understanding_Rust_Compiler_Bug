{"sha": "92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTI2NWNkZWEwYzUyOGNjY2E0Y2NkZDFlNjJkOGJjMzYxNGIzZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T00:12:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T00:12:58Z"}, "message": "auto merge of #5802 : nikomatsakis/rust/issue-4183-trait-substs, r=nikomatsakis\n\nCleanup substitutions and treatment of generics around traits in a number of ways\r\n\r\n- In a TraitRef, use the self type consistently to refer to the Self type:\r\n  - trait ref in `impl Trait<A,B,C> for S` has a self type of `S`.\r\n  - trait ref in `A:Trait` has the self type `A`\r\n  - trait ref associated with a trait decl has self type `Self`\r\n  - trait ref associated with a supertype has self type `Self`\r\n  - trait ref in an object type `@Trait` has no self type\r\n\r\n- Rewrite `each_bound_traits_and_supertraits` to perform\r\n  substitutions as it goes, and thus yield a series of trait refs\r\n  that are always in the same 'namespace' as the type parameter\r\n  bound given as input.  Before, we left this to the caller, but\r\n  this doesn't work because the caller lacks adequare information\r\n  to perform the type substitutions correctly.\r\n\r\n- For provided methods, substitute the generics involved in the provided\r\n  method correctly.\r\n\r\n- Introduce TypeParameterDef, which tracks the bounds declared on a type\r\n  parameter and brings them together with the def_id and (in the future)\r\n  other information (maybe even the parameter's name!).\r\n\r\n- Introduce Subst trait, which helps to cleanup a lot of the\r\n  repetitive code involved with doing type substitution.\r\n\r\n- Introduce Repr trait, which makes debug printouts far more convenient.\r\n\r\nFixes #4183.  Needed for #5656.\r\n\r\nr? @catamorphism", "tree": {"sha": "a3a5a291d3949c6be6ab70f929912128325afc15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3a5a291d3949c6be6ab70f929912128325afc15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "html_url": "https://github.com/rust-lang/rust/commit/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e570ce4b087ad7f8623772b64a3d618df9b7756", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e570ce4b087ad7f8623772b64a3d618df9b7756", "html_url": "https://github.com/rust-lang/rust/commit/5e570ce4b087ad7f8623772b64a3d618df9b7756"}, {"sha": "e8cd29ba5ecae71cfde24d2e652b50acf63ea155", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cd29ba5ecae71cfde24d2e652b50acf63ea155", "html_url": "https://github.com/rust-lang/rust/commit/e8cd29ba5ecae71cfde24d2e652b50acf63ea155"}], "stats": {"total": 1873, "additions": 1253, "deletions": 620}, "files": [{"sha": "e2672338a8a0baa6e95ee8c7cfc461a862694c60", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -127,7 +127,7 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_node_type_subst = 0x58,\n     tag_table_freevars = 0x59,\n     tag_table_tcache = 0x5a,\n-    tag_table_param_bounds = 0x5b,\n+    tag_table_param_defs = 0x5b,\n     tag_table_inferred_modes = 0x5c,\n     tag_table_mutbl = 0x5d,\n     tag_table_last_use = 0x5e,"}, {"sha": "f7de281194f390ace39b0b26ff24d99d887dfb42", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -210,7 +210,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {bounds: @~[],\n+        generics: ty::Generics {type_param_defs: @~[],\n                                 region_param: None},\n         ty: ty\n     }"}, {"sha": "472b455b73531c2377d298b2b2a59a7ff0d70fb7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -19,7 +19,8 @@ use metadata::csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n-use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n+use metadata::tydecode::{parse_ty_data, parse_def_id,\n+                         parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::{ty, resolve};\n \n@@ -266,13 +267,14 @@ fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n-                        tag: uint)\n-    -> @~[ty::param_bounds] {\n+fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n+                      tag: uint)\n+    -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n     for reader::tagged_docs(item, tag) |p| {\n-        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx,\n-                                   |_, did| translate_def_id(cdata, did));\n+        let bd = parse_type_param_def_data(\n+            p.data, p.start, cdata.cnum, tcx,\n+            |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n     }\n     @bounds\n@@ -378,11 +380,11 @@ pub fn get_trait_def(cdata: cmd,\n                      tcx: ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data);\n-    let tp_bounds = item_ty_param_bounds(item_doc, tcx, cdata,\n-                                         tag_items_data_item_ty_param_bounds);\n+    let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n+                                     tag_items_data_item_ty_param_bounds);\n     let rp = item_ty_region_param(item_doc);\n     ty::TraitDef {\n-        generics: ty::Generics {bounds: tp_bounds,\n+        generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param: rp},\n         trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n     }\n@@ -394,12 +396,12 @@ pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let item = lookup_item(id, cdata.data);\n     let t = item_type(ast::def_id { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n-    let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n+    let tp_defs = if family_has_type_params(item_family(item)) {\n+        item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {bounds: tp_bounds,\n+        generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param: rp},\n         ty: t\n     }\n@@ -753,17 +755,16 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let method_doc = lookup_item(id, cdata.data);\n     let def_id = item_def_id(method_doc, cdata);\n     let name = item_name(intr, method_doc);\n-    let bounds =\n-        item_ty_param_bounds(method_doc, tcx, cdata,\n-                             tag_item_method_tps);\n+    let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n+                                             tag_item_method_tps);\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n     let self_ty = get_self_ty(method_doc);\n     ty::method {\n         ident: name,\n         generics: ty::Generics {\n-            bounds: bounds,\n+            type_param_defs: type_param_defs,\n             region_param: None\n         },\n         transformed_self_ty: transformed_self_ty,\n@@ -797,8 +798,9 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         let did = item_def_id(mth, cdata);\n \n-        let bounds = item_ty_param_bounds(mth, tcx, cdata,\n-                                          tag_items_data_item_ty_param_bounds);\n+        let type_param_defs =\n+            item_ty_param_defs(mth, tcx, cdata,\n+                               tag_items_data_item_ty_param_bounds);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n \n@@ -815,7 +817,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         let ty_method = ty::method {\n             ident: name,\n             generics: ty::Generics {\n-                bounds: bounds,\n+                type_param_defs: type_param_defs,\n                 region_param: None\n             },\n             transformed_self_ty: transformed_self_ty,"}, {"sha": "b9f0f63040aefb140b4d48aff5ee189bca05daa4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -179,10 +179,10 @@ fn encode_family(ebml_w: writer::Encoder, c: char) {\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: writer::Encoder,\n-                               ecx: @EncodeContext,\n-                               params: @~[ty::param_bounds],\n-                               tag: uint) {\n+fn encode_ty_type_param_defs(ebml_w: writer::Encoder,\n+                             ecx: @EncodeContext,\n+                             params: @~[ty::TypeParameterDef],\n+                             tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -191,18 +191,18 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder,\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag);\n-        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, *param);\n+        tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n     }\n }\n \n fn encode_type_param_bounds(ebml_w: writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n-    let ty_param_bounds =\n-        @params.map_to_vec(|param| *ecx.tcx.ty_param_bounds.get(&param.id));\n-    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds,\n-                                tag_items_data_item_ty_param_bounds);\n+    let ty_param_defs =\n+        @params.map_to_vec(|param| *ecx.tcx.ty_param_defs.get(&param.id));\n+    encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n+                              tag_items_data_item_ty_param_bounds);\n }\n \n \n@@ -588,8 +588,9 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ecx, ebml_w, method_ty.ident);\n-    encode_ty_type_param_bounds(ebml_w, ecx, method_ty.generics.bounds,\n-                                tag_item_method_tps);\n+    encode_ty_type_param_defs(ebml_w, ecx,\n+                              method_ty.generics.type_param_defs,\n+                              tag_item_method_tps);\n     encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n@@ -952,8 +953,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                       method_ty.fty.purity));\n \n                     let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_ty_type_param_bounds(ebml_w, ecx, tpt.generics.bounds,\n-                                                tag_items_data_item_ty_param_bounds);\n+                    encode_ty_type_param_defs(ebml_w, ecx,\n+                                              tpt.generics.type_param_defs,\n+                                              tag_items_data_item_ty_param_bounds);\n                     encode_type(ecx, ebml_w, tpt.ty);\n                 }\n "}, {"sha": "867fe0cd816cce4b549eae09ef2f4f8ecb47bfaa", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -547,11 +547,17 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     ast::def_id { crate: crate_num, node: def_num }\n }\n \n-pub fn parse_bounds_data(data: @~[u8], start: uint,\n-                         crate_num: int, tcx: ty::ctxt, conv: conv_did)\n-                      -> @~[ty::param_bound] {\n+pub fn parse_type_param_def_data(data: @~[u8], start: uint,\n+                                 crate_num: int, tcx: ty::ctxt,\n+                                 conv: conv_did) -> ty::TypeParameterDef\n+{\n     let st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_bounds(st, conv)\n+    parse_type_param_def(st, conv)\n+}\n+\n+fn parse_type_param_def(st: @mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+    ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n+                          bounds: parse_bounds(st, conv)}\n }\n \n fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {"}, {"sha": "238f34b8c01b97e128ac513a8bf2396022075395", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -412,7 +412,7 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-pub fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n+fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         match *bound {\n           ty::bound_owned => w.write_char('S'),\n@@ -428,6 +428,12 @@ pub fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     w.write_char('.');\n }\n \n+pub fn enc_type_param_def(w: @io::Writer, cx: @ctxt, v: &ty::TypeParameterDef) {\n+    w.write_str((cx.ds)(v.def_id));\n+    w.write_char('|');\n+    enc_bounds(w, cx, v.bounds);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "68989b3142566a2dd2f1f7d46aaa8089f718b671", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -741,7 +741,9 @@ trait ebml_writer_helpers {\n     fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t);\n     fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore);\n     fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]);\n-    fn emit_bounds(&self, ecx: @e::EncodeContext, bs: ty::param_bounds);\n+    fn emit_type_param_def(&self,\n+                           ecx: @e::EncodeContext,\n+                           type_param_def: &ty::TypeParameterDef);\n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n@@ -771,9 +773,12 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    fn emit_bounds(&self, ecx: @e::EncodeContext, bs: ty::param_bounds) {\n+    fn emit_type_param_def(&self,\n+                           ecx: @e::EncodeContext,\n+                           type_param_def: &ty::TypeParameterDef) {\n         do self.emit_opaque {\n-            tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n+            tyencode::enc_type_param_def(self.writer, ecx.ty_str_ctxt(),\n+                                         type_param_def)\n         }\n     }\n \n@@ -782,9 +787,11 @@ impl ebml_writer_helpers for writer::Encoder {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n             do self.emit_field(~\"generics\", 0) {\n                 do self.emit_struct(\"Generics\", 2) {\n-                    do self.emit_field(~\"bounds\", 0) {\n-                        do self.emit_from_vec(*tpbt.generics.bounds) |bs| {\n-                            self.emit_bounds(ecx, *bs);\n+                    do self.emit_field(~\"type_param_defs\", 0) {\n+                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n+                            |type_param_def|\n+                        {\n+                            self.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n                     do self.emit_field(~\"region_param\", 1) {\n@@ -889,11 +896,11 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for tcx.ty_param_bounds.find(&id).each |&pbs| {\n-        do ebml_w.tag(c::tag_table_param_bounds) {\n+    for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n+        do ebml_w.tag(c::tag_table_param_defs) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                ebml_w.emit_bounds(ecx, *pbs)\n+                ebml_w.emit_type_param_def(ecx, type_param_def)\n             }\n         }\n     }\n@@ -990,7 +997,7 @@ trait ebml_decoder_decoder_helpers {\n     fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg;\n     fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t;\n     fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n-    fn read_bounds(&self, xcx: @ExtendedDecodeContext) -> @~[ty::param_bound];\n+    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef;\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n     fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n@@ -1038,10 +1045,9 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n-    fn read_bounds(&self, xcx: @ExtendedDecodeContext)\n-                  -> @~[ty::param_bound] {\n+    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef {\n         do self.read_opaque |doc| {\n-            tydecode::parse_bounds_data(\n+            tydecode::parse_type_param_def_data(\n                 doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n@@ -1054,8 +1060,8 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n             ty::ty_param_bounds_and_ty {\n                 generics: do self.read_struct(\"Generics\", 2) {\n                     ty::Generics {\n-                        bounds: self.read_field(~\"bounds\", 0, || {\n-                            @self.read_to_vec(|| self.read_bounds(xcx) )\n+                        type_param_defs: self.read_field(\"type_param_defs\", 0, || {\n+                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n                         }),\n                         region_param: self.read_field(~\"region_param\", 1, || {\n                             Decodable::decode(self)\n@@ -1134,9 +1140,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n                 let lid = ast::def_id { crate: ast::local_crate, node: id };\n                 dcx.tcx.tcache.insert(lid, tpbt);\n-            } else if tag == (c::tag_table_param_bounds as uint) {\n-                let bounds = val_dsr.read_bounds(xcx);\n-                dcx.tcx.ty_param_bounds.insert(id, bounds);\n+            } else if tag == (c::tag_table_param_defs as uint) {\n+                let bounds = val_dsr.read_type_param_def(xcx);\n+                dcx.tcx.ty_param_defs.insert(id, bounds);\n             } else if tag == (c::tag_table_last_use as uint) {\n                 let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())"}, {"sha": "233b1e191dc248e6d2f13cdebf83585913e0709e", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -29,7 +29,7 @@ use middle::pat_util;\n use middle::ty::{ty_region};\n use middle::ty;\n use util::common::indenter;\n-use util::ppaux::{expr_repr, region_to_str};\n+use util::ppaux::{Repr, region_to_str};\n \n use core::hashmap::{HashSet, HashMap};\n use core::vec;\n@@ -282,7 +282,7 @@ pub impl GatherLoanCtxt {\n                              expr: @ast::expr,\n                              adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n-               expr_repr(self.tcx(), expr), adjustment);\n+               expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n \n         match *adjustment {"}, {"sha": "e82b6ba5e7710b5138428a23011bf18466985fc2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -16,7 +16,7 @@ use middle::liveness;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, tys_to_str};\n+use util::ppaux::{Repr, ty_to_str, tys_to_str};\n \n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n@@ -91,7 +91,7 @@ fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if struct_tpt.generics.bounds.len() == 0 {\n+    if !struct_tpt.generics.has_type_params() {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n             self_r: None,\n             self_ty: None,\n@@ -276,31 +276,31 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n         // FIXME(#5562): removing this copy causes a segfault before stage2\n         let ts = /*bad*/ copy **ts;\n-        let bounds = match e.node {\n+        let type_param_defs = match e.node {\n           expr_path(_) => {\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n-            ty::lookup_item_type(cx.tcx, did).generics.bounds\n+            ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n           }\n           _ => {\n             // Type substitutions should only occur on paths and\n             // method calls, so this needs to be a method call.\n \n             // Even though the callee_id may have been the id with\n             // node_type_substs, e.id is correct here.\n-            ty::method_call_bounds(cx.tcx, cx.method_map, e.id).expect(\n+            ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n                 ~\"non path/method call expr has type substs??\")\n           }\n         };\n-        if ts.len() != bounds.len() {\n+        if ts.len() != type_param_defs.len() {\n             // Fail earlier to make debugging easier\n             fail!(fmt!(\"internal error: in kind::check_expr, length \\\n                        mismatch between actual and declared bounds: actual = \\\n-                        %s (%u tys), declared = %? (%u tys)\",\n-                      tys_to_str(cx.tcx, ts), ts.len(),\n-                      *bounds, bounds.len()));\n+                        %s, declared = %s\",\n+                       ts.repr(cx.tcx),\n+                       type_param_defs.repr(cx.tcx)));\n         }\n-        for vec::each2(ts, *bounds) |ty, bound| {\n-            check_bounds(cx, type_parameter_id, e.span, *ty, *bound)\n+        for vec::each2(ts, *type_param_defs) |&ty, type_param_def| {\n+            check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n         }\n     }\n \n@@ -340,9 +340,10 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n             // FIXME(#5562): removing this copy causes a segfault before stage2\n             let ts = /*bad*/ copy **ts;\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n-            let bounds = ty::lookup_item_type(cx.tcx, did).generics.bounds;\n-            for vec::each2(ts, *bounds) |ty, bound| {\n-                check_bounds(cx, aty.id, aty.span, *ty, *bound)\n+            let type_param_defs =\n+                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n+            for vec::each2(ts, *type_param_defs) |&ty, type_param_def| {\n+                check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n             }\n         }\n       }\n@@ -355,11 +356,11 @@ pub fn check_bounds(cx: Context,\n                     _type_parameter_id: node_id,\n                     sp: span,\n                     ty: ty::t,\n-                    bounds: ty::param_bounds)\n+                    type_param_def: &ty::TypeParameterDef)\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ~[];\n-    for bounds.each |bound| {\n+    for type_param_def.bounds.each |bound| {\n         match *bound {\n             ty::bound_trait(_) => {\n                 /* Not our job, checking in typeck */"}, {"sha": "a754f93f010381b60b2fe32a3a662f7737bdfb0b", "filename": "src/librustc/middle/subst.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type substitutions.\n+\n+use core::prelude::*;\n+use middle::ty;\n+use util::ppaux::Repr;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Public trait `Subst`\n+//\n+// Just call `foo.subst(tcx, substs)` to perform a substitution across\n+// `foo`.\n+\n+pub trait Subst {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Substitution over types\n+//\n+// Because this is so common, we make a special optimization to avoid\n+// doing anything if `substs` is a no-op.  I tried to generalize these\n+// to all subst methods but ran into trouble due to the limitations of\n+// our current method/trait matching algorithm. - Niko\n+\n+trait EffectfulSubst {\n+    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self;\n+}\n+\n+impl Subst for ty::t {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n+        if ty::substs_is_noop(substs) {\n+            return *self;\n+        } else {\n+            return self.effectfulSubst(tcx, substs);\n+        }\n+    }\n+}\n+\n+impl EffectfulSubst for ty::t {\n+    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n+        if !ty::type_needs_subst(*self) {\n+            return *self;\n+        }\n+\n+        match ty::get(*self).sty {\n+            ty::ty_param(p) => {\n+                substs.tps[p.idx]\n+            }\n+            ty::ty_self(_) => {\n+                substs.self_ty.expect(\"ty_self not found in substs\")\n+            }\n+            _ => {\n+                ty::fold_regions_and_ty(\n+                    tcx, *self,\n+                    |r| match r {\n+                        ty::re_bound(ty::br_self) => {\n+                            match substs.self_r {\n+                                None => {\n+                                    tcx.sess.bug(\n+                                        fmt!(\"ty::subst: \\\n+                                              Reference to self region when \\\n+                                              given substs with no self region, \\\n+                                              ty = %s\",\n+                                             self.repr(tcx)));\n+                                }\n+                                Some(self_r) => self_r\n+                            }\n+                        }\n+                        _ => r\n+                    },\n+                    |t| t.effectfulSubst(tcx, substs),\n+                    |t| t.effectfulSubst(tcx, substs))\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other types\n+\n+impl<T:Subst> Subst for ~[T] {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ~[T] {\n+        self.map(|t| t.subst(tcx, substs))\n+    }\n+}\n+\n+impl<T:Subst> Subst for @~[T] {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @~[T] {\n+        @(**self).subst(tcx, substs)\n+    }\n+}\n+\n+impl<T:Subst> Subst for Option<T> {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Option<T> {\n+        self.map(|t| t.subst(tcx, substs))\n+    }\n+}\n+\n+impl Subst for ty::TraitRef {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::TraitRef {\n+        ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: self.substs.subst(tcx, substs)\n+        }\n+    }\n+}\n+\n+impl Subst for ty::substs {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::substs {\n+        ty::substs {\n+            self_r: self.self_r,\n+            self_ty: self.self_ty.map(|typ| typ.subst(tcx, substs)),\n+            tps: self.tps.map(|typ| typ.subst(tcx, substs))\n+        }\n+    }\n+}\n+\n+impl Subst for ty::BareFnTy {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::BareFnTy {\n+        ty::fold_bare_fn_ty(self, |t| t.subst(tcx, substs))\n+    }\n+}\n+\n+impl Subst for ty::param_bound {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::param_bound {\n+        match self {\n+            &ty::bound_copy |\n+            &ty::bound_durable |\n+            &ty::bound_owned |\n+            &ty::bound_const => {\n+                *self\n+            }\n+\n+            &ty::bound_trait(tref) => {\n+                ty::bound_trait(@tref.subst(tcx, substs))\n+            }\n+        }\n+    }\n+}\n+\n+impl Subst for ty::TypeParameterDef {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::TypeParameterDef {\n+        ty::TypeParameterDef {\n+            def_id: self.def_id,\n+            bounds: self.bounds.subst(tcx, substs)\n+        }\n+    }\n+}\n+\n+impl Subst for ty::Generics {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Generics {\n+        ty::Generics {\n+            type_param_defs: self.type_param_defs.subst(tcx, substs),\n+            region_param: self.region_param\n+        }\n+    }\n+}\n+\n+impl Subst for ty::ty_param_bounds_and_ty {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ty_param_bounds_and_ty {\n+        ty::ty_param_bounds_and_ty {\n+            generics: self.generics.subst(tcx, substs),\n+            ty: self.ty.subst(tcx, substs)\n+        }\n+    }\n+}\n+"}, {"sha": "2eb7f8332ca92551c823040d80cd0948d1c98075", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -63,7 +63,7 @@ use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::ty;\n use util::common::indenter;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::{Repr, ty_to_str};\n use util::ppaux;\n \n use core::hash;\n@@ -1592,11 +1592,11 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n     for param_substs.each |p| { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n-            param_substs=%s\",\n+            param_substs=%s)\",\n            path_str(ccx.sess, path),\n            id,\n            impl_id,\n-           opt_param_substs_to_str(ccx.tcx, &param_substs));\n+           param_substs.repr(ccx.tcx));\n \n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @mut fn_ctxt_ {\n@@ -1788,6 +1788,9 @@ pub fn trans_closure(ccx: @CrateContext,\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n+    debug!(\"trans_closure(..., param_substs=%s)\",\n+           param_substs.repr(ccx.tcx));\n+\n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n                                   Some(body.span));\n@@ -1849,7 +1852,9 @@ pub fn trans_fn(ccx: @CrateContext,\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { time::Timespec::new(0, 0) };\n-    debug!(\"trans_fn(ty_self=%?)\", ty_self);\n+    debug!(\"trans_fn(ty_self=%?, param_substs=%s)\",\n+           ty_self,\n+           param_substs.repr(ccx.tcx));\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);"}, {"sha": "20382676fed21bce76ab168803b44fdc39dc97cf", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -42,6 +42,7 @@ use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n use util::common::indenter;\n+use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::ast_map;\n@@ -74,24 +75,13 @@ pub struct Callee {\n \n pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     let _icx = bcx.insn_ctxt(\"trans_callee\");\n+    debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n         ast::expr_path(_) => {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n-        ast::expr_field(base, _, _) => {\n-            match bcx.ccx().maps.method_map.find(&expr.id) {\n-                Some(origin) => { // An impl method\n-                    // FIXME(#5562): removing this copy causes a segfault\n-                    //               before stage2\n-                    let origin = /*bad*/ copy *origin;\n-                    return meth::trans_method_callee(bcx, expr.id,\n-                                                     base, origin);\n-                }\n-                None => {} // not a method, just a field\n-            }\n-        }\n         _ => {}\n     }\n \n@@ -178,11 +168,13 @@ pub fn trans_fn_ref(bcx: block,\n      * with id `def_id` into a function pointer.  This may require\n      * monomorphization or inlining. */\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn\");\n+    let _icx = bcx.insn_ctxt(\"trans_fn_ref\");\n \n     let type_params = node_id_type_params(bcx, ref_id);\n-\n     let vtables = node_vtables(bcx, ref_id);\n+    debug!(\"trans_fn_ref(def_id=%s, ref_id=%?, type_params=%s, vtables=%s)\",\n+           def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n+           vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n }\n \n@@ -224,12 +216,13 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%?, ref_id=%?, \\\n-            type_params=%?, vtables=%?)\",\n-           bcx.to_str(), def_id, ref_id,\n-           type_params.map(|t| bcx.ty_to_str(*t)),\n-           vtables);\n-    let _indenter = indenter();\n+    debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%s, ref_id=%?, \\\n+            type_params=%s, vtables=%s)\",\n+           bcx.to_str(),\n+           def_id.repr(bcx.tcx()),\n+           ref_id,\n+           type_params.repr(bcx.tcx()),\n+           vtables.repr(bcx.tcx()));\n \n     assert!(type_params.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -335,6 +328,9 @@ pub fn trans_method_call(in_cx: block,\n                          dest: expr::Dest)\n                       -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n+    debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n+           call_ex.repr(in_cx.tcx()),\n+           rcvr.repr(in_cx.tcx()));\n     trans_call_inner(\n         in_cx,\n         call_ex.info(),\n@@ -343,9 +339,14 @@ pub fn trans_method_call(in_cx: block,\n         |cx| {\n             match cx.ccx().maps.method_map.find(&call_ex.id) {\n                 Some(origin) => {\n+                    debug!(\"origin for %s: %s\",\n+                           call_ex.repr(in_cx.tcx()),\n+                           origin.repr(in_cx.tcx()));\n+\n                     // FIXME(#5562): removing this copy causes a segfault\n                     //               before stage2\n                     let origin = /*bad*/ copy *origin;\n+\n                     meth::trans_method_callee(cx,\n                                               call_ex.callee_id,\n                                               rcvr,\n@@ -641,8 +642,9 @@ pub fn trans_arg_expr(bcx: block,\n \n     debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n             ret_flag=%?)\",\n-           formal_ty.mode, bcx.ty_to_str(formal_ty.ty),\n-           bcx.expr_to_str(arg_expr),\n+           formal_ty.mode,\n+           formal_ty.ty.repr(bcx.tcx()),\n+           arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n "}, {"sha": "2cfd7a25d68237a0469f92e48a920e1bda9ae9c7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -41,7 +41,7 @@ use middle::trans::type_use;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{expr_repr, ty_to_str};\n+use util::ppaux::{Repr};\n \n use core::cast;\n use core::hash;\n@@ -250,7 +250,7 @@ pub enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n pub struct param_substs {\n     tys: ~[ty::t],\n     vtables: Option<typeck::vtable_res>,\n-    bounds: @~[ty::param_bounds],\n+    type_param_defs: @~[ty::TypeParameterDef],\n     self_ty: Option<ty::t>\n }\n \n@@ -261,16 +261,25 @@ pub impl param_substs {\n     }\n }\n \n-pub fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n-    fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n-         substs.tys.map(|t| ty_to_str(tcx, *t)),\n-         substs.vtables.map(|vs| vs.map(|v| v.to_str(tcx))),\n-         substs.bounds.map(|b| ty::param_bounds_to_str(tcx, *b)))\n+fn param_substs_to_str(self: &param_substs,\n+                       tcx: ty::ctxt) -> ~str\n+{\n+    fmt!(\"param_substs {tys:%s, vtables:%s, type_param_defs:%s}\",\n+         self.tys.repr(tcx),\n+         self.vtables.repr(tcx),\n+         self.type_param_defs.repr(tcx))\n }\n \n-pub fn opt_param_substs_to_str(tcx: ty::ctxt,\n-                               substs: &Option<@param_substs>) -> ~str {\n-    substs.map_default(~\"None\", |&ps| param_substs_to_str(tcx, ps))\n+impl Repr for param_substs {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        param_substs_to_str(self, tcx)\n+    }\n+}\n+\n+impl Repr for @param_substs {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        param_substs_to_str(*self, tcx)\n+    }\n }\n \n // Function context.  Every LLVM function we create will have one of\n@@ -413,8 +422,9 @@ pub fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean(%s, %s, %s)\",\n-           bcx.to_str(), val_str(bcx.ccx().tn, val),\n-           ty_to_str(bcx.ccx().tcx, t));\n+           bcx.to_str(),\n+           val_str(bcx.ccx().tn, val),\n+           t.repr(bcx.tcx()));\n     let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n@@ -429,7 +439,7 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty));\n+           ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |scope_info| {\n         scope_info.cleanups.push(\n@@ -442,7 +452,7 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n-           ty_to_str(bcx.ccx().tcx, t));\n+           t.repr(bcx.tcx()));\n     let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n@@ -455,7 +465,7 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n-           ty_to_str(bcx.ccx().tcx, t));\n+           t.repr(bcx.tcx()));\n     let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n@@ -703,7 +713,7 @@ pub impl block_ {\n     }\n \n     fn expr_to_str(@mut self, e: @ast::expr) -> ~str {\n-        expr_repr(self.tcx(), e)\n+        e.repr(self.tcx())\n     }\n \n     fn expr_is_lval(@mut self, e: @ast::expr) -> bool {\n@@ -733,7 +743,7 @@ pub impl block_ {\n     }\n \n     fn ty_to_str(@mut self, t: ty::t) -> ~str {\n-        ty_to_str(self.tcx(), t)\n+        t.repr(self.tcx())\n     }\n     fn to_str(@mut self) -> ~str {\n         match self.node_info {\n@@ -1445,14 +1455,14 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n                    n_param: uint, n_bound: uint)\n     -> typeck::vtable_origin {\n-    debug!(\"find_vtable_in_fn_ctxt(n_param=%u, n_bound=%u, ps=%?)\",\n-           n_param, n_bound, param_substs_to_str(tcx, ps));\n+    debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n+           n_param, n_bound, ps.repr(tcx));\n \n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    let first_n_bounds = ps.bounds.slice(0, n_param);\n+    let first_n_type_param_defs = ps.type_param_defs.slice(0, n_param);\n     let vtables_to_skip =\n-        ty::count_traits_and_supertraits(tcx, first_n_bounds);\n+        ty::count_traits_and_supertraits(tcx, first_n_type_param_defs);\n     let vtable_off = vtables_to_skip + n_bound;\n     /*bad*/ copy ps.vtables.get()[vtable_off]\n }"}, {"sha": "c5e708569dc25d66297d9a740942b451d35126e0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -25,7 +25,7 @@ use middle::trans::inline;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::ty;\n-use util::ppaux::{expr_repr, ty_to_str};\n+use util::ppaux::{Repr, ty_to_str};\n \n use core::libc::c_uint;\n use syntax::{ast, ast_util, ast_map};\n@@ -237,7 +237,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess.bug(fmt!(\"const %s of type %s has size %u instead of %u\",\n-                         expr_repr(cx.tcx, e), ty_to_str(cx.tcx, ety),\n+                         e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n                          csize, tsize));\n     }\n     llconst"}, {"sha": "15c2e8e3d935069fb69c0d3870b2ea098e6c70fb", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -86,13 +86,11 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n           csearch::found(ast::ii_method(impl_did, mth)) => {\n             ccx.stats.n_inlines += 1;\n             ccx.external.insert(fn_id, Some(mth.id));\n-            let ty::ty_param_bounds_and_ty {\n-                generics: ty::Generics { bounds: impl_bnds, _ },\n-                ty: _\n-            } = ty::lookup_item_type(ccx.tcx, impl_did);\n-            if translate &&\n-                impl_bnds.len() + mth.generics.ty_params.len() == 0u\n-            {\n+            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+            let num_type_params =\n+                impl_tpt.generics.type_param_defs.len() +\n+                mth.generics.ty_params.len();\n+            if translate && num_type_params == 0 {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = vec::append(\n                     ty::item_path(ccx.tcx, impl_did),"}, {"sha": "c518605faf13afce6457bc6a4353f77459dfce5b", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -30,7 +30,7 @@ use middle::ty;\n use middle::ty::arg;\n use middle::typeck;\n use util::common::indenter;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::Repr;\n \n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util;\n@@ -61,7 +61,7 @@ pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n                     param_substs_opt = Some(@param_substs {\n                         tys: ~[],\n                         vtables: None,\n-                        bounds: @~[],\n+                        type_param_defs: @~[],\n                         self_ty: Some(self_ty)\n                     });\n                 }\n@@ -115,11 +115,8 @@ pub fn trans_method(ccx: @CrateContext,\n             }\n         };\n         debug!(\"calling trans_fn with base_self_ty %s, self_ty %s\",\n-               match base_self_ty {\n-                    None => ~\"(none)\",\n-                    Some(x) => ty_to_str(ccx.tcx, x),\n-               },\n-               ty_to_str(ccx.tcx, self_ty));\n+               base_self_ty.repr(ccx.tcx),\n+               self_ty.repr(ccx.tcx));\n         match method.self_ty.node {\n           ast::sty_value => {\n             impl_owned_self(self_ty)\n@@ -175,8 +172,9 @@ pub fn trans_method_callee(bcx: block,\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%?)\",\n-           callee_id, bcx.expr_to_str(self), mentry);\n+    debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%s)\",\n+           callee_id, bcx.expr_to_str(self),\n+           mentry.repr(bcx.tcx()));\n \n     // Replace method_self with method_static here.\n     let mut origin = mentry.origin;\n@@ -302,7 +300,8 @@ pub fn trans_static_method_callee(bcx: block,\n     // one we are interested in.\n     let bound_index = {\n         let trait_def = ty::lookup_trait_def(bcx.tcx(), trait_id);\n-        ty::count_traits_and_supertraits(bcx.tcx(), *trait_def.generics.bounds)\n+        ty::count_traits_and_supertraits(\n+            bcx.tcx(), *trait_def.generics.type_param_defs)\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n@@ -552,14 +551,15 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     let ccx = bcx.ccx(), tcx = bcx.tcx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n     let ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {bounds: r_m_bounds, _},\n+        generics: r_m_generics,\n         _\n     } = ty::lookup_item_type(tcx, mth_did);\n-    let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n-    let m_boundss = vec::slice(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n+    let n_r_m_tps = r_m_generics.type_param_defs.len(); // rcvr + method tps\n+    let m_type_param_defs =\n+        vec::slice(*r_m_generics.type_param_defs, n_r_m_tps - n_m_tps, n_r_m_tps);\n \n     // Flatten out to find the number of vtables the method expects.\n-    let m_vtables = ty::count_traits_and_supertraits(tcx, m_boundss);\n+    let m_vtables = ty::count_traits_and_supertraits(tcx, m_type_param_defs);\n \n     // Find the vtables we computed at type check time and monomorphize them\n     let r_m_origins = match node_vtables(bcx, callee_id) {\n@@ -787,12 +787,13 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n     // XXX: This should support multiple traits.\n     let trt_id = ty::impl_trait_refs(tcx, impl_id)[0].def_id;\n \n-    let has_tps = ty::lookup_item_type(ccx.tcx, impl_id).generics.bounds.len() > 0u;\n+    let has_tps =\n+        !ty::lookup_item_type(ccx.tcx, impl_id).generics.type_param_defs.is_empty();\n     make_vtable(ccx, ty::trait_method_def_ids(tcx, trt_id).map(|method_def_id| {\n         let im = ty::method(tcx, *method_def_id);\n         let fty = ty::subst_tps(tcx, substs, None,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n-        if im.generics.bounds.len() > 0u || ty::type_has_self(fty) {\n+        if im.generics.has_type_params() || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))"}, {"sha": "97dc3fed780f0ac83058a9a865a459ef49ac53a2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -30,7 +30,7 @@ use middle::trans::type_use;\n use middle::ty;\n use middle::ty::{FnSig};\n use middle::typeck;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::Repr;\n \n use core::vec;\n use syntax::ast;\n@@ -46,8 +46,21 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                       real_substs: &[ty::t],\n                       vtables: Option<typeck::vtable_res>,\n                       impl_did_opt: Option<ast::def_id>,\n-                      ref_id: Option<ast::node_id>) ->\n-                      (ValueRef, bool) {\n+                      ref_id: Option<ast::node_id>)\n+    -> (ValueRef, bool)\n+{\n+    debug!(\"monomorphic_fn(\\\n+            fn_id=%s, \\\n+            real_substs=%s, \\\n+            vtables=%s, \\\n+            impl_did_opt=%s, \\\n+            ref_id=%?)\",\n+           fn_id.repr(ccx.tcx),\n+           real_substs.repr(ccx.tcx),\n+           vtables.repr(ccx.tcx),\n+           impl_did_opt.repr(ccx.tcx),\n+           ref_id);\n+\n     assert!(real_substs.all(|t| !ty::type_needs_infer(*t)));\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n@@ -69,13 +82,15 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         must_cast = true;\n     }\n \n-    debug!(\"monomorphic_fn(fn_id=%? (%s), vtables=%?, \\\n-            real_substs=%?, substs=%?, \\\n-            hash_id = %?\",\n-           fn_id, ty::item_path_str(ccx.tcx, fn_id),\n-           vtables,\n-           real_substs.map(|s| ty_to_str(ccx.tcx, *s)),\n-           substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id);\n+    debug!(\"monomorphic_fn(\\\n+            fn_id=%s, \\\n+            vtables=%s, \\\n+            substs=%s, \\\n+            hash_id=%?)\",\n+           fn_id.repr(ccx.tcx),\n+           vtables.repr(ccx.tcx),\n+           substs.repr(ccx.tcx),\n+           hash_id);\n \n     match ccx.monomorphized.find(&hash_id) {\n       Some(&val) => {\n@@ -169,7 +184,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let psubsts = Some(@param_substs {\n         tys: substs,\n         vtables: vtables,\n-        bounds: tpt.generics.bounds,\n+        type_param_defs: tpt.generics.type_param_defs,\n         self_ty: impl_ty_opt\n     });\n \n@@ -322,17 +337,19 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n     }\n }\n \n-pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: &[ty::t],\n+pub fn make_mono_id(ccx: @CrateContext,\n+                    item: ast::def_id,\n+                    substs: &[ty::t],\n                     vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n                     +param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n-        let bounds = ty::lookup_item_type(ccx.tcx, item).generics.bounds;\n+        let item_ty = ty::lookup_item_type(ccx.tcx, item);\n         let mut i = 0;\n-        vec::map2(*bounds, substs, |bounds, subst| {\n+        vec::map2(*item_ty.generics.type_param_defs, substs, |type_param_def, subst| {\n             let mut v = ~[];\n-            for bounds.each |bound| {\n+            for type_param_def.bounds.each |bound| {\n                 match *bound {\n                   ty::bound_trait(_) => {\n                     v.push(meth::vtable_id(ccx, /*bad*/copy vts[i]));"}, {"sha": "742153124346ad4e7ac23cc1b556f04ad92197a5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 85, "deletions": 140, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -20,12 +20,13 @@ use middle::lint;\n use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty;\n+use middle::subst::Subst;\n use middle::typeck;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, vstore_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, tys_to_str};\n-use util::ppaux::{trait_ref_to_str};\n+use util::ppaux::Repr;\n use util::common::{indenter};\n \n use core;\n@@ -277,7 +278,7 @@ struct ctxt_ {\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n-    ty_param_bounds: @mut HashMap<ast::node_id, param_bounds>,\n+    ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n     inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n@@ -400,19 +401,12 @@ impl to_bytes::IterBytes for ClosureTy {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct param_ty {\n     idx: uint,\n     def_id: def_id\n }\n \n-impl to_bytes::IterBytes for param_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n-    }\n-}\n-\n-\n /// Representation of regions:\n #[auto_encode]\n #[auto_decode]\n@@ -754,13 +748,24 @@ impl to_bytes::IterBytes for RegionVid {\n     }\n }\n \n+pub struct TypeParameterDef {\n+    def_id: ast::def_id,\n+    bounds: param_bounds\n+}\n+\n /// Information about the type/lifetime parametesr associated with an item.\n /// Analogous to ast::Generics.\n pub struct Generics {\n-    bounds: @~[param_bounds],\n+    type_param_defs: @~[TypeParameterDef],\n     region_param: Option<region_variance>,\n }\n \n+pub impl Generics {\n+    fn has_type_params(&self) -> bool {\n+        !self.type_param_defs.is_empty()\n+    }\n+}\n+\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -853,7 +858,7 @@ pub fn mk_ctxt(s: session::Session,\n         methods: @mut HashMap::new(),\n         trait_method_def_ids: @mut HashMap::new(),\n         trait_methods_cache: @mut HashMap::new(),\n-        ty_param_bounds: @mut HashMap::new(),\n+        ty_param_defs: @mut HashMap::new(),\n         inferred_modes: @mut HashMap::new(),\n         adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n@@ -1227,6 +1232,12 @@ pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     }\n }\n \n+pub fn fold_bare_fn_ty(fty: &BareFnTy, fldop: &fn(t) -> t) -> BareFnTy {\n+    BareFnTy {sig: fold_sig(&fty.sig, fldop),\n+              abis: fty.abis,\n+              purity: fty.purity}\n+}\n+\n fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n         substs {self_r: substs.self_r,\n@@ -1261,8 +1272,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n             ty_tup(new_ts)\n         }\n         ty_bare_fn(ref f) => {\n-            let sig = fold_sig(&f.sig, fldop);\n-            ty_bare_fn(BareFnTy {sig: sig, abis: f.abis, purity: f.purity})\n+            ty_bare_fn(fold_bare_fn_ty(f, fldop))\n         }\n         ty_closure(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);\n@@ -1409,94 +1419,22 @@ pub fn substs_is_noop(substs: &substs) -> bool {\n }\n \n pub fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n-    fmt!(\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n-         substs.self_r.map_default(~\"none\", |r| region_to_str(cx, *r)),\n-         substs.self_ty.map_default(~\"none\",\n-                                    |t| ::util::ppaux::ty_to_str(cx, *t)),\n-         tys_to_str(cx, substs.tps))\n+    substs.repr(cx)\n }\n \n pub fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n-    match *pb {\n-        bound_copy => ~\"copy\",\n-        bound_durable => ~\"'static\",\n-        bound_owned => ~\"owned\",\n-        bound_const => ~\"const\",\n-        bound_trait(t) => ::util::ppaux::trait_ref_to_str(cx, t)\n-    }\n+    pb.repr(cx)\n }\n \n pub fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n-    fmt!(\"%?\", pbs.map(|pb| param_bound_to_str(cx, pb)))\n+    pbs.repr(cx)\n }\n \n pub fn subst(cx: ctxt,\n              substs: &substs,\n              typ: t)\n           -> t {\n-    debug!(\"subst(substs=%s, typ=%s)\",\n-           substs_to_str(cx, substs),\n-           ::util::ppaux::ty_to_str(cx, typ));\n-\n-    if substs_is_noop(substs) { return typ; }\n-    let r = do_subst(cx, substs, typ);\n-    debug!(\"  r = %s\", ::util::ppaux::ty_to_str(cx, r));\n-    return r;\n-\n-    fn do_subst(cx: ctxt,\n-                substs: &substs,\n-                typ: t) -> t {\n-        let tb = get(typ);\n-        if !tbox_has_flag(tb, needs_subst) { return typ; }\n-        match tb.sty {\n-          ty_param(p) => substs.tps[p.idx],\n-          ty_self(_) => substs.self_ty.get(),\n-          _ => {\n-            fold_regions_and_ty(\n-                cx, typ,\n-                |r| match r {\n-                    re_bound(br_self) => {\n-                        match substs.self_r {\n-                            None => {\n-                                cx.sess.bug(\n-                                    fmt!(\"ty::subst: \\\n-                                  Reference to self region when given substs \\\n-                                  with no self region, ty = %s\",\n-                                  ::util::ppaux::ty_to_str(cx, typ)))\n-                            }\n-                            Some(self_r) => self_r\n-                        }\n-                    }\n-                    _ => r\n-                },\n-                |t| do_subst(cx, substs, t),\n-                |t| do_subst(cx, substs, t))\n-          }\n-        }\n-    }\n-}\n-\n-pub fn subst_in_trait_ref(cx: ctxt,\n-                          substs: &substs,\n-                          trait_ref: &ty::TraitRef) -> ty::TraitRef\n-{\n-    ty::TraitRef {\n-        def_id: trait_ref.def_id,\n-        substs: subst_in_substs(cx, substs, &trait_ref.substs)\n-    }\n-}\n-\n-// Performs substitutions on a set of substitutions (result = sup(sub)) to\n-// yield a new set of substitutions. This is used in trait inheritance.\n-pub fn subst_in_substs(cx: ctxt,\n-                       substs: &substs,\n-                       in_substs: &substs) -> substs\n-{\n-    substs {\n-        self_r: in_substs.self_r,\n-        self_ty: in_substs.self_ty.map(|&typ| subst(cx, substs, typ)),\n-        tps: in_substs.tps.map(|&typ| subst(cx, substs, typ))\n-    }\n+    typ.subst(cx, substs)\n }\n \n // Type utilities\n@@ -1511,6 +1449,10 @@ pub fn type_is_error(ty: t) -> bool {\n     (get(ty).flags & (has_ty_err as uint)) != 0\n }\n \n+pub fn type_needs_subst(ty: t) -> bool {\n+    tbox_has_flag(get(ty), needs_subst)\n+}\n+\n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n     tref.substs.self_ty.any(|&t| type_is_error(t)) ||\n         tref.substs.tps.any(|&t| type_is_error(t))\n@@ -2046,8 +1988,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // def-id.\n                 assert!(p.def_id.crate == ast::local_crate);\n \n-                param_bounds_to_contents(\n-                    cx, *cx.ty_param_bounds.get(&p.def_id.node))\n+                type_param_def_to_contents(\n+                    cx, cx.ty_param_defs.get(&p.def_id.node))\n             }\n \n             ty_self(_) => {\n@@ -2141,13 +2083,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st + rt + ot\n     }\n \n-    fn param_bounds_to_contents(cx: ctxt,\n-                                bounds: param_bounds) -> TypeContents\n+    fn type_param_def_to_contents(cx: ctxt,\n+                                  type_param_def: &TypeParameterDef) -> TypeContents\n     {\n-        debug!(\"param_bounds_to_contents()\");\n+        debug!(\"type_param_def_to_contents(%s)\", type_param_def.repr(cx));\n         let _i = indenter();\n \n-        let r = bounds.foldl(TC_ALL, |tc, bound| {\n+        let r = type_param_def.bounds.foldl(TC_ALL, |tc, bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             match *bound {\n                 bound_copy => tc - TypeContents::nonimplicitly_copyable(cx),\n@@ -3042,16 +2984,18 @@ pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n-                          id: ast::node_id)\n-    -> Option<@~[param_bounds]> {\n+pub fn method_call_type_param_defs(\n+    tcx: ctxt,\n+    method_map: typeck::method_map,\n+    id: ast::node_id) -> Option<@~[TypeParameterDef]>\n+{\n     do method_map.find(&id).map |method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n             // that we encode include both the impl bounds\n             // and then the method bounds themselves...\n-            ty::lookup_item_type(tcx, did).generics.bounds\n+            ty::lookup_item_type(tcx, did).generics.type_param_defs\n           }\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n@@ -3062,9 +3006,11 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n-            let trt_bounds = ty::lookup_trait_def(tcx, trt_id).generics.bounds;\n-            @(vec::append(/*bad*/copy *trt_bounds,\n-                          *ty::trait_method(tcx, trt_id, n_mth).generics.bounds))\n+            let trait_type_param_defs =\n+                ty::lookup_trait_def(tcx, trt_id).generics.type_param_defs;\n+            @vec::append(\n+                copy *trait_type_param_defs,\n+                *ty::trait_method(tcx, trt_id, n_mth).generics.type_param_defs)\n           }\n         }\n     }\n@@ -3614,6 +3560,12 @@ pub fn trait_supertraits(cx: ctxt,\n     return result;\n }\n \n+pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef] {\n+    let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n+    supertrait_refs.map(\n+        |supertrait_ref| @supertrait_ref.subst(cx, &trait_ref.substs))\n+}\n+\n fn lookup_locally_or_in_crate_store<V:Copy>(\n     descr: &str,\n     def_id: ast::def_id,\n@@ -4327,11 +4279,9 @@ pub fn determine_inherited_purity(parent_purity: ast::purity,\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n+pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                          bounds: param_bounds,\n                                          f: &fn(&TraitRef) -> bool) {\n-    let mut fin = false;\n-\n     for bounds.each |bound| {\n         let bound_trait_ref = match *bound {\n             ty::bound_trait(bound_t) => bound_t,\n@@ -4343,51 +4293,46 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n         };\n \n         let mut supertrait_set = HashMap::new();\n-        let mut seen_def_ids = ~[];\n+        let mut trait_refs = ~[];\n         let mut i = 0;\n-        let trait_ty_id = bound_trait_ref.def_id;\n-        let mut trait_ref = bound_trait_ref;\n \n-        debug!(\"iter_bound_traits_and_supertraits: trait_ref = %s\",\n-               trait_ref_to_str(tcx, trait_ref));\n+        // Seed the worklist with the trait from the bound\n+        supertrait_set.insert(bound_trait_ref.def_id, ());\n+        trait_refs.push(bound_trait_ref);\n \n         // Add the given trait ty to the hash map\n-        supertrait_set.insert(trait_ty_id, ());\n-        seen_def_ids.push(trait_ty_id);\n-\n-        if f(trait_ref) {\n-            // Add all the supertraits to the hash map,\n-            // executing <f> on each of them\n-            while i < supertrait_set.len() && !fin {\n-                let init_trait_id = seen_def_ids[i];\n-                i += 1;\n-\n-                 // Add supertraits to supertrait_set\n-                let supertrait_refs = trait_supertraits(tcx, init_trait_id);\n-                for supertrait_refs.each |&supertrait_ref| {\n-                    let d_id = supertrait_ref.def_id;\n-                    if !supertrait_set.contains_key(&d_id) {\n-                        // FIXME(#5527) Could have same trait multiple times\n-                        supertrait_set.insert(d_id, ());\n-                        trait_ref = supertrait_ref;\n-                        seen_def_ids.push(d_id);\n-                    }\n-                    debug!(\"A super_t = %s\", trait_ref_to_str(tcx, trait_ref));\n-                    if !f(trait_ref) {\n-                        fin = true;\n-                    }\n+        while i < trait_refs.len() {\n+            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n+                   i, trait_refs[i].repr(tcx));\n+\n+            if !f(trait_refs[i]) {\n+                return;\n+            }\n+\n+            // Add supertraits to supertrait_set\n+            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n+            for supertrait_refs.each |&supertrait_ref| {\n+                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n+                       supertrait_ref.repr(tcx));\n+\n+                let d_id = supertrait_ref.def_id;\n+                if !supertrait_set.contains_key(&d_id) {\n+                    // FIXME(#5527) Could have same trait multiple times\n+                    supertrait_set.insert(d_id, ());\n+                    trait_refs.push(supertrait_ref);\n                 }\n             }\n-        };\n-        fin = false;\n+\n+            i += 1;\n+        }\n     }\n }\n \n pub fn count_traits_and_supertraits(tcx: ctxt,\n-                                    boundses: &[param_bounds]) -> uint {\n+                                    type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n-    for boundses.each |bounds| {\n-        for iter_bound_traits_and_supertraits(tcx, *bounds) |_trait_ty| {\n+    for type_param_defs.each |type_param_def| {\n+        for each_bound_trait_and_supertraits(tcx, type_param_def.bounds) |_| {\n             total += 1;\n         }\n     }"}, {"sha": "bfc9d646dbb6c5387a060431c73e052a2dacce11", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -135,6 +135,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + Durable>(\n     rscope: &RS,\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n+    self_ty: Option<ty::t>,\n     path: @ast::path) -> ty::substs\n {\n     /*!\n@@ -172,15 +173,15 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + Durable>(\n     };\n \n     // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_generics.bounds, path.types) {\n+    if !vec::same_length(*decl_generics.type_param_defs, path.types) {\n         self.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n-                 decl_generics.bounds.len(), path.types.len()));\n+                 decl_generics.type_param_defs.len(), path.types.len()));\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n-    substs {self_r:self_r, self_ty:None, tps:tps}\n+    substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n@@ -195,7 +196,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         ty: decl_ty\n     } = self.get_item_ty(did);\n \n-    let substs = ast_path_substs(self, rscope, did, &generics, path);\n+    let substs = ast_path_substs(self, rscope, did, &generics, None, path);\n     let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n@@ -204,14 +205,18 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + Durable>(\n     self: &AC,\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n+    self_ty: Option<ty::t>,\n     path: @ast::path) -> @ty::TraitRef\n {\n     let trait_def =\n         self.get_trait_def(trait_def_id);\n     let substs =\n         ast_path_substs(\n-            self, rscope,\n-            trait_def.trait_ref.def_id, &trait_def.generics,\n+            self,\n+            rscope,\n+            trait_def.trait_ref.def_id,\n+            &trait_def.generics,\n+            self_ty,\n             path);\n     let trait_ref =\n         @ty::TraitRef {def_id: trait_def_id,\n@@ -280,7 +285,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                     }\n                     Some(&ast::def_trait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n-                            self, rscope, trait_def_id, path);\n+                            self, rscope, trait_def_id, None, path);\n                         let trait_store = match vst {\n                             ty::vstore_box => ty::BoxTraitStore,\n                             ty::vstore_uniq => ty::UniqTraitStore,"}, {"sha": "aa2414eac624068b01547f248730c743ee04b52e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -135,7 +135,9 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                     ty::enum_variant_with_id(tcx, enm, var);\n                 let var_tpt = ty::lookup_item_type(tcx, var);\n                 vinfo.args.map(|t| {\n-                    if var_tpt.generics.bounds.len() == expected_substs.tps.len() {\n+                    if var_tpt.generics.type_param_defs.len() ==\n+                        expected_substs.tps.len()\n+                    {\n                         ty::subst(tcx, expected_substs, *t)\n                     }\n                     else {"}, {"sha": "6a274e7f9eb07ea98cae6d950e02382a6593567d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 57, "deletions": 103, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -94,7 +94,6 @@ use middle::typeck::{method_map_entry, method_origin, method_param};\n use middle::typeck::{method_self, method_static, method_trait, method_super};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n-use util::ppaux::expr_repr;\n \n use core::hashmap::HashSet;\n use core::result;\n@@ -149,8 +148,7 @@ pub fn lookup(\n         autoderef_receiver: autoderef_receiver,\n     };\n     let mme = lcx.do_lookup(self_ty);\n-    debug!(\"method lookup for %s yielded %?\",\n-           expr_repr(fcx.tcx(), expr), mme);\n+    debug!(\"method lookup for %s yielded %?\", expr.repr(fcx.tcx()), mme);\n     return mme;\n }\n \n@@ -197,9 +195,8 @@ pub impl<'self> LookupContext<'self> {\n \n         debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n                self.ty_to_str(self_ty),\n-               expr_repr(self.tcx(), self.expr),\n-               expr_repr(self.tcx(), self.self_expr));\n-        let _indenter = indenter();\n+               self.expr.repr(self.tcx()),\n+               self.self_expr.repr(self.tcx()));\n \n         // Prepare the list of candidates\n         self.push_inherent_candidates(self_ty);\n@@ -379,105 +376,59 @@ pub impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n-        let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n-\n-        for bounds.each |bound| {\n-            let bound_trait_ref = match *bound {\n-                ty::bound_trait(bound_t) => bound_t,\n+        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n+            Some(t) => t,\n+            None => {\n+                tcx.sess.span_bug(\n+                    self.expr.span,\n+                    fmt!(\"No param def for %?\", param_ty));\n+            }\n+        };\n \n-                ty::bound_copy | ty::bound_owned |\n-                ty::bound_const | ty::bound_durable => {\n-                    loop; // skip non-trait bounds\n+        for ty::each_bound_trait_and_supertraits(tcx, type_param_def.bounds)\n+            |bound_trait_ref|\n+        {\n+            let this_bound_idx = next_bound_idx;\n+            next_bound_idx += 1;\n+\n+            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n+            let pos = {\n+                match trait_methods.position(|m| {\n+                    m.self_ty != ast::sty_static &&\n+                        m.ident == self.m_name })\n+                {\n+                    Some(pos) => pos,\n+                    None => {\n+                        debug!(\"trait doesn't contain method: %?\",\n+                               bound_trait_ref.def_id);\n+                        loop; // check next trait or bound\n+                    }\n                 }\n             };\n+            let method = trait_methods[pos];\n \n-            // Loop over the trait and all of its supertraits.\n-            let mut worklist = ~[];\n-\n-            let init_trait_ref = bound_trait_ref;\n-\n-            // Replace any appearance of `self` with the type of the\n-            // generic parameter itself.  Note that this is the only\n-            // case where this replacement is necessary: in all other\n-            // cases, we are either invoking a method directly from an\n-            // impl or class (where the self type is not permitted),\n-            // or from a trait type (in which case methods that refer\n-            // to self are not permitted).\n-            let init_substs = substs {\n-                self_ty: Some(rcvr_ty),\n-                ..copy bound_trait_ref.substs\n-            };\n-\n-            worklist.push((init_trait_ref.def_id, init_substs));\n-\n-            let mut i = 0;\n-            while i < worklist.len() {\n-                let (init_trait_id, init_substs) = /*bad*/copy worklist[i];\n-                i += 1;\n-\n-                // Add all the supertraits of this trait to the worklist.\n-                let supertraits = ty::trait_supertraits(tcx, init_trait_id);\n-                for supertraits.each |supertrait_ref| {\n-                    debug!(\"adding supertrait: %?\",\n-                           supertrait_ref.def_id);\n-\n-                    let new_substs = ty::subst_in_substs(\n-                        tcx,\n-                        &init_substs,\n-                        &supertrait_ref.substs);\n-\n-                    // Again replacing the self type\n-                    let new_substs = substs {\n-                        self_ty: Some(rcvr_ty),\n-                        ..new_substs\n-                    };\n-\n-                    worklist.push((supertrait_ref.def_id, new_substs));\n-                }\n-\n-\n-                let this_bound_idx = next_bound_idx;\n-                next_bound_idx += 1;\n-\n-                let trait_methods = ty::trait_methods(tcx, init_trait_id);\n-                let pos = {\n-                    match trait_methods.position(|m| {\n-                        m.self_ty != ast::sty_static &&\n-                            m.ident == self.m_name })\n-                    {\n-                        Some(pos) => pos,\n-                        None => {\n-                            debug!(\"trait doesn't contain method: %?\",\n-                                   init_trait_id);\n-                            loop; // check next trait or bound\n-                        }\n-                    }\n-                };\n-                let method = trait_methods[pos];\n-\n-                let (rcvr_ty, rcvr_substs) =\n-                    self.create_rcvr_ty_and_substs_for_method(\n-                        method.self_ty,\n-                        rcvr_ty,\n-                        init_substs,\n-                        TransformTypeNormally);\n+            let (rcvr_ty, rcvr_substs) =\n+                self.create_rcvr_ty_and_substs_for_method(\n+                    method.self_ty,\n+                    rcvr_ty,\n+                    copy bound_trait_ref.substs,\n+                    TransformTypeNormally);\n \n-                let cand = Candidate {\n-                    rcvr_ty: rcvr_ty,\n-                    rcvr_substs: rcvr_substs,\n-                    method_ty: method,\n-                    origin: method_param(\n-                        method_param {\n-                            trait_id: init_trait_id,\n-                            method_num: pos,\n-                            param_num: param_ty.idx,\n-                            bound_num: this_bound_idx,\n-                        })\n-                };\n+            let cand = Candidate {\n+                rcvr_ty: rcvr_ty,\n+                rcvr_substs: rcvr_substs,\n+                method_ty: method,\n+                origin: method_param(\n+                    method_param {\n+                        trait_id: bound_trait_ref.def_id,\n+                        method_num: pos,\n+                        param_num: param_ty.idx,\n+                        bound_num: this_bound_idx,\n+                    })\n+            };\n \n-                debug!(\"pushing inherent candidate for param: %?\", cand);\n-                self.inherent_candidates.push(cand);\n-            }\n+            debug!(\"pushing inherent candidate for param: %?\", cand);\n+            self.inherent_candidates.push(cand);\n         }\n     }\n \n@@ -499,7 +450,7 @@ pub impl<'self> LookupContext<'self> {\n         };\n         let method = ms[index];\n \n-        /* FIXME(#3157) we should transform the vstore in accordance\n+        /* FIXME(#5762) we should transform the vstore in accordance\n            with the self type\n \n         match method.self_type {\n@@ -517,6 +468,9 @@ pub impl<'self> LookupContext<'self> {\n         // `trait_ty` for `self` here, because it allows the compiler\n         // to soldier on.  An error will be reported should this\n         // candidate be selected if the method refers to `self`.\n+        //\n+        // NB: `confirm_candidate()` also relies upon this substitution\n+        // for Self.\n         let rcvr_substs = substs {\n             self_ty: Some(self_ty),\n             ../*bad*/copy *substs\n@@ -1075,7 +1029,7 @@ pub impl<'self> LookupContext<'self> {\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n \n         debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n-               expr_repr(tcx, self.expr),\n+               self.expr.repr(tcx),\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n \n@@ -1101,7 +1055,7 @@ pub impl<'self> LookupContext<'self> {\n         // If they were not explicitly supplied, just construct fresh\n         // type variables.\n         let num_supplied_tps = self.supplied_tps.len();\n-        let num_method_tps = candidate.method_ty.generics.bounds.len();\n+        let num_method_tps = candidate.method_ty.generics.type_param_defs.len();\n         let m_substs = {\n             if num_supplied_tps == 0u {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n@@ -1195,7 +1149,7 @@ pub impl<'self> LookupContext<'self> {\n                   self-type through a boxed trait\");\n         }\n \n-        if candidate.method_ty.generics.bounds.len() > 0 {\n+        if candidate.method_ty.generics.has_type_params() {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 ~\"cannot call a generic method through a boxed trait\");"}, {"sha": "2455201907447b047055c960992321da4a341c20", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -107,7 +107,7 @@ use middle::typeck::{isr_alist, lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_to_str, expr_repr, pat_repr};\n+use util::ppaux::{bound_region_to_str};\n use util::ppaux;\n \n use core::hashmap::HashMap;\n@@ -610,7 +610,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         } else {\n             for m.items.each |item| {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n-                if !tpt.generics.bounds.is_empty() {\n+                if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n                         fmt!(\"foreign items may not have type parameters\"));\n@@ -761,11 +761,11 @@ pub impl FnCtxt {\n     }\n \n     fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n-        expr_repr(self.tcx(), expr)\n+        expr.repr(self.tcx())\n     }\n \n     fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n-        pat_repr(self.tcx(), pat)\n+        pat.repr(self.tcx())\n     }\n \n     fn expr_ty(&self, ex: @ast::expr) -> ty::t {\n@@ -1068,7 +1068,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let (n_tps, region_param, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (ity.generics.bounds.len(), ity.generics.region_param, ity.ty)\n+        (ity.generics.type_param_defs.len(), ity.generics.region_param, ity.ty)\n     };\n \n     let self_r = if region_param.is_some() {\n@@ -1893,7 +1893,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = item_type.generics.bounds.len();\n+            type_parameter_count = item_type.generics.type_param_defs.len();\n             region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n@@ -1981,7 +1981,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, enum_id);\n-            type_parameter_count = item_type.generics.bounds.len();\n+            type_parameter_count = item_type.generics.type_param_defs.len();\n             region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n@@ -3153,7 +3153,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n         // extern functions are just u8 pointers\n         return ty_param_bounds_and_ty {\n             generics: ty::Generics {\n-                bounds: @~[],\n+                type_param_defs: @~[],\n                 region_param: None\n             },\n             ty: ty::mk_ptr(\n@@ -3218,7 +3218,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         region_lb: ty::Region) {\n     debug!(\">>> instantiate_path\");\n \n-    let ty_param_count = tpt.generics.bounds.len();\n+    let ty_param_count = tpt.generics.type_param_defs.len();\n     let ty_substs_len = vec::len(pth.types);\n \n     debug!(\"ty_param_count=%? ty_substs_len=%?\",\n@@ -3692,7 +3692,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                     output: output}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n-    let i_n_tps = i_ty.generics.bounds.len();\n+    let i_n_tps = i_ty.generics.type_param_defs.len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n                                          of type parameters: found %u, \\"}, {"sha": "6ea668605fd4d90e1dce46763ef9708900effd31", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -20,14 +20,14 @@ use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{CrateCtxt, vtable_origin, vtable_param, vtable_res};\n use middle::typeck::vtable_static;\n+use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux::tys_to_str;\n use util::ppaux;\n \n use core::result::{Ok, Err};\n use core::result;\n use core::uint;\n-use core::vec;\n use core::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast_util;\n@@ -70,45 +70,43 @@ pub impl VtableContext {\n     fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n }\n \n-fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n-    vec::any(tps, |bs| {\n-        bs.any(|b| {\n-            match b { &ty::bound_trait(_) => true, _ => false }\n-        })\n-    })\n+fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n+    type_param_defs.any(\n+        |type_param_def| type_param_def.bounds.any(\n+            |bound| match bound { &ty::bound_trait(*) => true, _ => false }))\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n                   location_info: &LocationInfo,\n-                  bounds: @~[ty::param_bounds],\n+                  type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(location_info=%?,\n-            # bounds=%?, \\\n+    debug!(\"lookup_vtables(location_info=%?, \\\n+            type_param_defs=%s, \\\n             substs=%s\",\n            location_info,\n-           bounds.len(),\n-           ty::substs_to_str(vcx.tcx(), substs));\n+           type_param_defs.repr(vcx.tcx()),\n+           substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n     let tcx = vcx.tcx();\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n-        for ty::iter_bound_traits_and_supertraits(\n-            tcx, bounds[i]) |trait_ref|\n+        // ty is the value supplied for the type parameter A...\n+\n+        for ty::each_bound_trait_and_supertraits(\n+            tcx, type_param_defs[i].bounds) |trait_ref|\n         {\n-            debug!(\"about to subst: %?, %?\",\n-                   ppaux::trait_ref_to_str(tcx, trait_ref),\n-                   ty::substs_to_str(tcx, substs));\n+            // ...and here trait_ref is each bound that was declared on A,\n+            // expressed in terms of the type parameters.\n+\n+            debug!(\"about to subst: %s, %s\", trait_ref.repr(tcx), substs.repr(tcx));\n \n-            let new_substs = substs {\n-                self_ty: Some(*ty),\n-                ../*bad*/copy *substs\n-            };\n-            let trait_ref = ty::subst_in_trait_ref(tcx, &new_substs, trait_ref);\n+            // Substitute the values of the type parameters that may\n+            // appear in the bound.\n+            let trait_ref = trait_ref.subst(tcx, substs);\n \n-            debug!(\"after subst: %?\",\n-                   vcx.infcx.trait_ref_to_str(&trait_ref));\n+            debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n             match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n                 Some(vtable) => result.push(vtable),\n@@ -125,14 +123,14 @@ fn lookup_vtables(vcx: &VtableContext,\n         i += 1u;\n     }\n     debug!(\"lookup_vtables result(\\\n-            location_info=%?,\n-            # bounds=%?, \\\n+            location_info=%?, \\\n+            type_param_defs=%s, \\\n             substs=%s, \\\n-            result=%?\",\n+            result=%s)\",\n            location_info,\n-           bounds.len(),\n-           ty::substs_to_str(vcx.tcx(), substs),\n-           result);\n+           type_param_defs.repr(vcx.tcx()),\n+           substs.repr(vcx.tcx()),\n+           result.repr(vcx.tcx()));\n     @result\n }\n \n@@ -219,12 +217,11 @@ fn lookup_vtable(vcx: &VtableContext,\n     match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            let bounds = *tcx.ty_param_bounds.get(&did.node);\n-            for ty::iter_bound_traits_and_supertraits(\n-                tcx, bounds) |bound_trait_ref|\n+            let type_param_def = tcx.ty_param_defs.get(&did.node);\n+            for ty::each_bound_trait_and_supertraits(\n+                tcx, type_param_def.bounds) |bound_trait_ref|\n             {\n-                debug!(\"checking bounds trait %?\",\n-                       vcx.infcx.trait_ref_to_str(bound_trait_ref));\n+                debug!(\"checking bounds trait %s\", bound_trait_ref.repr(vcx.tcx()));\n \n                 if bound_trait_ref.def_id == trait_ref.def_id {\n                     relate_trait_refs(vcx,\n@@ -302,6 +299,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                             // of the thing that we're trying to cast\n                             // to some_trait.  If not, then we try the next\n                             // impl.\n+                            //\n+                            // FIXME(#5781) this should be mk_eqty not mk_subty\n                             let ty::ty_param_substs_and_ty {\n                                 substs: substs,\n                                 ty: for_ty\n@@ -341,8 +340,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.trait_ref_to_str(trait_ref),\n                                    vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let of_trait_ref =\n-                                ty::subst_in_trait_ref(tcx, &substs, of_trait_ref);\n+                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n                             relate_trait_refs(\n                                 vcx, location_info,\n                                 &of_trait_ref, trait_ref);\n@@ -387,15 +385,16 @@ fn lookup_vtable(vcx: &VtableContext,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n-                            let im_bs =\n-                                ty::lookup_item_type(tcx, im.did).generics.bounds;\n+                            let im_generics =\n+                                ty::lookup_item_type(tcx, im.did).generics;\n                             connect_trait_tps(vcx,\n                                               location_info,\n                                               &substs_f,\n                                               trait_ref,\n                                               im.did);\n                             let subres = lookup_vtables(\n-                                vcx, location_info, im_bs, &substs_f,\n+                                vcx, location_info,\n+                                *im_generics.type_param_defs, &substs_f,\n                                 is_early);\n \n                             // Finally, we register that we found a\n@@ -460,15 +459,15 @@ fn connect_trait_tps(vcx: &VtableContext,\n \n     // XXX: This should work for multiple traits.\n     let impl_trait_ref = ty::impl_trait_refs(tcx, impl_did)[0];\n-    let impl_trait_ref = ty::subst_in_trait_ref(tcx, impl_substs, impl_trait_ref);\n-    relate_trait_refs(vcx, location_info, trait_ref, &impl_trait_ref);\n+    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+    relate_trait_refs(vcx, location_info, &impl_trait_ref, trait_ref);\n }\n \n fn insert_vtables(fcx: @mut FnCtxt,\n                   callee_id: ast::node_id,\n                   vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n-           callee_id, vtables.map(|v| v.to_str(fcx.tcx())));\n+           callee_id, vtables.repr(fcx.tcx()));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n \n@@ -493,17 +492,15 @@ pub fn early_resolve_expr(ex: @ast::expr,\n             let def = *cx.tcx.def_map.get(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n+            debug!(\"early resolve expr: def %? %?, %?, %s\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(/*bad*/copy *item_ty.generics.bounds) {\n-                for item_ty.generics.bounds.each |bounds| {\n-                    debug!(\"early_resolve_expr: looking up vtables for bound \\\n-                            %s\",\n-                           ty::param_bounds_to_str(fcx.tcx(), *bounds));\n-                }\n+            if has_trait_bounds(*item_ty.generics.type_param_defs) {\n+                debug!(\"early_resolve_expr: looking up vtables for type params %s\",\n+                       item_ty.generics.type_param_defs.repr(fcx.tcx()));\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           item_ty.generics.bounds, substs, is_early);\n+                                           *item_ty.generics.type_param_defs,\n+                                           substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -519,9 +516,9 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       ast::expr_binary(*) |\n       ast::expr_unary(*) | ast::expr_assign_op(*) |\n       ast::expr_index(*) | ast::expr_method_call(*) => {\n-        match ty::method_call_bounds(cx.tcx, fcx.inh.method_map, ex.id) {\n-          Some(bounds) => {\n-            if has_trait_bounds(/*bad*/copy *bounds) {\n+        match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n+          Some(type_param_defs) => {\n+            if has_trait_bounds(*type_param_defs) {\n                 let callee_id = match ex.node {\n                   ast::expr_field(_, _, _) => ex.id,\n                   _ => ex.callee_id\n@@ -530,7 +527,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           bounds, &substs, is_early);\n+                                           *type_param_defs, &substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, callee_id, vtbls);\n                 }\n@@ -561,7 +558,11 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                           };\n                           let target_trait_ref = ty::TraitRef {\n                               def_id: target_def_id,\n-                              substs: copy *target_substs\n+                              substs: ty::substs {\n+                                  tps: copy target_substs.tps,\n+                                  self_r: target_substs.self_r,\n+                                  self_ty: Some(mt.ty)\n+                              }\n                           };\n                           let vtable_opt =\n                               lookup_vtable(&vcx,"}, {"sha": "3af4cb7f10cb40abeedb7d5fd470835c627e7586", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -91,7 +91,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n-                   id, r_origins.map(|v| v.to_str(fcx.tcx())));\n+                   id, r_origins.repr(fcx.tcx()));\n         }\n     }\n "}, {"sha": "174a20dd7f4c798b0f4b85c0ce2f908dbb3b7df8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 121, "deletions": 32, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -32,6 +32,7 @@ use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n+use middle::subst::Subst;\n use middle::ty;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n@@ -59,7 +60,7 @@ use core::uint;\n pub struct UniversalQuantificationResult {\n     monotype: t,\n     type_variables: ~[ty::t],\n-    bounds: @~[param_bounds]\n+    type_param_defs: @~[ty::TypeParameterDef]\n }\n \n pub fn get_base_type(inference_context: @mut InferCtxt,\n@@ -269,25 +270,24 @@ pub impl CoherenceChecker {\n         // We only want to generate one Impl structure. When we generate one,\n         // we store it here so that we don't recreate it.\n         let mut implementation_opt = None;\n-        for associated_traits.each |associated_trait| {\n-            let trait_did =\n-                self.trait_ref_to_trait_def_id(*associated_trait);\n-            debug!(\"(checking implementation) adding impl for trait \\\n-                    '%s', item '%s'\",\n-                    ast_map::node_id_to_str(\n-                        self.crate_context.tcx.items, trait_did.node,\n-                        self.crate_context.tcx.sess.parse_sess.interner),\n-                    *self.crate_context.tcx.sess.str_of(item.ident));\n-\n-            self.instantiate_default_methods(item.id, trait_did);\n+        for associated_traits.each |&associated_trait| {\n+            let trait_ref =\n+                ty::node_id_to_trait_ref(\n+                    self.crate_context.tcx,\n+                    associated_trait.ref_id);\n+            debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n+                   trait_ref.repr(self.crate_context.tcx),\n+                   *self.crate_context.tcx.sess.str_of(item.ident));\n+\n+            self.instantiate_default_methods(item.id, trait_ref);\n \n             let implementation;\n             if implementation_opt.is_none() {\n                 implementation = self.create_impl_from_item(item);\n                 implementation_opt = Some(implementation);\n             }\n \n-            self.add_trait_method(trait_did, implementation_opt.get());\n+            self.add_trait_method(trait_ref.def_id, implementation_opt.get());\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -325,22 +325,48 @@ pub impl CoherenceChecker {\n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self, impl_id: ast::node_id,\n-                                   trait_did: ast::def_id) {\n-        for self.each_provided_trait_method(trait_did) |trait_method| {\n+    fn instantiate_default_methods(&self,\n+                                   impl_id: ast::node_id,\n+                                   trait_ref: &ty::TraitRef) {\n+        let tcx = self.crate_context.tcx;\n+        debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n+               impl_id, trait_ref.repr(tcx));\n+\n+        let impl_poly_type = ty::lookup_item_type(tcx, local_def(impl_id));\n+\n+        for self.each_provided_trait_method(trait_ref.def_id) |trait_method| {\n             // Synthesize an ID.\n-            let tcx = self.crate_context.tcx;\n             let new_id = parse::next_node_id(tcx.sess.parse_sess);\n             let new_did = local_def(new_id);\n \n-            let new_method_ty = @ty::method {\n-                def_id: new_did,\n-                ..copy *trait_method\n+            debug!(\"new_did=%? trait_method=%s\", new_did, trait_method.repr(tcx));\n+\n+            // Create substitutions for the various trait parameters.\n+            let new_method_ty =\n+                @subst_receiver_types_in_method_ty(\n+                    tcx,\n+                    impl_id,\n+                    trait_ref,\n+                    new_did,\n+                    trait_method);\n+\n+            debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n+\n+            // construct the polytype for the method based on the method_ty\n+            let new_generics = ty::Generics {\n+                type_param_defs:\n+                    @vec::append(\n+                        copy *impl_poly_type.generics.type_param_defs,\n+                        *new_method_ty.generics.type_param_defs),\n+                region_param:\n+                    impl_poly_type.generics.region_param\n+            };\n+            let new_polytype = ty::ty_param_bounds_and_ty {\n+                generics: new_generics,\n+                ty: ty::mk_bare_fn(tcx, copy new_method_ty.fty)\n             };\n+            debug!(\"new_polytype=%s\", new_polytype.repr(tcx));\n \n-            // XXX: Perform substitutions.\n-            let new_polytype = ty::lookup_item_type(tcx,\n-                                                    trait_method.def_id);\n             tcx.tcache.insert(new_did, new_polytype);\n             tcx.methods.insert(new_did, new_method_ty);\n \n@@ -358,7 +384,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method.generics.bounds.len(),\n+                        n_tps: trait_method.generics.type_param_defs.len(),\n                         ident: trait_method.ident,\n                         self_type: trait_method.self_ty\n                     },\n@@ -545,9 +571,8 @@ pub impl CoherenceChecker {\n             polytype.generics.region_param.map(\n                 |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n \n-        let bounds_count = polytype.generics.bounds.len();\n-        let type_parameters =\n-            self.inference_context.next_ty_vars(bounds_count);\n+        let bounds_count = polytype.generics.type_param_defs.len();\n+        let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n             self_r: self_region,\n@@ -565,7 +590,7 @@ pub impl CoherenceChecker {\n         UniversalQuantificationResult {\n             monotype: monotype,\n             type_variables: type_parameters,\n-            bounds: polytype.generics.bounds\n+            type_param_defs: polytype.generics.type_param_defs\n         }\n     }\n \n@@ -582,13 +607,13 @@ pub impl CoherenceChecker {\n                 // Check to ensure that each parameter binding respected its\n                 // kind bounds.\n                 for [ a, b ].each |result| {\n-                    for vec::each2(result.type_variables, *result.bounds)\n-                            |ty_var, bounds| {\n+                    for vec::each2(result.type_variables, *result.type_param_defs)\n+                            |ty_var, type_param_def| {\n                         match resolve_type(self.inference_context,\n                                            *ty_var,\n                                            resolve_nested_tvar) {\n                             Ok(resolved_ty) => {\n-                                for bounds.each |bound| {\n+                                for type_param_def.bounds.each |bound| {\n                                     match *bound {\n                                         bound_copy => {\n                                             if !ty::type_is_copyable(\n@@ -914,7 +939,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method_info.ty.generics.bounds.len(),\n+                        n_tps: trait_method_info.ty.generics.type_param_defs.len(),\n                         ident: trait_method_info.ty.ident,\n                         self_type: trait_method_info.ty.self_ty\n                     },\n@@ -1010,6 +1035,70 @@ pub impl CoherenceChecker {\n     }\n }\n \n+fn subst_receiver_types_in_method_ty(\n+    tcx: ty::ctxt,\n+    impl_id: ast::node_id,\n+    trait_ref: &ty::TraitRef,\n+    new_def_id: ast::def_id,\n+    method: &ty::method) -> ty::method\n+{\n+    /*!\n+     * Substitutes the values for the receiver's type parameters\n+     * that are found in method, leaving the method's type parameters\n+     * intact.  This is in fact a mildly complex operation,\n+     * largely because of the hokey way that we concatenate the\n+     * receiver and method generics.\n+     */\n+\n+    // determine how many type parameters were declared on the impl\n+    let num_impl_type_parameters = {\n+        let impl_polytype = ty::lookup_item_type(tcx, local_def(impl_id));\n+        impl_polytype.generics.type_param_defs.len()\n+    };\n+\n+    // determine how many type parameters appear on the trait\n+    let num_trait_type_parameters = trait_ref.substs.tps.len();\n+\n+    // the current method type has the type parameters from the trait + method\n+    let num_method_type_parameters =\n+        num_trait_type_parameters + method.generics.type_param_defs.len();\n+\n+    // the new method type will have the type parameters from the impl + method\n+    let combined_tps = vec::from_fn(num_method_type_parameters, |i| {\n+        if i < num_trait_type_parameters {\n+            // replace type parameters that come from trait with new value\n+            trait_ref.substs.tps[i]\n+        } else {\n+            // replace type parameters that belong to method with another\n+            // type parameter, this time with the index adjusted\n+            let method_index = i - num_trait_type_parameters;\n+            let type_param_def = &method.generics.type_param_defs[method_index];\n+            let new_index = num_impl_type_parameters + method_index;\n+            ty::mk_param(tcx, new_index, type_param_def.def_id)\n+        }\n+    });\n+\n+    let combined_substs = ty::substs {\n+        self_r: trait_ref.substs.self_r,\n+        self_ty: trait_ref.substs.self_ty,\n+        tps: combined_tps\n+    };\n+\n+    ty::method {\n+        ident: method.ident,\n+\n+        // method tps cannot appear in the self_ty, so use `substs` from trait ref\n+        transformed_self_ty: method.transformed_self_ty.subst(tcx, &trait_ref.substs),\n+\n+        // method types *can* appear in the generic bounds or the fty\n+        generics: method.generics.subst(tcx, &combined_substs),\n+        fty: method.fty.subst(tcx, &combined_substs),\n+        self_ty: method.self_ty,\n+        vis: method.vis,\n+        def_id: new_def_id\n+    }\n+}\n+\n pub fn check_coherence(crate_context: @mut CrateCtxt, crate: @crate) {\n     let coherence_checker = @CoherenceChecker(crate_context);\n     coherence_checker.check_coherence(crate);"}, {"sha": "a3296f6c20985f10420eb7e241999dc2136c63e5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 164, "deletions": 83, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -35,6 +35,7 @@ use core::prelude::*;\n use metadata::csearch;\n use middle::ty::{substs, ty_param_bounds_and_ty};\n use middle::ty;\n+use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n@@ -186,7 +187,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics),\n+                    generics: ty_generics(ccx, rp, generics, 0),\n                     ty: enum_ty\n                 };\n \n@@ -207,7 +208,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             None => {}\n             Some(result_ty) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics),\n+                    generics: ty_generics(ccx, rp, generics, 0),\n                     ty: result_ty\n                 };\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -227,7 +228,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             node: ast::item_trait(ref generics, _, ref ms),\n             _\n         }, _) => {\n-            let trait_ty_generics = ty_generics(ccx, region_paramd, generics);\n+            let trait_ty_generics = ty_generics(ccx, region_paramd, generics, 0);\n \n             // For each method, construct a suitable ty::method and\n             // store it into the `tcx.methods` table:\n@@ -274,48 +275,99 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                              trait_id: ast::node_id,\n                              m: &ty::method,\n                              trait_ty_generics: &ty::Generics) {\n-        // We need to create a typaram that replaces self. This param goes\n-        // *in between* the typarams from the trait and those from the\n-        // method (since its bound can depend on the trait? or\n-        // something like that).\n+        // If declaration is\n+        //\n+        //     trait<A,B,C> {\n+        //        fn foo<D,E,F>(...) -> Self;\n+        //     }\n+        //\n+        // and we will create a function like\n+        //\n+        //     fn foo<A',B',C',D',E',F',G'>(...) -> D' {}\n+        //\n+        // Note that `Self` is replaced with an explicit type\n+        // parameter D' that is sandwiched in between the trait params\n+        // and the method params, and thus the indices of the method\n+        // type parameters are offset by 1 (that is, the method\n+        // parameters are mapped from D, E, F to E', F', and G').  The\n+        // choice of this ordering is somewhat arbitrary.\n+        //\n+        // Also, this system is rather a hack that should be replaced\n+        // with a more uniform treatment of Self (which is partly\n+        // underway).\n \n         // build up a subst that shifts all of the parameters over\n         // by one and substitute in a new type param for self\n \n+        let tcx = ccx.tcx;\n+\n         let dummy_defid = ast::def_id {crate: 0, node: 0};\n \n-        let num_trait_bounds = trait_ty_generics.bounds.len();\n+        // Represents [A',B',C']\n+        let num_trait_bounds = trait_ty_generics.type_param_defs.len();\n         let non_shifted_trait_tps = do vec::from_fn(num_trait_bounds) |i| {\n-            ty::mk_param(ccx.tcx, i, dummy_defid)\n+            ty::mk_param(tcx, i, dummy_defid)\n         };\n-        let self_param = ty::mk_param(ccx.tcx, num_trait_bounds,\n+\n+        // Represents [D']\n+        let self_param = ty::mk_param(tcx, num_trait_bounds,\n                                       dummy_defid);\n-        let shifted_method_tps = do vec::from_fn(m.generics.bounds.len()) |i| {\n-            ty::mk_param(ccx.tcx, i + 1, dummy_defid)\n+\n+        // Represents [E',F',G']\n+        let num_method_bounds = m.generics.type_param_defs.len();\n+        let shifted_method_tps = do vec::from_fn(num_method_bounds) |i| {\n+            ty::mk_param(tcx, i + 1, dummy_defid)\n         };\n \n+        // build up the substitution from\n+        //     A,B,C => A',B',C'\n+        //     Self => D'\n+        //     D,E,F => E',F',G'\n         let substs = substs {\n             self_r: None,\n             self_ty: Some(self_param),\n             tps: non_shifted_trait_tps + shifted_method_tps\n         };\n-        let ty = ty::subst(ccx.tcx,\n+\n+        // create the type of `foo`, applying the substitution above\n+        let ty = ty::subst(tcx,\n                            &substs,\n-                           ty::mk_bare_fn(ccx.tcx, copy m.fty));\n-        let trait_def = get_trait_def(ccx, local_def(trait_id));\n-        let trait_ref = trait_def.trait_ref;\n-        let mut new_bounds = ~[];\n-        new_bounds.push_all(*trait_ty_generics.bounds);\n-        new_bounds.push(@~[ty::bound_trait(trait_ref)]);\n-        new_bounds.push_all(*m.generics.bounds);\n-        ccx.tcx.tcache.insert(m.def_id,\n-                              ty_param_bounds_and_ty {\n-                                  generics: ty::Generics {\n-                                      bounds: @new_bounds,\n-                                      region_param: trait_ty_generics.region_param\n-                                  },\n-                                  ty: ty\n-                              });\n+                           ty::mk_bare_fn(tcx, copy m.fty));\n+\n+        // create the type parameter definitions for `foo`, applying\n+        // the substitution to any traits that appear in their bounds.\n+\n+        // add in the type parameters from the trait\n+        let mut new_type_param_defs = ~[];\n+        let substd_type_param_defs =\n+            trait_ty_generics.type_param_defs.subst(tcx, &substs);\n+        new_type_param_defs.push_all(*substd_type_param_defs);\n+\n+        // add in the \"self\" type parameter\n+        let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n+        let self_trait_ref = @self_trait_def.trait_ref.subst(tcx, &substs);\n+        new_type_param_defs.push(ty::TypeParameterDef {\n+            def_id: dummy_defid,\n+            bounds: @~[ty::bound_trait(self_trait_ref)]\n+        });\n+\n+        // add in the type parameters from the method\n+        let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n+        new_type_param_defs.push_all(*substd_type_param_defs);\n+\n+        debug!(\"static method %s type_param_defs=%s substs=%s\",\n+               m.def_id.repr(tcx),\n+               new_type_param_defs.repr(tcx),\n+               substs.repr(tcx));\n+\n+        tcx.tcache.insert(m.def_id,\n+                          ty_param_bounds_and_ty {\n+                              generics: ty::Generics {\n+                                  type_param_defs: @new_type_param_defs,\n+                                  region_param: trait_ty_generics.region_param\n+                              },\n+                              ty: ty\n+                          });\n     }\n \n     fn ty_method_of_trait_method(self: &CrateCtxt,\n@@ -334,9 +386,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(self, &rscope, *m_purity, &m_generics.lifetimes,\n                                   trait_self_ty, *m_self_ty, m_decl);\n+        let num_trait_type_params = trait_generics.ty_params.len();\n         ty::method {\n             ident: *m_ident,\n-            generics: ty_generics(self, None, m_generics),\n+            generics: ty_generics(self, None, m_generics, num_trait_type_params),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: m_self_ty.node,\n@@ -357,9 +410,11 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n+    let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n     for ast_trait_refs.each |&ast_trait_ref| {\n-        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp, generics);\n+        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n+                                              generics, self_ty);\n \n         // FIXME(#5527) Could have same trait multiple times\n         if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n@@ -426,15 +481,18 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         }\n     }\n \n-    if impl_m.generics.bounds.len() != trait_m.generics.bounds.len() {\n+    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n+    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n+    if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 *tcx.sess.str_of(trait_m.ident), impl_m.generics.bounds.len(),\n-                 pluralize(impl_m.generics.bounds.len(), ~\"parameter\"),\n-                 trait_m.generics.bounds.len(),\n-                 pluralize(trait_m.generics.bounds.len(), ~\"parameter\")));\n+                 *tcx.sess.str_of(trait_m.ident),\n+                 num_impl_m_type_params,\n+                 pluralize(num_impl_m_type_params, ~\"parameter\"),\n+                 num_trait_m_type_params,\n+                 pluralize(num_trait_m_type_params, ~\"parameter\")));\n         return;\n     }\n \n@@ -452,23 +510,23 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // FIXME(#2687)---we should be checking that the bounds of the\n     // trait imply the bounds of the subtype, but it appears\n     // we are...not checking this.\n-    for trait_m.generics.bounds.eachi() |i, trait_param_bounds| {\n+    for trait_m.generics.type_param_defs.eachi |i, trait_param_def| {\n         // For each of the corresponding impl ty param's bounds...\n-        let impl_param_bounds = impl_m.generics.bounds[i];\n+        let impl_param_def = &impl_m.generics.type_param_defs[i];\n         // Make sure the bounds lists have the same length\n         // Would be nice to use the ty param names in the error message,\n         // but we don't have easy access to them here\n-        if impl_param_bounds.len() != trait_param_bounds.len() {\n+        if impl_param_def.bounds.len() != trait_param_def.bounds.len() {\n            tcx.sess.span_err(\n                cm.span,\n                fmt!(\"in method `%s`, \\\n                      type parameter %u has %u %s, but the same type \\\n                      parameter in its trait declaration has %u %s\",\n                     *tcx.sess.str_of(trait_m.ident),\n-                    i, impl_param_bounds.len(),\n-                    pluralize(impl_param_bounds.len(), ~\"bound\"),\n-                    trait_param_bounds.len(),\n-                    pluralize(trait_param_bounds.len(), ~\"bound\")));\n+                    i, impl_param_def.bounds.len(),\n+                    pluralize(impl_param_def.bounds.len(), ~\"bound\"),\n+                    trait_param_def.bounds.len(),\n+                    pluralize(trait_param_def.bounds.len(), ~\"bound\")));\n            return;\n         }\n     }\n@@ -492,12 +550,12 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n-    debug!(\"impl_fty: %s\", ppaux::ty_to_str(tcx, impl_fty));\n+    debug!(\"impl_fty (post-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n-        let dummy_tps = do vec::from_fn(trait_m.generics.bounds.len()) |i| {\n-            // hack: we don't know the def id of the impl tp, but it\n-            // is not important for unification\n-            ty::mk_param(tcx, i + impl_tps, ast::def_id {crate: 0, node: 0})\n+        let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n+        let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n+            ty::mk_param(tcx, i + impl_tps,\n+                         impl_m.generics.type_param_defs[i].def_id)\n         };\n         let trait_tps = trait_substs.tps.map(\n             |t| replace_bound_self(tcx, *t, dummy_self_r));\n@@ -507,9 +565,11 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n         let trait_fty = ty::mk_bare_fn(tcx, copy trait_m.fty);\n-        debug!(\"trait_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, trait_fty));\n+        debug!(\"trait_fty (pre-subst): %s substs=%s\",\n+               trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n+    debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     match infer::mk_subty(infcx, false, cm.span, impl_fty, trait_fty) {\n@@ -542,7 +602,8 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    impl_ms: &[ConvertedMethod])\n {\n     let tcx = ccx.tcx;\n-    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n+    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp,\n+                                          generics, selfty);\n \n     if trait_ref.def_id.crate == ast::local_crate {\n         ensure_trait_methods(ccx, trait_ref.def_id.node);\n@@ -574,7 +635,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n \n pub fn convert_field(ccx: &CrateCtxt,\n                      rp: Option<ty::region_variance>,\n-                     bounds: @~[ty::param_bounds],\n+                     type_param_defs: @~[ty::TypeParameterDef],\n                      v: @ast::struct_field,\n                      generics: &ast::Generics) {\n     let region_parameterization =\n@@ -585,7 +646,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n-                                  bounds: bounds,\n+                                  type_param_defs: type_param_defs,\n                                   region_param: rp\n                               },\n                               ty: tt\n@@ -609,8 +670,10 @@ pub fn convert_methods(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n     return vec::map(ms, |m| {\n+        let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n         let m_ty_generics =\n-            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics);\n+            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n+                        num_rcvr_ty_params);\n         let mty =\n             @ty_of_method(ccx, *m, rcvr_ty_generics.region_param,\n                           untransformed_rcvr_ty,\n@@ -625,8 +688,9 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             // the tps on the receiver and those on the method itself\n             ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    bounds: @(vec::append(copy *rcvr_ty_generics.bounds,\n-                                          *m_ty_generics.bounds)),\n+                    type_param_defs: @vec::append(\n+                        copy *rcvr_ty_generics.type_param_defs,\n+                        *m_ty_generics.type_param_defs),\n                     region_param: rcvr_ty_generics.region_param\n                 },\n                 ty: fty\n@@ -660,9 +724,10 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         // foo(); }`).\n         let method_vis = m.vis.inherit_from(rcvr_visibility);\n \n+        let num_rcvr_type_params = rcvr_generics.ty_params.len();\n         ty::method {\n             ident: m.ident,\n-            generics: ty_generics(ccx, None, &m.generics),\n+            generics: ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: m.self_ty.node,\n@@ -705,7 +770,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                                rp);\n       }\n       ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n-        let i_ty_generics = ty_generics(ccx, rp, generics);\n+        let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let selfty = ccx.to_ty(&type_rscope(region_parameterization), selfty);\n@@ -741,8 +806,9 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n \n           let (_, provided_methods) =\n               split_trait_methods(*trait_methods);\n-          let (ty_generics, _) = mk_substs(ccx, generics, rp);\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n+          let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n+                                                Some(untransformed_rcvr_ty));\n           let _ = convert_methods(ccx, provided_methods,\n                                   untransformed_rcvr_ty,\n                                   &ty_generics, generics,\n@@ -799,17 +865,17 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n-                                  bounds: tpt.generics.bounds,\n+                                  type_param_defs: tpt.generics.type_param_defs,\n                                   region_param: rp\n                               },\n                               ty: t_dtor});\n     };\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n-       convert_field(ccx, rp, tpt.generics.bounds, *f, generics);\n+       convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n     }\n-    let (_, substs) = mk_substs(ccx, generics, rp);\n+    let (_, substs) = mk_item_substs(ccx, generics, rp, None);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -850,7 +916,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                              ast_trait_ref: @ast::trait_ref,\n                              rp: Option<ty::region_variance>,\n-                             generics: &ast::Generics) -> @ty::TraitRef\n+                             generics: &ast::Generics,\n+                             self_ty: ty::t) -> @ty::TraitRef\n {\n     /*!\n      * Instantiates the path for the given trait reference, assuming that\n@@ -866,7 +933,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         ast::def_trait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n-                    ccx, &rscope, trait_did, ast_trait_ref.path);\n+                    ccx, &rscope, trait_did, Some(self_ty), ast_trait_ref.path);\n             ccx.tcx.trait_refs.insert(\n                 ast_trait_ref.ref_id, trait_ref);\n             return trait_ref;\n@@ -903,7 +970,9 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: @ast::item) -> @ty::TraitDef {\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n         ast::item_trait(ref generics, _, _) => {\n-            let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n+            let self_ty = ty::mk_self(tcx, def_id);\n+            let (ty_generics, substs) = mk_item_substs(ccx, generics, rp,\n+                                                       Some(self_ty));\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n@@ -937,7 +1006,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_fn(ref decl, purity, _, ref generics, _) => {\n         assert!(rp.is_none());\n-        let ty_generics = ty_generics(ccx, None, generics);\n+        let ty_generics = ty_generics(ccx, None, generics, 0);\n         let tofd = astconv::ty_of_bare_fn(ccx,\n                                           &empty_rscope,\n                                           purity,\n@@ -946,7 +1015,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n                                           decl);\n         let tpt = ty_param_bounds_and_ty {\n             generics: ty::Generics {\n-                bounds: ty_generics.bounds,\n+                type_param_defs: ty_generics.type_param_defs,\n                 region_param: None\n             },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n@@ -979,7 +1048,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n                 }\n             };\n             ty_param_bounds_and_ty {\n-                generics: ty_generics(ccx, rp, generics),\n+                generics: ty_generics(ccx, rp, generics, 0),\n                 ty: ty\n             }\n         };\n@@ -989,7 +1058,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_enum(_, ref generics) => {\n         // Create a new generic polytype.\n-        let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n+        let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = ty_param_bounds_and_ty {\n             generics: ty_generics,\n@@ -1004,7 +1073,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n               fmt!(\"Invoked ty_of_item on trait\"));\n       }\n       ast::item_struct(_, ref generics) => {\n-          let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n+          let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = ty_param_bounds_and_ty {\n               generics: ty_generics,\n@@ -1031,7 +1100,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt, it: @ast::foreign_item)\n         ast::foreign_item_const(t) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    bounds: @~[],\n+                    type_param_defs: @~[],\n                     region_param: None,\n                 },\n                 ty: ast_ty_to_ty(ccx, &empty_rscope, t)\n@@ -1042,16 +1111,25 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt, it: @ast::foreign_item)\n \n pub fn ty_generics(ccx: &CrateCtxt,\n                    rp: Option<ty::region_variance>,\n-                   generics: &ast::Generics) -> ty::Generics {\n+                   generics: &ast::Generics,\n+                   base_index: uint) -> ty::Generics {\n     return ty::Generics {\n         region_param: rp,\n-        bounds: @generics.ty_params.map_to_vec(|param| {\n-            match ccx.tcx.ty_param_bounds.find(&param.id) {\n-                Some(&bs) => bs,\n+        type_param_defs: @generics.ty_params.mapi_to_vec(|offset, param| {\n+            match ccx.tcx.ty_param_defs.find(&param.id) {\n+                Some(&def) => def,\n                 None => {\n-                    let bounds = compute_bounds(ccx, rp, generics, param.bounds);\n-                    ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n-                    bounds\n+                    let param_ty = ty::param_ty {idx: base_index + offset,\n+                                                 def_id: local_def(param.id)};\n+                    let bounds = compute_bounds(ccx, rp, generics,\n+                                                param_ty, param.bounds);\n+                    let def = ty::TypeParameterDef {\n+                        def_id: local_def(param.id),\n+                        bounds: bounds\n+                    };\n+                    debug!(\"def for param: %s\", def.repr(ccx.tcx));\n+                    ccx.tcx.ty_param_defs.insert(param.id, def);\n+                    def\n                 }\n             }\n         })\n@@ -1061,6 +1139,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         ccx: &CrateCtxt,\n         rp: Option<ty::region_variance>,\n         generics: &ast::Generics,\n+        param_ty: ty::param_ty,\n         ast_bounds: @OptVec<ast::TyParamBound>) -> ty::param_bounds\n     {\n         /*!\n@@ -1076,7 +1155,8 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             match b {\n                 &TraitTyParamBound(b) => {\n                     let li = &ccx.tcx.lang_items;\n-                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics);\n+                    let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n+                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n                     if trait_ref.def_id == li.owned_trait() {\n                         ~[ty::bound_owned]\n                     } else if trait_ref.def_id == li.copy_trait() {\n@@ -1104,7 +1184,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              def_id: ast::def_id,\n                              ast_generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n-    let ty_generics = ty_generics(ccx, None, ast_generics);\n+    let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n     let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n@@ -1127,17 +1207,18 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     return tpt;\n }\n \n-pub fn mk_substs(ccx: &CrateCtxt,\n-                 ast_generics: &ast::Generics,\n-                 rp: Option<ty::region_variance>) -> (ty::Generics, ty::substs)\n+pub fn mk_item_substs(ccx: &CrateCtxt,\n+                      ast_generics: &ast::Generics,\n+                      rp: Option<ty::region_variance>,\n+                      self_ty: Option<ty::t>) -> (ty::Generics, ty::substs)\n {\n     let mut i = 0;\n-    let ty_generics = ty_generics(ccx, rp, ast_generics);\n+    let ty_generics = ty_generics(ccx, rp, ast_generics, 0);\n     let params = ast_generics.ty_params.map_to_vec(|atp| {\n         let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n         i += 1u;\n         t\n     });\n     let self_r = rscope::bound_self_region(rp);\n-    (ty_generics, substs {self_r: self_r, self_ty: None, tps: params})\n+    (ty_generics, substs {self_r: self_r, self_ty: self_ty, tps: params})\n }"}, {"sha": "be1d291cfe5c9ef9dc5615d4f9b35d2cf8a0f60e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -274,15 +274,14 @@ pub fn super_tps<C:Combine>(\n pub fn super_self_tys<C:Combine>(\n     self: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n \n-    // Note: the self type parameter is (currently) always treated as\n-    // *invariant* (otherwise the type system would be unsound).\n-\n     match (a, b) {\n       (None, None) => {\n         Ok(None)\n       }\n       (Some(a), Some(b)) => {\n-        eq_tys(self, a, b).then(|| Ok(Some(a)) )\n+          // FIXME(#5781) this should be eq_tys\n+          // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n+          self.contratys(a, b).chain(|t| Ok(Some(t)))\n       }\n       (None, Some(_)) |\n       (Some(_), None) => {"}, {"sha": "fdb8049d79be99d5630f296fc58ef7a0f49a5386", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -53,6 +53,7 @@ use core::prelude::*;\n use middle::resolve;\n use middle::ty;\n use util::common::time;\n+use util::ppaux::Repr;\n use util::ppaux;\n \n use core::hashmap::HashMap;\n@@ -153,14 +154,15 @@ pub enum vtable_origin {\n     vtable_param(uint, uint)\n }\n \n-pub impl vtable_origin {\n-    fn to_str(&self, tcx: ty::ctxt) -> ~str {\n+impl Repr for vtable_origin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                fmt!(\"vtable_static(%?:%s, %?, %?)\",\n-                     def_id, ty::item_path_str(tcx, def_id),\n-                     tys,\n-                     vtable_res.map(|o| o.to_str(tcx)))\n+                fmt!(\"vtable_static(%?:%s, %s, %s)\",\n+                     def_id,\n+                     ty::item_path_str(tcx, def_id),\n+                     tys.repr(tcx),\n+                     vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n@@ -222,7 +224,7 @@ pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {bounds: @~[],\n+        generics: ty::Generics {type_param_defs: @~[],\n                                 region_param: None},\n         ty: t\n     }"}, {"sha": "94fcb85d1d84c4af5079ca2fe8291bb3b82f28d6", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -83,6 +83,7 @@ pub mod middle {\n         pub mod asm;\n     }\n     pub mod ty;\n+    pub mod subst;\n     pub mod resolve;\n     #[path = \"typeck/mod.rs\"]\n     pub mod typeck;"}, {"sha": "f26eeeca446c1cd4ae2f9091d8890d1bbc5db113", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 264, "deletions": 14, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use middle::ty;\n+use middle::typeck;\n use middle::ty::canon_mode;\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid,\n                  br_fresh};\n@@ -35,6 +36,10 @@ use syntax::abi::AbiSet;\n use core::str;\n use core::vec;\n \n+pub trait Repr {\n+    fn repr(&self, tcx: ctxt) -> ~str;\n+}\n+\n pub fn note_and_explain_region(cx: ctxt,\n                                prefix: ~str,\n                                region: ty::Region,\n@@ -257,18 +262,6 @@ pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-pub fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n-    fmt!(\"expr(%d: %s)\",\n-         expr.id,\n-         pprust::expr_to_str(expr, cx.sess.intr()))\n-}\n-\n-pub fn pat_repr(cx: ctxt, pat: @ast::pat) -> ~str {\n-    fmt!(\"pat(%d: %s)\",\n-         pat.id,\n-         pprust::pat_to_str(pat, cx.sess.intr()))\n-}\n-\n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     let tstrs = ts.map(|t| ty_to_str(cx, *t));\n     fmt!(\"(%s)\", str::connect(tstrs, \", \"))\n@@ -287,7 +280,13 @@ pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n     let path = ty::item_path(cx, trait_ref.def_id);\n     let base = ast_map::path_to_str(path, cx.sess.intr());\n-    parameterized(cx, base, trait_ref.substs.self_r, trait_ref.substs.tps)\n+    if cx.sess.verbose() && trait_ref.substs.self_ty.is_some() {\n+        let mut all_tps = copy trait_ref.substs.tps;\n+        for trait_ref.substs.self_ty.each |&t| { all_tps.push(t); }\n+        parameterized(cx, base, trait_ref.substs.self_r, all_tps)\n+    } else {\n+        parameterized(cx, base, trait_ref.substs.self_r, trait_ref.substs.tps)\n+    }\n }\n \n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n@@ -497,10 +496,261 @@ pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     return s;\n }\n \n+impl<T:Repr> Repr for Option<T> {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match self {\n+            &None => ~\"None\",\n+            &Some(ref t) => fmt!(\"Some(%s)\", t.repr(tcx))\n+        }\n+    }\n+}\n+\n+/*\n+Annoyingly, these conflict with @ast::expr.\n+\n+impl<T:Repr> Repr for @T {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        (&**self).repr(tcx)\n+    }\n+}\n+\n+impl<T:Repr> Repr for ~T {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        (&**self).repr(tcx)\n+    }\n+}\n+*/\n+\n+fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n+    fmt!(\"[%s]\", str::connect(v.map(|t| t.repr(tcx)), \",\"))\n+}\n+\n+impl<'self, T:Repr> Repr for &'self [T] {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        repr_vec(tcx, *self)\n+    }\n+}\n+\n+// This is necessary to handle types like Option<@~[T]>, for which\n+// autoderef cannot convert the &[T] handler\n+impl<T:Repr> Repr for @~[T] {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        repr_vec(tcx, **self)\n+    }\n+}\n+\n+impl Repr for ty::TypeParameterDef {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"TypeParameterDef {%?, bounds: %s}\",\n+             self.def_id, self.bounds.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::t {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        ty_to_str(tcx, *self)\n+    }\n+}\n+\n+impl Repr for ty::substs {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"substs(self_r=%s, self_ty=%s, tps=%s)\",\n+             self.self_r.repr(tcx),\n+             self.self_ty.repr(tcx),\n+             self.tps.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::param_bound {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match *self {\n+            ty::bound_copy => ~\"copy\",\n+            ty::bound_durable => ~\"'static\",\n+            ty::bound_owned => ~\"owned\",\n+            ty::bound_const => ~\"const\",\n+            ty::bound_trait(ref t) => t.repr(tcx)\n+        }\n+    }\n+}\n+\n+impl Repr for ty::TraitRef {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        trait_ref_to_str(tcx, self)\n+    }\n+}\n+\n+impl Repr for @ast::expr {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"expr(%d: %s)\",\n+             self.id,\n+             pprust::expr_to_str(*self, tcx.sess.intr()))\n+    }\n+}\n+\n+impl Repr for @ast::pat {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"pat(%d: %s)\",\n+             self.id,\n+             pprust::pat_to_str(*self, tcx.sess.intr()))\n+    }\n+}\n+\n+impl Repr for ty::Region {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        region_to_str(tcx, *self)\n+    }\n+}\n+\n+impl Repr for ast::def_id {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        // Unfortunately, there seems to be no way to attempt to print\n+        // a path for a def-id, so I'll just make a best effort for now\n+        // and otherwise fallback to just printing the crate/node pair\n+        if self.crate == ast::local_crate {\n+            match tcx.items.find(&self.node) {\n+                Some(&ast_map::node_item(*)) |\n+                Some(&ast_map::node_foreign_item(*)) |\n+                Some(&ast_map::node_method(*)) |\n+                Some(&ast_map::node_trait_method(*)) |\n+                Some(&ast_map::node_variant(*)) |\n+                Some(&ast_map::node_struct_ctor(*)) => {\n+                    return fmt!(\"%?:%s\", *self, ty::item_path_str(tcx, *self));\n+                }\n+                _ => {}\n+            }\n+        }\n+        return fmt!(\"%?\", *self);\n+    }\n+}\n+\n+impl Repr for ty::ty_param_bounds_and_ty {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"ty_param_bounds_and_ty {generics: %s, ty: %s}\",\n+             self.generics.repr(tcx),\n+             self.ty.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::Generics {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"Generics {type_param_defs: %s, region_param: %?}\",\n+             self.type_param_defs.repr(tcx),\n+             self.region_param)\n+    }\n+}\n+\n+impl Repr for ty::method {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"method {ident: %s, generics: %s, transformed_self_ty: %s, \\\n+              fty: %s, self_ty: %s, vis: %s, def_id: %s}\",\n+             self.ident.repr(tcx),\n+             self.generics.repr(tcx),\n+             self.transformed_self_ty.repr(tcx),\n+             self.fty.repr(tcx),\n+             self.self_ty.repr(tcx),\n+             self.vis.repr(tcx),\n+             self.def_id.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ast::ident {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        copy *tcx.sess.intr().get(*self)\n+    }\n+}\n+\n+impl Repr for ast::self_ty_ {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n+impl Repr for ast::visibility {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n+impl Repr for ty::BareFnTy {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"BareFnTy {purity: %?, abis: %s, sig: %s}\",\n+             self.purity,\n+             self.abis.to_str(),\n+             self.sig.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::FnSig {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fn_sig_to_str(tcx, self)\n+    }\n+}\n+\n+impl Repr for typeck::method_map_entry {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"method_map_entry {self_arg: %s, \\\n+              explicit_self: %s, \\\n+              origin: %s}\",\n+             self.self_arg.repr(tcx),\n+             self.explicit_self.repr(tcx),\n+             self.origin.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::arg {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"%?(%s)\", self.mode, self.ty.repr(tcx))\n+    }\n+}\n+\n+impl Repr for typeck::method_origin {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match self {\n+            &typeck::method_super(def_id, n) => {\n+                fmt!(\"method_super(%s, %?)\",\n+                     def_id.repr(tcx), n)\n+            }\n+            &typeck::method_static(def_id) => {\n+                fmt!(\"method_static(%s)\", def_id.repr(tcx))\n+            }\n+            &typeck::method_param(ref p) => {\n+                p.repr(tcx)\n+            }\n+            &typeck::method_trait(def_id, n, st) => {\n+                fmt!(\"method_trait(%s, %?, %s)\", def_id.repr(tcx), n,\n+                     st.repr(tcx))\n+            }\n+            &typeck::method_self(def_id, n) => {\n+                fmt!(\"method_self(%s, %?)\", def_id.repr(tcx), n)\n+            }\n+        }\n+    }\n+}\n+\n+impl Repr for typeck::method_param {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"method_param(%s,%?,%?,%?)\",\n+             self.trait_id.repr(tcx),\n+             self.method_num,\n+             self.param_num,\n+             self.bound_num)\n+    }\n+}\n+\n+impl Repr for ty::TraitStore {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match self {\n+            &ty::BoxTraitStore => ~\"@Trait\",\n+            &ty::UniqTraitStore => ~\"~Trait\",\n+            &ty::RegionTraitStore(r) => fmt!(\"&%s Trait\", r.repr(tcx))\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// End:\n+// End"}, {"sha": "fd54746f3dc517e72b943c1098ca851f5e93c076", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -102,6 +102,16 @@ impl<T:Copy> OptVec<T> {\n             self.push(copy *e);\n         }\n     }\n+\n+    #[inline(always)]\n+    fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+        let mut index = 0;\n+        iter::map_to_vec(self, |a| {\n+            let i = index;\n+            index += 1;\n+            op(i, a)\n+        })\n+    }\n }\n \n impl<A:Eq> Eq for OptVec<A> {"}, {"sha": "8105cf23d800433ed135bf9960e08aaea4fd3f97", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=92e265cdea0c528ccca4ccdd1e62d8bc3614b3d5", "patch": "@@ -0,0 +1,61 @@\n+// Test for issue #4183: use of Self in supertraits.\n+\n+pub static FUZZY_EPSILON: float = 0.1;\n+\n+pub trait FuzzyEq<Eps> {\n+    fn fuzzy_eq(&self, other: &Self) -> bool;\n+    fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n+}\n+\n+trait Float: FuzzyEq<Self> {\n+    fn two_pi() -> Self;\n+}\n+\n+impl FuzzyEq<f32> for f32 {\n+    fn fuzzy_eq(&self, other: &f32) -> bool {\n+        self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f32))\n+    }\n+\n+    fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n+        f32::abs(*self - *other) < *epsilon\n+    }\n+}\n+\n+impl Float for f32 {\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576_f32 }\n+}\n+\n+impl FuzzyEq<f64> for f64 {\n+    fn fuzzy_eq(&self, other: &f64) -> bool {\n+        self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f64))\n+    }\n+\n+    fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n+        f64::abs(*self - *other) < *epsilon\n+    }\n+}\n+\n+impl Float for f64 {\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576_f64 }\n+}\n+\n+fn compare<F:Float>(f1: F) -> bool {\n+    let f2 = Float::two_pi();\n+    f1.fuzzy_eq(&f2)\n+}\n+\n+pub fn main() {\n+    assert!(compare::<f32>(6.28318530717958647692528676655900576));\n+    assert!(compare::<f32>(6.29));\n+    assert!(compare::<f32>(6.3));\n+    assert!(compare::<f32>(6.19));\n+    assert!(!compare::<f32>(7.28318530717958647692528676655900576));\n+    assert!(!compare::<f32>(6.18));\n+\n+    assert!(compare::<f64>(6.28318530717958647692528676655900576));\n+    assert!(compare::<f64>(6.29));\n+    assert!(compare::<f64>(6.3));\n+    assert!(compare::<f64>(6.19));\n+    assert!(!compare::<f64>(7.28318530717958647692528676655900576));\n+    assert!(!compare::<f64>(6.18));\n+}\n\\ No newline at end of file"}]}