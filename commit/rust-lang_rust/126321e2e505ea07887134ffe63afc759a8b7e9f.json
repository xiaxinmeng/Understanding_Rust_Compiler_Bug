{"sha": "126321e2e505ea07887134ffe63afc759a8b7e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNjMyMWUyZTUwNWVhMDc4ODcxMzRmZmU2M2FmYzc1OWE4YjdlOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-28T18:31:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-28T18:31:52Z"}, "message": "Auto merge of #43230 - alexcrichton:more-tokenstream, r=nrc,jseyfried\n\nImplement tokenization for some items in proc_macro\n\nThis PR is a partial implementation of https://github.com/rust-lang/rust/issues/43081 targeted towards preserving span information in attribute-like procedural macros. Currently all attribute-like macros will lose span information with the input token stream if it's iterated over due to the inability of the compiler to losslessly tokenize an AST node. This PR takes a strategy of saving off a list of tokens in particular AST nodes to return a lossless tokenized version. There's a few limitations with this PR, however, so the old fallback remains in place.", "tree": {"sha": "b0a32d62221930b4d913216d4dcfccbc4a0b2088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0a32d62221930b4d913216d4dcfccbc4a0b2088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/126321e2e505ea07887134ffe63afc759a8b7e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/126321e2e505ea07887134ffe63afc759a8b7e9f", "html_url": "https://github.com/rust-lang/rust/commit/126321e2e505ea07887134ffe63afc759a8b7e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/126321e2e505ea07887134ffe63afc759a8b7e9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba9d7f08ce5c90549ee52337aca0010ad566f0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba9d7f08ce5c90549ee52337aca0010ad566f0d", "html_url": "https://github.com/rust-lang/rust/commit/eba9d7f08ce5c90549ee52337aca0010ad566f0d"}, {"sha": "4886ec86651a5eaae1ddc834a941842904a5db61", "url": "https://api.github.com/repos/rust-lang/rust/commits/4886ec86651a5eaae1ddc834a941842904a5db61", "html_url": "https://github.com/rust-lang/rust/commit/4886ec86651a5eaae1ddc834a941842904a5db61"}], "stats": {"total": 513, "additions": 489, "deletions": 24}, "files": [{"sha": "1bffffd6c9e711834416617ad236917115386154", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -509,14 +509,49 @@ impl TokenTree {\n             Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n             Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n \n-            Interpolated(ref nt) => __internal::with_sess(|(sess, _)| {\n-                TokenNode::Group(Delimiter::None, TokenStream(nt.1.force(|| {\n-                    // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n-                    let name = \"<macro expansion>\".to_owned();\n-                    let source = pprust::token_to_string(&token);\n-                    parse_stream_from_source_str(name, source, sess, Some(span))\n-                })))\n-            }),\n+            Interpolated(ref nt) => {\n+                // An `Interpolated` token means that we have a `Nonterminal`\n+                // which is often a parsed AST item. At this point we now need\n+                // to convert the parsed AST to an actual token stream, e.g.\n+                // un-parse it basically.\n+                //\n+                // Unfortunately there's not really a great way to do that in a\n+                // guaranteed lossless fashion right now. The fallback here is\n+                // to just stringify the AST node and reparse it, but this loses\n+                // all span information.\n+                //\n+                // As a result, some AST nodes are annotated with the token\n+                // stream they came from. Attempt to extract these lossless\n+                // token streams before we fall back to the stringification.\n+                let mut tokens = None;\n+\n+                match nt.0 {\n+                    Nonterminal::NtItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    Nonterminal::NtTraitItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    Nonterminal::NtImplItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    _ => {}\n+                }\n+\n+                tokens.map(|tokens| {\n+                    TokenNode::Group(Delimiter::None,\n+                                     TokenStream(tokens.clone()))\n+                }).unwrap_or_else(|| {\n+                    __internal::with_sess(|(sess, _)| {\n+                        TokenNode::Group(Delimiter::None, TokenStream(nt.1.force(|| {\n+                            // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n+                            let name = \"<macro expansion>\".to_owned();\n+                            let source = pprust::token_to_string(&token);\n+                            parse_stream_from_source_str(name, source, sess, Some(span))\n+                        })))\n+                    })\n+                })\n+            }\n \n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n@@ -580,6 +615,34 @@ impl TokenTree {\n     }\n }\n \n+fn prepend_attrs(attrs: &[ast::Attribute],\n+                 tokens: Option<&tokenstream::TokenStream>,\n+                 span: syntax_pos::Span)\n+    -> Option<tokenstream::TokenStream>\n+{\n+    let tokens = match tokens {\n+        Some(tokens) => tokens,\n+        None => return None,\n+    };\n+    if attrs.len() == 0 {\n+        return Some(tokens.clone())\n+    }\n+    let mut builder = tokenstream::TokenStreamBuilder::new();\n+    for attr in attrs {\n+        assert_eq!(attr.style, ast::AttrStyle::Outer,\n+                   \"inner attributes should prevent cached tokens from existing\");\n+        let stream = __internal::with_sess(|(sess, _)| {\n+            // FIXME: Avoid this pretty-print + reparse hack as bove\n+            let name = \"<macro expansion>\".to_owned();\n+            let source = pprust::attr_to_string(attr);\n+            parse_stream_from_source_str(name, source, sess, Some(span))\n+        });\n+        builder.push(stream);\n+    }\n+    builder.push(tokens.clone());\n+    Some(builder.build())\n+}\n+\n /// Permanently unstable internal implementation details of this crate. This\n /// should not be used.\n ///"}, {"sha": "25079613e586d694be643155334a0b97c55390be", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -389,6 +389,7 @@ impl CrateStore for cstore::CStore {\n                 legacy: def.legacy,\n             }),\n             vis: ast::Visibility::Inherited,\n+            tokens: None,\n         })\n     }\n "}, {"sha": "fb7915415245320b5ece76ee8e8b3340bd339224", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -1149,6 +1149,8 @@ pub struct TraitItem {\n     pub attrs: Vec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1168,6 +1170,8 @@ pub struct ImplItem {\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1812,6 +1816,15 @@ pub struct Item {\n     pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n+\n+    /// Original tokens this item was parsed from. This isn't necessarily\n+    /// available for all items, although over time more and more items should\n+    /// have this be `Some`. Right now this is primarily used for procedural\n+    /// macros, notably custom attributes.\n+    ///\n+    /// Note that the tokens here do not include the outer attributes, but will\n+    /// include inner attributes.\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "855f4cd3557008ad1dca7a0a8a6f2a24cb487922", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -236,6 +236,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             ),\n             vis: ast::Visibility::Public,\n             span: span,\n+            tokens: None,\n         })\n     ]))\n }"}, {"sha": "de0538e38b3ccaffcc194bec70c803149986f466", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -979,7 +979,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             vis: ast::Visibility::Inherited,\n-            span: span\n+            span: span,\n+            tokens: None,\n         })\n     }\n \n@@ -1147,7 +1148,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis: vis,\n-            span: sp\n+            span: sp,\n+            tokens: None,\n         })\n     }\n "}, {"sha": "16c264e0f941028e4cb59d636d58caed8500f09b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -214,6 +214,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             ident: keywords::Invalid.ident(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility::Public,\n+            tokens: None,\n         })));\n \n         match self.expand(krate_item).make_items().pop().map(P::unwrap) {"}, {"sha": "e3377c1d8deefa05b4428a528a349a03cc653e8a", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -46,15 +46,18 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n         ExpansionKind::Items => Expansion::Items(SmallVector::one(P(ast::Item {\n             id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n             node: ast::ItemKind::Mac(mac_placeholder()),\n+            tokens: None,\n         }))),\n         ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n             id: id, span: span, ident: ident, attrs: attrs,\n             node: ast::TraitItemKind::Macro(mac_placeholder()),\n+            tokens: None,\n         })),\n         ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n             id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n             node: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n+            tokens: None,\n         })),\n         ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n             id: id, span: span, node: ast::PatKind::Mac(mac_placeholder()),"}, {"sha": "279f63d13a4f47837c66eda820d708d3f57db109", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -957,7 +957,8 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n                 TraitItemKind::Macro(folder.fold_mac(mac))\n             }\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -980,7 +981,8 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n             ast::ImplItemKind::Type(ty) => ast::ImplItemKind::Type(folder.fold_ty(ty)),\n             ast::ImplItemKind::Macro(mac) => ast::ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -1000,6 +1002,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         vis: ast::Visibility::Public,\n         span: span,\n         node: ast::ItemKind::Mod(module),\n+        tokens: None,\n     })).into_iter();\n \n     let (module, attrs, span) = match items.next() {\n@@ -1032,15 +1035,19 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n }\n \n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span, tokens}: Item,\n                                         folder: &mut T) -> Item {\n     Item {\n         id: folder.new_id(id),\n         vis: folder.fold_vis(vis),\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: folder.fold_item_kind(node),\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n+\n+        // FIXME: if this is replaced with a call to `folder.fold_tts` it causes\n+        //        an ICE during resolve... odd!\n+        tokens: tokens,\n     }\n }\n "}, {"sha": "45e0b8404cc7e98e3d2f4ed11dd59c225f825cba", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -843,11 +843,18 @@ mod tests {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n-        assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n+        let item = string_to_item(\"fn a (b : i32) { b; }\".to_string()).map(|m| {\n+            m.map(|mut m| {\n+                m.tokens = None;\n+                m\n+            })\n+        });\n+        assert_eq!(item,\n                   Some(\n                       P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n+                            tokens: None,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n                                 inputs: vec![ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,"}, {"sha": "1a10aa9d621be0f31b26ae50ecff25e794d46fdc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 125, "deletions": 4, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -216,6 +216,30 @@ struct TokenCursorFrame {\n     open_delim: bool,\n     tree_cursor: tokenstream::Cursor,\n     close_delim: bool,\n+    last_token: LastToken,\n+}\n+\n+/// This is used in `TokenCursorFrame` above to track tokens that are consumed\n+/// by the parser, and then that's transitively used to record the tokens that\n+/// each parse AST item is created with.\n+///\n+/// Right now this has two states, either collecting tokens or not collecting\n+/// tokens. If we're collecting tokens we just save everything off into a local\n+/// `Vec`. This should eventually though likely save tokens from the original\n+/// token stream and just use slicing of token streams to avoid creation of a\n+/// whole new vector.\n+///\n+/// The second state is where we're passively not recording tokens, but the last\n+/// token is still tracked for when we want to start recording tokens. This\n+/// \"last token\" means that when we start recording tokens we'll want to ensure\n+/// that this, the first token, is included in the output.\n+///\n+/// You can find some more example usage of this in the `collect_tokens` method\n+/// on the parser.\n+#[derive(Clone)]\n+enum LastToken {\n+    Collecting(Vec<TokenTree>),\n+    Was(Option<TokenTree>),\n }\n \n impl TokenCursorFrame {\n@@ -226,6 +250,7 @@ impl TokenCursorFrame {\n             open_delim: delimited.delim == token::NoDelim,\n             tree_cursor: delimited.stream().into_trees(),\n             close_delim: delimited.delim == token::NoDelim,\n+            last_token: LastToken::Was(None),\n         }\n     }\n }\n@@ -250,6 +275,11 @@ impl TokenCursor {\n                 return TokenAndSpan { tok: token::Eof, sp: syntax_pos::DUMMY_SP }\n             };\n \n+            match self.frame.last_token {\n+                LastToken::Collecting(ref mut v) => v.push(tree.clone()),\n+                LastToken::Was(ref mut t) => *t = Some(tree.clone()),\n+            }\n+\n             match tree {\n                 TokenTree::Token(sp, tok) => return TokenAndSpan { tok: tok, sp: sp },\n                 TokenTree::Delimited(sp, ref delimited) => {\n@@ -1209,7 +1239,20 @@ impl<'a> Parser<'a> {\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n-        let mut attrs = self.parse_outer_attributes()?;\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_trait_item_(at_end, attrs)\n+        })?;\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_trait_item_(&mut self,\n+                         at_end: &mut bool,\n+                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n         let lo = self.span;\n \n         let (name, node) = if self.eat_keyword(keywords::Type) {\n@@ -1304,6 +1347,7 @@ impl<'a> Parser<'a> {\n             attrs: attrs,\n             node: node,\n             span: lo.to(self.prev_span),\n+            tokens: None,\n         })\n     }\n \n@@ -4653,6 +4697,7 @@ impl<'a> Parser<'a> {\n             node: node,\n             vis: vis,\n             span: span,\n+            tokens: None,\n         })\n     }\n \n@@ -4708,8 +4753,21 @@ impl<'a> Parser<'a> {\n     /// Parse an impl item.\n     pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n         maybe_whole!(self, NtImplItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_impl_item_(at_end, attrs)\n+        })?;\n+\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n \n-        let mut attrs = self.parse_outer_attributes()?;\n+    fn parse_impl_item_(&mut self,\n+                        at_end: &mut bool,\n+                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n         let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness()?;\n@@ -4741,7 +4799,8 @@ impl<'a> Parser<'a> {\n             vis: vis,\n             defaultness: defaultness,\n             attrs: attrs,\n-            node: node\n+            node: node,\n+            tokens: None,\n         })\n     }\n \n@@ -6017,9 +6076,71 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n+    fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n+        where F: FnOnce(&mut Self) -> PResult<'a, R>\n+    {\n+        // Record all tokens we parse when parsing this item.\n+        let mut tokens = Vec::new();\n+        match self.token_cursor.frame.last_token {\n+            LastToken::Collecting(_) => {\n+                panic!(\"cannot collect tokens recursively yet\")\n+            }\n+            LastToken::Was(ref mut last) => tokens.extend(last.take()),\n+        }\n+        self.token_cursor.frame.last_token = LastToken::Collecting(tokens);\n+        let prev = self.token_cursor.stack.len();\n+        let ret = f(self);\n+        let last_token = if self.token_cursor.stack.len() == prev {\n+            &mut self.token_cursor.frame.last_token\n+        } else {\n+            &mut self.token_cursor.stack[prev].last_token\n+        };\n+        let mut tokens = match *last_token {\n+            LastToken::Collecting(ref mut v) => mem::replace(v, Vec::new()),\n+            LastToken::Was(_) => panic!(\"our vector went away?\"),\n+        };\n+\n+        // If we're not at EOF our current token wasn't actually consumed by\n+        // `f`, but it'll still be in our list that we pulled out. In that case\n+        // put it back.\n+        if self.token == token::Eof {\n+            *last_token = LastToken::Was(None);\n+        } else {\n+            *last_token = LastToken::Was(tokens.pop());\n+        }\n+\n+        Ok((ret?, tokens.into_iter().collect()))\n+    }\n+\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n         let attrs = self.parse_outer_attributes()?;\n-        self.parse_item_(attrs, true, false)\n+\n+        let (ret, tokens) = self.collect_tokens(|this| {\n+            this.parse_item_(attrs, true, false)\n+        })?;\n+\n+        // Once we've parsed an item and recorded the tokens we got while\n+        // parsing we may want to store `tokens` into the item we're about to\n+        // return. Note, though, that we specifically didn't capture tokens\n+        // related to outer attributes. The `tokens` field here may later be\n+        // used with procedural macros to convert this item back into a token\n+        // stream, but during expansion we may be removing attributes as we go\n+        // along.\n+        //\n+        // If we've got inner attributes then the `tokens` we've got above holds\n+        // these inner attributes. If an inner attribute is expanded we won't\n+        // actually remove it from the token stream, so we'll just keep yielding\n+        // it (bad!). To work around this case for now we just avoid recording\n+        // `tokens` if we detect any inner attributes. This should help keep\n+        // expansion correct, but we should fix this bug one day!\n+        Ok(ret.map(|item| {\n+            item.map(|mut i| {\n+                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    i.tokens = Some(tokens);\n+                }\n+                i\n+            })\n+        }))\n     }\n \n     fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {"}, {"sha": "d9ed96f293a80625b958153899bb9c2147b7a364", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -60,6 +60,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n+        tokens: None,\n     }));\n \n     let span = ignored_span(DUMMY_SP);\n@@ -82,6 +83,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         id: ast::DUMMY_NODE_ID,\n         ident: keywords::Invalid.ident(),\n         span: span,\n+        tokens: None,\n     }));\n \n     krate"}, {"sha": "887479a24724989263ed43b21a98b775c334852b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -192,7 +192,7 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n-                folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n+                folded.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n                     let allow_str = Symbol::intern(\"allow\");\n                     let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n@@ -212,7 +212,8 @@ impl fold::Folder for EntryPointCleaner {\n                             .collect(),\n                         node: node,\n                         vis: vis,\n-                        span: span\n+                        span: span,\n+                        tokens: tokens,\n                     }\n                 }),\n             EntryPointType::None |\n@@ -255,6 +256,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n+        tokens: None,\n     })).pop().unwrap();\n \n     (it, sym)\n@@ -465,7 +467,8 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         node: vi,\n         attrs: vec![],\n         vis: vis,\n-        span: sp\n+        span: sp,\n+        tokens: None,\n     })\n }\n \n@@ -506,7 +509,8 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: ast::Visibility::Public,\n-        span: sp\n+        span: sp,\n+        tokens: None,\n     })\n }\n \n@@ -536,6 +540,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         node: item_,\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n+        tokens: None,\n     })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.map(|s| {\n         // building `use <ident> = __test::main`\n@@ -551,7 +556,8 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n-            span: DUMMY_SP\n+            span: DUMMY_SP,\n+            tokens: None,\n         })).pop().unwrap()\n     });\n "}, {"sha": "3cbc7938bde0c0a46362f679d205d19cf47f5f9d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -504,6 +504,7 @@ impl<'a> TraitDef<'a> {\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 node: ast::ImplItemKind::Type(type_def.to_ty(cx, self.span, type_ident, generics)),\n+                tokens: None,\n             }\n         });\n \n@@ -930,6 +931,7 @@ impl<'a> MethodDef<'a> {\n                                                 decl: fn_decl,\n                                             },\n                                             body_block),\n+            tokens: None,\n         }\n     }\n "}, {"sha": "8b0bb8cb891ee5267bf1a3a39a5089d475f0adfc", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -61,5 +61,6 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })),\n         vis: ast::Visibility::Inherited,\n         span: sp,\n+        tokens: None,\n     })))\n }"}, {"sha": "65f4b6350c4eed4f578d9d78bc61949360b66a4f", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute-with-error.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attribute-with-error.rs\n+\n+#![feature(proc_macro)]\n+\n+extern crate attribute_with_error;\n+\n+use attribute_with_error::foo;\n+\n+#[foo]\n+fn test1() {\n+    let a: i32 = \"foo\";\n+    //~^ ERROR: mismatched types\n+}\n+\n+fn test2() {\n+    #![foo]\n+\n+    // FIXME: should have a type error here and assert it works but it doesn't\n+}\n+\n+trait A {\n+    // FIXME: should have a #[foo] attribute here and assert that it works\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+struct B;\n+\n+impl A for B {\n+    #[foo]\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+#[foo]\n+fn main() {\n+}"}, {"sha": "508f8dac5711939f75f13bfbac6b1b0645378eba", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attributes-included.rs\n+\n+#![feature(proc_macro, rustc_attrs)]\n+\n+extern crate attributes_included;\n+\n+#[attributes_included::bar]\n+#[inline]\n+/// doc\n+#[attributes_included::foo]\n+#[inline]\n+/// doc\n+fn foo() {\n+    let a: i32 = \"foo\"; //~ WARN: unused variable\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    foo()\n+}"}, {"sha": "85a7a0bf6336f30a6d3b169d5284069d903bd178", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attribute-with-error.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn foo(_attr: TokenStream, input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}"}, {"sha": "a1efbb88a4d2e26dc1e9c1ef274452a259e9cb59", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126321e2e505ea07887134ffe63afc759a8b7e9f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=126321e2e505ea07887134ffe63afc759a8b7e9f", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, TokenNode, Delimiter, Literal};\n+\n+#[proc_macro_attribute]\n+pub fn foo(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    fold_stream(input.into_iter().collect())\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_invoc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    input.into_iter().collect()\n+}\n+\n+fn assert_inline(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_doc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Literal(_) => {}\n+        _ => panic!(\"expected literal doc comment got other\"),\n+    }\n+    *slice = &slice[1..];\n+}\n+\n+fn assert_invoc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_foo(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"fn\"),\n+        _ => panic!(\"expected fn\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"foo\"),\n+        _ => panic!(\"expected foo\"),\n+    }\n+    match slice[2].kind {\n+        TokenNode::Group(Delimiter::Parenthesis, ref s) => assert!(s.is_empty()),\n+        _ => panic!(\"expected parens\"),\n+    }\n+    match slice[3].kind {\n+        TokenNode::Group(Delimiter::Brace, _) => {}\n+        _ => panic!(\"expected braces\"),\n+    }\n+    *slice = &slice[4..];\n+}\n+\n+fn fold_stream(input: TokenStream) -> TokenStream {\n+    input.into_iter().map(fold_tree).collect()\n+}\n+\n+fn fold_tree(input: TokenTree) -> TokenTree {\n+    TokenTree {\n+        span: input.span,\n+        kind: fold_node(input.kind),\n+    }\n+}\n+\n+fn fold_node(input: TokenNode) -> TokenNode {\n+    match input {\n+        TokenNode::Group(a, b) => TokenNode::Group(a, fold_stream(b)),\n+        TokenNode::Op(a, b) => TokenNode::Op(a, b),\n+        TokenNode::Term(a) => TokenNode::Term(a),\n+        TokenNode::Literal(a) => {\n+            if a.to_string() != \"\\\"foo\\\"\" {\n+                TokenNode::Literal(a)\n+            } else {\n+                TokenNode::Literal(Literal::integer(3))\n+            }\n+        }\n+    }\n+}"}]}