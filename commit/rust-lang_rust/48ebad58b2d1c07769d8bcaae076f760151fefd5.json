{"sha": "48ebad58b2d1c07769d8bcaae076f760151fefd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZWJhZDU4YjJkMWMwNzc2OWQ4YmNhYWUwNzZmNzYwMTUxZmVmZDU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-02T17:57:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-02T17:57:28Z"}, "message": "Rollup merge of #83065 - CDirkx:win-alloc, r=dtolnay\n\nRework `std::sys::windows::alloc`\n\nI came across https://github.com/rust-lang/rust/pull/76676#discussion_r488729990, which points out that there was unsound code in the Windows alloc code, creating a &mut to possibly uninitialized memory. I reworked the code so that that particular issue does not occur anymore, and started adding more documentation and safety comments.\n\nFull list of changes:\n - moved and documented the relevant Windows Heap API functions\n - refactor `allocate_with_flags` to `allocate` (and remove the other helper functions), which now takes just a `bool` if the memory should be zeroed\n - add checks for if `GetProcessHeap` returned null\n - add a test that checks if the size and alignment of a `Header` are indeed <= `MIN_ALIGN`\n - add `#![deny(unsafe_op_in_unsafe_fn)]` and the necessary unsafe blocks with safety comments\n\nI feel like I may have overdone the documenting, the unsoundness fix is the most important part; I could spit this PR up in separate parts.", "tree": {"sha": "1781e065ec5caf7fb79486e5956665350f402d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1781e065ec5caf7fb79486e5956665350f402d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ebad58b2d1c07769d8bcaae076f760151fefd5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgZ1sJCRBK7hj4Ov3rIwAAdHIIAIWlSBIXUzrZC97LuPrvyax1\n2YNRbO4qo/xkkQS09OxwyBnr1K3Zeub2AwiFU3o45C0PRpns7aR2MPlsKwKXRaDw\nTs/sDauhDAqIB60bXeM/BtEL7RnGLT85M/aVfACyRNk25xg0WX0xHArCm1tbTQI3\nDoiprLriKMc1KYt6pcJw88qfJuUgKeKYjabl5ty1ghVZ14cxZH4Z/HVNXTr84g6j\nWPtLXwgOmXDBUxY/GJ0T/OQecFjnG6KNIkRjAw7EUeYFND7aPHVHkSzSICsWUPDg\nRnnxDN5Oew95/K4WEO3qgWdlQxbf+JXu4hS4o32OxDc8CrBd/diaHvf7IJipIug=\n=W4M2\n-----END PGP SIGNATURE-----\n", "payload": "tree 1781e065ec5caf7fb79486e5956665350f402d6c\nparent 36bcf4069717b9dff90270d13b53a3b130329960\nparent db1d003de1657e31174fac2bfa016000294ea266\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617386248 +0200\ncommitter GitHub <noreply@github.com> 1617386248 +0200\n\nRollup merge of #83065 - CDirkx:win-alloc, r=dtolnay\n\nRework `std::sys::windows::alloc`\n\nI came across https://github.com/rust-lang/rust/pull/76676#discussion_r488729990, which points out that there was unsound code in the Windows alloc code, creating a &mut to possibly uninitialized memory. I reworked the code so that that particular issue does not occur anymore, and started adding more documentation and safety comments.\n\nFull list of changes:\n - moved and documented the relevant Windows Heap API functions\n - refactor `allocate_with_flags` to `allocate` (and remove the other helper functions), which now takes just a `bool` if the memory should be zeroed\n - add checks for if `GetProcessHeap` returned null\n - add a test that checks if the size and alignment of a `Header` are indeed <= `MIN_ALIGN`\n - add `#![deny(unsafe_op_in_unsafe_fn)]` and the necessary unsafe blocks with safety comments\n\nI feel like I may have overdone the documenting, the unsoundness fix is the most important part; I could spit this PR up in separate parts.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ebad58b2d1c07769d8bcaae076f760151fefd5", "html_url": "https://github.com/rust-lang/rust/commit/48ebad58b2d1c07769d8bcaae076f760151fefd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ebad58b2d1c07769d8bcaae076f760151fefd5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36bcf4069717b9dff90270d13b53a3b130329960", "url": "https://api.github.com/repos/rust-lang/rust/commits/36bcf4069717b9dff90270d13b53a3b130329960", "html_url": "https://github.com/rust-lang/rust/commit/36bcf4069717b9dff90270d13b53a3b130329960"}, {"sha": "db1d003de1657e31174fac2bfa016000294ea266", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1d003de1657e31174fac2bfa016000294ea266", "html_url": "https://github.com/rust-lang/rust/commit/db1d003de1657e31174fac2bfa016000294ea266"}], "stats": {"total": 253, "additions": 220, "deletions": 33}, "files": [{"sha": "af93cd7a3e27d43f53d52db60136f2ac87a0126e", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 211, "deletions": 26, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=48ebad58b2d1c07769d8bcaae076f760151fefd5", "patch": "@@ -1,61 +1,246 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ffi::c_void;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering};\n use crate::sys::c;\n use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n-#[repr(C)]\n-struct Header(*mut u8);\n+#[cfg(test)]\n+mod tests;\n+\n+// Heap memory management on Windows is done by using the system Heap API (heapapi.h)\n+// See https://docs.microsoft.com/windows/win32/api/heapapi/\n+\n+// Flag to indicate that the memory returned by `HeapAlloc` should be zeroed.\n+const HEAP_ZERO_MEMORY: c::DWORD = 0x00000008;\n \n-unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-    &mut *(ptr as *mut Header).offset(-1)\n+extern \"system\" {\n+    // Get a handle to the default heap of the current process, or null if the operation fails.\n+    //\n+    // SAFETY: Successful calls to this function within the same process are assumed to\n+    // always return the same handle, which remains valid for the entire lifetime of the process.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-getprocessheap\n+    fn GetProcessHeap() -> c::HANDLE;\n+\n+    // Allocate a block of `dwBytes` bytes of memory from a given heap `hHeap`.\n+    // The allocated memory may be uninitialized, or zeroed if `dwFlags` is\n+    // set to `HEAP_ZERO_MEMORY`.\n+    //\n+    // Returns a pointer to the newly-allocated memory or null if the operation fails.\n+    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n+    //\n+    // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n+    //  - `dwFlags` must be set to either zero or `HEAP_ZERO_MEMORY`.\n+    //\n+    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapalloc\n+    fn HeapAlloc(hHeap: c::HANDLE, dwFlags: c::DWORD, dwBytes: c::SIZE_T) -> c::LPVOID;\n+\n+    // Reallocate a block of memory behind a given pointer `lpMem` from a given heap `hHeap`,\n+    // to a block of at least `dwBytes` bytes, either shrinking the block in place,\n+    // or allocating at a new location, copying memory, and freeing the original location.\n+    //\n+    // Returns a pointer to the reallocated memory or null if the operation fails.\n+    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n+    // If the operation fails the given block will never have been freed.\n+    //\n+    // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n+    //  - `dwFlags` must be set to zero.\n+    //  - `lpMem` must be a non-null pointer to an allocated block returned by `HeapAlloc` or\n+    //     `HeapReAlloc`, that has not already been freed.\n+    // If the block was successfully reallocated at a new location, pointers pointing to\n+    // the freed memory, such as `lpMem`, must not be dereferenced ever again.\n+    //\n+    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heaprealloc\n+    fn HeapReAlloc(\n+        hHeap: c::HANDLE,\n+        dwFlags: c::DWORD,\n+        lpMem: c::LPVOID,\n+        dwBytes: c::SIZE_T,\n+    ) -> c::LPVOID;\n+\n+    // Free a block of memory behind a given pointer `lpMem` from a given heap `hHeap`.\n+    // Returns a nonzero value if the operation is successful, and zero if the operation fails.\n+    //\n+    // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n+    //  - `dwFlags` must be set to zero.\n+    //  - `lpMem` must be a pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`,\n+    //     that has not already been freed.\n+    // If the block was successfully freed, pointers pointing to the freed memory, such as `lpMem`,\n+    // must not be dereferenced ever again.\n+    //\n+    // Note that `lpMem` is allowed to be null, which will not cause the operation to fail.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapfree\n+    fn HeapFree(hHeap: c::HANDLE, dwFlags: c::DWORD, lpMem: c::LPVOID) -> c::BOOL;\n }\n \n-unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-    let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n-    *get_header(aligned) = Header(ptr);\n-    aligned\n+// Cached handle to the default heap of the current process.\n+// Either a non-null handle returned by `GetProcessHeap`, or null when not yet initialized or `GetProcessHeap` failed.\n+static HEAP: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+// Get a handle to the default heap of the current process, or null if the operation fails.\n+// If this operation is successful, `HEAP` will be successfully initialized and contain\n+// a non-null handle returned by `GetProcessHeap`.\n+#[inline]\n+fn init_or_get_process_heap() -> c::HANDLE {\n+    let heap = HEAP.load(Ordering::Relaxed);\n+    if heap.is_null() {\n+        // `HEAP` has not yet been successfully initialized\n+        let heap = unsafe { GetProcessHeap() };\n+        if !heap.is_null() {\n+            // SAFETY: No locking is needed because within the same process,\n+            // successful calls to `GetProcessHeap` will always return the same value, even on different threads.\n+            HEAP.store(heap, Ordering::Release);\n+\n+            // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n+            heap\n+        } else {\n+            // Could not get the current process heap.\n+            ptr::null_mut()\n+        }\n+    } else {\n+        // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n+        heap\n+    }\n }\n \n+// Get a non-null handle to the default heap of the current process.\n+// SAFETY: `HEAP` must have been successfully initialized.\n #[inline]\n-unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n-    if layout.align() <= MIN_ALIGN {\n-        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8;\n+unsafe fn get_process_heap() -> c::HANDLE {\n+    HEAP.load(Ordering::Acquire)\n+}\n+\n+// Header containing a pointer to the start of an allocated block.\n+// SAFETY: Size and alignment must be <= `MIN_ALIGN`.\n+#[repr(C)]\n+struct Header(*mut u8);\n+\n+// Allocate a block of optionally zeroed memory for a given `layout`.\n+// SAFETY: Returns a pointer satisfying the guarantees of `System` about allocated pointers,\n+// or null if the operation fails. If this returns non-null `HEAP` will have been successfully\n+// initialized.\n+#[inline]\n+unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n+    let heap = init_or_get_process_heap();\n+    if heap.is_null() {\n+        // Allocation has failed, could not get the current process heap.\n+        return ptr::null_mut();\n     }\n \n-    let size = layout.size() + layout.align();\n-    let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n-    if ptr.is_null() { ptr as *mut u8 } else { align_ptr(ptr as *mut u8, layout.align()) }\n+    // Allocated memory will be either zeroed or uninitialized.\n+    let flags = if zeroed { HEAP_ZERO_MEMORY } else { 0 };\n+\n+    if layout.align() <= MIN_ALIGN {\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n+        // The returned pointer points to the start of an allocated block.\n+        unsafe { HeapAlloc(heap, flags, layout.size()) as *mut u8 }\n+    } else {\n+        // Allocate extra padding in order to be able to satisfy the alignment.\n+        let total = layout.align() + layout.size();\n+\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n+        let ptr = unsafe { HeapAlloc(heap, flags, total) as *mut u8 };\n+        if ptr.is_null() {\n+            // Allocation has failed.\n+            return ptr::null_mut();\n+        }\n+\n+        // Create a correctly aligned pointer offset from the start of the allocated block,\n+        // and write a header before it.\n+\n+        let offset = layout.align() - (ptr as usize & (layout.align() - 1));\n+        // SAFETY: `MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated\n+        // block is `layout.align() + layout.size()`. `aligned` will thus be a correctly aligned\n+        // pointer inside the allocated block with at least `layout.size()` bytes after it and at\n+        // least `MIN_ALIGN` bytes of padding before it.\n+        let aligned = unsafe { ptr.add(offset) };\n+        // SAFETY: Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned`\n+        // is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before\n+        // it, it is safe to write a header directly before it.\n+        unsafe { ptr::write((aligned as *mut Header).offset(-1), Header(ptr)) };\n+\n+        // SAFETY: The returned pointer does not point to the to the start of an allocated block,\n+        // but there is a header readable directly before it containing the location of the start\n+        // of the block.\n+        aligned\n+    }\n }\n \n+// All pointers returned by this allocator have, in addition to the guarantees of `GlobalAlloc`, the\n+// following properties:\n+//\n+// If the pointer was allocated or reallocated with a `layout` specifying an alignment <= `MIN_ALIGN`\n+// the pointer will be aligned to at least `MIN_ALIGN` and point to the start of the allocated block.\n+//\n+// If the pointer was allocated or reallocated with a `layout` specifying an alignment > `MIN_ALIGN`\n+// the pointer will be aligned to the specified alignment and not point to the start of the allocated block.\n+// Instead there will be a header readable directly before the returned pointer, containing the actual\n+// location of the start of the block.\n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        allocate_with_flags(layout, 0)\n+        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n+        let zeroed = false;\n+        unsafe { allocate(layout, zeroed) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        allocate_with_flags(layout, c::HEAP_ZERO_MEMORY)\n+        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n+        let zeroed = true;\n+        unsafe { allocate(layout, zeroed) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        if layout.align() <= MIN_ALIGN {\n-            let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n-        } else {\n-            let header = get_header(ptr);\n-            let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n-        }\n+        let block = {\n+            if layout.align() <= MIN_ALIGN {\n+                ptr\n+            } else {\n+                // The location of the start of the block is stored in the padding before `ptr`.\n+\n+                // SAFETY: Because of the contract of `System`, `ptr` is guaranteed to be non-null\n+                // and have a header readable directly before it.\n+                unsafe { ptr::read((ptr as *mut Header).offset(-1)).0 }\n+            }\n+        };\n+\n+        // SAFETY: because `ptr` has been successfully allocated with this allocator,\n+        // `HEAP` must have been successfully initialized.\n+        let heap = unsafe { get_process_heap() };\n+\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n+        // `block` is a pointer to the start of an allocated block.\n+        unsafe { HeapFree(heap, 0, block as c::LPVOID) };\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         if layout.align() <= MIN_ALIGN {\n-            c::HeapReAlloc(c::GetProcessHeap(), 0, ptr as c::LPVOID, new_size) as *mut u8\n+            // SAFETY: because `ptr` has been successfully allocated with this allocator,\n+            // `HEAP` must have been successfully initialized.\n+            let heap = unsafe { get_process_heap() };\n+\n+            // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n+            // `ptr` is a pointer to the start of an allocated block.\n+            // The returned pointer points to the start of an allocated block.\n+            unsafe { HeapReAlloc(heap, 0, ptr as c::LPVOID, new_size) as *mut u8 }\n         } else {\n-            realloc_fallback(self, ptr, layout, new_size)\n+            // SAFETY: `realloc_fallback` is implemented using `dealloc` and `alloc`, which will\n+            // correctly handle `ptr` and return a pointer satisfying the guarantees of `System`\n+            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n         }\n     }\n }"}, {"sha": "674a3e1d92d175443147e8d223d7c4d57e4e2bd3", "filename": "library/std/src/sys/windows/alloc/tests.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs?ref=48ebad58b2d1c07769d8bcaae076f760151fefd5", "patch": "@@ -0,0 +1,9 @@\n+use super::{Header, MIN_ALIGN};\n+use crate::mem;\n+\n+#[test]\n+fn alloc_header() {\n+    // Header must fit in the padding before an aligned pointer\n+    assert!(mem::size_of::<Header>() <= MIN_ALIGN);\n+    assert!(mem::align_of::<Header>() <= MIN_ALIGN);\n+}"}, {"sha": "3e4176ef7f8fec9b5956c6350a9a8ae04e45201f", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ebad58b2d1c07769d8bcaae076f760151fefd5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=48ebad58b2d1c07769d8bcaae076f760151fefd5", "patch": "@@ -285,8 +285,6 @@ pub const FD_SETSIZE: usize = 64;\n \n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n-pub const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-\n pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n \n #[repr(C)]\n@@ -1017,11 +1015,6 @@ extern \"system\" {\n         timeout: *const timeval,\n     ) -> c_int;\n \n-    pub fn GetProcessHeap() -> HANDLE;\n-    pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-    pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-    pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-\n     // >= Vista / Server 2008\n     // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinkw\n     pub fn CreateSymbolicLinkW("}]}