{"sha": "74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "node_id": "C_kwDOAAsO6NoAKDc0YzQ4MjEwNDVjNjhkNDJiYjhiOGE3Yzk5OGJkYjVjMmE3MmJkMGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-04T20:49:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-04T20:49:23Z"}, "message": "Auto merge of #111014 - klensy:no-rc, r=WaffleLapkin\n\ntry to downgrade Arc -> Lrc -> Rc -> no-Rc in few places\n\nExpecting this be not slower on non-parallel compiler and probably faster on parallel (checked that this PR builds on it).", "tree": {"sha": "ba442cf2a77a47739ffe3278df8f55dbd681d6dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba442cf2a77a47739ffe3278df8f55dbd681d6dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "html_url": "https://github.com/rust-lang/rust/commit/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb7a7434215dd9d4b7cc18746ad1d0e531c25325", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7a7434215dd9d4b7cc18746ad1d0e531c25325", "html_url": "https://github.com/rust-lang/rust/commit/eb7a7434215dd9d4b7cc18746ad1d0e531c25325"}, {"sha": "07266362c6b29139dc09ecd4b963722690eaa31f", "url": "https://api.github.com/repos/rust-lang/rust/commits/07266362c6b29139dc09ecd4b963722690eaa31f", "html_url": "https://github.com/rust-lang/rust/commit/07266362c6b29139dc09ecd4b963722690eaa31f"}], "stats": {"total": 52, "additions": 24, "deletions": 28}, "files": [{"sha": "8fbe814c85607f4a727cd32d4ecee0016ca9450d", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "patch": "@@ -76,7 +76,7 @@ pub struct RegionInferenceContext<'tcx> {\n     /// Reverse of the SCC constraint graph --  i.e., an edge `A -> B` exists if\n     /// `B: A`. This is used to compute the universal regions that are required\n     /// to outlive a given SCC. Computed lazily.\n-    rev_scc_graph: Option<Rc<ReverseSccGraph>>,\n+    rev_scc_graph: Option<ReverseSccGraph>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n     member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n@@ -813,9 +813,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // free region that must outlive the member region `R0` (`UB:\n         // R0`). Therefore, we need only keep an option `O` if `UB: O`\n         // for all UB.\n-        let rev_scc_graph = self.reverse_scc_graph();\n+        self.compute_reverse_scc_graph();\n         let universal_region_relations = &self.universal_region_relations;\n-        for ub in rev_scc_graph.upper_bounds(scc) {\n+        for ub in self.rev_scc_graph.as_ref().unwrap().upper_bounds(scc) {\n             debug!(?ub);\n             choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n         }"}, {"sha": "fe56bd54a3f17450209691fef5c5b28f81115832", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "patch": "@@ -8,7 +8,6 @@ use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::graph::WithSuccessors;\n use rustc_middle::ty::RegionVid;\n use std::ops::Range;\n-use std::rc::Rc;\n \n pub(crate) struct ReverseSccGraph {\n     graph: VecGraph<ConstraintSccIndex>,\n@@ -40,10 +39,10 @@ impl ReverseSccGraph {\n }\n \n impl RegionInferenceContext<'_> {\n-    /// Compute and return the reverse SCC-based constraint graph (lazily).\n-    pub(super) fn reverse_scc_graph(&mut self) -> Rc<ReverseSccGraph> {\n-        if let Some(g) = &self.rev_scc_graph {\n-            return g.clone();\n+    /// Compute the reverse SCC-based constraint graph (lazily).\n+    pub(super) fn compute_reverse_scc_graph(&mut self) {\n+        if self.rev_scc_graph.is_some() {\n+            return;\n         }\n \n         let graph = self.constraint_sccs.reverse();\n@@ -63,8 +62,6 @@ impl RegionInferenceContext<'_> {\n             start += group_size;\n         }\n \n-        let rev_graph = Rc::new(ReverseSccGraph { graph, scc_regions, universal_regions });\n-        self.rev_scc_graph = Some(rev_graph.clone());\n-        rev_graph\n+        self.rev_scc_graph = Some(ReverseSccGraph { graph, scc_regions, universal_regions });\n     }\n }"}, {"sha": "1c222fb4a898c8761fee20a0769b78a09e4fe532", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "patch": "@@ -88,6 +88,7 @@ use rustc_span::Span;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::fmt::Display;\n+use std::rc::Rc;\n \n /// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)\n /// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.\n@@ -257,10 +258,10 @@ struct MatcherPos {\n     /// against the relevant metavar by the black box parser. An element will be a `MatchedSeq` if\n     /// the corresponding metavar decl is within a sequence.\n     ///\n-    /// It is critical to performance that this is an `Lrc`, because it gets cloned frequently when\n+    /// It is critical to performance that this is an `Rc`, because it gets cloned frequently when\n     /// processing sequences. Mostly for sequence-ending possibilities that must be tried but end\n     /// up failing.\n-    matches: Lrc<Vec<NamedMatch>>,\n+    matches: Rc<Vec<NamedMatch>>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -272,7 +273,7 @@ impl MatcherPos {\n     /// and both are hot enough to be always worth inlining.\n     #[inline(always)]\n     fn push_match(&mut self, metavar_idx: usize, seq_depth: usize, m: NamedMatch) {\n-        let matches = Lrc::make_mut(&mut self.matches);\n+        let matches = Rc::make_mut(&mut self.matches);\n         match seq_depth {\n             0 => {\n                 // We are not within a sequence. Just append `m`.\n@@ -427,7 +428,7 @@ pub struct TtParser {\n \n     /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules\n     /// that have no metavars.\n-    empty_matches: Lrc<Vec<NamedMatch>>,\n+    empty_matches: Rc<Vec<NamedMatch>>,\n }\n \n impl TtParser {\n@@ -437,7 +438,7 @@ impl TtParser {\n             cur_mps: vec![],\n             next_mps: vec![],\n             bb_mps: vec![],\n-            empty_matches: Lrc::new(vec![]),\n+            empty_matches: Rc::new(vec![]),\n         }\n     }\n \n@@ -507,7 +508,7 @@ impl TtParser {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,\n-                            matches: Lrc::clone(&mp.matches),\n+                            matches: Rc::clone(&mp.matches),\n                         });\n                     }\n \n@@ -521,7 +522,7 @@ impl TtParser {\n                     // processed next time around the loop.\n                     let ending_mp = MatcherPos {\n                         idx: mp.idx + 1, // +1 skips the Kleene op\n-                        matches: Lrc::clone(&mp.matches),\n+                        matches: Rc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -537,7 +538,7 @@ impl TtParser {\n                     // will fail quietly when it is processed next time around the loop.\n                     let ending_mp = MatcherPos {\n                         idx: mp.idx + 2, // +2 skips the separator and the Kleene op\n-                        matches: Lrc::clone(&mp.matches),\n+                        matches: Rc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -587,9 +588,9 @@ impl TtParser {\n         if *token == token::Eof {\n             Some(match eof_mps {\n                 EofMatcherPositions::One(mut eof_mp) => {\n-                    // Need to take ownership of the matches from within the `Lrc`.\n-                    Lrc::make_mut(&mut eof_mp.matches);\n-                    let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n+                    // Need to take ownership of the matches from within the `Rc`.\n+                    Rc::make_mut(&mut eof_mp.matches);\n+                    let matches = Rc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n                     self.nameize(matcher, matches)\n                 }\n                 EofMatcherPositions::Multiple => {"}, {"sha": "72371b9950bfb9337163dd0681171c9bacfa97a2", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "patch": "@@ -2,15 +2,14 @@\n \n use hir::CRATE_HIR_ID;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n use rustc_expand::base::resolve_path;\n use rustc_hir as hir;\n use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_middle::{query::LocalCrate, ty::query::Providers};\n use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n-use std::sync::Arc;\n-\n use crate::errors::DebugVisualizerUnreadable;\n \n fn check_for_debugger_visualizer(\n@@ -52,7 +51,7 @@ fn check_for_debugger_visualizer(\n             match std::fs::read(&file) {\n                 Ok(contents) => {\n                     debugger_visualizers\n-                        .insert(DebuggerVisualizerFile::new(Arc::from(contents), visualizer_type));\n+                        .insert(DebuggerVisualizerFile::new(Lrc::from(contents), visualizer_type));\n                 }\n                 Err(error) => {\n                     tcx.sess.emit_err(DebugVisualizerUnreadable {"}, {"sha": "341cc61fd1c10b557b517a0edb3ffd930534e528", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "patch": "@@ -69,7 +69,6 @@ use std::hash::Hash;\n use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n-use std::sync::Arc;\n \n use md5::Digest;\n use md5::Md5;\n@@ -1269,13 +1268,13 @@ pub enum DebuggerVisualizerType {\n #[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable)]\n pub struct DebuggerVisualizerFile {\n     /// The complete debugger visualizer source.\n-    pub src: Arc<[u8]>,\n+    pub src: Lrc<[u8]>,\n     /// Indicates which visualizer type this targets.\n     pub visualizer_type: DebuggerVisualizerType,\n }\n \n impl DebuggerVisualizerFile {\n-    pub fn new(src: Arc<[u8]>, visualizer_type: DebuggerVisualizerType) -> Self {\n+    pub fn new(src: Lrc<[u8]>, visualizer_type: DebuggerVisualizerType) -> Self {\n         DebuggerVisualizerFile { src, visualizer_type }\n     }\n }"}]}