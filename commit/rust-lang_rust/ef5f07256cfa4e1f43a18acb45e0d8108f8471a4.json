{"sha": "ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "node_id": "C_kwDOAAsO6NoAKGVmNWYwNzI1NmNmYTRlMWY0M2ExOGFjYjQ1ZTBkODEwOGY4NDcxYTQ", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-27T09:11:54Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-27T14:58:16Z"}, "message": "combine all unsized types and add another recursive call to process nested unsized types correctly", "tree": {"sha": "77dc397dc295ff6cd5ddecb5a5bddcbf3ab1ed4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77dc397dc295ff6cd5ddecb5a5bddcbf3ab1ed4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "html_url": "https://github.com/rust-lang/rust/commit/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfefb4d74cbd1520afaa97db1eba59c06283c696", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfefb4d74cbd1520afaa97db1eba59c06283c696", "html_url": "https://github.com/rust-lang/rust/commit/bfefb4d74cbd1520afaa97db1eba59c06283c696"}], "stats": {"total": 176, "additions": 79, "deletions": 97}, "files": [{"sha": "38fecf7232ebc704436755d752b000401df2afbb", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "patch": "@@ -1,4 +1,4 @@\n-use super::{const_to_valtree, CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n@@ -219,13 +219,6 @@ fn turn_into_const_value<'tcx>(\n     let const_val = op_to_const(&ecx, &mplace.into());\n     debug!(?const_val);\n \n-    if cfg!(debug_assertions) {\n-        if let Some(valtree) = const_to_valtree(tcx, key.param_env, constant) {\n-            let const_val = tcx.valtree_to_const_val((constant.ty, valtree));\n-            debug!(?const_val);\n-        }\n-    }\n-\n     const_val\n }\n "}, {"sha": "374179d0cc24da0f7f230518ade0909d178674e4", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 77, "deletions": 88, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "patch": "@@ -194,55 +194,48 @@ fn create_pointee_place<'tcx>(\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx.tcx;\n \n-    match ty.kind() {\n-        ty::Slice(_) | ty::Str => {\n-            let slice_ty = match ty.kind() {\n-                ty::Slice(slice_ty) => *slice_ty,\n-                ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n-                _ => bug!(\"expected ty::Slice | ty::Str\"),\n-            };\n-\n-            // Create a place for the underlying array\n-            let len = valtree.unwrap_branch().len() as u64;\n-            let arr_ty = tcx.mk_array(slice_ty, len as u64);\n-            let place = create_mplace_from_layout(ecx, arr_ty);\n-            debug!(?place);\n+    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+        // We need to create `Allocation`s for custom DSTs\n+\n+        let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n+        let unsized_inner_ty = match unsized_inner_ty.kind() {\n+            ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+            _ => unsized_inner_ty,\n+        };\n+        let unsized_inner_ty_size =\n+            tcx.layout_of(ty::ParamEnv::empty().and(unsized_inner_ty)).unwrap().layout.size();\n+        debug!(?unsized_inner_ty, ?unsized_inner_ty_size, ?num_elems);\n+\n+        // for custom DSTs only the last field/element is unsized, but we need to also allocate\n+        // space for the other fields/elements\n+        let layout = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap();\n+        let size_of_sized_part = layout.layout.size();\n+\n+        // Get the size of the memory behind the DST\n+        let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n+\n+        let ptr = ecx\n+            .allocate_ptr(\n+                size_of_sized_part.checked_add(dst_size, &tcx).unwrap(),\n+                Align::from_bytes(1).unwrap(),\n+                MemoryKind::Stack,\n+            )\n+            .unwrap();\n+        debug!(?ptr);\n \n-            place\n-        }\n-        ty::Adt(_, _) if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) => {\n-            // We need to create `Allocation`s for custom DSTs\n-\n-            let layout = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap();\n-            let sized_fields_size = layout.layout.size();\n-            let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n-            let unsized_inner_ty_size =\n-                tcx.layout_of(ty::ParamEnv::empty().and(unsized_inner_ty)).unwrap().layout.size();\n-            debug!(?unsized_inner_ty, ?unsized_inner_ty_size, ?num_elems);\n-\n-            // Get the size of the array behind the DST\n-            let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n-\n-            let ptr = ecx\n-                .allocate_ptr(\n-                    sized_fields_size.checked_add(dst_size, &tcx).unwrap(),\n-                    Align::from_bytes(1).unwrap(),\n-                    MemoryKind::Stack,\n-                )\n-                .unwrap();\n-            debug!(?ptr);\n-\n-            let place = MPlaceTy::from_aligned_ptr(ptr.into(), layout);\n-            debug!(?place);\n+        let mut place = MPlaceTy::from_aligned_ptr(ptr.into(), layout);\n+        place.meta = MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64));\n+        debug!(?place);\n \n-            place\n-        }\n-        _ => create_mplace_from_layout(ecx, ty),\n+        place\n+    } else {\n+        create_mplace_from_layout(ecx, ty)\n     }\n }\n \n /// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n /// construction has finished.\n+// FIXME Merge `valtree_to_const_value` and `fill_place_recursively` into one function\n #[instrument(skip(tcx), level = \"debug\")]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -374,12 +367,9 @@ fn fill_place_recursively<'tcx>(\n \n             ecx.write_immediate(imm, &(*place).into()).unwrap();\n         }\n-        ty::Adt(_, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Str => {\n+        ty::Adt(_, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Str | ty::Slice(_) => {\n             let branches = valtree.unwrap_branch();\n \n-            // Need to collect the length of the unsized field for meta info\n-            let mut unsized_meta_info = None;\n-\n             // Need to downcast place for enums\n             let (place_adjusted, branches, variant_idx) = match ty.kind() {\n                 ty::Adt(def, _) if def.is_enum() => {\n@@ -399,48 +389,52 @@ fn fill_place_recursively<'tcx>(\n             };\n             debug!(?place_adjusted, ?branches);\n \n-            // Create the places for the fields and fill them recursively\n+            // Create the places (by indexing into `place`) for the fields and fill\n+            // them recursively\n             for (i, inner_valtree) in branches.iter().enumerate() {\n                 debug!(?i, ?inner_valtree);\n \n-                if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) && i == branches.len() - 1 {\n-                    // Note: For custom DSTs we need to manually process the last unsized field.\n-                    // We created a `Pointer` for the `Allocation` of the complete sized version of\n-                    // the Adt in `create_pointee_place` and now we fill that `Allocation` with the\n-                    // values in the ValTree. For the unsized field we have to additionally add the meta\n-                    // data.\n-\n-                    let offset = place.layout.fields.offset(i);\n-                    let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n-                    unsized_meta_info = Some(num_elems);\n-\n-                    // We create an array type to allow the recursive call to fill the place\n-                    // corresponding to the array\n-                    let arr_ty = tcx.mk_array(unsized_inner_ty, num_elems as u64);\n-                    debug!(?arr_ty);\n-                    let arr_layout = tcx.layout_of(ty::ParamEnv::empty().and(arr_ty)).unwrap();\n-                    let mut place_arr =\n-                        place.offset(offset, MemPlaceMeta::None, arr_layout, &tcx).unwrap();\n-                    debug!(?place_arr);\n-\n-                    fill_place_recursively(ecx, &mut place_arr, *inner_valtree);\n-                    dump_place(&ecx, place_arr.into());\n-\n-                    // Add the meta information for the unsized type\n-                    place_arr.meta = MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64));\n-\n-                    break;\n-                }\n-\n-                let mut place_inner = match *ty.kind() {\n-                    ty::Adt(_, _) | ty::Tuple(_) => ecx.mplace_field(&place_adjusted, i).unwrap(),\n-                    ty::Array(_, _) | ty::Str => {\n-                        ecx.mplace_index(&place_adjusted, i as u64).unwrap()\n+                let mut place_inner = match ty.kind() {\n+                    ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n+                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                        && i == branches.len() - 1 =>\n+                    {\n+                        // Note: For custom DSTs we need to manually process the last unsized field.\n+                        // We created a `Pointer` for the `Allocation` of the complete sized version of\n+                        // the Adt in `create_pointee_place` and now we fill that `Allocation` with the\n+                        // values in the ValTree. For the unsized field we have to additionally add the meta\n+                        // data.\n+\n+                        let (unsized_inner_ty, num_elems) =\n+                            get_info_on_unsized_field(ty, valtree, tcx);\n+                        debug!(?unsized_inner_ty);\n+\n+                        let inner_ty = match ty.kind() {\n+                            ty::Adt(def, substs) => {\n+                                def.variant(VariantIdx::from_u32(0)).fields[i].ty(tcx, substs)\n+                            }\n+                            ty::Tuple(inner_tys) => inner_tys[i],\n+                            _ => bug!(\"unexpected unsized type {:?}\", ty),\n+                        };\n+\n+                        let inner_layout =\n+                            tcx.layout_of(ty::ParamEnv::empty().and(inner_ty)).unwrap();\n+                        debug!(?inner_layout);\n+\n+                        let offset = place_adjusted.layout.fields.offset(i);\n+                        place\n+                            .offset(\n+                                offset,\n+                                MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64)),\n+                                inner_layout,\n+                                &tcx,\n+                            )\n+                            .unwrap()\n                     }\n-                    _ => bug!(),\n+                    _ => ecx.mplace_field(&place_adjusted, i).unwrap(),\n                 };\n-                debug!(?place_inner);\n \n+                debug!(?place_inner);\n                 fill_place_recursively(ecx, &mut place_inner, *inner_valtree);\n                 dump_place(&ecx, place_inner.into());\n             }\n@@ -453,12 +447,7 @@ fn fill_place_recursively<'tcx>(\n                 ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n             }\n \n-            // add meta information for unsized type\n-            if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n-                place.meta =\n-                    MemPlaceMeta::Meta(Scalar::from_u64(unsized_meta_info.unwrap() as u64));\n-            }\n-\n+            debug!(\"dump of place after writing discriminant:\");\n             dump_place(ecx, (*place).into());\n         }\n         _ => bug!(\"shouldn't have created a ValTree for {:?}\", ty),"}, {"sha": "918fe49e8e3fc6dad1b3d0ed645cfc531477d6b9", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "patch": "@@ -220,7 +220,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         mut ty: Ty<'tcx>,\n         mut normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,\n-        // This is a hack that is currently used to allow us to walk a ValTree\n+        // This is currently used to allow us to walk a ValTree\n         // in lockstep with the type in order to get the ValTree branch that\n         // corresponds to an unsized field.\n         mut f: impl FnMut() -> (),"}]}