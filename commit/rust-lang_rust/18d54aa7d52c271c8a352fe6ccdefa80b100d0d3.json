{"sha": "18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDU0YWE3ZDUyYzI3MWM4YTM1MmZlNmNjZGVmYTgwYjEwMGQwZDM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-19T09:38:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc: move layout::Struct into FieldPlacement/Abi.", "tree": {"sha": "9d36302d8d9a42b05a49aca5fd7b1b0beba2fc04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d36302d8d9a42b05a49aca5fd7b1b0beba2fc04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "html_url": "https://github.com/rust-lang/rust/commit/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08f9f134fd9d790c99ffab590fee264bd062f599", "url": "https://api.github.com/repos/rust-lang/rust/commits/08f9f134fd9d790c99ffab590fee264bd062f599", "html_url": "https://github.com/rust-lang/rust/commit/08f9f134fd9d790c99ffab590fee264bd062f599"}], "stats": {"total": 1096, "additions": 496, "deletions": 600}, "files": [{"sha": "f69e714a99724386ca58c2d1bab0744f479a298b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -41,7 +41,7 @@ use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predic\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n-use ty::layout::{Layout, TargetDataLayout};\n+use ty::layout::{CachedLayout, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -78,7 +78,7 @@ use hir;\n /// Internal storage\n pub struct GlobalArenas<'tcx> {\n     // internings\n-    layout: TypedArena<Layout<'tcx>>,\n+    layout: TypedArena<CachedLayout>,\n \n     // references\n     generics: TypedArena<ty::Generics>,\n@@ -918,7 +918,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n-    layout_interner: RefCell<FxHashSet<&'tcx Layout<'tcx>>>,\n+    layout_interner: RefCell<FxHashSet<&'tcx CachedLayout>>,\n \n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n@@ -1016,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn intern_layout(self, layout: Layout<'gcx>) -> &'gcx Layout<'gcx> {\n+    pub fn intern_layout(self, layout: CachedLayout) -> &'gcx CachedLayout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n         }"}, {"sha": "1a8f46d83440447a695edeef4091653238d3de9a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 475, "deletions": 563, "changes": 1038, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -12,7 +12,6 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use rustc_back::slice::ref_slice;\n use session::{self, DataTypeKind, Session};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n@@ -623,303 +622,6 @@ impl<'a, 'tcx> Primitive {\n     }\n }\n \n-/// A structure, a product type in ADT terms.\n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub struct Struct {\n-    /// Maximum alignment of fields and repr alignment.\n-    align: Align,\n-\n-    /// Primitive alignment of fields without repr alignment.\n-    primitive_align: Align,\n-\n-    /// If true, no alignment padding is used.\n-    packed: bool,\n-\n-    /// If true, the size is exact, otherwise it's only a lower bound.\n-    sized: bool,\n-\n-    /// Offsets for the first byte of each field, ordered to match the source definition order.\n-    /// This vector does not go in increasing order.\n-    /// FIXME(eddyb) use small vector optimization for the common case.\n-    offsets: Vec<Size>,\n-\n-    /// Maps source order field indices to memory order indices, depending how fields were permuted.\n-    /// FIXME (camlorn) also consider small vector  optimization here.\n-    pub memory_index: Vec<u32>,\n-\n-    min_size: Size,\n-}\n-\n-/// Info required to optimize struct layout.\n-#[derive(Copy, Clone, Debug)]\n-enum StructKind {\n-    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n-    AlwaysSizedUnivariant,\n-    /// A univariant, the last field of which may be coerced to unsized.\n-    MaybeUnsizedUnivariant,\n-    /// A univariant, but part of an enum.\n-    EnumVariant(Integer),\n-}\n-\n-impl<'a, 'tcx> Struct {\n-    fn new(dl: &TargetDataLayout,\n-           fields: &[FullLayout],\n-           repr: &ReprOptions,\n-           kind: StructKind,\n-           scapegoat: Ty<'tcx>)\n-           -> Result<Struct, LayoutError<'tcx>> {\n-        if repr.packed() && repr.align > 0 {\n-            bug!(\"Struct cannot be packed and aligned\");\n-        }\n-\n-        let align = if repr.packed() {\n-            dl.i8_align\n-        } else {\n-            dl.aggregate_align\n-        };\n-\n-        let mut ret = Struct {\n-            align,\n-            primitive_align: align,\n-            packed: repr.packed(),\n-            sized: true,\n-            offsets: vec![],\n-            memory_index: vec![],\n-            min_size: Size::from_bytes(0),\n-        };\n-\n-        // Anything with repr(C) or repr(packed) doesn't optimize.\n-        // Neither do  1-member and 2-member structs.\n-        // In addition, code in trans assume that 2-element structs can become pairs.\n-        // It's easier to just short-circuit here.\n-        let (mut optimize, sort_ascending) = match kind {\n-            StructKind::AlwaysSizedUnivariant |\n-            StructKind::MaybeUnsizedUnivariant => (fields.len() > 2, false),\n-            StructKind::EnumVariant(discr) => {\n-                (discr.size().bytes() == 1, true)\n-            }\n-        };\n-\n-        optimize &= (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n-\n-        ret.offsets = vec![Size::from_bytes(0); fields.len()];\n-        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n-\n-        if optimize {\n-            let end = if let StructKind::MaybeUnsizedUnivariant = kind {\n-                fields.len() - 1\n-            } else {\n-                fields.len()\n-            };\n-            if end > 0 {\n-                let optimizing  = &mut inverse_memory_index[..end];\n-                if sort_ascending {\n-                    optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n-                } else {\n-                    optimizing.sort_by(| &a, &b | {\n-                        let a = fields[a as usize].align(dl).abi();\n-                        let b = fields[b as usize].align(dl).abi();\n-                        b.cmp(&a)\n-                    });\n-                }\n-            }\n-        }\n-\n-        // inverse_memory_index holds field indices by increasing memory offset.\n-        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n-        // We now write field offsets to the corresponding offset slot;\n-        // field 5 with offset 0 puts 0 in offsets[5].\n-        // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n-\n-        let mut offset = Size::from_bytes(0);\n-\n-        if let StructKind::EnumVariant(discr) = kind {\n-            offset = discr.size();\n-            if !ret.packed {\n-                let align = discr.align(dl);\n-                ret.align = ret.align.max(align);\n-                ret.primitive_align = ret.primitive_align.max(align);\n-            }\n-        }\n-\n-        for i in inverse_memory_index.iter() {\n-            let field = fields[*i as usize];\n-            if !ret.sized {\n-                bug!(\"Struct::new: field #{} of `{}` comes after unsized field\",\n-                     ret.offsets.len(), scapegoat);\n-            }\n-\n-            if field.is_unsized() {\n-                ret.sized = false;\n-            }\n-\n-            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            if !ret.packed {\n-                let align = field.align(dl);\n-                let primitive_align = field.primitive_align(dl);\n-                ret.align = ret.align.max(align);\n-                ret.primitive_align = ret.primitive_align.max(primitive_align);\n-                offset = offset.abi_align(align);\n-            }\n-\n-            debug!(\"Struct::new offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n-            ret.offsets[*i as usize] = offset;\n-\n-            offset = offset.checked_add(field.size(dl), dl)\n-                           .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n-        }\n-\n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            ret.align = ret.align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n-            debug!(\"Struct::new repr_align: {:?}\", repr_align);\n-        }\n-\n-        debug!(\"Struct::new min_size: {:?}\", offset);\n-        ret.min_size = offset;\n-\n-        // As stated above, inverse_memory_index holds field indices by increasing offset.\n-        // This makes it an already-sorted view of the offsets vec.\n-        // To invert it, consider:\n-        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n-        // Field 5 would be the first element, so memory_index is i:\n-        // Note: if we didn't optimize, it's already right.\n-\n-        if optimize {\n-            ret.memory_index = vec![0; inverse_memory_index.len()];\n-\n-            for i in 0..inverse_memory_index.len() {\n-                ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n-            }\n-        } else {\n-            ret.memory_index = inverse_memory_index;\n-        }\n-\n-        Ok(ret)\n-    }\n-\n-    /// Get the size with trailing alignment padding.\n-    fn stride(&self) -> Size {\n-        self.min_size.abi_align(self.align)\n-    }\n-\n-    /// Get indices of the tys that made this struct by increasing offset.\n-    #[inline]\n-    pub fn field_index_by_increasing_offset<'b>(&'b self) -> impl iter::Iterator<Item=usize>+'b {\n-        let mut inverse_small = [0u8; 64];\n-        let mut inverse_big = vec![];\n-        let use_small = self.memory_index.len() <= inverse_small.len();\n-\n-        // We have to write this logic twice in order to keep the array small.\n-        if use_small {\n-            for i in 0..self.memory_index.len() {\n-                inverse_small[self.memory_index[i] as usize] = i as u8;\n-            }\n-        } else {\n-            inverse_big = vec![0; self.memory_index.len()];\n-            for i in 0..self.memory_index.len() {\n-                inverse_big[self.memory_index[i] as usize] = i as u32;\n-            }\n-        }\n-\n-        (0..self.memory_index.len()).map(move |i| {\n-            if use_small { inverse_small[i] as usize }\n-            else { inverse_big[i] as usize }\n-        })\n-    }\n-\n-    /// Find the offset of a non-zero leaf field, starting from\n-    /// the given type and recursing through aggregates.\n-    /// The tuple is `(offset, primitive, source_path)`.\n-    // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              param_env: ty::ParamEnv<'tcx>,\n-                              layout: FullLayout<'tcx>)\n-                              -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>> {\n-        let cx = (tcx, param_env);\n-        match (layout.layout, layout.abi, &layout.ty.sty) {\n-            (&Scalar, Abi::Scalar(Pointer), _) if !layout.ty.is_unsafe_ptr() => {\n-                Ok(Some((Size::from_bytes(0), Pointer)))\n-            }\n-            (&General { discr, .. }, _, &ty::TyAdt(def, _)) => {\n-                if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n-                    Ok(Some((layout.fields.offset(0), discr)))\n-                } else {\n-                    Ok(None)\n-                }\n-            }\n-\n-            (&FatPointer, _, _) if !layout.ty.is_unsafe_ptr() => {\n-                Ok(Some((layout.fields.offset(FAT_PTR_ADDR), Pointer)))\n-            }\n-\n-            // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (_, _, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n-                let field = layout.field(cx, 0)?;\n-                match (field.layout, field.abi) {\n-                    (&Scalar, Abi::Scalar(value)) => {\n-                        Ok(Some((layout.fields.offset(0), value)))\n-                    }\n-                    (&FatPointer, _) => {\n-                        Ok(Some((layout.fields.offset(0) +\n-                                 field.fields.offset(FAT_PTR_ADDR),\n-                                 Pointer)))\n-                    }\n-                    _ => Ok(None)\n-                }\n-            }\n-\n-            // Perhaps one of the fields is non-zero, let's recurse and find out.\n-            (&Univariant(ref variant), _, _) => {\n-                variant.non_zero_field(\n-                    tcx,\n-                    param_env,\n-                    (0..layout.fields.count()).map(|i| layout.field(cx, i)))\n-            }\n-\n-            // Is this a fixed-size array of something non-zero\n-            // with at least one element?\n-            (_, _, &ty::TyArray(ety, mut count)) => {\n-                if count.has_projections() {\n-                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n-                    if count.has_projections() {\n-                        return Err(LayoutError::Unknown(layout.ty));\n-                    }\n-                }\n-                if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n-                    Struct::non_zero_field_in_type(tcx, param_env, cx.layout_of(ety)?)\n-                } else {\n-                    Ok(None)\n-                }\n-            }\n-\n-            (_, _, &ty::TyProjection(_)) | (_, _, &ty::TyAnon(..)) => {\n-                bug!(\"Struct::non_zero_field_in_type: {:?} not normalized\", layout);\n-            }\n-\n-            // Anything else is not a non-zero type.\n-            _ => Ok(None)\n-        }\n-    }\n-\n-    /// Find the offset of a non-zero leaf field, starting from\n-    /// the given set of fields and recursing through aggregates.\n-    /// Returns Some((offset, primitive, source_path)) on success.\n-    fn non_zero_field<I>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         param_env: ty::ParamEnv<'tcx>,\n-                         fields: I)\n-                         -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n-    where I: Iterator<Item = Result<FullLayout<'tcx>, LayoutError<'tcx>>> {\n-        for (field, &field_offset) in fields.zip(&self.offsets) {\n-            let r = Struct::non_zero_field_in_type(tcx, param_env, field?)?;\n-            if let Some((offset, primitive)) = r {\n-                return Ok(Some((field_offset + offset, primitive)));\n-            }\n-        }\n-        Ok(None)\n-    }\n-}\n-\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -931,8 +633,8 @@ pub const FAT_PTR_ADDR: usize = 0;\n pub const FAT_PTR_EXTRA: usize = 1;\n \n /// Describes how the fields of a type are located in memory.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum FieldPlacement<'a> {\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub enum FieldPlacement {\n     /// Array-like placement. Can also express\n     /// unions, by using a stride of zero bytes.\n     Linear {\n@@ -948,11 +650,20 @@ pub enum FieldPlacement<'a> {\n     /// For example, enum variants leave a gap at the start,\n     /// where the discriminant field in the enum layout goes.\n     Arbitrary {\n-        offsets: &'a [Size]\n+        /// Offsets for the first byte of each field,\n+        /// ordered to match the source definition order.\n+        /// This vector does not go in increasing order.\n+        // FIXME(eddyb) use small vector optimization for the common case.\n+        offsets: Vec<Size>,\n+\n+        /// Maps source order field indices to memory order indices,\n+        /// depending how fields were permuted.\n+        // FIXME(camlorn) also consider small vector  optimization here.\n+        memory_index: Vec<u32>\n     }\n }\n \n-impl<'a> FieldPlacement<'a> {\n+impl FieldPlacement {\n     pub fn union(count: usize) -> Self {\n         FieldPlacement::Linear {\n             stride: Size::from_bytes(0),\n@@ -967,19 +678,62 @@ impl<'a> FieldPlacement<'a> {\n                 assert_eq!(usize_count as u64, count);\n                 usize_count\n             }\n-            FieldPlacement::Arbitrary { offsets } => offsets.len()\n+            FieldPlacement::Arbitrary { ref offsets, .. } => offsets.len()\n         }\n     }\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Linear { stride, count, .. } => {\n+            FieldPlacement::Linear { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);\n                 stride * i\n             }\n-            FieldPlacement::Arbitrary { offsets } => offsets[i]\n+            FieldPlacement::Arbitrary { ref offsets, .. } => offsets[i]\n+        }\n+    }\n+\n+    pub fn memory_index(&self, i: usize) -> usize {\n+        match *self {\n+            FieldPlacement::Linear { .. } => i,\n+            FieldPlacement::Arbitrary { ref memory_index, .. } => {\n+                let r = memory_index[i];\n+                assert_eq!(r as usize as u32, r);\n+                r as usize\n+            }\n+        }\n+    }\n+\n+    /// Get source indices of the fields by increasing offsets.\n+    #[inline]\n+    pub fn index_by_increasing_offset<'a>(&'a self) -> impl iter::Iterator<Item=usize>+'a {\n+        let mut inverse_small = [0u8; 64];\n+        let mut inverse_big = vec![];\n+        let use_small = self.count() <= inverse_small.len();\n+\n+        // We have to write this logic twice in order to keep the array small.\n+        if let FieldPlacement::Arbitrary { ref memory_index, .. } = *self {\n+            if use_small {\n+                for i in 0..self.count() {\n+                    inverse_small[memory_index[i] as usize] = i as u8;\n+                }\n+            } else {\n+                inverse_big = vec![0; self.count()];\n+                for i in 0..self.count() {\n+                    inverse_big[memory_index[i] as usize] = i as u32;\n+                }\n+            }\n         }\n+\n+        (0..self.count()).map(move |i| {\n+            match *self {\n+                FieldPlacement::Linear { .. } => i,\n+                FieldPlacement::Arbitrary { .. } => {\n+                    if use_small { inverse_small[i] as usize }\n+                    else { inverse_big[i] as usize }\n+                }\n+            }\n+        })\n     }\n }\n \n@@ -1078,7 +832,7 @@ impl Abi {\n /// NOTE: Because Layout is interned, redundant information should be\n /// kept to a minimum, e.g. it includes no sub-component Ty or Layout.\n #[derive(PartialEq, Eq, Hash, Debug)]\n-pub enum Layout<'a> {\n+pub enum Layout {\n     /// TyBool, TyChar, TyInt, TyUint, TyFloat, TyRawPtr, TyRef or TyFnPtr.\n     Scalar,\n \n@@ -1094,7 +848,7 @@ pub enum Layout<'a> {\n     // Remaining variants are all ADTs such as structs, enums or tuples.\n \n     /// Single-case enums, and structs/tuples.\n-    Univariant(Struct),\n+    Univariant,\n \n     /// Untagged unions.\n     UntaggedUnion,\n@@ -1110,12 +864,12 @@ pub enum Layout<'a> {\n         // the largest space between two consecutive discriminants and\n         // taking everything else as the (shortest) discriminant range.\n         discr_range: RangeInclusive<u64>,\n-        variants: Vec<CachedLayout<'a>>,\n+        variants: Vec<CachedLayout>,\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the field at the\n-    /// `discr_offset` offset is known to be nonnull due to its type; if that field is null, then\n+    /// `nndiscr` is represented by the struct `nonnull`, where field `0`\n+    /// is known to be nonnull due to its type; if that field is null, then\n     /// it represents the other case, which is known to be zero sized.\n     ///\n     /// For example, `std::option::Option` instantiated at a safe pointer type\n@@ -1124,8 +878,7 @@ pub enum Layout<'a> {\n     NullablePointer {\n         nndiscr: u64,\n         discr: Primitive,\n-        discr_offset: Size,\n-        variants: Vec<CachedLayout<'a>>,\n+        variants: Vec<CachedLayout>,\n     }\n }\n \n@@ -1148,16 +901,16 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct CachedLayout<'tcx> {\n-    pub layout: &'tcx Layout<'tcx>,\n-    pub fields: FieldPlacement<'tcx>,\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct CachedLayout {\n+    pub layout: Layout,\n+    pub fields: FieldPlacement,\n     pub abi: Abi,\n }\n \n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<CachedLayout<'tcx>, LayoutError<'tcx>>\n+                        -> Result<&'tcx CachedLayout, LayoutError<'tcx>>\n {\n     let (param_env, ty) = query.into_parts();\n \n@@ -1182,47 +935,168 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n }\n \n-impl<'a, 'tcx> Layout<'tcx> {\n+impl<'a, 'tcx> Layout {\n     fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>,\n                         ty: Ty<'tcx>)\n-                        -> Result<CachedLayout<'tcx>, LayoutError<'tcx>> {\n+                        -> Result<&'tcx CachedLayout, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n         let scalar = |value| {\n-            CachedLayout {\n-                layout: &Layout::Scalar,\n+            tcx.intern_layout(CachedLayout {\n+                layout: Layout::Scalar,\n                 fields: FieldPlacement::union(0),\n                 abi: Abi::Scalar(value)\n-            }\n+            })\n         };\n-        let univariant = |st| {\n-            let layout = tcx.intern_layout(Layout::Univariant(st));\n-            let fields = match *layout {\n-                Univariant(ref variant) => {\n-                    FieldPlacement::Arbitrary {\n-                        offsets: &variant.offsets\n-                    }\n+        #[derive(Copy, Clone, Debug)]\n+        enum StructKind {\n+            /// A tuple, closure, or univariant which cannot be coerced to unsized.\n+            AlwaysSized,\n+            /// A univariant, the last field of which may be coerced to unsized.\n+            MaybeUnsized,\n+            /// A univariant, but part of an enum.\n+            EnumVariant(Integer),\n+        }\n+        let univariant_uninterned = |fields: &[FullLayout], repr: &ReprOptions, kind| {\n+            let packed = repr.packed();\n+            if packed && repr.align > 0 {\n+                bug!(\"struct cannot be packed and aligned\");\n+            }\n+\n+            let mut align = if packed {\n+                dl.i8_align\n+            } else {\n+                dl.aggregate_align\n+            };\n+\n+            let mut primitive_align = align;\n+            let mut sized = true;\n+\n+            // Anything with repr(C) or repr(packed) doesn't optimize.\n+            // Neither do  1-member and 2-member structs.\n+            // In addition, code in trans assume that 2-element structs can become pairs.\n+            // It's easier to just short-circuit here.\n+            let (mut optimize, sort_ascending) = match kind {\n+                StructKind::AlwaysSized |\n+                StructKind::MaybeUnsized => (fields.len() > 2, false),\n+                StructKind::EnumVariant(discr) => {\n+                    (discr.size().bytes() == 1, true)\n                 }\n-                _ => bug!()\n             };\n-            let abi = match *layout {\n-                Univariant(ref st) => {\n-                    Abi::Aggregate {\n-                        sized: st.sized,\n-                        packed: st.packed,\n-                        align: st.align,\n-                        primitive_align: st.primitive_align,\n-                        size: st.stride()\n+\n+            optimize &= (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n+\n+            let mut offsets = vec![Size::from_bytes(0); fields.len()];\n+            let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+\n+            if optimize {\n+                let end = if let StructKind::MaybeUnsized = kind {\n+                    fields.len() - 1\n+                } else {\n+                    fields.len()\n+                };\n+                if end > 0 {\n+                    let optimizing  = &mut inverse_memory_index[..end];\n+                    if sort_ascending {\n+                        optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n+                    } else {\n+                        optimizing.sort_by(| &a, &b | {\n+                            let a = fields[a as usize].align(dl).abi();\n+                            let b = fields[b as usize].align(dl).abi();\n+                            b.cmp(&a)\n+                        });\n                     }\n                 }\n-                _ => bug!()\n-            };\n-            CachedLayout {\n-                layout,\n-                fields,\n-                abi\n             }\n+\n+            // inverse_memory_index holds field indices by increasing memory offset.\n+            // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+            // We now write field offsets to the corresponding offset slot;\n+            // field 5 with offset 0 puts 0 in offsets[5].\n+            // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n+\n+            let mut offset = Size::from_bytes(0);\n+\n+            if let StructKind::EnumVariant(discr) = kind {\n+                offset = discr.size();\n+                if !packed {\n+                    let discr_align = discr.align(dl);\n+                    align = align.max(discr_align);\n+                    primitive_align = primitive_align.max(discr_align);\n+                }\n+            }\n+\n+            for i in inverse_memory_index.iter() {\n+                let field = fields[*i as usize];\n+                if !sized {\n+                    bug!(\"univariant: field #{} of `{}` comes after unsized field\",\n+                        offsets.len(), ty);\n+                }\n+\n+                if field.is_unsized() {\n+                    sized = false;\n+                }\n+\n+                // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+                if !packed {\n+                    let field_align = field.align(dl);\n+                    align = align.max(field_align);\n+                    primitive_align = primitive_align.max(field.primitive_align(dl));\n+                    offset = offset.abi_align(field_align);\n+                }\n+\n+                debug!(\"univariant offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+                offsets[*i as usize] = offset;\n+\n+                offset = offset.checked_add(field.size(dl), dl)\n+                    .ok_or(LayoutError::SizeOverflow(ty))?;\n+            }\n+\n+            if repr.align > 0 {\n+                let repr_align = repr.align as u64;\n+                align = align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+                debug!(\"univariant repr_align: {:?}\", repr_align);\n+            }\n+\n+            debug!(\"univariant min_size: {:?}\", offset);\n+            let min_size = offset;\n+\n+            // As stated above, inverse_memory_index holds field indices by increasing offset.\n+            // This makes it an already-sorted view of the offsets vec.\n+            // To invert it, consider:\n+            // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+            // Field 5 would be the first element, so memory_index is i:\n+            // Note: if we didn't optimize, it's already right.\n+\n+            let mut memory_index;\n+            if optimize {\n+                memory_index = vec![0; inverse_memory_index.len()];\n+\n+                for i in 0..inverse_memory_index.len() {\n+                    memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+                }\n+            } else {\n+                memory_index = inverse_memory_index;\n+            }\n+\n+            Ok(CachedLayout {\n+                layout: Layout::Univariant,\n+                fields: FieldPlacement::Arbitrary {\n+                    offsets,\n+                    memory_index\n+                },\n+                abi: Abi::Aggregate {\n+                    sized,\n+                    packed,\n+                    align,\n+                    primitive_align,\n+                    size: min_size.abi_align(align)\n+                }\n+            })\n+        };\n+        let univariant = |fields: &[FullLayout], repr: &ReprOptions, kind| {\n+            Ok(tcx.intern_layout(univariant_uninterned(fields, repr, kind)?))\n         };\n         assert!(!ty.has_infer_types());\n \n@@ -1250,18 +1124,17 @@ impl<'a, 'tcx> Layout<'tcx> {\n             };\n             let meta_offset = fields.offset(1);\n             assert_eq!(meta_offset, meta_offset.abi_align(metadata.align(dl)));\n-            Ok(CachedLayout {\n-                layout: tcx.intern_layout(Layout::FatPointer),\n+            Ok(tcx.intern_layout(CachedLayout {\n+                layout: Layout::FatPointer,\n                 fields,\n-                abi:\n-                Abi::Aggregate {\n+                abi: Abi::Aggregate {\n                     sized: true,\n                     packed: false,\n                     align,\n                     primitive_align: align,\n                     size: (meta_offset + metadata.size(dl)).abi_align(align)\n                 }\n-            })\n+            }))\n         };\n \n         Ok(match ty.sty {\n@@ -1280,8 +1153,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n \n             // The never type.\n             ty::TyNever => {\n-                univariant(Struct::new(dl, &[], &ReprOptions::default(),\n-                                       StructKind::AlwaysSizedUnivariant, ty)?)\n+                univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n             }\n \n             // Potentially-fat pointers.\n@@ -1308,8 +1180,8 @@ impl<'a, 'tcx> Layout<'tcx> {\n                 let size = element_size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n-                CachedLayout {\n-                    layout: &Layout::Array,\n+                tcx.intern_layout(CachedLayout {\n+                    layout: Layout::Array,\n                     fields: FieldPlacement::Linear {\n                         stride: element_size,\n                         count\n@@ -1321,12 +1193,12 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         primitive_align: element.primitive_align(dl),\n                         size\n                     }\n-                }\n+                })\n             }\n             ty::TySlice(element) => {\n                 let element = cx.layout_of(element)?;\n-                CachedLayout {\n-                    layout: &Layout::Array,\n+                tcx.intern_layout(CachedLayout {\n+                    layout: Layout::Array,\n                     fields: FieldPlacement::Linear {\n                         stride: element.size(dl),\n                         count: 0\n@@ -1338,11 +1210,11 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         primitive_align: element.primitive_align(dl),\n                         size: Size::from_bytes(0)\n                     }\n-                }\n+                })\n             }\n             ty::TyStr => {\n-                CachedLayout {\n-                    layout: &Layout::Array,\n+                tcx.intern_layout(CachedLayout {\n+                    layout: Layout::Array,\n                     fields: FieldPlacement::Linear {\n                         stride: Size::from_bytes(1),\n                         count: 0\n@@ -1354,51 +1226,47 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         primitive_align: dl.i8_align,\n                         size: Size::from_bytes(0)\n                     }\n-                }\n+                })\n             }\n \n             // Odd unit types.\n             ty::TyFnDef(..) => {\n-                univariant(Struct::new(dl, &[], &ReprOptions::default(),\n-                                       StructKind::AlwaysSizedUnivariant, ty)?)\n+                univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n             }\n             ty::TyDynamic(..) | ty::TyForeign(..) => {\n-                let mut unit = Struct::new(dl, &[], &ReprOptions::default(),\n-                  StructKind::AlwaysSizedUnivariant, ty)?;\n-                unit.sized = false;\n-                univariant(unit)\n+                let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n+                  StructKind::AlwaysSized)?;\n+                match unit.abi {\n+                    Abi::Aggregate { ref mut sized, .. } => *sized = false,\n+                    _ => bug!()\n+                }\n+                tcx.intern_layout(unit)\n             }\n \n             // Tuples, generators and closures.\n             ty::TyGenerator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n-                univariant(Struct::new(dl,\n-                    &tys.map(|ty| cx.layout_of(ty))\n-                      .collect::<Result<Vec<_>, _>>()?,\n+                univariant(&tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSizedUnivariant, ty)?)\n+                    StructKind::AlwaysSized)?\n             }\n \n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                univariant(Struct::new(dl,\n-                    &tys.map(|ty| cx.layout_of(ty))\n-                      .collect::<Result<Vec<_>, _>>()?,\n+                univariant(&tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSizedUnivariant, ty)?)\n+                    StructKind::AlwaysSized)?\n             }\n \n             ty::TyTuple(tys, _) => {\n                 let kind = if tys.len() == 0 {\n-                    StructKind::AlwaysSizedUnivariant\n+                    StructKind::AlwaysSized\n                 } else {\n-                    StructKind::MaybeUnsizedUnivariant\n+                    StructKind::MaybeUnsized\n                 };\n \n-                univariant(Struct::new(dl,\n-                    &tys.iter().map(|ty| cx.layout_of(ty))\n-                      .collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), kind, ty)?)\n+                univariant(&tys.iter().map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                    &ReprOptions::default(), kind)?\n             }\n \n             // SIMD vector types.\n@@ -1413,14 +1281,14 @@ impl<'a, 'tcx> Layout<'tcx> {\n                                                 ty, element));\n                     }\n                 };\n-                CachedLayout {\n-                    layout: &Layout::Vector,\n+                tcx.intern_layout(CachedLayout {\n+                    layout: Layout::Vector,\n                     fields: FieldPlacement::Linear {\n                         stride: element.size(tcx),\n                         count\n                     },\n                     abi: Abi::Vector { element, count }\n-                }\n+                })\n             }\n \n             // ADTs.\n@@ -1436,8 +1304,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    return Ok(univariant(Struct::new(dl, &[],\n-                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?));\n+                    return univariant(&[], &def.repr, StructKind::AlwaysSized);\n                 }\n \n                 if def.is_union() {\n@@ -1471,8 +1338,8 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         size = cmp::max(size, field.size(dl));\n                     }\n \n-                    return Ok(CachedLayout {\n-                        layout: &Layout::UntaggedUnion,\n+                    return Ok(tcx.intern_layout(CachedLayout {\n+                        layout: Layout::UntaggedUnion,\n                         fields: FieldPlacement::union(variants[0].len()),\n                         abi: Abi::Aggregate {\n                             sized: true,\n@@ -1481,7 +1348,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n                             primitive_align,\n                             size: size.abi_align(align)\n                         }\n-                    });\n+                    }));\n                 }\n \n                 if !def.is_enum() || (variants.len() == 1 &&\n@@ -1491,17 +1358,17 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n                     let kind = if def.is_enum() || variants[0].len() == 0 {\n-                        StructKind::AlwaysSizedUnivariant\n+                        StructKind::AlwaysSized\n                     } else {\n                         let param_env = tcx.param_env(def.did);\n                         let last_field = def.variants[0].fields.last().unwrap();\n                         let always_sized = tcx.type_of(last_field.did)\n                           .is_sized(tcx, param_env, DUMMY_SP);\n-                        if !always_sized { StructKind::MaybeUnsizedUnivariant }\n-                        else { StructKind::AlwaysSizedUnivariant }\n+                        if !always_sized { StructKind::MaybeUnsized }\n+                        else { StructKind::AlwaysSized }\n                     };\n \n-                    return Ok(univariant(Struct::new(dl, &variants[0], &def.repr, kind, ty)?));\n+                    return univariant(&variants[0], &def.repr, kind);\n                 }\n \n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n@@ -1511,71 +1378,56 @@ impl<'a, 'tcx> Layout<'tcx> {\n                    !def.repr.inhibit_enum_layout_opt() &&\n                    no_explicit_discriminants {\n                     // Nullable pointer optimization\n-                    let mut st = vec![\n-                        Struct::new(dl, &variants[0],\n-                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?,\n-                        Struct::new(dl, &variants[1],\n-                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?\n-                    ];\n-\n-                    let mut choice = None;\n-                    for discr in 0..2 {\n-                        if st[1 - discr].stride().bytes() > 0 {\n+                    for i in 0..2 {\n+                        if !variants[1 - i].iter().all(|f| f.size(dl).bytes() == 0) {\n                             continue;\n                         }\n \n-                        let field = st[discr].non_zero_field(tcx, param_env,\n-                            variants[discr].iter().map(|&f| Ok(f)))?;\n-                        if let Some((offset, primitive)) = field {\n-                            choice = Some((discr, offset, primitive));\n-                            break;\n-                        }\n-                    }\n-\n-                    if let Some((nndiscr, offset, discr)) = choice {\n-                        let variants: Vec<_> = st.into_iter().map(&univariant).collect();\n-                        let mut abi = variants[nndiscr].abi;\n-\n-                        let mut discr_align = discr.align(dl);\n-                        match abi {\n-                            Abi::Aggregate {\n-                                ref mut align,\n-                                ref mut primitive_align,\n-                                ref mut packed,\n-                                ..\n-                            } => {\n-                                if offset.abi_align(discr_align) != offset {\n-                                    *packed = true;\n-                                    discr_align = dl.i8_align;\n+                        for (field_index, field) in variants[i].iter().enumerate() {\n+                            if let Some((offset, discr)) = field.non_zero_field(cx)? {\n+                                let st = vec![\n+                                    univariant_uninterned(&variants[0],\n+                                        &def.repr, StructKind::AlwaysSized)?,\n+                                    univariant_uninterned(&variants[1],\n+                                        &def.repr, StructKind::AlwaysSized)?\n+                                ];\n+                                let offset = st[i].fields.offset(field_index) + offset;\n+                                let mut abi = st[i].abi;\n+                                if offset.bytes() == 0 && discr.size(dl) == abi.size(dl) {\n+                                    abi = Abi::Scalar(discr);\n                                 }\n-                                *align = align.max(discr_align);\n-                                *primitive_align = primitive_align.max(discr_align);\n-                            }\n-                            _ => {}\n-                        }\n-\n-                        let layout = tcx.intern_layout(Layout::NullablePointer {\n-                            nndiscr: nndiscr as u64,\n-                            discr,\n-                            discr_offset: offset,\n-                            variants,\n-                        });\n-                        return Ok(CachedLayout {\n-                            layout,\n-                            fields: match *layout {\n-                                Layout::NullablePointer { ref discr_offset, .. } => {\n-                                    FieldPlacement::Arbitrary {\n-                                        offsets: ref_slice(discr_offset)\n+                                let mut discr_align = discr.align(dl);\n+                                match abi {\n+                                    Abi::Aggregate {\n+                                        ref mut align,\n+                                        ref mut primitive_align,\n+                                        ref mut packed,\n+                                        ..\n+                                    } => {\n+                                        if offset.abi_align(discr_align) != offset {\n+                                            *packed = true;\n+                                            discr_align = dl.i8_align;\n+                                        }\n+                                        *align = align.max(discr_align);\n+                                        *primitive_align = primitive_align.max(discr_align);\n                                     }\n+                                    _ => {}\n                                 }\n-                                _ => bug!()\n-                            },\n-                            abi: if offset.bytes() == 0 && discr.size(dl) == abi.size(dl) {\n-                                Abi::Scalar(discr)\n-                            } else {\n-                                abi\n+                                return Ok(tcx.intern_layout(CachedLayout {\n+                                    layout: Layout::NullablePointer {\n+                                        nndiscr: i as u64,\n+\n+                                        discr,\n+                                        variants: st,\n+                                    },\n+                                    fields: FieldPlacement::Arbitrary {\n+                                        offsets: vec![offset],\n+                                        memory_index: vec![0]\n+                                    },\n+                                    abi\n+                                }));\n                             }\n-                        });\n+                        }\n                     }\n                 }\n \n@@ -1598,22 +1450,22 @@ impl<'a, 'tcx> Layout<'tcx> {\n                 assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n                 // Create the set of structs that represent each variant.\n-                let mut variants = variants.into_iter().map(|fields| {\n-                    let st = Struct::new(dl, &fields,\n-                        &def.repr, StructKind::EnumVariant(min_ity), ty)?;\n+                let mut variants = variants.into_iter().map(|field_layouts| {\n+                    let st = univariant_uninterned(&field_layouts,\n+                        &def.repr, StructKind::EnumVariant(min_ity))?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n-                    for i in st.field_index_by_increasing_offset() {\n-                        let field = fields[i];\n+                    for i in st.fields.index_by_increasing_offset() {\n+                        let field = field_layouts[i];\n                         let field_align = field.align(dl);\n                         if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n                             start_align = start_align.min(field_align);\n                             break;\n                         }\n                     }\n-                    size = cmp::max(size, st.min_size);\n-                    align = align.max(st.align);\n-                    primitive_align = primitive_align.max(st.primitive_align);\n+                    size = cmp::max(size, st.abi.size(dl));\n+                    align = align.max(st.abi.align(dl));\n+                    primitive_align = primitive_align.max(st.abi.primitive_align(dl));\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1662,29 +1514,38 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n                     for variant in &mut variants {\n-                        for i in variant.offsets.iter_mut() {\n-                            if *i <= old_ity_size {\n-                                assert_eq!(*i, old_ity_size);\n-                                *i = new_ity_size;\n+                        match (&mut variant.fields, &mut variant.abi) {\n+                            (&mut FieldPlacement::Arbitrary { ref mut offsets, .. },\n+                             &mut Abi::Aggregate { ref mut size, .. }) => {\n+                                for i in offsets {\n+                                    if *i <= old_ity_size {\n+                                        assert_eq!(*i, old_ity_size);\n+                                        *i = new_ity_size;\n+                                    }\n+                                }\n+                                // We might be making the struct larger.\n+                                if *size <= old_ity_size {\n+                                    *size = new_ity_size;\n+                                }\n                             }\n-                        }\n-                        // We might be making the struct larger.\n-                        if variant.min_size <= old_ity_size {\n-                            variant.min_size = new_ity_size;\n+                            _ => bug!()\n                         }\n                     }\n                 }\n \n                 let discr = Int(ity, signed);\n-                CachedLayout {\n-                    layout: tcx.intern_layout(Layout::General {\n+                tcx.intern_layout(CachedLayout {\n+                    layout: Layout::General {\n                         discr,\n \n                         // FIXME: should be u128?\n                         discr_range: (min as u64)..=(max as u64),\n-                        variants: variants.into_iter().map(&univariant).collect(),\n-                    }),\n-                    fields: FieldPlacement::union(1),\n+                        variants\n+                    },\n+                    fields: FieldPlacement::Arbitrary {\n+                        offsets: vec![Size::from_bytes(0)],\n+                        memory_index: vec![0]\n+                    },\n                     abi: if discr.size(dl) == size {\n                         Abi::Scalar(discr)\n                     } else {\n@@ -1696,7 +1557,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n                             size\n                         }\n                     }\n-                }\n+                })\n             }\n \n             // Types with no meaningful known layout.\n@@ -1705,12 +1566,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n-                let layout = cx.layout_of(normalized)?;\n-                CachedLayout {\n-                    layout: layout.layout,\n-                    fields: layout.fields,\n-                    abi: layout.abi\n-                }\n+                tcx.layout_raw(param_env.and(normalized))?\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -1727,7 +1583,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n     fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   param_env: ty::ParamEnv<'tcx>,\n-                                  layout: FullLayout) {\n+                                  layout: FullLayout<'tcx>) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n@@ -1747,7 +1603,8 @@ impl<'a, 'tcx> Layout<'tcx> {\n     fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            ty: Ty<'tcx>,\n                                            param_env: ty::ParamEnv<'tcx>,\n-                                           layout: FullLayout) {\n+                                           layout: FullLayout<'tcx>) {\n+        let cx = (tcx, param_env);\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", ty);\n@@ -1761,10 +1618,10 @@ impl<'a, 'tcx> Layout<'tcx> {\n                                                               variants);\n         };\n \n-        let (adt_def, substs) = match ty.sty {\n-            ty::TyAdt(ref adt_def, substs) => {\n+        let adt_def = match ty.sty {\n+            ty::TyAdt(ref adt_def, _) => {\n                 debug!(\"print-type-size t: `{:?}` process adt\", ty);\n-                (adt_def, substs)\n+                adt_def\n             }\n \n             ty::TyClosure(..) => {\n@@ -1781,91 +1638,87 @@ impl<'a, 'tcx> Layout<'tcx> {\n \n         let adt_kind = adt_def.adt_kind();\n \n-        let build_field_info = |(field_name, field_ty): (ast::Name, Ty<'tcx>), offset: &Size| {\n-            match (tcx, param_env).layout_of(field_ty) {\n-                Err(_) => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n-                Ok(field_layout) => {\n-                    session::FieldInfo {\n-                        name: field_name.to_string(),\n-                        offset: offset.bytes(),\n-                        size: field_layout.size(tcx).bytes(),\n-                        align: field_layout.align(tcx).abi(),\n+        let build_variant_info = |n: Option<ast::Name>,\n+                                  flds: &[ast::Name],\n+                                  layout: FullLayout<'tcx>| {\n+            let mut min_size = Size::from_bytes(0);\n+            let field_info: Vec<_> = flds.iter().enumerate().map(|(i, &name)| {\n+                match layout.field(cx, i) {\n+                    Err(err) => {\n+                        bug!(\"no layout found for field {}: `{:?}`\", name, err);\n+                    }\n+                    Ok(field_layout) => {\n+                        let offset = layout.fields.offset(i);\n+                        let field_size = field_layout.size(tcx);\n+                        let field_end = offset + field_size;\n+                        if min_size < field_end {\n+                            min_size = field_end;\n+                        }\n+                        session::FieldInfo {\n+                            name: name.to_string(),\n+                            offset: offset.bytes(),\n+                            size: field_size.bytes(),\n+                            align: field_layout.align(tcx).abi(),\n+                        }\n                     }\n                 }\n-            }\n-        };\n-\n-        let build_variant_info = |n: Option<ast::Name>,\n-                                  flds: &[(ast::Name, Ty<'tcx>)],\n-                                  s: &Struct| {\n-            let field_info: Vec<_> =\n-                flds.iter()\n-                    .zip(&s.offsets)\n-                    .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n-                    .collect();\n+            }).collect();\n \n             session::VariantInfo {\n                 name: n.map(|n|n.to_string()),\n-                kind: if s.sized {\n+                kind: if layout.is_unsized() {\n+                    session::SizeKind::Min\n+                } else {\n                     session::SizeKind::Exact\n+                },\n+                align: layout.align(tcx).abi(),\n+                size: if min_size.bytes() == 0 {\n+                    layout.size(tcx).bytes()\n                 } else {\n-                    session::SizeKind::Min\n+                    min_size.bytes()\n                 },\n-                align: s.align.abi(),\n-                size: s.min_size.bytes(),\n                 fields: field_info,\n             }\n         };\n \n         match *layout.layout {\n-            Layout::Univariant(ref variant_layout) => {\n+            Layout::Univariant => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n                 };\n-                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n-                       ty, variant_layout, variant_names());\n+                debug!(\"print-type-size `{:#?}` variants: {:?}\",\n+                       layout, variant_names());\n                 assert!(adt_def.variants.len() <= 1,\n                         \"univariant with variants {:?}\", variant_names());\n                 if adt_def.variants.len() == 1 {\n                     let variant_def = &adt_def.variants[0];\n                     let fields: Vec<_> =\n-                        variant_def.fields.iter()\n-                                          .map(|f| (f.name, f.ty(tcx, substs)))\n-                                          .collect();\n+                        variant_def.fields.iter().map(|f| f.name).collect();\n                     record(adt_kind.into(),\n                            None,\n                            vec![build_variant_info(Some(variant_def.name),\n                                                    &fields,\n-                                                   variant_layout)]);\n+                                                   layout)]);\n                 } else {\n                     // (This case arises for *empty* enums; so give it\n                     // zero variants.)\n                     record(adt_kind.into(), None, vec![]);\n                 }\n             }\n \n-            Layout::NullablePointer { ref variants, .. } |\n-            Layout::General { ref variants, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n-                       ty, adt_def.variants.len(), variants.len(), variants);\n+            Layout::NullablePointer { .. } |\n+            Layout::General { .. } => {\n+                debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n+                       ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n-                    adt_def.variants.iter()\n-                                    .zip(variants.iter())\n-                                    .map(|(variant_def, variant_layout)| {\n-                                        let fields: Vec<_> =\n-                                            variant_def.fields\n-                                                       .iter()\n-                                                       .map(|f| (f.name, f.ty(tcx, substs)))\n-                                                       .collect();\n-                                        let variant_layout = match *variant_layout.layout {\n-                                            Univariant(ref variant) => variant,\n-                                            _ => bug!()\n-                                        };\n-                                        build_variant_info(Some(variant_def.name),\n-                                                           &fields,\n-                                                           variant_layout)\n-                                    })\n-                                    .collect();\n+                    adt_def.variants.iter().enumerate().map(|(i, variant_def)| {\n+                        let fields: Vec<_> =\n+                            variant_def.fields.iter().map(|f| f.name).collect();\n+                        build_variant_info(Some(variant_def.name),\n+                                            &fields,\n+                                            layout.for_variant(i))\n+                    })\n+                    .collect();\n                 record(adt_kind.into(), match *layout.layout {\n                     Layout::General { discr, .. } => Some(discr.size(tcx)),\n                     _ => None\n@@ -2048,8 +1901,8 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n pub struct FullLayout<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub variant_index: Option<usize>,\n-    pub layout: &'tcx Layout<'tcx>,\n-    pub fields: FieldPlacement<'tcx>,\n+    pub layout: &'tcx Layout,\n+    pub fields: &'tcx FieldPlacement,\n     pub abi: Abi,\n }\n \n@@ -2101,8 +1954,8 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n         let layout = FullLayout {\n             ty,\n             variant_index: None,\n-            layout: cached.layout,\n-            fields: cached.fields,\n+            layout: &cached.layout,\n+            fields: &cached.fields,\n             abi: cached.abi\n         };\n \n@@ -2133,8 +1986,8 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n         let layout = FullLayout {\n             ty,\n             variant_index: None,\n-            layout: cached.layout,\n-            fields: cached.fields,\n+            layout: &cached.layout,\n+            fields: &cached.fields,\n             abi: cached.abi\n         };\n \n@@ -2163,12 +2016,12 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n         };\n \n         let (layout, fields, abi) = match *self.layout {\n-            Univariant(_) => (self.layout, self.fields, self.abi),\n+            Univariant => (self.layout, self.fields, self.abi),\n \n             NullablePointer { ref variants, .. } |\n             General { ref variants, .. } => {\n-                let variant = variants[variant_index];\n-                (variant.layout, variant.fields, variant.abi)\n+                let variant = &variants[variant_index];\n+                (&variant.layout, &variant.fields, variant.abi)\n             }\n \n             _ => bug!()\n@@ -2310,9 +2163,81 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n     pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n         self.abi.primitive_align(cx)\n     }\n+\n+    /// Find the offset of a non-zero leaf field, starting from\n+    /// the given type and recursing through aggregates.\n+    /// The tuple is `(offset, primitive, source_path)`.\n+    // FIXME(eddyb) track value ranges and traverse already optimized enums.\n+    fn non_zero_field<C>(&self, cx: C)\n+        -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n+        where C: LayoutOf<Ty<'tcx>, FullLayout = Result<Self, LayoutError<'tcx>>> +\n+                 HasTyCtxt<'tcx>\n+    {\n+        let tcx = cx.tcx();\n+        match (self.layout, self.abi, &self.ty.sty) {\n+            (&Scalar, Abi::Scalar(Pointer), _) if !self.ty.is_unsafe_ptr() => {\n+                Ok(Some((Size::from_bytes(0), Pointer)))\n+            }\n+            (&General { discr, .. }, _, &ty::TyAdt(def, _)) => {\n+                if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n+                    Ok(Some((self.fields.offset(0), discr)))\n+                } else {\n+                    Ok(None)\n+                }\n+            }\n+\n+            (&FatPointer, _, _) if !self.ty.is_unsafe_ptr() => {\n+                Ok(Some((self.fields.offset(FAT_PTR_ADDR), Pointer)))\n+            }\n+\n+            // Is this the NonZero lang item wrapping a pointer or integer type?\n+            (_, _, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n+                let field = self.field(cx, 0)?;\n+                match (field.layout, field.abi) {\n+                    (&Scalar, Abi::Scalar(value)) => {\n+                        Ok(Some((self.fields.offset(0), value)))\n+                    }\n+                    (&FatPointer, _) => {\n+                        Ok(Some((self.fields.offset(0) +\n+                                 field.fields.offset(FAT_PTR_ADDR),\n+                                 Pointer)))\n+                    }\n+                    _ => Ok(None)\n+                }\n+            }\n+\n+            // Perhaps one of the fields is non-zero, let's recurse and find out.\n+            (&Univariant, _, _) => {\n+                for i in 0..self.fields.count() {\n+                    let r = self.field(cx, i)?.non_zero_field(cx)?;\n+                    if let Some((offset, primitive)) = r {\n+                        return Ok(Some((self.fields.offset(i) + offset, primitive)));\n+                    }\n+                }\n+                Ok(None)\n+            }\n+\n+            // Is this a fixed-size array of something non-zero\n+            // with at least one element?\n+            (_, _, &ty::TyArray(ety, _)) => {\n+                if self.fields.count() != 0 {\n+                    cx.layout_of(ety)?.non_zero_field(cx)\n+                } else {\n+                    Ok(None)\n+                }\n+            }\n+\n+            (_, _, &ty::TyProjection(_)) | (_, _, &ty::TyAnon(..)) => {\n+                bug!(\"FullLayout::non_zero_field: {:#?} not normalized\", self);\n+            }\n+\n+            // Anything else is not a non-zero type.\n+            _ => Ok(None)\n+        }\n+    }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -2324,9 +2249,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout<'gcx> {\n             Vector => {}\n             Array => {}\n             FatPointer => {}\n-            Univariant(ref variant) => {\n-                variant.hash_stable(hcx, hasher);\n-            }\n+            Univariant => {}\n             UntaggedUnion => {}\n             General {\n                 discr,\n@@ -2342,18 +2265,16 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout<'gcx> {\n                 nndiscr,\n                 ref variants,\n                 ref discr,\n-                discr_offset,\n             } => {\n                 nndiscr.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n                 discr.hash_stable(hcx, hasher);\n-                discr_offset.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -2365,8 +2286,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement<'gcx> {\n                 count.hash_stable(hcx, hasher);\n                 stride.hash_stable(hcx, hasher);\n             }\n-            Arbitrary { offsets } => {\n+            Arbitrary { ref offsets, ref memory_index } => {\n                 offsets.hash_stable(hcx, hasher);\n+                memory_index.hash_stable(hcx, hasher);\n             }\n         }\n     }\n@@ -2398,7 +2320,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n     }\n }\n \n-impl_stable_hash_for!(struct ::ty::layout::CachedLayout<'tcx> {\n+impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n     layout,\n     fields,\n     abi\n@@ -2443,13 +2365,3 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for LayoutError<'gcx>\n         }\n     }\n }\n-\n-impl_stable_hash_for!(struct ::ty::layout::Struct {\n-    align,\n-    primitive_align,\n-    packed,\n-    sized,\n-    offsets,\n-    memory_index,\n-    min_size\n-});"}, {"sha": "ebd17ebabe79fe415190835dfa0bbf873a668509", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -264,7 +264,7 @@ define_maps! { <'tcx>\n     [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                  -> Result<ty::layout::CachedLayout<'tcx>,\n+                                  -> Result<&'tcx ty::layout::CachedLayout,\n                                             ty::layout::LayoutError<'tcx>>,\n \n     [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)"}, {"sha": "739b2a3789a3f8cfe30f0eeb81663a65680b5133", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -316,7 +316,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 let mut total = Size::from_bytes(0);\n                 let mut result = None;\n \n-                let is_union = match self.fields {\n+                let is_union = match *self.fields {\n                     layout::FieldPlacement::Linear { stride, .. } => {\n                         stride.bytes() == 0\n                     }"}, {"sha": "07c64c35c07d6c46828b927b2ac6780b0f8c5049", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -72,7 +72,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return;\n     }\n     match *l.layout {\n-        layout::Univariant(_) => {\n+        layout::Univariant => {\n             let is_enum = if let ty::TyAdt(def, _) = t.sty {\n                 def.is_enum()\n             } else {\n@@ -100,7 +100,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return cx.llvm_type_of(value.to_ty(cx.tcx()));\n     }\n     match *l.layout {\n-        layout::Univariant(_) => {\n+        layout::Univariant => {\n             match name {\n                 None => {\n                     Type::struct_(cx, &struct_llfields(cx, l), l.is_packed())\n@@ -152,11 +152,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n-    let field_index_by_increasing_offset = match *layout.layout {\n-        layout::Univariant(ref variant) => variant.field_index_by_increasing_offset(),\n-        _ => bug!(\"unexpected {:#?}\", layout)\n-    };\n-    for i in field_index_by_increasing_offset {\n+    for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(cx, i);\n         let target_offset = layout.fields.offset(i as usize);\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\","}, {"sha": "d7397e359a148266e811d947e38685593f718c5b", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -64,8 +64,8 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n     let layout = ccx.layout_of(ty);\n     match *layout.layout {\n-        Layout::FatPointer { .. } => true,\n-        Layout::Univariant(_) => {\n+        Layout::FatPointer => true,\n+        Layout::Univariant => {\n             // There must be only 2 fields.\n             if layout.fields.count() != 2 {\n                 return false;"}, {"sha": "5948c3a3e592648102347daf131dab9bb9f43cee", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -1159,7 +1159,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 }).collect()\n             },\n-            layout::Univariant(_) => {\n+            layout::Univariant => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n@@ -1194,7 +1194,6 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             layout::NullablePointer {\n                 nndiscr,\n                 discr,\n-                discr_offset,\n                 ..\n             } => {\n                 let variant = self.type_rep.for_variant(nndiscr as usize);\n@@ -1239,7 +1238,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 }\n                 compute_field_path(cx, &mut name,\n                                    self.type_rep,\n-                                   discr_offset,\n+                                   self.type_rep.fields.offset(0),\n                                    discr.size(cx));\n                 name.push_str(&adt.variants[(1 - nndiscr) as usize].name.as_str());\n "}, {"sha": "ae19c865d1c933841a544710fc8a6221216c886f", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -1117,11 +1117,11 @@ fn trans_const_adt<'a, 'tcx>(\n \n             Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n         }\n-        layout::Univariant(_) => {\n+        layout::Univariant => {\n             assert_eq!(variant_index, 0);\n             build_const_struct(ccx, l, vals, None)\n         }\n-        layout::Vector { .. } => {\n+        layout::Vector => {\n             Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n         }\n         layout::NullablePointer { nndiscr, .. } => {\n@@ -1162,11 +1162,7 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         offset = ccx.size_of(discr.ty);\n     }\n \n-    let field_index_by_increasing_offset = match *layout.layout {\n-        layout::Univariant(ref variant) => variant.field_index_by_increasing_offset(),\n-        _ => bug!(\"unexpected {:#?}\", layout)\n-    };\n-    let parts = field_index_by_increasing_offset.map(|i| {\n+    let parts = layout.fields.index_by_increasing_offset().map(|i| {\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {"}, {"sha": "bd37bfb01d71aae8ff4798275722c3e5e4630077", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "patch": "@@ -240,25 +240,18 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n         if let layout::Abi::Scalar(_) = self.abi {\n             bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);\n         }\n+        let index = self.fields.memory_index(index);\n         match *self.layout {\n-            Layout::Scalar { .. } |\n-            Layout::UntaggedUnion { .. } |\n-            Layout::NullablePointer { .. } |\n-            Layout::General { .. } => {\n-                bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n-            }\n-\n-            Layout::Vector { .. } |\n-            Layout::Array { .. } => {\n+            Layout::Vector | Layout::Array => {\n                 index as u64\n             }\n \n-            Layout::FatPointer { .. } => {\n+            Layout::FatPointer | Layout::Univariant => {\n                 adt::memory_index_to_gep(index as u64)\n             }\n \n-            Layout::Univariant(ref variant) => {\n-                adt::memory_index_to_gep(variant.memory_index[index] as u64)\n+            _ => {\n+                bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n         }\n     }"}]}