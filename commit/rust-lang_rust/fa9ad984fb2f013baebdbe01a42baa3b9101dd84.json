{"sha": "fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOWFkOTg0ZmIyZjAxM2JhZWJkYmUwMWE0MmJhYTNiOTEwMWRkODQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-14T00:25:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-14T00:34:50Z"}, "message": "Copy first batch of material from libstd to libcore.", "tree": {"sha": "49115690e45ca322337b93f25308cd618f85b013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49115690e45ca322337b93f25308cd618f85b013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "html_url": "https://github.com/rust-lang/rust/commit/fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32087f5c2a35bf8050067c22a57fd60269633a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/32087f5c2a35bf8050067c22a57fd60269633a60", "html_url": "https://github.com/rust-lang/rust/commit/32087f5c2a35bf8050067c22a57fd60269633a60"}], "stats": {"total": 6305, "additions": 5582, "deletions": 723}, "files": [{"sha": "aefa9a6182b5992c4a6ec34c4f3d11ffc679edc0", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,13 +6,13 @@ import rustc::syntax::parse::parser;\n import std::fs;\n import std::generic_os;\n import std::io;\n-import std::option;\n-import std::option::{none, some};\n+import option;\n+import option::{none, some};\n import std::os;\n import std::run;\n-import std::str;\n+import str;\n import std::tempfile;\n-import std::vec;\n+import vec;\n \n type cargo = {\n     root: str,"}, {"sha": "a451d9dbacc682d7e9f86b983bedf29e764d52c9", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,10 +5,10 @@ import front::attr;\n import middle::ty;\n import metadata::{encoder, cstore};\n import middle::trans_common::crate_ctxt;\n-import std::str;\n+import str;\n import std::fs;\n-import std::vec;\n-import std::option;\n+import vec;\n+import option;\n import std::run;\n import option::some;\n import option::none;\n@@ -32,7 +32,7 @@ tag output_type {\n \n fn llvm_err(sess: session::session, msg: str) unsafe {\n     let buf = llvm::LLVMRustGetLastError();\n-    if buf == std::ptr::null() {\n+    if buf == ptr::null() {\n         sess.fatal(msg);\n     } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n }"}, {"sha": "a3b662e243f42e8e56d01a20a34305b1182bbca0", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n import std::os;\n import std::fs;\n import std::os_fs;\n-import std::vec;\n+import vec;\n import std::map;\n import std::math;\n-import std::str;\n-import std::uint;\n+import str;\n+import uint;\n import metadata::cstore;\n import driver::session;\n import util::filesearch;"}, {"sha": "9c2fabdb565ebe348d8fc3f517b96b8bf1bd6401", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -10,9 +10,10 @@ import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n-import std::{fs, option, str, vec, int, io, getopts, result};\n-import std::option::{some, none};\n-import std::getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n+import core::{option, str, vec, int, result};\n+import std::{fs, io, getopts};\n+import option::{some, none};\n+import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n \n tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n@@ -104,7 +105,7 @@ fn time<T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n     log_err #fmt[\"time: %s took %s s\", what,\n-                 std::float::to_str(end - start, 3u)];\n+                 float::to_str(end - start, 3u)];\n     ret rv;\n }\n "}, {"sha": "f2d19f09965a607fbd4cb1880ea163f7be56f5dd", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,8 +3,8 @@ import syntax::{ast, codemap};\n import syntax::ast::node_id;\n import codemap::span;\n import syntax::ast::{int_ty, uint_ty, float_ty};\n-import std::{option};\n-import std::option::{some, none};\n+import option;\n+import option::{some, none};\n import syntax::parse::parser::parse_sess;\n import util::filesearch;\n import back::target_strs;"}, {"sha": "0f0d21f695b16454d5dde1edf831cdf4bfe9043c", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n // Functions dealing with attributes and meta_items\n \n-import std::{either, vec, map, option};\n+import core::{either, vec, option};\n+import std::map;\n import syntax::{ast, ast_util};\n import driver::session;\n "}, {"sha": "f58f8d0b97a662607d48e70d6290f50c899d5d83", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{vec, option};\n+import core::{vec, option};\n import syntax::{ast, fold};\n import attr;\n "}, {"sha": "4756ee0b83ef4ba58feec121dc5146f4debdf6be", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // Code that generates a test runner to run all the tests in a crate\n \n-import std::{option, vec};\n+import core::{option, vec};\n import syntax::{ast, ast_util};\n import syntax::ast_util::*;\n //import syntax::ast_util::dummy_sp;"}, {"sha": "9ff014699abcc4f7507747f25b3f8aa33f5c0492", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, str, option};\n-import std::str::sbuf;\n+import core::{vec, str, option};\n+import str::sbuf;\n \n import llvm::{TypeRef, MemoryBufferRef,\n               PassManagerRef, TargetDataRef,\n@@ -960,7 +960,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       5 { ret \"PPC_FP128\"; }\n       6 { ret \"Label\"; }\n       7 {\n-        ret \"i\" + std::int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n+        ret \"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n       8 {\n         let s = \"fn(\";\n@@ -996,7 +996,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                ret \"*\\\\\" + std::int::str(n as int);\n+                ret \"*\\\\\" + int::str(n as int);\n             }\n         }\n         ret \"*\" +"}, {"sha": "60b1236398e1ec46bf5c86986a9cbce0c11cf4a1", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // EBML tag definitions and utils shared by the encoder and decoder\n \n-import std::str;\n+import str;\n \n const tag_paths: uint = 0x01u;\n "}, {"sha": "34da777a864357f8a5e8d0a656728c10a6e04cc6", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -7,8 +7,9 @@ import front::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import util::{filesearch};\n-import std::{either, vec, str, fs, io, option};\n-import std::option::{none, some};\n+import core::{either, vec, str, option};\n+import std::{io, fs};\n+import option::{none, some};\n import std::map::{hashmap, new_int_hash};\n import syntax::print::pprust;\n import common::*;\n@@ -206,7 +207,7 @@ fn get_metadata_section(sess: session::session,\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             unsafe {\n-                let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);\n+                let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n                 ret option::some::<@[u8]>(@vec::unsafe::from_buf(cvbuf, csz));\n             }\n         }"}, {"sha": "48b9774db51950204c350fa6c8fedb447c563b68", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n import syntax::ast;\n import middle::ty;\n-import std::option;\n+import option;\n import driver::session;\n \n export get_symbol;"}, {"sha": "de74591c814eec0767e14ef747a6991f20e1d15f", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,8 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-import std::{vec, map, str};\n+import core::{vec, str};\n+import std::map;\n import syntax::ast;\n \n export cstore;"}, {"sha": "bd8c02d0cb7adf1492259be7f31097920cdd5ad7", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n // Decoding metadata from a single crate's metadata\n \n-import std::{ebml, vec, option, str, io};\n+import core::{vec, option, str};\n+import std::{ebml, io};\n import syntax::{ast, ast_util};\n import front::attr;\n import middle::ty;"}, {"sha": "150c241ff60360a459e04ff4ce6139065f263b0d", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n // Metadata encoding\n \n-import std::{vec, str, uint, io, ebml, map};\n+import core::{vec, str, uint};\n+import std::{io, ebml, map};\n import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::local_def;"}, {"sha": "0bf44376b63239134f7d6c82567ad3fc66a29c16", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // Type decoding\n \n-import std::{vec, str, uint};\n-import std::option::{none, some};\n+import core::{vec, str, uint};\n+import option::{none, some};\n import syntax::ast;\n import syntax::ast::*;\n import syntax::ast_util;"}, {"sha": "9fb37e4f4bfe8b798840340cb8c1c116642dafb6", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,9 @@\n // Type encoding\n \n-import std::{io, int, uint};\n+import core::{int, uint};\n+import std::io;\n import std::map::hashmap;\n-import std::option::{some, none};\n+import option::{some, none};\n import syntax::ast::*;\n import middle::ty;\n import syntax::print::pprust::*;"}, {"sha": "6600bf566afe6b191a56a851f447110897bba333", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,8 +4,9 @@ import ast::{ident, fn_ident, node_id};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::{vec, option, list};\n-import std::option::{some, none, is_none};\n+import core::{vec, option};\n+import std::list;\n+import option::{some, none, is_none};\n import list::list;\n \n // This is not an alias-analyser (though it would merit from becoming one, or"}, {"sha": "a86208dd8c6c9d594e5816d2b726c76b6dfe277e", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,5 @@\n-import std::{smallintmap, option};\n+import option;\n+import std::smallintmap;\n import syntax::ast::*;\n import syntax::ast_util;\n import syntax::{visit, codemap};"}, {"sha": "0783504b682c4c986262d59f2ca3132d1314783a", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@ import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit_exprs,\n                           lit_expr_eq};\n import syntax::visit;\n-import std::option::{some, none};\n+import option::{some, none};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     let v =\n@@ -25,7 +25,7 @@ fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n             let reachable = true;\n             let j = 0;\n             while j < i {\n-                if std::option::is_none(arms[j].guard) {\n+                if option::is_none(arms[j].guard) {\n                     for prev_pat: @pat in arms[j].pats {\n                         if pattern_supersedes(tcx, prev_pat, arm_pat) {\n                             reachable = false;\n@@ -149,7 +149,7 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       }\n       pat_tag(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if std::vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n+        if vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         false\n       }"}, {"sha": "1bf9533f0803cd9074a5409dc0ffc44175d7195a", "filename": "src/comp/middle/fn_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffn_usage.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n import syntax::ast;\n import syntax::visit;\n-import std::option::some;\n+import option::some;\n import syntax::print::pprust::expr_to_str;\n \n export check_crate_fn_usage;"}, {"sha": "decdc220d16797c36d504a852d97ab98ec132e2c", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n // A pass that annotates for each loops and functions with the free\n // variables that they contain.\n \n-import std::{int};\n+import int;\n import std::map::*;\n-import std::option::*;\n+import option::*;\n import syntax::{ast, ast_util, visit};\n import middle::resolve;\n import syntax::codemap::span;\n@@ -101,7 +101,7 @@ fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     }\n }\n fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n-    ret std::vec::len(*get_freevars(tcx, fid)) != 0u;\n+    ret vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n \n // Local Variables:"}, {"sha": "f98bd259d4df85b00a887450d6252dbde8d55d4c", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,8 +6,8 @@ import middle::trans;\n import middle::trans::{get_tydesc, tps_normal};\n import middle::trans_common::*;\n import middle::ty;\n-import std::option::none;\n-import std::str;\n+import option::none;\n+import str;\n \n import lll = lib::llvm::llvm;\n import bld = trans_build;"}, {"sha": "d771ba65faf7aa32afbb606b1d047f86b2bd929f", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::option::{some, none};\n+import option::{some, none};\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n@@ -64,7 +64,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f } };\n             for tf in ty_fields {\n-                if !std::vec::any({|f| f.node.ident == tf.ident}, fields) &&\n+                if !vec::any({|f| f.node.ident == tf.ident}, fields) &&\n                    ty::type_kind(cx.tcx, tf.mt.ty) == kind_noncopyable {\n                     cx.tcx.sess.span_err(ex.span,\n                                          \"copying a noncopyable value\");"}, {"sha": "fac179f386f468957ee03e5470e671ef11b895c9", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,8 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import std::list::{list, nil, cons, tail};\n-import std::{vec, list, option};\n+import core::{vec, option};\n+import std::list;\n \n // Last use analysis pass.\n //"}, {"sha": "adf6fe3e0ee624b8a740bb3a2853e3c4c1b2c478", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{vec, str, option};\n+import core::{vec, str, option};\n import option::{some, none};\n import syntax::ast::*;\n import syntax::visit;"}, {"sha": "1fe94a14345620e7be4fc24fe7d6a186771d8366", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -11,10 +11,11 @@ import std::map::{new_int_hash, new_str_hash};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::{vec, list, option, str};\n+import core::{vec, option, str};\n+import std::list;\n import std::map::hashmap;\n import std::list::{list, nil, cons};\n-import std::option::{some, none, is_none};\n+import option::{some, none, is_none};\n import syntax::print::pprust::*;\n \n export resolve_crate;"}, {"sha": "a84b9095a8238c084033f486b3d8bac71a6ca67f", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -14,9 +14,9 @@ import syntax::ast_util::dummy_sp;\n import syntax::util::interner;\n import util::common;\n \n-import std::{vec, str};\n+import core::{vec, str};\n import std::map::hashmap;\n-import std::option::{none, some};\n+import option::{none, some};\n \n import ty_ctxt = middle::ty::ctxt;\n "}, {"sha": "69f232045f202da514ee9f4b6c5c0e2700779baf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -12,10 +12,12 @@\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n-import std::{either, str, uint, map, option, time, vec};\n+\n+import core::{either, str, uint, option, vec};\n+import std::{map, time};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};\n-import std::option::{some, none};\n+import option::{some, none};\n import driver::session;\n import front::attr;\n import middle::{ty, gc};\n@@ -205,7 +207,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n \n fn type_of_tag(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-    let degen = std::vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    let degen = vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if check type_has_static_size(cx, t) {\n         let size = static_size_of_tag(cx, sp, t);\n         if !degen { T_tag(cx, size) }\n@@ -225,7 +227,7 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) {\n         check returns_non_ty_var(cx, t);\n-        ret type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n+        ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.kinds));\n       }\n       _ {\n         // fall through\n@@ -328,7 +330,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n-    let inputs = std::vec::init_elt::<TypeRef>(ccx.int_type, n_args as uint);\n+    let inputs = vec::init_elt::<TypeRef>(ccx.int_type, n_args as uint);\n     let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n@@ -337,7 +339,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n                      llmod: ModuleRef, name: str, args: [ValueRef]) ->\n    ValueRef {\n-    let n: int = std::vec::len::<ValueRef>(args) as int;\n+    let n: int = vec::len::<ValueRef>(args) as int;\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n@@ -600,7 +602,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         }\n         let max_size_val = Load(bcx, max_size);\n         let total_size =\n-            if std::vec::len(variants) != 1u {\n+            if vec::len(variants) != 1u {\n                 Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n@@ -693,7 +695,7 @@ fn GEP_tup_like(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n \n     fn split_type(ccx: @crate_ctxt, t: ty::t, ixs: [int], n: uint) ->\n        {prefix: [ty::t], target: ty::t} {\n-        let len: uint = std::vec::len::<int>(ixs);\n+        let len: uint = vec::len::<int>(ixs);\n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n         // values for the 0th index (we don't).\n@@ -972,8 +974,8 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // promising to do so itself.\n     let n_params = ty::count_ty_params(bcx_tcx(bcx), t);\n \n-    assert (n_params == std::vec::len::<uint>(tys.params));\n-    assert (n_params == std::vec::len::<ValueRef>(tys.descs));\n+    assert (n_params == vec::len::<uint>(tys.params));\n+    assert (n_params == vec::len::<ValueRef>(tys.descs));\n \n     let llparamtydescs =\n         alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type), n_params + 1u));\n@@ -1042,7 +1044,7 @@ fn get_tydesc(cx: @block_ctxt, orig_t: ty::t, escapes: bool,\n                                           \"orig_t = \" +\n                                           ty_to_str(bcx_tcx(cx), orig_t) +\n                                           \" ty_param = \" +\n-                                          std::uint::str(id));\n+                                          uint::str(id));\n         }\n       }\n       none. {/* fall through */ }\n@@ -1192,15 +1194,15 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n             T_ptr(type_of(ccx, sp, t))\n         } else { T_ptr(T_i8()) };\n \n-    let ty_param_count = std::vec::len::<uint>(ty_params);\n+    let ty_param_count = vec::len::<uint>(ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 2u);\n     let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n         let llparam = GEPi(load_env_bcx, lltyparams, [p as int]);\n         llparam = Load(load_env_bcx, llparam);\n-        std::vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n+        vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n         p += 1u;\n     }\n \n@@ -1453,7 +1455,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     // for type variables.\n     let val_llty = lib::llvm::fn_ty_param_tys\n         (llvm::LLVMGetElementType\n-         (llvm::LLVMTypeOf(dtor_addr)))[std::vec::len(args)];\n+         (llvm::LLVMTypeOf(dtor_addr)))[vec::len(args)];\n     let val_cast = BitCast(cx, val.val, val_llty);\n     Call(cx, dtor_addr, args + [val_cast]);\n \n@@ -1608,7 +1610,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: ty::variant_info, tps: [ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> @block_ctxt {\n-        if std::vec::len::<ty::t>(variant.args) == 0u { ret cx; }\n+        if vec::len::<ty::t>(variant.args) == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n         let cx = cx;\n@@ -1667,7 +1669,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n-        let n_variants = std::vec::len(variants);\n+        let n_variants = vec::len(variants);\n \n         // Cast the tags to types we can GEP into.\n         if n_variants == 1u {\n@@ -2351,8 +2353,8 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n-            if std::vec::len(variants) != 1u ||\n-                   std::vec::len(variants[0].args) != 1u {\n+            if vec::len(variants) != 1u ||\n+                   vec::len(variants[0].args) != 1u {\n                 break;\n             }\n             t1 =\n@@ -2580,9 +2582,9 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     // Make a vector that contains ty_param_count copies of tydesc_ty.\n     // (We'll need room for that many tydescs in the closure.)\n-    let ty_param_count = std::vec::len(lltydescs);\n+    let ty_param_count = vec::len(lltydescs);\n     let tydesc_ty: ty::t = ty::mk_type(tcx);\n-    let captured_tys: [ty::t] = std::vec::init_elt(tydesc_ty, ty_param_count);\n+    let captured_tys: [ty::t] = vec::init_elt(tydesc_ty, ty_param_count);\n \n     // Get all the types we've got (some of which we synthesized\n     // ourselves) into a vector.  The whole things ends up looking\n@@ -2746,7 +2748,7 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let tydesc_count = std::vec::len(enclosing_cx.fcx.lltydescs);\n+    let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n     let lltydescs = find_environment_tydescs(bcx, envty, llclosure);\n     let i = 0u;\n     while i < tydesc_count {\n@@ -2854,7 +2856,7 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n     };\n     let tys = ty::node_id_to_type_params(bcx_tcx(bcx), id);\n     let gen = none, bcx = bcx;\n-    if std::vec::len::<ty::t>(tys) != 0u {\n+    if vec::len::<ty::t>(tys) != 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n             // TODO: Doesn't always escape.\n@@ -2950,7 +2952,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let bcx = alloc_result.bcx;\n             let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n             let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n-            let d = if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n+            let d = if vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n                 let lldiscrim = Load(bcx, lldiscrim_gv);\n                 lldiscrim\n@@ -3166,8 +3168,8 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     alt c.generic {\n       some(gi) {\n-        let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n-        let args = std::vec::init_elt(none::<@ast::expr>, n_args);\n+        let n_args = vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n+        let args = vec::init_elt(none::<@ast::expr>, n_args);\n         let space = alloc_ty(c.bcx, ty);\n         let bcx = trans_bind_1(space.bcx, ty, c, args, ty,\n                                save_in(space.val));\n@@ -3490,8 +3492,8 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n       }\n     }\n \n-    let ty_param_count = std::vec::len(lltydescs);\n-    if std::vec::len(bound) == 0u && ty_param_count == 0u {\n+    let ty_param_count = vec::len(lltydescs);\n+    if vec::len(bound) == 0u && ty_param_count == 0u {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n@@ -4598,9 +4600,9 @@ fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n    @block_ctxt {\n     if bcx.unreachable { ret bcx; }\n     if cleanup_cx.kind == NON_SCOPE_BLOCK {\n-        assert (std::vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n+        assert (vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n     }\n-    let i = std::vec::len::<cleanup>(cleanup_cx.cleanups), bcx = bcx;\n+    let i = vec::len::<cleanup>(cleanup_cx.cleanups), bcx = bcx;\n     while i > 0u {\n         i -= 1u;\n         let c = cleanup_cx.cleanups[i];\n@@ -4913,7 +4915,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     // its magic.\n \n     let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n-    let n_typarams = std::vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n+    let n_typarams = vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(ccx, n_typarams);\n     let box_cell = GEPi(bcx, llself.v, [0, abi::obj_field_box]);\n     let box_ptr = Load(bcx, box_cell);\n@@ -5073,7 +5075,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                      ty_params: [ast::ty_param]) {\n     let ccx = cx.ccx;\n \n-    if std::vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n+    if vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n \n     }\n@@ -5474,7 +5476,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n       }\n       ast::item_tag(variants, tps) {\n         let sub_cx = extend_path(cx, item.ident);\n-        let degen = std::vec::len(variants) == 1u;\n+        let degen = vec::len(variants) == 1u;\n         let i = 0;\n         for variant: ast::variant in variants {\n             trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n@@ -5522,7 +5524,7 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n     : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n     let llfty =\n-        type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n+        type_of_fn_from_ty(ccx, sp, node_type, vec::len(ty_params));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n@@ -5543,7 +5545,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n     let main_takes_argv =\n         alt ty::struct(ccx.tcx, main_node_type) {\n-          ty::ty_fn(_, args, _, _, _) { std::vec::len(args) != 0u }\n+          ty::ty_fn(_, args, _, _, _) { vec::len(args) != 0u }\n         };\n \n     let llfn = create_main(ccx, sp, main_llfn, main_takes_argv);\n@@ -5645,7 +5647,7 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n                         actually a fn\");\n       }\n       ast::native_item_fn(_, tps) {\n-        count = std::vec::len::<ast::ty_param>(tps);\n+        count = vec::len::<ast::ty_param>(tps);\n       }\n     }\n     ret count;\n@@ -5812,7 +5814,7 @@ fn collect_tag_ctor(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n     alt i.node {\n       ast::item_tag(variants, tps) {\n         for variant: ast::variant in variants {\n-            if std::vec::len(variant.node.args) != 0u {\n+            if vec::len(variant.node.args) != 0u {\n                 register_fn(ccx, i.span, new_pt + [variant.node.name],\n                             \"tag\", tps, variant.node.id);\n             }\n@@ -5838,7 +5840,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n     alt it.node {\n       ast::item_tag(variants, _) {\n         let i = 0u;\n-        let n_variants = std::vec::len::<ast::variant>(variants);\n+        let n_variants = vec::len::<ast::variant>(variants);\n         while i < n_variants {\n             let variant = variants[i];\n             let p = new_pt + [it.ident, variant.node.name, \"discrim\"];"}, {"sha": "8ca7adcfe26d980843d98d0d380ad03d766b85fc", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{str, vec, option};\n+import core::{str, vec, option};\n import option::{some, none};\n \n import lib::llvm::llvm;"}, {"sha": "210626deffbe80720f1a73514478270ab8bb67fc", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, str};\n-import std::str::sbuf;\n+import core::{vec, str};\n+import str::sbuf;\n import lib::llvm::llvm;\n import syntax::codemap::span;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n@@ -84,7 +84,7 @@ fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n // lot more efficient) than doing str::as_buf(\"\", ...) every time.\n fn noname() -> sbuf unsafe {\n     const cnull: uint = 0u;\n-    ret std::unsafe::reinterpret_cast(std::ptr::addr_of(cnull));\n+    ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n \n fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n@@ -491,8 +491,8 @@ fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     if llvm::LLVMIsUndef(phi) == lib::llvm::True { ret; }\n     unsafe {\n-        let valptr = std::unsafe::reinterpret_cast(std::ptr::addr_of(val));\n-        let bbptr = std::unsafe::reinterpret_cast(std::ptr::addr_of(bb));\n+        let valptr = unsafe::reinterpret_cast(ptr::addr_of(val));\n+        let bbptr = unsafe::reinterpret_cast(ptr::addr_of(bb));\n         llvm::LLVMAddIncoming(phi, valptr, bbptr, 1u);\n     }\n }"}, {"sha": "5cad1197b1d35ef0f7d43f34b779fe217c8f7938", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,10 +3,10 @@\n \n */\n \n-import std::{int, vec, str, uint, option, unsafe};\n-import std::vec::to_ptr;\n+import core::{int, vec, str, uint, option, unsafe};\n+import vec::to_ptr;\n import std::map::hashmap;\n-import std::option::some;\n+import option::some;\n import syntax::ast;\n import driver::session;\n import middle::ty;\n@@ -301,9 +301,9 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n     if found == -1 { ret; }\n     // We found the cleanup and remove it\n     sc_cx.cleanups =\n-        std::vec::slice(sc_cx.cleanups, 0u, found as uint) +\n-            std::vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n-                            std::vec::len(sc_cx.cleanups));\n+        vec::slice(sc_cx.cleanups, 0u, found as uint) +\n+            vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n+                            vec::len(sc_cx.cleanups));\n     sc_cx.lpad_dirty = true;\n     ret;\n }\n@@ -411,7 +411,7 @@ fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n     let elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n     assert (n < elt_count);\n-    let elt_tys = std::vec::init_elt(T_nil(), elt_count);\n+    let elt_tys = vec::init_elt(T_nil(), elt_count);\n     llvm::LLVMGetStructElementTypes(llstructty, to_ptr(elt_tys));\n     ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n@@ -531,7 +531,7 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n     unsafe {\n         ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                   std::vec::len::<TypeRef>(inputs), False);\n+                                   vec::len::<TypeRef>(inputs), False);\n     }\n }\n \n@@ -543,7 +543,7 @@ fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n fn T_struct(elts: [TypeRef]) -> TypeRef {\n     unsafe {\n-        ret llvm::LLVMStructType(to_ptr(elts), std::vec::len(elts), False);\n+        ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n     }\n }\n \n@@ -553,7 +553,7 @@ fn T_named_struct(name: str) -> TypeRef {\n }\n \n fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n-    llvm::LLVMStructSetBody(t, to_ptr(elts), std::vec::len(elts), False);\n+    llvm::LLVMStructSetBody(t, to_ptr(elts), vec::len(elts), False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -595,7 +595,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n-        std::vec::init_elt::<TypeRef>(T_nil(),\n+        vec::init_elt::<TypeRef>(T_nil(),\n                                       abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     to_ptr::<TypeRef>(tydesc_elts));\n@@ -733,7 +733,7 @@ fn T_opaque_tag_ptr(cx: @crate_ctxt) -> TypeRef {\n }\n \n fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n-    ret T_struct(std::vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n+    ret T_struct(vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n }\n \n fn T_obj_ptr(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n@@ -823,23 +823,23 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let i = 0u;\n     let elts: [ValueRef] = [];\n     while i < size { elts += [C_u8(0u)]; i += 1u; }\n-    ret llvm::LLVMConstArray(T_i8(), std::vec::to_ptr(elts),\n-                             std::vec::len(elts));\n+    ret llvm::LLVMConstArray(T_i8(), vec::to_ptr(elts),\n+                             vec::len(elts));\n }\n \n fn C_struct(elts: [ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstStruct(std::vec::to_ptr(elts), std::vec::len(elts),\n+    ret llvm::LLVMConstStruct(vec::to_ptr(elts), vec::len(elts),\n                               False);\n }\n \n fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstNamedStruct(T, std::vec::to_ptr(elts),\n-                                   std::vec::len(elts));\n+    ret llvm::LLVMConstNamedStruct(T, vec::to_ptr(elts),\n+                                   vec::len(elts));\n }\n \n fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstArray(ty, std::vec::to_ptr(elts),\n-                             std::vec::len(elts));\n+    ret llvm::LLVMConstArray(ty, vec::to_ptr(elts),\n+                             vec::len(elts));\n }\n \n fn C_bytes(bytes: [u8]) -> ValueRef unsafe {"}, {"sha": "4b8795deea8fcdca6c07ca5e7b069ae1db8a13ec", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // Translation of object-related things to LLVM IR.\n \n-import std::{str, option, vec};\n+import core::{str, option, vec};\n import option::{none, some};\n \n import lib::llvm::{llvm, True};"}, {"sha": "dba2b67410ec9a29e39a24c639ca08ef4820266b", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::vec;\n-import std::option::none;\n+import vec;\n+import option::none;\n import syntax::ast;\n import lib::llvm::llvm::{ValueRef, TypeRef};\n import back::abi;\n@@ -131,7 +131,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n }\n \n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n-    let veclen = std::str::byte_len(s) + 1u; // +1 for \\0\n+    let veclen = str::byte_len(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n "}, {"sha": "0ca72c569a2ffbda88ebba502527199d594d925f", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n \n-import std::{int, uint};\n+import core::{int, uint};\n import syntax::ast::*;\n import syntax::ast_util::pat_binding_ids;\n import syntax::visit;"}, {"sha": "ec1c268e77541b91826f6c0aebbc9ff9e893abd6", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, int, uint, option};\n-import std::option::*;\n+import core::{vec, int, uint, option};\n+import option::*;\n import syntax::ast::*;\n import syntax::ast_util::*;\n import syntax::codemap::span;\n@@ -989,7 +989,7 @@ fn args_mention<T>(args: [@constr_arg_use], q: fn([T], node_id) -> bool,\n \n fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n \n-// FIXME: This should be a function in std::vec::.\n+// FIXME: This should be a function in vec::.\n fn vec_contains(v: @mutable [node_id], i: node_id) -> bool {\n     for d: node_id in *v { if d == i { ret true; } }\n     ret false;"}, {"sha": "9cfe4e3c178135d80c902541a3b578f9ab2d607b", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n import syntax::ast::*;\n import syntax::visit;\n-import std::vec;\n-import std::option::*;\n+import vec;\n+import option::*;\n import aux::*;\n import tstate::ann::{pre_and_post, precond, postcond, prestate, poststate,\n                      relax_prestate, relax_precond, relax_poststate,"}, {"sha": "3fd1721c8f088a441b417b27d86cb878b1114595", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -9,7 +9,7 @@ import middle::ty::{type_is_nil, ret_ty_of_fn};\n import tstate::ann::{\n                      precond, prestate,\n                      implies, ann_precond, ann_prestate};\n-import std::{option};\n+import option;\n import aux::*;\n import syntax::print::pprust::ty_to_str;\n import bitvectors::*;"}, {"sha": "14999d8ad97113bc28c5f280c7b8876c8436c1fb", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n import syntax::ast::*;\n import syntax::ast_util::*;\n import util::ppaux::fn_ident_to_string;\n-import std::option::*;\n+import option::*;\n import syntax::visit;\n import aux::*;\n import util::common::new_def_hash;\n@@ -60,7 +60,7 @@ fn find_locals(tcx: ty::ctxt, f: _fn, tps: [ty_param], sp: span, i: fn_ident,\n \n fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n    uint {\n-    log constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n+    log constraint_to_str(tcx, c) + \" |-> \" + uint::str(next);\n     alt c.node {\n       ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n       npred(p, d_id, args) {\n@@ -142,7 +142,7 @@ fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n          i_diverge: ninit(diverges_id, diverges_name),\n          used_vars: v};\n     ccx.fm.insert(id, rslt);\n-    log name + \" has \" + std::uint::str(num_constraints(rslt)) +\n+    log name + \" has \" + uint::str(num_constraints(rslt)) +\n             \" constraints\";\n }\n "}, {"sha": "0663682884c970fa43791baee3fda9c5ce05d4a9", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n \n-import std::{vec, option};\n-import std::option::{none, some};\n+import core::{vec, option};\n+import option::{none, some};\n \n import tstate::ann::*;\n import aux::*;"}, {"sha": "1ac92efac692a1e30bca34561549dd2ccb1164d0", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, option};\n-import std::option::{none, some};\n+import core::{vec, option};\n+import option::{none, some};\n import ann::*;\n import aux::*;\n import tritv::{tritv_clone, tritv_set, ttrue};"}, {"sha": "bb6deac5a02b3d2597b2036dae35f6f742fc52df", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,13 +1,13 @@\n-import std::vec;\n-import std::str;\n-import std::uint;\n+import vec;\n+import str;\n+import uint;\n import std::ufind;\n import std::map;\n import std::map::hashmap;\n import std::math;\n-import std::option;\n-import std::option::none;\n-import std::option::some;\n+import option;\n+import option::none;\n+import option::some;\n import std::smallintmap;\n import driver::session;\n import syntax::ast;\n@@ -1471,7 +1471,7 @@ fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n     alt smallintmap::find(*cx.node_types, id as uint) {\n       none. {\n         cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n-                        \"an untyped node (\" + std::int::to_str(id, 10u) +\n+                        \"an untyped node (\" + int::to_str(id, 10u) +\n                         \")\");\n       }\n       some(tpot) { ret tpot; }\n@@ -2712,7 +2712,7 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> [variant_info] {\n             for variant: ast::variant in variants {\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n                 let arg_tys: [t] = [];\n-                if std::vec::len(variant.node.args) > 0u {\n+                if vec::len(variant.node.args) > 0u {\n                     for a: arg in ty_fn_args(cx, ctor_ty) {\n                         arg_tys += [a.ty];\n                     }"}, {"sha": "c8607fab723cba9bef422fea3554bece285811ac", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -12,9 +12,10 @@ import middle::ty::{node_id_to_type, arg, bind_params_in_type, block_ty,\n                     ty_param_substs_opt_and_ty, ty_param_kinds_and_ty};\n import util::ppaux::ty_to_str;\n import middle::ty::unify::{ures_ok, ures_err, fix_ok, fix_err};\n-import std::{int, vec, str, option, smallintmap};\n+import core::{int, vec, str, option};\n+import std::smallintmap;\n import std::map::{hashmap, new_int_hash};\n-import std::option::{none, some};\n+import option::{none, some};\n import syntax::print::pprust::*;\n \n export check_crate;\n@@ -1256,8 +1257,8 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n-            let subpats_len = std::vec::len::<@ast::pat>(subpats);\n-            if std::vec::len::<ty::t>(arg_types) > 0u {\n+            let subpats_len = vec::len::<@ast::pat>(subpats);\n+            if vec::len::<ty::t>(arg_types) > 0u {\n                 // N-ary variant.\n \n                 let arg_len = vec::len::<ty::t>(arg_types);\n@@ -2270,7 +2271,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n             let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n             inner_obj_methods =\n-                std::vec::filter_map::<ty::method,\n+                vec::filter_map::<ty::method,\n                                        ty::method>(f, inner_obj_methods);\n \n             method_types += inner_obj_methods;"}, {"sha": "a20d1ae5c6f5449128025c2f53b85eeacdf30405", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // The Rust abstract syntax tree.\n \n-import std::option;\n+import option;\n import codemap::{span, filename};\n \n type spanned<T> = {node: T, span: span};"}, {"sha": "2ab55edcb743f4d40e4b0dadd4ea395c1a6be0a0", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,5 @@\n-import std::{str, option, int, map};\n+import core::{str, option, int};\n+import std::map;\n import codemap::span;\n import ast::*;\n \n@@ -212,7 +213,7 @@ fn is_constraint_arg(e: @expr) -> bool {\n     }\n }\n \n-fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n+fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret box::ptr_eq(a, b); }\n \n fn hash_ty(&&t: @ty) -> uint {\n     let res = (t.span.lo << 16u) + t.span.hi;\n@@ -333,7 +334,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_str(s) { const_str(s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n-      lit_float(n, _) { const_float(std::float::from_str(n)) }\n+      lit_float(n, _) { const_float(float::from_str(n)) }\n       lit_nil. { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }"}, {"sha": "9725517ed285cdecff3471543131865ce549d94c", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,6 @@\n-import std::{vec, uint, str, term, io, option, result};\n-import std::option::{some, none};\n+import core::{vec, uint, str, option, result};\n+import std::{term, io};\n+import option::{some, none};\n \n type filename = str;\n "}, {"sha": "55294000f66f9a032d6db22b35966eec3495bc05", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{vec, option};\n+import core::{vec, option};\n import std::map::hashmap;\n import driver::session::session;\n import codemap::span;"}, {"sha": "c487a3ecc3612a85c4545326b92bacd9b72d7621", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::option;\n+import option;\n import base::*;\n import syntax::ast;\n "}, {"sha": "0b536159367830b20575e57c12cbf64bed5db884", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,7 +4,8 @@\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n-import std::{vec, option, generic_os};\n+import core::{vec, option};\n+import std::generic_os;\n import base::*;\n export expand_syntax_ext;\n "}, {"sha": "ef2105b4271b5818d450a5be2abff21155a3e7b8", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n import driver::session;\n \n-import std::option::{none, some};\n+import option::{none, some};\n \n import std::map::hashmap;\n-import std::{vec};\n+import vec;\n \n import syntax::ast::{crate, expr_, expr_mac, mac_invoc};\n import syntax::fold::*;"}, {"sha": "c8721d058a3423c448c331ef1293aa68089e72c3", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,9 +5,9 @@\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n-import std::{vec, str, option};\n-import std::option::{some};\n-import std::extfmt::ct::*;\n+import core::{vec, str, option};\n+import option::{some};\n+import extfmt::ct::*;\n import base::*;\n import codemap::span;\n export expand_syntax_ext;\n@@ -257,7 +257,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     }\n     fn log_conv(c: conv) {\n         alt c.param {\n-          some(p) { log \"param: \" + std::int::to_str(p, 10u); }\n+          some(p) { log \"param: \" + int::to_str(p, 10u); }\n           _ { log \"param: none\"; }\n         }\n         for f: flag in c.flags {\n@@ -270,17 +270,17 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             }\n         }\n         alt c.width {\n-          count_is(i) { log \"width: count is \" + std::int::to_str(i, 10u); }\n+          count_is(i) { log \"width: count is \" + int::to_str(i, 10u); }\n           count_is_param(i) {\n-            log \"width: count is param \" + std::int::to_str(i, 10u);\n+            log \"width: count is param \" + int::to_str(i, 10u);\n           }\n           count_is_next_param. { log \"width: count is next param\"; }\n           count_implied. { log \"width: count is implied\"; }\n         }\n         alt c.precision {\n-          count_is(i) { log \"prec: count is \" + std::int::to_str(i, 10u); }\n+          count_is(i) { log \"prec: count is \" + int::to_str(i, 10u); }\n           count_is_param(i) {\n-            log \"prec: count is param \" + std::int::to_str(i, 10u);\n+            log \"prec: count is param \" + int::to_str(i, 10u);\n           }\n           count_is_next_param. { log \"prec: count is next param\"; }\n           count_implied. { log \"prec: count is implied\"; }"}, {"sha": "d6093b61dbfd584be6e25c430434559ce6a04b6a", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{vec, option};\n+import core::{vec, option};\n import base::*;\n import syntax::ast;\n "}, {"sha": "40bc90e510d14449f4ddc3ded3f88ac29aebb7b7", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::{option};\n+import option;\n import base::*;\n import syntax::ast;\n "}, {"sha": "8243483f2c49fe97c0897052051278a370739ac5", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n import codemap::span;\n-import std::{vec, option};\n+import core::{vec, option};\n import std::map::{hashmap, new_str_hash};\n import option::{some, none};\n "}, {"sha": "fc1a45366fe79b3dcf36ccd0cec6c36ba73f3649", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n import syntax::codemap::span;\n import ast::*;\n \n-import std::{vec, option};\n+import core::{vec, option};\n \n export ast_fold_precursor;\n export ast_fold;"}, {"sha": "2b0fcab9b8e3f7e638ea791352657a72c73b6e99", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,8 @@\n \n import front::attr;\n-import std::{option, result, io, fs};\n-import std::option::{some, none};\n+import core::{option, result};\n+import std::{io, fs};\n+import option::{some, none};\n import syntax::ast;\n import syntax::parse::token;\n import syntax::parse::parser::{parser, new_parser_from_file,"}, {"sha": "299a7ecafeb8cfe8a22d882a9560589006f3314b", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n \n-import std::{io, vec, str, option, either};\n-import std::option::{some, none};\n+import core::{vec, str, option, either};\n+import std::io;\n+import option::{some, none};\n import util::interner;\n import util::interner::intern;\n import codemap;\n@@ -180,7 +181,7 @@ fn scan_digits(rdr: reader, radix: uint) -> str {\n     while true {\n         let c = rdr.curr();\n         if c == '_' { rdr.bump(); cont; }\n-        alt std::char::maybe_digit(c) {\n+        alt char::maybe_digit(c) {\n           some(d) when (d as uint) < radix {\n             str::push_byte(rslt, c as u8);\n             rdr.bump();\n@@ -232,7 +233,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n             tp = signed ? either::left(ast::ty_i64)\n                         : either::right(ast::ty_u64);\n         }\n-        let parsed = std::u64::from_str(num_str, base as u64);\n+        let parsed = u64::from_str(num_str, base as u64);\n         alt tp {\n           either::left(t) { ret token::LIT_INT(parsed as i64, t); }\n           either::right(t) { ret token::LIT_UINT(parsed, t); }\n@@ -276,7 +277,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         ret token::LIT_FLOAT(interner::intern(*rdr.get_interner(), num_str),\n                              ast::ty_f);\n     } else {\n-        let parsed = std::u64::from_str(num_str, base as u64);\n+        let parsed = u64::from_str(num_str, base as u64);\n         ret token::LIT_INT(parsed as i64, ast::ty_i);\n     }\n }"}, {"sha": "7ff08181e1a516cfc6c217b6c51d604153722ec9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,8 @@\n \n-import std::{io, vec, str, option, either, result, fs};\n-import std::option::{some, none};\n-import std::either::{left, right};\n+import core::{vec, str, option, either, result};\n+import std::{io, fs};\n+import option::{some, none};\n+import either::{left, right};\n import std::map::{hashmap, new_str_hash};\n import token::can_begin_expr;\n import codemap::span;"}, {"sha": "5ff688ecc6815fe930fc2798a743637c017f4f3a", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n \n import util::interner;\n-import std::{int, uint, str};\n+import core::{int, uint, str};\n \n type str_num = uint;\n "}, {"sha": "b870f9f93daba7b5464085253a9c34f984312598", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,6 @@\n \n-import std::{io, vec, str};\n+import core::{vec, str};\n+import std::io;\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's"}, {"sha": "f58bea2ee7455c363eff2f6a60087d987fc07264", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,6 @@\n \n-import std::{vec, int, io, str, uint, option};\n+import core::{vec, int, str, uint, option};\n+import std::io;\n import parse::lexer;\n import syntax::codemap::codemap;\n import ast;"}, {"sha": "2c1589085f2f6a9b86773713f07899bafec6d54d", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,10 @@\n // An \"interner\" is a data structure that associates values with uint tags and\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n-import std::{vec, map};\n+import core::vec;\n+import std::map;\n import std::map::{hashmap, hashfn, eqfn};\n-import std::option::{none, some};\n+import option::{none, some};\n \n type interner<T> =\n     {map: hashmap<T, uint>,"}, {"sha": "310d169805b0ac2d2da3a8c850374b232733a738", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n \n import ast::*;\n-import std::option;\n-import std::option::{none, some};\n+import option;\n+import option::{none, some};\n import codemap::span;\n \n "}, {"sha": "c9bf34d69c7e0ac9ad54d8b1315712779ea63282", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n-import std::{str, option};\n+import core::{str, option};\n import std::math::{max, min};\n import std::map::hashmap;\n-import std::option::{some};\n+import option::{some};\n import syntax::ast;\n import ast::{ty, pat};\n import syntax::codemap::{span};\n@@ -82,7 +82,7 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n }\n \n fn is_main_name(path: [ast::ident]) -> bool {\n-    str::eq(option::get(std::vec::last(path)), \"main\")\n+    str::eq(option::get(vec::last(path)), \"main\")\n }\n \n "}, {"sha": "de07a213a3fd0d577d8c66981f8a84da0d1c986b", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,9 +2,9 @@\n // FIXME: I'm not happy how this module turned out. Should probably\n // just be folded into cstore.\n \n-import std::option;\n+import core::option;\n import std::fs;\n-import std::vec;\n+import vec;\n import std::os;\n \n export filesearch;"}, {"sha": "540f8917f7d62849cf2f3112ae3ed60144a9cc82", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, str, int, option};\n-import std::option::{none, some};\n+import core::{vec, str, int, option};\n+import option::{none, some};\n import middle::ty;\n import middle::ty::*;\n import metadata::encoder;"}, {"sha": "0555fabbcdcd93b796c1f614a24dbd220d628774", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::option;\n+import option;\n \n tag mode { mode_compile_fail; mode_run_fail; mode_run_pass; mode_pretty; }\n "}, {"sha": "f85edd837824375ddf65698699a160a23f0c5248", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,18 +1,18 @@\n // FIXME: The way this module sets up tests is a relic and more convoluted\n // than it needs to be\n \n-import std::option;\n+import option;\n import std::getopts;\n import std::test;\n import std::fs;\n-import std::str;\n-import std::vec;\n-import std::task;\n-\n-import std::comm::port;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n+import str;\n+import vec;\n+import task;\n+\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n \n import common::cx;\n import common::config;"}, {"sha": "abc72c2bce28dca263c50a2714afe029133896d7", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n-import std::option;\n-import std::str;\n+import option;\n+import str;\n import std::io;\n import std::fs;\n \n@@ -63,7 +63,7 @@ fn is_test_ignored(config: config, testfile: str) -> bool {\n }\n \n fn iter_header(testfile: str, it: block(str)) {\n-    let rdr = std::result::get(io::file_reader(testfile));\n+    let rdr = result::get(io::file_reader(testfile));\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n "}, {"sha": "17f2c73906239f9cb3311547eddf9c99bad063be", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,20 +4,21 @@\n // child process. Because of that we have to use a complicated scheme with a\n // dedicated server for spawning processes.\n \n-import std::option;\n-import std::task;\n+import core::comm;\n+import core::option;\n+import task;\n import std::generic_os::setenv;\n import std::generic_os::getenv;\n-import std::vec;\n+import vec;\n import std::os;\n import std::run;\n import std::io;\n-import std::str;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n-import std::ctypes::{pid_t, fd_t};\n+import str;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n+import ctypes::{pid_t, fd_t};\n \n export handle;\n export mk;"}, {"sha": "199b4823248be7010e6a0565c534aaa5808c1b86", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,10 @@\n import std::io;\n-import std::str;\n-import std::option;\n+import str;\n+import option;\n import std::fs;\n import std::os;\n-import std::vec;\n-import std::result;\n+import vec;\n+import result;\n \n import common::mode_run_pass;\n import common::mode_run_fail;"}, {"sha": "bc830048979602a02f3d9d8033e6b3ada8c8fabb", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-import std::option;\n+import option;\n import std::generic_os::getenv;\n import std::io;\n "}, {"sha": "46d9613fbc7f3d375a7831854b4cd38769f1df16", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::vec;\n+import vec;\n \n fn vec_equal<T>(v: [T], u: [T], element_equality_test: fn(T, T) -> bool) ->\n    bool {"}, {"sha": "792d3b776861933e688748e908c283080eca1b9c", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n-import std::vec;\n+import vec;\n import std::rand;\n-import std::option;\n+import option;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint { assert n != 0u; r.next() as uint % n }"}, {"sha": "08b95b6163d59616c3df1a322dad227466e7605a", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,5 @@\n-import std::{fs, io, math, vec, str, int, uint, option, result};\n+import core::{vec, str, int, uint, option, result};\n+import std::{fs, io, math};\n \n import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n import rustc::syntax::parse::parser;"}, {"sha": "8fbdcc1e96ae7a34c92cf3ea7e346411f06d5d62", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -17,10 +17,10 @@ vec_edits is not an iter because iters might go away.\n */\n \n use std;\n-import std::vec;\n-import std::vec::slice;\n-import std::vec::len;\n-import std::int;\n+import vec;\n+import vec::slice;\n+import vec::len;\n+import int;\n \n fn vec_omit<T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))"}, {"sha": "a3194568882cd8e0959a98476b2c2ff11044b819", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::rand;\n-import std::vec;\n+import vec;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint { assert n != 0u; r.next() as uint % n }"}, {"sha": "0fc869d1b41a93b0b8077bcc30ce0a12a375cf93", "filename": "src/libcore/bool.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,134 @@\n+// -*- rust -*-\n+\n+/*\n+Module: bool\n+\n+Classic Boolean logic reified as ADT\n+*/\n+\n+export t;\n+export not, and, or, xor, implies;\n+export eq, ne, is_true, is_false;\n+export from_str, to_str, all_values, to_bit;\n+\n+/*\n+Type: t\n+\n+The type of boolean logic values\n+*/\n+type t = bool;\n+\n+/* Function: not\n+\n+Negation/Inverse\n+*/\n+pure fn not(v: t) -> t { !v }\n+\n+/* Function: and\n+\n+Conjunction\n+*/\n+pure fn and(a: t, b: t) -> t { a && b }\n+\n+/* Function: or\n+\n+Disjunction\n+*/\n+pure fn or(a: t, b: t) -> t { a || b }\n+\n+/*\n+Function: xor\n+\n+Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\n+*/\n+pure fn xor(a: t, b: t) -> t { (a && !b) || (!a && b) }\n+\n+/*\n+Function: implies\n+\n+Implication in the logic, i.e. from `a` follows `b`\n+*/\n+pure fn implies(a: t, b: t) -> t { !a || b }\n+\n+/*\n+Predicate: eq\n+\n+Returns:\n+\n+true if truth values `a` and `b` are indistinguishable in the logic\n+*/\n+pure fn eq(a: t, b: t) -> bool { a == b }\n+\n+/*\n+Predicate: ne\n+\n+Returns:\n+\n+true if truth values `a` and `b` are distinguishable in the logic\n+*/\n+pure fn ne(a: t, b: t) -> bool { a != b }\n+\n+/*\n+Predicate: is_true\n+\n+Returns:\n+\n+true if `v` represents truth in the logic\n+*/\n+pure fn is_true(v: t) -> bool { v }\n+\n+/*\n+Predicate: is_false\n+\n+Returns:\n+\n+true if `v` represents falsehood in the logic\n+*/\n+pure fn is_false(v: t) -> bool { !v }\n+\n+/*\n+Function: from_str\n+\n+Parse logic value from `s`\n+*/\n+pure fn from_str(s: str) -> t {\n+    alt s {\n+      \"true\" { true }\n+      \"false\" { false }\n+    }\n+}\n+\n+/*\n+Function: to_str\n+\n+Convert `v` into a string\n+*/\n+pure fn to_str(v: t) -> str { if v { \"true\" } else { \"false\" } }\n+\n+/*\n+Function: all_values\n+\n+Iterates over all truth values by passing them to `blk`\n+in an unspecified order\n+*/\n+fn all_values(blk: block(v: t)) {\n+    blk(true);\n+    blk(false);\n+}\n+\n+/*\n+Function: to_bit\n+\n+Returns:\n+\n+An u8 whose first bit is set if `if_true(v)` holds\n+*/\n+fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "6682fe17284ac429a2000635d04d02b418d8327f", "filename": "src/libcore/box.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,20 @@\n+/*\n+Module: box\n+*/\n+\n+\n+export ptr_eq;\n+\n+/*\n+Function: ptr_eq\n+\n+Determine if two shared boxes point to the same object\n+*/\n+fn ptr_eq<T>(a: @T, b: @T) -> bool {\n+    // FIXME: ptr::addr_of\n+    unsafe {\n+        let a_ptr: uint = unsafe::reinterpret_cast(a);\n+        let b_ptr: uint = unsafe::reinterpret_cast(b);\n+        ret a_ptr == b_ptr;\n+    }\n+}"}, {"sha": "5ff7681ae8ab484dc377d2f71541d5dcc24d283a", "filename": "src/libcore/char.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,150 @@\n+/*\n+Module: char\n+\n+Utilities for manipulating the char type\n+*/\n+\n+/*\n+Function: is_whitespace\n+\n+Indicates whether a character is whitespace.\n+\n+Whitespace characters include space (U+0020), tab (U+0009), line feed\n+(U+000A), carriage return (U+000D), and a number of less common\n+ASCII and unicode characters.\n+*/\n+pure fn is_whitespace(c: char) -> bool {\n+    const ch_space: char = '\\u0020';\n+    const ch_ogham_space_mark: char = '\\u1680';\n+    const ch_mongolian_vowel_sep: char = '\\u180e';\n+    const ch_en_quad: char = '\\u2000';\n+    const ch_em_quad: char = '\\u2001';\n+    const ch_en_space: char = '\\u2002';\n+    const ch_em_space: char = '\\u2003';\n+    const ch_three_per_em_space: char = '\\u2004';\n+    const ch_four_per_em_space: char = '\\u2005';\n+    const ch_six_per_em_space: char = '\\u2006';\n+    const ch_figure_space: char = '\\u2007';\n+    const ch_punctuation_space: char = '\\u2008';\n+    const ch_thin_space: char = '\\u2009';\n+    const ch_hair_space: char = '\\u200a';\n+    const ch_narrow_no_break_space: char = '\\u202f';\n+    const ch_medium_mathematical_space: char = '\\u205f';\n+    const ch_ideographic_space: char = '\\u3000';\n+    const ch_line_separator: char = '\\u2028';\n+    const ch_paragraph_separator: char = '\\u2029';\n+    const ch_character_tabulation: char = '\\u0009';\n+    const ch_line_feed: char = '\\u000a';\n+    const ch_line_tabulation: char = '\\u000b';\n+    const ch_form_feed: char = '\\u000c';\n+    const ch_carriage_return: char = '\\u000d';\n+    const ch_next_line: char = '\\u0085';\n+    const ch_no_break_space: char = '\\u00a0';\n+\n+    if c == ch_space {\n+        true\n+    } else if c == ch_ogham_space_mark {\n+        true\n+    } else if c == ch_mongolian_vowel_sep {\n+        true\n+    } else if c == ch_en_quad {\n+        true\n+    } else if c == ch_em_quad {\n+        true\n+    } else if c == ch_en_space {\n+        true\n+    } else if c == ch_em_space {\n+        true\n+    } else if c == ch_three_per_em_space {\n+        true\n+    } else if c == ch_four_per_em_space {\n+        true\n+    } else if c == ch_six_per_em_space {\n+        true\n+    } else if c == ch_figure_space {\n+        true\n+    } else if c == ch_punctuation_space {\n+        true\n+    } else if c == ch_thin_space {\n+        true\n+    } else if c == ch_hair_space {\n+        true\n+    } else if c == ch_narrow_no_break_space {\n+        true\n+    } else if c == ch_medium_mathematical_space {\n+        true\n+    } else if c == ch_ideographic_space {\n+        true\n+    } else if c == ch_line_tabulation {\n+        true\n+    } else if c == ch_paragraph_separator {\n+        true\n+    } else if c == ch_character_tabulation {\n+        true\n+    } else if c == ch_line_feed {\n+        true\n+    } else if c == ch_line_tabulation {\n+        true\n+    } else if c == ch_form_feed {\n+        true\n+    } else if c == ch_carriage_return {\n+        true\n+    } else if c == ch_next_line {\n+        true\n+    } else if c == ch_no_break_space { true } else { false }\n+}\n+\n+/*\n+ Function: to_digit\n+\n+ Convert a char to the corresponding digit.\n+\n+ Parameters:\n+   c - a char, either '0' to '9', 'a' to 'z' or 'A' to 'Z'\n+\n+ Returns:\n+   If `c` is between '0' and '9', the corresponding value between 0 and 9.\n+ If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc.\n+\n+ Safety note:\n+   This function fails if `c` is not a valid char\n+*/\n+pure fn to_digit(c: char) -> u8 unsafe {\n+    alt maybe_digit(c) {\n+      option::some(x) { x }\n+      option::none. { fail; }\n+    }\n+}\n+\n+/*\n+ Function: to_digit\n+\n+ Convert a char to the corresponding digit. Returns none when the\n+ character is not a valid hexadecimal digit.\n+*/\n+fn maybe_digit(c: char) -> option::t<u8> {\n+    alt c {\n+      '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n+      'a' to 'z' { option::some(c as u8 + 10u8 - ('a' as u8)) }\n+      'A' to 'Z' { option::some(c as u8 + 10u8 - ('A' as u8)) }\n+      _ { option::none }\n+    }\n+}\n+\n+/*\n+ Function: cmp\n+\n+ Compare two chars.\n+\n+ Parameters:\n+  a - a char\n+  b - a char\n+\n+ Returns:\n+  -1 if a<b, 0 if a==b, +1 if a>b\n+*/\n+fn cmp(a: char, b: char) -> int {\n+    ret  if b > a { -1 }\n+    else if b < a { 1 }\n+    else { 0 }\n+}\n\\ No newline at end of file"}, {"sha": "e00205a522b43fda5f30a042e5ed50dc2bc66bac", "filename": "src/libcore/comm.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,184 @@\n+/*\n+Module: comm\n+\n+Communication between tasks\n+\n+Communication between tasks is facilitated by ports (in the receiving task),\n+and channels (in the sending task). Any number of channels may feed into a\n+single port.\n+\n+Ports and channels may only transmit values of unique types; that is,\n+values that are statically guaranteed to be accessed by a single\n+'owner' at a time.  Unique types include scalars, vectors, strings,\n+and records, tags, tuples and unique boxes (~T) thereof. Most notably,\n+shared boxes (@T) may not be transmitted across channels.\n+\n+Example:\n+\n+> use std::{task, comm, io};\n+>\n+> let p = comm::port();\n+> task::spawn(comm::chan(p), fn (c: chan<str>) {\n+>   comm::send(c, \"Hello, World\");\n+> });\n+>\n+> io::println(comm::recv(p));\n+\n+*/\n+\n+import sys;\n+import task;\n+\n+export send;\n+export recv;\n+export chan;\n+export port;\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    type void;\n+    type rust_port;\n+\n+    fn chan_id_send<send T>(t: *sys::type_desc,\n+                            target_task: task::task, target_port: port_id,\n+                            data: T) -> ctypes::uintptr_t;\n+\n+    fn new_port(unit_sz: uint) -> *rust_port;\n+    fn del_port(po: *rust_port);\n+    fn rust_port_detach(po: *rust_port);\n+    fn get_port_id(po: *rust_port) -> port_id;\n+    fn rust_port_size(po: *rust_port) -> ctypes::size_t;\n+    fn port_recv(dptr: *uint, po: *rust_port,\n+                 yield: *ctypes::uintptr_t,\n+                 killed: *ctypes::uintptr_t);\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn call_with_retptr<send T>(&&f: fn@(*uint)) -> T;\n+}\n+\n+type port_id = int;\n+\n+// It's critical that this only have one variant, so it has a record\n+// layout, and will work in the rust_task structure in task.rs.\n+/*\n+Type: chan\n+\n+A communication endpoint that can send messages. Channels send\n+messages to ports.\n+\n+Each channel is bound to a port when the channel is constructed, so\n+the destination port for a channel must exist before the channel\n+itself.\n+\n+Channels are weak: a channel does not keep the port it is bound to alive.\n+If a channel attempts to send data to a dead port that data will be silently\n+dropped.\n+\n+Channels may be duplicated and themselves transmitted over other channels.\n+*/\n+tag chan<send T> {\n+    chan_t(task::task, port_id);\n+}\n+\n+resource port_ptr<send T>(po: *rustrt::rust_port) {\n+    // Once the port is detached it's guaranteed not to receive further\n+    // messages\n+    rustrt::rust_port_detach(po);\n+    // Drain the port so that all the still-enqueued items get dropped\n+    while rustrt::rust_port_size(po) > 0u {\n+        // FIXME: For some reason if we don't assign to something here\n+        // we end up with invalid reads in the drop glue.\n+        let _t = recv_::<T>(po);\n+    }\n+    rustrt::del_port(po);\n+}\n+\n+/*\n+Type: port\n+\n+A communication endpoint that can receive messages. Ports receive\n+messages from channels.\n+\n+Each port has a unique per-task identity and may not be replicated or\n+transmitted. If a port value is copied, both copies refer to the same port.\n+\n+Ports may be associated with multiple <chan>s.\n+*/\n+tag port<send T> { port_t(@port_ptr<T>); }\n+\n+/*\n+Function: send\n+\n+Sends data over a channel.\n+\n+The sent data is moved into the channel, whereupon the caller loses access\n+to it.\n+*/\n+fn send<send T>(ch: chan<T>, -data: T) {\n+    let chan_t(t, p) = ch;\n+    let res = rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n+    if res != 0u unsafe {\n+        // Data sent successfully\n+        unsafe::leak(data);\n+    }\n+    task::yield();\n+}\n+\n+/*\n+Function: port\n+\n+Constructs a port.\n+*/\n+fn port<send T>() -> port<T> {\n+    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n+}\n+\n+/*\n+Function: recv\n+\n+Receive from a port.\n+\n+If no data is available on the port then the task will block until data\n+becomes available.\n+*/\n+fn recv<send T>(p: port<T>) -> T { recv_(***p) }\n+\n+// Receive on a raw port pointer\n+fn recv_<send T>(p: *rustrt::rust_port) -> T {\n+    // FIXME: Due to issue 1185 we can't use a return pointer when\n+    // calling C code, and since we can't create our own return\n+    // pointer on the stack, we're going to call a little intrinsic\n+    // that will grab the value of the return pointer, then call this\n+    // function, which we will then use to call the runtime.\n+    fn recv(dptr: *uint, port: *rustrt::rust_port,\n+            yield: *ctypes::uintptr_t,\n+            killed: *ctypes::uintptr_t) unsafe {\n+        rustrt::port_recv(dptr, port, yield, killed);\n+    }\n+    let yield = 0u;\n+    let yieldp = ptr::addr_of(yield);\n+    let killed = 0u;\n+    let killedp = ptr::addr_of(killed);\n+    let res = rusti::call_with_retptr(bind recv(_, p, yieldp, killedp));\n+    if killed != 0u {\n+        fail \"killed\";\n+    }\n+    if yield != 0u {\n+        // Data isn't available yet, so res has not been initialized.\n+        task::yield();\n+    }\n+    ret res;\n+}\n+\n+/*\n+Function: chan\n+\n+Constructs a channel.\n+\n+The channel is bound to the port used to construct it.\n+*/\n+fn chan<send T>(p: port<T>) -> chan<T> {\n+    chan_t(task::get_task(), rustrt::get_port_id(***p))\n+}"}, {"sha": "6805c5b30c7cf8b3d6c48236e262e7c4c1509b84", "filename": "src/libcore/core.rc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -7,6 +7,47 @@\n #[license = \"BSD\"];\n #[crate_type = \"lib\"];\n \n+export box, char, float, int, str, ptr, uint, u8, u32, u64, vec, bool;\n+export either, option, result;\n+export ctypes, sys, unsafe, comm, task;\n+export extfmt;\n+\n+// Built-in-type support modules\n+\n+mod box;\n+mod char;\n+mod float;\n+mod int;\n+mod str;\n+mod ptr;\n+mod uint;\n+mod u8;\n+mod u32;\n+mod u64;\n+mod vec;\n+mod bool;\n+\n+\n+// Ubiquitous-utility-type modules\n+\n+mod either;\n+mod option;\n+mod result;\n+\n+\n+// Runtime and language-primitive support\n+\n+mod ctypes;\n+mod sys;\n+mod unsafe;\n+mod comm;\n+mod task;\n+\n+// Compiler support modules\n+\n+mod extfmt;\n+\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "509eb3ef05762a61d6609216672713d9dc7656d2", "filename": "src/libcore/ctypes.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fctypes.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,146 @@\n+/*\n+Module: ctypes\n+\n+Definitions useful for C interop\n+*/\n+\n+/*\n+FIXME: Add a test that uses some native code to verify these sizes,\n+which are not obviously correct for all potential platforms.\n+*/\n+\n+/*\n+Type: c_int\n+\n+A signed integer with the same size as a C `int`\n+*/\n+type c_int = i32;\n+\n+/*\n+Type: c_uint\n+\n+An unsigned integer with the same size as a C `unsigned int`\n+*/\n+type c_uint = u32;\n+\n+/*\n+Type: long\n+\n+A signed integer with the same size as a C `long`\n+*/\n+type long = int;\n+\n+/*\n+Type: unsigned\n+\n+An unsigned integer with the same size as a C `unsigned int`\n+*/\n+type unsigned = u32;\n+\n+/*\n+Type: ulong\n+\n+An unsigned integer with the same size as a C `unsigned long`\n+*/\n+type ulong = uint;\n+\n+/*\n+Type: intptr_t\n+\n+A signed integer with the same size as a pointer. This is\n+guaranteed to always be the same type as a Rust `int`\n+*/\n+type intptr_t = uint; // FIXME: int\n+\n+/*\n+Type: uintptr_t\n+\n+An unsigned integer with the same size as a pointer. This is\n+guaranteed to always be the same type as a Rust `uint`.\n+*/\n+type uintptr_t = uint;\n+type uint32_t = u32;\n+\n+/*\n+Type: void\n+\n+A type, a pointer to which can be used as C `void *`\n+\n+Note that this does not directly correspond to the C `void` type,\n+which is an incomplete type. Using pointers to this type\n+when interoperating with C void pointers can help in documentation.\n+*/\n+type void = int;\n+\n+// machine type equivalents of rust int, uint, float\n+\n+/*\n+Type: m_int\n+\n+FIXME: What C type does this represent?\n+*/\n+#[cfg(target_arch=\"x86\")]\n+type m_int = i32;\n+#[cfg(target_arch=\"x86_64\")]\n+type m_int = i64;\n+\n+/*\n+Type: m_uint\n+\n+FIXME: What C type does this represent?\n+*/\n+#[cfg(target_arch=\"x86\")]\n+type m_uint = u32;\n+#[cfg(target_arch=\"x86_64\")]\n+type m_uint = u64;\n+\n+// This *must* match with \"import m_float = fXX\" in std::math per arch\n+/*\n+Type: m_float\n+\n+FIXME: What C type does this represent?\n+*/\n+type m_float = f64;\n+\n+/*\n+Type: size_t\n+\n+An unsigned integer corresponding to the C `size_t`\n+*/\n+type size_t = uint;\n+\n+/*\n+Type: ssize_t\n+\n+A signed integer correpsonding to the C `ssize_t`\n+*/\n+type ssize_t = int;\n+\n+/*\n+Type: off_t\n+\n+An unsigned integer corresponding to the C `off_t`\n+*/\n+type off_t = uint;\n+\n+/*\n+Type: fd_t\n+\n+A type that can be used for C file descriptors\n+*/\n+type fd_t = i32;      // not actually a C type, but should be.\n+\n+/*\n+Type: pid_t\n+\n+A type for representing process ID's, corresponding to C `pid_t`\n+*/\n+type pid_t = i32;\n+\n+// enum is implementation-defined, but is 32-bits in practice\n+/*\n+Type: enum\n+\n+An unsigned integer with the same size as a C enum\n+*/\n+type enum = u32;"}, {"sha": "89d47b20746a0c9d6f2a58a5595e5f273f73d893", "filename": "src/libcore/either.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,89 @@\n+/*\n+Module: either\n+\n+A type that represents one of two alternatives\n+*/\n+\n+\n+/*\n+Tag: t\n+\n+The either type\n+*/\n+tag t<T, U> {\n+    /* Variant: left */\n+    left(T);\n+    /* Variant: right */\n+    right(U);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Function: either\n+\n+Applies a function based on the given either value\n+\n+If `value` is left(T) then `f_left` is applied to its contents, if\n+`value` is right(U) then `f_right` is applied to its contents, and\n+the result is returned.\n+*/\n+fn either<T, U,\n+          V>(f_left: block(T) -> V, f_right: block(U) -> V, value: t<T, U>) ->\n+   V {\n+    alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n+}\n+\n+/*\n+Function: lefts\n+\n+Extracts from a vector of either all the left values.\n+*/\n+fn lefts<copy T, U>(eithers: [t<T, U>]) -> [T] {\n+    let result: [T] = [];\n+    for elt: t<T, U> in eithers {\n+        alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n+    }\n+    ret result;\n+}\n+\n+/*\n+Function: rights\n+\n+Extracts from a vector of either all the right values\n+*/\n+fn rights<T, copy U>(eithers: [t<T, U>]) -> [U] {\n+    let result: [U] = [];\n+    for elt: t<T, U> in eithers {\n+        alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n+    }\n+    ret result;\n+}\n+\n+/*\n+Function: partition\n+\n+Extracts from a vector of either all the left values and right values\n+\n+Returns a structure containing a vector of left values and a vector of\n+right values.\n+*/\n+fn partition<copy T, copy U>(eithers: [t<T, U>])\n+    -> {lefts: [T], rights: [U]} {\n+    let lefts: [T] = [];\n+    let rights: [U] = [];\n+    for elt: t<T, U> in eithers {\n+        alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n+    }\n+    ret {lefts: lefts, rights: rights};\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "14a014e891a0b9535fb52339c6f2a3f3d79f6f8a", "filename": "src/libcore/extfmt.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,453 @@\n+/*\n+Syntax Extension: fmt\n+\n+Format a string\n+\n+The 'fmt' extension is modeled on the posix printf system.\n+\n+A posix conversion ostensibly looks like this\n+\n+> %[parameter][flags][width][.precision][length]type\n+\n+Given the different numeric type bestiary we have, we omit the 'length'\n+parameter and support slightly different conversions for 'type'\n+\n+> %[parameter][flags][width][.precision]type\n+\n+we also only support translating-to-rust a tiny subset of the possible\n+combinations at the moment.\n+\n+Example:\n+\n+log #fmt(\"hello, %s!\", \"world\");\n+\n+*/\n+\n+import option::{some, none};\n+\n+\n+/*\n+ * We have a 'ct' (compile-time) module that parses format strings into a\n+ * sequence of conversions. From those conversions AST fragments are built\n+ * that call into properly-typed functions in the 'rt' (run-time) module.\n+ * Each of those run-time conversion functions accepts another conversion\n+ * description that specifies how to format its output.\n+ *\n+ * The building of the AST is currently done in a module inside the compiler,\n+ * but should migrate over here as the plugin interface is defined.\n+ */\n+\n+// Functions used by the fmt extension at compile time\n+mod ct {\n+    tag signedness { signed; unsigned; }\n+    tag caseness { case_upper; case_lower; }\n+    tag ty {\n+        ty_bool;\n+        ty_str;\n+        ty_char;\n+        ty_int(signedness);\n+        ty_bits;\n+        ty_hex(caseness);\n+        ty_octal;\n+        ty_float;\n+        // FIXME: More types\n+    }\n+    tag flag {\n+        flag_left_justify;\n+        flag_left_zero_pad;\n+        flag_space_for_sign;\n+        flag_sign_always;\n+        flag_alternate;\n+    }\n+    tag count {\n+        count_is(int);\n+        count_is_param(int);\n+        count_is_next_param;\n+        count_implied;\n+    }\n+\n+    // A formatted conversion from an expression to a string\n+    type conv =\n+        {param: option::t<int>,\n+         flags: [flag],\n+         width: count,\n+         precision: count,\n+         ty: ty};\n+\n+\n+    // A fragment of the output sequence\n+    tag piece { piece_string(str); piece_conv(conv); }\n+    type error_fn = fn@(str) -> ! ;\n+\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n+        let pieces: [piece] = [];\n+        let lim = str::byte_len(s);\n+        let buf = \"\";\n+        fn flush_buf(buf: str, &pieces: [piece]) -> str {\n+            if str::byte_len(buf) > 0u {\n+                let piece = piece_string(buf);\n+                pieces += [piece];\n+            }\n+            ret \"\";\n+        }\n+        let i = 0u;\n+        while i < lim {\n+            let curr = str::substr(s, i, 1u);\n+            if str::eq(curr, \"%\") {\n+                i += 1u;\n+                if i >= lim {\n+                    error(\"unterminated conversion at end of string\");\n+                }\n+                let curr2 = str::substr(s, i, 1u);\n+                if str::eq(curr2, \"%\") {\n+                    i += 1u;\n+                } else {\n+                    buf = flush_buf(buf, pieces);\n+                    let rs = parse_conversion(s, i, lim, error);\n+                    pieces += [rs.piece];\n+                    i = rs.next;\n+                }\n+            } else { buf += curr; i += 1u; }\n+        }\n+        buf = flush_buf(buf, pieces);\n+        ret pieces;\n+    }\n+    fn peek_num(s: str, i: uint, lim: uint) ->\n+       option::t<{num: uint, next: uint}> {\n+        if i >= lim { ret none; }\n+        let c = s[i];\n+        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n+        let n = c - ('0' as u8) as uint;\n+        ret alt peek_num(s, i + 1u, lim) {\n+              none. { some({num: n, next: i + 1u}) }\n+              some(next) {\n+                let m = next.num;\n+                let j = next.next;\n+                some({num: n * 10u + m, next: j})\n+              }\n+            };\n+    }\n+    fn parse_conversion(s: str, i: uint, lim: uint, error: error_fn) ->\n+       {piece: piece, next: uint} {\n+        let parm = parse_parameter(s, i, lim);\n+        let flags = parse_flags(s, parm.next, lim);\n+        let width = parse_count(s, flags.next, lim);\n+        let prec = parse_precision(s, width.next, lim);\n+        let ty = parse_type(s, prec.next, lim, error);\n+        ret {piece:\n+                 piece_conv({param: parm.param,\n+                             flags: flags.flags,\n+                             width: width.count,\n+                             precision: prec.count,\n+                             ty: ty.ty}),\n+             next: ty.next};\n+    }\n+    fn parse_parameter(s: str, i: uint, lim: uint) ->\n+       {param: option::t<int>, next: uint} {\n+        if i >= lim { ret {param: none, next: i}; }\n+        let num = peek_num(s, i, lim);\n+        ret alt num {\n+              none. { {param: none, next: i} }\n+              some(t) {\n+                let n = t.num;\n+                let j = t.next;\n+                if j < lim && s[j] == '$' as u8 {\n+                    {param: some(n as int), next: j + 1u}\n+                } else { {param: none, next: i} }\n+              }\n+            };\n+    }\n+    fn parse_flags(s: str, i: uint, lim: uint) ->\n+       {flags: [flag], next: uint} {\n+        let noflags: [flag] = [];\n+        if i >= lim { ret {flags: noflags, next: i}; }\n+\n+        // FIXME: This recursion generates illegal instructions if the return\n+        // value isn't boxed. Only started happening after the ivec conversion\n+        fn more_(f: flag, s: str, i: uint, lim: uint) ->\n+           @{flags: [flag], next: uint} {\n+            let next = parse_flags(s, i + 1u, lim);\n+            let rest = next.flags;\n+            let j = next.next;\n+            let curr: [flag] = [f];\n+            ret @{flags: curr + rest, next: j};\n+        }\n+        let more = bind more_(_, s, i, lim);\n+        let f = s[i];\n+        ret if f == '-' as u8 {\n+                *more(flag_left_justify)\n+            } else if f == '0' as u8 {\n+                *more(flag_left_zero_pad)\n+            } else if f == ' ' as u8 {\n+                *more(flag_space_for_sign)\n+            } else if f == '+' as u8 {\n+                *more(flag_sign_always)\n+            } else if f == '#' as u8 {\n+                *more(flag_alternate)\n+            } else { {flags: noflags, next: i} };\n+    }\n+    fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n+        ret if i >= lim {\n+                {count: count_implied, next: i}\n+            } else if s[i] == '*' as u8 {\n+                let param = parse_parameter(s, i + 1u, lim);\n+                let j = param.next;\n+                alt param.param {\n+                  none. { {count: count_is_next_param, next: j} }\n+                  some(n) { {count: count_is_param(n), next: j} }\n+                }\n+            } else {\n+                let num = peek_num(s, i, lim);\n+                alt num {\n+                  none. { {count: count_implied, next: i} }\n+                  some(num) {\n+                    {count: count_is(num.num as int), next: num.next}\n+                  }\n+                }\n+            };\n+    }\n+    fn parse_precision(s: str, i: uint, lim: uint) ->\n+       {count: count, next: uint} {\n+        ret if i >= lim {\n+                {count: count_implied, next: i}\n+            } else if s[i] == '.' as u8 {\n+                let count = parse_count(s, i + 1u, lim);\n+\n+\n+                // If there were no digits specified, i.e. the precision\n+                // was \".\", then the precision is 0\n+                alt count.count {\n+                  count_implied. { {count: count_is(0), next: count.next} }\n+                  _ { count }\n+                }\n+            } else { {count: count_implied, next: i} };\n+    }\n+    fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n+       {ty: ty, next: uint} {\n+        if i >= lim { error(\"missing type in conversion\"); }\n+        let tstr = str::substr(s, i, 1u);\n+        // TODO: Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        let t =\n+            if str::eq(tstr, \"b\") {\n+                ty_bool\n+            } else if str::eq(tstr, \"s\") {\n+                ty_str\n+            } else if str::eq(tstr, \"c\") {\n+                ty_char\n+            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n+                ty_int(signed)\n+            } else if str::eq(tstr, \"u\") {\n+                ty_int(unsigned)\n+            } else if str::eq(tstr, \"x\") {\n+                ty_hex(case_lower)\n+            } else if str::eq(tstr, \"X\") {\n+                ty_hex(case_upper)\n+            } else if str::eq(tstr, \"t\") {\n+                ty_bits\n+            } else if str::eq(tstr, \"o\") {\n+                ty_octal\n+            } else if str::eq(tstr, \"f\") {\n+                ty_float\n+            } else { error(\"unknown type in conversion: \" + tstr) };\n+        ret {ty: t, next: i + 1u};\n+    }\n+}\n+\n+\n+// Functions used by the fmt extension at runtime. For now there are a lot of\n+// decisions made a runtime. If it proves worthwhile then some of these\n+// conditions can be evaluated at compile-time. For now though it's cleaner to\n+// implement it this way, I think.\n+mod rt {\n+    tag flag {\n+        flag_left_justify;\n+        flag_left_zero_pad;\n+        flag_space_for_sign;\n+        flag_sign_always;\n+        flag_alternate;\n+\n+\n+        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n+        // which have some difficulty typechecking currently. See\n+        // comments in front::extfmt::make_flags\n+        flag_none;\n+    }\n+    tag count { count_is(int); count_implied; }\n+    tag ty { ty_default; ty_bits; ty_hex_upper; ty_hex_lower; ty_octal; }\n+\n+    // FIXME: May not want to use a vector here for flags;\n+    // instead just use a bool per flag\n+    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n+\n+    fn conv_int(cv: conv, i: int) -> str {\n+        let radix = 10u;\n+        let prec = get_int_precision(cv);\n+        let s = int_to_str_prec(i, radix, prec);\n+        if 0 <= i {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                s = \"+\" + s;\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                s = \" \" + s;\n+            }\n+        }\n+        ret pad(cv, s, pad_signed);\n+    }\n+    fn conv_uint(cv: conv, u: uint) -> str {\n+        let prec = get_int_precision(cv);\n+        let rs =\n+            alt cv.ty {\n+              ty_default. { uint_to_str_prec(u, 10u, prec) }\n+              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n+              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n+              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n+              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n+            };\n+        ret pad(cv, rs, pad_unsigned);\n+    }\n+    fn conv_bool(cv: conv, b: bool) -> str {\n+        let s = if b { \"true\" } else { \"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+\n+        ret conv_str(cv, s);\n+    }\n+    fn conv_char(cv: conv, c: char) -> str {\n+        ret pad(cv, str::from_char(c), pad_nozero);\n+    }\n+    fn conv_str(cv: conv, s: str) -> str {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+\n+        // FIXME: substr works on bytes, not chars!\n+        let unpadded =\n+            alt cv.precision {\n+              count_implied. { s }\n+              count_is(max) {\n+                if max as uint < str::char_len(s) {\n+                    str::substr(s, 0u, max as uint)\n+                } else { s }\n+              }\n+            };\n+        ret pad(cv, unpadded, pad_nozero);\n+    }\n+    fn conv_float(cv: conv, f: float) -> str {\n+        let (to_str, digits) = alt cv.precision {\n+              count_is(c) { (float::to_str_exact, c as uint) }\n+              count_implied. { (float::to_str, 6u) }\n+        };\n+        let s = to_str(f, digits);\n+        if 0.0 <= f {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                s = \"+\" + s;\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                s = \" \" + s;\n+            }\n+        }\n+        ret pad(cv, s, pad_signed);\n+    }\n+\n+    // Convert an int to string with minimum number of digits. If precision is\n+    // 0 and num is 0 then the result is the empty string.\n+    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> str {\n+        ret if num < 0 {\n+                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+            } else { uint_to_str_prec(num as uint, radix, prec) };\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> str {\n+        ret if prec == 0u && num == 0u {\n+                \"\"\n+            } else {\n+                let s = uint::to_str(num, radix);\n+                let len = str::char_len(s);\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str_init_elt('0', diff);\n+                    pad + s\n+                } else { s }\n+            };\n+    }\n+    fn get_int_precision(cv: conv) -> uint {\n+        ret alt cv.precision {\n+              count_is(c) { c as uint }\n+              count_implied. { 1u }\n+            };\n+    }\n+\n+    // FIXME: This might be useful in str: but needs to be utf8 safe first\n+    fn str_init_elt(c: char, n_elts: uint) -> str {\n+        let svec = vec::init_elt::<u8>(c as u8, n_elts);\n+\n+        ret str::unsafe_from_bytes(svec);\n+    }\n+    tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n+    fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n+        let uwidth;\n+        alt cv.width {\n+          count_implied. { ret s; }\n+          count_is(width) {\n+            // FIXME: Maybe width should be uint\n+\n+            uwidth = width as uint;\n+          }\n+        }\n+        let strlen = str::char_len(s);\n+        if uwidth <= strlen { ret s; }\n+        let padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            let padstr = str_init_elt(padchar, diff);\n+            ret s + padstr;\n+        }\n+        let might_zero_pad = false;\n+        let signed = false;\n+        alt mode {\n+          pad_nozero. {\n+            // fallthrough\n+\n+          }\n+          pad_signed. { might_zero_pad = true; signed = true; }\n+          pad_unsigned. { might_zero_pad = true; }\n+        }\n+        fn have_precision(cv: conv) -> bool {\n+            ret alt cv.precision { count_implied. { false } _ { true } };\n+        }\n+        let zero_padding = false;\n+        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+               !have_precision(cv) {\n+            padchar = '0';\n+            zero_padding = true;\n+        }\n+        let padstr = str_init_elt(padchar, diff);\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding && str::byte_len(s) > 0u {\n+            let head = s[0];\n+            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n+                let headstr = str::unsafe_from_bytes([head]);\n+                let bytelen = str::byte_len(s);\n+                let numpart = str::substr(s, 1u, bytelen - 1u);\n+                ret headstr + padstr + numpart;\n+            }\n+        }\n+        ret padstr + s;\n+    }\n+    fn have_flag(flags: [flag], f: flag) -> bool {\n+        for candidate: flag in flags { if candidate == f { ret true; } }\n+        ret false;\n+    }\n+}\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "015dceb1dc1c0caf3c30229c40228447ddf60837", "filename": "src/libcore/float.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,343 @@\n+/*\n+Module: float\n+*/\n+\n+/**\n+ * Section: String Conversions\n+ */\n+\n+/*\n+Function: to_str_common\n+\n+Converts a float to a string\n+\n+Parameters:\n+\n+num - The float value\n+digits - The number of significant digits\n+exact - Whether to enforce the exact number of significant digits\n+*/\n+fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n+    let (num, accum) = num < 0.0 ? (-num, \"-\") : (num, \"\");\n+    let trunc = num as uint;\n+    let frac = num - (trunc as float);\n+    accum += uint::str(trunc);\n+    if frac == 0.0 || digits == 0u { ret accum; }\n+    accum += \".\";\n+    let i = digits;\n+    let epsilon = 1. / pow_uint_to_uint_as_float(10u, i);\n+    while i > 0u && (frac >= epsilon || exact) {\n+        frac *= 10.0;\n+        epsilon *= 10.0;\n+        let digit = frac as uint;\n+        accum += uint::str(digit);\n+        frac -= digit as float;\n+        i -= 1u;\n+    }\n+    ret accum;\n+\n+}\n+\n+/*\n+Function: to_str\n+\n+Converts a float to a string with exactly the number of provided significant\n+digits\n+\n+Parameters:\n+\n+num - The float value\n+digits - The number of significant digits\n+*/\n+fn to_str_exact(num: float, digits: uint) -> str {\n+    to_str_common(num, digits, true)\n+}\n+\n+/*\n+Function: to_str\n+\n+Converts a float to a string with a maximum number of significant digits\n+\n+Parameters:\n+\n+num - The float value\n+digits - The number of significant digits\n+*/\n+fn to_str(num: float, digits: uint) -> str {\n+    to_str_common(num, digits, false)\n+}\n+\n+/*\n+Function: from_str\n+\n+Convert a string to a float\n+\n+This function accepts strings such as\n+* \"3.14\"\n+* \"+3.14\", equivalent to \"3.14\"\n+* \"-3.14\"\n+* \"2.5E10\", or equivalently, \"2.5e10\"\n+* \"2.5E-10\"\n+* \"\", or, equivalently, \".\" (understood as 0)\n+* \"5.\"\n+* \".5\", or, equivalently,  \"0.5\"\n+\n+Leading and trailing whitespace are ignored.\n+\n+Parameters:\n+\n+num - A string, possibly empty.\n+\n+Returns:\n+\n+<NaN> If the string did not represent a valid number.\n+Otherwise, the floating-point number represented [num].\n+*/\n+fn from_str(num: str) -> float {\n+   let num = str::trim(num);\n+\n+   let pos = 0u;                  //Current byte position in the string.\n+                                  //Used to walk the string in O(n).\n+   let len = str::byte_len(num);  //Length of the string, in bytes.\n+\n+   if len == 0u { ret 0.; }\n+   let total = 0f;                //Accumulated result\n+   let c     = 'z';               //Latest char.\n+\n+   //The string must start with one of the following characters.\n+   alt str::char_at(num, 0u) {\n+      '-' | '+' | '0' to '9' | '.' {}\n+      _ { ret NaN; }\n+   }\n+\n+   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n+   let neg = false;               //Sign of the result\n+   alt str::char_at(num, 0u) {\n+      '-' {\n+          neg = true;\n+          pos = 1u;\n+      }\n+      '+' {\n+          pos = 1u;\n+      }\n+      _ {}\n+   }\n+\n+   //Examine the following chars until '.', 'e', 'E'\n+   while(pos < len) {\n+       let char_range = str::char_range_at(num, pos);\n+       c   = char_range.ch;\n+       pos = char_range.next;\n+       alt c {\n+         '0' to '9' {\n+           total = total * 10f;\n+           total += ((c as int) - ('0' as int)) as float;\n+         }\n+         '.' | 'e' | 'E' {\n+           break;\n+         }\n+         _ {\n+           ret NaN;\n+         }\n+       }\n+   }\n+\n+   if c == '.' {//Examine decimal part\n+      let decimal = 1.f;\n+      while(pos < len) {\n+         let char_range = str::char_range_at(num, pos);\n+         c = char_range.ch;\n+         pos = char_range.next;\n+         alt c {\n+            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  {\n+                 decimal /= 10.f;\n+                 total += (((c as int) - ('0' as int)) as float)*decimal;\n+             }\n+             'e' | 'E' {\n+                 break;\n+             }\n+             _ {\n+                 ret NaN;\n+             }\n+         }\n+      }\n+   }\n+\n+   if (c == 'e') | (c == 'E') {//Examine exponent\n+      let exponent = 0u;\n+      let neg_exponent = false;\n+      if(pos < len) {\n+          let char_range = str::char_range_at(num, pos);\n+          c   = char_range.ch;\n+          alt c  {\n+             '+' {\n+                pos = char_range.next;\n+             }\n+             '-' {\n+                pos = char_range.next;\n+                neg_exponent = true;\n+             }\n+             _ {}\n+          }\n+          while(pos < len) {\n+             let char_range = str::char_range_at(num, pos);\n+             c = char_range.ch;\n+             alt c {\n+                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' {\n+                     exponent *= 10u;\n+                     exponent += ((c as uint) - ('0' as uint));\n+                 }\n+                 _ {\n+                     break;\n+                 }\n+             }\n+             pos = char_range.next;\n+          }\n+          let multiplier = pow_uint_to_uint_as_float(10u, exponent);\n+              //Note: not [int::pow], otherwise, we'll quickly\n+              //end up with a nice overflow\n+          if neg_exponent {\n+             total = total / multiplier;\n+          } else {\n+             total = total * multiplier;\n+          }\n+      } else {\n+         ret NaN;\n+      }\n+   }\n+\n+   if(pos < len) {\n+     ret NaN;\n+   } else {\n+     if(neg) {\n+        total *= -1f;\n+     }\n+     ret total;\n+   }\n+}\n+\n+/**\n+ * Section: Arithmetics\n+ */\n+\n+/*\n+Function: pow_uint_to_uint_as_float\n+\n+Compute the exponentiation of an integer by another integer as a float.\n+\n+Parameters:\n+x - The base.\n+pow - The exponent.\n+\n+Returns:\n+<NaN> of both `x` and `pow` are `0u`, otherwise `x^pow`.\n+*/\n+fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n+   if x == 0u {\n+      if pow == 0u {\n+        ret NaN;\n+      }\n+       ret 0.;\n+   }\n+   let my_pow     = pow;\n+   let total      = 1f;\n+   let multiplier = x as float;\n+   while (my_pow > 0u) {\n+     if my_pow % 2u == 1u {\n+       total = total * multiplier;\n+     }\n+     my_pow     /= 2u;\n+     multiplier *= multiplier;\n+   }\n+   ret total;\n+}\n+\n+\n+/* Const: NaN */\n+const NaN: float = 0./0.;\n+\n+/* Const: infinity */\n+const infinity: float = 1./0.;\n+\n+/* Const: neg_infinity */\n+const neg_infinity: float = -1./0.;\n+\n+/* Predicate: isNaN */\n+pure fn isNaN(f: float) -> bool { f != f }\n+\n+/* Function: add */\n+pure fn add(x: float, y: float) -> float { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: float, y: float) -> float { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: float, y: float) -> float { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: float, y: float) -> float { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: float, y: float) -> float { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: float, y: float) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: float, y: float) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: float, y: float) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: float, y: float) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: float, y: float) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: float, y: float) -> bool { ret x > y; }\n+\n+/*\n+Predicate: positive\n+\n+Returns true if `x` is a positive number, including +0.0 and +Infinity.\n+ */\n+pure fn positive(x: float) -> bool { ret x > 0. || (1./x) == infinity; }\n+\n+/*\n+Predicate: negative\n+\n+Returns true if `x` is a negative number, including -0.0 and -Infinity.\n+ */\n+pure fn negative(x: float) -> bool { ret x < 0. || (1./x) == neg_infinity; }\n+\n+/*\n+Predicate: nonpositive\n+\n+Returns true if `x` is a negative number, including -0.0 and -Infinity.\n+(This is the same as `float::negative`.)\n+*/\n+pure fn nonpositive(x: float) -> bool {\n+  ret x < 0. || (1./x) == neg_infinity;\n+}\n+\n+/*\n+Predicate: nonnegative\n+\n+Returns true if `x` is a positive number, including +0.0 and +Infinity.\n+(This is the same as `float::positive`.)\n+*/\n+pure fn nonnegative(x: float) -> bool {\n+  ret x > 0. || (1./x) == infinity;\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "2ab299800adf52589ff11e1d65c277ff4e75f369", "filename": "src/libcore/int.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,189 @@\n+/*\n+Module: int\n+*/\n+\n+/*\n+Const: max_value\n+\n+The maximum value of an integer\n+*/\n+// FIXME: Find another way to access the machine word size in a const expr\n+#[cfg(target_arch=\"x86\")]\n+const max_value: int = (-1 << 31)-1;\n+\n+#[cfg(target_arch=\"x86_64\")]\n+const max_value: int = (-1 << 63)-1;\n+\n+/*\n+Const: min_value\n+\n+The minumum value of an integer\n+*/\n+#[cfg(target_arch=\"x86\")]\n+const min_value: int = -1 << 31;\n+\n+#[cfg(target_arch=\"x86_64\")]\n+const min_value: int = -1 << 63;\n+\n+/* Function: add */\n+pure fn add(x: int, y: int) -> int { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: int, y: int) -> int { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: int, y: int) -> int { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: int, y: int) -> int { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: int, y: int) -> int { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: int, y: int) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: int, y: int) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: int, y: int) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: int, y: int) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: int, y: int) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: int, y: int) -> bool { ret x > y; }\n+\n+/* Predicate: positive */\n+pure fn positive(x: int) -> bool { ret x > 0; }\n+\n+/* Predicate: negative */\n+pure fn negative(x: int) -> bool { ret x < 0; }\n+\n+/* Predicate: nonpositive */\n+pure fn nonpositive(x: int) -> bool { ret x <= 0; }\n+\n+/* Predicate: nonnegative */\n+pure fn nonnegative(x: int) -> bool { ret x >= 0; }\n+\n+\n+// FIXME: Make sure this works with negative integers.\n+/*\n+Function: hash\n+\n+Produce a uint suitable for use in a hash table\n+*/\n+fn hash(x: int) -> uint { ret x as uint; }\n+\n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n+fn range(lo: int, hi: int, it: block(int)) {\n+    let i = lo;\n+    while i < hi { it(i); i += 1; }\n+}\n+\n+/*\n+Function: parse_buf\n+\n+Parse a buffer of bytes\n+\n+Parameters:\n+\n+buf - A byte buffer\n+radix - The base of the number\n+\n+Failure:\n+\n+buf must not be empty\n+*/\n+fn parse_buf(buf: [u8], radix: uint) -> int {\n+    if vec::len::<u8>(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = vec::len::<u8>(buf) - 1u;\n+    let start = 0u;\n+    let power = 1;\n+\n+    if buf[0] == ('-' as u8) {\n+        power = -1;\n+        start = 1u;\n+    }\n+    let n = 0;\n+    while true {\n+        let digit = char::to_digit(buf[i] as char);\n+        if (digit as uint) >= radix {\n+            fail;\n+        }\n+        n += (digit as int) * power;\n+        power *= radix as int;\n+        if i <= start { ret n; }\n+        i -= 1u;\n+    }\n+    fail;\n+}\n+\n+/*\n+Function: from_str\n+\n+Parse a string to an int\n+\n+Failure:\n+\n+s must not be empty\n+*/\n+fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n+\n+/*\n+Function: to_str\n+\n+Convert to a string in a given base\n+*/\n+fn to_str(n: int, radix: uint) -> str {\n+    assert (0u < radix && radix <= 16u);\n+    ret if n < 0 {\n+            \"-\" + uint::to_str(-n as uint, radix)\n+        } else { uint::to_str(n as uint, radix) };\n+}\n+\n+/*\n+Function: str\n+\n+Convert to a string\n+*/\n+fn str(i: int) -> str { ret to_str(i, 10u); }\n+\n+/*\n+Function: pow\n+\n+Returns `base` raised to the power of `exponent`\n+*/\n+fn pow(base: int, exponent: uint) -> int {\n+    if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n+    if base     == 0  { ret 0; }\n+    let my_pow  = exponent;\n+    let acc     = 1;\n+    let multiplier = base;\n+    while(my_pow > 0u) {\n+      if my_pow % 2u == 1u {\n+         acc *= multiplier;\n+      }\n+      my_pow     /= 2u;\n+      multiplier *= multiplier;\n+    }\n+    ret acc;\n+}\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "403cb47f47e645d608a2fe04f1ea27f89fbd888f", "filename": "src/libcore/option.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,93 @@\n+/*\n+Module: option\n+\n+Represents the presence or absence of a value.\n+\n+Every option<T> value can either be some(T) or none. Where in other languages\n+you might use a nullable type, in Rust you would use an option type.\n+*/\n+\n+/*\n+Tag: t\n+\n+The option type\n+*/\n+tag t<T> {\n+    /* Variant: none */\n+    none;\n+    /* Variant: some */\n+    some(T);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Function: get\n+\n+Gets the value out of an option\n+\n+Failure:\n+\n+Fails if the value equals `none`.\n+*/\n+fn get<copy T>(opt: t<T>) -> T {\n+    alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n+}\n+\n+/*\n+*/\n+fn map<T, U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n+    alt opt { some(x) { some(f(x)) } none. { none } }\n+}\n+\n+/*\n+Function: is_none\n+\n+Returns true if the option equals none\n+*/\n+pure fn is_none<T>(opt: t<T>) -> bool {\n+    alt opt { none. { true } some(_) { false } }\n+}\n+\n+/*\n+Function: is_some\n+\n+Returns true if the option contains some value\n+*/\n+pure fn is_some<T>(opt: t<T>) -> bool { !is_none(opt) }\n+\n+/*\n+Function: from_maybe\n+\n+Returns the contained value or a default\n+*/\n+fn from_maybe<T>(def: T, opt: t<T>) -> T {\n+    alt opt { some(x) { x } none. { def } }\n+}\n+\n+/*\n+Function: maybe\n+\n+Applies a function to the contained value or returns a default\n+*/\n+fn maybe<T, U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n+    alt opt { none. { def } some(t) { f(t) } }\n+}\n+\n+// FIXME: Can be defined in terms of the above when/if we have const bind.\n+/*\n+Function: may\n+\n+Performs an operation on the contained value or does nothing\n+*/\n+fn may<T>(f: block(T), opt: t<T>) {\n+    alt opt { none. {/* nothing */ } some(t) { f(t); } }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "0372b17cdf1d27dbda952c10b75e2b3e6ec43de1", "filename": "src/libcore/ptr.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,52 @@\n+/*\n+Module: ptr\n+\n+Unsafe pointer utility functions\n+*/\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn addr_of<T>(val: T) -> *T;\n+    fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n+}\n+\n+/*\n+Function: addr_of\n+\n+Get an unsafe pointer to a value\n+*/\n+fn addr_of<T>(val: T) -> *T { ret rusti::addr_of(val); }\n+\n+/*\n+Function: mut_addr_of\n+\n+Get an unsafe mutable pointer to a value\n+*/\n+fn mut_addr_of<T>(val: T) -> *mutable T unsafe {\n+    ret unsafe::reinterpret_cast(rusti::addr_of(val));\n+}\n+\n+/*\n+Function: offset\n+\n+Calculate the offset from a pointer\n+*/\n+fn offset<T>(ptr: *T, count: uint) -> *T {\n+    ret rusti::ptr_offset(ptr, count);\n+}\n+\n+/*\n+Function: mut_offset\n+\n+Calculate the offset from a mutable pointer\n+*/\n+fn mut_offset<T>(ptr: *mutable T, count: uint) -> *mutable T {\n+    ret rusti::ptr_offset(ptr as *T, count) as *mutable T;\n+}\n+\n+\n+/*\n+Function: null\n+\n+Create an unsafe null pointer\n+*/\n+fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }"}, {"sha": "550f53470bbe8d0e9db5cc7924859abbf808a739", "filename": "src/libcore/result.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,112 @@\n+/*\n+Module: result\n+\n+A type representing either success or failure\n+*/\n+\n+/* Section: Types */\n+\n+/*\n+Tag: t\n+\n+The result type\n+*/\n+tag t<T, U> {\n+    /*\n+    Variant: ok\n+\n+    Contains the result value\n+    */\n+    ok(T);\n+    /*\n+    Variant: err\n+\n+    Contains the error value\n+    */\n+    err(U);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Function: get\n+\n+Get the value out of a successful result\n+\n+Failure:\n+\n+If the result is an error\n+*/\n+fn get<T, U>(res: t<T, U>) -> T {\n+    alt res {\n+      ok(t) { t }\n+      err(_) {\n+        // FIXME: Serialize the error value\n+        // and include it in the fail message\n+        fail \"get called on error result\";\n+      }\n+    }\n+}\n+\n+/*\n+Function: get_err\n+\n+Get the value out of an error result\n+\n+Failure:\n+\n+If the result is not an error\n+*/\n+fn get_err<T, U>(res: t<T, U>) -> U {\n+    alt res {\n+      err(u) { u }\n+      ok(_) {\n+        fail \"get_error called on ok result\";\n+      }\n+    }\n+}\n+\n+/*\n+Function: success\n+\n+Returns true if the result is <ok>\n+*/\n+fn success<T, U>(res: t<T, U>) -> bool {\n+    alt res {\n+      ok(_) { true }\n+      err(_) { false }\n+    }\n+}\n+\n+/*\n+Function: failure\n+\n+Returns true if the result is <error>\n+*/\n+fn failure<T, U>(res: t<T, U>) -> bool {\n+    !success(res)\n+}\n+\n+/*\n+Function: chain\n+\n+Call a function based on a previous result\n+\n+If `res` is <ok> then the value is extracted and passed to `op` whereupon\n+`op`s result is returned. if `res` is <err> then it is immediately returned.\n+This function can be used to compose the results of two functions.\n+\n+Example:\n+\n+> let res = chain(read_file(file), { |buf|\n+>   ok(parse_buf(buf))\n+> })\n+\n+*/\n+fn chain<T, copy U, copy V>(res: t<T, V>, op: block(T) -> t<U, V>)\n+    -> t<U, V> {\n+    alt res {\n+      ok(t) { op(t) }\n+      err(e) { err(e) }\n+    }\n+}"}, {"sha": "31c3516b862c1bdf6eb5a3cbfd30a446f8d3d721", "filename": "src/libcore/str.rs", "status": "added", "additions": 962, "deletions": 0, "changes": 962, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,962 @@\n+/*\n+Module: str\n+\n+String manipulation.\n+*/\n+\n+export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n+       byte_len_range, index,\n+       rindex, find, starts_with, ends_with, substr, slice, split, concat,\n+       connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n+       unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars,\n+       to_chars, char_len, char_len_range, char_at, bytes, is_ascii,\n+       shift_byte, pop_byte,\n+       unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n+       str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n+       contains, iter_chars, loop_chars, loop_chars_sub,\n+       escape;\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    fn rust_str_push(&s: str, ch: u8);\n+}\n+\n+/*\n+Function: eq\n+\n+Bytewise string equality\n+*/\n+fn eq(&&a: str, &&b: str) -> bool { a == b }\n+\n+/*\n+Function: lteq\n+\n+Bytewise less than or equal\n+*/\n+fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n+\n+/*\n+Function: hash\n+\n+String hash function\n+*/\n+fn hash(&&s: str) -> uint {\n+    // djb hash.\n+    // FIXME: replace with murmur.\n+\n+    let u: uint = 5381u;\n+    for c: u8 in s { u *= 33u; u += c as uint; }\n+    ret u;\n+}\n+\n+// UTF-8 tags and ranges\n+const tag_cont_u8: u8 = 128u8;\n+const tag_cont: uint = 128u;\n+const max_one_b: uint = 128u;\n+const tag_two_b: uint = 192u;\n+const max_two_b: uint = 2048u;\n+const tag_three_b: uint = 224u;\n+const max_three_b: uint = 65536u;\n+const tag_four_b: uint = 240u;\n+const max_four_b: uint = 2097152u;\n+const tag_five_b: uint = 248u;\n+const max_five_b: uint = 67108864u;\n+const tag_six_b: uint = 252u;\n+\n+/*\n+Function: is_utf8\n+\n+Determines if a vector uf bytes contains valid UTF-8\n+*/\n+fn is_utf8(v: [u8]) -> bool {\n+    let i = 0u;\n+    let total = vec::len::<u8>(v);\n+    while i < total {\n+        let chsize = utf8_char_width(v[i]);\n+        if chsize == 0u { ret false; }\n+        if i + chsize > total { ret false; }\n+        i += 1u;\n+        while chsize > 1u {\n+            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n+            i += 1u;\n+            chsize -= 1u;\n+        }\n+    }\n+    ret true;\n+}\n+\n+/*\n+Function: is_ascii\n+\n+Determines if a string contains only ASCII characters\n+*/\n+fn is_ascii(s: str) -> bool {\n+    let i: uint = byte_len(s);\n+    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n+    ret true;\n+}\n+\n+/*\n+Predicate: is_empty\n+\n+Returns true if the string has length 0\n+*/\n+pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n+\n+/*\n+Predicate: is_not_empty\n+\n+Returns true if the string has length greater than 0\n+*/\n+pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n+\n+/*\n+Function: is_whitespace\n+\n+Returns true if the string contains only whitespace\n+*/\n+fn is_whitespace(s: str) -> bool {\n+    let i = 0u;\n+    let len = char_len(s);\n+    while i < len {\n+        // FIXME: This is not how char_at works\n+        if !char::is_whitespace(char_at(s, i)) { ret false; }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+/*\n+Function: byte_len\n+\n+Returns the length in bytes of a string\n+*/\n+fn byte_len(s: str) -> uint unsafe {\n+    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let vlen = vec::len(v);\n+    unsafe::leak(v);\n+    // There should always be a null terminator\n+    assert (vlen > 0u);\n+    ret vlen - 1u;\n+}\n+\n+/*\n+Function: byte_len_range\n+\n+As byte_len but for a substring\n+\n+Parameters:\n+s - A string\n+byte_offset - The byte offset at which to start in the string\n+char_len    - The number of chars (not bytes!) in the range\n+\n+Returns:\n+The number of bytes in the substring starting at `byte_offset` and\n+containing `char_len` chars.\n+\n+Safety note:\n+\n+This function fails if `byte_offset` or `char_len` do not represent\n+valid positions in `s`\n+*/\n+fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n+    let i = byte_offset;\n+    let chars = 0u;\n+    while chars < char_len {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        i += chsize;\n+        chars += 1u;\n+    }\n+    ret i - byte_offset;\n+}\n+\n+/*\n+Function: bytes\n+\n+Converts a string to a vector of bytes. The result vector is not\n+null-terminated.\n+*/\n+fn bytes(s: str) -> [u8] unsafe {\n+    let v = unsafe::reinterpret_cast(s);\n+    let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n+    unsafe::leak(v);\n+    ret vcopy;\n+}\n+\n+/*\n+Function: unsafe_from_bytes\n+\n+Converts a vector of bytes to a string. Does not verify that the\n+vector contains valid UTF-8.\n+*/\n+fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n+    let vcopy: [u8] = v + [0u8];\n+    let scopy: str = unsafe::reinterpret_cast(vcopy);\n+    unsafe::leak(vcopy);\n+    ret scopy;\n+}\n+\n+/*\n+Function: unsafe_from_byte\n+\n+Converts a byte to a string. Does not verify that the byte is\n+valid UTF-8.\n+*/\n+fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n+\n+fn push_utf8_bytes(&s: str, ch: char) {\n+    let code = ch as uint;\n+    let bytes =\n+        if code < max_one_b {\n+            [code as u8]\n+        } else if code < max_two_b {\n+            [code >> 6u & 31u | tag_two_b as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_three_b {\n+            [code >> 12u & 15u | tag_three_b as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_four_b {\n+            [code >> 18u & 7u | tag_four_b as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_five_b {\n+            [code >> 24u & 3u | tag_five_b as u8,\n+             code >> 18u & 63u | tag_cont as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else {\n+            [code >> 30u & 1u | tag_six_b as u8,\n+             code >> 24u & 63u | tag_cont as u8,\n+             code >> 18u & 63u | tag_cont as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        };\n+    push_bytes(s, bytes);\n+}\n+\n+/*\n+Function: from_char\n+\n+Convert a char to a string\n+*/\n+fn from_char(ch: char) -> str {\n+    let buf = \"\";\n+    push_utf8_bytes(buf, ch);\n+    ret buf;\n+}\n+\n+/*\n+Function: from_chars\n+\n+Convert a vector of chars to a string\n+*/\n+fn from_chars(chs: [char]) -> str {\n+    let buf = \"\";\n+    for ch: char in chs { push_utf8_bytes(buf, ch); }\n+    ret buf;\n+}\n+\n+/*\n+Function: utf8_char_width\n+\n+FIXME: What does this function do?\n+*/\n+fn utf8_char_width(b: u8) -> uint {\n+    let byte: uint = b as uint;\n+    if byte < 128u { ret 1u; }\n+    if byte < 192u {\n+        ret 0u; // Not a valid start byte\n+\n+    }\n+    if byte < 224u { ret 2u; }\n+    if byte < 240u { ret 3u; }\n+    if byte < 248u { ret 4u; }\n+    if byte < 252u { ret 5u; }\n+    ret 6u;\n+}\n+\n+/*\n+Function: char_range_at\n+\n+Pluck a character out of a string and return the index of the next character.\n+This function can be used to iterate over the unicode characters of a string.\n+\n+Example:\n+\n+> let s = \"Clam chowder, hot sauce, pork rinds\";\n+> let i = 0;\n+> while i < len(s) {\n+>   let {ch, next} = char_range_at(s, i);\n+>   log ch;\n+>   i = next;\n+> }\n+\n+Parameters:\n+\n+s - The string\n+i - The byte offset of the char to extract\n+\n+Returns:\n+\n+A record {ch: char, next: uint} containing the char value and the byte\n+index of the next unicode character.\n+\n+Failure:\n+\n+If `i` is greater than or equal to the length of the string.\n+If `i` is not the index of the beginning of a valid UTF-8 character.\n+*/\n+fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+    let b0 = s[i];\n+    let w = utf8_char_width(b0);\n+    assert (w != 0u);\n+    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n+    let val = 0u;\n+    let end = i + w;\n+    let i = i + 1u;\n+    while i < end {\n+        let byte = s[i];\n+        assert (byte & 192u8 == tag_cont_u8);\n+        val <<= 6u;\n+        val += byte & 63u8 as uint;\n+        i += 1u;\n+    }\n+    // Clunky way to get the right bits from the first byte. Uses two shifts,\n+    // the first to clip off the marker bits at the left of the byte, and then\n+    // a second (as uint) to get it to the right position.\n+    val += (b0 << (w + 1u as u8) as uint) << ((w - 1u) * 6u - w - 1u);\n+    ret {ch: val as char, next: i};\n+}\n+\n+/*\n+Function: char_at\n+\n+Pluck a character out of a string\n+*/\n+fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+\n+/*\n+Function: iter_chars\n+\n+Iterate over the characters in a string\n+*/\n+\n+fn iter_chars(s: str, it: block(char)) {\n+    let pos = 0u, len = byte_len(s);\n+    while (pos < len) {\n+        let {ch, next} = char_range_at(s, pos);\n+        pos = next;\n+        it(ch);\n+    }\n+}\n+\n+/*\n+Function: loop_chars\n+\n+Loop through a string, char by char\n+\n+Parameters:\n+s  - A string to traverse. It may be empty.\n+it - A block to execute with each consecutive character of `s`.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+ */\n+fn loop_chars(s: str, it: block(char) -> bool) -> bool{\n+    ret loop_chars_sub(s, 0u, byte_len(s), it);\n+}\n+\n+/*\n+Function: loop_chars_sub\n+\n+Loop through a substring, char by char\n+\n+Parameters:\n+s           - A string to traverse. It may be empty.\n+byte_offset - The byte offset at which to start in the string.\n+byte_len    - The number of bytes to traverse in the string\n+it          - A block to execute with each consecutive character of `s`.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+\n+Safety note:\n+- This function does not check whether the substring is valid.\n+- This function fails if `byte_offset` or `byte_len` do not\n+ represent valid positions inside `s`\n+ */\n+fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n+              it: block(char) -> bool) -> bool {\n+   let i = byte_offset;\n+   let result = true;\n+   while i < byte_len {\n+      let {ch, next} = char_range_at(s, i);\n+      if !it(ch) {result = false; break;}\n+      i = next;\n+   }\n+   ret result;\n+}\n+\n+\n+/*\n+Function: char_len\n+\n+Count the number of unicode characters in a string\n+*/\n+fn char_len(s: str) -> uint {\n+    ret char_len_range(s, 0u, byte_len(s));\n+}\n+\n+/*\n+Function: char_len_range\n+\n+As char_len but for a slice of a string\n+\n+Parameters:\n+ s           - A valid string\n+ byte_start  - The position inside `s` where to start counting in bytes.\n+ byte_len    - The number of bytes of `s` to take into account.\n+\n+Returns:\n+ The number of Unicode characters in `s` in\n+segment [byte_start, byte_start+len( .\n+\n+Safety note:\n+- This function does not check whether the substring is valid.\n+- This function fails if `byte_offset` or `byte_len` do not\n+ represent valid positions inside `s`\n+*/\n+fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n+    let i     = byte_start;\n+    let len   = 0u;\n+    while i < byte_len {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        len += 1u;\n+        i += chsize;\n+    }\n+    assert (i == byte_len);\n+    ret len;\n+}\n+\n+/*\n+Function: to_chars\n+\n+Convert a string to a vector of characters\n+*/\n+fn to_chars(s: str) -> [char] {\n+    let buf: [char] = [];\n+    let i = 0u;\n+    let len = byte_len(s);\n+    while i < len {\n+        let cur = char_range_at(s, i);\n+        buf += [cur.ch];\n+        i = cur.next;\n+    }\n+    ret buf;\n+}\n+\n+/*\n+Function: push_char\n+\n+Append a character to a string\n+*/\n+fn push_char(&s: str, ch: char) { s += from_char(ch); }\n+\n+/*\n+Function: pop_char\n+\n+Remove the final character from a string and return it.\n+\n+Failure:\n+\n+If the string does not contain any characters.\n+*/\n+fn pop_char(&s: str) -> char {\n+    let end = byte_len(s);\n+    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n+    assert (end > 0u);\n+    let ch = char_at(s, end - 1u);\n+    s = substr(s, 0u, end - 1u);\n+    ret ch;\n+}\n+\n+/*\n+Function: shift_char\n+\n+Remove the first character from a string and return it.\n+\n+Failure:\n+\n+If the string does not contain any characters.\n+*/\n+fn shift_char(&s: str) -> char {\n+    let r = char_range_at(s, 0u);\n+    s = substr(s, r.next, byte_len(s) - r.next);\n+    ret r.ch;\n+}\n+\n+/*\n+Function: unshift_char\n+\n+Prepend a char to a string\n+*/\n+fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n+\n+/*\n+Function: index\n+\n+Returns the index of the first matching byte. Returns -1 if\n+no match is found.\n+*/\n+fn index(s: str, c: u8) -> int {\n+    let i: int = 0;\n+    for k: u8 in s { if k == c { ret i; } i += 1; }\n+    ret -1;\n+}\n+\n+/*\n+Function: rindex\n+\n+Returns the index of the last matching byte. Returns -1\n+if no match is found.\n+*/\n+fn rindex(s: str, c: u8) -> int {\n+    let n: int = byte_len(s) as int;\n+    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n+    ret n;\n+}\n+\n+/*\n+Function: find\n+\n+Finds the index of the first matching substring.\n+Returns -1 if `haystack` does not contain `needle`.\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+\n+Returns:\n+\n+The index of the first occurance of `needle`, or -1 if not found.\n+*/\n+fn find(haystack: str, needle: str) -> int {\n+    let haystack_len: int = byte_len(haystack) as int;\n+    let needle_len: int = byte_len(needle) as int;\n+    if needle_len == 0 { ret 0; }\n+    fn match_at(haystack: str, needle: str, i: int) -> bool {\n+        let j: int = i;\n+        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n+        ret true;\n+    }\n+    let i: int = 0;\n+    while i <= haystack_len - needle_len {\n+        if match_at(haystack, needle, i) { ret i; }\n+        i += 1;\n+    }\n+    ret -1;\n+}\n+\n+/*\n+Function: contains\n+\n+Returns true if one string contains another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn contains(haystack: str, needle: str) -> bool {\n+    0 <= find(haystack, needle)\n+}\n+\n+/*\n+Function: starts_with\n+\n+Returns true if one string starts with another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn starts_with(haystack: str, needle: str) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    if needle_len == 0u { ret true; }\n+    if needle_len > haystack_len { ret false; }\n+    ret eq(substr(haystack, 0u, needle_len), needle);\n+}\n+\n+/*\n+Function: ends_with\n+\n+Returns true if one string ends with another\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n+fn ends_with(haystack: str, needle: str) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    ret if needle_len == 0u {\n+            true\n+        } else if needle_len > haystack_len {\n+            false\n+        } else {\n+            eq(substr(haystack, haystack_len - needle_len, needle_len),\n+               needle)\n+        };\n+}\n+\n+/*\n+Function: substr\n+\n+Take a substring of another. Returns a string containing `len` bytes\n+starting at byte offset `begin`.\n+\n+This function is not unicode-safe.\n+\n+Failure:\n+\n+If `begin` + `len` is is greater than the byte length of the string\n+*/\n+fn substr(s: str, begin: uint, len: uint) -> str {\n+    ret slice(s, begin, begin + len);\n+}\n+\n+/*\n+Function: slice\n+\n+Takes a bytewise slice from a string. Returns the substring from\n+[`begin`..`end`).\n+\n+This function is not unicode-safe.\n+\n+Failure:\n+\n+- If begin is greater than end.\n+- If end is greater than the length of the string.\n+*/\n+fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+    // FIXME: Typestate precondition\n+    assert (begin <= end);\n+    assert (end <= byte_len(s));\n+\n+    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let v2 = vec::slice(v, begin, end);\n+    unsafe::leak(v);\n+    v2 += [0u8];\n+    let s2: str = unsafe::reinterpret_cast(v2);\n+    unsafe::leak(v2);\n+    ret s2;\n+}\n+\n+/*\n+Function: safe_slice\n+*/\n+fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n+    // would need some magic to make this a precondition\n+    assert (end <= byte_len(s));\n+    ret slice(s, begin, end);\n+}\n+\n+/*\n+Function: shift_byte\n+\n+Removes the first byte from a string and returns it.\n+\n+This function is not unicode-safe.\n+*/\n+fn shift_byte(&s: str) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[0];\n+    s = substr(s, 1u, len - 1u);\n+    ret b;\n+}\n+\n+/*\n+Function: pop_byte\n+\n+Removes the last byte from a string and returns it.\n+\n+This function is not unicode-safe.\n+*/\n+fn pop_byte(&s: str) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[len - 1u];\n+    s = substr(s, 0u, len - 1u);\n+    ret b;\n+}\n+\n+/*\n+Function: push_byte\n+\n+Appends a byte to a string.\n+\n+This function is not unicode-safe.\n+*/\n+fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n+\n+/*\n+Function: push_bytes\n+\n+Appends a vector of bytes to a string.\n+\n+This function is not unicode-safe.\n+*/\n+fn push_bytes(&s: str, bytes: [u8]) {\n+    for byte in bytes { rustrt::rust_str_push(s, byte); }\n+}\n+\n+/*\n+Function: split\n+\n+Split a string at each occurance of a given separator\n+\n+Returns:\n+\n+A vector containing all the strings between each occurance of the separator\n+*/\n+fn split(s: str, sep: u8) -> [str] {\n+    let v: [str] = [];\n+    let accum: str = \"\";\n+    let ends_with_sep: bool = false;\n+    for c: u8 in s {\n+        if c == sep {\n+            v += [accum];\n+            accum = \"\";\n+            ends_with_sep = true;\n+        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+    }\n+    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n+    ret v;\n+}\n+\n+/*\n+Function: concat\n+\n+Concatenate a vector of strings\n+*/\n+fn concat(v: [str]) -> str {\n+    let s: str = \"\";\n+    for ss: str in v { s += ss; }\n+    ret s;\n+}\n+\n+/*\n+Function: connect\n+\n+Concatenate a vector of strings, placing a given separator between each\n+*/\n+fn connect(v: [str], sep: str) -> str {\n+    let s: str = \"\";\n+    let first: bool = true;\n+    for ss: str in v {\n+        if first { first = false; } else { s += sep; }\n+        s += ss;\n+    }\n+    ret s;\n+}\n+\n+// FIXME: This only handles ASCII\n+/*\n+Function: to_upper\n+\n+Convert a string to uppercase\n+*/\n+fn to_upper(s: str) -> str {\n+    let outstr = \"\";\n+    let ascii_a = 'a' as u8;\n+    let ascii_z = 'z' as u8;\n+    let diff = 32u8;\n+    for byte: u8 in s {\n+        let next;\n+        if ascii_a <= byte && byte <= ascii_z {\n+            next = byte - diff;\n+        } else { next = byte; }\n+        push_byte(outstr, next);\n+    }\n+    ret outstr;\n+}\n+\n+// FIXME: This is super-inefficient\n+/*\n+Function: replace\n+\n+Replace all occurances of one string with another\n+\n+Parameters:\n+\n+s - The string containing substrings to replace\n+from - The string to replace\n+to - The replacement string\n+\n+Returns:\n+\n+The original string with all occurances of `from` replaced with `to`\n+*/\n+fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n+    // FIXME (694): Shouldn't have to check this\n+    check (is_not_empty(from));\n+    if byte_len(s) == 0u {\n+        ret \"\";\n+    } else if starts_with(s, from) {\n+        ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n+    } else {\n+        ret unsafe_from_byte(s[0]) +\n+                replace(slice(s, 1u, byte_len(s)), from, to);\n+    }\n+}\n+\n+// FIXME: Also not efficient\n+/*\n+Function: char_slice\n+\n+Unicode-safe slice. Returns a slice of the given string containing\n+the characters in the range [`begin`..`end`). `begin` and `end` are\n+character indexes, not byte indexes.\n+\n+Failure:\n+\n+- If begin is greater than end\n+- If end is greater than the character length of the string\n+*/\n+fn char_slice(s: str, begin: uint, end: uint) -> str {\n+    from_chars(vec::slice(to_chars(s), begin, end))\n+}\n+\n+/*\n+Function: trim_left\n+\n+Returns a string with leading whitespace removed.\n+*/\n+fn trim_left(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n+        let i = 0u;\n+        while i < vec::len(s) {\n+            if !char::is_whitespace(s[i]) { break; }\n+            i += 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n+}\n+\n+/*\n+Function: trim_right\n+\n+Returns a string with trailing whitespace removed.\n+*/\n+fn trim_right(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n+        let i = vec::len(s);\n+        while 0u < i {\n+            if !char::is_whitespace(s[i - 1u]) { break; }\n+            i -= 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, 0u, whities));\n+}\n+\n+/*\n+Function: trim\n+\n+Returns a string with leading and trailing whitespace removed\n+*/\n+fn trim(s: str) -> str { trim_left(trim_right(s)) }\n+\n+/*\n+Type: sbuf\n+\n+An unsafe buffer of bytes. Corresponds to a C char pointer.\n+*/\n+type sbuf = *u8;\n+\n+// NB: This is intentionally unexported because it's easy to misuse (there's\n+// no guarantee that the string is rooted). Instead, use as_buf below.\n+unsafe fn buf(s: str) -> sbuf {\n+    let saddr = ptr::addr_of(s);\n+    let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n+    let buf = vec::to_ptr(*vaddr);\n+    ret buf;\n+}\n+\n+/*\n+Function: as_buf\n+\n+Work with the byte buffer of a string. Allows for unsafe manipulation\n+of strings, which is useful for native interop.\n+\n+Example:\n+\n+> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+\n+*/\n+fn as_buf<T>(s: str, f: block(sbuf) -> T) -> T unsafe {\n+    let buf = buf(s); f(buf)\n+}\n+\n+/*\n+Function: str_from_cstr\n+\n+Create a Rust string from a null-terminated C string\n+*/\n+unsafe fn str_from_cstr(cstr: sbuf) -> str {\n+    let res = \"\";\n+    let start = cstr;\n+    let curr = start;\n+    let i = 0u;\n+    while *curr != 0u8 {\n+        push_byte(res, *curr);\n+        i += 1u;\n+        curr = ptr::offset(start, i);\n+    }\n+    ret res;\n+}\n+\n+/*\n+Function: escape_char\n+\n+Escapes a single character.\n+*/\n+fn escape_char(c: char) -> str {\n+    alt c {\n+      '\"' { \"\\\\\\\"\" }\n+      '\\\\' { \"\\\\\\\\\" }\n+      '\\n' { \"\\\\n\" }\n+      '\\t' { \"\\\\t\" }\n+      '\\r' { \"\\\\r\" }\n+      // FIXME: uncomment this when extfmt is moved to core\n+      // in a snapshot.\n+      // '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n+      v { from_char(c) }\n+    }\n+}\n+\n+/*\n+Function: escape\n+\n+Escapes special characters inside the string, making it safe for transfer.\n+*/\n+fn escape(s: str) -> str {\n+    let r = \"\";\n+    loop_chars(s, { |c| r += escape_char(c); true });\n+    r\n+}"}, {"sha": "3b4a3b8c64378eeae0c037f9c453d26018ffd0bf", "filename": "src/libcore/sys.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,96 @@\n+/*\n+Module: sys\n+\n+Misc low level stuff\n+*/\n+tag type_desc = {\n+    first_param: **ctypes::c_int,\n+    size: ctypes::size_t,\n+    align: ctypes::size_t\n+    // Remaining fields not listed\n+};\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    // Explicitly re-export native stuff we want to be made\n+    // available outside this crate. Otherwise it's\n+    // visible-in-crate, but not re-exported.\n+    fn last_os_error() -> str;\n+    fn refcount<T>(t: @T) -> uint;\n+    fn do_gc();\n+    fn unsupervise();\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn get_type_desc<T>() -> *type_desc;\n+}\n+\n+/*\n+Function: get_type_desc\n+\n+Returns a pointer to a type descriptor. Useful for calling certain\n+function in the Rust runtime or otherwise performing dark magick.\n+*/\n+fn get_type_desc<T>() -> *type_desc {\n+    ret rusti::get_type_desc::<T>();\n+}\n+\n+/*\n+Function: last_os_error\n+\n+Get a string representing the platform-dependent last error\n+*/\n+fn last_os_error() -> str {\n+    ret rustrt::last_os_error();\n+}\n+\n+/*\n+Function: size_of\n+\n+Returns the size of a type\n+*/\n+fn size_of<T>() -> uint unsafe {\n+    ret (*get_type_desc::<T>()).size;\n+}\n+\n+/*\n+Function: align_of\n+\n+Returns the alignment of a type\n+*/\n+fn align_of<T>() -> uint unsafe {\n+    ret (*get_type_desc::<T>()).align;\n+}\n+\n+/*\n+Function: refcount\n+\n+Returns the refcount of a shared box\n+*/\n+fn refcount<T>(t: @T) -> uint {\n+    ret rustrt::refcount::<T>(t);\n+}\n+\n+/*\n+Function: do_gc\n+\n+Force a garbage collection\n+*/\n+fn do_gc() -> () {\n+    ret rustrt::do_gc();\n+}\n+\n+// FIXME: There's a wrapper for this in the task module and this really\n+// just belongs there\n+fn unsupervise() -> () {\n+    ret rustrt::unsupervise();\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "31f01cf838425eb06f51a9085dcda124b840888a", "filename": "src/libcore/task.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,357 @@\n+/*\n+Module: task\n+\n+Task management.\n+\n+An executing Rust program consists of a tree of tasks, each with their own\n+stack, and sole ownership of their allocated heap data. Tasks communicate\n+with each other using ports and channels.\n+\n+When a task fails, that failure will propagate to its parent (the task\n+that spawned it) and the parent will fail as well. The reverse is not\n+true: when a parent task fails its children will continue executing. When\n+the root (main) task fails, all tasks fail, and then so does the entire\n+process.\n+\n+A task may remove itself from this failure propagation mechanism by\n+calling the <unsupervise> function, after which failure will only\n+result in the termination of that task.\n+\n+Tasks may execute in parallel and are scheduled automatically by the runtime.\n+\n+Example:\n+\n+> spawn(\"Hello, World\", fn (&&msg: str) {\n+>   log msg;\n+> });\n+\n+*/\n+import cast = unsafe::reinterpret_cast;\n+import comm;\n+import option::{some, none};\n+import option = option::t;\n+import ptr;\n+\n+export task;\n+export joinable_task;\n+export sleep;\n+export yield;\n+export task_notification;\n+export join;\n+export unsupervise;\n+export pin;\n+export unpin;\n+export set_min_stack;\n+export task_result;\n+export tr_success;\n+export tr_failure;\n+export get_task;\n+export spawn;\n+export spawn_notify;\n+export spawn_joinable;\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    // these must run on the Rust stack so that they can swap stacks etc:\n+    fn task_sleep(task: *rust_task, time_in_us: uint, &killed: bool);\n+}\n+\n+#[link_name = \"rustrt\"]\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    // these can run on the C stack:\n+    fn pin_task();\n+    fn unpin_task();\n+    fn get_task_id() -> task_id;\n+    fn rust_get_task() -> *rust_task;\n+\n+    fn set_min_stack(stack_size: uint);\n+\n+    fn new_task() -> task_id;\n+    fn drop_task(task_id: *rust_task);\n+    fn get_task_pointer(id: task_id) -> *rust_task;\n+\n+    fn migrate_alloc(alloc: *u8, target: task_id);\n+\n+    fn start_task(id: task, closure: *u8);\n+\n+}\n+\n+/* Section: Types */\n+\n+type rust_task =\n+    {id: task,\n+     mutable notify_enabled: int,\n+     mutable notify_chan: comm::chan<task_notification>,\n+     mutable stack_ptr: *u8};\n+\n+resource rust_task_ptr(task: *rust_task) { rustrt::drop_task(task); }\n+\n+type task_id = int;\n+\n+/*\n+Type: task\n+\n+A handle to a task\n+*/\n+type task = task_id;\n+\n+/*\n+Type: joinable_task\n+\n+A task that sends notification upon termination\n+*/\n+type joinable_task = (task, comm::port<task_notification>);\n+\n+/*\n+Tag: task_result\n+\n+Indicates the manner in which a task exited\n+*/\n+tag task_result {\n+    /* Variant: tr_success */\n+    tr_success;\n+    /* Variant: tr_failure */\n+    tr_failure;\n+}\n+\n+/*\n+Tag: task_notification\n+\n+Message sent upon task exit to indicate normal or abnormal termination\n+*/\n+tag task_notification {\n+    /* Variant: exit */\n+    exit(task, task_result);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Type: get_task\n+\n+Retreives a handle to the currently executing task\n+*/\n+fn get_task() -> task { rustrt::get_task_id() }\n+\n+/*\n+Function: sleep\n+\n+Hints the scheduler to yield this task for a specified ammount of time.\n+\n+Parameters:\n+\n+time_in_us - maximum number of microseconds to yield control for\n+*/\n+fn sleep(time_in_us: uint) {\n+    let task = rustrt::rust_get_task();\n+    let killed = false;\n+    // FIXME: uncomment this when extfmt is moved to core\n+    // in a snapshot.\n+    // log #fmt(\"yielding for %u us\", time_in_us);\n+    rusti::task_sleep(task, time_in_us, killed);\n+    if killed {\n+        fail \"killed\";\n+    }\n+}\n+\n+/*\n+Function: yield\n+\n+Yield control to the task scheduler\n+\n+The scheduler may schedule another task to execute.\n+*/\n+fn yield() { sleep(1u) }\n+\n+/*\n+Function: join\n+\n+Wait for a child task to exit\n+\n+The child task must have been spawned with <spawn_joinable>, which\n+produces a notification port that the child uses to communicate its\n+exit status.\n+\n+Returns:\n+\n+A task_result indicating whether the task terminated normally or failed\n+*/\n+fn join(task_port: joinable_task) -> task_result {\n+    let (id, port) = task_port;\n+    alt comm::recv::<task_notification>(port) {\n+      exit(_id, res) {\n+        if _id == id {\n+            ret res\n+        } else {\n+            // FIXME: uncomment this when extfmt is moved to core\n+            // in a snapshot.\n+            // fail #fmt[\"join received id %d, expected %d\", _id, id]\n+            fail;\n+        }\n+      }\n+    }\n+}\n+\n+/*\n+Function: unsupervise\n+\n+Detaches this task from its parent in the task tree\n+\n+An unsupervised task will not propagate its failure up the task tree\n+*/\n+fn unsupervise() { ret sys::unsupervise(); }\n+\n+/*\n+Function: pin\n+\n+Pins the current task and future child tasks to a single scheduler thread\n+*/\n+fn pin() { rustrt::pin_task(); }\n+\n+/*\n+Function: unpin\n+\n+Unpin the current task and future child tasks\n+*/\n+fn unpin() { rustrt::unpin_task(); }\n+\n+/*\n+Function: set_min_stack\n+\n+Set the minimum stack size (in bytes) for tasks spawned in the future.\n+\n+This function has global effect and should probably not be used.\n+*/\n+fn set_min_stack(stack_size: uint) { rustrt::set_min_stack(stack_size); }\n+\n+/*\n+Function: spawn\n+\n+Creates and executes a new child task\n+\n+Sets up a new task with its own call stack and schedules it to be executed.\n+Upon execution the new task will call function `f` with the provided\n+argument `data`.\n+\n+Function `f` is a bare function, meaning it may not close over any data, as do\n+shared functions (fn@) and lambda blocks. `data` must be a uniquely owned\n+type; it is moved into the new task and thus can no longer be accessed\n+locally.\n+\n+Parameters:\n+\n+data - A unique-type value to pass to the new task\n+f - A function to execute in the new task\n+\n+Returns:\n+\n+A handle to the new task\n+*/\n+fn spawn<send T>(-data: T, f: fn(T)) -> task {\n+    spawn_inner(data, f, none)\n+}\n+\n+/*\n+Function: spawn_notify\n+\n+Create and execute a new child task, requesting notification upon its\n+termination\n+\n+Immediately before termination, either on success or failure, the spawned\n+task will send a <task_notification> message on the provided channel.\n+*/\n+fn spawn_notify<send T>(-data: T, f: fn(T),\n+                         notify: comm::chan<task_notification>) -> task {\n+    spawn_inner(data, f, some(notify))\n+}\n+\n+/*\n+Function: spawn_joinable\n+\n+Create and execute a task which can later be joined with the <join> function\n+\n+This is a convenience wrapper around spawn_notify which, when paired\n+with <join> can be easily used to spawn a task then wait for it to\n+complete.\n+*/\n+fn spawn_joinable<send T>(-data: T, f: fn(T)) -> joinable_task {\n+    let p = comm::port::<task_notification>();\n+    let id = spawn_notify(data, f, comm::chan::<task_notification>(p));\n+    ret (id, p);\n+}\n+\n+// FIXME: To transition from the unsafe spawn that spawns a shared closure to\n+// the safe spawn that spawns a bare function we're going to write\n+// barefunc-spawn on top of unsafe-spawn.  Sadly, bind does not work reliably\n+// enough to suite our needs (#1034, probably others yet to be discovered), so\n+// we're going to copy the bootstrap data into a unique pointer, cast it to an\n+// unsafe pointer then wrap up the bare function and the unsafe pointer in a\n+// shared closure to spawn.\n+//\n+// After the transition this should all be rewritten.\n+\n+fn spawn_inner<send T>(-data: T, f: fn(T),\n+                          notify: option<comm::chan<task_notification>>)\n+    -> task unsafe {\n+\n+    fn wrapper<send T>(data: *u8, f: fn(T)) unsafe {\n+        let data: ~T = unsafe::reinterpret_cast(data);\n+        f(*data);\n+    }\n+\n+    let data = ~data;\n+    let dataptr: *u8 = unsafe::reinterpret_cast(data);\n+    unsafe::leak(data);\n+    let wrapped = bind wrapper(dataptr, f);\n+    ret unsafe_spawn_inner(wrapped, notify);\n+}\n+\n+// FIXME: This is the old spawn function that spawns a shared closure.\n+// It is a hack and needs to be rewritten.\n+fn unsafe_spawn_inner(-thunk: fn@(),\n+                      notify: option<comm::chan<task_notification>>) ->\n+   task unsafe {\n+    let id = rustrt::new_task();\n+\n+    let raw_thunk: {code: uint, env: uint} = cast(thunk);\n+\n+    // set up the task pointer\n+    let task_ptr <- rust_task_ptr(rustrt::get_task_pointer(id));\n+\n+    assert (ptr::null() != (**task_ptr).stack_ptr);\n+\n+    // copy the thunk from our stack to the new stack\n+    let sp: uint = cast((**task_ptr).stack_ptr);\n+    let ptrsize = sys::size_of::<*u8>();\n+    let thunkfn: *mutable uint = cast(sp - ptrsize * 2u);\n+    let thunkenv: *mutable uint = cast(sp - ptrsize);\n+    *thunkfn = cast(raw_thunk.code);;\n+    *thunkenv = cast(raw_thunk.env);;\n+    // align the stack to 16 bytes\n+    (**task_ptr).stack_ptr = cast(sp - ptrsize * 4u);\n+\n+    // set up notifications if they are enabled.\n+    alt notify {\n+      some(c) {\n+        (**task_ptr).notify_enabled = 1;\n+        (**task_ptr).notify_chan = c;\n+      }\n+      none { }\n+    }\n+\n+    // give the thunk environment's allocation to the new task\n+    rustrt::migrate_alloc(cast(raw_thunk.env), id);\n+    rustrt::start_task(id, cast(thunkfn));\n+    // don't cleanup the thunk in this task\n+    unsafe::leak(thunk);\n+    ret id;\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "f33b8414a4d2eee46ac188d5fb90414fefc3f4d3", "filename": "src/libcore/u32.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu32.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,27 @@\n+/*\n+Module: u32\n+*/\n+\n+/*\n+Const: min_value\n+\n+Return the minimal value for a u32\n+*/\n+const min_value: u32 = 0u32;\n+\n+/*\n+Const: max_value\n+\n+Return the maximal value for a u32\n+*/\n+const max_value: u32 = 0xffff_ffffu32;\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "0e1a330c6631176565a0f9d144ef565d69e68583", "filename": "src/libcore/u64.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,88 @@\n+/*\n+Module: u64\n+*/\n+\n+/*\n+Const: min_value\n+\n+Return the minimal value for a u64\n+*/\n+const min_value: u64 = 0u64;\n+\n+/*\n+Const: max_value\n+\n+Return the maximal value for a u64\n+*/\n+const max_value: u64 = 18446744073709551615u64;\n+\n+/*\n+Function: to_str\n+\n+Convert to a string in a given base\n+*/\n+fn to_str(n: u64, radix: uint) -> str {\n+    assert (0u < radix && radix <= 16u);\n+\n+    let r64 = radix as u64;\n+\n+    fn digit(n: u64) -> str {\n+        ret alt n {\n+              0u64 { \"0\" }\n+              1u64 { \"1\" }\n+              2u64 { \"2\" }\n+              3u64 { \"3\" }\n+              4u64 { \"4\" }\n+              5u64 { \"5\" }\n+              6u64 { \"6\" }\n+              7u64 { \"7\" }\n+              8u64 { \"8\" }\n+              9u64 { \"9\" }\n+              10u64 { \"a\" }\n+              11u64 { \"b\" }\n+              12u64 { \"c\" }\n+              13u64 { \"d\" }\n+              14u64 { \"e\" }\n+              15u64 { \"f\" }\n+              _ { fail }\n+            };\n+    }\n+\n+    if n == 0u64 { ret \"0\"; }\n+\n+    let s = \"\";\n+\n+    let n = n;\n+    while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n+    ret s;\n+}\n+\n+/*\n+Function: str\n+\n+Convert to a string\n+*/\n+fn str(n: u64) -> str { ret to_str(n, 10u); }\n+\n+/*\n+Function: parse_buf\n+\n+Parse a string as an unsigned integer.\n+*/\n+fn from_str(buf: str, radix: u64) -> u64 {\n+    if str::byte_len(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = str::byte_len(buf) - 1u;\n+    let power = 1u64, n = 0u64;\n+    while true {\n+        let digit = char::to_digit(buf[i] as char) as u64;\n+        if digit >= radix { fail; }\n+        n += digit * power;\n+        power *= radix;\n+        if i == 0u { ret n; }\n+        i -= 1u;\n+    }\n+    fail;\n+}"}, {"sha": "eadfcadda4a12cd15f547cd91bae50cc944d7b2c", "filename": "src/libcore/u8.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu8.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,68 @@\n+/*\n+Module: u8\n+*/\n+\n+/*\n+Const: max_value\n+\n+The maximum value of a u8.\n+*/\n+const max_value: u8 = 255u8;\n+\n+/*\n+Const: min_value\n+\n+The minumum value of a u8.\n+*/\n+const min_value: u8 = 0u8;\n+\n+/* Function: add */\n+pure fn add(x: u8, y: u8) -> u8 { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: u8, y: u8) -> u8 { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: u8, y: u8) -> u8 { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: u8, y: u8) -> u8 { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: u8, y: u8) -> u8 { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: u8, y: u8) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: u8, y: u8) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: u8, y: u8) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: u8, y: u8) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: u8, y: u8) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: u8, y: u8) -> bool { ret x > y; }\n+\n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n+fn range(lo: u8, hi: u8, it: block(u8)) {\n+    let i = lo;\n+    while i < hi { it(i); i += 1u8; }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "ae1ba628aa644596af9c903e3cf8ca460be9f8d8", "filename": "src/libcore/uint.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,254 @@\n+/*\n+Module: uint\n+*/\n+\n+/*\n+Const: min_value\n+\n+Return the minimal value for an uint.\n+\n+This is always 0\n+*/\n+const min_value: uint = 0u;\n+\n+/*\n+Const: max_value\n+\n+Return the maximal value for an uint.\n+\n+This is 2^wordsize - 1\n+*/\n+const max_value: uint = 0u - 1u;\n+\n+/* Function: add */\n+pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: uint, y: uint) -> uint { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: uint, y: uint) -> uint { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: uint, y: uint) -> uint { ret x / y; }\n+\n+/* Function: div_ceil\n+\n+   Divide two numbers, return the result, rounded up.\n+\n+   Parameters:\n+   x - an integer\n+   y - an integer distinct from 0u\n+\n+   Return:\n+    The smallest integer `q` such that `x/y <= q`.\n+*/\n+pure fn div_ceil(x: uint, y: uint) -> uint {\n+    let div = div(x, y);\n+    if x % y == 0u { ret div;}\n+    else { ret div + 1u; }\n+}\n+\n+/* Function: div_ceil\n+\n+   Divide two numbers, return the result, rounded to the closest integer.\n+\n+   Parameters:\n+   x - an integer\n+   y - an integer distinct from 0u\n+\n+   Return:\n+    The integer `q` closest to `x/y`.\n+*/\n+pure fn div_round(x: uint, y: uint) -> uint {\n+    let div = div(x, y);\n+    if x % y * 2u  < y { ret div;}\n+    else { ret div + 1u; }\n+}\n+\n+/* Function: div_ceil\n+\n+   Divide two numbers, return the result, rounded down.\n+\n+   Parameters:\n+   x - an integer\n+   y - an integer distinct from 0u\n+\n+   Note: This is the same function as `div`.\n+\n+   Return:\n+    The smallest integer `q` such that `x/y <= q`. This\n+   is either `x/y` or `x/y + 1`.\n+*/\n+pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n+\n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n+fn range(lo: uint, hi: uint, it: block(uint)) {\n+    let i = lo;\n+    while i < hi { it(i); i += 1u; }\n+}\n+\n+/*\n+Function: loop\n+\n+Iterate over the range [`lo`..`hi`), or stop when requested\n+\n+Parameters:\n+lo - The integer at which to start the loop (included)\n+hi - The integer at which to stop the loop (excluded)\n+it - A block to execute with each consecutive integer of the range.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+*/\n+fn loop(lo: uint, hi: uint, it: block(uint) -> bool) -> bool {\n+    let i = lo;\n+    while i < hi {\n+        if (!it(i)) { ret false; }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+/*\n+Function: next_power_of_two\n+\n+Returns the smallest power of 2 greater than or equal to `n`\n+*/\n+fn next_power_of_two(n: uint) -> uint {\n+    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let tmp: uint = n - 1u;\n+    let shift: uint = 1u;\n+    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+    ret tmp + 1u;\n+}\n+\n+/*\n+Function: parse_buf\n+\n+Parse a buffer of bytes\n+\n+Parameters:\n+\n+buf - A byte buffer\n+radix - The base of the number\n+\n+Failure:\n+\n+buf must not be empty\n+*/\n+fn parse_buf(buf: [u8], radix: uint) -> uint {\n+    if vec::len::<u8>(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = vec::len::<u8>(buf) - 1u;\n+    let power = 1u;\n+    let n = 0u;\n+    while true {\n+        let digit = char::to_digit(buf[i] as char);\n+        if (digit as uint) >= radix {\n+            fail;\n+        }\n+        n += (digit as uint) * power;\n+        power *= radix;\n+        if i == 0u { ret n; }\n+        i -= 1u;\n+    }\n+    fail;\n+}\n+\n+/*\n+Function: from_str\n+\n+Parse a string to an int\n+\n+Failure:\n+\n+s must not be empty\n+*/\n+fn from_str(s: str) -> uint { parse_buf(str::bytes(s), 10u) }\n+\n+/*\n+Function: to_str\n+\n+Convert to a string in a given base\n+*/\n+fn to_str(num: uint, radix: uint) -> str {\n+    let n = num;\n+    assert (0u < radix && radix <= 16u);\n+    fn digit(n: uint) -> char {\n+        ret alt n {\n+              0u { '0' }\n+              1u { '1' }\n+              2u { '2' }\n+              3u { '3' }\n+              4u { '4' }\n+              5u { '5' }\n+              6u { '6' }\n+              7u { '7' }\n+              8u { '8' }\n+              9u { '9' }\n+              10u { 'a' }\n+              11u { 'b' }\n+              12u { 'c' }\n+              13u { 'd' }\n+              14u { 'e' }\n+              15u { 'f' }\n+              _ { fail }\n+            };\n+    }\n+    if n == 0u { ret \"0\"; }\n+    let s: str = \"\";\n+    while n != 0u {\n+        s += str::unsafe_from_byte(digit(n % radix) as u8);\n+        n /= radix;\n+    }\n+    let s1: str = \"\";\n+    let len: uint = str::byte_len(s);\n+    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n+    ret s1;\n+}\n+\n+/*\n+Function: str\n+\n+Convert to a string\n+*/\n+fn str(i: uint) -> str { ret to_str(i, 10u); }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "22cce4956498260f83a5fd5771d0266c071c3c0c", "filename": "src/libcore/unsafe.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,41 @@\n+/*\n+Module: unsafe\n+\n+Unsafe operations\n+*/\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn cast<T, U>(src: T) -> U;\n+}\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    fn leak<T>(-thing: T);\n+}\n+\n+/*\n+Function: reinterpret_cast\n+\n+Casts the value at `src` to U. The two types must have the same length.\n+*/\n+unsafe fn reinterpret_cast<T, U>(src: T) -> U {\n+    let t1 = sys::get_type_desc::<T>();\n+    let t2 = sys::get_type_desc::<U>();\n+    if (*t1).size != (*t2).size {\n+        fail \"attempt to cast values of differing sizes\";\n+    }\n+    ret rusti::cast(src);\n+}\n+\n+/*\n+Function: leak\n+\n+Move `thing` into the void.\n+\n+The leak function will take ownership of the provided value but neglect\n+to run any required cleanup or memory-management operations on it. This\n+can be used for various acts of magick, particularly when using\n+reinterpret_cast on managed pointer types.\n+*/\n+unsafe fn leak<T>(-thing: T) { rustrt::leak(thing); }"}, {"sha": "d8f89b3b27bc943407e23048c94832c913faa933", "filename": "src/libcore/vec.rs", "status": "added", "additions": 835, "deletions": 0, "changes": 835, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -0,0 +1,835 @@\n+/*\n+Module: vec\n+*/\n+\n+import option::{some, none};\n+import uint::next_power_of_two;\n+import ptr::addr_of;\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn vec_len<T>(&&v: [const T]) -> uint;\n+}\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    fn vec_reserve_shared<T>(t: *sys::type_desc,\n+                             &v: [const T],\n+                             n: uint);\n+    fn vec_from_buf_shared<T>(t: *sys::type_desc,\n+                              ptr: *T,\n+                              count: uint) -> [T];\n+}\n+\n+/*\n+Type: init_op\n+\n+A function used to initialize the elements of a vector.\n+*/\n+type init_op<T> = block(uint) -> T;\n+\n+\n+/*\n+Predicate: is_empty\n+\n+Returns true if a vector contains no elements.\n+*/\n+pure fn is_empty<T>(v: [const T]) -> bool {\n+    // FIXME: This would be easier if we could just call len\n+    for t: T in v { ret false; }\n+    ret true;\n+}\n+\n+/*\n+Predicate: is_not_empty\n+\n+Returns true if a vector contains some elements.\n+*/\n+pure fn is_not_empty<T>(v: [const T]) -> bool { ret !is_empty(v); }\n+\n+/*\n+Predicate: same_length\n+\n+Returns true if two vectors have the same length\n+*/\n+pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n+    vec::len(xs) == vec::len(ys)\n+}\n+\n+/*\n+Function: reserve\n+\n+Reserves capacity for `n` elements in the given vector.\n+\n+If the capacity for `v` is already equal to or greater than the requested\n+capacity, then no action is taken.\n+\n+Parameters:\n+\n+v - A vector\n+n - The number of elements to reserve space for\n+*/\n+fn reserve<T>(&v: [const T], n: uint) {\n+    rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n+}\n+\n+/*\n+Function: len\n+\n+Returns the length of a vector\n+*/\n+pure fn len<T>(v: [const T]) -> uint { unchecked { rusti::vec_len(v) } }\n+\n+/*\n+Function: init_fn\n+\n+Creates and initializes an immutable vector.\n+\n+Creates an immutable vector of size `n_elts` and initializes the elements\n+to the value returned by the function `op`.\n+*/\n+fn init_fn<T>(op: init_op<T>, n_elts: uint) -> [T] {\n+    let v = [];\n+    reserve(v, n_elts);\n+    let i: uint = 0u;\n+    while i < n_elts { v += [op(i)]; i += 1u; }\n+    ret v;\n+}\n+\n+// TODO: Remove me once we have slots.\n+/*\n+Function: init_fn_mut\n+\n+Creates and initializes a mutable vector.\n+\n+Creates a mutable vector of size `n_elts` and initializes the elements to\n+the value returned by the function `op`.\n+*/\n+fn init_fn_mut<T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n+    let v = [mutable];\n+    reserve(v, n_elts);\n+    let i: uint = 0u;\n+    while i < n_elts { v += [mutable op(i)]; i += 1u; }\n+    ret v;\n+}\n+\n+/*\n+Function: init_elt\n+\n+Creates and initializes an immutable vector.\n+\n+Creates an immutable vector of size `n_elts` and initializes the elements\n+to the value `t`.\n+*/\n+fn init_elt<copy T>(t: T, n_elts: uint) -> [T] {\n+    let v = [];\n+    reserve(v, n_elts);\n+    let i: uint = 0u;\n+    while i < n_elts { v += [t]; i += 1u; }\n+    ret v;\n+}\n+\n+// TODO: Remove me once we have slots.\n+/*\n+Function: init_elt_mut\n+\n+Creates and initializes a mutable vector.\n+\n+Creates a mutable vector of size `n_elts` and initializes the elements\n+to the value `t`.\n+*/\n+fn init_elt_mut<copy T>(t: T, n_elts: uint) -> [mutable T] {\n+    let v = [mutable];\n+    reserve(v, n_elts);\n+    let i: uint = 0u;\n+    while i < n_elts { v += [mutable t]; i += 1u; }\n+    ret v;\n+}\n+\n+// FIXME: Possible typestate postcondition:\n+// len(result) == len(v) (needs issue #586)\n+/*\n+Function: to_mut\n+\n+Produces a mutable vector from an immutable vector.\n+*/\n+fn to_mut<copy T>(v: [T]) -> [mutable T] {\n+    let vres = [mutable];\n+    for t: T in v { vres += [mutable t]; }\n+    ret vres;\n+}\n+\n+// Same comment as from_mut\n+/*\n+Function: from_mut\n+\n+Produces an immutable vector from a mutable vector.\n+*/\n+fn from_mut<copy T>(v: [mutable T]) -> [T] {\n+    let vres = [];\n+    for t: T in v { vres += [t]; }\n+    ret vres;\n+}\n+\n+// Accessors\n+\n+/*\n+Function: head\n+\n+Returns the first element of a vector\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n+fn head<copy T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n+\n+/*\n+Function: tail\n+\n+Returns all but the first element of a vector\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n+fn tail<copy T>(v: [const T]) : is_not_empty(v) -> [T] {\n+    ret slice(v, 1u, len(v));\n+}\n+\n+// FIXME: This name is sort of confusing next to init_fn, etc\n+// but this is the name haskell uses for this function,\n+// along with head/tail/last.\n+/*\n+Function: init\n+\n+Returns all but the last elemnt of a vector\n+\n+Preconditions:\n+`v` is not empty\n+*/\n+fn init<copy T>(v: [const T]) -> [T] {\n+    assert len(v) != 0u;\n+    slice(v, 0u, len(v) - 1u)\n+}\n+\n+/*\n+Function: last\n+\n+Returns the last element of a vector\n+\n+Returns:\n+\n+An option containing the last element of `v` if `v` is not empty, or\n+none if `v` is empty.\n+*/\n+fn last<copy T>(v: [const T]) -> option::t<T> {\n+    if len(v) == 0u { ret none; }\n+    ret some(v[len(v) - 1u]);\n+}\n+\n+/*\n+Function: last_total\n+\n+Returns the last element of a non-empty vector `v`\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n+fn last_total<copy T>(v: [const T]) : is_not_empty(v) -> T {\n+    ret v[len(v) - 1u];\n+}\n+\n+/*\n+Function: slice\n+\n+Returns a copy of the elements from [`start`..`end`) from `v`.\n+*/\n+fn slice<copy T>(v: [const T], start: uint, end: uint) -> [T] {\n+    assert (start <= end);\n+    assert (end <= len(v));\n+    let result = [];\n+    reserve(result, end - start);\n+    let i = start;\n+    while i < end { result += [v[i]]; i += 1u; }\n+    ret result;\n+}\n+\n+// TODO: Remove me once we have slots.\n+/*\n+Function: slice_mut\n+\n+Returns a copy of the elements from [`start`..`end`) from `v`.\n+*/\n+fn slice_mut<copy T>(v: [const T], start: uint, end: uint) -> [mutable T] {\n+    assert (start <= end);\n+    assert (end <= len(v));\n+    let result = [mutable];\n+    reserve(result, end - start);\n+    let i = start;\n+    while i < end { result += [mutable v[i]]; i += 1u; }\n+    ret result;\n+}\n+\n+\n+// Mutators\n+\n+/*\n+Function: shift\n+\n+Removes the first element from a vector and return it\n+*/\n+fn shift<copy T>(&v: [const T]) -> T {\n+    let ln = len::<T>(v);\n+    assert (ln > 0u);\n+    let e = v[0];\n+    v = slice::<T>(v, 1u, ln);\n+    ret e;\n+}\n+\n+// TODO: Write this, unsafely, in a way that's not O(n).\n+/*\n+Function: pop\n+\n+Remove the last element from a vector and return it\n+*/\n+fn pop<copy T>(&v: [const T]) -> T {\n+    let ln = len(v);\n+    assert (ln > 0u);\n+    ln -= 1u;\n+    let e = v[ln];\n+    v = slice(v, 0u, ln);\n+    ret e;\n+}\n+\n+// TODO: More.\n+\n+\n+// Appending\n+\n+/*\n+Function: grow\n+\n+Expands a vector in place, initializing the new elements to a given value\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+initval - The value for the new elements\n+*/\n+fn grow<copy T>(&v: [T], n: uint, initval: T) {\n+    reserve(v, next_power_of_two(len(v) + n));\n+    let i: uint = 0u;\n+    while i < n { v += [initval]; i += 1u; }\n+}\n+\n+// TODO: Remove me once we have slots.\n+// FIXME: Can't grow take a [const T]\n+/*\n+Function: grow_mut\n+\n+Expands a vector in place, initializing the new elements to a given value\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+initval - The value for the new elements\n+*/\n+fn grow_mut<copy T>(&v: [mutable T], n: uint, initval: T) {\n+    reserve(v, next_power_of_two(len(v) + n));\n+    let i: uint = 0u;\n+    while i < n { v += [mutable initval]; i += 1u; }\n+}\n+\n+/*\n+Function: grow_fn\n+\n+Expands a vector in place, initializing the new elements to the result of a\n+function\n+\n+Function `init_fn` is called `n` times with the values [0..`n`)\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+init_fn - A function to call to retreive each appended element's value\n+*/\n+fn grow_fn<T>(&v: [T], n: uint, op: init_op<T>) {\n+    reserve(v, next_power_of_two(len(v) + n));\n+    let i: uint = 0u;\n+    while i < n { v += [op(i)]; i += 1u; }\n+}\n+\n+/*\n+Function: grow_set\n+\n+Sets the value of a vector element at a given index, growing the vector as\n+needed\n+\n+Sets the element at position `index` to `val`. If `index` is past the end\n+of the vector, expands the vector by replicating `initval` to fill the\n+intervening space.\n+*/\n+fn grow_set<copy T>(&v: [mutable T], index: uint, initval: T, val: T) {\n+    if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n+    v[index] = val;\n+}\n+\n+\n+// Functional utilities\n+\n+/*\n+Function: map\n+\n+Apply a function to each element of a vector and return the results\n+*/\n+fn map<T, U>(f: block(T) -> U, v: [T]) -> [U] {\n+    let result = [];\n+    reserve(result, len(v));\n+    for elem: T in v { result += [f(elem)]; }\n+    ret result;\n+}\n+\n+/*\n+Function: map_mut\n+\n+Apply a function to each element of a mutable vector and return the results\n+*/\n+fn map_mut<copy T, U>(f: block(T) -> U, v: [const T]) -> [U] {\n+    let result = [];\n+    reserve(result, len(v));\n+    for elem: T in v {\n+        // copy satisfies alias checker\n+        result += [f(copy elem)];\n+    }\n+    ret result;\n+}\n+\n+/*\n+Function: map2\n+\n+Apply a function to each pair of elements and return the results\n+*/\n+fn map2<copy T, copy U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n+    let v0_len = len(v0);\n+    if v0_len != len(v1) { fail; }\n+    let u: [V] = [];\n+    let i = 0u;\n+    while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n+    ret u;\n+}\n+\n+/*\n+Function: filter_map\n+\n+Apply a function to each element of a vector and return the results\n+\n+If function `f` returns `none` then that element is excluded from\n+the resulting vector.\n+*/\n+fn filter_map<copy T, copy U>(f: block(T) -> option::t<U>, v: [const T])\n+    -> [U] {\n+    let result = [];\n+    for elem: T in v {\n+        alt f(copy elem) {\n+          none. {/* no-op */ }\n+          some(result_elem) { result += [result_elem]; }\n+        }\n+    }\n+    ret result;\n+}\n+\n+/*\n+Function: filter\n+\n+Construct a new vector from the elements of a vector for which some predicate\n+holds.\n+\n+Apply function `f` to each element of `v` and return a vector containing\n+only those elements for which `f` returned true.\n+*/\n+fn filter<copy T>(f: block(T) -> bool, v: [T]) -> [T] {\n+    let result = [];\n+    for elem: T in v {\n+        if f(elem) { result += [elem]; }\n+    }\n+    ret result;\n+}\n+\n+/*\n+Function: concat\n+\n+Concatenate a vector of vectors. Flattens a vector of vectors of T into\n+a single vector of T.\n+*/\n+fn concat<copy T>(v: [const [const T]]) -> [T] {\n+    let new: [T] = [];\n+    for inner: [T] in v { new += inner; }\n+    ret new;\n+}\n+\n+/*\n+Function: foldl\n+\n+Reduce a vector from left to right\n+*/\n+fn foldl<copy T, U>(p: block(T, U) -> T, z: T, v: [const U]) -> T {\n+    let accum = z;\n+    iter(v) { |elt|\n+        accum = p(accum, elt);\n+    }\n+    ret accum;\n+}\n+\n+/*\n+Function: foldr\n+\n+Reduce a vector from right to left\n+*/\n+fn foldr<T, copy U>(p: block(T, U) -> U, z: U, v: [const T]) -> U {\n+    let accum = z;\n+    riter(v) { |elt|\n+        accum = p(elt, accum);\n+    }\n+    ret accum;\n+}\n+\n+/*\n+Function: any\n+\n+Return true if a predicate matches any elements\n+\n+If the vector contains no elements then false is returned.\n+*/\n+fn any<T>(f: block(T) -> bool, v: [T]) -> bool {\n+    for elem: T in v { if f(elem) { ret true; } }\n+    ret false;\n+}\n+\n+/*\n+Function: all\n+\n+Return true if a predicate matches all elements\n+\n+If the vector contains no elements then true is returned.\n+*/\n+fn all<T>(f: block(T) -> bool, v: [T]) -> bool {\n+    for elem: T in v { if !f(elem) { ret false; } }\n+    ret true;\n+}\n+\n+/*\n+Function: member\n+\n+Return true if a vector contains an element with the given value\n+*/\n+fn member<T>(x: T, v: [T]) -> bool {\n+    for elt: T in v { if x == elt { ret true; } }\n+    ret false;\n+}\n+\n+/*\n+Function: count\n+\n+Returns the number of elements that are equal to a given value\n+*/\n+fn count<T>(x: T, v: [const T]) -> uint {\n+    let cnt = 0u;\n+    for elt: T in v { if x == elt { cnt += 1u; } }\n+    ret cnt;\n+}\n+\n+/*\n+Function: find\n+\n+Search for an element that matches a given predicate\n+\n+Apply function `f` to each element of `v`, starting from the first.\n+When function `f` returns true then an option containing the element\n+is returned. If `f` matches no elements then none is returned.\n+*/\n+fn find<copy T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n+    for elt: T in v { if f(elt) { ret some(elt); } }\n+    ret none;\n+}\n+\n+/*\n+Function: position\n+\n+Find the first index containing a matching value\n+\n+Returns:\n+\n+option::some(uint) - The first index containing a matching value\n+option::none - No elements matched\n+*/\n+fn position<T>(x: T, v: [T]) -> option::t<uint> {\n+    let i: uint = 0u;\n+    while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n+    ret none;\n+}\n+\n+/*\n+Function: position_pred\n+\n+Find the first index for which the value matches some predicate\n+*/\n+fn position_pred<T>(f: block(T) -> bool, v: [T]) -> option::t<uint> {\n+    let i: uint = 0u;\n+    while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n+    ret none;\n+}\n+\n+// FIXME: if issue #586 gets implemented, could have a postcondition\n+// saying the two result lists have the same length -- or, could\n+// return a nominal record with a constraint saying that, instead of\n+// returning a tuple (contingent on issue #869)\n+/*\n+Function: unzip\n+\n+Convert a vector of pairs into a pair of vectors\n+\n+Returns a tuple containing two vectors where the i-th element of the first\n+vector contains the first element of the i-th tuple of the input vector,\n+and the i-th element of the second vector contains the second element\n+of the i-th tuple of the input vector.\n+*/\n+fn unzip<copy T, copy U>(v: [(T, U)]) -> ([T], [U]) {\n+    let as = [], bs = [];\n+    for (a, b) in v { as += [a]; bs += [b]; }\n+    ret (as, bs);\n+}\n+\n+/*\n+Function: zip\n+\n+Convert two vectors to a vector of pairs\n+\n+Returns a vector of tuples, where the i-th tuple contains contains the\n+i-th elements from each of the input vectors.\n+\n+Preconditions:\n+\n+<same_length> (v, u)\n+*/\n+fn zip<copy T, copy U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n+    let zipped = [];\n+    let sz = len(v), i = 0u;\n+    assert (sz == len(u));\n+    while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n+    ret zipped;\n+}\n+\n+/*\n+Function: swap\n+\n+Swaps two elements in a vector\n+\n+Parameters:\n+v - The input vector\n+a - The index of the first element\n+b - The index of the second element\n+*/\n+fn swap<T>(v: [mutable T], a: uint, b: uint) {\n+    v[a] <-> v[b];\n+}\n+\n+/*\n+Function: reverse\n+\n+Reverse the order of elements in a vector, in place\n+*/\n+fn reverse<T>(v: [mutable T]) {\n+    let i: uint = 0u;\n+    let ln = len::<T>(v);\n+    while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n+}\n+\n+\n+/*\n+Function: reversed\n+\n+Returns a vector with the order of elements reversed\n+*/\n+fn reversed<copy T>(v: [const T]) -> [T] {\n+    let rs: [T] = [];\n+    let i = len::<T>(v);\n+    if i == 0u { ret rs; } else { i -= 1u; }\n+    while i != 0u { rs += [v[i]]; i -= 1u; }\n+    rs += [v[0]];\n+    ret rs;\n+}\n+\n+// FIXME: Seems like this should take char params. Maybe belongs in char\n+/*\n+Function: enum_chars\n+\n+Returns a vector containing a range of chars\n+*/\n+fn enum_chars(start: u8, end: u8) : u8::le(start, end) -> [char] {\n+    let i = start;\n+    let r = [];\n+    while i <= end { r += [i as char]; i += 1u as u8; }\n+    ret r;\n+}\n+\n+// FIXME: Probably belongs in uint. Compare to uint::range\n+/*\n+Function: enum_uints\n+\n+Returns a vector containing a range of uints\n+*/\n+fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n+    let i = start;\n+    let r = [];\n+    while i <= end { r += [i]; i += 1u; }\n+    ret r;\n+}\n+\n+/*\n+Function: iter\n+\n+Iterates over a vector\n+\n+Iterates over vector `v` and, for each element, calls function `f` with the\n+element's value.\n+\n+*/\n+fn iter<T>(v: [const T], f: block(T)) {\n+    iter2(v) { |_i, v| f(v) }\n+}\n+\n+/*\n+Function: iter2\n+\n+Iterates over a vector's elements and indexes\n+\n+Iterates over vector `v` and, for each element, calls function `f` with the\n+element's value and index.\n+*/\n+fn iter2<T>(v: [const T], f: block(uint, T)) {\n+    let i = 0u, l = len(v);\n+    while i < l { f(i, v[i]); i += 1u; }\n+}\n+\n+/*\n+Function: riter\n+\n+Iterates over a vector in reverse\n+\n+Iterates over vector `v` and, for each element, calls function `f` with the\n+element's value.\n+\n+*/\n+fn riter<T>(v: [const T], f: block(T)) {\n+    riter2(v) { |_i, v| f(v) }\n+}\n+\n+/*\n+Function: riter2\n+\n+Iterates over a vector's elements and indexes in reverse\n+\n+Iterates over vector `v` and, for each element, calls function `f` with the\n+element's value and index.\n+*/\n+fn riter2<T>(v: [const T], f: block(uint, T)) {\n+    let i = len(v);\n+    while 0u < i {\n+        i -= 1u;\n+        f(i, v[i]);\n+    };\n+}\n+\n+/*\n+Function: permute\n+\n+Iterate over all permutations of vector `v`.  Permutations are produced in\n+lexicographic order with respect to the order of elements in `v` (so if `v`\n+is sorted then the permutations are lexicographically sorted).\n+\n+The total number of permutations produced is `len(v)!`.  If `v` contains\n+repeated elements, then some permutations are repeated.\n+*/\n+fn permute<copy T>(v: [const T], put: block([T])) {\n+  let ln = len(v);\n+  if ln == 0u {\n+    put([]);\n+  } else {\n+    let i = 0u;\n+    while i < ln {\n+      let elt = v[i];\n+      let rest = slice(v, 0u, i) + slice(v, i+1u, ln);\n+      permute(rest) {|permutation| put([elt] + permutation)}\n+      i += 1u;\n+    }\n+  }\n+}\n+\n+/*\n+Function: to_ptr\n+\n+FIXME: We don't need this wrapper\n+*/\n+unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n+\n+/*\n+Module: unsafe\n+*/\n+mod unsafe {\n+    type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n+\n+    /*\n+    Function: from_buf\n+\n+    Constructs a vector from an unsafe pointer to a buffer\n+\n+    Parameters:\n+\n+    ptr - An unsafe pointer to a buffer of `T`\n+    elts - The number of elements in the buffer\n+    */\n+    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n+        ret rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n+                                        ptr, elts);\n+    }\n+\n+    /*\n+    Function: set_len\n+\n+    Sets the length of a vector\n+\n+    This well explicitly set the size of the vector, without actually\n+    modifing its buffers, so it is up to the caller to ensure that\n+    the vector is actually the specified size.\n+    */\n+    unsafe fn set_len<T>(&v: [const T], new_len: uint) {\n+        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).fill = new_len * sys::size_of::<T>();\n+    }\n+\n+    /*\n+    Function: to_ptr\n+\n+    Returns an unsafe pointer to the vector's buffer\n+\n+    The caller must ensure that the vector outlives the pointer this\n+    function returns, or else it will end up pointing to garbage.\n+\n+    Modifying the vector may cause its buffer to be reallocated, which\n+    would also make any pointers to it invalid.\n+    */\n+    unsafe fn to_ptr<T>(v: [const T]) -> *T {\n+        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "4448ee79d199a865ab3217b905cdc200b55ef7d3", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,6 +3,7 @@\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n+import core::option;\n import option::{some, none};\n \n type ebml_tag = {id: uint, size: uint};"}, {"sha": "7175df40a1660d01c1b8c3cd424b1353b9189170", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,8 @@ Module: fs\n File system manipulation\n */\n \n+import core::vec;\n+import core::option;\n import os;\n import os::getcwd;\n import os_fs;"}, {"sha": "babfd0281ba140386ccddecf7597c00973a67343", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,6 +6,7 @@ Some miscellaneous platform functions.\n These should be rolled into another module.\n */\n \n+import core::option;\n \n // Wow, this is an ugly way to write doc comments\n "}, {"sha": "115bcca8174b383f0bf9ed48cef2aa8b59c01214", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -45,6 +45,7 @@ name following -o, and accepts both -h and --help as optional flags.\n \n */\n \n+import core::option;\n import option::{some, none};\n export opt;\n export reqopt;"}, {"sha": "53dd5de3ab3f1feb2b9cea3822dd90756a755aef", "filename": "src/libstd/io.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,8 @@ Module: io\n Basic input/output\n */\n \n+import core::option;\n+import core::result;\n import ctypes::fd_t;\n import ctypes::c_int;\n "}, {"sha": "bdd8547e84eeace087885b21a9df93a3151af655", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,7 +3,7 @@\n \n import float;\n import map;\n-import option;\n+import core::option;\n import option::{some, none};\n import str;\n import vec;"}, {"sha": "8528057ed98f77fe4ce9304f7bba1c15a6939b35", "filename": "src/libstd/linux_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,7 @@ Module: os\n TODO: Restructure and document\n */\n \n+import core::option;\n import ctypes::*;\n \n export libc;"}, {"sha": "d0c7582426a48e96d3002e2fe7c9cfe8c9ee1c3b", "filename": "src/libstd/list.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,8 @@ Module: list\n A standard linked list\n */\n \n+import core::option;\n+import option::*;\n import option::{some, none};\n \n /* Section: Types */"}, {"sha": "72afcc234b3cbb6ef8ef867fa214978dd6a1df39", "filename": "src/libstd/macos_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,3 +1,4 @@\n+import core::option;\n import ctypes::*;\n \n export libc;"}, {"sha": "a07a9f9a1a233e4a00520eeb1335e0469ae194a2", "filename": "src/libstd/map.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -72,14 +72,14 @@ type hashmap<K, V> = obj {\n     Get the value for the specified key. If the key does not exist\n     in the map then returns none.\n     */\n-    fn find(K) -> option::t<V>;\n+    fn find(K) -> core::option::t<V>;\n     /*\n     Method: remove\n \n     Remove and return a value from the map. If the key does not exist\n     in the map then returns none.\n     */\n-    fn remove(K) -> option::t<V>;\n+    fn remove(K) -> core::option::t<V>;\n     /*\n     Method: rehash\n \n@@ -210,38 +210,38 @@ mod chained {\n         }\n     }\n \n-    fn get<copy K, copy V>(tbl: t<K,V>, k: K) -> option::t<V> {\n+    fn get<copy K, copy V>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n           not_found. {\n-            ret option::none;\n+            ret core::option::none;\n           }\n \n           found_first(_, entry) {\n-            ret option::some(entry.value);\n+            ret core::option::some(entry.value);\n           }\n \n           found_after(_, entry) {\n-            ret option::some(entry.value);\n+            ret core::option::some(entry.value);\n           }\n         }\n     }\n \n-    fn remove<copy K, copy V>(tbl: t<K,V>, k: K) -> option::t<V> {\n+    fn remove<copy K, copy V>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n           not_found. {\n-            ret option::none;\n+            ret core::option::none;\n           }\n \n           found_first(idx, entry) {\n             tbl.size -= 1u;\n             tbl.chains[idx] = entry.next;\n-            ret option::some(entry.value);\n+            ret core::option::some(entry.value);\n           }\n \n           found_after(eprev, entry) {\n             tbl.size -= 1u;\n             eprev.next = entry.next;\n-            ret option::some(entry.value);\n+            ret core::option::some(entry.value);\n           }\n         }\n     }\n@@ -311,18 +311,18 @@ mod chained {\n         }\n \n         fn contains_key(k: K) -> bool {\n-            ret option::is_some(get(*tbl, k));\n+            ret core::option::is_some(get(*tbl, k));\n         }\n \n         fn get(k: K) -> V {\n-            ret option::get(get(*tbl, k));\n+            ret core::option::get(get(*tbl, k));\n         }\n \n-        fn find(k: K) -> option::t<V> {\n+        fn find(k: K) -> core::option::t<V> {\n             ret get(*tbl, k);\n         }\n \n-        fn remove(k: K) -> option::t<V> {\n+        fn remove(k: K) -> core::option::t<V> {\n             ret remove(*tbl, k);\n         }\n "}, {"sha": "2872aa6c4f6171277cc2862c1423a288da377f58", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -26,6 +26,8 @@ The following operations are algorithmically faster in ropes:\n  */\n \n \n+import core::option;\n+\n \n \n /*\n@@ -211,7 +213,6 @@ Section: Keeping ropes healthy\n  */\n \n \n-\n /*\n Function: bal\n "}, {"sha": "ca4763ca7e2941c4cae874325b6246eaae742a33", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,6 +3,7 @@ Module: run\n \n Process spawning\n */\n+import core::option;\n import str::sbuf;\n import ctypes::{fd_t, pid_t};\n "}, {"sha": "d57f553b68fa0c7be52ab4e5df1a919b8fd97c1b", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,7 +4,8 @@ Module: smallintmap\n A simple map based on a vector for small integer keys. Space requirements\n are O(highest integer key).\n */\n-import option::{some, none};\n+import core::option;\n+import core::option::{some, none};\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be."}, {"sha": "fe2e7d9c567a29726cf6d39e5f8373fec9156522", "filename": "src/libstd/str.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -938,15 +938,13 @@ Escapes a single character.\n */\n fn escape_char(c: char) -> str {\n     alt c {\n-        '\"' { \"\\\\\\\"\" }\n-        '\\\\' { \"\\\\\\\\\" }\n-// TODO: uncomment these when https://github.com/graydon/rust/issues/1170 is\n-// fixed.\n-//        '\\n' { \"\\\\n\" }\n-//        '\\t' { \"\\\\t\" }\n-//        '\\r' { \"\\\\r\" }\n-        '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n-        v { from_char(c) }\n+      '\"' { \"\\\\\\\"\" }\n+      '\\\\' { \"\\\\\\\\\" }\n+      '\\n' { \"\\\\n\" }\n+      '\\t' { \"\\\\t\" }\n+      '\\r' { \"\\\\r\" }\n+      '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n+      v { from_char(c) }\n     }\n }\n "}, {"sha": "31f01cf838425eb06f51a9085dcda124b840888a", "filename": "src/libstd/task.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -146,7 +146,9 @@ time_in_us - maximum number of microseconds to yield control for\n fn sleep(time_in_us: uint) {\n     let task = rustrt::rust_get_task();\n     let killed = false;\n-    log #fmt(\"yielding for %u us\", time_in_us);\n+    // FIXME: uncomment this when extfmt is moved to core\n+    // in a snapshot.\n+    // log #fmt(\"yielding for %u us\", time_in_us);\n     rusti::task_sleep(task, time_in_us, killed);\n     if killed {\n         fail \"killed\";\n@@ -181,7 +183,12 @@ fn join(task_port: joinable_task) -> task_result {\n       exit(_id, res) {\n         if _id == id {\n             ret res\n-        } else { fail #fmt[\"join received id %d, expected %d\", _id, id] }\n+        } else {\n+            // FIXME: uncomment this when extfmt is moved to core\n+            // in a snapshot.\n+            // fail #fmt[\"join received id %d, expected %d\", _id, id]\n+            fail;\n+        }\n       }\n     }\n }"}, {"sha": "4d6adedfe18cc8a92d797ae1fa0864041eb9e442", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,8 +4,8 @@ Module: tempfile\n Temporary files and directories\n */\n \n+import core::option;\n import fs;\n-import option;\n import option::{none, some};\n import rand;\n "}, {"sha": "124e73b75d7edad121fdf507edf385a88fa9f053", "filename": "src/libstd/term.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,8 @@ Module: term\n Simple ANSI color library\n */\n \n+import core::option;\n+\n // TODO: Windows support.\n \n /* Const: color_black */"}, {"sha": "abf563197a5146046d82a615f307fa8d5da21b73", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,7 +3,12 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n+import core::comm;\n+import core::task;\n import task::task;\n+import core::option;\n+import core::either;\n+import core::vec;\n \n export test_name;\n export test_fn;"}, {"sha": "c7c76535846dfcfc8cb14b0aa94f4451dbf9e0d2", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -9,6 +9,7 @@ red-black tree or something else.\n \n */\n \n+import core::option;\n import option::{some, none};\n import option = option::t;\n "}, {"sha": "4f993cbc559f0319f2a58ff6dfa9df55f031a561", "filename": "src/libstd/ufind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fufind.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,5 @@\n \n+import core::option;\n import option::{some, none};\n \n "}, {"sha": "1e211d0ffcb6a6d990787f2bb98cbc65462485b2", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,6 +2,7 @@\n Module: vec\n */\n \n+import core::option;\n import option::{some, none};\n import uint::next_power_of_two;\n import ptr::addr_of;"}, {"sha": "439a79ec7acd56e64e0d93eb07cb0c209e171a97", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,3 +1,4 @@\n+import core::option;\n import ctypes::*;\n \n #[abi = \"cdecl\"]"}, {"sha": "500cb44758cf656703362bca44d37b32bf7b8d43", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,8 +5,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::int;\n-import std::str;\n+import int;\n+import str;\n \n fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n "}, {"sha": "4feeda28b1b69b0675b1827f47b432cef837267b", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,8 +5,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::int;\n-import std::str;\n+import int;\n+import str;\n \n tag bottle { none; dual; single; multiple(int); }\n "}, {"sha": "ac21780a62d0ec2db86bb4471cecd88fb405fa9e", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,8 +5,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::int;\n-import std::str;\n+import int;\n+import str;\n \n fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n "}, {"sha": "b4c50a87809328d1bb5c0a1879f431772bbf0b7b", "filename": "src/test/bench/99bob-tail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::int;\n-import std::str;\n+import int;\n+import str;\n \n fn main() {\n     fn multiple(n: int) {"}, {"sha": "213ee46c0ecdc5741c9c2d65e8afb973662c9e68", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::int;\n+import int;\n \n tag tree { nil; node(@tree, @tree, int); }\n "}, {"sha": "ea9f8341d4d72480a62efcad7029c400379f5865", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // Based on Isaac Gouy's fannkuchredux.csharp\n use std;\n-import std::int;\n-import std::vec;\n+import int;\n+import vec;\n \n fn fannkuch(n: int) -> int {\n     fn perm1init(i: uint) -> int { ret i as int; }"}, {"sha": "d8bba3d0725a2ff257dbd474ba480689a96fe208", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,10 +6,10 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std::vec;\n-import std::uint;\n-import std::int;\n-import std::str;\n+import vec;\n+import uint;\n+import int;\n+import str;\n \n fn LINE_LENGTH() -> uint { ret 60u; }\n "}, {"sha": "482d4e05d5195c734866004319eab238924a31bb", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -12,20 +12,20 @@\n \n use std;\n \n-import std::vec;\n-import std::uint;\n+import vec;\n+import uint;\n import std::time;\n-import std::str;\n-import std::int::range;\n+import str;\n+import int::range;\n import std::io;\n import std::getopts;\n-import std::task;\n-import std::u64;\n-import std::comm;\n-import std::comm::port;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n+import task;\n+import u64;\n+import comm;\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n \n fn fib(n: int) -> int {\n     fn pfib(args: (chan<int>, int)) {"}, {"sha": "4d8e289af88c6030ce3e7c9a477acf00090ff7ef", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,10 @@\n use std;\n \n import std::io;\n-import std::str;\n-import std::uint;\n-import std::u8;\n-import std::vec;\n+import str;\n+import uint;\n+import u8;\n+import vec;\n import std::bitv;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "3b9b9a0a05bfb577f1cea78d3b87a973b58f9b4c", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n use std;\n-import std::vec;\n-import std::task;\n-import std::uint;\n-import std::str;\n+import vec;\n+import task;\n+import uint;\n+import str;\n \n fn f(&&n: uint) {\n     let i = 0u;"}, {"sha": "b5d7fbf24a060f606092b1e8c56026bb21c9f7a1", "filename": "src/test/bench/task-perf-vector-party.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,10 +4,10 @@\n // allocating and freeing vectors.\n \n use std;\n-import std::vec;\n-import std::uint;\n-import std::str;\n-import std::task;\n+import vec;\n+import uint;\n+import str;\n+import task;\n \n fn f(&&n: uint) {\n     uint::range(0u, n) {|i|"}, {"sha": "94358e239455c83db9d9f3b46523ba595c86aa17", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -12,24 +12,24 @@\n \n use std;\n \n-import option = std::option::t;\n-import std::option::some;\n-import std::option::none;\n-import std::str;\n+import option = option::t;\n+import option::some;\n+import option::none;\n+import str;\n import std::treemap;\n-import std::vec;\n+import vec;\n import std::io;\n \n import std::time;\n-import std::u64;\n-\n-import std::task;\n-import std::task::joinable_task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::recv;\n-import std::comm::send;\n+import u64;\n+\n+import task;\n+import task::joinable_task;\n+import comm;\n+import comm::chan;\n+import comm::port;\n+import comm::recv;\n+import comm::send;\n \n fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n     let f = io::file_reader(str::unsafe_from_bytes(filename));"}, {"sha": "b4637eacdd1b3d8455cc15ed9878fc3eabc1df84", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -10,25 +10,25 @@\n \n use std;\n \n-import option = std::option::t;\n-import std::option::some;\n-import std::option::none;\n-import std::str;\n+import option = option::t;\n+import option::some;\n+import option::none;\n+import str;\n import std::map;\n-import std::vec;\n+import vec;\n import std::io;\n \n import std::time;\n-import std::u64;\n-import std::result;\n-\n-import std::task;\n-import std::task::joinable_task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::recv;\n-import std::comm::send;\n+import u64;\n+import result;\n+\n+import task;\n+import task::joinable_task;\n+import comm;\n+import comm::chan;\n+import comm::port;\n+import comm::recv;\n+import comm::send;\n \n fn map(input: str, emit: map_reduce::putter) {\n     let f = io::string_reader(input);"}, {"sha": "662e3108bf0ac79e4301d7f467153bc9f2560392", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved import\n-import vec;\n+import thing;\n \n-fn main() { let foo = vec::len([]); }\n+fn main() { let foo = thing::len([]); }"}, {"sha": "8c40cd3e25d02044d7937d8048c9bd6d9042b787", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,7 +3,7 @@\n \n use std;\n // expecting swap to be defined in vec\n-import std::vec::*;\n+import vec::*;\n import alternate_supplier::*;\n \n mod alternate_supplier {"}, {"sha": "3b9221587acee5c2f8c120d296f96a175475e958", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:precondition constraint (for example, uint::le(a, b)\n use std;\n-import std::str::*;\n+import str::*;\n \n fn main() {\n     let a: uint = 4u;"}, {"sha": "8d6b95653330226e671101c18b1678002e92f491", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -10,7 +10,7 @@ fn main() {\n \n     unsafe {\n         let a = 0;\n-        let v = std::ptr::mut_addr_of(a);\n+        let v = ptr::mut_addr_of(a);\n         f(v);\n     }\n }"}, {"sha": "f735af5ba73225052ba2bb8dde0706d2d978fd0c", "filename": "src/test/compile-fail/mutable-huh-variance-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,7 +4,7 @@ use std;\n \n fn main() {\n     let a = [0];\n-    let v: *mutable [int] = std::ptr::mut_addr_of(a);\n+    let v: *mutable [int] = ptr::mut_addr_of(a);\n \n     fn f(&&v: *mutable [const int]) {\n         unsafe {"}, {"sha": "59f5b8435d137394d18693a10a729792feae159f", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:Unsatisfied precondition constraint (for example, le(b, d\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 1u;"}, {"sha": "74a0e4da2880a32efd2cf76652ebf230e3ef102d", "filename": "src/test/compile-fail/non-triv-cast-be.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // error-pattern: non-trivial cast of tail-call return value\n use std;\n \n-import std::ctypes::*;\n+import ctypes::*;\n \n fn foo_float() -> m_float { ret 0.0 as m_float; }\n fn bar_float() -> bool { be foo_float() as bool; }"}, {"sha": "b7c5614f176e1d6dc0a5c7edf74cd863008bb965", "filename": "src/test/compile-fail/nonsense-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // Tests that the typechecker checks constraints\n // error-pattern:mismatched types: expected uint but found u8\n use std;\n-import std::uint;\n+import uint;\n \n fn enum_chars(start: u8, end: u8) : uint::le(start, end) -> [char] {\n     let i = start;"}, {"sha": "cfc85d86e21605ba265b088bf9dfe43f4d124cec", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std::option;\n-import std::option::some;\n+import option;\n+import option::some;\n \n // error-pattern: mismatched types\n "}, {"sha": "705a662e14ded33ad4b0573dda93d2578dec3658", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n use std;\n-import std::option;\n-import std::option::some;\n+import option;\n+import option::some;\n \n // error-pattern: mismatched types\n "}, {"sha": "e517be752e65547ca229de33fb30f1080492855f", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // error-pattern: mismatched types\n \n use std;\n-import std::task;\n+import task;\n \n fn f(&&x: int) -> int { ret x; }\n "}, {"sha": "0c0ea02164cf49de34cbc253d521f6fea435d3ca", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n // xfail-test\n // error-pattern:option::t\n use std;\n-import std::vec::*;\n+import vec::*;\n \n fn main() {\n     let y;"}, {"sha": "dac5b6d7e8fc0827e6e7e1fc5dee3002a010ce8a", "filename": "src/test/compile-fail/zip-missing-check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:Unsatisfied precondition constraint (for example, same_length\n use std;\n-import std::uint;\n-import std::u8;\n-import std::vec::*;\n+import uint;\n+import u8;\n+import vec::*;\n \n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;"}, {"sha": "1a4155574f89456d56d83de1b236ec896ddaa152", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n // error-pattern:explicit failure\n use std;\n-import std::option::*;\n+import option::*;\n \n fn foo(s: str) { }\n "}, {"sha": "5df6d09896e054fb260facb4bc3de40decd05f41", "filename": "src/test/run-fail/fail-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffail-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffail-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-main.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:moop\n use std;\n-import std::uint;\n+import uint;\n fn main() { fail \"moop\"; }"}, {"sha": "5a5fa5ea81c2d1b0b33388da7b515c716ded4e75", "filename": "src/test/run-fail/fn-constraint-claim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:quux\n use std;\n-import std::uint::*;\n+import uint::*;\n \n fn nop(a: uint, b: uint) : le(a, b) { fail \"quux\"; }\n "}, {"sha": "87d082c47a938804672bc0f6628bc3bc4537c829", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:Predicate le(a, b) failed\n use std;\n-import std::str::*;\n-import std::uint::le;\n+import str::*;\n+import uint::le;\n \n fn main() {\n     let a: uint = 4u;"}, {"sha": "cdb054a4e8da26984274eee8944a40f78ddf606a", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:moop\n use std;\n-import std::uint;\n+import uint;\n fn main() { uint::range(0u, 10u) {|_i| fail \"moop\"; } }"}, {"sha": "0baa9fd9098f26553de9b086dad4b841708dbbce", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,9 +2,9 @@\n \n // error-pattern:1 == 2\n use std;\n-import std::task;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::port;\n+import comm::recv;\n \n fn child(&&_i: ()) { assert (1 == 2); }\n "}, {"sha": "a52c1fed1ca481e935b1e111a4328516745af62b", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,10 +2,10 @@\n \n // error-pattern:fail\n use std;\n-import std::task;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::chan;\n+import comm::port;\n+import comm::recv;\n \n fn child(&&_i: ()) { fail; }\n "}, {"sha": "b24c6d8a6cf79e09f5f8cb9f8ce259496e782243", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,9 +2,9 @@\n \n // error-pattern:fail\n use std;\n-import std::task;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::port;\n+import comm::recv;\n \n fn grandchild(&&_i: ()) { fail; }\n "}, {"sha": "ef544778d4318d1a5c95ef63a214efd59d35b803", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,10 @@\n // -*- rust -*-\n // error-pattern:1 == 2\n use std;\n-import std::task;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::chan;\n+import comm::port;\n+import comm::recv;\n \n fn child(&&_args: ()) { assert (1 == 2); }\n "}, {"sha": "25170db40e4c93095e8a37893c07703cb52442fe", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -34,7 +34,7 @@ resource and_then_get_big_again(_i: ()) {\n \n fn main() {\n     rustrt::set_min_stack(1024u);\n-    std::task::spawn((), fn (&&_i: ()) {\n+    task::spawn((), fn (&&_i: ()) {\n         let r = and_then_get_big_again(());\n         getbig_call_c_and_fail(10000);\n     });"}, {"sha": "e1a77bee9b6a13549fcbf52b636327119baf457f", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -30,5 +30,5 @@ resource and_then_get_big_again(_i: @int) {\n \n fn main() {\n     rustrt::set_min_stack(1024u);\n-    std::task::spawn(400, getbig_and_fail);\n+    task::spawn(400, getbig_and_fail);\n }\n\\ No newline at end of file"}, {"sha": "a43c7ce0e694fae7aea9956c776e0b848bbe00f5", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n // error-pattern:meep\n use std;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n \n fn echo<send T>(c: chan<T>, oc: chan<chan<T>>) {\n     // Tests that the type argument in port gets"}, {"sha": "87cf90fc69d933945983602557405c296e327175", "filename": "src/test/run-fail/spawnfail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fspawnfail.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // xfail-win32\n // error-pattern:explicit\n use std;\n-import std::task;\n+import task;\n \n // We don't want to see any invalid reads\n fn main() {"}, {"sha": "314921cdfb7530b68d1362e4a86527c7c5f631c8", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:goodfail\n \n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n fn goodfail(&&_i: ()) {\n     task::yield();"}, {"sha": "365a1cbdcc64c2ca79bf9d18a23663ae38af9274", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,12 +2,12 @@\n \n use std;\n import std::map;\n-import std::uint;\n+import uint;\n \n fn main() {\n     let count = @mutable 0u;\n     fn hash(&&s: [@str]) -> uint {\n-        if (std::vec::len(s) > 0u && std::str::eq(*s[0], \"boom\")) { fail; }\n+        if (vec::len(s) > 0u && str::eq(*s[0], \"boom\")) { fail; }\n         ret 10u;\n     }\n     fn eq(&&s: [@str], &&t: [@str]) -> bool {"}, {"sha": "04ab5bf8d9d3b2da57b46c4c17900e35bb6c8f09", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,9 +2,9 @@\n // the check should fail at runtime\n // error-pattern:Predicate same_length\n use std;\n-import std::uint;\n-import std::u8;\n-import std::vec::*;\n+import uint;\n+import u8;\n+import vec::*;\n \n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 9u;"}, {"sha": "0b6b58fee2631ffa276fc7e33bc45638cc3a6de1", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,8 +2,8 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n-import std::task;\n+import comm;\n+import task;\n \n fn f(c: comm::_chan<int>) {\n     type t = {_0: int, _1: int, _2: int};"}, {"sha": "37186537d6cac95b92f64913dc5b4493f4d1449e", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,8 +2,8 @@\n \n // Regression test for issue #374\n use std;\n-import std::option;\n-import std::option::none;\n+import option;\n+import option::none;\n \n tag sty { ty_nil; }\n "}, {"sha": "27389ebdd23827a29edc256e9f7dba3fb1e270ae", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::option::*;\n+import option::*;\n \n fn main() {\n     let i: int ="}, {"sha": "6b2ae3ffa9cbec90ae2f8c5afe9a7008eb6200fa", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n \n use std;\n-import std::option;\n-import std::option::t;\n-import std::option::none;\n-import std::option::some;\n+import option;\n+import option::t;\n+import option::none;\n+import option::some;\n \n fn foo<T>(y: option::t<T>) {\n     let x: int;"}, {"sha": "ec6b45cef0160867b33ad842dd3841f96a2053c9", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n // -*- rust -*-\n \n use std;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n-import std::task;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n+import task;\n \n fn a(c: chan<int>) { send(c, 10); }\n "}, {"sha": "b1de773f02dd02866ffa0bcd306fa65383601476", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n-import std::comm::send;\n-import std::comm::chan;\n-import std::comm::recv;\n-import std::task;\n+import comm;\n+import comm::send;\n+import comm::chan;\n+import comm::recv;\n+import task;\n \n fn a(c: chan<int>) { log \"task a0\"; log \"task a1\"; send(c, 10); }\n "}, {"sha": "e162b3aba85c217c1903de5a6f30efc60f9945cd", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n-import std::comm::send;\n-import std::comm::chan;\n-import std::comm::recv;\n-import std::task;\n+import comm;\n+import comm::send;\n+import comm::chan;\n+import comm::recv;\n+import task;\n \n fn a(c: chan<int>) {\n     if true {"}, {"sha": "aab3ba2dc7564a02dd16ab6260d47b57d655627b", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,8 +2,8 @@\n // xfail-test bots are crashing on this on x86_64\n \n use std;\n-import std::str;\n-import std::ctypes::*;\n+import str;\n+import ctypes::*;\n \n #[link_name = \"\"]\n native mod libc {\n@@ -14,7 +14,7 @@ fn main() {\n     let s = \"hello world\\n\";\n     let b = str::bytes(s);\n     let l = str::byte_len(s);\n-    let b8 = unsafe { std::vec::unsafe::to_ptr(b) };\n+    let b8 = unsafe { vec::unsafe::to_ptr(b) };\n     libc::write(0i32, b8, l);\n     let a = bind libc::write(0i32, _, _);\n     a(b8, l);"}, {"sha": "3eedf7f48ca344ca433e756b20772fb91896dfba", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n // Binop corner cases\n \n use std;\n-import std::unsafe::reinterpret_cast;\n-import std::task;\n-import std::comm;\n+import unsafe::reinterpret_cast;\n+import task;\n+import comm;\n \n fn test_nil() {\n     assert (() == ());"}, {"sha": "9ffed2ff64a241a2b5eca0f143bec5e1889f322d", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n use std;\n-import std::vec;\n+import vec;\n \n fn main() {\n     let v =\n-        std::vec::map2({|i, b| if b { -i } else { i } }, [1, 2, 3, 4, 5],\n+        vec::map2({|i, b| if b { -i } else { i } }, [1, 2, 3, 4, 5],\n                        [true, false, false, true, true]);\n     log_err v;\n     assert (v == [-1, 2, 3, -4, -5]);"}, {"sha": "879db89b713571b07fc67534bbb21d5fcfe99ff1", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::str;\n+import str;\n \n #[abi = \"cdecl\"]\n #[link_name = \"\"]"}, {"sha": "171947050d80822632da717561cf81cd12fba618", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,12 +1,12 @@\n // Issue #763\n \n use std;\n-import std::task;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::chan;\n+import comm::send;\n+import comm;\n+import comm::port;\n+import comm::recv;\n \n tag request { quit; close(chan<bool>); }\n "}, {"sha": "ad820c3c683b68d072844774d9c982f09f5f4fab", "filename": "src/test/run-pass/check-pattern-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::option::*;\n+import option::*;\n \n pure fn p(x: int) -> bool { true }\n "}, {"sha": "04940947145bc9deb83ed40cc104ecff6374cac6", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // Reported as issue #126, child leaks the string.\n \n use std;\n-import std::task;\n+import task;\n \n fn child2(&&s: str) { }\n "}, {"sha": "5f427d185ebf3dfd396e63ff946cbdc44440a2b9", "filename": "src/test/run-pass/claim-nonterm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // tests that the pred in a claim isn't actually eval'd\n use std;\n-import std::uint::*;\n+import uint::*;\n \n pure fn fails(a: uint) -> bool { fail; }\n "}, {"sha": "7278e4ac9942de7ca6261f743a740ca5c9348862", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n //xfail-test\n \n use std;\n-import std::task;\n+import task;\n \n fn f(x : @{a:int, b:int}) {\n     assert (x.a == 10);"}, {"sha": "0962a182acdb09e4deab2743938dc7a04e33fc85", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n-import std::task;\n+import comm;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n+import task;\n \n fn main() {\n     let p = comm::port();"}, {"sha": "a83ef3e6f55c602303d553997d7fa481c2efd7a7", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 1u;"}, {"sha": "b551a0653d0751166b7c9de16b4c83156b5404d8", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 1u;"}, {"sha": "45d0464362789150d97af56cbd9635278f42c86a", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 4u;"}, {"sha": "e2e486cbd496978f1e9e2caabb92968411b5dd3f", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 1u;"}, {"sha": "7cee261e1cbef01059e98daba989ad4b53c00bbe", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,10 @@\n // -*- rust -*-\n \n use std;\n-import std::comm::port;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n \n fn main() {\n     let po = port();"}, {"sha": "f610bb0bf690baf6592966a7b8f8474019bf4e80", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::float;\n+import float;\n \n fn main() {\n   let nan = float::NaN;"}, {"sha": "00ee9f89140d238ee57b860cf3299369a3abf11c", "filename": "src/test/run-pass/fn-bare-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,6 +4,6 @@ use std;\n \n fn main() {\n     // Bare functions should just be a pointer\n-    assert std::sys::rustrt::size_of::<fn()>() ==\n-        std::sys::rustrt::size_of::<int>();\n+    assert sys::rustrt::size_of::<fn()>() ==\n+        sys::rustrt::size_of::<int>();\n }\n\\ No newline at end of file"}, {"sha": "0a7db451cfb61ea5ac56a6ea92940c87c084bbf7", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str::*;\n-import std::uint::*;\n+import str::*;\n+import uint::*;\n \n fn main() {\n     let a: uint = 1u;"}, {"sha": "32bcecc5ee33a495cf3169dbfcd686fe606def5f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,18 +6,18 @@\n \n use std;\n \n-import option = std::option::t;\n-import std::option::some;\n-import std::option::none;\n-import std::str;\n-import std::vec;\n+import option = option::t;\n+import option::some;\n+import option::none;\n+import str;\n+import vec;\n import std::map;\n-import std::task;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n-import std::comm;\n+import task;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n+import comm;\n \n fn map(filename: str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n "}, {"sha": "7646028eb2552c5841bb64a456f97aaf7d2cd3a8", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n \n use std;\n-import std::vec::*;\n+import vec::*;\n \n fn main() {\n     let v = init_elt(0, 0u);"}, {"sha": "534e00f4f5d231735fa511de3a8347da4b9e8293", "filename": "src/test/run-pass/import-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-in-block.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n fn main() {\n-    import std::vec;\n+    import vec;\n     import vec::to_mut;\n     log vec::len(to_mut([1, 2]));\n     {"}, {"sha": "4eae0601d03193a6c9a949c38d7c39ce3dd29f19", "filename": "src/test/run-pass/infinite-loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfinite-loops.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,7 +5,7 @@\n // xfail-test\n \n use std;\n-import std::task::join;\n+import task::join;\n \n fn loop(n: int) {\n     let t1: task;"}, {"sha": "d337f3c0942e39b67263694a6cc659782e8bb155", "filename": "src/test/run-pass/invoke-external-native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Finvoke-external-native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Finvoke-external-native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-native.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::sys;\n+import sys;\n \n // The purpose of this test is to check that we can\n // successfully (and safely) invoke external, cdecl"}, {"sha": "eb75139b4a3ac1b30179d3890db5c5bc1484d736", "filename": "src/test/run-pass/issue-1112.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-1112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-1112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1112.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n // Alignment of interior pointers to dynamic-size types\n \n use std;\n-import std::ptr::addr_of;\n+import ptr::addr_of;\n \n type x<T> = {\n     a: T,"}, {"sha": "b1feb5df68e77a7fb9a0f066e113f6688ca63c70", "filename": "src/test/run-pass/issue-506.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -8,7 +8,7 @@\n */\n \n use std;\n-import std::task;\n+import task;\n \n #[abi = \"cdecl\"]\n native mod rustrt {"}, {"sha": "e10048d850f2c3d39bd56d1c4608b66e201f54c3", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -7,13 +7,13 @@\n \n use std;\n \n-import std::task;\n-import std::task::join;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import task::join;\n+import comm;\n+import comm::chan;\n+import comm::send;\n+import comm::port;\n+import comm::recv;\n \n fn grandchild(c: chan<int>) { send(c, 42); }\n "}, {"sha": "36b2e65897ee5ec74dd44f148588758421ff6068", "filename": "src/test/run-pass/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-511.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::option;\n+import option;\n \n fn f<T>(&o: option::t<T>) {\n     assert o == option::none;"}, {"sha": "c23411d88cafb27831d1779da000bcbc7bf29ab9", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n use std;\n-import std::vec;\n-import std::task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::recv;\n-import std::comm::send;\n+import vec;\n+import task;\n+import comm;\n+import comm::chan;\n+import comm::port;\n+import comm::recv;\n+import comm::send;\n \n tag msg { closed; received([u8]); }\n "}, {"sha": "086e652932084fd242d8862ce2635e8a8483c3e0", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm::*;\n-import std::task::*;\n+import comm::*;\n+import task::*;\n \n fn a(&&_args: ()) {\n     fn doit() {"}, {"sha": "41b06d9294c7f15772a6b4401302a9846365e6d5", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n use std;\n \n-import std::task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n+import task;\n+import comm;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n \n fn producer(c: chan<[u8]>) {\n     send(c,"}, {"sha": "afcb43edfbec0d0e8555650b2ff1ffd4fcf1a773", "filename": "src/test/run-pass/join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fjoin.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n use std;\n \n-import std::task::*;\n+import task::*;\n \n fn main() {\n     let other = spawn_joinable((), child);"}, {"sha": "80687497366e3860a457f304ffe9d4d8de0f7088", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std::task;\n-import std::comm::*;\n+import task;\n+import comm::*;\n \n fn main() {\n     let p = port();"}, {"sha": "7e9b1571efe3f68e39225e87badbfb9ffa7ea4b4", "filename": "src/test/run-pass/linked-failure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinked-failure.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n // -*- rust -*-\n // xfail-win32\n use std;\n-import std::task;\n-import std::comm::port;\n-import std::comm::recv;\n+import task;\n+import comm::port;\n+import comm::recv;\n \n fn child(&&_i: ()) { assert (1 == 2); }\n "}, {"sha": "f2f83a9b3d9c3962f4b80d493250660121606e26", "filename": "src/test/run-pass/lots-a-fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flots-a-fail.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // xfail-win32 leaks\n use std;\n-import std::task;\n-import std::comm;\n-import std::uint;\n+import task;\n+import comm;\n+import uint;\n \n fn die(&&_i: ()) {\n     fail;"}, {"sha": "e8c6ae14fa1a271f3bfc80a61ae21af458a821aa", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n fn sub(&&args: (comm::chan<int>, int)) {\n     let (parent, id) = args;"}, {"sha": "1f7bd05a7ab98850bf676cb09d5dbf293142f6ce", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -10,6 +10,6 @@ fn main() {\n     let first: @cell = @{mutable c: @nil()};\n     let second: @cell = @{mutable c: @link(first)};\n     first._0 = @link(second);\n-    std::sys.rustrt.gc();\n+    sys.rustrt.gc();\n     let third: @cell = @{mutable c: @nil()};\n }\n\\ No newline at end of file"}, {"sha": "c83a6e53ebb4b950830a5cec2b732eadec81bf6d", "filename": "src/test/run-pass/mod-view-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-view-items.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,7 +6,7 @@\n \n mod m {\n     use std;\n-    import std::vec;\n+    import vec;\n     fn f() -> [int] { vec::init_elt(0, 1u) }\n }\n "}, {"sha": "b05e0f85539e9ce6fc44496debb50a2278959051", "filename": "src/test/run-pass/morestack5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack5.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -4,7 +4,7 @@\n // This test will call __morestack with various minimum stack sizes\n \n use std;\n-import std::task;\n+import task;\n \n native mod rustrt {\n     fn set_min_stack(size: uint);"}, {"sha": "c8e88ac7cddaaa8c2ae623ad6206ab5c0a4fc7cf", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,7 +5,7 @@\n // external symbols as close to the red zone as possible.\n \n use std;\n-import std::task;\n+import task;\n import std::rand;\n \n native mod rustrt {"}, {"sha": "13ff41ba3fb8188e060de578d28512e10a3799e4", "filename": "src/test/run-pass/move-3-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::uint;\n+import uint;\n \n fn test(x: bool, foo: ~{x: int, y: int, z: int}) -> int {\n     let bar = foo;"}, {"sha": "eb1e125725c6f62cc4e60d18ebc10eeac38be507", "filename": "src/test/run-pass/move-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::uint;\n+import uint;\n \n fn test(x: bool, foo: @{x: int, y: int, z: int}) -> int {\n     let bar = foo;"}, {"sha": "1fffce98e52cc4ef449a7ab52bb79030efd6a9f6", "filename": "src/test/run-pass/move-4-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::uint;\n+import uint;\n \n fn test(foo: ~{a: int, b: int, c: int}) -> ~{a: int, b: int, c: int} {\n     let foo = foo;"}, {"sha": "aaaf05938a833936aece613157be1f129ac955fb", "filename": "src/test/run-pass/move-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmove-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n \n use std;\n-import std::uint;\n+import uint;\n \n fn test(foo: @{a: int, b: int, c: int}) -> @{a: int, b: int, c: int} {\n     let foo = foo;"}, {"sha": "942efdadc06adecd920683b9aee3c82560ea9e9c", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     grow(v);\n     grow(v);\n     grow(v);\n-    let len = std::vec::len::<int>(v);\n+    let len = vec::len::<int>(v);\n     log len;\n     assert (len == 3 as uint);\n }"}, {"sha": "98f429f8cb0dc8841226ace9b95a012d5648dc4c", "filename": "src/test/run-pass/native-fn-linkname.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnative-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnative-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-fn-linkname.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n-import std::vec;\n-import std::str;\n+import vec;\n+import str;\n \n #[link_name = \"\"]\n #[abi = \"cdecl\"]"}, {"sha": "9ca73209f36ce802995ef38fc892c3d96455f6e4", "filename": "src/test/run-pass/nested-alts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-alts.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n \n use std;\n-import std::option::*;\n+import option::*;\n \n fn baz() -> ! { fail; }\n "}, {"sha": "cf19630146f6b14bef50e2fd5ae577f320d1c58f", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,9 +2,9 @@\n \n // a bug was causing this to complain about leaked memory on exit\n use std;\n-import std::option;\n-import std::option::some;\n-import std::option::none;\n+import option;\n+import option::some;\n+import option::none;\n \n tag t { foo(int, uint); bar(int, option::t<int>); }\n "}, {"sha": "3da7f5a29fa8cc1014d3cae3ea128c8ed4b1aa15", "filename": "src/test/run-pass/obj-docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-docs.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n // Sanity-check the code examples that appear in the object system\n // documentation.\n use std;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::port;\n \n fn main() {\n "}, {"sha": "d09f04cc92f35887ca37d7cdd3da27ef9f3f21ec", "filename": "src/test/run-pass/pattern-bound-var-in-for-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,8 +2,8 @@\n // pattern-bound var is an upvar (when translating\n // the for-each body)\n use std;\n-import std::option::*;\n-import std::uint;\n+import option::*;\n+import uint;\n \n fn foo(src: uint) {\n "}, {"sha": "ed40fec9e771f89236e27900f9ac275275885ed5", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,13 +3,13 @@\n // Regression tests for circular_buffer when using a unit\n // that has a size that is not a power of two\n use std;\n-import std::option;\n-import std::uint;\n-import std::comm;\n-import std::comm::port;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n+import option;\n+import uint;\n+import comm;\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n \n // A 12-byte unit to send over the channel\n type record = {val1: u32, val2: u32, val3: u32};"}, {"sha": "b119ac6eb1d21064a6db5651357b6c11d0fe5448", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // xfail-win32\n use std;\n-import std::task;\n-import std::comm;\n-import std::uint;\n+import task;\n+import comm;\n+import uint;\n \n fn die(&&_i: ()) {\n     fail;"}, {"sha": "1c88d0182f6216e56ac55f1d43b3645412fd51f3", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::port;\n \n // tests that ctrl's type gets inferred properly\n type command<send K, send V> = {key: K, val: V};"}, {"sha": "0d427dca45fe1c3ac61f169920b16bb91555f802", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,7 +5,7 @@\n use std;\n import std::list;\n import std::list::list;\n-import std::option;\n+import option;\n \n tag opt_span {\n "}, {"sha": "df64e47bbf8abe060c1e8f5a11b3cee1939fcfbd", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std::task::yield;\n-import std::task;\n+import task::yield;\n+import task;\n \n fn x(&&args: (str, int)) {\n     let (s, n) = args;"}, {"sha": "66ca0363472bc214110974cd4c891cf6fa09539e", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::task::join;\n-import std::task::spawn_joinable;\n+import task::join;\n+import task::spawn_joinable;\n \n fn main() { let x = spawn_joinable(10, m::child); join(x); }\n "}, {"sha": "fe6ea6374b13b81726fc456628b3cee5ac0deb0c", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,9 +6,9 @@\n \n use std;\n \n-import std::str;\n-import std::comm;\n-import std::task;\n+import str;\n+import comm;\n+import task;\n \n type ctx = comm::chan<int>;\n "}, {"sha": "cc540efa2afd1e67301f2715f2b2354612ff700a", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n use std;\n \n-import std::task;\n+import task;\n \n fn main() { let t = task::spawn_joinable(10, child); task::join(t); }\n "}, {"sha": "fa07cfecf5836b48acd0832f59be4fb4f1ee4d09", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std::task::spawn;\n+import task::spawn;\n \n fn main() { spawn((10, 20, 30, 40, 50, 60, 70, 80, 90), child); }\n "}, {"sha": "4e117c4baa22819e95ac0ce75395b33a2a3f51fc", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n // -*- rust -*-\n use std;\n-import std::str;\n+import str;\n \n fn test1() {\n     let s: str = \"hello\";"}, {"sha": "6523ce47df3069c5dd2e23f71aedb1faeca46dfe", "filename": "src/test/run-pass/str-multiline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-multiline.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n \n // -*- rust -*-\n use std;\n-import std::str;\n+import str;\n \n fn main() {\n     let a: str = \"this \\"}, {"sha": "d65cfcbf4a9be3b4cd109eef388bcaa9c1f38b34", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::str;\n+import str;\n \n fn main() {\n     // Make sure we properly handle repeated self-appends."}, {"sha": "66192aac5aa9b930823e3f11f38997dc1eee924a", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::str;\n+import str;\n \n fn test(actual: str, expected: str) {\n     log actual;"}, {"sha": "abd4819b3bdf80f2dcc9e42db7a9d7cc12c3f547", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n use std;\n \n-import std::comm;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::task;\n+import comm;\n+import comm::chan;\n+import comm::send;\n+import task;\n \n fn main() { test05(); }\n "}, {"sha": "970e885e6732289aab0847df45fde68d0dd3f2b5", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n-import std::task::spawn_joinable;\n-import std::task::join;\n+import task::spawn_joinable;\n+import task::join;\n \n fn main() { test00(); }\n "}, {"sha": "61017a994fc85d77e287e77dcfadde1041cb05fb", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n fn start(c: comm::chan<comm::chan<str>>) {\n     let p = comm::port();"}, {"sha": "d8f3d12d059b9747b0e14241fc81fe3055468aca", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm;\n-import std::task;\n+import comm;\n+import task;\n \n fn start(c: comm::chan<comm::chan<int>>) {\n     let p: comm::port<int> = comm::port();"}, {"sha": "bd4c8a64418ef322ba5ebadcf9e4fc4eb1c48e70", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::task;\n+import task;\n \n fn main() { test00(); }\n "}, {"sha": "a9d63c70237928e29109cd10ef2dcaa55ea07cd9", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n-import std::task;\n-import std::comm;\n-import std::comm::send;\n+import task;\n+import comm;\n+import comm::send;\n \n fn start(&&args: (comm::chan<int>, int, int)) {\n     let (c, start, number_of_messages) = args;"}, {"sha": "6bf0fe89abd4c024876da05a5cbc447c148d5751", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm;\n-import std::task;\n+import comm;\n+import task;\n \n fn main() {\n     let po = comm::port::<int>();"}, {"sha": "c526f54203d50acd97226cfe601f3ff044751f89", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // xfail-win32\n use std;\n-import std::comm;\n-import std::task;\n+import comm;\n+import task;\n \n fn start(&&args: (comm::chan<int>, int)) {\n     let (c, i) = args;"}, {"sha": "f1c83487c7259dc035aa3d1a780751cc38695685", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n-import std::comm::send;\n-import std::comm::port;\n-import std::comm::recv;\n-import std::comm::chan;\n+import comm;\n+import comm::send;\n+import comm::port;\n+import comm::recv;\n+import comm::chan;\n \n // Tests of ports and channels on various types\n fn test_rec() {"}, {"sha": "eb6ab00341761eb75d68df8ce8f3d1d04d528cdb", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,7 +6,7 @@\n // until such time as we have unique closures.\n \n use std;\n-import std::task;\n+import task;\n \n fn f() {\n }"}, {"sha": "84033d3c1013af33ef36611adbf9531056465da4", "filename": "src/test/run-pass/task-comm-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // xfail-win32\n use std;\n \n-import std::task;\n+import task;\n \n fn main() { log \"===== SPAWNING and JOINING THREAD TASKS =====\"; test00(); }\n "}, {"sha": "7a19381975626e073ba1a9a5d8994f2e65385cb2", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,9 +1,9 @@\n use std;\n-import std::task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::send;\n-import std::comm::recv;\n+import task;\n+import comm;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n \n fn main() { log \"===== WITHOUT THREADS =====\"; test00(); }\n "}, {"sha": "bc30f2e4e7d50f29ecc6f4d710e523b17d5d508f", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm;\n-import std::comm::send;\n+import comm;\n+import comm::send;\n \n fn main() { test00(); }\n "}, {"sha": "bbae3f343a8da7d4dffc59de4f1e944c1a46fc53", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::comm;\n+import comm;\n \n fn main() { test00(); }\n "}, {"sha": "635751091656299e6401b53ce6e98fef2e9f6a02", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm;\n-import std::comm::send;\n+import comm;\n+import comm::send;\n import comm::chan;\n import comm::recv;\n "}, {"sha": "07b82a179875680f9f115c3af9e7d0225810c9da", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n import comm::chan;\n import comm::recv;\n import comm::port;"}, {"sha": "bd2cc06cd4b9e7c9d96c606184d0d5321133a84b", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n fn main() { test00(); }\n "}, {"sha": "b020118ed8ad68c2caada95629789cd4fd62a66e", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n fn main() { test00(); }\n "}, {"sha": "32756ce494baa7a68bb1f15e47abd103627fb96c", "filename": "src/test/run-pass/task-comm-chan-cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::comm;\n+import comm;\n \n fn main() {\n     let p = comm::port();"}, {"sha": "39c3eefd7748b376af89d92c504e294c342bdc57", "filename": "src/test/run-pass/task-comm-chan-cleanup2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::comm;\n+import comm;\n \n fn main() {\n     let p = comm::port();"}, {"sha": "79c32e5f1fd7cfaaef3da67548fadd8a469e6c22", "filename": "src/test/run-pass/task-comm-chan-cleanup3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::comm;\n+import comm;\n \n fn main() {\n     let c = {"}, {"sha": "d7553afb8bb1f52c3859426dcc0a4f4d15cd9784", "filename": "src/test/run-pass/task-comm-chan-cleanup4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,12 +1,12 @@\n use std;\n-import std::int;\n-import std::comm;\n-import std::task;\n+import int;\n+import comm;\n+import task;\n \n // We're trying to trigger a race between send and port destruction that\n // results in the string not being freed\n \n-fn starship(&&ch: std::comm::chan<str>) {\n+fn starship(&&ch: comm::chan<str>) {\n     int::range(0, 10) { |_i|\n         comm::send(ch, \"pew pew\");\n     }"}, {"sha": "785ab6979e2c1ea866bc391af7f77235c5fa4e51", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std::comm;\n+import comm;\n \n // rustboot can't transmit nils across channels because they don't have\n // any size, but rustc currently can because they do have size. Whether"}, {"sha": "aa2806bdfbc240f6b36008ab56c4854ad6fc8c54", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,12 +1,12 @@\n use std;\n \n-import std::task;\n-import std::task::task;\n-import std::comm;\n-import std::comm::chan;\n-import std::comm::port;\n-import std::comm::send;\n-import std::comm::recv;\n+import task;\n+import task::task;\n+import comm;\n+import comm::chan;\n+import comm::port;\n+import comm::send;\n+import comm::recv;\n \n fn main() {\n     test00();"}, {"sha": "be7f658eb1abfc2ed14e961d4ad4cb5a3d010879", "filename": "src/test/run-pass/task-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-compare.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,9 +6,9 @@\n // xfail-test\n \n use std;\n-import std::task;\n-import std::task::join;\n-import std::comm;\n+import task;\n+import task::join;\n+import comm;\n \n fn child() { }\n "}, {"sha": "a4ba23ef925d60fe457a7721815358ce9a9ccac2", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -7,7 +7,7 @@\n // the supervised task exits.\n \n use std;\n-import std::task;\n+import task;\n \n fn supervised(&&_args: ()) {\n     // Yield to make sure the supervisor joins before we"}, {"sha": "47afb2aec5f6bd7f5dff0fa3b3a42961cbc672de", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::task;\n+import task;\n fn main() { task::spawn(\"Hello\", child); }\n \n fn child(&&s: str) {"}, {"sha": "f989c12fc3c7ee2dcc3d8215e00e28551a3926a4", "filename": "src/test/run-pass/task-pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-pin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftask-pin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-pin.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -5,6 +5,6 @@\n \n use std;\n \n-import std::task;\n+import task;\n \n fn main() { task::pin(); task::unpin(); }"}, {"sha": "f3fdeea259b9c42bb6d98f55e088cd299ee89ac9", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -11,14 +11,14 @@ fn test_cont() { let i = 0; while i < 1 { i += 1; let x: @int = cont; } }\n fn test_ret() { let x: @int = ret; }\n \n fn test_fail() {\n-    fn f(&&_i: ()) { std::task::unsupervise(); let x: @int = fail; }\n-    std::task::spawn((), f);\n+    fn f(&&_i: ()) { task::unsupervise(); let x: @int = fail; }\n+    task::spawn((), f);\n }\n \n fn test_fail_indirect() {\n     fn f() -> ! { fail; }\n-    fn g(&&_i: ()) { std::task::unsupervise(); let x: @int = f(); }\n-    std::task::spawn((), g);\n+    fn g(&&_i: ()) { task::unsupervise(); let x: @int = f(); }\n+    task::spawn((), g);\n }\n \n fn main() {"}, {"sha": "bf539066c5fe43cbe5a98b026564785b8a29f782", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,8 +3,8 @@\n // xfail-pretty\n \n use std;\n-import std::option;\n-import std::vec;\n+import option;\n+import vec;\n \n #[test]\n #[ignore(cfg(ignorecfg))]"}, {"sha": "d5bbb90b044dc16a4279dc4fb849cdf2b5c88b5c", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std::task;\n+import task;\n \n fn main() {\n     let i = 10;"}, {"sha": "96ab736c5255afb12beda5a077c1bfde4a47423e", "filename": "src/test/run-pass/triv-cast-be.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std::ctypes::*;\n+import ctypes::*;\n \n fn foo_float() -> m_float { ret 0.0 as m_float; }\n fn bar_float() -> float { be foo_float() as float; }"}, {"sha": "5aae65ea384d15132a6bde8e1636b0f6e17c89fc", "filename": "src/test/run-pass/triv-cast-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std::ctypes::*;\n+import ctypes::*;\n \n // This will be more interesting once there is support\n // for consts that refer to other consts, i.e. math_f64::consts::pi as m_float"}, {"sha": "0961cb7df3b98a02e6b5818b1779078dbb517767", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::comm::*;\n+import comm::*;\n \n /*\n   This is about the simplest program that can successfully send a"}, {"sha": "ea6c95fc36378b7b025d644defeb4857883c50e5", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n // xfail-test\n-import std::sys::rustrt::size_of;\n+import sys::rustrt::size_of;\n use std;\n \n fn main() {"}, {"sha": "c9676b67daa9685db4ff789e62cec74fd720c626", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -2,7 +2,7 @@\n // unified with the type *T, and so the type variable\n // in that type gets resolved.\n use std;\n-import std::unsafe;\n+import unsafe;\n \n fn null<T>() -> *T unsafe { unsafe::reinterpret_cast(0) }\n "}, {"sha": "afcc2f53406d934b5580e7362b9f6f0016c53c9c", "filename": "src/test/run-pass/unique-copy-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-copy-box.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::sys::refcount;\n+import sys::refcount;\n \n fn main() unsafe {\n     let i = ~@1;"}, {"sha": "1625e7cc9c174d7076a20567e21c951445a1f3b2", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n use std;\n-import std::comm;\n-import std::task;\n-import std::uint;\n+import comm;\n+import task;\n+import uint;\n \n fn child(args: (comm::chan<~uint>, uint)) {\n     let (c, i) = args;"}, {"sha": "58ff64a6cc91e03a906780af829c2b96da463fc4", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::comm;\n-import std::task;\n+import comm;\n+import task;\n \n fn main() {\n     let p = comm::port();"}, {"sha": "9cfcd5f5c55e2e241578dd0acda8c5fe9facc0d1", "filename": "src/test/run-pass/unwind-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-box.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // xfail-win32\n use std;\n-import std::task;\n+import task;\n \n fn f(&&_i: ()) {\n     task::unsupervise();"}, {"sha": "eaaee443cfc8b76d60dc35de038d7642f34cd932", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // xfail-win32\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n resource complainer(c: comm::chan<bool>) {\n     comm::send(c, true);"}, {"sha": "3d55982a5bb039e6caeaba05de754b0d09ebe5e5", "filename": "src/test/run-pass/unwind-resource2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // xfail-win32\n use std;\n-import std::task;\n-import std::comm;\n+import task;\n+import comm;\n \n resource complainer(c: @int) {\n }"}, {"sha": "40005d733f515bb091fbddc94f38d1ea83cd3adc", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n // xfail-win32\n use std;\n-import std::task;\n+import task;\n \n fn f(&&_i: ()) {\n     task::unsupervise();"}, {"sha": "78f46ef5f84b1a9a44f230659f783e871def84a5", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,11 +6,11 @@ use bar(name = \"std\", vers = \"0.1\");\n \n \n // FIXME: commented out since resolve doesn't know how to handle crates yet.\n-// import std::str;\n-// import x = std::str;\n+// import str;\n+// import x = str;\n mod baz {\n-    // import std::str;\n-    // import x = std::str;\n+    // import str;\n+    // import x = str;\n \n }\n "}, {"sha": "6587b7015185f016c25feaaaf6be1c438056aa1b", "filename": "src/test/run-pass/user.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fuser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fuser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuser.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -6,10 +6,10 @@ use std (name = \"std\",\n          uuid = _, ver = _);\n \n fn main() {\n-  auto s = std::str.alloc(10 as uint);\n+  auto s = str.alloc(10 as uint);\n   s += \"hello \";\n   log s;\n   s += \"there\";\n   log s;\n-  auto z = std::vec.alloc::<int>(10 as uint);\n+  auto z = vec.alloc::<int>(10 as uint);\n }"}, {"sha": "67e3dbcb46cfea2120e5e163a2789f933127f43d", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std::str;\n-import std::vec;\n+import str;\n+import vec;\n \n fn main() {\n     // Chars of 1, 2, 3, and 4 bytes"}, {"sha": "5065fad43d6d956ee7d559c9a94ee49f05741ad8", "filename": "src/test/run-pass/vec-self-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-self-append.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::vec;\n+import vec;\n \n fn test_heap_to_heap() {\n     // a spills onto the heap"}, {"sha": "bddd83313470f4a7d8df3f018e186620aace29a5", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n use std;\n-import std::task;\n-import std::task::*;\n+import task;\n+import task::*;\n \n fn main() {\n     let other = task::spawn_joinable((), child);"}, {"sha": "0b20762915992d0e6edc7c0b3b13af1d075f29a9", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n use std;\n-import std::task;\n-import std::task::*;\n+import task;\n+import task::*;\n \n fn main() {\n     let other = task::spawn_joinable((), child);"}, {"sha": "9b637c53cb5a9ad1f98330bb6997b76b03f254e1", "filename": "src/test/run-pass/yield2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -3,5 +3,5 @@ use std;\n \n fn main() {\n     let i: int = 0;\n-    while i < 100 { i = i + 1; log_err i; std::task::yield(); }\n+    while i < 100 { i = i + 1; log_err i; task::yield(); }\n }"}, {"sha": "d1950be9efaebed6cb5b8a8a12963c2dbc345cee", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,10 @@\n // In this case, the code should compile and should\n // succeed at runtime\n use std;\n-import std::uint;\n-import std::u8;\n+import uint;\n+import u8;\n \n-import std::vec::*;\n+import vec::*;\n \n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;"}, {"sha": "ffd3ec232faca7549810cbef7bf346de25065800", "filename": "src/test/stdtest/bitv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbitv.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n+import core::*;\n \n use std;\n-import std::vec;\n+import vec;\n import std::bitv;\n \n #[test]"}, {"sha": "528e8e42681acf8fa83a3bd378a134a1ec6d82ed", "filename": "src/test/stdtest/bool.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbool.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,8 @@\n+import core::*;\n+\n use std;\n \n-import std::bool;\n+import bool;\n \n #[test]\n fn test_bool_from_str() {"}, {"sha": "abe80eec99799d9289fcf432a13e0507acfa2ccf", "filename": "src/test/stdtest/box.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbox.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,7 @@\n+import core::*;\n \n use std;\n-import std::box;\n+import box;\n \n #[test]\n fn test() {"}, {"sha": "d196a7baa3b298c34ac52728fbeeb3ccc21cd113", "filename": "src/test/stdtest/c_vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fc_vec.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,7 +1,9 @@\n+import core::*;\n+\n // -*- rust -*-\n use std;\n import std::c_vec::*;\n-import std::ctypes::*;\n+import ctypes::*;\n \n #[link_name = \"\"]\n #[abi = \"cdecl\"]"}, {"sha": "a02abcb567619cc14d6d9a918017fede47d80dbb", "filename": "src/test/stdtest/char.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fchar.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,7 @@\n+import core::*;\n+\n use std;\n-import std::char;\n+import char;\n \n #[test]\n fn test_is_whitespace() {"}, {"sha": "fbb0cec73c914efcadc023fbb1706c9d73f0c3fa", "filename": "src/test/stdtest/comm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fcomm.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,7 @@\n+import core::*;\n+\n use std;\n-import std::comm;\n+import comm;\n \n #[test]\n fn create_port_and_chan() { let p = comm::port::<int>(); comm::chan(p); }"}, {"sha": "70b2c99f571179504c62ec09544ee884277badd1", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,4 +1,4 @@\n-\n+import core::*;\n \n // -*- rust -*-\n use std;"}, {"sha": "de5849f029f696d06fa6eca1bdad7a48ba69dbd1", "filename": "src/test/stdtest/either.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,9 @@\n+import core::*;\n+\n use std;\n-import std::either::*;\n-import std::vec::len;\n+import vec;\n+import core::either::*;\n+import vec::len;\n \n #[test]\n fn test_either_left() {"}, {"sha": "36f5dc167b1e09b747eacd9b8b4f2be1ad11469b", "filename": "src/test/stdtest/float.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffloat.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,5 +1,7 @@\n+import core::*;\n+\n use std;\n-import std::float;\n+import float;\n \n #[test]\n fn test_from_str() {"}, {"sha": "25f1abc4ceae32a7eed764044ee5a832eb3db48a", "filename": "src/test/stdtest/four.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffour.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,3 +1,5 @@\n+import core::*;\n+\n use std;\n \n import std::tri;"}, {"sha": "a57cebc332de600f1d53fc579276e8a377702952", "filename": "src/test/stdtest/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffs.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,8 @@\n+import core::*;\n \n use std;\n import std::fs;\n+import vec;\n \n #[test]\n fn test_connect() {\n@@ -18,7 +20,7 @@ fn test_list_dir_no_invalid_memory_access() { fs::list_dir(\".\"); }\n fn list_dir() {\n     let dirs = fs::list_dir(\".\");\n     // Just assuming that we've got some contents in the current directory\n-    assert (std::vec::len(dirs) > 0u);\n+    assert (vec::len(dirs) > 0u);\n \n     for dir in dirs { log dir; }\n }"}, {"sha": "3730a17e1816adb0b0087a424f3b70bdf2f5972a", "filename": "src/test/stdtest/getopts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,3 +1,4 @@\n+import core::*;\n \n use std;\n import opt = std::getopts;"}, {"sha": "c8ec806189fb5f3692ddbcad65c1492a942c62e4", "filename": "src/test/stdtest/int.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fint.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,10 @@\n+import core::*;\n \n use std;\n-import std::int;\n-import std::str::eq;\n-import std::str::bytes;\n+import str;\n+import int;\n+import str::eq;\n+import str::bytes;\n \n #[test]\n fn test_from_str() {"}, {"sha": "1c9774b7fe60ce05db30052f09f59bd7849a1a06", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,8 +1,10 @@\n+import core::*;\n+\n // -*- rust -*-\n use std;\n import std::io;\n-import std::str;\n-import std::result;\n+import str;\n+import result;\n \n #[test]\n fn test_simple() {"}, {"sha": "db65b223ff783def0206ceaef1bb53ea34bae524", "filename": "src/test/stdtest/json.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fjson.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,6 +1,9 @@\n+import core::*;\n+\n use std;\n+import option;\n import std::json::*;\n-import std::option::{none, some};\n+import option::{none, some};\n \n #[test]\n fn test_from_str_num() {"}, {"sha": "da1643e92749cb005bad4a3246c9b1c6eb3f900b", "filename": "src/test/stdtest/list.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,10 +1,11 @@\n+import core::*;\n \n use std;\n import std::list;\n import std::list::head;\n import std::list::tail;\n import std::list::from_vec;\n-import std::option;\n+import option;\n \n #[test]\n fn test_from_vec() {"}, {"sha": "b7e62a6b0d279fd090c9f3f710edbe82620556e9", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9ad984fb2f013baebdbe01a42baa3b9101dd84/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=fa9ad984fb2f013baebdbe01a42baa3b9101dd84", "patch": "@@ -1,11 +1,11 @@\n-\n+import core::*;\n \n // -*- rust -*-\n use std;\n import std::map;\n-import std::str;\n-import std::uint;\n-import std::option;\n+import str;\n+import uint;\n+import option;\n \n \n #[test]\n@@ -257,7 +257,7 @@ fn test_contains_key() {\n fn test_find() {\n     let key = \"k\";\n     let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n-    assert (std::option::is_none(map.find(key)));\n+    assert (option::is_none(map.find(key)));\n     map.insert(key, \"val\");\n-    assert (std::option::get(map.find(key)) == \"val\");\n+    assert (option::get(map.find(key)) == \"val\");\n }"}]}