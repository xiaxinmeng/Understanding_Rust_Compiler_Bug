{"sha": "34cfd2183b1d46ccec97691870a3bcceee5ee367", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0Y2ZkMjE4M2IxZDQ2Y2NlYzk3NjkxODcwYTNiY2NlZWU1ZWUzNjc=", "commit": {"author": {"name": "Ted Horst", "email": "ted.horst@earthlink.net", "date": "2013-05-23T20:06:29Z"}, "committer": {"name": "Ted Horst", "email": "ted.horst@earthlink.net", "date": "2013-05-23T20:06:29Z"}, "message": "more testing fallout from core->std/std->extra move", "tree": {"sha": "4f2fc889423e27ba3956a42bf103d36e30582492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f2fc889423e27ba3956a42bf103d36e30582492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34cfd2183b1d46ccec97691870a3bcceee5ee367", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34cfd2183b1d46ccec97691870a3bcceee5ee367", "html_url": "https://github.com/rust-lang/rust/commit/34cfd2183b1d46ccec97691870a3bcceee5ee367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34cfd2183b1d46ccec97691870a3bcceee5ee367/comments", "author": {"login": "tedhorst", "id": 113629, "node_id": "MDQ6VXNlcjExMzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/113629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedhorst", "html_url": "https://github.com/tedhorst", "followers_url": "https://api.github.com/users/tedhorst/followers", "following_url": "https://api.github.com/users/tedhorst/following{/other_user}", "gists_url": "https://api.github.com/users/tedhorst/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedhorst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedhorst/subscriptions", "organizations_url": "https://api.github.com/users/tedhorst/orgs", "repos_url": "https://api.github.com/users/tedhorst/repos", "events_url": "https://api.github.com/users/tedhorst/events{/privacy}", "received_events_url": "https://api.github.com/users/tedhorst/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tedhorst", "id": 113629, "node_id": "MDQ6VXNlcjExMzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/113629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedhorst", "html_url": "https://github.com/tedhorst", "followers_url": "https://api.github.com/users/tedhorst/followers", "following_url": "https://api.github.com/users/tedhorst/following{/other_user}", "gists_url": "https://api.github.com/users/tedhorst/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedhorst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedhorst/subscriptions", "organizations_url": "https://api.github.com/users/tedhorst/orgs", "repos_url": "https://api.github.com/users/tedhorst/repos", "events_url": "https://api.github.com/users/tedhorst/events{/privacy}", "received_events_url": "https://api.github.com/users/tedhorst/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2b082adc84c22ea3b023f4f08d7b21857fc399", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2b082adc84c22ea3b023f4f08d7b21857fc399", "html_url": "https://github.com/rust-lang/rust/commit/6e2b082adc84c22ea3b023f4f08d7b21857fc399"}], "stats": {"total": 294, "additions": 148, "deletions": 146}, "files": [{"sha": "1d5a685a6a2cb427bff2ee08804d8511fcba7c48", "filename": "doc/rust.md", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -17,14 +17,14 @@ This document does not serve as a tutorial introduction to the\n language. Background familiarity with the language is assumed. A separate\n [tutorial] document is available to help acquire such background familiarity.\n \n-This document also does not serve as a reference to the [core] or [standard]\n+This document also does not serve as a reference to the [standard] or [extra]\n libraries included in the language distribution. Those libraries are\n documented separately by extracting documentation attributes from their\n source code.\n \n [tutorial]: tutorial.html\n-[core]: core/index.html\n [standard]: std/index.html\n+[extra]: extra/index.html\n \n ## Disclaimer\n \n@@ -441,7 +441,7 @@ expression context, the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ~~~~\n-# use core::hashmap::HashMap;\n+# use std::hashmap::HashMap;\n # fn f() {\n # fn id<T:Copy>(t: T) -> T { t }\n type t = HashMap<int,~str>;  // Type arguments used in a type expression\n@@ -768,9 +768,9 @@ Three examples of `extern mod` declarations:\n ~~~~~~~~{.xfail-test}\n extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n \n-extern mod std; // equivalent to: extern mod std ( name = \"std\" );\n+extern mod extra; // equivalent to: extern mod extra ( name = \"extra\" );\n \n-extern mod ruststd (name = \"std\"); // linking to 'std' under another name\n+extern mod rustextra (name = \"extra\"); // linking to 'extra' under another name\n ~~~~~~~~\n \n ##### Use declarations\n@@ -802,19 +802,19 @@ Use declarations support a number of convenient shortcuts:\n An example of `use` declarations:\n \n ~~~~\n-use core::float::sin;\n-use core::str::{slice, contains};\n-use core::option::Some;\n+use std::float::sin;\n+use std::str::{slice, contains};\n+use std::option::Some;\n \n fn main() {\n-    // Equivalent to 'info!(core::float::sin(1.0));'\n+    // Equivalent to 'info!(std::float::sin(1.0));'\n     info!(sin(1.0));\n \n-    // Equivalent to 'info!(core::option::Some(1.0));'\n+    // Equivalent to 'info!(std::option::Some(1.0));'\n     info!(Some(1.0));\n \n     // Equivalent to\n-    // 'info!(core::str::contains(core::str::slice(\"foo\", 0, 1), \"oo\"));'\n+    // 'info!(std::str::contains(std::str::slice(\"foo\", 0, 1), \"oo\"));'\n     info!(contains(slice(\"foo\", 0, 1), \"oo\"));\n }\n ~~~~\n@@ -1327,7 +1327,7 @@ with the exception that they may not have a body\n and are instead terminated by a semicolon.\n \n ~~~\n-# use core::libc::{c_char, FILE};\n+# use std::libc::{c_char, FILE};\n # #[nolink]\n \n extern {\n@@ -1436,7 +1436,7 @@ Some primitive Rust operations are defined in Rust code,\n rather than being implemented directly in C or assembly language.\n The definitions of these operations have to be easy for the compiler to find.\n The `lang` attribute makes it possible to declare these operations.\n-For example, the `str` module in the Rust core library defines the string equality function:\n+For example, the `str` module in the Rust standard library defines the string equality function:\n \n ~~~ {.xfail-test}\n #[lang=\"str_eq\"]\n@@ -1562,7 +1562,7 @@ impl<T: Eq> Eq for Foo<T> {\n Supported traits for `deriving` are:\n \n * Comparison traits: `Eq`, `TotalEq`, `Ord`, `TotalOrd`.\n-* Serialization: `Encodable`, `Decodable`. These require `std`.\n+* Serialization: `Encodable`, `Decodable`. These require `extra`.\n * `Clone` and `DeepClone`, to perform (deep) copies.\n * `IterBytes`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n@@ -1885,25 +1885,25 @@ Binary operators expressions are given in terms of\n #### Arithmetic operators\n \n Binary arithmetic expressions are syntactic sugar for calls to built-in traits,\n-defined in the `core::ops` module of the `core` library.\n+defined in the `std::ops` module of the `std` library.\n This means that arithmetic operators can be overridden for user-defined types.\n The default meaning of the operators on standard types is given here.\n \n `+`\n   : Addition and vector/string concatenation.\n-    Calls the `add` method on the `core::ops::Add` trait.\n+    Calls the `add` method on the `std::ops::Add` trait.\n `-`\n   : Subtraction.\n-    Calls the `sub` method on the `core::ops::Sub` trait.\n+    Calls the `sub` method on the `std::ops::Sub` trait.\n `*`\n   : Multiplication.\n-    Calls the `mul` method on the `core::ops::Mul` trait.\n+    Calls the `mul` method on the `std::ops::Mul` trait.\n `/`\n   : Quotient.\n-    Calls the `div` method on the `core::ops::Div` trait.\n+    Calls the `div` method on the `std::ops::Div` trait.\n `%`\n   : Remainder.\n-    Calls the `rem` method on the `core::ops::Rem` trait.\n+    Calls the `rem` method on the `std::ops::Rem` trait.\n \n #### Bitwise operators\n \n@@ -1914,19 +1914,19 @@ The default meaning of the operators on standard types is given here.\n \n `&`\n   : And.\n-    Calls the `bitand` method of the `core::ops::BitAnd` trait.\n+    Calls the `bitand` method of the `std::ops::BitAnd` trait.\n `|`\n   : Inclusive or.\n-    Calls the `bitor` method of the `core::ops::BitOr` trait.\n+    Calls the `bitor` method of the `std::ops::BitOr` trait.\n `^`\n   : Exclusive or.\n-    Calls the `bitxor` method of the `core::ops::BitXor` trait.\n+    Calls the `bitxor` method of the `std::ops::BitXor` trait.\n `<<`\n   : Logical left shift.\n-    Calls the `shl` method of the `core::ops::Shl` trait.\n+    Calls the `shl` method of the `std::ops::Shl` trait.\n `>>`\n   : Logical right shift.\n-    Calls the `shr` method of the `core::ops::Shr` trait.\n+    Calls the `shr` method of the `std::ops::Shr` trait.\n \n #### Lazy boolean operators\n \n@@ -1947,22 +1947,22 @@ The default meaning of the operators on standard types is given here.\n \n `==`\n   : Equal to.\n-    Calls the `eq` method on the `core::cmp::Eq` trait.\n+    Calls the `eq` method on the `std::cmp::Eq` trait.\n `!=`\n   : Unequal to.\n-    Calls the `ne` method on the `core::cmp::Eq` trait.\n+    Calls the `ne` method on the `std::cmp::Eq` trait.\n `<`\n   : Less than.\n-    Calls the `lt` method on the `core::cmp::Ord` trait.\n+    Calls the `lt` method on the `std::cmp::Ord` trait.\n `>`\n   : Greater than.\n-    Calls the `gt` method on the `core::cmp::Ord` trait.\n+    Calls the `gt` method on the `std::cmp::Ord` trait.\n `<=`\n   : Less than or equal.\n-    Calls the `le` method on the `core::cmp::Ord` trait.\n+    Calls the `le` method on the `std::cmp::Ord` trait.\n `>=`\n   : Greater than or equal.\n-    Calls the `ge` method on the `core::cmp::Ord` trait.\n+    Calls the `ge` method on the `std::cmp::Ord` trait.\n \n \n #### Type cast expressions\n@@ -2121,11 +2121,11 @@ then the expression completes.\n Some examples of call expressions:\n \n ~~~~\n-# use core::from_str::FromStr::from_str;\n+# use std::from_str::FromStr;\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi = from_str::<f32>(\"3.14\");\n+let pi = FromStr::from_str::<f32>(\"3.14\");\n ~~~~\n \n ### Lambda expressions\n@@ -3168,7 +3168,7 @@ execute, after which it is *descheduled* at a loop-edge or similar\n preemption point, and another task within is scheduled, pseudo-randomly.\n \n An executing task can yield control at any time, by making a library call to\n-`core::task::yield`, which deschedules it immediately. Entering any other\n+`std::task::yield`, which deschedules it immediately. Entering any other\n non-executing state (blocked, dead) similarly deschedules the task.\n \n \n@@ -3181,7 +3181,7 @@ run-time. It is smaller and simpler than many modern language runtimes. It is\n tightly integrated into the language's execution model of memory, tasks,\n communication and logging.\n \n-> **Note:** The runtime library will merge with the `core` library in future versions of Rust.\n+> **Note:** The runtime library will merge with the `std` library in future versions of Rust.\n \n ### Memory allocation\n "}, {"sha": "33a8cd230bb2f295db1e5c87c9df02164f353520", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -12,7 +12,7 @@ The following is a minimal example of calling a foreign function which will comp\n installed:\n \n ~~~~ {.xfail-test}\n-use core::libc::size_t;\n+use std::libc::size_t;\n \n #[link_args = \"-lsnappy\"]\n extern {\n@@ -42,7 +42,7 @@ runtime.\n The `extern` block can be extended to cover the entire snappy API:\n \n ~~~~ {.xfail-test}\n-use core::libc::{c_int, size_t};\n+use std::libc::{c_int, size_t};\n \n #[link_args = \"-lsnappy\"]\n extern {\n@@ -149,9 +149,9 @@ A type with the same functionality as owned boxes can be implemented by\n wrapping `malloc` and `free`:\n \n ~~~~\n-use core::libc::{c_void, size_t, malloc, free};\n-use core::unstable::intrinsics;\n-use core::util;\n+use std::libc::{c_void, size_t, malloc, free};\n+use std::unstable::intrinsics;\n+use std::util;\n \n // a wrapper around the handle returned by the foreign code\n pub struct Unique<T> {\n@@ -161,7 +161,7 @@ pub struct Unique<T> {\n pub impl<T: Owned> Unique<T> {\n     fn new(value: T) -> Unique<T> {\n         unsafe {\n-            let ptr = malloc(core::sys::size_of::<T>() as size_t) as *mut T;\n+            let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n             intrinsics::move_val_init(&mut *ptr, value);"}, {"sha": "320385c89a652a7081c1dfe7ebafd583a52c76f7", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -39,40 +39,40 @@ data through the global _exchange heap_.\n \n While Rust's type system provides the building blocks needed for safe\n and efficient tasks, all of the task functionality itself is implemented\n-in the core and standard libraries, which are still under development\n+in the standard and extra libraries, which are still under development\n and do not always present a consistent or complete interface.\n \n For your reference, these are the standard modules involved in Rust\n concurrency at this writing:\n \n-* [`core::task`] - All code relating to tasks and task scheduling,\n-* [`core::comm`] - The message passing interface,\n-* [`core::pipes`] - The underlying messaging infrastructure,\n-* [`std::comm`] - Additional messaging types based on `core::pipes`,\n-* [`std::sync`] - More exotic synchronization tools, including locks,\n-* [`std::arc`] - The ARC (atomically reference counted) type,\n+* [`std::task`] - All code relating to tasks and task scheduling,\n+* [`std::comm`] - The message passing interface,\n+* [`std::pipes`] - The underlying messaging infrastructure,\n+* [`extra::comm`] - Additional messaging types based on `std::pipes`,\n+* [`extra::sync`] - More exotic synchronization tools, including locks,\n+* [`extra::arc`] - The ARC (atomically reference counted) type,\n   for safely sharing immutable data,\n-* [`std::future`] - A type representing values that may be computed concurrently and retrieved at a later time.\n+* [`extra::future`] - A type representing values that may be computed concurrently and retrieved at a later time.\n \n-[`core::task`]: core/task.html\n-[`core::comm`]: core/comm.html\n-[`core::pipes`]: core/pipes.html\n+[`std::task`]: std/task.html\n [`std::comm`]: std/comm.html\n-[`std::sync`]: std/sync.html\n-[`std::arc`]: std/arc.html\n-[`std::future`]: std/future.html\n+[`std::pipes`]: std/pipes.html\n+[`extra::comm`]: extra/comm.html\n+[`extra::sync`]: extra/sync.html\n+[`extra::arc`]: extra/arc.html\n+[`extra::future`]: extra/future.html\n \n # Basics\n \n The programming interface for creating and managing tasks lives\n-in the `task` module of the `core` library, and is thus available to all\n+in the `task` module of the `std` library, and is thus available to all\n Rust code by default. At its simplest, creating a task is a matter of\n calling the `spawn` function with a closure argument. `spawn` executes the\n closure in the new task.\n \n ~~~~\n-# use core::io::println;\n-# use core::task::spawn;\n+# use std::io::println;\n+# use std::task::spawn;\n \n // Print something profound in a different task using a named function\n fn print_message() { println(\"I am running in a different task!\"); }\n@@ -90,7 +90,7 @@ do spawn {\n In Rust, there is nothing special about creating tasks: a task is not a\n concept that appears in the language semantics. Instead, Rust's type system\n provides all the tools necessary to implement safe concurrency: particularly,\n-_owned types_. The language leaves the implementation details to the core\n+_owned types_. The language leaves the implementation details to the standard\n library.\n \n The `spawn` function has a very simple type signature: `fn spawn(f:\n@@ -101,8 +101,8 @@ execution. Like any closure, the function passed to `spawn` may capture\n an environment that it carries across tasks.\n \n ~~~\n-# use core::io::println;\n-# use core::task::spawn;\n+# use std::io::println;\n+# use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n let child_task_number = generate_task_number();\n@@ -118,8 +118,8 @@ in parallel. Thus, on a multicore machine, running the following code\n should interleave the output in vaguely random order.\n \n ~~~\n-# use core::io::print;\n-# use core::task::spawn;\n+# use std::io::print;\n+# use std::task::spawn;\n \n for int::range(0, 20) |child_task_number| {\n     do spawn {\n@@ -147,8 +147,8 @@ endpoint. Consider the following example of calculating two results\n concurrently:\n \n ~~~~\n-# use core::task::spawn;\n-# use core::comm::{stream, Port, Chan};\n+# use std::task::spawn;\n+# use std::comm::{stream, Port, Chan};\n \n let (port, chan): (Port<int>, Chan<int>) = stream();\n \n@@ -169,7 +169,7 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n a tuple into its component parts).\n \n ~~~~\n-# use core::comm::{stream, Chan, Port};\n+# use std::comm::{stream, Chan, Port};\n let (port, chan): (Port<int>, Chan<int>) = stream();\n ~~~~\n \n@@ -178,8 +178,8 @@ which will wait to receive the data on the port. The next statement\n spawns the child task.\n \n ~~~~\n-# use core::task::spawn;\n-# use core::comm::stream;\n+# use std::task::spawn;\n+# use std::comm::stream;\n # fn some_expensive_computation() -> int { 42 }\n # let (port, chan) = stream();\n do spawn || {\n@@ -199,7 +199,7 @@ computation, then waits for the child's result to arrive on the\n port:\n \n ~~~~\n-# use core::comm::{stream};\n+# use std::comm::{stream};\n # fn some_other_expensive_computation() {}\n # let (port, chan) = stream::<int>();\n # chan.send(0);\n@@ -214,8 +214,8 @@ example needed to compute multiple results across a number of tasks? The\n following program is ill-typed:\n \n ~~~ {.xfail-test}\n-# use core::task::{spawn};\n-# use core::comm::{stream, Port, Chan};\n+# use std::task::{spawn};\n+# use std::comm::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = stream();\n \n@@ -234,8 +234,8 @@ Instead we can use a `SharedChan`, a type that allows a single\n `Chan` to be shared by multiple senders.\n \n ~~~\n-# use core::task::spawn;\n-# use core::comm::{stream, SharedChan};\n+# use std::task::spawn;\n+# use std::comm::{stream, SharedChan};\n \n let (port, chan) = stream();\n let chan = SharedChan::new(chan);\n@@ -267,8 +267,8 @@ illustrate the point. For reference, written with multiple streams, it\n might look like the example below.\n \n ~~~\n-# use core::task::spawn;\n-# use core::comm::stream;\n+# use std::task::spawn;\n+# use std::comm::stream;\n \n // Create a vector of ports, one for each child task\n let ports = do vec::from_fn(3) |init_val| {\n@@ -285,7 +285,7 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n ~~~\n \n ## Futures\n-With `std::future`, rust has a mechanism for requesting a computation and getting the result\n+With `extra::future`, rust has a mechanism for requesting a computation and getting the result\n later.\n \n The basic example below illustrates this.\n@@ -296,7 +296,7 @@ fn fib(n: uint) -> uint {\n     12586269025\n }\n \n-let mut delayed_fib = std::future::spawn (|| fib(50) );\n+let mut delayed_fib = extra::future::spawn (|| fib(50) );\n make_a_sandwich();\n println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n ~~~\n@@ -319,7 +319,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| do std::future::spawn { partial_sum(ind) });\n+    let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n     for futures.each_mut |ft|  {\n@@ -344,7 +344,7 @@ All tasks are, by default, _linked_ to each other. That means that the fates\n of all tasks are intertwined: if one fails, so do all the others.\n \n ~~~\n-# use core::task::spawn;\n+# use std::task::spawn;\n # fn do_some_work() { loop { task::yield() } }\n # do task::try {\n // Create a child task that fails\n@@ -384,7 +384,7 @@ enum. If the child task terminates successfully, `try` will\n return an `Ok` result; if the child task fails, `try` will return\n an `Error` result.\n \n-[`Result`]: core/result.html\n+[`Result`]: std/result.html\n \n > ***Note:*** A failed task does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the\n@@ -428,8 +428,8 @@ internally, with additional logic to wait for the child task to finish\n before returning. Hence:\n \n ~~~\n-# use core::comm::{stream, Chan, Port};\n-# use core::task::{spawn, try};\n+# use std::comm::{stream, Chan, Port};\n+# use std::task::{spawn, try};\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n let (receiver, sender): (Port<int>, Chan<int>) = stream();\n@@ -493,7 +493,7 @@ fail!();\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n-function `std::comm::DuplexStream()` supports this pattern.  We'll\n+function `extra::comm::DuplexStream()` supports this pattern.  We'll\n look briefly at how to use it.\n \n To see how `DuplexStream()` works, we will create a child task\n@@ -502,7 +502,7 @@ the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~~\n-# use std::comm::DuplexStream;\n+# use extra::comm::DuplexStream;\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -524,8 +524,8 @@ response itself is simply the stringified version of the received value,\n Here is the code for the parent task:\n \n ~~~~\n-# use core::task::spawn;\n-# use std::comm::DuplexStream;\n+# use std::task::spawn;\n+# use extra::comm::DuplexStream;\n # fn stringifier(channel: &DuplexStream<~str, uint>) {\n #     let mut value: uint;\n #     loop {"}, {"sha": "ad9431ef60ca9f8bdf723847ff8acd1abbb20b58", "filename": "doc/tutorial.md", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -730,7 +730,7 @@ fn point_from_direction(dir: Direction) -> Point {\n Enum variants may also be structs. For example:\n \n ~~~~\n-# use core::float;\n+# use std::float;\n # struct Point { x: float, y: float }\n # fn square(x: float) -> float { x * x }\n enum Shape {\n@@ -1366,11 +1366,11 @@ let exchange_crayons: ~str = ~\"Black, BlizzardBlue, Blue\";\n ~~~\n \n Both vectors and strings support a number of useful\n-[methods](#functions-and-methods), defined in [`core::vec`]\n-and [`core::str`]. Here are some examples.\n+[methods](#functions-and-methods), defined in [`std::vec`]\n+and [`std::str`]. Here are some examples.\n \n-[`core::vec`]: core/vec.html\n-[`core::str`]: core/str.html\n+[`std::vec`]: std/vec.html\n+[`std::str`]: std/str.html\n \n ~~~\n # enum Crayon {\n@@ -1583,7 +1583,7 @@ words, it is a function that takes an owned closure that takes no\n arguments.\n \n ~~~~\n-use core::task::spawn;\n+use std::task::spawn;\n \n do spawn() || {\n     debug!(\"I'm a task, whatever\");\n@@ -1595,7 +1595,7 @@ lists back to back. Since that is so unsightly, empty argument lists\n may be omitted from `do` expressions.\n \n ~~~~\n-# use core::task::spawn;\n+# use std::task::spawn;\n do spawn {\n    debug!(\"Kablam!\");\n }\n@@ -1629,7 +1629,7 @@ fn each(v: &[int], op: &fn(v: &int) -> bool) {\n And using this function to iterate over a vector:\n \n ~~~~\n-# use each = core::vec::each;\n+# use each = std::vec::each;\n each([2, 4, 8, 5, 16], |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1645,7 +1645,7 @@ out of the loop, you just write `break`. To skip ahead\n to the next iteration, write `loop`.\n \n ~~~~\n-# use each = core::vec::each;\n+# use each = std::vec::each;\n for each([2, 4, 8, 5, 16]) |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1660,7 +1660,7 @@ normally allowed in closures, in a block that appears as the body of a\n the enclosing function, not just the loop body.\n \n ~~~~\n-# use each = core::vec::each;\n+# use each = std::vec::each;\n fn contains(v: &[int], elt: int) -> bool {\n     for each(v) |x| {\n         if (*x == elt) { return true; }\n@@ -1675,7 +1675,7 @@ In these situations it can be convenient to lean on Rust's\n argument patterns to bind `x` to the actual value, not the pointer.\n \n ~~~~\n-# use each = core::vec::each;\n+# use each = std::vec::each;\n # fn contains(v: &[int], elt: int) -> bool {\n     for each(v) |&x| {\n         if (x == elt) { return true; }\n@@ -1810,8 +1810,8 @@ impl Circle {\n To call such a method, just prefix it with the type name and a double colon:\n \n ~~~~\n-# use core::float::consts::pi;\n-# use core::float::sqrt;\n+# use std::float::consts::pi;\n+# use std::float::sqrt;\n struct Circle { radius: float }\n impl Circle {\n     fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n@@ -1857,7 +1857,7 @@ illegal to copy and pass by value.\n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n-# use core::hashmap::HashMap;\n+# use std::hashmap::HashMap;\n type Set<T> = HashMap<T, ()>;\n \n struct Stack<T> {\n@@ -2081,8 +2081,8 @@ name and a double colon.  The compiler uses type inference to decide which\n implementation to use.\n \n ~~~~\n-# use core::float::consts::pi;\n-# use core::float::sqrt;\n+# use std::float::consts::pi;\n+# use std::float::sqrt;\n trait Shape { fn new(area: float) -> Self; }\n struct Circle { radius: float }\n struct Square { length: float }\n@@ -2238,8 +2238,8 @@ trait Circle : Shape { fn radius(&self) -> float; }\n Now, we can implement `Circle` on a type only if we also implement `Shape`.\n \n ~~~~\n-# use core::float::consts::pi;\n-# use core::float::sqrt;\n+# use std::float::consts::pi;\n+# use std::float::sqrt;\n # trait Shape { fn area(&self) -> float; }\n # trait Circle : Shape { fn radius(&self) -> float; }\n # struct Point { x: float, y: float }\n@@ -2274,8 +2274,8 @@ fn radius_times_area<T: Circle>(c: T) -> float {\n Likewise, supertrait methods may also be called on trait objects.\n \n ~~~ {.xfail-test}\n-# use core::float::consts::pi;\n-# use core::float::sqrt;\n+# use std::float::consts::pi;\n+# use std::float::sqrt;\n # trait Shape { fn area(&self) -> float; }\n # trait Circle : Shape { fn radius(&self) -> float; }\n # struct Point { x: float, y: float }\n@@ -2292,7 +2292,7 @@ let nonsense = mycircle.radius() * mycircle.area();\n \n ## Deriving implementations for traits\n \n-A small number of traits in `core` and `std` can have implementations\n+A small number of traits in `std` and `std` can have implementations\n that can be automatically derived. These instances are specified by\n placing the `deriving` attribute on a data type declaration. For\n example, the following will mean that `Circle` has an implementation\n@@ -2541,17 +2541,17 @@ as well as an inscrutable string of alphanumerics. These are both\n part of Rust's library versioning scheme. The alphanumerics are\n a hash representing the crate metadata.\n \n-## The core library\n+## The std library\n \n-The Rust core library provides runtime features required by the language,\n+The Rust std library provides runtime features required by the language,\n including the task scheduler and memory allocators, as well as library\n support for Rust built-in types, platform abstractions, and other commonly\n used features.\n \n-[`core`] includes modules corresponding to each of the integer types, each of\n+[`std`] includes modules corresponding to each of the integer types, each of\n the floating point types, the [`bool`] type, [tuples], [characters], [strings],\n [vectors], [managed boxes], [owned boxes],\n-and unsafe and borrowed [pointers].  Additionally, `core` provides\n+and unsafe and borrowed [pointers].  Additionally, `std` provides\n some pervasive types ([`option`] and [`result`]),\n [task] creation and [communication] primitives,\n platform abstractions ([`os`] and [`path`]), basic\n@@ -2561,47 +2561,47 @@ common traits ([`kinds`], [`ops`], [`cmp`], [`num`],\n \n ### Core injection and the Rust prelude\n \n-`core` is imported at the topmost level of every crate by default, as\n+`std` is imported at the topmost level of every crate by default, as\n if the first line of each crate was\n \n-    extern mod core;\n+    extern mod std;\n \n-This means that the contents of core can be accessed from from any context\n-with the `core::` path prefix, as in `use core::vec`, `use core::task::spawn`,\n+This means that the contents of std can be accessed from from any context\n+with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n etc.\n \n-Additionally, `core` contains a `prelude` module that reexports many of the\n-most common core modules, types and traits. The contents of the prelude are\n+Additionally, `std` contains a `prelude` module that reexports many of the\n+most common std modules, types and traits. The contents of the prelude are\n imported into every *module* by default.  Implicitly, all modules behave as if\n they contained the following prologue:\n \n-    use core::prelude::*;\n-\n-[`core`]: core/index.html\n-[`bool`]: core/bool.html\n-[tuples]: core/tuple.html\n-[characters]: core/char.html\n-[strings]: core/str.html\n-[vectors]: core/vec.html\n-[managed boxes]: core/managed.html\n-[owned boxes]: core/owned.html\n-[pointers]: core/ptr.html\n-[`option`]: core/option.html\n-[`result`]: core/result.html\n-[task]: core/task.html\n-[communication]: core/comm.html\n-[`os`]: core/os.html\n-[`path`]: core/path.html\n-[`io`]: core/io.html\n-[containers]: core/container.html\n-[`hashmap`]: core/hashmap.html\n-[`kinds`]: core/kinds.html\n-[`ops`]: core/ops.html\n-[`cmp`]: core/cmp.html\n-[`num`]: core/num.html\n-[`to_str`]: core/to_str.html\n-[`clone`]: core/clone.html\n-[`libc`]: core/libc.html\n+    use std::prelude::*;\n+\n+[`std`]: std/index.html\n+[`bool`]: std/bool.html\n+[tuples]: std/tuple.html\n+[characters]: std/char.html\n+[strings]: std/str.html\n+[vectors]: std/vec.html\n+[managed boxes]: std/managed.html\n+[owned boxes]: std/owned.html\n+[pointers]: std/ptr.html\n+[`option`]: std/option.html\n+[`result`]: std/result.html\n+[task]: std/task.html\n+[communication]: std/comm.html\n+[`os`]: std/os.html\n+[`path`]: std/path.html\n+[`io`]: std/io.html\n+[containers]: std/container.html\n+[`hashmap`]: std/hashmap.html\n+[`kinds`]: std/kinds.html\n+[`ops`]: std/ops.html\n+[`cmp`]: std/cmp.html\n+[`num`]: std/num.html\n+[`to_str`]: std/to_str.html\n+[`clone`]: std/clone.html\n+[`libc`]: std/libc.html\n \n # What next?\n "}, {"sha": "0260789adfc2336869f545d50a74601df042cdd7", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -57,8 +57,8 @@\n         if not ignore:\n             if not re.search(r\"\\bfn main\\b\", block):\n                 block = \"fn main() {\\n\" + block + \"\\n}\\n\"\n-            if not re.search(r\"\\bextern mod std\\b\", block):\n-                block = \"extern mod std;\\n\" + block\n+            if not re.search(r\"\\bextern mod extra\\b\", block):\n+                block = \"extern mod extra;\\n\" + block\n             block = \"\"\"#[ forbid(ctypes) ];\n #[ forbid(deprecated_pattern) ];\n #[ forbid(implicit_copies) ];"}, {"sha": "d99e6f5085d464962d3878c0c7182c4cb8dc15ca", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -431,6 +431,7 @@ pub fn main() {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use core::io;\n \n     fn repl() -> Repl {\n         Repl {"}, {"sha": "55bc302d9a17ec330c736563f08146034c1ca778", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34cfd2183b1d46ccec97691870a3bcceee5ee367/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=34cfd2183b1d46ccec97691870a3bcceee5ee367", "patch": "@@ -13,6 +13,7 @@\n use context::Ctx;\n use core::hashmap::HashMap;\n use core::path::Path;\n+use core::prelude::*;\n use std::tempfile::mkdtemp;\n use util::{PkgId, default_version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,"}]}