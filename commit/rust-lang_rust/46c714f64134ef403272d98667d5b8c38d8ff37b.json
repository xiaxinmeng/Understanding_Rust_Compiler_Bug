{"sha": "46c714f64134ef403272d98667d5b8c38d8ff37b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YzcxNGY2NDEzNGVmNDAzMjcyZDk4NjY3ZDViOGMzOGQ4ZmYzN2I=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2020-11-05T13:29:48Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2020-11-05T13:29:48Z"}, "message": "Merge commit 'b20d4c155d2fe3a8391f86dcf9a8c49e17188703' into clippyup", "tree": {"sha": "02551df757af83cecad4a1842750436ea159af5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02551df757af83cecad4a1842750436ea159af5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46c714f64134ef403272d98667d5b8c38d8ff37b", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAl+j/k8ACgkQHKDfKvWd\naKV4RRAAh/BXJdgyTW28y6JPpUBDxXBoilD6wNJYOjYXz8WXmx5MrDcyhDJplxln\ngRsb3wU62HOFC85uIIT7gJLhK1lXFSjZ69GecxAp0dJn3yWlhcbmuB4BciTaeyfu\nGRp1RO+sIn+O2wRN68j8KWaDWls/j+9HhXjhfp4euAgAvCkq4S37J18RGGtPHHlL\nPe56nBE+auaSWfz4IOjHAEZZbghcispgg6ChupM6ck+A/l+bIXjtxwLOU17IjB0M\nS6GXbOAGcXBK8mkRjXnWNqHLhhnZycGK6ecaZWjF2sEDAKpU7lVNP7HGvkojtEHP\neceKLi937jAFBlFTYirmQYTV+vH5174FWSNbELqxR27iYxvKGWnkxNIO+g5ueGBX\nj3zwP+qb1owOsMobe+VfmJc26Emv7R3lCPP6DSIG/Jw0XtqseGofC3kus+qYav8B\nlaN62EIReEKpKWQCvLXV9VfFYonV9mn9/d+YlWIrx8o5Qwtk73JdoL6gyQNlYorf\nxX4x3QUrMnqWoMHbmQH7dgZfzpvItnx90lHzbNqLhMcdkPb1tXn3R33UQQAnBmUB\nlgD5BkMfuS254Ey6Ykx5iMIunS8GbLvAjBEUDC2usO3e7RVdh++ZCmEPuxGFVoB4\nnKdCPWkNZbUMMzXMP2odRpx2sNZLYMJp1U33q++wTeHbTEU+Z9U=\n=gMwq\n-----END PGP SIGNATURE-----", "payload": "tree 02551df757af83cecad4a1842750436ea159af5a\nparent f7801d6c7cc19ab22bdebcc8efa894a564c53469\nparent b20d4c155d2fe3a8391f86dcf9a8c49e17188703\nauthor flip1995 <philipp.krones@embecosm.com> 1604582988 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1604582988 +0100\n\nMerge commit 'b20d4c155d2fe3a8391f86dcf9a8c49e17188703' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46c714f64134ef403272d98667d5b8c38d8ff37b", "html_url": "https://github.com/rust-lang/rust/commit/46c714f64134ef403272d98667d5b8c38d8ff37b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46c714f64134ef403272d98667d5b8c38d8ff37b/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7801d6c7cc19ab22bdebcc8efa894a564c53469", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7801d6c7cc19ab22bdebcc8efa894a564c53469", "html_url": "https://github.com/rust-lang/rust/commit/f7801d6c7cc19ab22bdebcc8efa894a564c53469"}, {"sha": "b20d4c155d2fe3a8391f86dcf9a8c49e17188703", "url": "https://api.github.com/repos/rust-lang/rust/commits/b20d4c155d2fe3a8391f86dcf9a8c49e17188703", "html_url": "https://github.com/rust-lang/rust/commit/b20d4c155d2fe3a8391f86dcf9a8c49e17188703"}], "stats": {"total": 3514, "additions": 2839, "deletions": 675}, "files": [{"sha": "6ff189fc85926e61a2349bc3e6bc5fe370738204", "filename": "src/tools/clippy/.github/driver.sh", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -24,16 +24,16 @@ unset CARGO_MANIFEST_DIR\n # FIXME: How to match the clippy invocation in compile-test.rs?\n ./target/debug/clippy-driver -Dwarnings -Aunused -Zui-testing --emit metadata --crate-type bin tests/ui/double_neg.rs 2>double_neg.stderr && exit 1\n sed -e \"s,tests/ui,\\$DIR,\" -e \"/= help/d\" double_neg.stderr >normalized.stderr\n-diff normalized.stderr tests/ui/double_neg.stderr\n+diff -u normalized.stderr tests/ui/double_neg.stderr\n \n # make sure \"clippy-driver --rustc --arg\" and \"rustc --arg\" behave the same\n SYSROOT=$(rustc --print sysroot)\n-diff <(LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver --rustc --version --verbose) <(rustc --version --verbose)\n+diff -u <(LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver --rustc --version --verbose) <(rustc --version --verbose)\n \n echo \"fn main() {}\" >target/driver_test.rs\n # we can't run 2 rustcs on the same file at the same time\n CLIPPY=$(LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver ./target/driver_test.rs --rustc)\n RUSTC=$(rustc ./target/driver_test.rs)\n-diff <($CLIPPY) <($RUSTC)\n+diff -u <($CLIPPY) <($RUSTC)\n \n # TODO: CLIPPY_CONF_DIR / CARGO_MANIFEST_DIR"}, {"sha": "1b9b33803de26c29bc093fb6bb18274127b439b7", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -22,7 +22,7 @@ Current beta, release 2020-11-19\n * [`map_err_ignore`] [#5998](https://github.com/rust-lang/rust-clippy/pull/5998)\n * [`rc_buffer`] [#6044](https://github.com/rust-lang/rust-clippy/pull/6044)\n * [`to_string_in_display`] [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n-* [`single_char_push_str`] [#5881](https://github.com/rust-lang/rust-clippy/pull/5881)\n+* `single_char_push_str` [#5881](https://github.com/rust-lang/rust-clippy/pull/5881)\n \n ### Moves and Deprecations\n \n@@ -1665,6 +1665,7 @@ Released 2018-09-13\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n+[`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n [`create_dir`]: https://rust-lang.github.io/rust-clippy/master/index.html#create_dir\n [`crosspointer_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#crosspointer_transmute\n@@ -1713,6 +1714,7 @@ Released 2018-09-13\n [`extend_from_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#extend_from_slice\n [`extra_unused_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_lifetimes\n [`fallible_impl_from`]: https://rust-lang.github.io/rust-clippy/master/index.html#fallible_impl_from\n+[`field_reassign_with_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#field_reassign_with_default\n [`filetype_is_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#filetype_is_file\n [`filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map\n [`filter_map_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map_next\n@@ -1731,6 +1733,7 @@ Released 2018-09-13\n [`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n+[`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n@@ -1795,13 +1798,15 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n+[`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n+[`map_collect_result_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_collect_result_unit\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n [`map_err_ignore`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_err_ignore\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n@@ -1917,6 +1922,7 @@ Released 2018-09-13\n [`redundant_pub_crate`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pub_crate\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n+[`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n [`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n@@ -1937,8 +1943,8 @@ Released 2018-09-13\n [`should_assert_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_assert_eq\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n+[`single_char_add_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_add_str\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n-[`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n [`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match"}, {"sha": "a8e2123656e97a478269ad68d88e8bd4ca0077e0", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -63,9 +63,10 @@ To figure out how this syntax structure is encoded in the AST, it is recommended\n Usually the lint will end up to be a nested series of matches and ifs, [like so][deep-nesting].\n But we can make it nest-less by using [if_chain] macro, [like this][nest-less].\n \n-[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an E-easy issue first.\n-They are mostly classified as [`E-medium`], since they might be somewhat involved code wise,\n-but not difficult per-se.\n+[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good first issue`]\n+first. Sometimes they are only somewhat involved code wise, but not difficult per-se.\n+Note that [`E-medium`] issues may require some knowledge of Clippy internals or some \n+debugging to find the actual problem behind the issue. \n \n [`T-middle`] issues can be more involved and require verifying types. The [`ty`] module contains a\n lot of methods that are useful, though one of the most useful would be `expr_ty` (gives the type of"}, {"sha": "8a5975e1f9711b25878cc04d41d7215f3562b3be", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -167,18 +167,21 @@ You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n \n *   `allow`/`warn`/`deny` can be limited to a single function or module using `#[allow(...)]`, etc.\n \n-Note: `deny` produces errors instead of warnings.\n+Note: `allow` means to suppress the lint for your code. With `warn` the lint\n+will only emit a warning, while with `deny` the lint will emit an error, when\n+triggering for your code. An error causes clippy to exit with an error code, so\n+is useful in scripts like CI/CD.\n \n-If you do not want to include your lint levels in your code, you can globally enable/disable lints\n-by passing extra flags to Clippy during the run:\n+If you do not want to include your lint levels in your code, you can globally\n+enable/disable lints by passing extra flags to Clippy during the run:\n \n-To disable `lint_name`, run\n+To allow `lint_name`, run\n \n ```terminal\n cargo clippy -- -A clippy::lint_name\n ```\n \n-And to enable `lint_name`, run\n+And to warn on `lint_name`, run\n \n ```terminal\n cargo clippy -- -W clippy::lint_name\n@@ -190,7 +193,7 @@ can run Clippy with warnings for all lints enabled:\n cargo clippy -- -W clippy::pedantic\n ```\n \n-If you care only about a single lint, you can allow all others and then explicitly reenable\n+If you care only about a single lint, you can allow all others and then explicitly warn on\n the lint(s) you are interested in:\n ```terminal\n cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::..."}, {"sha": "9d9e836cc08a2f5e420dae848f8fe77aabcb40d5", "filename": "src/tools/clippy/clippy_dev/src/ra_setup.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -11,7 +11,7 @@ use std::path::PathBuf;\n // code. See https://github.com/rust-analyzer/rust-analyzer/issues/3517 and https://github.com/rust-lang/rust-clippy/issues/5514 for details\n \n pub fn run(rustc_path: Option<&str>) {\n-    // we can unwrap here because the arg is required here\n+    // we can unwrap here because the arg is required by clap\n     let rustc_path = PathBuf::from(rustc_path.unwrap());\n     assert!(rustc_path.is_dir(), \"path is not a directory\");\n     let rustc_source_basedir = rustc_path.join(\"compiler\");\n@@ -49,6 +49,15 @@ fn inject_deps_into_manifest(\n     cargo_toml: &str,\n     lib_rs: &str,\n ) -> std::io::Result<()> {\n+    // do not inject deps if we have aleady done so\n+    if cargo_toml.contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\") {\n+        eprintln!(\n+            \"cargo dev ra-setup: warning: deps already found inside {}, doing nothing.\",\n+            manifest_path\n+        );\n+        return Ok(());\n+    }\n+\n     let extern_crates = lib_rs\n         .lines()\n         // get the deps"}, {"sha": "9861d8cfc4e5f4146e7101d57fbea558b2d9c081", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -88,9 +88,28 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n \n                 let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n                 if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n-                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                    self.expr_span = Some(expr.span);\n-                } else if l_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+                    match op.node {\n+                        hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n+                            hir::ExprKind::Lit(_lit) => (),\n+                            hir::ExprKind::Unary(hir::UnOp::UnNeg, expr) => {\n+                                if let hir::ExprKind::Lit(lit) = &expr.kind {\n+                                    if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n+                                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                                        self.expr_span = Some(expr.span);\n+                                    }\n+                                }\n+                            },\n+                            _ => {\n+                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                                self.expr_span = Some(expr.span);\n+                            },\n+                        },\n+                        _ => {\n+                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                            self.expr_span = Some(expr.span);\n+                        },\n+                    }\n+                } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.expr_span = Some(expr.span);\n                 }"}, {"sha": "a004abb58b83ed0097f64e265a7a4b5126347e8d", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_span::symbol::{Symbol, SymbolStr};\n use semver::Version;\n \n@@ -286,14 +287,14 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     },\n                     _ => {},\n                 }\n-                if items.is_empty() || !attr.has_name(sym!(deprecated)) {\n+                if items.is_empty() || !attr.has_name(sym::deprecated) {\n                     return;\n                 }\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n                         if let MetaItemKind::NameValue(lit) = &mi.kind;\n-                        if mi.has_name(sym!(since));\n+                        if mi.has_name(sym::since);\n                         then {\n                             check_semver(cx, item.span(), lit);\n                         }\n@@ -309,7 +310,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym!(macro_use)));\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym::macro_use));\n \n                 for attr in item.attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n@@ -326,7 +327,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                         match item.kind {\n                                             ItemKind::Use(..) => {\n                                                 if is_word(lint, sym!(unused_imports))\n-                                                    || is_word(lint, sym!(deprecated))\n+                                                    || is_word(lint, sym::deprecated)\n                                                     || is_word(lint, sym!(unreachable_pub))\n                                                     || is_word(lint, sym!(unused))\n                                                     || extract_clippy_lint(lint)\n@@ -411,8 +412,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n     let lint_store = cx.lints();\n     for lint in items {\n         if let Some(lint_name) = extract_clippy_lint(lint) {\n-            if let CheckLintNameResult::Tool(Err((None, _))) =\n-                lint_store.check_lint_name(&lint_name, Some(sym!(clippy)))\n+            if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(&lint_name, Some(sym::clippy))\n             {\n                 span_lint_and_then(\n                     cx,\n@@ -529,10 +529,10 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n \n     for attr in attrs {\n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || !attr.has_name(sym!(inline)) {\n+            if values.len() != 1 || !attr.has_name(sym::inline) {\n                 continue;\n             }\n-            if is_word(&values[0], sym!(always)) {\n+            if is_word(&values[0], sym::always) {\n                 span_lint(\n                     cx,\n                     INLINE_ALWAYS,\n@@ -623,12 +623,12 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n     if_chain! {\n         // check cfg_attr\n-        if attr.has_name(sym!(cfg_attr));\n+        if attr.has_name(sym::cfg_attr);\n         if let Some(items) = attr.meta_item_list();\n         if items.len() == 2;\n         // check for `rustfmt`\n         if let Some(feature_item) = items[0].meta_item();\n-        if feature_item.has_name(sym!(rustfmt));\n+        if feature_item.has_name(sym::rustfmt);\n         // check for `rustfmt_skip` and `rustfmt::skip`\n         if let Some(skip_item) = &items[1].meta_item();\n         if skip_item.has_name(sym!(rustfmt_skip)) ||\n@@ -690,7 +690,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n     }\n \n     if_chain! {\n-        if attr.has_name(sym!(cfg));\n+        if attr.has_name(sym::cfg);\n         if let Some(list) = attr.meta_item_list();\n         let mismatched = find_mismatched_target_os(&list);\n         if !mismatched.is_empty();"}, {"sha": "90bb0bd555f274169d6144f7b5adb56385a422bb", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -11,6 +11,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for boolean expressions that can be written more\n@@ -253,8 +254,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n         },\n         ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n             let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n-            if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n-                && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n+            if !is_type_diagnostic_item(cx, type_of_receiver, sym::option_type)\n+                && !is_type_diagnostic_item(cx, type_of_receiver, sym::result_type)\n             {\n                 return None;\n             }"}, {"sha": "38a0e27c4cf5b8d1c48cec85d5a8e3b02ff735d6", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use rustc_span::Symbol;\n \n declare_clippy_lint! {\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n                                 filter_args[0].kind {\n                             let p = path.ident.name;\n-                            if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {\n+                            if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                                 &args[0]\n                             } else {\n                                 &filter_args[0]"}, {"sha": "b1bc2ec29e16ee3d2d1f847db6a23aadb6b29bdc", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n+use rustc_span::{sym, BytePos};\n \n use crate::utils::{is_type_diagnostic_item, snippet_opt, span_lint_and_help, LimitStack};\n \n@@ -61,7 +61,7 @@ impl CognitiveComplexity {\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n-        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n+        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::result_type) {\n             returns\n         } else {\n             #[allow(clippy::integer_division)]\n@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         hir_id: HirId,\n     ) {\n         let def_id = cx.tcx.hir().local_def_id(hir_id);\n-        if !cx.tcx.has_attr(def_id.to_def_id(), sym!(test)) {\n+        if !cx.tcx.has_attr(def_id.to_def_id(), sym::test) {\n             self.check(cx, kind, decl, body, span);\n         }\n     }"}, {"sha": "0035ded9356cf53ba787f20a386ac9bee6162126", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,10 +7,10 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n use rustc_lint::LateContext;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt, ScalarInt};\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n-use rustc_middle::mir::interpret::Scalar;\n use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n use std::convert::TryInto;\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n }\n \n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::{ConstValue};\n+    use rustc_middle::mir::interpret::ConstValue;\n     match result.val {\n         ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n             match result.ty.kind() {"}, {"sha": "612c5355338a140f1ed371a01779fee6a4fbf20a", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,304 @@\n+use crate::utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet};\n+use crate::utils::{span_lint_and_note, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n+use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Adt, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for literal calls to `Default::default()`.\n+    ///\n+    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+    /// being gotten than the generic `Default`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let s: String = Default::default();\n+    ///\n+    /// // Good\n+    /// let s = String::default();\n+    /// ```\n+    pub DEFAULT_TRAIT_ACCESS,\n+    pedantic,\n+    \"checks for literal calls to `Default::default()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for immediate reassignment of fields initialized\n+    /// with Default::default().\n+    ///\n+    /// **Why is this bad?**It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n+    ///\n+    /// **Known problems:** Assignments to patterns that are of tuple type are not linted.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```\n+    /// # #[derive(Default)]\n+    /// # struct A { i: i32 }\n+    /// let mut a: A = Default::default();\n+    /// a.i = 42;\n+    /// ```\n+    /// Use instead:\n+    /// ```\n+    /// # #[derive(Default)]\n+    /// # struct A { i: i32 }\n+    /// let a = A {\n+    ///     i: 42,\n+    ///     .. Default::default()\n+    /// };\n+    /// ```\n+    pub FIELD_REASSIGN_WITH_DEFAULT,\n+    style,\n+    \"binding initialized with Default should have its fields set in the initializer\"\n+}\n+\n+#[derive(Default)]\n+pub struct Default {\n+    // Spans linted by `field_reassign_with_default`.\n+    reassigned_linted: FxHashSet<Span>,\n+}\n+\n+impl_lint_pass!(Default => [DEFAULT_TRAIT_ACCESS, FIELD_REASSIGN_WITH_DEFAULT]);\n+\n+impl LateLintPass<'_> for Default {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // Avoid cases already linted by `field_reassign_with_default`\n+            if !self.reassigned_linted.contains(&expr.span);\n+            if let ExprKind::Call(ref path, ..) = expr.kind;\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n+            if let QPath::Resolved(None, _path) = qpath;\n+            then {\n+                let expr_ty = cx.typeck_results().expr_ty(expr);\n+                if let ty::Adt(def, ..) = expr_ty.kind() {\n+                    // TODO: Work out a way to put \"whatever the imported way of referencing\n+                    // this type in this file\" rather than a fully-qualified type.\n+                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                    span_lint_and_sugg(\n+                        cx,\n+                        DEFAULT_TRAIT_ACCESS,\n+                        expr.span,\n+                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n+                        \"try\",\n+                        replacement,\n+                        Applicability::Unspecified, // First resolve the TODO above\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_block<'tcx>(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+        // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n+        // `default` method of the `Default` trait, and store statement index in current block being\n+        // checked and the name of the bound variable\n+        let binding_statements_using_default = enumerate_bindings_using_default(cx, block);\n+\n+        // start from the `let mut _ = _::default();` and look at all the following\n+        // statements, see if they re-assign the fields of the binding\n+        for (stmt_idx, binding_name, binding_type, span) in binding_statements_using_default {\n+            // the last statement of a block cannot trigger the lint\n+            if stmt_idx == block.stmts.len() - 1 {\n+                break;\n+            }\n+\n+            // find all \"later statement\"'s where the fields of the binding set as\n+            // Default::default() get reassigned, unless the reassignment refers to the original binding\n+            let mut first_assign = None;\n+            let mut assigned_fields = Vec::new();\n+            let mut cancel_lint = false;\n+            for consecutive_statement in &block.stmts[stmt_idx + 1..] {\n+                // interrupt if the statement is a let binding (`Local`) that shadows the original\n+                // binding\n+                if stmt_shadows_binding(consecutive_statement, binding_name) {\n+                    break;\n+                }\n+                // find out if and which field was set by this `consecutive_statement`\n+                else if let Some((field_ident, assign_rhs)) =\n+                    field_reassigned_by_stmt(consecutive_statement, binding_name)\n+                {\n+                    // interrupt and cancel lint if assign_rhs references the original binding\n+                    if contains_name(binding_name, assign_rhs) {\n+                        cancel_lint = true;\n+                        break;\n+                    }\n+\n+                    // if the field was previously assigned, replace the assignment, otherwise insert the assignment\n+                    if let Some(prev) = assigned_fields\n+                        .iter_mut()\n+                        .find(|(field_name, _)| field_name == &field_ident.name)\n+                    {\n+                        *prev = (field_ident.name, assign_rhs);\n+                    } else {\n+                        assigned_fields.push((field_ident.name, assign_rhs));\n+                    }\n+\n+                    // also set first instance of error for help message\n+                    if first_assign.is_none() {\n+                        first_assign = Some(consecutive_statement);\n+                    }\n+                }\n+                // interrupt also if no field was assigned, since we only want to look at consecutive statements\n+                else {\n+                    break;\n+                }\n+            }\n+\n+            // if there are incorrectly assigned fields, do a span_lint_and_note to suggest\n+            // construction using `Ty { fields, ..Default::default() }`\n+            if !assigned_fields.is_empty() && !cancel_lint {\n+                // take the original assignment as span\n+                let stmt = &block.stmts[stmt_idx];\n+\n+                if let StmtKind::Local(preceding_local) = &stmt.kind {\n+                    // filter out fields like `= Default::default()`, because the FRU already covers them\n+                    let assigned_fields = assigned_fields\n+                        .into_iter()\n+                        .filter(|(_, rhs)| !is_expr_default(rhs, cx))\n+                        .collect::<Vec<(Symbol, &Expr<'_>)>>();\n+\n+                    // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n+                    let ext_with_default = !fields_of_type(binding_type)\n+                        .iter()\n+                        .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.name));\n+\n+                    let field_list = assigned_fields\n+                        .into_iter()\n+                        .map(|(field, rhs)| {\n+                            // extract and store the assigned value for help message\n+                            let value_snippet = snippet(cx, rhs.span, \"..\");\n+                            format!(\"{}: {}\", field, value_snippet)\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+\n+                    let sugg = if ext_with_default {\n+                        if field_list.is_empty() {\n+                            format!(\"{}::default()\", binding_type)\n+                        } else {\n+                            format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n+                        }\n+                    } else {\n+                        format!(\"{} {{ {} }}\", binding_type, field_list)\n+                    };\n+\n+                    // span lint once per statement that binds default\n+                    span_lint_and_note(\n+                        cx,\n+                        FIELD_REASSIGN_WITH_DEFAULT,\n+                        first_assign.unwrap().span,\n+                        \"field assignment outside of initializer for an instance created with Default::default()\",\n+                        Some(preceding_local.span),\n+                        &format!(\n+                            \"consider initializing the variable with `{}` and removing relevant reassignments\",\n+                            sugg\n+                        ),\n+                    );\n+                    self.reassigned_linted.insert(span);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks if the given expression is the `default` method belonging to the `Default` trait.\n+fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    if_chain! {\n+        if let ExprKind::Call(ref fn_expr, _) = &expr.kind;\n+        if let ExprKind::Path(qpath) = &fn_expr.kind;\n+        if let Res::Def(_, def_id) = qpath_res(cx, qpath, fn_expr.hir_id);\n+        then {\n+            // right hand side of assignment is `Default::default`\n+            match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Returns the block indices, identifiers and types of bindings set as `Default::default()`, except\n+/// for when the pattern type is a tuple.\n+fn enumerate_bindings_using_default<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    block: &Block<'tcx>,\n+) -> Vec<(usize, Symbol, Ty<'tcx>, Span)> {\n+    block\n+        .stmts\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(idx, stmt)| {\n+            if_chain! {\n+                // only take `let ...` statements\n+                if let StmtKind::Local(ref local) = stmt.kind;\n+                // only take bindings to identifiers\n+                if let PatKind::Binding(_, _, ident, _) = local.pat.kind;\n+                // that are not tuples\n+                let ty = cx.typeck_results().pat_ty(local.pat);\n+                if !matches!(ty.kind(), ty::Tuple(_));\n+                // only when assigning `... = Default::default()`\n+                if let Some(ref expr) = local.init;\n+                if is_expr_default(expr, cx);\n+                then {\n+                    Some((idx, ident.name, ty, expr.span))\n+                } else {\n+                    None\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn stmt_shadows_binding(this: &Stmt<'_>, shadowed: Symbol) -> bool {\n+    if let StmtKind::Local(local) = &this.kind {\n+        if let PatKind::Binding(_, _, ident, _) = local.pat.kind {\n+            return ident.name == shadowed;\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns the reassigned field and the assigning expression (right-hand side of assign).\n+fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+        // only take assignments\n+        if let StmtKind::Semi(ref later_expr) = this.kind;\n+        if let ExprKind::Assign(ref assign_lhs, ref assign_rhs, _) = later_expr.kind;\n+        // only take assignments to fields where the left-hand side field is a field of\n+        // the same binding as the previous statement\n+        if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n+        if let ExprKind::Path(ref qpath) = binding.kind;\n+        if let QPath::Resolved(_, path) = qpath;\n+        if let Some(second_binding_name) = path.segments.last();\n+        if second_binding_name.ident.name == binding_name;\n+        then {\n+            Some((field_ident, assign_rhs))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Returns the vec of fields for a struct and an empty vec for non-struct ADTs.\n+fn fields_of_type(ty: Ty<'_>) -> Vec<Ident> {\n+    if let Adt(adt, _) = ty.kind() {\n+        if adt.is_struct() {\n+            let variant = &adt.non_enum_variant();\n+            return variant.fields.iter().map(|f| f.ident).collect();\n+        }\n+    }\n+    vec![]\n+}"}, {"sha": "3048436d9a7b5f30d066fc7374fd2db090d9e2db", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,62 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{any_parent_is_automatically_derived, match_def_path, paths, span_lint_and_sugg};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for literal calls to `Default::default()`.\n-    ///\n-    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n-    /// being gotten than the generic `Default`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let s: String = Default::default();\n-    ///\n-    /// // Good\n-    /// let s = String::default();\n-    /// ```\n-    pub DEFAULT_TRAIT_ACCESS,\n-    pedantic,\n-    \"checks for literal calls to `Default::default()`\"\n-}\n-\n-declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref path, ..) = expr.kind;\n-            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-            if let ExprKind::Path(ref qpath) = path.kind;\n-            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n-            // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n-            if let QPath::Resolved(None, _path) = qpath;\n-            then {\n-                let expr_ty = cx.typeck_results().expr_ty(expr);\n-                if let ty::Adt(def, ..) = expr_ty.kind() {\n-                    // TODO: Work out a way to put \"whatever the imported way of referencing\n-                    // this type in this file\" rather than a fully-qualified type.\n-                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n-                    span_lint_and_sugg(\n-                        cx,\n-                        DEFAULT_TRAIT_ACCESS,\n-                        expr.span,\n-                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n-                        \"try\",\n-                        replacement,\n-                        Applicability::Unspecified, // First resolve the TODO above\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "edecba57e44f0a38073d8664ff76211aed3174a7", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -15,7 +15,7 @@ use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n-use rustc_span::{FileName, Pos};\n+use rustc_span::{sym, FileName, Pos};\n use std::io;\n use std::ops::Range;\n use url::Url;\n@@ -237,7 +237,7 @@ fn lint_for_missing_headers<'tcx>(\n         );\n     }\n     if !headers.errors {\n-        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             span_lint(\n                 cx,\n                 MISSING_ERRORS_DOC,\n@@ -255,7 +255,7 @@ fn lint_for_missing_headers<'tcx>(\n                 if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n                 if let ty::Generator(_, subs, _) = gen.kind();\n-                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n+                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym::result_type);\n                 then {\n                     span_lint(\n                         cx,\n@@ -333,7 +333,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n             let (comment, current_spans) = strip_doc_comment_decoration(&comment.as_str(), comment_kind, attr.span);\n             spans.extend_from_slice(&current_spans);\n             doc.push_str(&comment);\n-        } else if attr.has_name(sym!(doc)) {\n+        } else if attr.has_name(sym::doc) {\n             // ignore mix of sugared and non-sugared doc\n             // don't trigger the safety or errors check\n             return DocHeaders {\n@@ -479,7 +479,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n                     | ItemKind::ExternCrate(..)\n                     | ItemKind::ForeignMod(..) => return false,\n                     // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym!(main) => {\n+                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n                         let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n                         let returns_nothing = match &sig.decl.output {\n                             FnRetTy::Default(..) => true,"}, {"sha": "f8038d06e50347ea90c317b7c194c7f69832ffe0", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,6 +5,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n@@ -33,7 +34,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n         if_chain! {\n             // match call to unwrap\n             if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;\n-            if unwrap_fun.ident.name == sym!(unwrap);\n+            if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n             if !unwrap_args.is_empty();\n             if let ExprKind::MethodCall(ref write_fun, _, write_args, _) ="}, {"sha": "fe817fe94f2e4c4cdb5bd19cbc839cb8a33d7fb7", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n@@ -95,8 +95,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-                if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+                if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n                 {\n                     self.result.push(expr.span);\n                 }\n@@ -113,7 +113,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n     for impl_item in impl_items {\n         if_chain! {\n-            if impl_item.ident.name == sym!(from);\n+            if impl_item.ident.name == sym::from;\n             if let ImplItemKind::Fn(_, body_id) =\n                 cx.tcx.hir().impl_item(impl_item.id).kind;\n             then {"}, {"sha": "8e41e0e34daf75bc6f87242e19dc38756a30248a", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `format!(\"string literal with no\n@@ -91,7 +92,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if pats.len() == 1;\n         then {\n             let ty = cx.typeck_results().pat_ty(&pats[0]).peel_refs();\n-            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 return None;\n             }\n             if let ExprKind::Lit(ref lit) = format_args.kind {\n@@ -186,15 +187,15 @@ fn check_unformatted(expr: &Expr<'_>) -> bool {\n         if exprs.len() == 1;\n         // struct `core::fmt::rt::v1::Argument`\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n-        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n+        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n-        if last_path_segment(precision_path).ident.name == sym!(Implied);\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if last_path_segment(precision_path).ident.name == sym::Implied;\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym::width);\n         if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n-        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n+        if last_path_segment(width_qpath).ident.name == sym::Implied;\n         then {\n             return true;\n         }"}, {"sha": "8b58d1f26013aa504fac9978d33e350a89ac474e", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -473,7 +474,7 @@ fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span\n         if !in_external_macro(cx.sess(), item_span);\n         if let hir::FnRetTy::Return(ref ty) = decl.output;\n         if let hir::TyKind::Path(ref qpath) = ty.kind;\n-        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym!(result_type));\n+        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym::result_type);\n         if let Some(ref args) = last_path_segment(qpath).args;\n         if let [_, hir::GenericArg::Type(ref err_ty)] = args.args;\n         if let hir::TyKind::Tup(t) = err_ty.kind;"}, {"sha": "cdd8a42e7cd12c003363c1e538b2f4564b79803b", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for using `x.get(x.len() - 1)` instead of\n@@ -55,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n             // Argument 0 (the struct we're calling the method on) is a vector\n             if let Some(struct_calling_on) = args.get(0);\n             let struct_ty = cx.typeck_results().expr_ty(struct_calling_on);\n-            if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n+            if is_type_diagnostic_item(cx, struct_ty, sym::vec_type);\n \n             // Argument to \"get\" is a subtraction\n             if let Some(get_index_arg) = args.get(1);"}, {"sha": "e0a1f4c5ca4f2cd25f0fbd7d5862a52bbaa3edc1", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -4,6 +4,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:*** Checks for unnecessary `ok()` in if let.\n@@ -45,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym!(result_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "b723d06a6881d27454b4d94a3b5aca6918748739", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -2,6 +2,7 @@ use if_chain::if_chain;\n use rustc_hir::{ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n use crate::utils::{\n     get_trait_def_id, implements_trait, is_type_diagnostic_item, paths, return_ty, span_lint_and_help,\n@@ -107,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if decl.inputs.len() == 1;\n \n             // Check if return type is String\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::string_type);\n \n             // Filters instances of to_string which are required by a trait\n             if trait_ref_of_method(cx, impl_item.hir_id).is_none();"}, {"sha": "d1c3fdc71461b03e6552712c4451e478209f6698", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{TraitFn, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for InlineFnWithoutBody {\n \n fn check_attrs(cx: &LateContext<'_>, name: Symbol, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if !attr.has_name(sym!(inline)) {\n+        if !attr.has_name(sym::inline) {\n             continue;\n         }\n "}, {"sha": "8998fae09de31f38b50d79b48e8fab933bf3b63e", "filename": "src/tools/clippy/clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -2,7 +2,8 @@\n \n use crate::utils::span_lint;\n use rustc_ast::ast::{Block, ItemKind, StmtKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -53,7 +54,7 @@ declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n \n impl EarlyLintPass for ItemsAfterStatements {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n-        if item.span.from_expansion() {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n \n@@ -67,7 +68,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n         // lint on all further items\n         for stmt in stmts {\n             if let StmtKind::Item(ref it) = *stmt {\n-                if it.span.from_expansion() {\n+                if in_external_macro(cx.sess(), it.span) {\n                     return;\n                 }\n                 if let ItemKind::MacroDef(..) = it.kind {"}, {"sha": "8e2f03d6e4e91641cfd93e22e75f958d10413c03", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -68,7 +68,44 @@ declare_clippy_lint! {\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n }\n \n-declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparing to an empty slice such as \"\" or [],`\n+    /// and suggests using `.is_empty()` where applicable.\n+    ///\n+    /// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+    /// than checking for equality. So it is good to get into the habit of using\n+    /// `.is_empty()`, and having it is cheap.\n+    /// Besides, it makes the intent clearer than a manual comparison in some contexts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// if s == \"\" {\n+    ///     ..\n+    /// }\n+    ///\n+    /// if arr == [] {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```ignore\n+    /// if s.is_empty() {\n+    ///     ..\n+    /// }\n+    ///\n+    /// if arr.is_empty() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub COMPARISON_TO_EMPTY,\n+    style,\n+    \"checking `x == \\\"\\\"` or `x == []` (or similar) when `.is_empty()` could be used instead\"\n+}\n+\n+declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY, COMPARISON_TO_EMPTY]);\n \n impl<'tcx> LateLintPass<'tcx> for LenZero {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -221,6 +258,8 @@ fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>\n         }\n \n         check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to)\n+    } else {\n+        check_empty_expr(cx, span, method, lit, op)\n     }\n }\n \n@@ -258,6 +297,42 @@ fn check_len(\n     }\n }\n \n+fn check_empty_expr(cx: &LateContext<'_>, span: Span, lit1: &Expr<'_>, lit2: &Expr<'_>, op: &str) {\n+    if (is_empty_array(lit2) || is_empty_string(lit2)) && has_is_empty(cx, lit1) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            COMPARISON_TO_EMPTY,\n+            span,\n+            \"comparison to empty slice\",\n+            &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n+            format!(\n+                \"{}{}.is_empty()\",\n+                op,\n+                snippet_with_applicability(cx, lit1.span, \"_\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}\n+\n+fn is_empty_string(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Lit(ref lit) = expr.kind {\n+        if let LitKind::Str(lit, _) = lit.node {\n+            let lit = lit.as_str();\n+            return lit == \"\";\n+        }\n+    }\n+    false\n+}\n+\n+fn is_empty_array(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Array(ref arr) = expr.kind {\n+        return arr.is_empty();\n+    }\n+    false\n+}\n+\n /// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`."}, {"sha": "126852df502eb38465750a851771675fedb648ee", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -176,7 +176,7 @@ mod copies;\n mod copy_iterator;\n mod create_dir;\n mod dbg_macro;\n-mod default_trait_access;\n+mod default;\n mod dereference;\n mod derive;\n mod disallowed_method;\n@@ -234,6 +234,7 @@ mod macro_use;\n mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n+mod manual_ok_or;\n mod manual_strip;\n mod manual_unwrap_or;\n mod map_clone;\n@@ -294,6 +295,7 @@ mod redundant_closure_call;\n mod redundant_field_names;\n mod redundant_pub_crate;\n mod redundant_static_lifetimes;\n+mod ref_option_ref;\n mod reference;\n mod regex;\n mod repeat_once;\n@@ -537,7 +539,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &copy_iterator::COPY_ITERATOR,\n         &create_dir::CREATE_DIR,\n         &dbg_macro::DBG_MACRO,\n-        &default_trait_access::DEFAULT_TRAIT_ACCESS,\n+        &default::DEFAULT_TRAIT_ACCESS,\n+        &default::FIELD_REASSIGN_WITH_DEFAULT,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n         &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -615,6 +618,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_const_arrays::LARGE_CONST_ARRAYS,\n         &large_enum_variant::LARGE_ENUM_VARIANT,\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n+        &len_zero::COMPARISON_TO_EMPTY,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n@@ -649,6 +653,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n+        &manual_ok_or::MANUAL_OK_OR,\n         &manual_strip::MANUAL_STRIP,\n         &manual_unwrap_or::MANUAL_UNWRAP_OR,\n         &map_clone::MAP_CLONE,\n@@ -692,6 +697,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::FILTER_NEXT,\n         &methods::FIND_MAP,\n         &methods::FLAT_MAP_IDENTITY,\n+        &methods::FROM_ITER_INSTEAD_OF_COLLECT,\n         &methods::GET_UNWRAP,\n         &methods::INEFFICIENT_TO_STRING,\n         &methods::INTO_ITER_ON_REF,\n@@ -702,6 +708,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::ITER_NTH_ZERO,\n         &methods::ITER_SKIP_NEXT,\n         &methods::MANUAL_SATURATING_ARITHMETIC,\n+        &methods::MAP_COLLECT_RESULT_UNIT,\n         &methods::MAP_FLATTEN,\n         &methods::MAP_UNWRAP_OR,\n         &methods::NEW_RET_NO_SELF,\n@@ -712,8 +719,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::RESULT_MAP_OR_INTO_OPTION,\n         &methods::SEARCH_IS_SOME,\n         &methods::SHOULD_IMPLEMENT_TRAIT,\n+        &methods::SINGLE_CHAR_ADD_STR,\n         &methods::SINGLE_CHAR_PATTERN,\n-        &methods::SINGLE_CHAR_PUSH_STR,\n         &methods::SKIP_WHILE_NEXT,\n         &methods::STRING_EXTEND_CHARS,\n         &methods::SUSPICIOUS_MAP,\n@@ -807,6 +814,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n+        &ref_option_ref::REF_OPTION_REF,\n         &reference::DEREF_ADDROF,\n         &reference::REF_IN_DEREF,\n         &regex::INVALID_REGEX,\n@@ -1030,6 +1038,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &sess.target,\n     );\n     store.register_late_pass(move || box pass_by_ref_or_value);\n+    store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n     store.register_late_pass(|| box try_err::TryErr);\n     store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n@@ -1047,7 +1056,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n     store.register_late_pass(|| box duration_subsec::DurationSubsec);\n-    store.register_late_pass(|| box default_trait_access::DefaultTraitAccess);\n     store.register_late_pass(|| box indexing_slicing::IndexingSlicing);\n     store.register_late_pass(|| box non_copy_const::NonCopyConst);\n     store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n@@ -1098,6 +1106,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n     store.register_early_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold));\n     store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n+    store.register_late_pass(|| box default::Default::default());\n     store.register_late_pass(|| box unused_self::UnusedSelf);\n     store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n     store.register_late_pass(|| box exit::Exit);\n@@ -1146,6 +1155,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n     store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n+    store.register_late_pass(|| box manual_ok_or::ManualOkOr);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n     store.register_late_pass(|| box manual_strip::ManualStrip);\n@@ -1210,7 +1220,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n-        LintId::of(&default_trait_access::DEFAULT_TRAIT_ACCESS),\n+        LintId::of(&default::DEFAULT_TRAIT_ACCESS),\n         LintId::of(&dereference::EXPLICIT_DEREF_METHODS),\n         LintId::of(&derive::EXPL_IMPL_CLONE_ON_COPY),\n         LintId::of(&derive::UNSAFE_DERIVE_DESERIALIZE),\n@@ -1234,6 +1244,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_INTO_ITER_LOOP),\n         LintId::of(&loops::EXPLICIT_ITER_LOOP),\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n+        LintId::of(&manual_ok_or::MANUAL_OK_OR),\n         LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n@@ -1258,6 +1269,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n+        LintId::of(&ref_option_ref::REF_OPTION_REF),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n@@ -1319,6 +1331,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n+        LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n         LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n@@ -1366,6 +1379,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&int_plus_one::INT_PLUS_ONE),\n         LintId::of(&large_const_arrays::LARGE_CONST_ARRAYS),\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n+        LintId::of(&len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n@@ -1419,6 +1433,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::EXPECT_FUN_CALL),\n         LintId::of(&methods::FILTER_NEXT),\n         LintId::of(&methods::FLAT_MAP_IDENTITY),\n+        LintId::of(&methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITERATOR_STEP_BY_ZERO),\n         LintId::of(&methods::ITER_CLONED_COLLECT),\n@@ -1427,6 +1442,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::ITER_NTH_ZERO),\n         LintId::of(&methods::ITER_SKIP_NEXT),\n         LintId::of(&methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(&methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(&methods::NEW_RET_NO_SELF),\n         LintId::of(&methods::OK_EXPECT),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n@@ -1435,8 +1451,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::RESULT_MAP_OR_INTO_OPTION),\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n+        LintId::of(&methods::SINGLE_CHAR_ADD_STR),\n         LintId::of(&methods::SINGLE_CHAR_PATTERN),\n-        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::SUSPICIOUS_MAP),\n@@ -1577,6 +1593,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n+        LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&enum_variants::ENUM_VARIANT_NAMES),\n@@ -1592,6 +1609,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::RESULT_UNIT_ERR),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n+        LintId::of(&len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n@@ -1615,18 +1633,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n         LintId::of(&methods::CHARS_LAST_CMP),\n         LintId::of(&methods::CHARS_NEXT_CMP),\n+        LintId::of(&methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITER_CLONED_COLLECT),\n         LintId::of(&methods::ITER_NEXT_SLICE),\n         LintId::of(&methods::ITER_NTH_ZERO),\n         LintId::of(&methods::ITER_SKIP_NEXT),\n         LintId::of(&methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(&methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(&methods::NEW_RET_NO_SELF),\n         LintId::of(&methods::OK_EXPECT),\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::RESULT_MAP_OR_INTO_OPTION),\n         LintId::of(&methods::SHOULD_IMPLEMENT_TRAIT),\n-        LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n+        LintId::of(&methods::SINGLE_CHAR_ADD_STR),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n         LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n@@ -1953,6 +1973,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::for_loop_over_result\", \"clippy::for_loops_over_fallibles\");\n     ls.register_renamed(\"clippy::identity_conversion\", \"clippy::useless_conversion\");\n     ls.register_renamed(\"clippy::zero_width_space\", \"clippy::invisible_characters\");\n+    ls.register_renamed(\"clippy::single_char_push_str\", \"clippy::single_char_add_str\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "4d737b3f49b0351e2222fe950807d948e60c2d43", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -16,7 +16,6 @@ use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Symbol};\n-use std::iter::FromIterator;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for lifetime annotations which can be removed by\n@@ -214,14 +213,15 @@ fn could_use_elision<'tcx>(\n     }\n \n     if allowed_lts\n-        .intersection(&FxHashSet::from_iter(\n-            input_visitor\n+        .intersection(\n+            &input_visitor\n                 .nested_elision_site_lts\n                 .iter()\n                 .chain(output_visitor.nested_elision_site_lts.iter())\n                 .cloned()\n-                .filter(|v| matches!(v, RefLt::Named(_))),\n-        ))\n+                .filter(|v| matches!(v, RefLt::Named(_)))\n+                .collect(),\n+        )\n         .next()\n         .is_some()\n     {"}, {"sha": "32c2562ee95b447af8e10e4b07059d717c831b40", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -619,9 +619,9 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n                 }\n \n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.ident.name == sym!(next)\n+                if method_path.ident.name == sym::next\n                     && match_trait_method(cx, match_expr, &paths::ITERATOR)\n-                    && lhs_constructor.ident.name == sym!(Some)\n+                    && lhs_constructor.ident.name == sym::Some\n                     && (pat_args.is_empty()\n                         || !is_refutable(cx, &pat_args[0])\n                             && !is_used_inside(cx, iter_expr, &arms[0].body)\n@@ -985,13 +985,13 @@ fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n         _ => false,\n     };\n \n-    is_slice || is_type_diagnostic_item(cx, ty, sym!(vec_type)) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n }\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n         if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if method.ident.name == sym!(clone);\n+        if method.ident.name == sym::clone;\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n         then { arg } else { expr }\n@@ -1355,7 +1355,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n             if let Some(self_expr) = args.get(0);\n             if let Some(pushed_item) = args.get(1);\n             // Check that the method being called is push() on a Vec\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym!(vec_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n             if path.ident.name.as_str() == \"push\";\n             then {\n                 return Some((self_expr, pushed_item))\n@@ -1736,7 +1736,7 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(arg);\n-    if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOPS_OVER_FALLIBLES,\n@@ -1753,7 +1753,7 @@ fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n                 snippet(cx, arg.span, \"_\")\n             ),\n         );\n-    } else if is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOPS_OVER_FALLIBLES,\n@@ -2186,8 +2186,8 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n-            if (meth.ident.name == sym!(index) && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.ident.name == sym!(index_mut) && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n             then { return }\n         }\n@@ -2333,7 +2333,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     // will allow further borrows afterwards\n     let ty = cx.typeck_results().expr_ty(e);\n     is_iterable_array(ty, cx) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n     is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n     is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n@@ -2890,7 +2890,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n             let ty = cx.typeck_results().node_type(ty.hir_id);\n-            if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                 is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n                 is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {"}, {"sha": "a1450b0d5feaac4ba85e6eba11a5ddd550f39eb3", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,7 +5,7 @@ use rustc_attr as attr;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n@@ -83,9 +83,9 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n     }\n \n     fn is_doc_hidden(attr: &Attribute) -> bool {\n-        attr.has_name(sym!(doc))\n+        attr.has_name(sym::doc)\n             && match attr.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n+                Some(l) => attr::list_contains_name(&l, sym::hidden),\n                 None => false,\n             }\n     }\n@@ -102,7 +102,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n                         let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {\n@@ -154,7 +154,7 @@ fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data:\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n                         let header_span = find_header_span(cx, item, data);\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {"}, {"sha": "c99d2e35b94a6c253f61dd32d3b1caf057b801b7", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,99 @@\n+use crate::utils::{\n+    indent_of, is_type_diagnostic_item, match_qpath, paths, reindent_multiline, snippet_opt, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def, Expr, ExprKind, PatKind, QPath};\n+use rustc_lint::LintContext;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Finds patterns that reimplement `Option::ok_or`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n+    ///\n+    /// let foo: Option<i32> = None;\n+    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.ok_or(\"error\");\n+    /// ```\n+    pub MANUAL_OK_OR,\n+    pedantic,\n+    \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n+}\n+\n+declare_lint_pass!(ManualOkOr => [MANUAL_OK_OR]);\n+\n+impl LateLintPass<'_> for ManualOkOr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'tcx>) {\n+        if in_external_macro(cx.sess(), scrutinee.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_segment, _, args, _) = scrutinee.kind;\n+            if method_segment.ident.name == sym!(map_or);\n+            if args.len() == 3;\n+            let method_receiver = &args[0];\n+            let ty = cx.typeck_results().expr_ty(method_receiver);\n+            if is_type_diagnostic_item(cx, ty, sym!(option_type));\n+            let or_expr = &args[1];\n+            if is_ok_wrapping(cx, &args[2]);\n+            if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;\n+            if match_qpath(err_path, &paths::RESULT_ERR);\n+            if let Some(method_receiver_snippet) = snippet_opt(cx, method_receiver.span);\n+            if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n+            if let Some(indent) = indent_of(cx, scrutinee.span);\n+            then {\n+                let reindented_err_arg_snippet =\n+                    reindent_multiline(err_arg_snippet.into(), true, Some(indent + 4));\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_OK_OR,\n+                    scrutinee.span,\n+                    \"this pattern reimplements `Option::ok_or`\",\n+                    \"replace with\",\n+                    format!(\n+                        \"{}.ok_or({})\",\n+                        method_receiver_snippet,\n+                        reindented_err_arg_snippet\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(ref qpath) = map_expr.kind {\n+        if match_qpath(qpath, &paths::RESULT_OK) {\n+            return true;\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::Closure(_, _, body_id, ..) = map_expr.kind;\n+        let body = cx.tcx.hir().body(body_id);\n+        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n+        if match_qpath(ok_path, &paths::RESULT_OK);\n+        if let ExprKind::Path(QPath::Resolved(_, ok_arg_path)) = ok_arg.kind;\n+        if let def::Res::Local(ok_arg_path_id) = ok_arg_path.res;\n+        then { param_id == ok_arg_path_id } else { false }\n+    }\n+}"}, {"sha": "9e2c6c7f231dafadba929a53f1a9e444aac5f220", "filename": "src/tools/clippy/clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,6 +8,7 @@ use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -97,9 +98,9 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym::option_type) {\n             Some(Case::Option)\n-        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym::result_type) {\n             Some(Case::Result)\n         } else {\n             None"}, {"sha": "034cd99a9be06b072ef7a1e8fdafa8e8a912cf42", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n+            if is_type_diagnostic_item(cx, ty, sym::option_type) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);"}, {"sha": "6b782385a38d29f36e0ef3cfb321f820d4feb5e7", "filename": "src/tools/clippy/clippy_lints/src/map_identity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n@@ -65,8 +66,8 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n         if args.len() == 2 && method.ident.as_str() == \"map\";\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n-            || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n-            || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n+            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n         then {\n             Some(args)\n         } else {"}, {"sha": "e50d11a4d7175a911194ee5ab05bb7c2dce08b77", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -6,6 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `option.map(f)` where f is a function\n@@ -206,9 +207,9 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     let var_arg = &map_args[0];\n \n     let (map_type, variant, lint) =\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(option_type)) {\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::option_type) {\n             (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(result_type)) {\n+        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::result_type) {\n             (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n         } else {\n             return;"}, {"sha": "086dae9422f9b57184af6e39f796377ec285e54d", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `match vec[idx]` or `match vec[n..m]`.\n@@ -90,7 +91,7 @@ fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Opti\n fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     let ty = ty.peel_refs();\n-    is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    is_type_diagnostic_item(cx, ty, sym::vec_type)\n }\n \n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {"}, {"sha": "c6dca54e2509adbbf493114ffebfcff9b244361d", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -662,7 +662,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             }\n         } else {\n             // not a block, don't lint\n-            return; \n+            return;\n         };\n \n         let ty = cx.typeck_results().expr_ty(ex);\n@@ -840,7 +840,7 @@ fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms\n \n fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n+    if is_type_diagnostic_item(cx, ex_ty, sym::result_type) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n@@ -1509,6 +1509,7 @@ mod redundant_pattern_match {\n     use rustc_errors::Applicability;\n     use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n     use rustc_lint::LateContext;\n+    use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n@@ -1552,7 +1553,7 @@ mod redundant_pattern_match {\n         if_chain! {\n             if keyword == \"while\";\n             if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-            if method_path.ident.name == sym!(next);\n+            if method_path.ident.name == sym::next;\n             if match_trait_method(cx, op, &paths::ITERATOR);\n             then {\n                 return;"}, {"sha": "c83b6f2c32963e779ddc52645046c5f27e009415", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n@@ -50,7 +51,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         return true;\n     }\n \n-    if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+    if is_type_diagnostic_item(cx, ty, sym::string_type) {\n         return true;\n     }\n "}, {"sha": "7186656f4e11a6b73f1011c493136678859fe0d5", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 226, "deletions": 77, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -32,8 +32,7 @@ use crate::utils::{\n     is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n     match_trait_method, match_type, match_var, method_calls, method_chain_args, paths, remove_blocks, return_ty,\n     single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth,\n-    SpanlessEq,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1291,8 +1290,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Warns when using `push_str` with a single-character string literal,\n-    /// and `push` with a `char` would work fine.\n+    /// **What it does:** Warns when using `push_str`/`insert_str` with a single-character string literal\n+    /// where `push`/`insert` with a `char` would work fine.\n     ///\n     /// **Why is this bad?** It's less clear that we are pushing a single character.\n     ///\n@@ -1301,16 +1300,18 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let mut string = String::new();\n+    /// string.insert_str(0, \"R\");\n     /// string.push_str(\"R\");\n     /// ```\n     /// Could be written as\n     /// ```rust\n     /// let mut string = String::new();\n+    /// string.insert(0, 'R');\n     /// string.push('R');\n     /// ```\n-    pub SINGLE_CHAR_PUSH_STR,\n+    pub SINGLE_CHAR_ADD_STR,\n     style,\n-    \"`push_str()` used with a single-character string literal as parameter\"\n+    \"`push_str()` or `insert_str()` used with a single-character string literal as parameter\"\n }\n \n declare_clippy_lint! {\n@@ -1349,6 +1350,60 @@ declare_clippy_lint! {\n     \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map(_).collect::<Result<(),_>()`.\n+    ///\n+    /// **Why is this bad?** Using `try_for_each` instead is more readable and idiomatic.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// (0..3).map(|t| Err(t)).collect::<Result<(), _>>();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// (0..3).try_for_each(|t| Err(t));\n+    /// ```\n+    pub MAP_COLLECT_RESULT_UNIT,\n+    style,\n+    \"using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `from_iter()` function calls on types that implement the `FromIterator`\n+    /// trait.\n+    ///\n+    /// **Why is this bad?** It is recommended style to use collect. See\n+    /// [FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::iter::FromIterator;\n+    ///\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v = Vec::from_iter(five_fives);\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v: Vec<i32> = five_fives.collect();\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    pub FROM_ITER_INSTEAD_OF_COLLECT,\n+    style,\n+    \"use `.collect()` instead of `::from_iter()`\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1370,7 +1425,7 @@ declare_lint_pass!(Methods => [\n     INEFFICIENT_TO_STRING,\n     NEW_RET_NO_SELF,\n     SINGLE_CHAR_PATTERN,\n-    SINGLE_CHAR_PUSH_STR,\n+    SINGLE_CHAR_ADD_STR,\n     SEARCH_IS_SOME,\n     FILTER_NEXT,\n     SKIP_WHILE_NEXT,\n@@ -1398,6 +1453,8 @@ declare_lint_pass!(Methods => [\n     FILETYPE_IS_FILE,\n     OPTION_AS_REF_DEREF,\n     UNNECESSARY_LAZY_EVALUATIONS,\n+    MAP_COLLECT_RESULT_UNIT,\n+    FROM_ITER_INSTEAD_OF_COLLECT,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n@@ -1479,10 +1536,18 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\"),\n             [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"get_or_insert\"),\n             [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"ok_or\"),\n+            [\"collect\", \"map\"] => lint_map_collect(cx, expr, arg_lists[1], arg_lists[0]),\n             _ => {},\n         }\n \n         match expr.kind {\n+            hir::ExprKind::Call(ref func, ref args) => {\n+                if let hir::ExprKind::Path(path) = &func.kind {\n+                    if match_qpath(path, &[\"from_iter\"]) {\n+                        lint_from_iter(cx, expr, args);\n+                    }\n+                }\n+            },\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n@@ -1499,6 +1564,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n                         lint_single_char_push_string(cx, expr, args);\n+                    } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n+                        lint_single_char_insert_string(cx, expr, args);\n                     }\n                 }\n \n@@ -1655,7 +1722,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, item.span);\n-            if item.ident.name == sym!(new);\n+            if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id);\n             let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n@@ -1712,7 +1779,7 @@ fn lint_or_fun_call<'tcx>(\n                     \"try this\",\n                     format!(\n                         \"{}.unwrap_or_default()\",\n-                        snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)\n+                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n                     ),\n                     applicability,\n                 );\n@@ -1745,7 +1812,7 @@ fn lint_or_fun_call<'tcx>(\n                     _ => (),\n                 }\n \n-                if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n                     return;\n                 }\n             }\n@@ -1842,11 +1909,11 @@ fn lint_expect_fun_call(\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n                 hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n                     if call_args.len() == 1\n-                        && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n                         }\n                     {\n                         &call_args[0]\n@@ -1864,7 +1931,7 @@ fn lint_expect_fun_call(\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n         let arg_ty = cx.typeck_results().expr_ty(arg);\n-        if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n+        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n             return false;\n         }\n         if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n@@ -1951,9 +2018,9 @@ fn lint_expect_fun_call(\n     }\n \n     let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n         \"||\"\n-    } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n         \"|_|\"\n     } else {\n         return;\n@@ -2119,7 +2186,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"_\");\n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,\n@@ -2140,7 +2207,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\"\n-        } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n+        } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n             \"&\"\n         } else {\n             return;\n@@ -2155,9 +2222,9 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n+                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n                 ref_str,\n-                snippet_with_applicability(cx, target.span, \"_\", &mut applicability)\n+                snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n             ),\n             applicability,\n         );\n@@ -2166,14 +2233,14 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n \n fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n-    if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n+    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n fn lint_iter_cloned_collect<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym!(vec_type));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n         if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n@@ -2326,7 +2393,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n         || matches!(\n             &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n             ty::Array(_, _)\n@@ -2359,7 +2426,7 @@ fn lint_iter_nth<'tcx>(\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n         \"Vec\"\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n         \"VecDeque\"\n@@ -2404,15 +2471,15 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     let mut applicability = Applicability::MachineApplicable;\n     let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n-        snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n+        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n     } else {\n         return; // not linting on a .get().unwrap() chain or variant\n     };\n     let mut needs_ref;\n     let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"Vec\"\n     } else if is_type_diagnostic_item(cx, expr_ty, sym!(vecdeque_type)) {\n@@ -2464,7 +2531,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet_with_applicability(cx, get_args[0].span, \"_\", &mut applicability),\n+            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n             get_args_str\n         ),\n         applicability,\n@@ -2480,7 +2547,7 @@ fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[\n                 cx,\n                 ITER_SKIP_NEXT,\n                 expr.span.trim_start(caller.span).unwrap(),\n-                \"called `skip(x).next()` on an iterator\",\n+                \"called `skip(..).next()` on an iterator\",\n                 \"use `nth` instead\",\n                 hint,\n                 Applicability::MachineApplicable,\n@@ -2498,7 +2565,7 @@ fn derefs_to_slice<'tcx>(\n         match ty.kind() {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n-            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n+            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::vec_type),\n             ty::Array(_, size) => size\n                 .try_eval_usize(cx.tcx, cx.param_env)\n                 .map_or(false, |size| size < 32),\n@@ -2508,7 +2575,7 @@ fn derefs_to_slice<'tcx>(\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym!(iter) && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n+        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -2533,9 +2600,9 @@ fn derefs_to_slice<'tcx>(\n fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n         Some((UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2585,7 +2652,7 @@ fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::E\n fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym!(result_type));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n         let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n@@ -2615,7 +2682,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n                     _ => map_closure_ty.fn_sig(cx.tcx),\n                 };\n                 let map_closure_return_ty = cx.tcx.erase_late_bound_regions(&map_closure_sig.output());\n-                is_type_diagnostic_item(cx, map_closure_return_ty, sym!(option_type))\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n             },\n             _ => false,\n         };\n@@ -2641,7 +2708,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n         let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n@@ -2665,8 +2732,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) -> bool {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2683,11 +2750,11 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n         // lint message\n         let msg = if is_option {\n-            \"called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling \\\n-            `map_or_else(g, f)` instead\"\n+            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n+            `map_or_else(<g>, <f>)` instead\"\n         } else {\n-            \"called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling \\\n-            `.map_or_else(g, f)` instead\"\n+            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n+            `.map_or_else(<g>, <f>)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n@@ -2697,16 +2764,15 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n         if same_span && !multiline {\n-            span_lint_and_note(\n+            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            span_lint_and_sugg(\n                 cx,\n                 MAP_UNWRAP_OR,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\n-                    \"replace `map({0}).unwrap_or_else({1})` with `map_or_else({1}, {0})`\",\n-                    map_snippet, unwrap_snippet,\n-                ),\n+                \"try this\",\n+                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                Applicability::MachineApplicable,\n             );\n             return true;\n         } else if same_span && multiline {\n@@ -2720,8 +2786,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -2753,8 +2819,8 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n         if is_option {\n             let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n-            let msg = \"called `map_or(None, f)` on an `Option` value. This can be done more directly by calling \\\n-                       `and_then(f)` instead\";\n+            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n             (\n                 OPTION_MAP_OR_NONE,\n                 msg,\n@@ -2792,18 +2858,20 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n fn lint_filter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n-                   `.find(p)` instead.\";\n+        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n             // add note if not multi-line\n-            span_lint_and_note(\n+            span_lint_and_sugg(\n                 cx,\n                 FILTER_NEXT,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet),\n+                \"try this\",\n+                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint(cx, FILTER_NEXT, expr.span, msg);\n@@ -2823,9 +2891,9 @@ fn lint_skip_while_next<'tcx>(\n             cx,\n             SKIP_WHILE_NEXT,\n             expr.span,\n-            \"called `skip_while(p).next()` on an `Iterator`\",\n+            \"called `skip_while(<p>).next()` on an `Iterator`\",\n             None,\n-            \"this is more succinctly expressed by calling `.find(!p)` instead\",\n+            \"this is more succinctly expressed by calling `.find(!<p>)` instead\",\n         );\n     }\n }\n@@ -2839,7 +2907,7 @@ fn lint_filter_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `filter(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.filter_map(..)` instead\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n     }\n@@ -2848,17 +2916,19 @@ fn lint_filter_map<'tcx>(\n /// lint use of `filter_map().next()` for `Iterators`\n fn lint_filter_map_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n-                   `.find_map(p)` instead.\";\n+        let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find_map(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            span_lint_and_note(\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            span_lint_and_sugg(\n                 cx,\n                 FILTER_MAP_NEXT,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\"replace `filter_map({0}).next()` with `find_map({0})`\", filter_snippet),\n+                \"try this\",\n+                format!(\"{}.find_map({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint(cx, FILTER_MAP_NEXT, expr.span, msg);\n@@ -2875,7 +2945,7 @@ fn lint_find_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, &map_args[0], &paths::ITERATOR) {\n-        let msg = \"called `find(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `find(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.find_map(..)` instead\";\n         span_lint_and_help(cx, FIND_MAP, expr.span, msg, None, hint);\n     }\n@@ -2890,7 +2960,7 @@ fn lint_filter_map_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by only calling `.filter_map(..)` instead\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n     }\n@@ -2905,7 +2975,7 @@ fn lint_filter_flat_map<'tcx>(\n ) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).flat_map(q)` on an `Iterator`\";\n+        let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n                     and filtering by returning `iter::empty()`\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n@@ -2921,7 +2991,7 @@ fn lint_filter_map_flat_map<'tcx>(\n ) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`\";\n+        let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n                     and filtering by returning `iter::empty()`\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n@@ -3075,7 +3145,7 @@ fn lint_chars_cmp(\n         if arg_char.len() == 1;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym!(Some);\n+        if segment.ident.name == sym::Some;\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -3092,9 +3162,9 @@ fn lint_chars_cmp(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"_\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n                 applicability,\n             );\n \n@@ -3141,7 +3211,7 @@ fn lint_chars_cmp_with_unwrap<'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n                         c),\n                 applicability,\n@@ -3177,7 +3247,7 @@ fn get_hint_if_single_char_arg(\n         if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n         let string = r.as_str();\n-        if string.len() == 1;\n+        if string.chars().count() == 1;\n         then {\n             let snip = snippet_with_applicability(cx, arg.span, &string, applicability);\n             let ch = if let ast::StrStyle::Raw(nhash) = style {\n@@ -3216,11 +3286,12 @@ fn lint_single_char_pattern(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &h\n fn lint_single_char_push_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n     if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n-        let base_string_snippet = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n         let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n         span_lint_and_sugg(\n             cx,\n-            SINGLE_CHAR_PUSH_STR,\n+            SINGLE_CHAR_ADD_STR,\n             expr.span,\n             \"calling `push_str()` using a single-character string literal\",\n             \"consider using `push` with a character literal\",\n@@ -3230,6 +3301,26 @@ fn lint_single_char_push_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args\n     }\n }\n \n+/// lint for length-1 `str`s as argument for `insert_str`\n+fn lint_single_char_insert_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+        let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_ADD_STR,\n+            expr.span,\n+            \"calling `insert_str()` using a single-character string literal\",\n+            \"consider using `insert` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}\n+\n /// Checks for the `USELESS_ASREF` lint.\n fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n@@ -3259,7 +3350,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n                 expr.span,\n                 &format!(\"this call to `{}` does nothing\", call_name),\n                 \"try this\",\n-                snippet_with_applicability(cx, recvr.span, \"_\", &mut applicability).to_string(),\n+                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n                 applicability,\n             );\n         }\n@@ -3350,7 +3441,7 @@ fn lint_option_as_ref_deref<'tcx>(\n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n     let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n-    if !is_type_diagnostic_item(cx, option_ty, sym!(option_type)) {\n+    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n         return;\n     }\n \n@@ -3445,10 +3536,46 @@ fn lint_option_as_ref_deref<'tcx>(\n     }\n }\n \n+fn lint_map_collect(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: &[hir::Expr<'_>],\n+    collect_args: &[hir::Expr<'_>],\n+) {\n+    if_chain! {\n+        // called on Iterator\n+        if let [map_expr] = collect_args;\n+        if match_trait_method(cx, map_expr, &paths::ITERATOR);\n+        // return of collect `Result<(),_>`\n+        let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n+        if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n+        if let ty::Adt(_, substs) = collect_ret_ty.kind();\n+        if let Some(result_t) = substs.types().next();\n+        if result_t.is_unit();\n+        // get parts for snippet\n+        if let [iter, map_fn] = map_args;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_COLLECT_RESULT_UNIT,\n+                expr.span,\n+                \"`.map().collect()` can be replaced with `.try_for_each()`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.try_for_each({})\",\n+                    snippet(cx, iter.span, \"..\"),\n+                    snippet(cx, map_fn.span, \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     match ty.kind() {\n-        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n         _ => None,\n     }\n }\n@@ -3770,6 +3897,28 @@ fn lint_filetype_is_file(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir\n     span_lint_and_help(cx, FILETYPE_IS_FILE, span, &lint_msg, None, &help_msg);\n }\n \n+fn lint_from_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    let from_iter_id = get_trait_def_id(cx, &paths::FROM_ITERATOR).unwrap();\n+    let iter_id = get_trait_def_id(cx, &paths::ITERATOR).unwrap();\n+\n+    if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]) {\n+        // `expr` implements `FromIterator` trait\n+        let iter_expr = snippet(cx, args[0].span, \"..\");\n+        span_lint_and_sugg(\n+            cx,\n+            FROM_ITER_INSTEAD_OF_COLLECT,\n+            expr.span,\n+            \"usage of `FromIterator::from_iter`\",\n+            \"use `.collect()` instead of `::from_iter()`\",\n+            format!(\"{}.collect()\", iter_expr),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n fn fn_header_equals(expected: hir::FnHeader, actual: hir::FnHeader) -> bool {\n     expected.constness == actual.constness\n         && expected.unsafety == actual.unsafety"}, {"sha": "7763fd5f113fa6fa68ba4e59208f15201dfd6bbb", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::{self, HirId, Path};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Symbol};\n \n use super::MAP_UNWRAP_OR;\n \n@@ -20,7 +20,7 @@ pub(super) fn lint<'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n         if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n@@ -53,15 +53,15 @@ pub(super) fn lint<'tcx>(\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"<a>\" };\n         let unwrap_snippet_none = unwrap_snippet == \"None\";\n         let suggest = if unwrap_snippet_none {\n-            \"and_then(f)\"\n+            \"and_then(<f>)\"\n         } else {\n-            \"map_or(a, f)\"\n+            \"map_or(<a>, <f>)\"\n         };\n         let msg = &format!(\n-            \"called `map(f).unwrap_or({})` on an `Option` value. \\\n+            \"called `map(<f>).unwrap_or({})` on an `Option` value. \\\n             This can be done more directly by calling `{}` instead\",\n             arg, suggest\n         );"}, {"sha": "cde89983a2656aff2d0a50eb646b690699a79c6b", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -3,6 +3,7 @@ use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n@@ -14,8 +15,8 @@ pub(super) fn lint<'tcx>(\n     args: &'tcx [hir::Expr<'_>],\n     simplify_using: &str,\n ) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::result_type);\n \n     if is_option || is_result {\n         if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {"}, {"sha": "308e92057b751cecf7f8e2c5f13fb54904c43ec2", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::{\n     StmtKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n@@ -271,13 +272,16 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n         k: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n-        _: Span,\n+        span: Span,\n         _: HirId,\n     ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n         }\n+        if in_external_macro(cx.tcx.sess, span) {\n+            return;\n+        }\n         for arg in iter_input_pats(decl, body) {\n             if let PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..) = arg.pat.kind {\n                 span_lint(\n@@ -293,13 +297,16 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if_chain! {\n+            if !in_external_macro(cx.tcx.sess, stmt.span);\n             if let StmtKind::Local(ref local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(ref init) = local.init;\n             if !higher::is_from_for_desugar(local);\n             then {\n                 if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n-                    let sugg_init = if init.span.from_expansion() {\n+                    // use the macro callsite when the init span (but not the whole local span)\n+                    // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n+                    let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n                         Sugg::hir_with_macro_callsite(cx, init, \"..\")\n                     } else {\n                         Sugg::hir(cx, init, \"..\")\n@@ -310,7 +317,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                         (\"\", sugg_init.addr())\n                     };\n                     let tyopt = if let Some(ref ty) = local.ty {\n-                        format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"_\"))\n+                        format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n                     } else {\n                         String::new()\n                     };\n@@ -326,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                                 \"try\",\n                                 format!(\n                                     \"let {name}{tyopt} = {initref};\",\n-                                    name=snippet(cx, name.span, \"_\"),\n+                                    name=snippet(cx, name.span, \"..\"),\n                                     tyopt=tyopt,\n                                     initref=initref,\n                                 ),"}, {"sha": "009e3d8937e0233e2602ff03c37e7bc5f2311609", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -14,6 +14,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Warns if there is missing doc for any documentable item\n@@ -105,10 +106,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.has_name(sym!(doc))\n+                attr.has_name(sym::doc)\n                     && match attr.meta_item_list() {\n                         None => false,\n-                        Some(l) => attr::list_contains_name(&l[..], sym!(hidden)),\n+                        Some(l) => attr::list_contains_name(&l[..], sym::hidden),\n                     }\n             });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -128,7 +129,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Enum(..) => \"an enum\",\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n-                if it.ident.name == sym!(main) {\n+                if it.ident.name == sym::main {\n                     let def_id = it.hir_id.owner;\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {"}, {"sha": "53abe6086ea411ef5220b9b78e7e75088bf01acf", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_lint::{self, LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** it lints if an exported function, method, trait method with default impl,\n@@ -57,7 +58,7 @@ declare_clippy_lint! {\n }\n \n fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.has_name(sym!(inline)));\n+    let has_inline = attrs.iter().any(|a| a.has_name(sym::inline));\n     if !has_inline {\n         span_lint(\n             cx,"}, {"sha": "405c21d608d978b360b791ca630e6a95dc2a153b", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,6 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -112,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if item.attrs.iter().any(|a| a.has_name(sym!(automatically_derived))) {\n+        if item.attrs.iter().any(|a| a.has_name(sym::automatically_derived)) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "1d0e230c6a7775413e1f62fa29417f8c6e3b9e73", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -13,7 +13,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -204,12 +204,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n                         let deref_span = spans_need_deref.get(&canonical_id);\n                         if_chain! {\n-                            if is_type_diagnostic_item(cx, ty, sym!(vec_type));\n+                            if is_type_diagnostic_item(cx, ty, sym::vec_type);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n                             if let TyKind::Path(QPath::Resolved(_, ref path)) = input.kind;\n                             if let Some(elem_ty) = path.segments.iter()\n-                                .find(|seg| seg.ident.name == sym!(Vec))\n+                                .find(|seg| seg.ident.name == sym::Vec)\n                                 .and_then(|ps| ps.args.as_ref())\n                                 .map(|params| params.args.iter().find_map(|arg| match arg {\n                                     GenericArg::Type(ty) => Some(ty),\n@@ -243,7 +243,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             }\n                         }\n \n-                        if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                        if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                                 diag.span_suggestion(\n@@ -302,7 +302,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n /// Functions marked with these attributes must have the exact signature.\n fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n-        [sym!(proc_macro), sym!(proc_macro_attribute), sym!(proc_macro_derive)]\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n             .iter()\n             .any(|&allow| attr.has_name(allow))\n     })"}, {"sha": "68fdd0eb269ef31af5013d5bee8ef39b8e75bf0c", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n@@ -91,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == sym!(new) && cx.access_levels.is_reachable(id) {\n+                        if sig.decl.inputs.is_empty() && name == sym::new && cx.access_levels.is_reachable(id) {\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if_chain! {"}, {"sha": "485888fa9444f1ae794630b7de64d4c62d94dacf", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,6 +7,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use std::cmp::Ordering;\n \n@@ -384,7 +385,7 @@ impl EarlyLintPass for NonExpressiveNames {\n }\n \n fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n-    if !attrs.iter().any(|attr| attr.has_name(sym!(test))) {\n+    if !attrs.iter().any(|attr| attr.has_name(sym::test)) {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),\n             cx,"}, {"sha": "681dbce97697ece39789b183fb280214f53acbb2", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -66,7 +67,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.to_ident_string() == \"ok\"\n-            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym!(result_type))\n+            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n     } else {\n         false\n     }"}, {"sha": "72dfccc1089e9da4e7484c2a542795b22521db02", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!` or `unreachable!` in a function of type result.\n@@ -40,7 +40,7 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n         hir_id: hir::HirId,\n     ) {\n         if !matches!(fn_kind, FnKind::Closure(_))\n-            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type))\n+            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type)\n         {\n             lint_impl_body(cx, span, body);\n         }"}, {"sha": "ceecc8dbc06fcbcd872ccc2d5d50187e0318e496", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -3,6 +3,7 @@ use if_chain::if_chain;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n@@ -39,7 +40,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {\n                 for impl_item in impl_items {\n-                    if impl_item.ident.name == sym!(ne) {\n+                    if impl_item.ident.name == sym::ne {\n                         span_lint_hir(\n                             cx,\n                             PARTIALEQ_NE_IMPL,"}, {"sha": "030650c3256c09819a066afc7e9d22cb38cc1a67", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutabil\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::Target;\n@@ -230,8 +230,8 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n                 }\n                 for a in attrs {\n                     if let Some(meta_items) = a.meta_item_list() {\n-                        if a.has_name(sym!(proc_macro_derive))\n-                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        if a.has_name(sym::proc_macro_derive)\n+                            || (a.has_name(sym::inline) && attr::list_contains_name(&meta_items, sym::always))\n                         {\n                             return;\n                         }"}, {"sha": "dcb643a28aebcceb0cc2420ccde03a87d851589b", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -15,7 +15,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::MultiSpan;\n+use rustc_span::{sym, MultiSpan};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -181,7 +181,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n         }\n \n         if let ty::Ref(_, ty, Mutability::Not) = ty.kind() {\n-            if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n                     if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n@@ -225,7 +225,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n-            } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                     span_lint_and_then(\n                         cx,"}, {"sha": "e0996804a5934a8ad77c83a30fc363c3452c7e82", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -3,6 +3,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use std::fmt;\n \n declare_clippy_lint! {\n@@ -92,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n     if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n-            if path_segment.ident.name == sym!(offset) {\n+            if path_segment.ident.name == sym::offset {\n                 return Some((&args[0], &args[1], Method::Offset));\n             }\n             if path_segment.ident.name == sym!(wrapping_offset) {"}, {"sha": "d9b280b7a85970115456e222755b198428a5db02", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n@@ -143,7 +144,7 @@ impl QuestionMark {\n     fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.typeck_results().expr_ty(expression);\n \n-        is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n+        is_type_diagnostic_item(cx, expr_ty, sym::option_type)\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {"}, {"sha": "79e9a56af9a196c14a413e9e5094dfae620bd8e5", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,6 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n@@ -304,7 +305,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if_chain! {\n             // `.iter()` call\n             if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n-            if iter_path.ident.name == sym!(iter);\n+            if iter_path.ident.name == sym::iter;\n             // range expression in `.zip()` call: `0..x.len()`\n             if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n             if is_integer_const(cx, start, 0);"}, {"sha": "b4a9804fb25a5a5984356f019f4236ce36a3e643", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n+use rustc_span::sym;\n use std::convert::TryFrom;\n use std::ops::ControlFlow;\n \n@@ -115,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             let from_borrow = match_def_path(cx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n                 || match_def_path(cx, fn_def_id, &paths::TO_OWNED_METHOD)\n                 || (match_def_path(cx, fn_def_id, &paths::TO_STRING_METHOD)\n-                    && is_type_diagnostic_item(cx, arg_ty, sym!(string_type)));\n+                    && is_type_diagnostic_item(cx, arg_ty, sym::string_type));\n \n             let from_deref = !from_borrow\n                 && (match_def_path(cx, fn_def_id, &paths::PATH_TO_PATH_BUF)\n@@ -518,7 +519,10 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 self.possible_borrower.add(borrowed.local, lhs);\n             },\n             other => {\n-                if ContainsRegion.visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty).is_continue() {\n+                if ContainsRegion\n+                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n+                    .is_continue()\n+                {\n                     return;\n                 }\n                 rvalue_locals(other, |rhs| {"}, {"sha": "a914a77d48b4e3a1f1168925a9098d3896edceea", "filename": "src/tools/clippy/clippy_lints/src/ref_option_ref.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,66 @@\n+use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n+use rustc_hir::{GenericArg, Mutability, Ty, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `&Option<&T>`.\n+    ///\n+    /// **Why is this bad?** Since `&` is Copy, it's useless to have a\n+    /// reference on `Option<&T>`.\n+    ///\n+    /// **Known problems:** It may be irrevelent to use this lint on\n+    /// public API code as it will make a breaking change to apply it.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// let x: &Option<&u32> = &Some(&0u32);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let x: Option<&u32> = Some(&0u32);\n+    /// ```\n+    pub REF_OPTION_REF,\n+    pedantic,\n+    \"use `Option<&T>` instead of `&Option<&T>`\"\n+}\n+\n+declare_lint_pass!(RefOptionRef => [REF_OPTION_REF]);\n+\n+impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n+    fn check_ty(&mut self, cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) {\n+        if_chain! {\n+            if let TyKind::Rptr(_, ref mut_ty) = ty.kind;\n+            if mut_ty.mutbl == Mutability::Not;\n+            if let TyKind::Path(ref qpath) = &mut_ty.ty.kind;\n+            let last = last_path_segment(qpath);\n+            if let Some(res) = last.res;\n+            if let Some(def_id) = res.opt_def_id();\n+\n+            if cx.tcx.is_diagnostic_item(sym!(option_type), def_id);\n+            if let Some(ref params) = last_path_segment(qpath).args ;\n+            if !params.parenthesized;\n+            if let Some(inner_ty) = params.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(inner_ty) => Some(inner_ty),\n+                _ => None,\n+            });\n+            if let TyKind::Rptr(_, _) = inner_ty.kind;\n+\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    REF_OPTION_REF,\n+                    ty.span,\n+                    \"since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\",\n+                    \"try\",\n+                    format!(\"Option<{}>\", &snippet(cx, inner_ty.span, \"..\")),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "d34e744eb944cd0631f0bc00b6d55ffdc6b6585c", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,6 +5,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `.repeat(1)` and suggest the following method for each types.\n@@ -65,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n-                } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                     span_lint_and_sugg(\n                         cx,\n                         REPEAT_ONCE,"}, {"sha": "7f4913a02cbd33eda2c73ce45f5f028bcbbd5342", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n@@ -141,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n }\n \n fn attr_is_cfg(attr: &Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+    attr.meta_item_list().is_some() && attr.has_name(sym::cfg)\n }\n \n fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {"}, {"sha": "0dd2da949c4c33e5d8105148abda3f98430465b0", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -4,6 +4,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n \n use if_chain::if_chain;\n \n@@ -154,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym!(string_type))\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::string_type)\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "386987eb181ea9c411c213b5a802f3b058122ded", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual swapping.\n@@ -197,7 +198,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n \n                 if matches!(ty.kind(), ty::Slice(_))\n                     || matches!(ty.kind(), ty::Array(_, _))\n-                    || is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+                    || is_type_diagnostic_item(cx, ty, sym::vec_type)\n                     || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n                 {\n                     return Slice::Swappable(lhs1, idx1, idx2);"}, {"sha": "6f6b6999bf0a9cdbace8ae8e28789bae480fa778", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `Err(x)?`.\n@@ -133,7 +134,7 @@ fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> O\n fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(_, subst) = ty.kind();\n-        if is_type_diagnostic_item(cx, ty, sym!(result_type));\n+        if is_type_diagnostic_item(cx, ty, sym::result_type);\n         let err_ty = subst.type_at(1);\n         then {\n             Some(err_ty)\n@@ -151,7 +152,7 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(result_type), ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::result_type, ready_def.did);\n         let err_ty = ready_subst.type_at(1);\n \n         then {\n@@ -170,11 +171,11 @@ fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) ->\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(option_type), ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::option_type, ready_def.did);\n         let some_ty = ready_subst.type_at(0);\n \n         if let ty::Adt(some_def, some_subst) = some_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(result_type), some_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::result_type, some_def.did);\n         let err_ty = some_subst.type_at(1);\n \n         then {"}, {"sha": "c7d82da3b8ba4c0f38b6fb76a15321487b5e2f1f", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,9 +10,9 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n-    TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n+    ImplItem, ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt,\n+    StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -522,7 +522,7 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                    } else if cx.tcx.is_diagnostic_item(sym!(vec_type), def_id) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n                         if_chain! {\n                             // Get the _ part of Vec<_>\n                             if let Some(ref last) = last_path_segment(qpath).args;\n@@ -559,7 +559,7 @@ impl Types {\n                                 return; // don't recurse into the type\n                             }\n                         }\n-                    } else if cx.tcx.is_diagnostic_item(sym!(option_type), def_id) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n                         if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n                             span_lint(\n                                 cx,\n@@ -678,17 +678,30 @@ impl Types {\n                             // details.\n                             return;\n                         }\n+\n+                        // When trait objects or opaque types have lifetime or auto-trait bounds,\n+                        // we need to add parentheses to avoid a syntax error due to its ambiguity.\n+                        // Originally reported as the issue #3128.\n+                        let inner_snippet = snippet(cx, inner.span, \"..\");\n+                        let suggestion = match &inner.kind {\n+                            TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n+                                format!(\"&{}({})\", ltopt, &inner_snippet)\n+                            },\n+                            TyKind::Path(qpath)\n+                                if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n+                                    .map_or(false, |bounds| bounds.len() > 1) =>\n+                            {\n+                                format!(\"&{}({})\", ltopt, &inner_snippet)\n+                            },\n+                            _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n+                        };\n                         span_lint_and_sugg(\n                             cx,\n                             BORROWED_BOX,\n                             hir_ty.span,\n                             \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n                             \"try\",\n-                            format!(\n-                                \"&{}{}\",\n-                                ltopt,\n-                                &snippet(cx, inner.span, \"..\")\n-                            ),\n+                            suggestion,\n                             // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n                             // because the trait impls of it will break otherwise;\n                             // and there may be other cases that result in invalid code.\n@@ -721,6 +734,21 @@ fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n     false\n }\n \n+fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n+    if_chain! {\n+        if let Some(did) = qpath_res(cx, qpath, id).opt_def_id();\n+        if let Some(node) = cx.tcx.hir().get_if_local(did);\n+        if let Node::GenericParam(generic_param) = node;\n+        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n+        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n+        then {\n+            Some(generic_param.bounds)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for binding a unit value.\n     ///\n@@ -1582,7 +1610,7 @@ fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         if names.is_empty() {\n             return false;\n         }\n-        if names[0] == sym!(libc) || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n+        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n             return true;\n         }\n     }\n@@ -2749,7 +2777,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                 }\n \n                 if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.ident.name == sym!(new) {\n+                    if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n                     } else if method.ident.name == sym!(with_capacity) {\n@@ -2762,7 +2790,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                         );\n                     }\n                 } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.ident.name == sym!(new) {\n+                    if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());\n                     } else if method.ident.name == sym!(with_capacity) {"}, {"sha": "0bccfc156788a5984f2731d994567dc5e408b91d", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegme\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n@@ -175,7 +176,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        if utils::is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym!(vec_type));\n+        if utils::is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym::vec_type);\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},"}, {"sha": "b1339c3d6395de31cb5c56573debb95fdca5806c", "filename": "src/tools/clippy/clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -123,6 +123,17 @@ fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n         fn_source\n             .rfind(\"->\")\n             .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                let mut rpos = rpos;\n+                let chars: Vec<char> = fn_source.chars().collect();\n+                while rpos > 1 {\n+                    if let Some(c) = chars.get(rpos - 1) {\n+                        if c.is_whitespace() {\n+                            rpos -= 1;\n+                            continue;\n+                        }\n+                    }\n+                    break;\n+                }\n                 (\n                     #[allow(clippy::cast_possible_truncation)]\n                     ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),"}, {"sha": "f4a77e54dd149463a866066cfe43467d16a8b117", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n@@ -92,11 +93,11 @@ fn collect_unwrap_info<'tcx>(\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     fn is_relevant_option_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n-        is_type_diagnostic_item(cx, ty, sym!(option_type)) && [\"is_some\", \"is_none\"].contains(&method_name)\n+        is_type_diagnostic_item(cx, ty, sym::option_type) && [\"is_some\", \"is_none\"].contains(&method_name)\n     }\n \n     fn is_relevant_result_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n-        is_type_diagnostic_item(cx, ty, sym!(result_type)) && [\"is_ok\", \"is_err\"].contains(&method_name)\n+        is_type_diagnostic_item(cx, ty, sym::result_type) && [\"is_ok\", \"is_err\"].contains(&method_name)\n     }\n \n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n@@ -168,8 +169,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n             if_chain! {\n                 if let ExprKind::MethodCall(ref method_name, _, ref args, _) = expr.kind;\n                 if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n-                if [sym!(unwrap), sym!(unwrap_err)].contains(&method_name.ident.name);\n-                let call_to_unwrap = method_name.ident.name == sym!(unwrap);\n+                if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n+                let call_to_unwrap = method_name.ident.name == sym::unwrap;\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.ident.res == path.res);\n                 // Span contexts should not differ with the conditional branch"}, {"sha": "fde3102933098415d2aece0bc10df6aac083f302", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for functions of type Result that contain `expect()` or `unwrap()`\n@@ -57,8 +57,8 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n             // first check if it's a method or function\n             if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n             // checking if its return type is `result` or `option`\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(result_type))\n-                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(option_type));\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::result_type)\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::option_type);\n             then {\n                 lint_impl_body(cx, impl_item.span, impl_item);\n             }\n@@ -82,8 +82,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n             let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n             {\n                 self.result.push(expr.span);\n             }\n@@ -92,8 +92,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n             let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n             {\n                 self.result.push(expr.span);\n             }"}, {"sha": "c6194b0c6de3ea74fe4cdd49c76cff1a96e74784", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `Into`, `TryInto`, `From`, `TryFrom`,`IntoIter` calls\n@@ -106,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if_chain! {\n                         let a = cx.typeck_results().expr_ty(e);\n                         let b = cx.typeck_results().expr_ty(&args[0]);\n-                        if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                        if is_type_diagnostic_item(cx, a, sym::result_type);\n                         if let ty::Adt(_, substs) = a.kind();\n                         if let Some(a_type) = substs.types().next();\n                         if TyS::same_type(a_type, b);\n@@ -136,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     then {\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n-                            if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                            if is_type_diagnostic_item(cx, a, sym::result_type);\n                             if let ty::Adt(_, substs) = a.kind();\n                             if let Some(a_type) = substs.types().next();\n                             if TyS::same_type(a_type, b);"}, {"sha": "8b59a9541a736fb8d18da04bd7f523ad4add84e4", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -225,7 +225,7 @@ declare_clippy_lint! {\n     ///\n     /// Good:\n     /// ```rust,ignore\n-    /// utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    /// utils::is_type_diagnostic_item(cx, ty, sym::vec_type)\n     /// ```\n     pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n     internal,\n@@ -724,7 +724,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n                     expr.span,\n                     \"usage of `utils::match_type()` on a type diagnostic item\",\n                     \"try\",\n-                    format!(\"utils::is_type_diagnostic_item({}, {}, sym!({}))\", cx_snippet, ty_snippet, item_name),\n+                    format!(\"utils::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "85e7f055e79de4810ef1322764c9d3dd0e77006b", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -52,6 +52,7 @@ use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n+use rustc_span::sym as rustc_sym;\n use rustc_span::symbol::{self, kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n@@ -974,7 +975,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym!(automatically_derived)))\n+    attrs.iter().any(|attr| attr.has_name(rustc_sym::automatically_derived))\n }\n \n /// Remove blocks around an expression."}, {"sha": "1ad8c6029860b7a0d33037355a261f0915466012", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -44,6 +44,7 @@ pub const FN: [&str; 3] = [\"core\", \"ops\", \"Fn\"];\n pub const FN_MUT: [&str; 3] = [\"core\", \"ops\", \"FnMut\"];\n pub const FN_ONCE: [&str; 3] = [\"core\", \"ops\", \"FnOnce\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n+pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n@@ -52,6 +53,7 @@ pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entr\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n+pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n pub const INTO: [&str; 3] = [\"core\", \"convert\", \"Into\"];\n pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];"}, {"sha": "ff414f748ef97e5b00ed0c359e527022344f0bd3", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -10,8 +10,7 @@ use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Symbol;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span, Symbol};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -224,7 +223,7 @@ impl EarlyLintPass for Write {\n                 .expect(\"path has at least one segment\")\n                 .ident\n                 .name;\n-            if trait_name == sym!(Debug) {\n+            if trait_name == sym::Debug {\n                 self.in_debug_impl = true;\n             }\n         }"}, {"sha": "b1dacfc9c6d28d3428383aa4635447555608bf2d", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -311,7 +311,7 @@ Running our UI test should now produce output that contains the lint message.\n According to [the rustc-dev-guide], the text should be matter of fact and avoid\n capitalization and periods, unless multiple sentences are needed.\n When code or an identifier must appear in a message or label, it should be\n-surrounded with single acute accents \\`.\n+surrounded with single grave accents \\`.\n \n [check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n [diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs"}, {"sha": "702f9d86de62deae4d0650d75df79d07715cc988", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -298,6 +298,13 @@ vec![\n         deprecation: None,\n         module: \"comparison_chain\",\n     },\n+    Lint {\n+        name: \"comparison_to_empty\",\n+        group: \"style\",\n+        desc: \"checking `x == \\\"\\\"` or `x == []` (or similar) when `.is_empty()` could be used instead\",\n+        deprecation: None,\n+        module: \"len_zero\",\n+    },\n     Lint {\n         name: \"copy_iterator\",\n         group: \"pedantic\",\n@@ -352,7 +359,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"checks for literal calls to `Default::default()`\",\n         deprecation: None,\n-        module: \"default_trait_access\",\n+        module: \"default\",\n     },\n     Lint {\n         name: \"deprecated_cfg_attr\",\n@@ -620,6 +627,13 @@ vec![\n         deprecation: None,\n         module: \"fallible_impl_from\",\n     },\n+    Lint {\n+        name: \"field_reassign_with_default\",\n+        group: \"style\",\n+        desc: \"binding initialized with Default should have its fields set in the initializer\",\n+        deprecation: None,\n+        module: \"default\",\n+    },\n     Lint {\n         name: \"filetype_is_file\",\n         group: \"restriction\",\n@@ -746,6 +760,13 @@ vec![\n         deprecation: None,\n         module: \"drop_forget_ref\",\n     },\n+    Lint {\n+        name: \"from_iter_instead_of_collect\",\n+        group: \"style\",\n+        desc: \"use `.collect()` instead of `::from_iter()`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"future_not_send\",\n         group: \"nursery\",\n@@ -1173,6 +1194,13 @@ vec![\n         deprecation: None,\n         module: \"manual_non_exhaustive\",\n     },\n+    Lint {\n+        name: \"manual_ok_or\",\n+        group: \"pedantic\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::ok_or`\",\n+        deprecation: None,\n+        module: \"manual_ok_or\",\n+    },\n     Lint {\n         name: \"manual_range_contains\",\n         group: \"style\",\n@@ -1222,6 +1250,13 @@ vec![\n         deprecation: None,\n         module: \"map_clone\",\n     },\n+    Lint {\n+        name: \"map_collect_result_unit\",\n+        group: \"style\",\n+        desc: \"using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"map_entry\",\n         group: \"perf\",\n@@ -2013,6 +2048,13 @@ vec![\n         deprecation: None,\n         module: \"reference\",\n     },\n+    Lint {\n+        name: \"ref_option_ref\",\n+        group: \"pedantic\",\n+        desc: \"use `Option<&T>` instead of `&Option<&T>`\",\n+        deprecation: None,\n+        module: \"ref_option_ref\",\n+    },\n     Lint {\n         name: \"repeat_once\",\n         group: \"complexity\",\n@@ -2133,16 +2175,16 @@ vec![\n         module: \"non_expressive_names\",\n     },\n     Lint {\n-        name: \"single_char_pattern\",\n-        group: \"perf\",\n-        desc: \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\",\n+        name: \"single_char_add_str\",\n+        group: \"style\",\n+        desc: \"`push_str()` or `insert_str()` used with a single-character string literal as parameter\",\n         deprecation: None,\n         module: \"methods\",\n     },\n     Lint {\n-        name: \"single_char_push_str\",\n-        group: \"style\",\n-        desc: \"`push_str()` used with a single-character string literal as parameter\",\n+        name: \"single_char_pattern\",\n+        group: \"perf\",\n+        desc: \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\",\n         deprecation: None,\n         module: \"methods\",\n     },"}, {"sha": "93303865e178ec0dfb8d24638adfe76ee99c50b3", "filename": "src/tools/clippy/tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -56,3 +56,17 @@ macro_rules! option_env_unwrap_external {\n         option_env!($env).expect($message)\n     };\n }\n+\n+#[macro_export]\n+macro_rules! ref_arg_binding {\n+    () => {\n+        let ref _y = 42;\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! ref_arg_function {\n+    () => {\n+        fn fun_example(ref _x: usize) {}\n+    };\n+}"}, {"sha": "b606f773cfbad1d603b31df22311e3745d02e515", "filename": "src/tools/clippy/tests/ui/borrow_box.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -3,6 +3,8 @@\n #![allow(unused_variables)]\n #![allow(dead_code)]\n \n+use std::fmt::Display;\n+\n pub fn test1(foo: &mut Box<bool>) {\n     // Although this function could be changed to \"&mut bool\",\n     // avoiding the Box, mutable references to boxes are not\n@@ -89,6 +91,20 @@ pub fn test13(boxed_slice: &mut Box<[i32]>) {\n     *boxed_slice = data.into_boxed_slice();\n }\n \n+// The suggestion should include proper parentheses to avoid a syntax error.\n+pub fn test14(_display: &Box<dyn Display>) {}\n+pub fn test15(_display: &Box<dyn Display + Send>) {}\n+pub fn test16<'a>(_display: &'a Box<dyn Display + 'a>) {}\n+\n+pub fn test17(_display: &Box<impl Display>) {}\n+pub fn test18(_display: &Box<impl Display + Send>) {}\n+pub fn test19<'a>(_display: &'a Box<impl Display + 'a>) {}\n+\n+// This exists only to check what happens when parentheses are already present.\n+// Even though the current implementation doesn't put extra parentheses,\n+// it's fine that unnecessary parentheses appear in the future for some reason.\n+pub fn test20(_display: &Box<(dyn Display + Send)>) {}\n+\n fn main() {\n     test1(&mut Box::new(false));\n     test2();"}, {"sha": "3eac32815be3fac2bb13dfa886623da7a91bb85f", "filename": "src/tools/clippy/tests/ui/borrow_box.stderr", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_box.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,5 +1,5 @@\n error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n-  --> $DIR/borrow_box.rs:19:14\n+  --> $DIR/borrow_box.rs:21:14\n    |\n LL |     let foo: &Box<bool>;\n    |              ^^^^^^^^^^ help: try: `&bool`\n@@ -11,16 +11,58 @@ LL | #![deny(clippy::borrowed_box)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n-  --> $DIR/borrow_box.rs:23:10\n+  --> $DIR/borrow_box.rs:25:10\n    |\n LL |     foo: &'a Box<bool>,\n    |          ^^^^^^^^^^^^^ help: try: `&'a bool`\n \n error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n-  --> $DIR/borrow_box.rs:27:17\n+  --> $DIR/borrow_box.rs:29:17\n    |\n LL |     fn test4(a: &Box<bool>);\n    |                 ^^^^^^^^^^ help: try: `&bool`\n \n-error: aborting due to 3 previous errors\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:95:25\n+   |\n+LL | pub fn test14(_display: &Box<dyn Display>) {}\n+   |                         ^^^^^^^^^^^^^^^^^ help: try: `&dyn Display`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:96:25\n+   |\n+LL | pub fn test15(_display: &Box<dyn Display + Send>) {}\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&(dyn Display + Send)`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:97:29\n+   |\n+LL | pub fn test16<'a>(_display: &'a Box<dyn Display + 'a>) {}\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&'a (dyn Display + 'a)`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:99:25\n+   |\n+LL | pub fn test17(_display: &Box<impl Display>) {}\n+   |                         ^^^^^^^^^^^^^^^^^^ help: try: `&impl Display`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:100:25\n+   |\n+LL | pub fn test18(_display: &Box<impl Display + Send>) {}\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&(impl Display + Send)`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:101:29\n+   |\n+LL | pub fn test19<'a>(_display: &'a Box<impl Display + 'a>) {}\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&'a (impl Display + 'a)`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> $DIR/borrow_box.rs:106:25\n+   |\n+LL | pub fn test20(_display: &Box<(dyn Display + Send)>) {}\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&(dyn Display + Send)`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "261024caca761127e98274d241fa6e92d03a8ff3", "filename": "src/tools/clippy/tests/ui/comparison_to_empty.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+\n+#![warn(clippy::comparison_to_empty)]\n+\n+fn main() {\n+    // Disallow comparisons to empty\n+    let s = String::new();\n+    let _ = s.is_empty();\n+    let _ = !s.is_empty();\n+\n+    let v = vec![0];\n+    let _ = v.is_empty();\n+    let _ = !v.is_empty();\n+\n+    // Allow comparisons to non-empty\n+    let s = String::new();\n+    let _ = s == \" \";\n+    let _ = s != \" \";\n+\n+    let v = vec![0];\n+    let _ = v == [0];\n+    let _ = v != [0];\n+}"}, {"sha": "98ddd974951611f19d4e6af4d1b77752036286b4", "filename": "src/tools/clippy/tests/ui/comparison_to_empty.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+\n+#![warn(clippy::comparison_to_empty)]\n+\n+fn main() {\n+    // Disallow comparisons to empty\n+    let s = String::new();\n+    let _ = s == \"\";\n+    let _ = s != \"\";\n+\n+    let v = vec![0];\n+    let _ = v == [];\n+    let _ = v != [];\n+\n+    // Allow comparisons to non-empty\n+    let s = String::new();\n+    let _ = s == \" \";\n+    let _ = s != \" \";\n+\n+    let v = vec![0];\n+    let _ = v == [0];\n+    let _ = v != [0];\n+}"}, {"sha": "f69d6bd5255df81ad45b23b64868537dd6cdb536", "filename": "src/tools/clippy/tests/ui/comparison_to_empty.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcomparison_to_empty.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,28 @@\n+error: comparison to empty slice\n+  --> $DIR/comparison_to_empty.rs:8:13\n+   |\n+LL |     let _ = s == \"\";\n+   |             ^^^^^^^ help: using `is_empty` is clearer and more explicit: `s.is_empty()`\n+   |\n+   = note: `-D clippy::comparison-to-empty` implied by `-D warnings`\n+\n+error: comparison to empty slice\n+  --> $DIR/comparison_to_empty.rs:9:13\n+   |\n+LL |     let _ = s != \"\";\n+   |             ^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!s.is_empty()`\n+\n+error: comparison to empty slice\n+  --> $DIR/comparison_to_empty.rs:12:13\n+   |\n+LL |     let _ = v == [];\n+   |             ^^^^^^^ help: using `is_empty` is clearer and more explicit: `v.is_empty()`\n+\n+error: comparison to empty slice\n+  --> $DIR/comparison_to_empty.rs:13:13\n+   |\n+LL |     let _ = v != [];\n+   |             ^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!v.is_empty()`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c33580ff6ab6aa52182c5527b70523b45904550e", "filename": "src/tools/clippy/tests/ui/crashes/ice-6250.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,16 @@\n+// originally from glacier/fixed/77218.rs\n+// ice while adjusting...\n+\n+pub struct Cache {\n+    data: Vec<i32>,\n+}\n+\n+pub fn list_data(cache: &Cache, key: usize) {\n+    for reference in vec![1, 2, 3] {\n+        if\n+        /* let */\n+        Some(reference) = cache.data.get(key) {\n+            unimplemented!()\n+        }\n+    }\n+}"}, {"sha": "8241dcd8feb7ba1d3a5142a900cc7bcb5ac478d6", "filename": "src/tools/clippy/tests/ui/crashes/ice-6250.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,27 @@\n+error[E0601]: `main` function not found in crate `ice_6250`\n+  --> $DIR/ice-6250.rs:4:1\n+   |\n+LL | / pub struct Cache {\n+LL | |     data: Vec<i32>,\n+LL | | }\n+LL | |\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^ consider adding a `main` function to `$DIR/ice-6250.rs`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ice-6250.rs:12:9\n+   |\n+LL |         Some(reference) = cache.data.get(key) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n+   |\n+help: you might have meant to use pattern matching\n+   |\n+LL |         let Some(reference) = cache.data.get(key) {\n+   |         ^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0601.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "6aa779aaeb3b660a18aaa6acefa9e70790628087", "filename": "src/tools/clippy/tests/ui/crashes/ice-6251.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,6 @@\n+// originally from glacier/fixed/77329.rs\n+// assertion failed: `(left == right) ; different DefIds\n+\n+fn bug<T>() -> impl Iterator<Item = [(); { |x: [u8]| x }]> {\n+    std::iter::empty()\n+}"}, {"sha": "9a7cf4b0919f63bf7ca195bb240852dafd8a6880", "filename": "src/tools/clippy/tests/ui/crashes/ice-6251.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6251.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,43 @@\n+error[E0601]: `main` function not found in crate `ice_6251`\n+  --> $DIR/ice-6251.rs:4:1\n+   |\n+LL | / fn bug<T>() -> impl Iterator<Item = [(); { |x: [u8]| x }]> {\n+LL | |     std::iter::empty()\n+LL | | }\n+   | |_^ consider adding a `main` function to `$DIR/ice-6251.rs`\n+\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/ice-6251.rs:4:45\n+   |\n+LL | fn bug<T>() -> impl Iterator<Item = [(); { |x: [u8]| x }]> {\n+   |                                             ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = help: unsized fn params are gated as an unstable feature\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn bug<T>() -> impl Iterator<Item = [(); { |&x: [u8]| x }]> {\n+   |                                             ^\n+\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/ice-6251.rs:4:54\n+   |\n+LL | fn bug<T>() -> impl Iterator<Item = [(); { |x: [u8]| x }]> {\n+   |                                                      ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ice-6251.rs:4:44\n+   |\n+LL | fn bug<T>() -> impl Iterator<Item = [(); { |x: [u8]| x }]> {\n+   |                                            ^^^^^^^^^^^ expected `usize`, found closure\n+   |\n+   = note: expected type `usize`\n+           found closure `[closure@$DIR/ice-6251.rs:4:44: 4:55]`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0601.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "2e3d9fd1e9240ed097512ca6216325968fa4c078", "filename": "src/tools/clippy/tests/ui/crashes/ice-6252.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,15 @@\n+// originally from glacier fixed/77919.rs\n+// encountered errors resolving bounds after type-checking\n+\n+trait TypeVal<T> {\n+    const VAL: T;\n+}\n+struct Five;\n+struct Multiply<N, M> {\n+    _n: PhantomData,\n+}\n+impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+\n+fn main() {\n+    [1; <Multiply<Five, Five>>::VAL];\n+}"}, {"sha": "440973e24398e15a7299e2a7d758b814b1673a12", "filename": "src/tools/clippy/tests/ui/crashes/ice-6252.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,46 @@\n+error[E0412]: cannot find type `PhantomData` in this scope\n+  --> $DIR/ice-6252.rs:9:9\n+   |\n+LL |     _n: PhantomData,\n+   |         ^^^^^^^^^^^ not found in this scope\n+   |\n+help: consider importing this struct\n+   |\n+LL | use std::marker::PhantomData;\n+   |\n+\n+error[E0412]: cannot find type `VAL` in this scope\n+  --> $DIR/ice-6252.rs:11:63\n+   |\n+LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   |          -                                                    ^^^ not found in this scope\n+   |          |\n+   |          help: you might be missing a type parameter: `, VAL`\n+\n+error[E0046]: not all trait items implemented, missing: `VAL`\n+  --> $DIR/ice-6252.rs:11:1\n+   |\n+LL |     const VAL: T;\n+   |     ------------- `VAL` from trait\n+...\n+LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n+\n+error: any use of this value will cause an error\n+  --> $DIR/ice-6252.rs:5:5\n+   |\n+LL |     const VAL: T;\n+   |     ^^^^^^^^^^^^^ no MIR body is available for DefId(0:5 ~ ice_6252[317d]::TypeVal::VAL)\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ice-6252.rs:14:9\n+   |\n+LL |     [1; <Multiply<Five, Five>>::VAL];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0046, E0080, E0412.\n+For more information about an error, try `rustc --explain E0046`."}, {"sha": "c19eca43884aa41ca412259f971fce4d357504bb", "filename": "src/tools/clippy/tests/ui/crashes/ice-6254.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,15 @@\n+// originally from ./src/test/ui/pattern/usefulness/consts-opaque.rs\n+// panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())',\n+// compiler/rustc_mir_build/src/thir/pattern/_match.rs:2030:5\n+\n+#[derive(PartialEq)]\n+struct Foo(i32);\n+const FOO_REF_REF: &&Foo = &&Foo(42);\n+\n+fn main() {\n+    // This used to cause an ICE (https://github.com/rust-lang/rust/issues/78071)\n+    match FOO_REF_REF {\n+        FOO_REF_REF => {},\n+        Foo(_) => {},\n+    }\n+}"}, {"sha": "95ebf23d81817a9fad386d3d254f5274be17dbef", "filename": "src/tools/clippy/tests/ui/crashes/ice-6254.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6254.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,12 @@\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/ice-6254.rs:12:9\n+   |\n+LL |         FOO_REF_REF => {},\n+   |         ^^^^^^^^^^^\n+   |\n+   = note: `-D indirect-structural-match` implied by `-D warnings`\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error: aborting due to previous error\n+"}, {"sha": "bd4a81d98e2e7c8b5a84e5329a2e2927acc83c18", "filename": "src/tools/clippy/tests/ui/crashes/ice-6255.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,15 @@\n+// originally from rustc ./src/test/ui/macros/issue-78325-inconsistent-resolution.rs\n+// inconsistent resolution for a macro\n+\n+macro_rules! define_other_core {\n+    ( ) => {\n+        extern crate std as core;\n+        //~^ ERROR macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+    };\n+}\n+\n+fn main() {\n+    core::panic!();\n+}\n+\n+define_other_core!();"}, {"sha": "d973ea1e23a259951b14e471c63bbee6f58fa3bf", "filename": "src/tools/clippy/tests/ui/crashes/ice-6255.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6255.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,13 @@\n+error: macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+  --> $DIR/ice-6255.rs:6:9\n+   |\n+LL |         extern crate std as core;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | define_other_core!();\n+   | --------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "6f60d45d68a8ee277123ab8f6a07dff260fe7ee7", "filename": "src/tools/clippy/tests/ui/crashes/ice-6256.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,13 @@\n+// originally from rustc ./src/test/ui/regions/issue-78262.rs\n+// ICE: to get the signature of a closure, use substs.as_closure().sig() not fn_sig()\n+\n+trait TT {}\n+\n+impl dyn TT {\n+    fn func(&self) {}\n+}\n+\n+fn main() {\n+    let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n+                                   //[nll]~^ ERROR: borrowed data escapes outside of closure\n+}"}, {"sha": "0e8353a418a87b002465bb435fe828acc664ebb3", "filename": "src/tools/clippy/tests/ui/crashes/ice-6256.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6256.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ice-6256.rs:11:28\n+   |\n+LL |     let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n+   |                            ^^^^ lifetime mismatch\n+   |\n+   = note: expected reference `&(dyn TT + 'static)`\n+              found reference `&dyn TT`\n+note: the anonymous lifetime #1 defined on the body at 11:13...\n+  --> $DIR/ice-6256.rs:11:13\n+   |\n+LL |     let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "79a30c22f953658269ee94b88de670e4d9f6257a", "filename": "src/tools/clippy/tests/ui/field_reassign_with_default.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,110 @@\n+#![warn(clippy::field_reassign_with_default)]\n+\n+#[derive(Default)]\n+struct A {\n+    i: i32,\n+    j: i64,\n+}\n+\n+struct B {\n+    i: i32,\n+    j: i64,\n+}\n+\n+/// Implements .next() that returns a different number each time.\n+struct SideEffect(i32);\n+\n+impl SideEffect {\n+    fn new() -> SideEffect {\n+        SideEffect(0)\n+    }\n+    fn next(&mut self) -> i32 {\n+        self.0 += 1;\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    // wrong, produces first error in stderr\n+    let mut a: A = Default::default();\n+    a.i = 42;\n+\n+    // right\n+    let mut a: A = Default::default();\n+\n+    // right\n+    let a = A {\n+        i: 42,\n+        ..Default::default()\n+    };\n+\n+    // right\n+    let mut a: A = Default::default();\n+    if a.i == 0 {\n+        a.j = 12;\n+    }\n+\n+    // right\n+    let mut a: A = Default::default();\n+    let b = 5;\n+\n+    // right\n+    let mut b = 32;\n+    let mut a: A = Default::default();\n+    b = 2;\n+\n+    // right\n+    let b: B = B { i: 42, j: 24 };\n+\n+    // right\n+    let mut b: B = B { i: 42, j: 24 };\n+    b.i = 52;\n+\n+    // right\n+    let mut b = B { i: 15, j: 16 };\n+    let mut a: A = Default::default();\n+    b.i = 2;\n+\n+    // wrong, produces second error in stderr\n+    let mut a: A = Default::default();\n+    a.j = 43;\n+    a.i = 42;\n+\n+    // wrong, produces third error in stderr\n+    let mut a: A = Default::default();\n+    a.i = 42;\n+    a.j = 43;\n+    a.j = 44;\n+\n+    // wrong, produces fourth error in stderr\n+    let mut a = A::default();\n+    a.i = 42;\n+\n+    // wrong, but does not produce an error in stderr, because we can't produce a correct kind of\n+    // suggestion with current implementation\n+    let mut c: (i32, i32) = Default::default();\n+    c.0 = 42;\n+    c.1 = 21;\n+\n+    // wrong, produces the fifth error in stderr\n+    let mut a: A = Default::default();\n+    a.i = Default::default();\n+\n+    // wrong, produces the sixth error in stderr\n+    let mut a: A = Default::default();\n+    a.i = Default::default();\n+    a.j = 45;\n+\n+    // right, because an assignment refers to another field\n+    let mut x = A::default();\n+    x.i = 42;\n+    x.j = 21 + x.i as i64;\n+\n+    // right, we bail out if there's a reassignment to the same variable, since there is a risk of\n+    // side-effects affecting the outcome\n+    let mut x = A::default();\n+    let mut side_effect = SideEffect::new();\n+    x.i = side_effect.next();\n+    x.j = 2;\n+    x.i = side_effect.next();\n+}"}, {"sha": "c788ebae5526ce4e397038b07a0dca309067e7a1", "filename": "src/tools/clippy/tests/ui/field_reassign_with_default.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,75 @@\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:30:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+   = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n+note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:29:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:70:5\n+   |\n+LL |     a.j = 43;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { j: 43, i: 42 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:69:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:75:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { i: 42, j: 44 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:74:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:81:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:80:5\n+   |\n+LL |     let mut a = A::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:91:5\n+   |\n+LL |     a.i = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A::default()` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:90:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:95:5\n+   |\n+LL |     a.i = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { j: 45, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:94:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "dbeb2354309c92bb4a66b2288ab2a7ec7ac905e5", "filename": "src/tools/clippy/tests/ui/filter_map_next.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -3,9 +3,6 @@\n fn main() {\n     let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n \n-    let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n-    assert_eq!(element, Some(1));\n-\n     #[rustfmt::skip]\n     let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n         .into_iter()"}, {"sha": "45427684d96e1c058ec0c0a25e31e64ed3af2852", "filename": "src/tools/clippy/tests/ui/filter_map_next.stderr", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,14 +1,5 @@\n-error: called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(p)` instead.\n-  --> $DIR/filter_map_next.rs:6:32\n-   |\n-LL |     let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n-   = note: replace `filter_map(|s| s.parse().ok()).next()` with `find_map(|s| s.parse().ok())`\n-\n-error: called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(p)` instead.\n-  --> $DIR/filter_map_next.rs:10:26\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+  --> $DIR/filter_map_next.rs:7:26\n    |\n LL |       let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n    |  __________________________^\n@@ -19,6 +10,8 @@ LL | |             if x == 2 {\n LL | |         })\n LL | |         .next();\n    | |_______________^\n+   |\n+   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "c3992d7e92cf37c36d0c5568aa3a462bfcd2278b", "filename": "src/tools/clippy/tests/ui/filter_map_next_fixable.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+\n+fn main() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    let element: Option<i32> = a.iter().find_map(|s| s.parse().ok());\n+    assert_eq!(element, Some(1));\n+}"}, {"sha": "447219a96839181630629af538bd834624f0bb51", "filename": "src/tools/clippy/tests/ui/filter_map_next_fixable.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+\n+fn main() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n+    assert_eq!(element, Some(1));\n+}"}, {"sha": "6c2530e0379e4fded306cb600956b395a3affb42", "filename": "src/tools/clippy/tests/ui/filter_map_next_fixable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_map_next_fixable.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,10 @@\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+  --> $DIR/filter_map_next_fixable.rs:8:32\n+   |\n+LL |     let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `a.iter().find_map(|s| s.parse().ok())`\n+   |\n+   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "91718dd11755b75310056c4a60277da2b63e8329", "filename": "src/tools/clippy/tests/ui/filter_methods.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,4 +1,4 @@\n-error: called `filter(p).map(q)` on an `Iterator`\n+error: called `filter(..).map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:5:21\n    |\n LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x * 2).collect();\n@@ -7,7 +7,7 @@ LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x *\n    = note: `-D clippy::filter-map` implied by `-D warnings`\n    = help: this is more succinctly expressed by calling `.filter_map(..)` instead\n \n-error: called `filter(p).flat_map(q)` on an `Iterator`\n+error: called `filter(..).flat_map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:7:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n@@ -19,7 +19,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    |\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n-error: called `filter_map(p).flat_map(q)` on an `Iterator`\n+error: called `filter_map(..).flat_map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:13:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n@@ -31,7 +31,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    |\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n-error: called `filter_map(p).map(q)` on an `Iterator`\n+error: called `filter_map(..).map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:19:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]"}, {"sha": "aea3cc62afcc41631213bbafca089acc6f9b72b5", "filename": "src/tools/clippy/tests/ui/find_map.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,4 +1,4 @@\n-error: called `find(p).map(q)` on an `Iterator`\n+error: called `find(..).map(..)` on an `Iterator`\n   --> $DIR/find_map.rs:20:26\n    |\n LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n@@ -7,7 +7,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = note: `-D clippy::find-map` implied by `-D warnings`\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n-error: called `find(p).map(q)` on an `Iterator`\n+error: called `find(..).map(..)` on an `Iterator`\n   --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week"}, {"sha": "045eb3133d3c4b87539a17fe0aa49559e7318126", "filename": "src/tools/clippy/tests/ui/from_iter_instead_of_collect.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,13 @@\n+#![warn(clippy::from_iter_instead_of_collect)]\n+\n+use std::collections::HashMap;\n+use std::iter::FromIterator;\n+\n+fn main() {\n+    let iter_expr = std::iter::repeat(5).take(5);\n+    Vec::from_iter(iter_expr);\n+\n+    HashMap::<usize, &i8>::from_iter(vec![5, 5, 5, 5].iter().enumerate());\n+\n+    Vec::from_iter(vec![42u32]);\n+}"}, {"sha": "46bdc2f4e199b34cf645f1cb4f108919a70a6f9c", "filename": "src/tools/clippy/tests/ui/from_iter_instead_of_collect.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_iter_instead_of_collect.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,16 @@\n+error: usage of `FromIterator::from_iter`\n+  --> $DIR/from_iter_instead_of_collect.rs:8:5\n+   |\n+LL |     Vec::from_iter(iter_expr);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `iter_expr.collect()`\n+   |\n+   = note: `-D clippy::from-iter-instead-of-collect` implied by `-D warnings`\n+\n+error: usage of `FromIterator::from_iter`\n+  --> $DIR/from_iter_instead_of_collect.rs:10:5\n+   |\n+LL |     HashMap::<usize, &i8>::from_iter(vec![5, 5, 5, 5].iter().enumerate());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `vec![5, 5, 5, 5].iter().enumerate().collect()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "924c02a4054d4022ef54225853514053b1b59980", "filename": "src/tools/clippy/tests/ui/get_unwrap.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused_mut)]\n+#![allow(unused_mut, clippy::from_iter_instead_of_collect)]\n #![deny(clippy::get_unwrap)]\n \n use std::collections::BTreeMap;"}, {"sha": "c0c37bb7206631e48334b79ac731c178f25dde72", "filename": "src/tools/clippy/tests/ui/get_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused_mut)]\n+#![allow(unused_mut, clippy::from_iter_instead_of_collect)]\n #![deny(clippy::get_unwrap)]\n \n use std::collections::BTreeMap;"}, {"sha": "b74c93dc4a666d445b8b324de3c32b4f9c641515", "filename": "src/tools/clippy/tests/ui/integer_arithmetic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -11,6 +11,8 @@\n #[rustfmt::skip]\n fn main() {\n     let mut i = 1i32;\n+    let mut var1 = 0i32;\n+    let mut var2 = -1i32;\n     1 + i;\n     i * 2;\n     1 %\n@@ -32,7 +34,15 @@ fn main() {\n     i -= 1;\n     i *= 2;\n     i /= 2;\n+    i /= 0;\n+    i /= -1;\n+    i /= var1;\n+    i /= var2;\n     i %= 2;\n+    i %= 0;\n+    i %= -1;\n+    i %= var1;\n+    i %= var2;\n     i <<= 3;\n     i >>= 2;\n "}, {"sha": "add3b6b90fa26108cb534a9f93e11cc8b167582c", "filename": "src/tools/clippy/tests/ui/integer_arithmetic.stderr", "status": "modified", "additions": 65, "deletions": 27, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,131 +1,169 @@\n+error: this operation will panic at runtime\n+  --> $DIR/integer_arithmetic.rs:37:5\n+   |\n+LL |     i /= 0;\n+   |     ^^^^^^ attempt to divide `_` by zero\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: this operation will panic at runtime\n+  --> $DIR/integer_arithmetic.rs:42:5\n+   |\n+LL |     i %= 0;\n+   |     ^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n+\n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:14:5\n+  --> $DIR/integer_arithmetic.rs:16:5\n    |\n LL |     1 + i;\n    |     ^^^^^\n    |\n    = note: `-D clippy::integer-arithmetic` implied by `-D warnings`\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:15:5\n+  --> $DIR/integer_arithmetic.rs:17:5\n    |\n LL |     i * 2;\n    |     ^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:16:5\n+  --> $DIR/integer_arithmetic.rs:18:5\n    |\n LL | /     1 %\n LL | |     i / 2; // no error, this is part of the expression in the preceding line\n-   | |_________^\n+   | |_____^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:18:5\n+  --> $DIR/integer_arithmetic.rs:20:5\n    |\n LL |     i - 2 + 2 - i;\n    |     ^^^^^^^^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:19:5\n+  --> $DIR/integer_arithmetic.rs:21:5\n    |\n LL |     -i;\n    |     ^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:20:5\n+  --> $DIR/integer_arithmetic.rs:22:5\n    |\n LL |     i >> 1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:21:5\n+  --> $DIR/integer_arithmetic.rs:23:5\n    |\n LL |     i << 1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:31:5\n+  --> $DIR/integer_arithmetic.rs:33:5\n    |\n LL |     i += 1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:32:5\n+  --> $DIR/integer_arithmetic.rs:34:5\n    |\n LL |     i -= 1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:33:5\n+  --> $DIR/integer_arithmetic.rs:35:5\n    |\n LL |     i *= 2;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:34:5\n+  --> $DIR/integer_arithmetic.rs:38:11\n    |\n-LL |     i /= 2;\n-   |     ^^^^^^\n+LL |     i /= -1;\n+   |           ^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:35:5\n+  --> $DIR/integer_arithmetic.rs:39:5\n    |\n-LL |     i %= 2;\n-   |     ^^^^^^\n+LL |     i /= var1;\n+   |     ^^^^^^^^^\n+\n+error: integer arithmetic detected\n+  --> $DIR/integer_arithmetic.rs:40:5\n+   |\n+LL |     i /= var2;\n+   |     ^^^^^^^^^\n+\n+error: integer arithmetic detected\n+  --> $DIR/integer_arithmetic.rs:43:11\n+   |\n+LL |     i %= -1;\n+   |           ^\n+\n+error: integer arithmetic detected\n+  --> $DIR/integer_arithmetic.rs:44:5\n+   |\n+LL |     i %= var1;\n+   |     ^^^^^^^^^\n+\n+error: integer arithmetic detected\n+  --> $DIR/integer_arithmetic.rs:45:5\n+   |\n+LL |     i %= var2;\n+   |     ^^^^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:36:5\n+  --> $DIR/integer_arithmetic.rs:46:5\n    |\n LL |     i <<= 3;\n    |     ^^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:37:5\n+  --> $DIR/integer_arithmetic.rs:47:5\n    |\n LL |     i >>= 2;\n    |     ^^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:79:5\n+  --> $DIR/integer_arithmetic.rs:89:5\n    |\n LL |     3 + &1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:80:5\n+  --> $DIR/integer_arithmetic.rs:90:5\n    |\n LL |     &3 + 1;\n    |     ^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:81:5\n+  --> $DIR/integer_arithmetic.rs:91:5\n    |\n LL |     &3 + &1;\n    |     ^^^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:86:5\n+  --> $DIR/integer_arithmetic.rs:96:5\n    |\n LL |     a + x\n    |     ^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:90:5\n+  --> $DIR/integer_arithmetic.rs:100:5\n    |\n LL |     x + y\n    |     ^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:94:5\n+  --> $DIR/integer_arithmetic.rs:104:5\n    |\n LL |     x + y\n    |     ^^^^^\n \n error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:98:5\n+  --> $DIR/integer_arithmetic.rs:108:5\n    |\n LL |     (&x + &y)\n    |     ^^^^^^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 27 previous errors\n "}, {"sha": "377e58e44174977a5e4bdbea2257ada3d4946633", "filename": "src/tools/clippy/tests/ui/item_after_statement.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -28,7 +28,10 @@ fn mac() {\n     // do not lint this, because it needs to be after `a`\n     macro_rules! b {\n         () => {{\n-            a = 6\n+            a = 6;\n+            fn say_something() {\n+                println!(\"something\");\n+            }\n         }};\n     }\n     b!();"}, {"sha": "68a3c81b6a804e7f25a23e454a171b7ef494c401", "filename": "src/tools/clippy/tests/ui/item_after_statement.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitem_after_statement.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -16,5 +16,18 @@ LL | |         println!(\"foo\");\n LL | |     }\n    | |_____^\n \n-error: aborting due to 2 previous errors\n+error: adding items after statements is confusing, since items exist from the start of the scope\n+  --> $DIR/item_after_statement.rs:32:13\n+   |\n+LL | /             fn say_something() {\n+LL | |                 println!(\"something\");\n+LL | |             }\n+   | |_____________^\n+...\n+LL |       b!();\n+   |       ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "486de718bb563f9064338396bf07f16d1e7c7bfd", "filename": "src/tools/clippy/tests/ui/iter_skip_next.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_skip_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_skip_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_skip_next.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,24 +1,24 @@\n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:15:28\n    |\n LL |     let _ = some_vec.iter().skip(42).next();\n    |                            ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n    |\n    = note: `-D clippy::iter-skip-next` implied by `-D warnings`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:16:36\n    |\n LL |     let _ = some_vec.iter().cycle().skip(42).next();\n    |                                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:17:20\n    |\n LL |     let _ = (1..10).skip(10).next();\n    |                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(10)`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:18:33\n    |\n LL |     let _ = &some_vec[..].iter().skip(3).next();"}, {"sha": "b42e94bd727de9fa998f54bdb83d099ebf4401a9", "filename": "src/tools/clippy/tests/ui/manual_ok_or.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+#![warn(clippy::manual_ok_or)]\n+#![allow(clippy::blacklisted_name)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(dead_code)]\n+#![allow(unused_must_use)]\n+\n+fn main() {\n+    // basic case\n+    let foo: Option<i32> = None;\n+    foo.ok_or(\"error\");\n+\n+    // eta expansion case\n+    foo.ok_or(\"error\");\n+\n+    // turbo fish syntax\n+    None::<i32>.ok_or(\"error\");\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    foo.ok_or(&format!(\n+        \"{}{}{}{}{}{}{}\",\n+        \"Alice\", \"Bob\", \"Sarah\", \"Marc\", \"Sandra\", \"Eric\", \"Jenifer\"));\n+\n+    // not applicable, closure isn't direct `Ok` wrapping\n+    foo.map_or(Err(\"error\"), |v| Ok(v + 1));\n+\n+    // not applicable, or side isn't `Result::Err`\n+    foo.map_or(Ok::<i32, &str>(1), |v| Ok(v));\n+\n+    // not applicatble, expr is not a `Result` value\n+    foo.map_or(42, |v| v);\n+\n+    // TODO patterns not covered yet\n+    match foo {\n+        Some(v) => Ok(v),\n+        None => Err(\"error\"),\n+    };\n+    foo.map_or_else(|| Err(\"error\"), |v| Ok(v));\n+}"}, {"sha": "e5a6056fbf5cc40ba9cb089d663e1ca81b3186db", "filename": "src/tools/clippy/tests/ui/manual_ok_or.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,44 @@\n+// run-rustfix\n+#![warn(clippy::manual_ok_or)]\n+#![allow(clippy::blacklisted_name)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(dead_code)]\n+#![allow(unused_must_use)]\n+\n+fn main() {\n+    // basic case\n+    let foo: Option<i32> = None;\n+    foo.map_or(Err(\"error\"), |v| Ok(v));\n+\n+    // eta expansion case\n+    foo.map_or(Err(\"error\"), Ok);\n+\n+    // turbo fish syntax\n+    None::<i32>.map_or(Err(\"error\"), |v| Ok(v));\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    foo.map_or(Err::<i32, &str>(\n+        &format!(\n+            \"{}{}{}{}{}{}{}\",\n+            \"Alice\", \"Bob\", \"Sarah\", \"Marc\", \"Sandra\", \"Eric\", \"Jenifer\")\n+        ),\n+        |v| Ok(v),\n+    );\n+\n+    // not applicable, closure isn't direct `Ok` wrapping\n+    foo.map_or(Err(\"error\"), |v| Ok(v + 1));\n+\n+    // not applicable, or side isn't `Result::Err`\n+    foo.map_or(Ok::<i32, &str>(1), |v| Ok(v));\n+\n+    // not applicatble, expr is not a `Result` value\n+    foo.map_or(42, |v| v);\n+\n+    // TODO patterns not covered yet\n+    match foo {\n+        Some(v) => Ok(v),\n+        None => Err(\"error\"),\n+    };\n+    foo.map_or_else(|| Err(\"error\"), |v| Ok(v));\n+}"}, {"sha": "8ea10ac54363660225df1216d7435f3c756630f1", "filename": "src/tools/clippy/tests/ui/manual_ok_or.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_ok_or.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,41 @@\n+error: this pattern reimplements `Option::ok_or`\n+  --> $DIR/manual_ok_or.rs:11:5\n+   |\n+LL |     foo.map_or(Err(\"error\"), |v| Ok(v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `foo.ok_or(\"error\")`\n+   |\n+   = note: `-D clippy::manual-ok-or` implied by `-D warnings`\n+\n+error: this pattern reimplements `Option::ok_or`\n+  --> $DIR/manual_ok_or.rs:14:5\n+   |\n+LL |     foo.map_or(Err(\"error\"), Ok);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `foo.ok_or(\"error\")`\n+\n+error: this pattern reimplements `Option::ok_or`\n+  --> $DIR/manual_ok_or.rs:17:5\n+   |\n+LL |     None::<i32>.map_or(Err(\"error\"), |v| Ok(v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `None::<i32>.ok_or(\"error\")`\n+\n+error: this pattern reimplements `Option::ok_or`\n+  --> $DIR/manual_ok_or.rs:21:5\n+   |\n+LL | /     foo.map_or(Err::<i32, &str>(\n+LL | |         &format!(\n+LL | |             \"{}{}{}{}{}{}{}\",\n+LL | |             \"Alice\", \"Bob\", \"Sarah\", \"Marc\", \"Sandra\", \"Eric\", \"Jenifer\")\n+LL | |         ),\n+LL | |         |v| Ok(v),\n+LL | |     );\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     foo.ok_or(&format!(\n+LL |         \"{}{}{}{}{}{}{}\",\n+LL |         \"Alice\", \"Bob\", \"Sarah\", \"Marc\", \"Sandra\", \"Eric\", \"Jenifer\"));\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e66c9cc24207ade95d7984e6b48d1acf78091e02", "filename": "src/tools/clippy/tests/ui/map_collect_result_unit.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::map_collect_result_unit)]\n+\n+fn main() {\n+    {\n+        let _ = (0..3).try_for_each(|t| Err(t + 1));\n+        let _: Result<(), _> = (0..3).try_for_each(|t| Err(t + 1));\n+\n+        let _ = (0..3).try_for_each(|t| Err(t + 1));\n+    }\n+}\n+\n+fn _ignore() {\n+    let _ = (0..3).map(|t| Err(t + 1)).collect::<Result<Vec<i32>, _>>();\n+    let _ = (0..3).map(|t| Err(t + 1)).collect::<Vec<Result<(), _>>>();\n+}"}, {"sha": "6f08f4c3c53549c76e449f7947666ac48abbc6bf", "filename": "src/tools/clippy/tests/ui/map_collect_result_unit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::map_collect_result_unit)]\n+\n+fn main() {\n+    {\n+        let _ = (0..3).map(|t| Err(t + 1)).collect::<Result<(), _>>();\n+        let _: Result<(), _> = (0..3).map(|t| Err(t + 1)).collect();\n+\n+        let _ = (0..3).try_for_each(|t| Err(t + 1));\n+    }\n+}\n+\n+fn _ignore() {\n+    let _ = (0..3).map(|t| Err(t + 1)).collect::<Result<Vec<i32>, _>>();\n+    let _ = (0..3).map(|t| Err(t + 1)).collect::<Vec<Result<(), _>>>();\n+}"}, {"sha": "8b06e13baa6b4f29eba699643a9b1a984af20068", "filename": "src/tools/clippy/tests/ui/map_collect_result_unit.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_collect_result_unit.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,16 @@\n+error: `.map().collect()` can be replaced with `.try_for_each()`\n+  --> $DIR/map_collect_result_unit.rs:6:17\n+   |\n+LL |         let _ = (0..3).map(|t| Err(t + 1)).collect::<Result<(), _>>();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(0..3).try_for_each(|t| Err(t + 1))`\n+   |\n+   = note: `-D clippy::map-collect-result-unit` implied by `-D warnings`\n+\n+error: `.map().collect()` can be replaced with `.try_for_each()`\n+  --> $DIR/map_collect_result_unit.rs:7:32\n+   |\n+LL |         let _: Result<(), _> = (0..3).map(|t| Err(t + 1)).collect();\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(0..3).try_for_each(|t| Err(t + 1))`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "87e16f5d09bd75b03786b26e07b6a225510decd9", "filename": "src/tools/clippy/tests/ui/map_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,4 +1,3 @@\n-// FIXME: Add \"run-rustfix\" once it's supported for multipart suggestions\n // aux-build:option_helpers.rs\n \n #![warn(clippy::map_unwrap_or)]\n@@ -47,10 +46,6 @@ fn option_methods() {\n     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n \n     // Check for `option.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = opt.map(|x| x + 1)\n-        // Should lint even though this call is on a separate line.\n-        .unwrap_or_else(|| 0);\n     // Multi-line cases.\n     let _ = opt.map(|x| {\n         x + 1\n@@ -60,37 +55,24 @@ fn option_methods() {\n         .unwrap_or_else(||\n             0\n         );\n-    // Macro case.\n-    // Should not lint.\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n-\n-    // Issue #4144\n-    {\n-        let mut frequencies = HashMap::new();\n-        let word = \"foo\";\n-\n-        frequencies\n-            .get_mut(word)\n-            .map(|count| {\n-                *count += 1;\n-            })\n-            .unwrap_or_else(|| {\n-                frequencies.insert(word.to_owned(), 1);\n-            });\n-    }\n }\n \n+#[rustfmt::skip]\n fn result_methods() {\n     let res: Result<i32, ()> = Ok(1);\n \n     // Check for `result.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-                                                      // multi line cases\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    // multi line cases\n+    let _ = res.map(|x| {\n+        x + 1\n+    }\n+    ).unwrap_or_else(|_e| 0);\n+    let _ = res.map(|x| x + 1)\n+        .unwrap_or_else(|_e| {\n+            0\n+        });\n     // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n }\n \n fn main() {"}, {"sha": "96b9d6cc3c14519aed1cb04cdf5d9c941a797deb", "filename": "src/tools/clippy/tests/ui/map_unwrap_or.stderr", "status": "modified", "additions": 42, "deletions": 57, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,5 +1,5 @@\n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:17:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:16:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -8,13 +8,13 @@ LL | |         .unwrap_or(0);\n    | |_____________________^\n    |\n    = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| x + 1);\n    |                 ^^^^^^ ^^          --\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:21:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:20:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -23,16 +23,16 @@ LL | |     }\n LL | |     ).unwrap_or(0);\n    | |__________________^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| {\n LL |         x + 1\n LL |     }\n LL |     );\n    |\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:25:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:24:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -41,26 +41,26 @@ LL | |             0\n LL | |         });\n    | |__________^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or({\n LL |             0\n LL |         }, |x| x + 1);\n    |\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:30:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:29:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |     let _ = opt.and_then(|x| Some(x + 1));\n    |                 ^^^^^^^^                --\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:32:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:31:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,52 +69,41 @@ LL | |     }\n LL | |     ).unwrap_or(None);\n    | |_____________________^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |     let _ = opt.and_then(|x| {\n LL |         Some(x + 1)\n LL |     }\n LL |     );\n    |\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:36:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:35:13\n    |\n LL |       let _ = opt\n    |  _____________^\n LL | |         .map(|x| Some(x + 1))\n LL | |         .unwrap_or(None);\n    | |________________________^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |         .and_then(|x| Some(x + 1));\n    |          ^^^^^^^^                --\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:47:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:46:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = Some(\"prefix\").map_or(id, |p| format!(\"{}.\", p));\n    |                            ^^^^^^ ^^^                      --\n \n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:51:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |         // Should lint even though this call is on a separate line.\n-LL | |         .unwrap_or_else(|| 0);\n-   | |_____________________________^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:55:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:50:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -123,8 +112,8 @@ LL | |     }\n LL | |     ).unwrap_or_else(|| 0);\n    | |__________________________^\n \n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:59:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:54:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -133,29 +122,25 @@ LL | |             0\n LL | |         );\n    | |_________^\n \n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:88:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:66:13\n    |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:90:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+LL |       let _ = res.map(|x| {\n+   |  _____________^\n+LL | |         x + 1\n+LL | |     }\n+LL | |     ).unwrap_or_else(|_e| 0);\n+   | |____________________________^\n \n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:91:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:70:13\n    |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |         .unwrap_or_else(|_e| {\n+LL | |             0\n+LL | |         });\n+   | |__________^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "bd5b4f7165a4e65396224e927a5b10b3e99bb2ca", "filename": "src/tools/clippy/tests/ui/map_unwrap_or_fixable.fixed", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,54 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map_or_else(|| 0, |x| x + 1);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map_or_else(|_e| 0, |x| x + 1);\n+\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "0b892caf20e82a41d6c9c4f245af09ff647da0d2", "filename": "src/tools/clippy/tests/ui/map_unwrap_or_fixable.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or_else(|| 0);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map(|x| x + 1)\n+        // should lint even though this call is on a separate line\n+        .unwrap_or_else(|_e| 0);\n+\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "1837bc2ca3b8b393526be48f827c18029dca064c", "filename": "src/tools/clippy/tests/ui/map_unwrap_or_fixable.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_unwrap_or_fixable.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,22 @@\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_fixable.rs:17:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or_else(|| 0);\n+   | |_____________________________^ help: try this: `opt.map_or_else(|| 0, |x| x + 1)`\n+   |\n+   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_fixable.rs:47:13\n+   |\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // should lint even though this call is on a separate line\n+LL | |         .unwrap_or_else(|_e| 0);\n+   | |_______________________________^ help: try this: `res.map_or_else(|_e| 0, |x| x + 1)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "82465dbaf6ecc9d9e61b5f99e25f62948da7ebc7", "filename": "src/tools/clippy/tests/ui/match_type_on_diag_item.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_type_on_diag_item.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -2,7 +2,7 @@ error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:41:17\n    |\n LL |         let _ = match_type(cx, ty, &paths::VEC);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::vec_type)`\n    |\n note: the lint level is defined here\n   --> $DIR/match_type_on_diag_item.rs:1:9\n@@ -15,19 +15,19 @@ error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:42:17\n    |\n LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(option_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::option_type)`\n \n error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:43:17\n    |\n LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(result_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::result_type)`\n \n error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:46:17\n    |\n LL |         let _ = utils::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(Rc))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::Rc)`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d93e5b114ecfa7a8933431848efc8a8543f442d8", "filename": "src/tools/clippy/tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -122,16 +122,13 @@ impl Mul<T> for T {\n fn filter_next() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n-    // Single-line case.\n-    let _ = v.iter().filter(|&x| *x < 0).next();\n-\n     // Multi-line case.\n     let _ = v.iter().filter(|&x| {\n                                 *x < 0\n                             }\n                    ).next();\n \n-    // Check that hat we don't lint if the caller is not an `Iterator`.\n+    // Check that we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.filter().next();\n }"}, {"sha": "8a281c2dbd25c2ec3feee082f9735bf89dff00f4", "filename": "src/tools/clippy/tests/ui/methods.stderr", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -8,53 +8,46 @@ LL | |     }\n    |\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n-error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n   --> $DIR/methods.rs:126:13\n    |\n-LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::filter-next` implied by `-D warnings`\n-   = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n-\n-error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:129:13\n-   |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n LL | |                                 *x < 0\n LL | |                             }\n LL | |                    ).next();\n    | |___________________________^\n+   |\n+   = note: `-D clippy::filter-next` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:146:22\n+  --> $DIR/methods.rs:143:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:147:20\n+  --> $DIR/methods.rs:144:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:148:20\n+  --> $DIR/methods.rs:145:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:149:22\n+  --> $DIR/methods.rs:146:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:152:13\n+  --> $DIR/methods.rs:149:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -64,13 +57,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:158:22\n+  --> $DIR/methods.rs:155:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:161:13\n+  --> $DIR/methods.rs:158:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -80,13 +73,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:167:22\n+  --> $DIR/methods.rs:164:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:170:13\n+  --> $DIR/methods.rs:167:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -95,5 +88,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "ee7c1b0da6d979cb7d0213574864d4d0833ab2b9", "filename": "src/tools/clippy/tests/ui/methods_fixable.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+\n+#![warn(clippy::filter_next)]\n+\n+/// Checks implementation of `FILTER_NEXT` lint.\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // Single-line case.\n+    let _ = v.iter().find(|&x| *x < 0);\n+}"}, {"sha": "6d0f1b7bd5147beed87737827d520e45827c7638", "filename": "src/tools/clippy/tests/ui/methods_fixable.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+\n+#![warn(clippy::filter_next)]\n+\n+/// Checks implementation of `FILTER_NEXT` lint.\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // Single-line case.\n+    let _ = v.iter().filter(|&x| *x < 0).next();\n+}"}, {"sha": "70e7c3dea545bbeff7c3f78e4555fd0f2aee8822", "filename": "src/tools/clippy/tests/ui/methods_fixable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods_fixable.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,10 @@\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n+  --> $DIR/methods_fixable.rs:10:13\n+   |\n+LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `v.iter().find(|&x| *x < 0)`\n+   |\n+   = note: `-D clippy::filter-next` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "47e7460fa7a44d4a11f38119d9c2a118d7075d0f", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n+#![allow(clippy::ref_option_ref)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     string.map_or((false, \"hello\"), |x| (true, x))"}, {"sha": "e2f8dec3b930c898bafc52bf82acbf6852c48d7c", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n+#![allow(clippy::ref_option_ref)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     if let Some(x) = string {"}, {"sha": "7aab068800a029079e17fe4522474ef04e3bd264", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:6:5\n+  --> $DIR/option_if_let_else.rs:7:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:16:12\n+  --> $DIR/option_if_let_else.rs:17:12\n    |\n LL |       } else if let Some(x) = string {\n    |  ____________^\n@@ -22,19 +22,19 @@ LL | |     }\n    | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:24:13\n+  --> $DIR/option_if_let_else.rs:25:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:27:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -54,13 +54,13 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:32:13\n+  --> $DIR/option_if_let_else.rs:33:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:34:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -80,7 +80,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:39:13\n+  --> $DIR/option_if_let_else.rs:40:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -100,7 +100,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:48:5\n+  --> $DIR/option_if_let_else.rs:49:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -119,7 +119,7 @@ LL |     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:61:13\n+  --> $DIR/option_if_let_else.rs:62:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -131,7 +131,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:70:13\n+  --> $DIR/option_if_let_else.rs:71:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -154,7 +154,7 @@ LL |     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:99:13\n+  --> $DIR/option_if_let_else.rs:100:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`"}, {"sha": "1cba29412b872b927a359b74ab397d5b1b2798a9", "filename": "src/tools/clippy/tests/ui/option_map_or_none.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_map_or_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_map_or_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_map_or_none.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,12 +1,12 @@\n-error: called `map_or(None, f)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n   --> $DIR/option_map_or_none.rs:10:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n-error: called `map_or(None, f)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n   --> $DIR/option_map_or_none.rs:13:13\n    |\n LL |       let _ = opt.map_or(None, |x| {"}, {"sha": "b2c275d68afa16169ad78ac3b64562d766a88ca7", "filename": "src/tools/clippy/tests/ui/ref_option_ref.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,47 @@\n+#![allow(unused)]\n+#![warn(clippy::ref_option_ref)]\n+\n+// This lint is not tagged as run-rustfix because automatically\n+// changing the type of a variable would also means changing\n+// all usages of this variable to match and This is not handled\n+// by this lint.\n+\n+static THRESHOLD: i32 = 10;\n+static REF_THRESHOLD: &Option<&i32> = &Some(&THRESHOLD);\n+const CONST_THRESHOLD: &i32 = &10;\n+const REF_CONST: &Option<&i32> = &Some(&CONST_THRESHOLD);\n+\n+type RefOptRefU32<'a> = &'a Option<&'a u32>;\n+type RefOptRef<'a, T> = &'a Option<&'a T>;\n+\n+fn foo(data: &Option<&u32>) {}\n+\n+fn bar(data: &u32) -> &Option<&u32> {\n+    &None\n+}\n+\n+struct StructRef<'a> {\n+    data: &'a Option<&'a u32>,\n+}\n+\n+struct StructTupleRef<'a>(u32, &'a Option<&'a u32>);\n+\n+enum EnumRef<'a> {\n+    Variant1(u32),\n+    Variant2(&'a Option<&'a u32>),\n+}\n+\n+trait RefOptTrait {\n+    type A;\n+    fn foo(&self, _: Self::A);\n+}\n+\n+impl RefOptTrait for u32 {\n+    type A = &'static Option<&'static Self>;\n+\n+    fn foo(&self, _: Self::A) {}\n+}\n+\n+fn main() {\n+    let x: &Option<&u32> = &None;\n+}"}, {"sha": "4e7fc800061185a3d593562168986905e53e4f52", "filename": "src/tools/clippy/tests/ui/ref_option_ref.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_option_ref.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,70 @@\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:10:23\n+   |\n+LL | static REF_THRESHOLD: &Option<&i32> = &Some(&THRESHOLD);\n+   |                       ^^^^^^^^^^^^^ help: try: `Option<&i32>`\n+   |\n+   = note: `-D clippy::ref-option-ref` implied by `-D warnings`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:12:18\n+   |\n+LL | const REF_CONST: &Option<&i32> = &Some(&CONST_THRESHOLD);\n+   |                  ^^^^^^^^^^^^^ help: try: `Option<&i32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:14:25\n+   |\n+LL | type RefOptRefU32<'a> = &'a Option<&'a u32>;\n+   |                         ^^^^^^^^^^^^^^^^^^^ help: try: `Option<&'a u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:15:25\n+   |\n+LL | type RefOptRef<'a, T> = &'a Option<&'a T>;\n+   |                         ^^^^^^^^^^^^^^^^^ help: try: `Option<&'a T>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:17:14\n+   |\n+LL | fn foo(data: &Option<&u32>) {}\n+   |              ^^^^^^^^^^^^^ help: try: `Option<&u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:19:23\n+   |\n+LL | fn bar(data: &u32) -> &Option<&u32> {\n+   |                       ^^^^^^^^^^^^^ help: try: `Option<&u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:24:11\n+   |\n+LL |     data: &'a Option<&'a u32>,\n+   |           ^^^^^^^^^^^^^^^^^^^ help: try: `Option<&'a u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:27:32\n+   |\n+LL | struct StructTupleRef<'a>(u32, &'a Option<&'a u32>);\n+   |                                ^^^^^^^^^^^^^^^^^^^ help: try: `Option<&'a u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:31:14\n+   |\n+LL |     Variant2(&'a Option<&'a u32>),\n+   |              ^^^^^^^^^^^^^^^^^^^ help: try: `Option<&'a u32>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:40:14\n+   |\n+LL |     type A = &'static Option<&'static Self>;\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Option<&'static Self>`\n+\n+error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n+  --> $DIR/ref_option_ref.rs:46:12\n+   |\n+LL |     let x: &Option<&u32> = &None;\n+   |            ^^^^^^^^^^^^^ help: try: `Option<&u32>`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "63a6d37a9cce9ddbc5346920fa865405c6219be3", "filename": "src/tools/clippy/tests/ui/single_char_add_str.fixed", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,45 @@\n+// run-rustfix\n+#![warn(clippy::single_char_add_str)]\n+\n+macro_rules! get_string {\n+    () => {\n+        String::from(\"Hello world!\")\n+    };\n+}\n+\n+fn main() {\n+    // `push_str` tests\n+\n+    let mut string = String::new();\n+    string.push('R');\n+    string.push('\\'');\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push('\\x52');\n+    string.push('\\u{0052}');\n+    string.push('a');\n+\n+    get_string!().push('\u00f6');\n+\n+    // `insert_str` tests\n+\n+    let mut string = String::new();\n+    string.insert(0, 'R');\n+    string.insert(1, '\\'');\n+\n+    string.insert(0, 'u');\n+    string.insert_str(2, \"st\");\n+    string.insert_str(0, \"\");\n+    string.insert(0, '\\x52');\n+    string.insert(0, '\\u{0052}');\n+    let x: usize = 2;\n+    string.insert(x, 'a');\n+    const Y: usize = 1;\n+    string.insert(Y, 'a');\n+    string.insert(Y, '\"');\n+    string.insert(Y, '\\'');\n+\n+    get_string!().insert(1, '?');\n+}"}, {"sha": "a799ea7d88564a188c3b4da1e2c14efeb8ff2fcf", "filename": "src/tools/clippy/tests/ui/single_char_add_str.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,45 @@\n+// run-rustfix\n+#![warn(clippy::single_char_add_str)]\n+\n+macro_rules! get_string {\n+    () => {\n+        String::from(\"Hello world!\")\n+    };\n+}\n+\n+fn main() {\n+    // `push_str` tests\n+\n+    let mut string = String::new();\n+    string.push_str(\"R\");\n+    string.push_str(\"'\");\n+\n+    string.push('u');\n+    string.push_str(\"st\");\n+    string.push_str(\"\");\n+    string.push_str(\"\\x52\");\n+    string.push_str(\"\\u{0052}\");\n+    string.push_str(r##\"a\"##);\n+\n+    get_string!().push_str(\"\u00f6\");\n+\n+    // `insert_str` tests\n+\n+    let mut string = String::new();\n+    string.insert_str(0, \"R\");\n+    string.insert_str(1, \"'\");\n+\n+    string.insert(0, 'u');\n+    string.insert_str(2, \"st\");\n+    string.insert_str(0, \"\");\n+    string.insert_str(0, \"\\x52\");\n+    string.insert_str(0, \"\\u{0052}\");\n+    let x: usize = 2;\n+    string.insert_str(x, r##\"a\"##);\n+    const Y: usize = 1;\n+    string.insert_str(Y, r##\"a\"##);\n+    string.insert_str(Y, r##\"\"\"##);\n+    string.insert_str(Y, r##\"'\"##);\n+\n+    get_string!().insert_str(1, \"?\");\n+}"}, {"sha": "55d91583ad04d30d6deb01c4d5baeafc1746e292", "filename": "src/tools/clippy/tests/ui/single_char_add_str.stderr", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_add_str.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -0,0 +1,94 @@\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:14:5\n+   |\n+LL |     string.push_str(\"R\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('R')`\n+   |\n+   = note: `-D clippy::single-char-add-str` implied by `-D warnings`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:15:5\n+   |\n+LL |     string.push_str(\"'\");\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/'')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:20:5\n+   |\n+LL |     string.push_str(\"/x52\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/x52')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:21:5\n+   |\n+LL |     string.push_str(\"/u{0052}\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/u{0052}')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:22:5\n+   |\n+LL |     string.push_str(r##\"a\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('a')`\n+\n+error: calling `push_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:24:5\n+   |\n+LL |     get_string!().push_str(\"\u00f6\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `get_string!().push('\u00f6')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:29:5\n+   |\n+LL |     string.insert_str(0, \"R\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(0, 'R')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:30:5\n+   |\n+LL |     string.insert_str(1, \"'\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(1, '/'')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:35:5\n+   |\n+LL |     string.insert_str(0, \"/x52\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(0, '/x52')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:36:5\n+   |\n+LL |     string.insert_str(0, \"/u{0052}\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(0, '/u{0052}')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:38:5\n+   |\n+LL |     string.insert_str(x, r##\"a\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(x, 'a')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:40:5\n+   |\n+LL |     string.insert_str(Y, r##\"a\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(Y, 'a')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:41:5\n+   |\n+LL |     string.insert_str(Y, r##\"\"\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(Y, '\"')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:42:5\n+   |\n+LL |     string.insert_str(Y, r##\"'\"##);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `string.insert(Y, '/'')`\n+\n+error: calling `insert_str()` using a single-character string literal\n+  --> $DIR/single_char_add_str.rs:44:5\n+   |\n+LL |     get_string!().insert_str(1, \"?\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `insert` with a character literal: `get_string!().insert(1, '?')`\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "d8b5f19e144dcfd0567610bc8ef6302109125eb3", "filename": "src/tools/clippy/tests/ui/single_char_pattern.fixed", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -12,15 +12,9 @@ fn main() {\n \n     let y = \"x\";\n     x.split(y);\n-    // Not yet testing for multi-byte characters\n-    // Changing `r.len() == 1` to `r.chars().count() == 1` in `lint_clippy::single_char_pattern`\n-    // should have done this but produced an ICE\n-    //\n-    // We may not want to suggest changing these anyway\n-    // See: https://github.com/rust-lang/rust-clippy/issues/650#issuecomment-184328984\n-    x.split(\"\u00df\");\n-    x.split(\"\u211d\");\n-    x.split(\"\ud83d\udca3\");\n+    x.split('\u00df');\n+    x.split('\u211d');\n+    x.split('\ud83d\udca3');\n     // Can't use this lint for unicode code points which don't fit in a char\n     x.split(\"\u2764\ufe0f\");\n     x.contains('x');"}, {"sha": "a7bc73e3756dfb13e30925159b237321d296a62c", "filename": "src/tools/clippy/tests/ui/single_char_pattern.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -12,12 +12,6 @@ fn main() {\n \n     let y = \"x\";\n     x.split(y);\n-    // Not yet testing for multi-byte characters\n-    // Changing `r.len() == 1` to `r.chars().count() == 1` in `lint_clippy::single_char_pattern`\n-    // should have done this but produced an ICE\n-    //\n-    // We may not want to suggest changing these anyway\n-    // See: https://github.com/rust-lang/rust-clippy/issues/650#issuecomment-184328984\n     x.split(\"\u00df\");\n     x.split(\"\u211d\");\n     x.split(\"\ud83d\udca3\");"}, {"sha": "ee4e7e50efd17371a24a1eb904a8db47e4b12a27", "filename": "src/tools/clippy/tests/ui/single_char_pattern.stderr", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_pattern.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -7,160 +7,178 @@ LL |     x.split(\"x\");\n    = note: `-D clippy::single-char-pattern` implied by `-D warnings`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:26:16\n+  --> $DIR/single_char_pattern.rs:15:13\n+   |\n+LL |     x.split(\"\u00df\");\n+   |             ^^^ help: try using a `char` instead: `'\u00df'`\n+\n+error: single-character string constant used as pattern\n+  --> $DIR/single_char_pattern.rs:16:13\n+   |\n+LL |     x.split(\"\u211d\");\n+   |             ^^^ help: try using a `char` instead: `'\u211d'`\n+\n+error: single-character string constant used as pattern\n+  --> $DIR/single_char_pattern.rs:17:13\n+   |\n+LL |     x.split(\"\ud83d\udca3\");\n+   |             ^^^^ help: try using a `char` instead: `'\ud83d\udca3'`\n+\n+error: single-character string constant used as pattern\n+  --> $DIR/single_char_pattern.rs:20:16\n    |\n LL |     x.contains(\"x\");\n    |                ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:27:19\n+  --> $DIR/single_char_pattern.rs:21:19\n    |\n LL |     x.starts_with(\"x\");\n    |                   ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:28:17\n+  --> $DIR/single_char_pattern.rs:22:17\n    |\n LL |     x.ends_with(\"x\");\n    |                 ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:29:12\n+  --> $DIR/single_char_pattern.rs:23:12\n    |\n LL |     x.find(\"x\");\n    |            ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:30:13\n+  --> $DIR/single_char_pattern.rs:24:13\n    |\n LL |     x.rfind(\"x\");\n    |             ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:31:14\n+  --> $DIR/single_char_pattern.rs:25:14\n    |\n LL |     x.rsplit(\"x\");\n    |              ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:32:24\n+  --> $DIR/single_char_pattern.rs:26:24\n    |\n LL |     x.split_terminator(\"x\");\n    |                        ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:33:25\n+  --> $DIR/single_char_pattern.rs:27:25\n    |\n LL |     x.rsplit_terminator(\"x\");\n    |                         ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:34:17\n+  --> $DIR/single_char_pattern.rs:28:17\n    |\n LL |     x.splitn(0, \"x\");\n    |                 ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:35:18\n+  --> $DIR/single_char_pattern.rs:29:18\n    |\n LL |     x.rsplitn(0, \"x\");\n    |                  ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:36:15\n+  --> $DIR/single_char_pattern.rs:30:15\n    |\n LL |     x.matches(\"x\");\n    |               ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:37:16\n+  --> $DIR/single_char_pattern.rs:31:16\n    |\n LL |     x.rmatches(\"x\");\n    |                ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:38:21\n+  --> $DIR/single_char_pattern.rs:32:21\n    |\n LL |     x.match_indices(\"x\");\n    |                     ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:39:22\n+  --> $DIR/single_char_pattern.rs:33:22\n    |\n LL |     x.rmatch_indices(\"x\");\n    |                      ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:40:26\n+  --> $DIR/single_char_pattern.rs:34:26\n    |\n LL |     x.trim_start_matches(\"x\");\n    |                          ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:41:24\n+  --> $DIR/single_char_pattern.rs:35:24\n    |\n LL |     x.trim_end_matches(\"x\");\n    |                        ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:43:13\n+  --> $DIR/single_char_pattern.rs:37:13\n    |\n LL |     x.split(\"/n\");\n    |             ^^^^ help: try using a `char` instead: `'/n'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:44:13\n+  --> $DIR/single_char_pattern.rs:38:13\n    |\n LL |     x.split(\"'\");\n    |             ^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:45:13\n+  --> $DIR/single_char_pattern.rs:39:13\n    |\n LL |     x.split(\"/'\");\n    |             ^^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:50:31\n+  --> $DIR/single_char_pattern.rs:44:31\n    |\n LL |     x.replace(\";\", \",\").split(\",\"); // issue #2978\n    |                               ^^^ help: try using a `char` instead: `','`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:51:19\n+  --> $DIR/single_char_pattern.rs:45:19\n    |\n LL |     x.starts_with(\"/x03\"); // issue #2996\n    |                   ^^^^^^ help: try using a `char` instead: `'/x03'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:58:13\n+  --> $DIR/single_char_pattern.rs:52:13\n    |\n LL |     x.split(r\"a\");\n    |             ^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:59:13\n+  --> $DIR/single_char_pattern.rs:53:13\n    |\n LL |     x.split(r#\"a\"#);\n    |             ^^^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:60:13\n+  --> $DIR/single_char_pattern.rs:54:13\n    |\n LL |     x.split(r###\"a\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:61:13\n+  --> $DIR/single_char_pattern.rs:55:13\n    |\n LL |     x.split(r###\"'\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:62:13\n+  --> $DIR/single_char_pattern.rs:56:13\n    |\n LL |     x.split(r###\"#\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'#'`\n \n-error: aborting due to 27 previous errors\n+error: aborting due to 30 previous errors\n "}, {"sha": "0812c026a644fbdd84f05569edc5cf954a8a109f", "filename": "src/tools/clippy/tests/ui/single_char_push_str.fixed", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.fixed?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-#![warn(clippy::single_char_push_str)]\n-\n-fn main() {\n-    let mut string = String::new();\n-    string.push('R');\n-    string.push('\\'');\n-\n-    string.push('u');\n-    string.push_str(\"st\");\n-    string.push_str(\"\");\n-    string.push('\\x52');\n-    string.push('\\u{0052}');\n-    string.push('a');\n-}"}, {"sha": "ab293bbe4eeb5ce8171ec28f610410a45f2d5cb8", "filename": "src/tools/clippy/tests/ui/single_char_push_str.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-#![warn(clippy::single_char_push_str)]\n-\n-fn main() {\n-    let mut string = String::new();\n-    string.push_str(\"R\");\n-    string.push_str(\"'\");\n-\n-    string.push('u');\n-    string.push_str(\"st\");\n-    string.push_str(\"\");\n-    string.push_str(\"\\x52\");\n-    string.push_str(\"\\u{0052}\");\n-    string.push_str(r##\"a\"##);\n-}"}, {"sha": "0e9bdaa23e7e8474accd8321884cc0861db8405c", "filename": "src/tools/clippy/tests/ui/single_char_push_str.stderr", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_push_str.stderr?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,34 +0,0 @@\n-error: calling `push_str()` using a single-character string literal\n-  --> $DIR/single_char_push_str.rs:6:5\n-   |\n-LL |     string.push_str(\"R\");\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('R')`\n-   |\n-   = note: `-D clippy::single-char-push-str` implied by `-D warnings`\n-\n-error: calling `push_str()` using a single-character string literal\n-  --> $DIR/single_char_push_str.rs:7:5\n-   |\n-LL |     string.push_str(\"'\");\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/'')`\n-\n-error: calling `push_str()` using a single-character string literal\n-  --> $DIR/single_char_push_str.rs:12:5\n-   |\n-LL |     string.push_str(\"/x52\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/x52')`\n-\n-error: calling `push_str()` using a single-character string literal\n-  --> $DIR/single_char_push_str.rs:13:5\n-   |\n-LL |     string.push_str(\"/u{0052}\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('/u{0052}')`\n-\n-error: calling `push_str()` using a single-character string literal\n-  --> $DIR/single_char_push_str.rs:14:5\n-   |\n-LL |     string.push_str(r##\"a\"##);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `push` with a character literal: `string.push('a')`\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "269cc13468bc83a3ba58d280b5e1c62373f30c42", "filename": "src/tools/clippy/tests/ui/skip_while_next.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fskip_while_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fskip_while_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fskip_while_next.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,13 +1,13 @@\n-error: called `skip_while(p).next()` on an `Iterator`\n+error: called `skip_while(<p>).next()` on an `Iterator`\n   --> $DIR/skip_while_next.rs:14:13\n    |\n LL |     let _ = v.iter().skip_while(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::skip-while-next` implied by `-D warnings`\n-   = help: this is more succinctly expressed by calling `.find(!p)` instead\n+   = help: this is more succinctly expressed by calling `.find(!<p>)` instead\n \n-error: called `skip_while(p).next()` on an `Iterator`\n+error: called `skip_while(<p>).next()` on an `Iterator`\n   --> $DIR/skip_while_next.rs:17:13\n    |\n LL |       let _ = v.iter().skip_while(|&x| {\n@@ -17,7 +17,7 @@ LL | |                             }\n LL | |                    ).next();\n    | |___________________________^\n    |\n-   = help: this is more succinctly expressed by calling `.find(!p)` instead\n+   = help: this is more succinctly expressed by calling `.find(!<p>)` instead\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b129d95c5602fd4d62e626d8f3c50517ea85d3f3", "filename": "src/tools/clippy/tests/ui/toplevel_ref_arg.fixed", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,7 +1,17 @@\n // run-rustfix\n+// aux-build:macro_rules.rs\n \n #![warn(clippy::toplevel_ref_arg)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! gen_binding {\n+    () => {\n+        let _y = &42;\n+    };\n+}\n+\n fn main() {\n     // Closures should not warn\n     let y = |ref x| println!(\"{:?}\", x);\n@@ -26,4 +36,15 @@ fn main() {\n \n     // ok\n     for ref _x in 0..10 {}\n+\n+    // lint in macro\n+    #[allow(unused)]\n+    {\n+        gen_binding!();\n+    }\n+\n+    // do not lint in external macro\n+    {\n+        ref_arg_binding!();\n+    }\n }"}, {"sha": "73eb4ff7306f715832668d8fb6b0e05dbd169309", "filename": "src/tools/clippy/tests/ui/toplevel_ref_arg.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,7 +1,17 @@\n // run-rustfix\n+// aux-build:macro_rules.rs\n \n #![warn(clippy::toplevel_ref_arg)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! gen_binding {\n+    () => {\n+        let ref _y = 42;\n+    };\n+}\n+\n fn main() {\n     // Closures should not warn\n     let y = |ref x| println!(\"{:?}\", x);\n@@ -26,4 +36,15 @@ fn main() {\n \n     // ok\n     for ref _x in 0..10 {}\n+\n+    // lint in macro\n+    #[allow(unused)]\n+    {\n+        gen_binding!();\n+    }\n+\n+    // do not lint in external macro\n+    {\n+        ref_arg_binding!();\n+    }\n }"}, {"sha": "15cb933fedc9e78f34b2511d5d8650c3934bed93", "filename": "src/tools/clippy/tests/ui/toplevel_ref_arg.stderr", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,34 +1,45 @@\n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:10:9\n+  --> $DIR/toplevel_ref_arg.rs:20:9\n    |\n LL |     let ref _x = 1;\n    |     ----^^^^^^----- help: try: `let _x = &1;`\n    |\n    = note: `-D clippy::toplevel-ref-arg` implied by `-D warnings`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:12:9\n+  --> $DIR/toplevel_ref_arg.rs:22:9\n    |\n LL |     let ref _y: (&_, u8) = (&1, 2);\n    |     ----^^^^^^--------------------- help: try: `let _y: &(&_, u8) = &(&1, 2);`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:14:9\n+  --> $DIR/toplevel_ref_arg.rs:24:9\n    |\n LL |     let ref _z = 1 + 2;\n    |     ----^^^^^^--------- help: try: `let _z = &(1 + 2);`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:16:9\n+  --> $DIR/toplevel_ref_arg.rs:26:9\n    |\n LL |     let ref mut _z = 1 + 2;\n    |     ----^^^^^^^^^^--------- help: try: `let _z = &mut (1 + 2);`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:21:9\n+  --> $DIR/toplevel_ref_arg.rs:31:9\n    |\n LL |     let ref _x = vec![1, 2, 3];\n    |     ----^^^^^^----------------- help: try: `let _x = &vec![1, 2, 3];`\n \n-error: aborting due to 5 previous errors\n+error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n+  --> $DIR/toplevel_ref_arg.rs:11:13\n+   |\n+LL |         let ref _y = 42;\n+   |         ----^^^^^^------ help: try: `let _y = &42;`\n+...\n+LL |         gen_binding!();\n+   |         --------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "1a493fbce0ef31d8f16b481dd29c441e2d67e05c", "filename": "src/tools/clippy/tests/ui/toplevel_ref_arg_non_rustfix.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,11 +1,33 @@\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::toplevel_ref_arg)]\n #![allow(unused)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n fn the_answer(ref mut x: u8) {\n     *x = 42;\n }\n \n+macro_rules! gen_function {\n+    () => {\n+        fn fun_example(ref _x: usize) {}\n+    };\n+}\n+\n fn main() {\n     let mut x = 0;\n     the_answer(x);\n+\n+    // lint in macro\n+    #[allow(unused)]\n+    {\n+        gen_function!();\n+    }\n+\n+    // do not lint in external macro\n+    {\n+        ref_arg_function!();\n+    }\n }"}, {"sha": "6c36141a58c6557ad5db5788556876b512e68340", "filename": "src/tools/clippy/tests/ui/toplevel_ref_arg_non_rustfix.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,10 +1,21 @@\n error: `ref` directly on a function argument is ignored. Consider using a reference type instead.\n-  --> $DIR/toplevel_ref_arg_non_rustfix.rs:4:15\n+  --> $DIR/toplevel_ref_arg_non_rustfix.rs:9:15\n    |\n LL | fn the_answer(ref mut x: u8) {\n    |               ^^^^^^^^^\n    |\n    = note: `-D clippy::toplevel-ref-arg` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: `ref` directly on a function argument is ignored. Consider using a reference type instead.\n+  --> $DIR/toplevel_ref_arg_non_rustfix.rs:15:24\n+   |\n+LL |         fn fun_example(ref _x: usize) {}\n+   |                        ^^^^^^\n+...\n+LL |         gen_function!();\n+   |         ---------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "7afc5361356333235224a79b64710f13cd76e5cd", "filename": "src/tools/clippy/tests/ui/unused_unit.fixed", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.fixed?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -15,35 +15,35 @@\n struct Unitter;\n impl Unitter {\n     #[allow(clippy::no_effect)]\n-    pub fn get_unit<F: Fn() , G>(&self, f: F, _g: G) \n-    where G: Fn()  {\n-        let _y: &dyn Fn()  = &f;\n+    pub fn get_unit<F: Fn(), G>(&self, f: F, _g: G)\n+    where G: Fn() {\n+        let _y: &dyn Fn() = &f;\n         (); // this should not lint, as it's not in return type position\n     }\n }\n \n impl Into<()> for Unitter {\n     #[rustfmt::skip]\n-    fn into(self)  {\n+    fn into(self) {\n         \n     }\n }\n \n trait Trait {\n-    fn redundant<F: FnOnce() , G, H>(&self, _f: F, _g: G, _h: H)\n+    fn redundant<F: FnOnce(), G, H>(&self, _f: F, _g: G, _h: H)\n     where\n-        G: FnMut() ,\n-        H: Fn() ;\n+        G: FnMut(),\n+        H: Fn();\n }\n \n impl Trait for Unitter {\n-    fn redundant<F: FnOnce() , G, H>(&self, _f: F, _g: G, _h: H)\n+    fn redundant<F: FnOnce(), G, H>(&self, _f: F, _g: G, _h: H)\n     where\n-        G: FnMut() ,\n-        H: Fn()  {}\n+        G: FnMut(),\n+        H: Fn() {}\n }\n \n-fn return_unit()  {  }\n+fn return_unit() {  }\n \n #[allow(clippy::needless_return)]\n #[allow(clippy::never_loop)]\n@@ -70,3 +70,12 @@ fn foo() {\n         recv(rx) -> _x => ()\n     }\n }\n+\n+#[rustfmt::skip]\n+fn test(){}\n+\n+#[rustfmt::skip]\n+fn test2(){}\n+\n+#[rustfmt::skip]\n+fn test3(){}"}, {"sha": "96cef1ed5a5f213dddad7bb987fa034b39ec3f6b", "filename": "src/tools/clippy/tests/ui/unused_unit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.rs?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -70,3 +70,12 @@ fn foo() {\n         recv(rx) -> _x => ()\n     }\n }\n+\n+#[rustfmt::skip]\n+fn test()->(){}\n+\n+#[rustfmt::skip]\n+fn test2() ->(){}\n+\n+#[rustfmt::skip]\n+fn test3()-> (){}"}, {"sha": "c45634c2b6df71a5131c4c7f8689e5a0edbf7607", "filename": "src/tools/clippy/tests/ui/unused_unit.stderr", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46c714f64134ef403272d98667d5b8c38d8ff37b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr?ref=46c714f64134ef403272d98667d5b8c38d8ff37b", "patch": "@@ -1,8 +1,8 @@\n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:18:29\n+  --> $DIR/unused_unit.rs:18:28\n    |\n LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                             ^^^^^ help: remove the `-> ()`\n+   |                            ^^^^^^ help: remove the `-> ()`\n    |\n note: the lint level is defined here\n   --> $DIR/unused_unit.rs:12:9\n@@ -11,28 +11,28 @@ LL | #![deny(clippy::unused_unit)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:19\n+  --> $DIR/unused_unit.rs:19:18\n    |\n LL |     where G: Fn() -> () {\n-   |                   ^^^^^ help: remove the `-> ()`\n+   |                  ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:18:59\n+  --> $DIR/unused_unit.rs:18:58\n    |\n LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                                                           ^^^^^ help: remove the `-> ()`\n+   |                                                          ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:20:27\n+  --> $DIR/unused_unit.rs:20:26\n    |\n LL |         let _y: &dyn Fn() -> () = &f;\n-   |                           ^^^^^ help: remove the `-> ()`\n+   |                          ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:27:19\n+  --> $DIR/unused_unit.rs:27:18\n    |\n LL |     fn into(self) -> () {\n-   |                   ^^^^^ help: remove the `-> ()`\n+   |                  ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit expression\n   --> $DIR/unused_unit.rs:28:9\n@@ -41,46 +41,46 @@ LL |         ()\n    |         ^^ help: remove the final `()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:33:30\n+  --> $DIR/unused_unit.rs:33:29\n    |\n LL |     fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n-   |                              ^^^^^ help: remove the `-> ()`\n+   |                             ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:35:20\n+  --> $DIR/unused_unit.rs:35:19\n    |\n LL |         G: FnMut() -> (),\n-   |                    ^^^^^ help: remove the `-> ()`\n+   |                   ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:36:17\n+  --> $DIR/unused_unit.rs:36:16\n    |\n LL |         H: Fn() -> ();\n-   |                 ^^^^^ help: remove the `-> ()`\n+   |                ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:40:30\n+  --> $DIR/unused_unit.rs:40:29\n    |\n LL |     fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n-   |                              ^^^^^ help: remove the `-> ()`\n+   |                             ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:42:20\n+  --> $DIR/unused_unit.rs:42:19\n    |\n LL |         G: FnMut() -> (),\n-   |                    ^^^^^ help: remove the `-> ()`\n+   |                   ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:43:17\n+  --> $DIR/unused_unit.rs:43:16\n    |\n LL |         H: Fn() -> () {}\n-   |                 ^^^^^ help: remove the `-> ()`\n+   |                ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:46:18\n+  --> $DIR/unused_unit.rs:46:17\n    |\n LL | fn return_unit() -> () { () }\n-   |                  ^^^^^ help: remove the `-> ()`\n+   |                 ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit expression\n   --> $DIR/unused_unit.rs:46:26\n@@ -100,5 +100,23 @@ error: unneeded `()`\n LL |     return();\n    |           ^^ help: remove the `()`\n \n-error: aborting due to 16 previous errors\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:75:10\n+   |\n+LL | fn test()->(){}\n+   |          ^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:78:11\n+   |\n+LL | fn test2() ->(){}\n+   |           ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:81:11\n+   |\n+LL | fn test3()-> (){}\n+   |           ^^^^^ help: remove the `-> ()`\n+\n+error: aborting due to 19 previous errors\n "}]}